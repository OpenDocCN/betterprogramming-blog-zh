<html>
<head>
<title>A Deep Dive Into Tuples in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究C#中的元组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-tuples-in-c-be0432d92922?source=collection_archive---------11-----------------------#2022-09-06">https://betterprogramming.pub/a-deep-dive-into-tuples-in-c-be0432d92922?source=collection_archive---------11-----------------------#2022-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcdd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索这些容器的多功能性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d15418db68fd93cc0aca696100bcd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8ZvUnkNvmyNI08LH7O5JQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/es/@curology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Curology </a>在<a class="ae ky" href="https://unsplash.com/s/photos/box?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片|图像高度改变</p></figure><p id="8e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组很棒。</p><p id="974a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我清楚地记得元组出现之前的日子——很难找出从一个方法返回多个值的最佳方式。一旦元组被添加到C#中，我就可以看到它们会有很多用处。</p><p id="b3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，随着它们在C#后续版本上的开发，它们已经得到了改进。如果你从元组的早期就没有接触过它们，那么你现在认不出它们是可以原谅的。他们完全变了，但都很好。</p><p id="de60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看元组是从哪里开始的，然后看看我们今天如何使用它们。</p><h1 id="2763" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">C#4中引入的元组</h1><p id="5e6f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">早在2010年，我们就有了新版本的。这是元组的第一次出现。</p><p id="0746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新概念(对C#来说是新的)的目的是使处理少量的值变得更容易。在元组出现之前，我们要么创建一个自定义的类/结构来存储值，要么使用一堆<code class="fe ms mt mu mv b">ref</code>参数——这两者都不理想。</p><p id="4a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们得到了一个新的类，毫不奇怪地叫做<code class="fe ms mt mu mv b">Tuple</code>，我们可以用它在一个结构中保存多个数据元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？</p><p id="6e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用泛型定义元组来指定它将包含的数据类型，然后创建一个可以作为单个结构传递的元组。</p><p id="6345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以从这个元组中获取值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，但是如果你和我一样，那些<code class="fe ms mt mu mv b">Item1</code>和<code class="fe ms mt mu mv b">Item2</code>属性就有点没意义了。就其本身而言，你无法判断这种价值代表了什么。</p><p id="4a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，最初的问题已经解决了，但是还有改进的空间。</p><h1 id="951d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">C# 7中的超负荷元组</h1><p id="4c0d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">时间快进到2017年，我们发布了C# 7。人们对元组给予了很多关注。</p><p id="8530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不再需要使用<code class="fe ms mt mu mv b">Tuple</code>类本身，但是我们可以在语言本身中使用特殊的构造来表示我们的意思。</p><h1 id="3c52" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义新的元组</h1><p id="99f5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们有了一个更快的创建元组的方法。不用实例化<code class="fe ms mt mu mv b">Tuple</code>类，我们可以简单地将元素放在括号中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c1e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常整洁，但是当我们尝试从元组中获取数据时，什么都没有改变——它仍然使用<code class="fe ms mt mu mv b">Item1</code>和<code class="fe ms mt mu mv b">Item2</code>。</p><h2 id="d927" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated">命名元组中的元素</h2><p id="addb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">但是，在您给这些元素命名之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法签名中，我们可以向元组的定义中添加名称。创建这样一个返回的元组的方式没有什么变化，但是看看当您尝试从这个结构中获取数据时，IntelliSense显示了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bc2978510823bbb3122f8f22666eef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*axSsbxKhtogq5SGObfnE4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元组的自动完成将命名元素显示为属性</p></figure><p id="afd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，在Visual Studio 2022(以及更早的版本)中，这些元素名称被列为属性，你可以像使用类的属性一样使用它们。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以清楚地看到元组中每个元素的含义。当你得到一个有一大堆<code class="fe ms mt mu mv b">int</code>元素的元组时，当你不需要记住应该使用<code class="fe ms mt mu mv b">Item5</code>还是<code class="fe ms mt mu mv b">Item6</code>时，你会感谢我的。</p><p id="9a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以在创建tuple时命名元素，如果是内联创建tuple，而不是从方法返回它，这将非常有用。这是一行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="722f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对元组使用Var</h1><p id="d2b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如你在上面看到的，我们使用<code class="fe ms mt mu mv b">var</code>作为局部变量类型。这很方便，正如我之前所写的，<a class="ae ky" href="https://jamie-burns.medium.com/using-var-in-c-a-pragmatic-approach-1f1b17078988" rel="noopener"> var真的很有用</a>。</p><p id="1347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你只使用<code class="fe ms mt mu mv b">var</code>，你就错过了元组的另一个技巧。让我们看看Visual Studio建议对此变量进行什么样的重构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4225942cda501b0e5feb5a2ed1444d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*YH7FSpDBjbmOq0N5_3ZMjg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“var”元组的重构选项</p></figure><p id="3b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个选择:</p><ul class=""><li id="447b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">使用显式类型而不是“var”</li><li id="9453" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">解构变量声明</li></ul><p id="3f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们依次来看这些。</p><h2 id="c51a" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated">将元组定义为显式类型，而不是var</h2><p id="54ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们想使用显式类型而不是<code class="fe ms mt mu mv b">var</code>，我们使用我们在方法签名中使用的相同构造:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它让这个元组包含了什么变得非常清楚。</p><p id="5450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们还可以更进一步，将元组提升到下一个层次。</p><h2 id="4008" class="my lw it bd lx mz na dn mb nb nc dp mf li nd ne mh lm nf ng mj lq nh ni ml nj bi translated">解构元组变量声明</h2><p id="ae1a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们从类似方法的东西中返回一个元组时，我们只对元组中的内容感兴趣(而不是元组本身)，那么我们可以将声明解构为数据元素，并将它们直接用作变量。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这可能看起来有点奇怪，但是能够像这样从元组中直接定义变量确实很方便。您的代码的其余部分并不关心它们来自元组，您也不需要自己定义和实例化其他局部变量。</p><p id="9a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，对吧？</p><h1 id="888d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">忽略元组中的一些元素</h1><p id="f377" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">但是，如果您对tuple返回的一些元素不感兴趣，会发生什么呢？你一定要有这些你忽略的额外变量吗？</p><p id="a756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要！</p><p id="41e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards" rel="noopener ugc nofollow" target="_blank">丢弃</a>任何你不想要的东西。这段代码很简单，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们如何不用定义<code class="fe ms mt mu mv b">int totalItems</code>，而是使用下划线。这样做是告诉编译器你不会用到那个元素，所以它不会把你的代码弄乱。</p><h1 id="66f9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你能在元组中存储什么？</h1><p id="cb3d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可以在一个元组中存储几乎任何东西。如果你真的想的话，你甚至可以创建一个函数元组。这里有一个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="b5e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一个元组可以容纳多少个元素？</h1><p id="b8ce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您使用的是老式的<code class="fe ms mt mu mv b">Tuple</code>类，那么在一个元组中只能有八个元素。如果需要更多，最后一个元素可以是一个tuple，其思想是将tuple对象嵌套在彼此内部，以存储您需要的所有内容。</p><p id="e123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用新的元组语法，就没有这样的限制了。只要你能写出来，元组就会存储。</p><p id="e585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，像这样创建的元组有一个可用的<code class="fe ms mt mu mv b">.ToTuple()</code>方法，将新型元组转换为<code class="fe ms mt mu mv b">Tuple</code>类类型。如果它太大，它使用嵌套元组来存储额外的元素。代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f2884ae03127dd0e969c73973d504514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dV5A-jHqIxSaC4-ScZhb4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ToTuple()方法使用<code class="fe ms mt mu mv b">Tuple</code>类创建一个元组，并嵌套额外的元素，使它们符合元组类的限制</p></figure><h1 id="1caa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">比较元组</h1><p id="29c6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">元组是值类型，这意味着您可以轻松地比较它们。然而，有几件事你需要知道，这样你才不会被他们抓住。</p><p id="4d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有两个包含相同值的元组，那么相等性检查显示它们是相等的。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的是C# 7.3或更高版本，您也可以使用<code class="fe ms mt mu mv b">==</code>来实现这个等式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ad6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意的第一件事是，比较是对值进行的，不考虑任何数据元素名称。因此，如果两个元组被赋予不同的名称，但仍然包含相同的值，它们仍然被视为相等。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="73ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点很重要，因为即使命名的元素匹配，用于比较的也是值的顺序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f13d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您设置一个单元测试来验证这一点，这是最容易看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="86c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行测试时，它失败了，我们得到这样的响应:</p><blockquote class="ob oc od"><p id="3fa9" class="kz la oe lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">断言。AreEqual失败。预期:。实际:。</p></blockquote><p id="cb2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可以看到，元素名称没有在那里列出，只是按照它们在元组中的设置顺序列出了值。</p><p id="a9ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进行元组相等时，需要注意更多的事情——最好的参考资料是关于元组相等的微软文档。</p><h1 id="4c82" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="b723" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">元组已经走过了漫长的道路。从<code class="fe ms mt mu mv b">Tuple</code>类开始，它部分解决了移动多个数据元素的问题，以元组的最新语法结束，允许您快速、轻松地创建数据结构来保存您需要的数据。</p><p id="59c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名tuple中的元素非常容易，这样您就总能知道数据与什么相关，并且从tuple中提取元素的语法非常简单，您可以在以后的代码中使用这些元素。</p><p id="1bf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以比较元组，但重要的是要记住元组中值的顺序用于比较，而不是命名元素。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="91ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oe">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>