# 一个提供查克·诺里斯笑话的简单的网络服务器

> 原文：<https://betterprogramming.pub/a-jokingly-simple-go-web-server-f03b6315a5fb>

## 查克·诺里斯不写代码——他盯着它直到它自己写出来

![](img/c5a49d9bd8a39f87a1407ce9040026bf.png)

Go 是一种优秀的后端语言，具有强大的包支持，使得系统构建变得容易。再加上良好的运行时性能，我们就拥有了构建一个简单的、接近生产就绪的 web 服务器所需的所有工具(这恰好是书呆子 Chuck Norris 的笑话)。

为了简洁起见，我省略了一些，但是完整的(可部署的)代码库可以在这里找到。

# 积木

web 服务器需要两样东西——供客户机与之交互的 API，以及处理客户机使用服务器的任何事情的逻辑。我们将从开发 API 开始。

在 Go 中构建 web *东西*时，我们经常使用`net/http`包，这次也不例外——它提供了构建我们的服务器所需的一切。我们将在`/`上监听，但是这个概念可以扩展到你选择的任何[子目录](https://blog.hubspot.com/marketing/parts-url)。

`net/http`提供开箱即用的并发请求处理，因此我们可以高效地工作，而不必太费力地思考。我们使用`http.HandleFunc`将我们的函数设置为各个子目录上的请求，而`ListenAndServe`会将这些请求定向到它们在所提供的`port`上的处理程序，直到它停止或出现错误。

接下来，我们必须设置逻辑来处理这些请求。对于这个例子来说,`handleGetJoke`是大部分业务逻辑的所在。

在这里，我们必须生成一个在笑话中使用的名称(代替“Chuck Norris”，只是为了让事情更有趣一点)。然后，我们会用那些名字组成一个笑话，最后我们会把完成的笑话返回给客户端。

`r`表示我们从客户端获得的请求，而`w`是我们生成并返回的响应。

请注意，我们已经将名称和笑话生成分别抽象为一个模块化的包`names`和`jokes`。构建模块化服务有很多好处。它缩小了职责范围，简化了交换库，使测试编写更容易，允许更具协作性的开发环境，并减少了开发人员扩展或调试服务所需的认知负荷。让这些模块化组件实现一个公共接口会更好，但那是以后的事了。

我们将使用 randomuser.me 为`names`包生成我们的名字。以下要点主要是发出一个 API 请求，然后处理返回的 JSON 数据。`GetNew()`通过调用支持函数来处理业务逻辑。

`simplehttpget`是使用`http.Client`的薄包装，在[全回购](https://github.com/swayne275/joke-web-server)中可以看到更多细节。

接下来，我们将使用[互联网 Chuck Norris 数据库](http://www.icndb.com)使用我们上面生成的名字生成一个笑话。如上所述，`GetNew()`是这个包的入口点。

同样，这主要是提供一个名称，发出一个 API 请求，并解析结果。一旦你编写了一些 API 客户端/消费者，你会开始注意到一些常见的模式。注意，struct 字段是公共的——这是`json`包编组/解组数据所必需的。

# 运行服务器

终于到了`main()`吸引人的时刻:

因为我们已经用多个包构建了这个服务器，所以运行起来非常简洁。我们选择一个端口，调用`StartServer`，如果我们得到任何错误，就会惊慌失措(还记得我怎么写的吗，这是*接近*生产就绪？您很可能希望在现实世界中优雅地处理这个错误)。

现在剩下的就是在这个目录的根目录下打开一个终端并运行`go run main.go`。然后你可以在网页浏览器中访问`localhost:5000`，在每次刷新时看到一个自定义的查克·诺里斯笑话！

如果您看到如下消息:

`panic: Could not start client API server on port 5000: listen tcp :5000: bind: address already in use`

使用端口`5000`可能会有其他的东西。将`main.go`中的`port`常量更改为其他值，然后重试！

# 停止服务器

要结束这个笑话，你可以在运行服务器的窗口中使用`ctrl-c`。这将释放资源(如服务器监听的端口)并退出程序。

# 包扎

我希望这是有教育意义和一点点乐趣。我计划围绕这一点构建一个系列，其中我将描述 Docker 设置(包含在 repo 中)，并探索几个用于构建简单 UI 的 Go 包。一如既往，请给我留下反馈，告诉我如何改进这一点！

# 更多即将推出…

我打算继续这个系列，并将保持下面的链接更新。未来的主题包括探索 Go 框架来构建前端！

现在，你可以继续阅读如何[对应用](https://medium.com/@swayne275/dockerizing-a-go-app-45ca034263ca)进行 Dockerize。请留下您还想阅读的反馈！