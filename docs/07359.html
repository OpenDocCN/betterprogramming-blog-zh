<html>
<head>
<title>SwiftUI Tips: Detecting a SwiftUI App’s Active, Inactive, and Background State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI提示:检测SwiftUI应用的活动、非活动和后台状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-tips-detecting-a-swiftui-apps-active-inactive-and-background-state-a5ff8acf5db1?source=collection_archive---------4-----------------------#2021-01-07">https://betterprogramming.pub/swiftui-tips-detecting-a-swiftui-apps-active-inactive-and-background-state-a5ff8acf5db1?source=collection_archive---------4-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="465e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">跟踪SwiftUI应用的前台和后台状态很容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c85ee03b4a11a9efbab02b92f78d8666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SF45kc_ljKlSgGM9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@iamdavid_10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David vihovec</a>拍摄的照片。</p></figure><p id="9f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迟早，你需要知道你的应用程序什么时候在前台，什么时候在后台，或者在两者之间转换。您可能已经知道在UIKit中通过使用<code class="fe ls lt lu lv b">UIApplicationDelegate</code>或<code class="fe ls lt lu lv b">UISceneDelegate</code>可以做到这一点，但是在SwiftUI中是如何做到的呢？</p><p id="5d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，处理这项任务的方法不止一种。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4f09" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">通知中心</h1><p id="a7f5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果你以前开发过iOS应用程序，通知中心可能对你来说很熟悉。Apple已经对其进行了更新，以提供一个组合发布器来发出可用于观察活动和非活动状态的事件。如果您不熟悉Combine的详细信息，请不要担心。观察这些状态真的很简单。</p><p id="5b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将一个<code class="fe ls lt lu lv b">onReceive</code>动作附加到一个视图，您可以轻松地监控<code class="fe ls lt lu lv b">didBecomeActiveNotification</code>和<code class="fe ls lt lu lv b">willResignActiveNotification</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="340d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在默认的<code class="fe ls lt lu lv b">App</code>结构中增加了两行:</p><ol class=""><li id="ea24" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在这里，我们观察<code class="fe ls lt lu lv b">didBecomeActiveNotification</code>并通过打印到控制台对其做出反应。</li><li id="88c6" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">在这一行，我们观察到<code class="fe ls lt lu lv b">willResignActiveNotification</code>并且也打印到控制台。</li></ol><p id="bda2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管很容易，但这不是我喜欢的做这件事的方法。我喜欢使用场景阶段，因为它提供了更多的灵活性。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6cf8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">场景相</h1><p id="873f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">观察活动和非活动状态的另一种方法是使用SwiftUI环境的<code class="fe ls lt lu lv b">scenePhase</code>。场景阶段是具有值<code class="fe ls lt lu lv b">active</code>、<code class="fe ls lt lu lv b">inactive</code>和<code class="fe ls lt lu lv b">background</code>的枚举。</p><p id="0298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过从<code class="fe ls lt lu lv b">@main</code> <code class="fe ls lt lu lv b">App</code>结构(应用程序的主入口点)观察场景阶段，您可以观察应用程序中所有场景的总体状态。换句话说，一旦app中的所有场景都处于后台状态，app的<code class="fe ls lt lu lv b">scenePhase</code>就变成了<code class="fe ls lt lu lv b">background</code>，这是App进入后台的标志。您可以在<code class="fe ls lt lu lv b">WindowGroup</code>上附加一个<code class="fe ls lt lu lv b">onChange</code>动作，以观察场景相位何时变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事情是这样的:</p><ol class=""><li id="21a7" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们将<code class="fe ls lt lu lv b">scenePhase</code>环境值分配给一个名为<code class="fe ls lt lu lv b">scenePhase</code>的新应用程序属性。</li><li id="d4d3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们通过使用场景的<code class="fe ls lt lu lv b">onChange</code>动作来观察新<code class="fe ls lt lu lv b">scenePhase</code>属性的变化。对<code class="fe ls lt lu lv b">scenePhase</code>属性的任何修改都会导致闭包运行。在我们的例子中，我们将把当前场景阶段打印到控制台。</li></ol><p id="3c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是要明白，除了从一个<code class="fe ls lt lu lv b">App</code>结构中观察场景相位，你也可以从<code class="fe ls lt lu lv b">Scene</code>和<code class="fe ls lt lu lv b">View</code>结构中观察它。这就是它如此灵活的原因，但这些表明了非常不同的事情。从<code class="fe ls lt lu lv b">View</code>观察为包含视图的场景提供相位。从<code class="fe ls lt lu lv b">Scene</code>观察为场景提供相位。只有从<code class="fe ls lt lu lv b">@main</code> <code class="fe ls lt lu lv b">App</code>观察，就像我们上面的例子一样，它才会为应用程序中的所有场景提供聚合阶段。这意味着——不管你的应用有多少场景——一旦第一个场景进入前景，最后一个场景进入背景，那么<code class="fe ls lt lu lv b">App</code>的场景相位就会更新。</p><p id="46d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是全部，除了…</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="fe2e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">非活动状态</h1><p id="10d1" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">监控阶段的<code class="fe ls lt lu lv b">active</code>和<code class="fe ls lt lu lv b">background</code>状态可能就是您所需要的。然而，如果您想利用<code class="fe ls lt lu lv b">inactive</code>状态，还有一点更好的方法。进入背景的场景的SwiftUI生命周期将从<code class="fe ls lt lu lv b">active</code>到<code class="fe ls lt lu lv b">inactive</code>再到<code class="fe ls lt lu lv b">background</code>。从后台出来的时候是反过来的(<code class="fe ls lt lu lv b">background</code>到<code class="fe ls lt lu lv b">inactive</code>到<code class="fe ls lt lu lv b">active</code>)。随着<code class="fe ls lt lu lv b">inactive</code>在两个方向上被使用，你如何在进入后台之前利用不活动状态来清理？还是在再次激活之前刷新数据？</p><p id="9578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检测非活动状态是进入活动状态还是后台状态只需要很小的变化。由于SwiftUI基于struct的架构，这不像给<code class="fe ls lt lu lv b">ScenePhaseApp</code>添加一个属性来跟踪之前的场景阶段那么容易，但仍然非常容易。同样，有许多不同的方法来处理这个问题，但是我将向您展示一种使用名为<code class="fe ls lt lu lv b">AppManager</code>的Swift类来存储这些数据的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ef51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该类是单例的，包含一个属性<code class="fe ls lt lu lv b">isActive</code>。该属性将跟踪应用程序是否处于活动状态，我们可以使用它来确定<code class="fe ls lt lu lv b">inactive</code>的场景阶段是进入背景还是前景。回到<code class="fe ls lt lu lv b">ScenePhaseApp</code>结构，我们将场景的<code class="fe ls lt lu lv b">onChange</code>事件改为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4d84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加或修改了三行代码来实现这一点:</p><ol class=""><li id="eadb" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在<code class="fe ls lt lu lv b">active</code>的例子中，我们将应用程序管理器的<code class="fe ls lt lu lv b">isActive</code>属性设置为<code class="fe ls lt lu lv b">true</code>。</li><li id="4e19" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">在<code class="fe ls lt lu lv b">background</code>案例中，我们将应用程序管理器的<code class="fe ls lt lu lv b">isActive</code>属性设置为<code class="fe ls lt lu lv b">false</code>。</li><li id="8c1d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">最后，我们更改<code class="fe ls lt lu lv b">inactive</code>案例的<code class="fe ls lt lu lv b">print</code>语句，打印应用程序是进入活动状态(前台)还是后台状态。这是你放置代码的地方，为应用程序进入前台和/或后台做准备。</li></ol><p id="7b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行上面的代码时，控制台输出将显示:</p><pre class="kg kh ki kj gt nq lv nr ns aw nt bi"><span id="bef7" class="nu me iq lv b gy nv nw l nx ny">Active</span></pre><p id="fe67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的背景将显示:</p><pre class="kg kh ki kj gt nq lv nr ns aw nt bi"><span id="6ab1" class="nu me iq lv b gy nv nw l nx ny">Inactive: entering background<br/>Background</span></pre><p id="7ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将应用程序带回前台会显示:</p><pre class="kg kh ki kj gt nq lv nr ns aw nt bi"><span id="9fed" class="nu me iq lv b gy nv nw l nx ny">Inactive: entering foreground<br/>Active</span></pre><p id="69b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看所有这些代码，您可以在<a class="ae kv" href="https://github.com/CoreyWDavis/ScenePhase" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载我的<code class="fe ls lt lu lv b">ScenePhase</code>项目。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d520" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">继续阅读</h1><ul class=""><li id="1514" class="nc nd iq ky b kz mv lc mw lf nz lj oa ln ob lr oc ni nj nk bi translated">苹果的<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/scenephase" rel="noopener ugc nofollow" target="_blank">场景阶段文档</a></li><li id="e85f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">苹果的<a class="ae kv" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank">通知中心文档</a></li></ul></div></div>    
</body>
</html>