<html>
<head>
<title>Replace Deprecated Kotlin Synthetics With Jetpack View Binding in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中用Jetpack视图绑定替换已弃用的Kotlin合成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-jetpack-view-binding-c0947f7a6e9e?source=collection_archive---------1-----------------------#2021-02-28">https://betterprogramming.pub/android-jetpack-view-binding-c0947f7a6e9e?source=collection_archive---------1-----------------------#2021-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="185d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果科特林合成材料正在消失，是时候转向替代品了吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38cc541a5f20f644d55589cae91dc4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TA2N0gF7-v2TIe1j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@masakaze?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">川上正和</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从Android开发开始以来，已经有许多方法可以从类内部的XML布局文件中访问视图，以对它们执行操作。让我们回顾一下导入视图的演变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="67a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> findViewById </strong></h1><p id="1ab6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最初，我们通过传递视图ID <strong class="lb iu"> </strong>来使用<code class="fe mz na nb nc b">findViewById()</code>方法访问视图。这在所有膨胀布局的类文件中添加了大量样板代码。仅仅为了找到视图而重复编写这些代码既不有趣也不舒服。</p><h2 id="1275" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><strong class="ak">语法</strong></h2><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="c80d" class="nd md it nc b gy nt nu l nv nw">TextView emailTextView;<br/>emailTextView = (TextView) findViewById(R.id.txt_email);</span></pre><ul class=""><li id="3cc9" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe mz na nb nc b">R.id.txt_email</code>表示在ID名称为<code class="fe mz na nb nc b">txt_email</code> <strong class="lb iu">的任何布局中定义的视图。</strong></li><li id="f905" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe mz na nb nc b">R</code> <strong class="lb iu"> </strong>是Android中的一个类，拥有所有视图id的集合。</li><li id="e2f6" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe mz na nb nc b">findViewById</code>是一种用于从附加到当前活动的布局资源文件中找到视图的方法。</li></ul><p id="fa26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点是:</p><ol class=""><li id="f313" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu ol od oe of bi translated"><code class="fe mz na nb nc b">NullPointerException</code>和<code class="fe mz na nb nc b">ClassCastException</code>导致无空安全或类型安全。</li><li id="0bed" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">更多样板代码。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c725" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">黄油刀</strong></h1><p id="418b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">挣扎了几年后，我们迁移到ButterKnife <strong class="lb iu">，</strong>一个基于注释的库，以方便地访问视图。ButterKnife是一个用于Android的视图注入库。我们必须在<code class="fe mz na nb nc b">gradle</code>文件中集成一个依赖项，然后使用各自的注释来访问视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="86af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点是:</p><ol class=""><li id="beb0" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu ol od oe of bi translated">这也不令人兴奋。尽管我们减少了行数，但样板代码仍然存在于所有类文件的顶部。</li><li id="a48a" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">堆栈跟踪有点难以理解。</li><li id="9982" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">它已被弃用，功能开发和一般错误修复已经停止。</li></ol><p id="f971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在说说Kotlin synthetics，在过去三年里，它在导入视图方面统治了Android开发世界。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4591" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">科特林合成纤维</h1><p id="e9c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">合成材料是JetBrains开发的Kotlin Android扩展的一部分。合成使得在代码中绑定视图变得更加简单和容易。合成让我们在<code class="fe mz na nb nc b">kotlinx.android.synthetic</code>绑定的帮助下取代对<code class="fe mz na nb nc b">findViewById</code>的调用。</p><p id="9fd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在<code class="fe mz na nb nc b">gradle</code>文件中添加一个插件来访问合成:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="5089" class="nd md it nc b gy nt nu l nv nw">apply plugin: 'kotlin-android-extensions'</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="90ac" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">科特林合成被否决了吗？</h2><p id="74db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多开发人员很快喜欢并采用了Kotlin合成材料，因为它们非常容易使用。然而，随着Kotlin 1.4.20 <strong class="lb iu">，</strong>的发布，官方宣布不推荐使用Kotlin Android扩展。</p><p id="7995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在1.4.20中，JetBrains的团队从<code class="fe mz na nb nc b">kotlin-android-extensions</code>中提取了Parcelable实现生成器，并开始了人工合成的弃用周期。目前，合成材料将继续工作，但会有一个弃用警告。<code class="fe mz na nb nc b">android-kotlin-extensions</code>将在2021年9月(或之后)的未来Kotlin版本中删除。</p><h2 id="8b52" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">为什么科特林合成材料被弃用？</h2><p id="4a77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用Kotlin合成纤维有许多缺点:</p><ul class=""><li id="c7f9" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">它们污染了全局名称空间。</li><li id="3af4" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">它们不公开可空性信息。</li><li id="fcfd" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">他们只使用科特林代码。</li><li id="2786" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">在切换口味时，使用产品口味会导致合成导入语句出错。</li><li id="57c3" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">在多个布局中导入具有相同id的视图会导致开销问题。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Android Jetpack视图绑定</h1><p id="d1da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">视图绑定是Google团队当前的建议，用于将视图从XML导入到<code class="fe mz na nb nc b">Activity</code>、<code class="fe mz na nb nc b">Fragment</code>或<code class="fe mz na nb nc b">Adapter</code>类。视图绑定是一个允许我们更容易地编写与视图交互的代码的特性。大多数情况下，视图绑定取代了<code class="fe mz na nb nc b">findViewById</code>。它同时支持Java和Kotlin。</p><p id="ce2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要遵循的步骤:</p><ol class=""><li id="89f3" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu ol od oe of bi translated">在<code class="fe mz na nb nc b">build.gradle</code>中启用视图绑定(不需要额外的依赖)。</li><li id="0ef6" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">它为该模块中的每个XML布局生成一个绑定类。</li><li id="d9dc" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">binding类的一个实例包含对所有视图的直接引用，这些视图在相应的布局中有一个ID。</li></ol><h2 id="7f7e" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">设置</h2><p id="8596" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">视图绑定是类似于Android扩展的模块级配置。不需要添加任何额外的依赖项。<strong class="lb iu"> </strong>让我们通过在模块级<code class="fe mz na nb nc b">build.gradle</code>文件中将其值设置为<code class="fe mz na nb nc b">true</code>来启用视图绑定。</p><p id="dd61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Android Studio版开始:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="9264" class="nd md it nc b gy nt nu l nv nw">android {<br/>    ...<br/>    buildFeatures {<br/><strong class="nc iu">        viewBinding true<br/></strong>    }<br/>}</span></pre><p id="8b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦该特性被启用，它将自动(在构建或使用<code class="fe mz na nb nc b">rebuild</code>选项时)为该模块中的布局生成所有绑定类。</p><h2 id="3b9a" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">禁用视图绑定</h2><p id="e11a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想跳过绑定类的生成，我们需要将<code class="fe mz na nb nc b">tools:viewBindingIgnore="true"</code>属性添加到布局文件的根视图中:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="56f0" class="nd md it nc b gy nt nu l nv nw">&lt;LinearLayout<br/>        ...<br/>        <strong class="nc iu">tools:viewBindingIgnore="true" </strong>&gt;<br/>    ...<br/>&lt;/LinearLayout&gt;</span></pre><p id="f59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下<code class="fe mz na nb nc b">Activity</code>和<code class="fe mz na nb nc b">Fragment</code>类中视图的用法。</p><h2 id="e765" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">课堂上的基本用法</h2><p id="bd21" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在使用绑定类生成之前，我们需要了解它。绑定类的名称是Pascal格式的XML文件的名称，并在末尾加上单词<code class="fe mz na nb nc b">Binding</code>。</p><p id="dbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果布局文件的名称是<code class="fe mz na nb nc b">activity_main.xml</code>，则生成的绑定类的名称是<code class="fe mz na nb nc b">ActivityMainBinding</code>。</p><h2 id="a72a" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">在活动中使用视图绑定</h2><p id="9097" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一个示例项目，并检查在<code class="fe mz na nb nc b">Activity</code>中访问视图元素的流程。</p><p id="ef63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看完整的代码库，请查看<a class="ae ky" href="https://github.com/pavan5208/viewbinding_sample" rel="noopener ugc nofollow" target="_blank">视图绑定示例</a>。</p><ol class=""><li id="82be" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu ol od oe of bi translated">在Android Studio中创建新项目:文件→新项目→ …</li><li id="4453" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">在app级<code class="fe mz na nb nc b">build.gradle</code>文件中启用视图绑定:</li></ol><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="8966" class="nd md it nc b gy nt nu l nv nw">android{<br/>......<br/>buildFeatures <strong class="nc iu">{<br/>    </strong>viewBinding true<br/><strong class="nc iu">}<br/>}</strong></span></pre><p id="0753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.重新生成项目，并检查生成的绑定类的生成文件夹，或者通过按下double-shift搜索该类的名称。绑定类的名称是Pascal格式的布局文件的名称，在末尾加上单词<code class="fe mz na nb nc b">Binding</code>。我的情况是<code class="fe mz na nb nc b">ActivityMainBinding</code>，看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/441c93ff9bfe17641ea9252e4e3845e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcsQmg_8olCknTzsC03xYw.png"/></div></div></figure><p id="8e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.现在我的<code class="fe mz na nb nc b">ActivityMainBinding</code>类包含了布局中每个带有ID的视图的属性。因此，让我们将ID为<code class="fe mz na nb nc b">text_email</code>的文本视图添加到布局文件中，并重新构建项目。然后我们将检查<code class="fe mz na nb nc b">ActivityMainBinding</code>文件的变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="82f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.我们需要遵循下面的三个步骤来访问绑定类实例，并将视图设置为<code class="fe mz na nb nc b">Activity</code>:</p><ol class=""><li id="82b0" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu ol od oe of bi translated">我们需要调用包含在生成的<code class="fe mz na nb nc b">ActivityMainBinding</code>类中的静态<code class="fe mz na nb nc b">inflate()</code>方法。这创建了一个绑定类的实例或对象供<code class="fe mz na nb nc b">Activity</code>使用。</li><li id="48bd" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">接下来，通过调用<code class="fe mz na nb nc b">getRoot()</code>方法或使用Kotlin的属性语法来获取对根视图的引用。</li><li id="9060" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu ol od oe of bi translated">最后，将根视图设置为<code class="fe mz na nb nc b">setContentView()</code>，使其成为屏幕上的活动视图。</li></ol><p id="a141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这三个步骤放在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.现在，我们已经准备好访问绑定类实例上相应布局中带有id的视图:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="512c" class="nd md it nc b gy nt nu l nv nw"><em class="op">binding</em>.textEmail.<em class="op">text </em>= "Satya"<br/><em class="op">binding</em>.textEmail.setOnClickListener <strong class="nc iu">{ <br/>    </strong>//Do some awful stuff here<br/><strong class="nc iu">}</strong></span></pre><p id="28a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在片段中使用视图绑定。</p><p id="8df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7.在电子邮件文本视图下面的<code class="fe mz na nb nc b">Activity</code> XML中添加一个静态<code class="fe mz na nb nc b">Fragment</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="db13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8.<code class="fe mz na nb nc b">Fragment</code>内的视图绑定与<code class="fe mz na nb nc b">Activity</code>内的相似。唯一的区别是我们需要丢弃<code class="fe mz na nb nc b">onDestroyView</code>生命周期回调中的绑定对象，因为<code class="fe mz na nb nc b">Fragment</code>中的绑定实例的范围是<code class="fe mz na nb nc b">Fragment</code>视图的生命周期(在<code class="fe mz na nb nc b">onCreateView</code>和<code class="fe mz na nb nc b">onDestroyView</code>之间)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行并检查应用程序。此外，检查生成的代码，以便更好地理解。要获得完整的代码，请查看GitHub 上的<a class="ae ky" href="https://github.com/pavan5208/viewbinding_sample" rel="noopener ugc nofollow" target="_blank">视图绑定示例。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d9fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="352f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">视图绑定在某些方面类似于Kotlin synthetics(例如，访问属性)，但在处理绑定实例和设置根方面有一点额外的东西。Kotlin合成材料的替代品是<code class="fe mz na nb nc b">findViewbyId()</code>和view binding。</p><p id="9ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不担心样板代码、空安全或类型安全，您可以使用<code class="fe mz na nb nc b">findViewbyId()</code>。如果你想用最新的东西更新自己，遵循Android开发者的建议。如果您担心样板代码、空安全和类型安全，可以使用视图绑定。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="02af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="3262" class="nx ny it lb b lc mu lf mv li oq lm or lq os lu oc od oe of bi translated"><a class="ae ky" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank"> Android开发者:视图绑定</a></li></ul></div></div>    
</body>
</html>