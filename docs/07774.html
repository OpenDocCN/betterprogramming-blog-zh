<html>
<head>
<title>Authenticating Frontend Apps Using Cookies in .NET Core Web API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在中使用Cookies验证前端应用程序。NET Core Web API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/authenticating-frontend-apps-using-cookies-in-net-core-web-api-2df311e735bb?source=collection_archive---------2-----------------------#2021-02-18">https://betterprogramming.pub/authenticating-frontend-apps-using-cookies-in-net-core-web-api-2df311e735bb?source=collection_archive---------2-----------------------#2021-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a75" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的前端设置一个. NET核心后端，并使用cookies构建安全的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2eb6f8c1130bd3c9545989546751872e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wrR0K7Ie9vAJuKUK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@olia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olia Gozha </a>拍摄的照片。</p></figure><p id="bd43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去，web应用程序被视为一体。前端和后端应用程序之间没有分离，至少不像今天这样。原因是在那时，计算机没有今天这样强大。浏览器过去依赖服务器来呈现前端，并将其作为简单的HTML返回。这种技术被称为服务器端呈现。这种心态催生了像ASP.NET网络表单这样的框架。</p><p id="5968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是随着计算机领域的创新迅速增加，现代计算机变得比以前更加强大。这使得他们能够呈现更多的客户端代码。</p><p id="f84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，现代应用程序往往通过实现客户端渲染而从中受益。我相信你听说过像React和Vue这样的JavaScript框架。这些应用的复杂性通常会使前端和后端应用的分离更加合理。</p><p id="f917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关注点的分离使得应用程序之间的同步更加困难。由于JavaScript框架的本质——它们运行在客户端的机器上，安全性问题也随之而来。</p><p id="3284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将提供一个演示，演示我们如何使用cookies为带有. NET核心后端的前端应用程序实现身份验证。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b637" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">配置前端</h1><p id="18a6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们配置后端之前，我们需要配置前端。为什么？独立的前端和后端应用程序将拥有某种跨源资源共享(CORS)策略。</p><h2 id="e133" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">HTTP请求</h2><p id="852b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因此，通过首先配置我们的前端，我们只允许我们需要的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取请求的示例。</p></figure><p id="c0ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以这个代码片段为例。如果我们使用这个请求，我们将需要允许所有三个<code class="fe nk nl nm nn b">Accept</code>、<code class="fe nk nl nm nn b">Content-Type</code>和<code class="fe nk nl nm nn b">Authorization</code>头。同样，如果我们使用像<code class="fe nk nl nm nn b">GET</code>、<code class="fe nk nl nm nn b">POST</code>、<code class="fe nk nl nm nn b">PATCH</code>和<code class="fe nk nl nm nn b">DELETE</code>这样的HTTP方法，我们也需要允许这些方法。另外，如果我们想使用前面提到的HTTP方法之一，<a class="ae kv" href="https://stackoverflow.com/questions/40758013/response-to-preflight-request-doesnt-pass-access-control-check-in-nodejs/40758058#40758058" rel="noopener ugc nofollow" target="_blank">我们也需要允许</a> <code class="fe nk nl nm nn b"><a class="ae kv" href="https://stackoverflow.com/questions/40758013/response-to-preflight-request-doesnt-pass-access-control-check-in-nodejs/40758058#40758058" rel="noopener ugc nofollow" target="_blank">OPTIONS</a></code> <a class="ae kv" href="https://stackoverflow.com/questions/40758013/response-to-preflight-request-doesnt-pass-access-control-check-in-nodejs/40758058#40758058" rel="noopener ugc nofollow" target="_blank">。在每个请求之前，浏览器发送一个<code class="fe nk nl nm nn b">OPTIONS</code>请求。</a></p><h2 id="30c0" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">在前端接收cookies</h2><p id="ca18" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">请注意代码片段中的这一行:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="d4f7" class="mw ma iq nn b gy ns nt l nu nv">credentials: 'true'</span></pre><p id="3402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想要在我们的前端应用中允许<code class="fe nk nl nm nn b">set-cookies</code>时，这一行是至关重要的。对于使用新fetch API的应用程序，在请求中添加<code class="fe nk nl nm nn b">credentials: 'include'</code>以启用cookies。对于Axios用户，在启动新的Axios客户端之前，请使用<code class="fe nk nl nm nn b">axios.defaults.withCredentials = true;</code>。</p><p id="b2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于前端CORS的更深入的解释，<a class="ae kv" href="https://web.dev/cross-origin-resource-sharing/" rel="noopener ugc nofollow" target="_blank">你可以查看这篇文章</a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8e33" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">配置后端</h1><p id="8280" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">后端是奇迹发生的地方。嗯，算是吧。</p><p id="23ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看，当处理CORS时，你总是需要从后端允许它。来自前端的请求只定义了我们需要从后端得到什么，而安全性由我们的后端策略决定。</p><p id="d9ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以从后端应用程序配置CORS策略，也可以在您的服务器配置中配置它们。似乎两边的<a class="ae kv" href="https://stackoverflow.com/questions/62015085/net-3-1-api-angular-9-cors-with-nginx-proxy" rel="noopener ugc nofollow" target="_blank">配置都会导致问题</a>。</p><h2 id="f47c" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">定义CORS政策</h2><p id="634c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如前一节所述，您需要定义允许的方法、头和来源。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CORS政策的例子。</p></figure><p id="031b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">策略生成器允许我们流畅地添加将通过CORS允许的方法。在上面的例子中，我们允许HTTP请求使用<code class="fe nk nl nm nn b">GET</code>、<code class="fe nk nl nm nn b">POST</code>、<code class="fe nk nl nm nn b">PATCH</code>、<code class="fe nk nl nm nn b">DELETE</code>和<code class="fe nk nl nm nn b">OPTIONS</code>方法。此外，我们允许所有三个<code class="fe nk nl nm nn b">Accept</code>、<code class="fe nk nl nm nn b">Content-Type</code>和<code class="fe nk nl nm nn b">Authorization</code>标题。</p><p id="95b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了成功地通过API传递cookies，我们需要允许带有<code class="fe nk nl nm nn b">AllowCredentials</code>的凭证。如果我们允许凭证，我们还需要在后端定义允许的来源。因此，我们可以使用<code class="fe nk nl nm nn b"><a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.cors.infrastructure.corspolicybuilder.withorigins?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">WithOrigin</a></code>或<code class="fe nk nl nm nn b"><a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.cors.infrastructure.corspolicybuilder.setisoriginallowed?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">SetIsOriginAllowed</a></code>。这两种方法都行得通，因为它们似乎有着相同的目标。</p><p id="2859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数CORS实现会使用<code class="fe nk nl nm nn b">withOrigin</code>，并最终设置一个通配符(即<code class="fe nk nl nm nn b">*</code>)作为原点。这对于一些不实现凭证的情况是可行的，但是最佳实践是定义允许哪些来源。为了实现这一点，我选择使用<code class="fe nk nl nm nn b">SetIsOriginAllowed</code>方法。</p><p id="fe7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nw">注:一个实现允许来自任何原籍的CORS凭国书可以参见</em><a class="ae kv" href="https://jasonwatmore.com/post/2020/05/20/aspnet-core-api-allow-cors-requests-from-any-origin-and-with-credentials" rel="noopener ugc nofollow" target="_blank"><em class="nw"/></a><em class="nw">。将这种配置用于开发目的是可以的，但是我不建议在生产中使用这种配置。</em></p><p id="b4d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现了依赖注入之后，您可以通过从<code class="fe nk nl nm nn b">IApplicationBuilder</code>调用策略名来实现CORS策略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CORS实施的例子。</p></figure><h2 id="0f56" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">通过依赖注入添加cookie身份验证</h2><p id="4d26" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，您需要在<code class="fe nk nl nm nn b">Startup.cs</code>文件中确定您的cookie配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">cookie实现的示例。</p></figure><p id="e6db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">AddAuthentication</code>扩展了<code class="fe nk nl nm nn b">IServiceCollection</code>配置。这就是我们注入cookie认证方案的方式。在我们使用cookie添加身份验证方案之后，我们将需要定义cookie。<code class="fe nk nl nm nn b">AddCookie</code>方法就是这样做的。</p><p id="1772" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过使用<code class="fe nk nl nm nn b">Cookie.Name</code>参数来定义我们的cookie名称，并通过定义<code class="fe nk nl nm nn b">ExpireTimeSpan</code>来定义我们的cookie何时到期(在我们的例子中，cookie将在一小时后到期)。<code class="fe nk nl nm nn b">SlidingExpiration</code>将通过在到期时间接近时刷新到期时间，使您的cookies持续更长时间<a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.cookies.cookieauthenticationoptions.slidingexpiration?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="e762" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">保护cookie配置</h2><p id="a7c1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要使用安全cookie，使用<code class="fe nk nl nm nn b">HttpOnly</code> cookie选项是关键。本质上，<a class="ae kv" href="https://owasp.org/www-community/HttpOnly" rel="noopener ugc nofollow" target="_blank">它保护我们的cookies不被恶意的XSS脚本检索</a>。你一定要实现它。</p><p id="2607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该实现的下一件事是<code class="fe nk nl nm nn b">SameSite</code>选项。如果你的应用程序有相同的来源，<a class="ae kv" href="https://owasp.org/www-community/SameSite" rel="noopener ugc nofollow" target="_blank">你很可能将</a> <code class="fe nk nl nm nn b"><a class="ae kv" href="https://owasp.org/www-community/SameSite" rel="noopener ugc nofollow" target="_blank">SameSite</a></code> <a class="ae kv" href="https://owasp.org/www-community/SameSite" rel="noopener ugc nofollow" target="_blank">设置为严格选项</a>。否则，如果您使用跨站点cookie，您可能希望将<code class="fe nk nl nm nn b">SameSite</code>选项设置为None。你可能会想，“这如何让我的应用安全？”嗯，没有。它只会让你的。NET Core app <a class="ae kv" href="https://docs.microsoft.com/en-us/aspnet/core/security/samesite?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">认证来自其他域的cookie</a>。</p><p id="a05a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为了防止你的cookie被恶意使用，现代浏览器会要求你在cookie上添加一个<code class="fe nk nl nm nn b">Secure</code>策略。您可以通过扩展<code class="fe nk nl nm nn b">IApplicationBuilder</code>来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何使用“安全”cookies</p></figure><p id="11af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe nk nl nm nn b">Secure</code>是什么意思呢？我将检查cookie是否通过HTTPS传输，并且只接受来自HTTPS的cookie。只有当您想要将<code class="fe nk nl nm nn b">SameSite</code>设置为“无”时，这才是强制的。这就是为什么在本地环境中，我通常注释掉<code class="fe nk nl nm nn b">SameSite</code>和<code class="fe nk nl nm nn b">Secure</code>策略。</p><h2 id="cac5" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">使用cookie认证中间件</h2><p id="a88f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了使开发过程更加无缝，在<code class="fe nk nl nm nn b">IApplicationBuilder</code>中实现<code class="fe nk nl nm nn b">UseAuthentication</code>和<code class="fe nk nl nm nn b">UseAuthorization</code>中间件。</p><p id="a316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nw">注意:</em> <a class="ae kv" href="https://manojchoudhari.wordpress.com/2020/01/25/securing-net-core-3-api-with-cookie-authentication/" rel="noopener ugc nofollow" target="_blank"> <em class="nw">记得在</em> </a> <code class="fe nk nl nm nn b"><a class="ae kv" href="https://manojchoudhari.wordpress.com/2020/01/25/securing-net-core-3-api-with-cookie-authentication/" rel="noopener ugc nofollow" target="_blank"><em class="nw">UseEndpoints</em></a></code> <a class="ae kv" href="https://manojchoudhari.wordpress.com/2020/01/25/securing-net-core-3-api-with-cookie-authentication/" rel="noopener ugc nofollow" target="_blank"> <em class="nw">方法之前实现这个！</em> </a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何实现认证和授权？</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0032" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在方法上实现Cookie身份验证</h1><p id="243b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我将举例说明我是如何编写登录和注销方法的实现的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AuthController代码片段。</p></figure><p id="078b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过在<code class="fe nk nl nm nn b">HttpContext</code>上调用<code class="fe nk nl nm nn b">SignInAsync</code>来获得认证cookie。这将在HTTP请求返回时设置cookie。要在cookies上使用认证方法，我们需要在方法上使用<code class="fe nk nl nm nn b">Authorize</code>属性。这将激活<code class="fe nk nl nm nn b">UseAuthentication</code>和<code class="fe nk nl nm nn b">UseAuthorization</code>中间件。</p><p id="69cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要销毁cookie，只需调用<code class="fe nk nl nm nn b">HttpContext</code>上的<code class="fe nk nl nm nn b">SignOutAsync</code>。该cookie将过期，并且不再可用于所有会话。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4a4b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">现实生活中的例子</h1><p id="526e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我已经实现了我的解决方案，为了向您展示它是如何工作的，我附上了一些截图。我希望这可以帮助您理解当所有都正确实现时会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/0f13c05b4b06acb5a6397a1bf0850ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqlbJEaL0Er0gQsRUUHA5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用cookies的本地主机。</p></figure><p id="c2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是cookie设置工作时会发生什么的一个例子。cookie将被保存，可以在Chrome Dev Tools的“应用程序”标签中查看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f33d345c8c509cff7867dce698926d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*WSzlshA3MVJYuUBe1zBv6w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HTTP请求的示例。</p></figure><p id="3d66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意cookie中的<code class="fe nk nl nm nn b">SameSite</code>属性是松散的。这是因为我是在本地主机环境中测试的。因此，我不能将<code class="fe nk nl nm nn b">SameSite</code>设置为None，因为它必须通过HTTPS运输。</p><p id="4a1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，如果我实现HTTPS，预期结果将如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/114f699411ddb277b4fc5c461aef4d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*ZJMcl9OQGvGk0-GzGAZZZA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用HTTPS请求登录的示例。</p></figure><p id="f25e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的生产环境cookies的一个例子。请注意<code class="fe nk nl nm nn b">Secure</code>属性以及<code class="fe nk nl nm nn b">SameSite</code>属性是如何被设置为None的。注销请求应该有以下响应:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/401d2bbc2662bbb0eeecd50e01ddc58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*G56Tgk_Ub6vRqSWhJzFgBQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注销请求示例。</p></figure><p id="81a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">期望<code class="fe nk nl nm nn b">set-cookie</code>头是空的，只返回一个简单的响应。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5741" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="42f7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这就是你在前端应用程序中使用cookies的方式。请记住，会话不是分布式的，如果您有多台服务器，您需要实现分布式会话。最常见的是Redis会话。中Redis会话的实现。网芯可以在GitHub 上看到<a class="ae kv" href="https://mikerussellnz.github.io/.NET-Core-Auth-Ticket-Redis/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CORS的实现很复杂，但是从中可以学到很多东西。我希望这篇文章能帮助你建立你的CORS。NET Core app。</p></div></div>    
</body>
</html>