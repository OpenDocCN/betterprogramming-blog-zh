<html>
<head>
<title>The Search Bar With Combine in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中带有组合的搜索栏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/search-bar-and-combine-in-swift-ui-46f37cec5a9f?source=collection_archive---------1-----------------------#2020-10-17">https://betterprogramming.pub/search-bar-and-combine-in-swift-ui-46f37cec5a9f?source=collection_archive---------1-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="94e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的应用中搜索，由Combine提供支持</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4711aff2e9643542584bd5f05c6f7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kWcpWAXmklxg3N-8"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@paulminami?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">保罗·美并</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="aa36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近我在SwiftUI上做一个项目。SwiftUI对于iOS开发人员来说是一件轻而易举的事情。我记得我们很难布置视图的时候，不管是使用程序性的还是故事板的方法(尽管我不是故事板的粉丝)。对我来说，在模拟器和设计师之间来回奔波是一件乏味的工作。幸运的是，SwiftUI出现了，iOS开发的方方面面正在慢慢发展。当然，我们都喜欢UI Kit，它仍将统治iOS开发多年。</p><p id="d220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，SwiftUI在中很容易工作和实现，尽管仍然有一些警告。例如，<code class="fe ls lt lu lv b">UISearchController</code>和<code class="fe ls lt lu lv b">SearchBar</code>在SwiftUI中不可用，获取键入文本的委托方法也不可用。在这里，我试图呈现一个简单的情况，您希望发送一个带有搜索关键字的网络请求，并在SwiftUI中呈现数据。</p><p id="59ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这个演示/教程的目的，我将使用<a class="ae kv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">组合</a>和SwiftUI。Combine也是在2019年WWDC奥运会上推出的，它是一个反应式框架，是苹果对Rx编程风格的实现。对于像我这样之前没有RxSwift使用经验的人来说，Combine会感觉很艰难。然而，与传统方法相比，使用Combine的好处是代码更加健壮，并且消除了我们通常在网络调用和其他地方实现的各种完成处理程序块。我将尽力解释所使用的方法；尽管如此，我还是强烈建议多读一些关于联合收割机的书。</p><p id="6ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将创建一个普通视图，其中有一个搜索栏，允许在某个远程服务器上搜索产品。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ed30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码中发生了很多需要解释的事情。首先，布局数组定义了列表中的项目应该如何显示。它甚至可以说是SwiftUI的集合视图，因为它充当了委托流布局的<code class="fe ls lt lu lv b">sizeForItemAt</code>方法。然而，布局属性告诉SwiftUI，“嘿SwiftUI，我想要一个具有灵活宽度或者跨越视图整个宽度的网格项目。”很简单，对吧？这个代码库中第二件看起来令人畏惧的事情是<code class="fe ls lt lu lv b">ObservedObject</code>的属性包装。稍后我会解释它，但让我们首先关注布局。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/a3ef5d6153c720ccc9b7d720f48c1f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*FMyPBFJ2VRWzAR-5CFgiEA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SearchView.swift</p></figure><p id="adb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">布局很简单:我们正在创建一个<code class="fe ls lt lu lv b">VStack</code>，它将保存我们的搜索栏和结果。搜索栏是一个在<code class="fe ls lt lu lv b">HStack</code>内的纯文本字段，它的宽度可以调整所有的屏幕尺寸。还有一个<code class="fe ls lt lu lv b">ScrollView</code>，它封装了负责显示列表项的<code class="fe ls lt lu lv b">LazyVGrid</code>。内嵌的<code class="fe ls lt lu lv b">ItemView</code>有一个<code class="fe ls lt lu lv b">ZStack</code>和<code class="fe ls lt lu lv b">HStack</code>比较好理解。</p><p id="44f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI中的<code class="fe ls lt lu lv b">TextField</code>期望绑定从<code class="fe ls lt lu lv b">ProductViewModel</code>传来的字符串，这是这个谜题的关键部分。我们负责向网络发送请求和更新视图模型中的数据源。注意变量中的<code class="fe ls lt lu lv b">Published</code>属性包装器；这将有助于SwiftUI计算各州的差异。让我们看看视图模型的组织。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0cea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，<code class="fe ls lt lu lv b">ViewModel</code>承担了所有的重担。<code class="fe ls lt lu lv b">TextField</code>的可绑定字符串也由此对象提供。注意产品数组前面的关键字<code class="fe ls lt lu lv b">@Published</code>和<code class="fe ls lt lu lv b">searchText</code>。</p><p id="2427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来看看<code class="fe ls lt lu lv b">searchText</code>。这就像一个上游发布者，随着时间的推移发布值。也就是说，每当用户开始在字段上输入时，这个<code class="fe ls lt lu lv b">searchText</code>就会产生值。在这个<code class="fe ls lt lu lv b">ViewModel</code>的初始化器上，我们订阅了<code class="fe ls lt lu lv b">searchText</code>发布者发出的值。这里我们是<em class="lz">反跳</em>，这意味着将值的检索延迟800毫秒，因为我们不想在用户键入后立即发送请求，我们希望等待几秒钟，这样我们就不必在每个键入的字母上往返一次。在等待800毫秒后，我们将转向另一个运营商<code class="fe ls lt lu lv b">removeDuplicates</code>，如果用户键入重复的字母并迅速删除它们以使我们崩溃，iOS将智能地处理这一问题。</p><p id="c86d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此后，订户链上出现了<code class="fe ls lt lu lv b">map</code>操作符，它检查字符串的计数是否合适。例如，如果用户放置光标并使其保持不动，那么就没有必要去服务器获取数据。如果计数大于1，发布的值只通过<code class="fe ls lt lu lv b">map</code>；如果没有，则传递nil。注意<code class="fe ls lt lu lv b">compactMap</code>，它巧妙地过滤掉了不会在这个操作符下面传递的零值，因此，它将允许我们进入网络。</p><p id="a46d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果上述所有操作都成功，我们将发送一个网络请求并检索结果。订阅集对我们来说起着重要的作用。它为我们保存订阅，并在需要时清除内存。这是iOS自己完成的，所以我们不需要担心。但是，如果我们想使用发布者-订阅者链，最好记住保留订阅。然后，调用一个函数进入网络并获取所需的结果。</p><p id="6b0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/705a85bbc29f03779dec32cdbd633a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/1*Bt_wkT0R0XmSb0g_htZDbQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">搜索结果</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/de5d1eb6a1815744eb6cf2eef1eace3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*2va1oOSSY0KiP4K3Ts-Xug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库ˌ资料库</p></figure><p id="165e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这是一个令人兴奋的阅读对我们所有人来说。我没有包含<code class="fe ls lt lu lv b">Codable</code>模型文件，我们都知道它简单且易于实现，也没有添加<code class="fe ls lt lu lv b">NetworkManager</code>代码。它只是访问网络，并使用所需的查询字符串获取端点的结果。我还添加了数据库的截图，作为我们的证据。</p></div></div>    
</body>
</html>