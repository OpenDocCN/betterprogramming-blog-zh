<html>
<head>
<title>Optimize Your Go Dockerfile for Size and Speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化您的Go Dockerfile文件的大小和速度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-e0070aa1b383?source=collection_archive---------1-----------------------#2022-08-21">https://betterprogramming.pub/modern-rest-api-with-go-and-postgresql-e0070aa1b383?source=collection_archive---------1-----------------------#2022-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="250f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Go构建现代REST API第4部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0090449ffef31b7a9e5fa8c3b7359d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cLcltnCI-BZtZ323rjRHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Guillaume Bolduc 在<a class="ae kv" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是一个系列的第四篇，涵盖了逐步实现现代REST API微服务的所有方面:</p><ol class=""><li id="2e00" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-c765d571b9e7" rel="noopener">用sqlc定义SQL优先数据模型</a></li><li id="b88f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-39b0e966534a" rel="noopener">用Gin实现REST API</a></li><li id="55cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-1d48767a813" rel="noopener">用Viper配置</a></li><li id="6a11" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">在容器中构建和运行</strong></li><li id="a305" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/@bquenin/modern-rest-api-with-go-and-postgresql-7c916ce2816a" rel="noopener">集装箱测试</a></li></ol><p id="0265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该系列的所有代码都可以在https://github.com/bquenin/modern-go-rest-api-tutorial<a class="ae kv" href="https://github.com/bquenin/modern-go-rest-api-tutorial" rel="noopener ugc nofollow" target="_blank">获得</a></p><h1 id="9143" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我们的执行环境是什么？</h1><p id="7fb6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了更好地理解我们需要构建什么，我们需要知道我们的目标是什么执行环境:</p><ul class=""><li id="b5ea" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><strong class="ky ir">生产环境</strong>:我们希望在尽可能接近生产环境的环境中运行我们的容器化应用程序，</li><li id="509e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><strong class="ky ir">开发环境</strong>:我们也想要一个快速的开发周期，在这个周期中，我们可以运行、停止和重启我们的应用程序，而不需要将其容器化。通常，这在开发新特性、实现测试、调试问题、分析等时很有用。</li></ul><h1 id="d7a3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">生产环境</h1><p id="a13c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在开发REST API微服务时，您负责为您的应用程序提供一个容器。一旦构建了容器，您可能需要将它推送到您选择的容器注册中心，以便可以将应用程序部署到您的生产环境中。</p><p id="ecc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们不会涵盖容器化应用程序的整个部署过程，但我们将涵盖以下主题:</p><ul class=""><li id="6565" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated">构建生产容器映像，</li><li id="0cc9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated">使用docker-compose在模拟生产环境的堆栈中运行该映像。</li></ul><h2 id="ce85" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">尺寸很重要</h2><p id="9f4e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在一个集装箱化的世界里，占地面积小是至关重要的。事实上，您的图像将被无数次地构建、压缩、推送到注册表，并从该注册表中取出。更大的映像不仅需要更长的时间来完成所有这些操作，而且还会导致更高的成本，因为云提供商会收取存储和网络使用费！</p><p id="0890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么像<a class="ae kv" href="https://www.alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>这样的小型操作系统非常方便。Alpine是一个非常小的Linux发行版，专为运行容器化的应用程序而定制，力求占用空间尽可能小。压缩图像的大小是<a class="ae kv" href="https://hub.docker.com/_/alpine/tags" rel="noopener ugc nofollow" target="_blank">2MB多一点</a>。</p><p id="5593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go是构建容器化应用程序的完美选择。事实上，二进制文件是静态链接的，这使得将它们打包到一个容器中变得非常容易。您甚至可以构建一个只包含go二进制文件的映像(从头开始)，它仍然可以工作！</p><p id="b4a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用Alpine作为基础映像，因为当您调试一个正在运行的容器并附加到它时，拥有一个shell和其他命令是非常有用的。</p><h2 id="ef71" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">构建容器映像</h2><p id="a130" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">有多种方法可以构建符合OCI标准的容器映像，但是在本教程中，我们将使用Docker。为了保持我们的容器映像较小，我们将使用多阶段构建过程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多级码头建造</p></figure><ol class=""><li id="9e57" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">构建go二进制文件:我们使用官方的Go docker映像。为了启用缓存，我们首先下载go模块。这将创建一个可以跨构建重用的单独层，从而大大减少构建时间。然后，我们复制源代码并构建Go二进制文件。</li><li id="a6cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">构建生产映像:我们使用官方的Alpine映像和<strong class="ky ir">复制</strong>我们刚刚构建的go二进制文件<strong class="ky ir"> </strong> <code class="fe ns nt nu nv b">--from</code>前一层。</li></ol><p id="1ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的映像很小，因为它只包含Alpine OS和go二进制文件。没有任何构建工件(源代码、导入的包等。)都在最终图像中。</p><p id="3fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们将图像锁定到特定的版本。您希望尽可能精确，因为Docker图像标签是别名，可能会随着时间的推移指向不同的图像。确定特定的版本可以确保您拥有可重现的构建，这意味着如果某个给定的构建出现任何问题，您都可以自信地重现它。</p><h2 id="189e" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">定义我们的服务堆栈</h2><p id="ae28" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们有了自己的容器，我们希望在尽可能接近生产环境的环境中运行它。为了实现这一点，我们将使用docker-compose。<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Compose </a>是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令从配置中创建和启动所有服务。</p><p id="894a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的堆栈只需要2个服务:Postgres数据库和我们的微服务。我们可以使用Compose描述这个堆栈，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">stack.yml</p></figure><h1 id="9647" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">微服务</h1><p id="25a9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是我们的应用微服务。</p><p id="750e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它包括一个<strong class="ky ir">构建</strong>部分，告诉Compose在我们启动堆栈时构建容器。如果您修改了源代码，将会构建一个新的映像来反映这些更改。</p><p id="a55b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如在上一篇文章中提到的，我们使用<strong class="ky ir">环境</strong>变量来配置我们的应用程序，以指定Postgres数据库的主机名和密码。请注意，服务DNS名称来自堆栈中定义的服务名称。在这种情况下，Postgres可以通过<strong class="ky ir"> postgres </strong> DNS名称访问。</p><p id="5109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，容器不会将其端口导出到本地主机。因此，我们需要指定一个端口映射来访问端口8080上的服务。你可以在这里了解更多关于<a class="ae kv" href="https://docs.docker.com/compose/networking/" rel="noopener ugc nofollow" target="_blank"> Compose networking </a>的信息。</p><h2 id="054b" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">Postgres</h2><p id="f99a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是我们的Postgres数据库服务。我们使用Docker hub的官方图片。</p><p id="06b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于另一个服务，我们使用环境变量来指定密码。在生产部署中，配置管理器或其他方式(如Kubernetes secret)会提供这个环境变量。</p><p id="9db4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了初始化我们的数据库模式，我们依赖于容器化的数据库约定，并将我们的schema.sql挂载到<strong class="ky ir">/docker-entry point-initdb . d</strong>文件夹。你可以在这里阅读更多关于这个<a class="ae kv" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">机制的内容。</a></p><p id="0fdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用一个命名卷来存储Postgres数据。在本教程中，我们确保在重新启动之间擦除卷，但是您可以在重新启动之间保留卷以重用现有数据。</p><h2 id="3d6a" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">关于安全性的说明</h2><p id="e93b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在本教程中，我们使用Docker合成文件中的环境变量来提供数据库密码。为了方便起见，在源代码库中检查默认的数据库密码。然而，记住<strong class="ky ir">永远不要检查源代码库中的任何敏感信息</strong>。</p><p id="0316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，部署管道可以通过在Compose 文件中执行<a class="ae kv" href="https://docs.docker.com/compose/environment-variables/#substitute-environment-variables-in-compose-files" rel="noopener ugc nofollow" target="_blank">变量替换来设置数据库密码环境变量。一个更安全的方法是依靠一个秘密管理工具，例如</a><a class="ae kv" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>结合<a class="ae kv" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes secrets </a>或<a class="ae kv" href="https://docs.docker.com/engine/swarm/secrets/" rel="noopener ugc nofollow" target="_blank"> Docker secrets </a>。</p><h1 id="4ea7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">开发环境</h1><p id="c31e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在让我们来看看开发环境。唯一的根本区别是，我们不希望我们的微服务在堆栈中运行。我们希望使用我们最喜欢的IDE或其他方式来启动我们的服务。</p><p id="a929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然需要让Postgres数据库运行并可到达。事实上，production Postgres服务并不导出任何端口，因此从堆栈外部连接到它是不可能的。我们需要在开发模式下公开这个端口。</p><p id="330e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望我们可以通过创建另一个堆栈文件来表达这些差异:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">堆栈.开发. yml</p></figure><p id="17ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将这个文件与产品堆栈相结合来开始我们的开发堆栈。微服务的副本数量设置为0，因此堆栈中没有运行任何实例，Postgres服务将其端口暴露给主机。</p><p id="f0a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要启动我们的微服务实例，并使用环境变量对其进行配置，以从堆栈(可在localhost:5432上访问)连接到Postgres实例。</p><h1 id="28f9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">把它们包装在一起</h1><p id="09df" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们有了堆栈，我们需要使用方便的命令来启动和停止它们。为此，我们将使用一个很好的旧Makefile:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在可以使用以下命令:</p><ul class=""><li id="da31" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nd ly lz ma bi translated"><code class="fe ns nt nu nv b">make prod</code>:在localhost:8080上启动可以连接到您的微服务的生产环境，</li><li id="7757" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><code class="fe ns nt nu nv b">make dev</code>:启动dev环境，在这里可以连接到localhost上的数据库:5432。</li><li id="cd82" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nd ly lz ma bi translated"><code class="fe ns nt nu nv b">make stop</code>:优雅地停止任何堆叠。</li></ul><h1 id="7552" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">下一步是什么？</h1><p id="b327" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">既然我们已经介绍了生产和开发环境，我们将看看如何编写和容器化我们的集成测试<a class="ae kv" href="https://medium.com/better-programming/modern-rest-api-with-go-and-postgresql-7c916ce2816a" rel="noopener">！</a></p></div></div>    
</body>
</html>