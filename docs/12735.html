<html>
<head>
<title>Creating a Certificate Checker With .Net</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用创建证书检查器。网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-certificate-checker-with-net-3317b53f91da?source=collection_archive---------12-----------------------#2022-06-27">https://betterprogramming.pub/creating-a-certificate-checker-with-net-3317b53f91da?source=collection_archive---------12-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="41d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用ASP.NET最小API的SSL证书检查器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/102b91b0b8a1c8d39323ec3580a1a24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V7alrDiJ0PDkznzu"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">信用:unsplash.com</p></figure><p id="bb7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我经常需要快速检索关于监控和自动化场景的SSL证书的详细信息，所以我想我应该尝试编写一个简单的API来提供帮助。</p><p id="9b62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">API可用于以编程方式访问有关证书的详细信息，如通用名称或San，还可以与应用程序健康检查集成，以便在到期日期临近时提供警报。</p><h1 id="e553" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">正在检索证书</h1><p id="fb1b" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在。NET世界中，普遍接受的检索TLS证书的方式是使用带有自定义<code class="fe mo mp mq mr b">HttpClientHandler</code>的<code class="fe mo mp mq mr b">HttpClient</code>。请求启动处理程序的最快捷、最可靠的方式是向使用证书托管的网站发送<code class="fe mo mp mq mr b">HEAD</code>请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c320" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码存在一些问题，不适合大规模使用。</p><h2 id="4124" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">创建大量的HttpClients不是一个好主意</h2><p id="6131" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">即使您正在处理代码中的<code class="fe mo mp mq mr b">HttpClient</code>对象，线程池也会保持连接打开，以防处理后有任何数据包返回。如果你在大范围内这样做，那么你会很快耗尽可用的WebSockets。这个问题<a class="ae ng" href="https://www.aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/" rel="noopener ugc nofollow" target="_blank">在这里</a>有更好的解释。</p><p id="5f2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，引入了<code class="fe mo mp mq mr b">HttpClientFactory</code>来管理HttpClient实例的生命周期。</p><h2 id="6586" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">线程安全</h2><p id="e6a6" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果我们通过使用一个共享的<code class="fe mo mp mq mr b">HttpClient</code>实例来修复上面的代码，那么我们将会遇到线程安全的问题，因为同一个<code class="fe mo mp mq mr b">HttpClientHandler</code>实例将会被用来检查不同请求的证书。</p><p id="b33c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果同时检查两个不同的域，我们就不能确定每个证书的到期日期。</p><h2 id="6cd9" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">性能和节流</h2><p id="1f08" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">通常，证书不会经常更改，因此我们不需要在短时间内处理同一主机的请求。如果我们执行太多的请求，我们也可能被下游服务器限制或阻塞。</p><p id="9fa9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一节中，我将解释如何使用缓存来解决最后两个问题。</p><h1 id="46f5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">解决方案</h1><p id="c1b1" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在自定义证书提取处理程序检索到证书后，将创建一个证书存储来缓存证书。证书提取处理程序扩展了<code class="fe mo mp mq mr b">HttpClientHandler</code>并通过一个<code class="fe mo mp mq mr b">HttpClient</code>进行配置，它向被检查的主机发送<code class="fe mo mp mq mr b">HEAD</code>请求。</p><p id="2bf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mo mp mq mr b">HEAD</code>请求通过证书检查器服务发送，该服务将首先检查证书存储，查看是否已经有可用的证书，如果没有，则调用下游服务器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/7e36a3568267882e435ee6852ce2d09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njjZIKIwWS7tzj_Wh4a7-w.jpeg"/></div></div></figure><h2 id="0353" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">证书存储</h2><p id="c328" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我想解决的第一个问题是如何在提取之后存储证书，以及在执行检查之前/之后检索证书。一个简单的<code class="fe mo mp mq mr b">MemoryCache</code>是保持证书的快速线程安全的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="44d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">主机从<code class="fe mo mp mq mr b">requestUri</code>中提取出来，这样，如果不同的路径先前已经用于相同的主机，则可以重复使用证书检查。</p><h2 id="0b60" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">证书提取处理程序</h2><p id="2d91" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">创建一个定制的<code class="fe mo mp mq mr b">HttpClientHandler</code>实现来封装在请求后提取X509Certificate，并将其保存在证书存储中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="4c47" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">TLS证书</h2><p id="572d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我想从X509Certificate中提取一些我感兴趣的细节。我决定创建一个<code class="fe mo mp mq mr b">TlsCertificate</code>类来提取以下内容:</p><ul class=""><li id="05ef" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">发行人</li><li id="f4d5" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">科目</li><li id="72e2" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">常用名(这可以从主题中提取)</li><li id="764c" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">使用者替代名称/SANs(可以从证书扩展中提取)</li></ul><p id="1f78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提取这些细节的代码可以在<a class="ae ng" href="https://github.com/matt-bentley/Certificate.Checker/blob/main/Certificate.Checker/Models/TlsCertificate.cs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="94a2" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">证书检查服务</h2><p id="565e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">难题的最后一部分是一个服务，用于编排从证书存储中检索提取的证书，并将HTTP <code class="fe mo mp mq mr b">HEAD</code>请求发送到被检查的主机。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9801" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该服务检查最近是否已经为被检查的主机提取了证书。如果还没有可用的证书，则服务向主机发送一个<code class="fe mo mp mq mr b">HEAD</code>请求，并检索提取的证书。</p><h1 id="1060" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">把所有的放在一起</h1><p id="e9fe" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">既然已经创建了检查证书的组件，那么是时候创建一些API端点了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="f3a8" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">POST:/检查端点</h2><p id="482d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这个端点将总是返回一个<code class="fe mo mp mq mr b">200</code>响应，即使证书无效或者已经过期。</p><h2 id="78f6" class="mu ls iq bd lt mv mw dn lx mx my dp mb le mz na md li nb nc mf lm nd ne mh nf bi translated">GET: /validate端点</h2><p id="3066" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">此端点使用查询字符串，因此可以使用GET请求来调用它。如果证书无效或过期，端点将返回502错误网关。由于端点使用一个简单的GET请求，因此它可以很容易地连接到健康检查中来监控证书。</p><p id="9006" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我使用了最小的API，所以必须创建一个自定义的<code class="fe mo mp mq mr b">IResult</code>来处理返回的错误网关结果。我创建了一个简单的<code class="fe mo mp mq mr b">Check Result</code>类，它处理结果的序列化，并根据证书的有效性设置HTTP状态代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="1808" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">最后的话</h1><p id="1ce8" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">最终结果是一个REST API，它提取证书信息并验证有效期和域名。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/310dafc15b873ef949ccc0db3c53706b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ad0k2_rsXGm2to0X2lzBg.png"/></div></div></figure><p id="00d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望你觉得这个小应用有用。如果你想查看完整的代码，可以在这里找到<a class="ae ng" href="https://github.com/matt-bentley/Certificate.Checker" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>