<html>
<head>
<title>A New Way to Pass Data Between Fragments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种在片段之间传递数据的新方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-new-way-to-pass-data-between-fragments-a5d32acc34e7?source=collection_archive---------5-----------------------#2020-06-23">https://betterprogramming.pub/a-new-way-to-pass-data-between-fragments-a5d32acc34e7?source=collection_archive---------5-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="936a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Android片段中使用新的<strong class="ak">result listener API</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/babc560cf727b2d5782acdd4864db310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ApzTXNdh9ch3iu86"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="44c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从Android架构组件出现以来，Android开发变得更加简单和高效。另一方面，像真理的单一来源和单一活动这样的概念带来了巨大的转变。</p><p id="952a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样高质量的开发思路，开发者往往会从传统的活动转向有效的片段。这使得许多开发人员(在某些情况下包括我自己)在片段之间的数据通信方面处于一个棘手的位置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7288" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题</h1><p id="1341" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在没有任何引用(上下文、接口、共享视图模型或应用程序级实时数据)的情况下，将数据从一个片段传递到另一个片段似乎几乎是不可能的。但是如果你看得更深入一点，你会找到解决办法:<code class="fe mz na nb nc b">targetFragment</code>。</p><p id="5503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">targetFragment</code>提供了一种与后台堆栈中的片段进行通信的方式。不需要在源中引用任何目标。简单来说，<code class="fe mz na nb nc b">targetFragment</code>是一种分段实现<code class="fe mz na nb nc b">onActivityResult</code>功能的方式。</p><h2 id="7d07" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">它是如何工作的</h2><p id="c071" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们在父片段中调用<code class="fe mz na nb nc b">showOptionsDialog()</code>，它显示了一个带有选项列表的<code class="fe mz na nb nc b">OptionsDialogFragment</code>。我们在这里做的唯一新的事情是用请求代码设置目标片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="03c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要在需要接收数据的片段中实现<code class="fe mz na nb nc b">onActivityResult</code>。之后，剩下的唯一事情就是传递来自源片段的数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这很好。我们可以将数据传递给一个片段，而不引用它。但是问题是<code class="fe mz na nb nc b">targetFragment</code>的功能只有当源和目的片段都在同一个片段管理器上时才起作用。如果一个片段在<code class="fe mz na nb nc b">childfragmentmanager</code>上膨胀，那么<code class="fe mz na nb nc b">targetFragment</code>就不起作用了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e31b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><p id="c2ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">近十年后，Android团队开始关注这个问题。随着<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha04" rel="noopener ugc nofollow" target="_blank">Fragment 1.3.0-alpha04</a></code>的发布，现在每个<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/androidx/fragment/app/FragmentManager" rel="noopener ugc nofollow" target="_blank">FragmentManager</a></code>都实现了<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.android.com/reference/androidx/fragment/app/FragmentResultOwner" rel="noopener ugc nofollow" target="_blank">FragmentResultOwner</a></code>。这意味着<code class="fe mz na nb nc b">FragmentManager</code>可以作为片段结果的中央存储。</p><p id="4f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种改变允许各个片段通过设置片段结果并监听这些结果来相互通信，而不需要片段具有彼此的直接引用。不像<code class="fe mz na nb nc b">targetFragment</code>，它跨片段管理器工作。</p><h2 id="9cb5" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">它是如何工作的</h2><p id="85bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们看看如何在<code class="fe mz na nb nc b">FragmentManager</code>级别传递数据，然后在父节点和子节点<code class="fe mz na nb nc b">FragmentManagers</code>之间传递数据。为了将数据从源片段传递到目的片段，我们必须添加一个带有特定键的监听器。这里只调用由任何其他片段发布的带有这个键的包。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们需要检索数据的源片段中的侦听器</p></figure><p id="3e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，是时候传递来自源片段的数据了，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用setResult从源片段传递数据</p></figure><p id="520c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个片段都在同一个<code class="fe mz na nb nc b">FragmentManager</code>上时，这非常简单并且工作良好。<code class="fe mz na nb nc b">setResult</code>如果多次发布，总是将最新数据发送到目的地。如果在调用<code class="fe mz na nb nc b">setResult</code>时没有设置监听器，它将在指定监听器时存储数据和交付。最重要的是，记住您应该只声明一个带有特定键的侦听器。</p><p id="e8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子片段和父片段之间的交流呢？嗯，我们也有解决办法。从高层次来解释，子片段将数据传递给<code class="fe mz na nb nc b">childfragmentmanager</code>，然后它将数据传递给父片段。实现部分和上面类似。唯一的区别是我们需要将监听器添加到子片段管理器中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在子片段中设置侦听器</p></figure><p id="04a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。传递数据同上。我们需要用一个惟一的键和绑定的数据来调用<code class="fe mz na nb nc b">setResult</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fed4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0f1a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道我们都习惯于使用一个界面，共享的视图模型，以及更多的片段间交流的方式。但是取消<code class="fe mz na nb nc b">targetfragment</code>并引入片段结果API提供了一个平台原生的解决方案。它仍处于alpha阶段，我认为它在未来的日子里会非常有用，因为我们比以往任何时候都更关注面向片段的开发。</p><p id="1b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>