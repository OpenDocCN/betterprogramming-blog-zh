<html>
<head>
<title>Django 4.1: Where To Apply Async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django 4.1:在哪里应用异步</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-4-1-where-to-apply-async-c05f29ca2041?source=collection_archive---------4-----------------------#2022-09-01">https://betterprogramming.pub/django-4-1-where-to-apply-async-c05f29ca2041?source=collection_archive---------4-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">异步和同步进程的执行时间比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/038acd7b3411bd5014c6e87ff605e7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JY2eEsP5FJ8vqNDd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">瑞兰德·迪恩在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Django框架的未来发展中，一些激动人心的变化即将到来。一个显著的变化是更新了对异步数据访问操作和HTTP方法处理程序的支持。本文将回顾我创建的一些测试，并比较异步和同步流程的执行时间。</p><h1 id="62f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Django中同步和异步的区别</h1><p id="2599" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">同步编程遵循一组严格的序列(或者，换句话说，它按顺序执行)，其中操作按照严格的顺序一次执行一个。下面这段来自mendix.com大学的David Bevans的话很好地描述了同步编程:</p><blockquote class="mp mq mr"><p id="02fc" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">为了说明同步编程是如何工作的，想象一下电话。打电话时，一个人在说话，另一个人在听。当第一个人结束时，第二个人往往会立即回应。</p></blockquote><p id="f844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步编程允许多个相关操作同时运行，而无需等待前面的任务完成。我们将其描述为实现非阻塞架构的多线程模型。如果一个线程是空闲的并且可以执行一个操作，那么它会在暂停正在等待的操作的同时执行该操作。David Bevans对异步编程的另一个精彩描述是:</p><blockquote class="mp mq mr"><p id="4e23" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">发短信是一种异步的交流方式。一个人可以发送一条短信，收件人可以在空闲时回复。与此同时，发送方在等待响应时可能会做其他事情。</p></blockquote><p id="07b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，我们可以看出，如果正确利用，异步应该会带来显著的性能提升。</p><p id="aa6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django的核心是同步工作和执行，大约在3.0版本左右(当“twisted”、“channels”和“asyncio”等扩展开始流行时)，Django可以异步工作的想法开始显现。</p><p id="e7cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的研究，决定在哪里使用sync或async的最好方法是辨别视图(以及，通过扩展，我们希望通过该视图实现的目标)是I/O受限还是CPU受限。当处理I/O绑定问题时，应该使用异步。</p><h2 id="e8c9" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">环境和先决条件</h2><p id="22ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">测试之前，让我们回顾一下设置和一些重要注意事项。首先，一个显而易见的注意事项(但很重要):结果可能因IDE而异，每个人在他们的项目、后台进程和第三方软件中相关/使用的包的设置也不同。因此，如果您决定重新创建这些测试，您在这里看到的执行时间可能与您实现的时间相似，也可能不相似。</p><p id="72b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这些测试，我们使用Python 3.9作为解释器，PostgreSQL 13.6作为数据库系统。已安装的Python包如下:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="1503" class="mw lt iq nj b gy nn no l np nq">Django~=4.1<br/>psycopg2~=2.9.3<br/>hypercorn~=0.14.1</span></pre><p id="b844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">psycopg2充当我们的数据库适配器，hypercorn将为我们的环境模拟ASGI测试服务器。</p><p id="1233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会想，“是的，但是当我们的项目中已经有了asgi.py，为什么还要使用hypercorn呢？”的确，我们项目中的asgi.py包含了一个可调用的应用程序，可以被开发或生产中的任何asgi服务器使用。但是开发服务器不使用它(我们用<code class="fe nr ns nt nj b">runserver</code>命令调用它)，这就是hypercorn的用武之地。通过调用<code class="fe nr ns nt nj b">myproject.asgi:application</code>，服务器启动并准备在本地使用。</p><p id="bbaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重要提示</strong>:测量性能和执行时间的正确方法是通过<code class="fe nr ns nt nj b">TestCase</code>(或者功能更丰富的<code class="fe nr ns nt nj b">TransactionTestCase</code>)和测试模块/单元。但是我对测试中使用的<code class="fe nr ns nt nj b">AsyncRequestFactory</code>和<code class="fe nr ns nt nj b">AsyncClient()</code>有些担心。通读文档，似乎部分模拟了“异步”行为，其中异步函数被执行，然后过程回复到同步行为。</p><p id="3612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最真实/现实的测试方法是做一个简单的视图，并通过hypercorn的模拟ASGI服务器的URL调用它。参考文献[3]和[4]包含了更多关于“测试异步代码”和“高级测试主题”的信息，但是我可能遗漏了一些重要的上下文。</p><h2 id="cba9" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">型号</strong></h2><p id="b05a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于我们的测试，我们将尽可能保持我们的模型轻。我们使用的字段各不相同，但是模型中每个对象的数据大小即使不相同，也是相似的。</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="16eb" class="nx lt iq nj b be ny nz l oa nq">from django.db.models import Model, CharField, DateField, ForeignKey, CASCADE, ManyToManyField, TextField<br/>from django.utils.timezone import now<br/><br/>class CarParts(Model):<br/>    engine = TextField()<br/><br/>class Manufacturer(Model):<br/>    name = CharField(max_length=150)<br/><br/>class Store(Model):<br/>    location = CharField(max_length=150)<br/><br/>class Car(Model):<br/>    created_at = DateField(default=now)<br/>    store = ManyToManyField(Store)<br/>    car_parts = ForeignKey(CarParts, on_delete=CASCADE, null=True)<br/>    manufacturer = ForeignKey(Manufacturer, on_delete=CASCADE, null=True)</span></pre><p id="a6c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将对每个模型的50、500和1，500个对象进行查询和迭代，这样我们就可以跟踪它如何随着更多的数据而扩展。</p><h2 id="6f7b" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">测试</h2><p id="805c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们有两个从<code class="fe nr ns nt nj b">django.views</code>扩展基类<code class="fe nr ns nt nj b">View</code>的类视图，每个视图包含多个方法。Django不允许混合使用同步和异步方法。记住，sync实现了阻塞方法，而async实现了非阻塞方法。因此一个类视图将包含所有异步方法和其他同步方法。</p><p id="ddfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试将按以下顺序进行:</p><ol class=""><li id="1d5d" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr og oh oi oj bi translated">加载x个对象</li><li id="fe73" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">执行三次连续测试(多次测试以补偿可能导致性能下降的潜在IDE后台进程)</li><li id="98c8" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">分析</li></ol><h2 id="f64d" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">测试A:通过get和post方法使用ORM的CRUD循环</strong></h2><p id="2644" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要在视图中调用的全局函数(一个异步，另一个同步):</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="8127" class="nx lt iq nj b be ny nz l oa nq">async def async_iteration():<br/>    car_obj = Car.objects.all()<br/>    async for i in car_obj:<br/>        a_query = await i.store.afirst()<br/>    return car_obj<br/><br/>def sync_iteration():<br/>    car_obj = Car.objects.all()<br/>    for i in car_obj:<br/>        a_query = i.store.first()<br/>    return car_obj</span></pre><p id="e9a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的同步类:</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="b4ef" class="nx lt iq nj b be ny nz l oa nq">class PerformanceTestSync(View):<br/>    def get(self, request):<br/>        e_list = []<br/>        start = time.time()<br/>        for entry in Car.objects.all():<br/>            try:<br/>                a_query = entry.store.first()<br/>                b_query = CarParts.objects.filter(<br/>                    Q(engine__contains='engine') &amp; <br/>                    Q(car__manufacturer_id__gt=20)).first()<br/>            except (Exception, KeyError) as e:<br/>                print('Error during sync iteration: ', e)<br/>        co = sync_iteration()<br/>        for v in co:<br/>            e_list.append(v)<br/>        end = time.time()<br/>        print('Sync GET time: ', end - start)<br/><br/>    def post(self, request):<br/>        start = time.time()<br/>        engine = request.POST.get('engine')<br/>        name = request.POST.get('name')<br/>        location = request.POST.get('location')<br/>        try:<br/>            car_parts_obj = CarParts.objects.create(engine=engine)<br/>        except (CarParts.DoesNotExist, ObjectDoesNotExist, <br/>                Exception) as e:<br/>            print('CarParts failed to create: ', e)<br/>            car_parts_obj = None<br/>            pass<br/>        try:<br/>            manufacturer_obj = Manufacturer.objects.create(<br/>                                                 name=name)<br/>        except (Manufacturer.DoesNotExist, ObjectDoesNotExist,<br/>                             Exception) as e:<br/>            print('Manufacturer failed to create: ', e)<br/>            manufacturer_obj = None<br/>            pass<br/>        try:<br/>            store_obj = Store.objects.create(location=location)<br/>        except (Store.DoesNotExist, ObjectDoesNotExist, <br/>                Exception) as e:<br/>            print('Store failed to create: ', e)<br/>            store_obj = None<br/>            pass<br/><br/>        if car_parts_obj and manufacturer_obj:<br/>            try:<br/>                car_obj = Car.objects.create(<br/>                            car_parts=car_parts_obj, <br/>                            manufacturer=manufacturer_obj<br/>                          )<br/>                car_obj.store.add(store_obj)<br/><br/>            except (Car.DoesNotExist, ObjectDoesNotExist, <br/>                    Exception) as e:<br/>                print('Car failed to create: ', e)<br/>                pass<br/><br/>        end = time.time()<br/>        print('Sync POST time: ', end - start)<br/>        return HttpResponse("ok", status=200)</span></pre><p id="56a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的异步类:</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="4ac4" class="nx lt iq nj b be ny nz l oa nq">class PerformanceTestAsync(View):<br/>    async def get(self, request):<br/>        e_list = []<br/>        start = time.time()<br/>        async for entry in Car.objects.all():<br/>            try:<br/>                a_query = await entry.store.afirst()<br/>                b_query = await CarParts.objects.filter(<br/>                        Q(engine__contains='engine') &amp; <br/>                        Q(car__manufacturer_id__gt=20)).afirst()<br/>            except (Exception, KeyError) as e:<br/>                print('Error during async iteration: ', e)<br/>        co = await async_iteration()<br/>        async for v in co:<br/>            e_list.append(v)<br/>        end = time.time()<br/>        print('Async GET time: ', end - start)<br/><br/>        return render(request, 'demo_template.html')<br/><br/>    async def post(self, request):<br/>        start = time.time()<br/>        engine = request.POST.get('engine')<br/>        name = request.POST.get('name')<br/>        location = request.POST.get('location')<br/>        try:<br/>            car_parts_obj = await CarParts.objects.acreate(<br/>                                 engine=engine<br/>                                )<br/>        except (CarParts.DoesNotExist, ObjectDoesNotExist, <br/>                Exception) as e:<br/>            print('CarParts failed to create: ', e)<br/>            car_parts_obj = None<br/>            pass<br/>        try:<br/>            manufacturer_obj = await Manufacturer.objects.acreate(<br/>                                        name=name<br/>                                      )<br/>        except (Manufacturer.DoesNotExist, ObjectDoesNotExist, <br/>                Exception) as e:<br/>            print('Manufacturer failed to create: ', e)<br/>            manufacturer_obj = None<br/>            pass<br/><br/>        if car_parts_obj and manufacturer_obj:<br/>            try:<br/>                car_obj = await Car.objects.acreate(<br/>                                  car_parts=car_parts_obj, <br/>                                  manufacturer=manufacturer_obj<br/>                                )<br/>                if car_obj:<br/>                    try:<br/>                        await car_obj.store.acreate(<br/>                               location=location<br/>                              )<br/>                    except Exception as e:<br/>                        print('Couldnt add store object <br/>                               relations for m2m: ', e)<br/>            except (Car.DoesNotExist, ObjectDoesNotExist, <br/>                    Exception) as e:<br/>                print('Car failed to create: ', e)<br/>                pass<br/><br/>        end = time.time()<br/>        print('Async POST time: ', end - start)<br/>        return HttpResponse("ok", status=200)</span></pre><p id="1cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nr ns nt nj b">get()</code>方法中，我们遍历<code class="fe nr ns nt nj b">Car</code>模型中的对象，在循环中，我们用Q表达式进行一个简单的查询和一个有点复杂的查询。所有这些都包装在4.1中引入的新ORM接口中。最后，我们调用一个全局函数，该函数将迭代并返回<code class="fe nr ns nt nj b">queryset</code>，其条目将被追加到一个空列表中。</p><p id="bb4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，在<code class="fe nr ns nt nj b">post()</code>方法中，我们为我们的模型创建一些对象，并更新现有的数据。最后，我们会删除它们。通过请求从客户端接收post中的数据。删除本身可以是一种方法，更新也可以，但是为了简单起见，<code class="fe nr ns nt nj b">get</code>和<code class="fe nr ns nt nj b">post</code>将完成这个任务。</p><p id="e60a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会注意到在异步类中，我没有在m2m字段更新中使用<code class="fe nr ns nt nj b">.add</code>。这是因为(遗憾的是)我在文档中找不到它的异步改编版本，Django将其视为同步操作。因此，我做了一点变通，直接创建了<code class="fe nr ns nt nj b">Store</code>对象。</p><h1 id="90fa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">测试结果</strong></h1><p id="f565" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">50个对象的方法<code class="fe nr ns nt nj b">get()</code>(显示三次测试的平均值):</p><ul class=""><li id="b433" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr op oh oi oj bi translated">异步:~0.39832秒</li><li id="a940" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr op oh oi oj bi translated">同步:~0.29502秒</li></ul><p id="532d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为所有模型创建单个对象的方法<code class="fe nr ns nt nj b">post()</code>:</p><ul class=""><li id="0cf2" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr op oh oi oj bi translated">异步:~0.07699秒</li><li id="ad23" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr op oh oi oj bi translated">同步:~0.08299秒</li></ul><p id="0333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于500个对象的方法<code class="fe nr ns nt nj b">get()</code>:</p><ul class=""><li id="df6c" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr op oh oi oj bi translated">异步:~3.67973秒</li><li id="b2d5" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr op oh oi oj bi translated">同步:~2.39427秒</li></ul><p id="f54c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1500个对象的方法<code class="fe nr ns nt nj b">get()</code>:</p><ul class=""><li id="5c33" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr op oh oi oj bi translated">异步:~8.79098秒</li><li id="408d" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr op oh oi oj bi translated">同步:~6.26344秒</li></ul><p id="ea08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试的结论是这个测试多边形是CPU受限的，我们的异步没有被充分利用</p><h1 id="737d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">测试B: API通信</strong></h1><p id="c60e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于这个测试，您可能需要安装Python的“httpx”包。我第一次尝试Python的“requests”包，认为它有异步功能，但遗憾的是，它没有，所以“httpx”作为一个很好的替代物出现了。此外，还需要Python的内置“asyncio”包来从等待的函数调用中收集数据。最后，我们正在从“asyncio”导入“shield ”,以防止潜在的取消。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="f793" class="mw lt iq nj b gy nn no l np nq">pip install httpx<br/># Then in your view<br/>import httpx<br/>import asyncio<br/>from asyncio import shield</span></pre><p id="564b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用GET请求，我们将联系apilayer.com汇率的外部API。</p><p id="1868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:我使用的是免费订阅，作为测试目的的试用/演示，非常适合这次测试。具体来说，我在https://apilayer.com/marketplace/exchangerates_data-api上使用API。此外，它非常易于使用，甚至为多种编程语言调用其API提供了模板代码。</p><p id="a720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在提供的API集中，我们只使用一个，那就是:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="e767" class="mw lt iq nj b gy nn no l np nq">GET/timeseries</span></pre><p id="33f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标API允许我们从过去(最大)提取汇率。365天的周期)，这将导致冗长的响应，需要一些时间来汇集/发送。apilayer.com速度快，反应快，所以这次测试用了一整年的汇率。</p><p id="b174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，我们创建了一个同步和异步版本来执行API调用。如前所述，将进行三次连续测试，并显示平均值。</p><p id="8352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是基于API函数的视图:</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="684f" class="nx lt iq nj b be ny nz l oa nq">def api_exchange_sync():<br/>    url = "https://api.apilayer.com/exchangerates_data/timeseries"<br/><br/>    payload = {}<br/>    headers = {<br/>        "apikey": "[Insert your API key]"<br/>    }<br/><br/>    r = httpx.get(url, params={"start_date": "2016-01-02", <br/>                               "end_date": "2017-01-01"},<br/>                               headers=headers)<br/><br/>    return r.json()<br/><br/>async def api_exchange_async():<br/>    url = "https://api.apilayer.com/exchangerates_data/timeseries"<br/><br/>    payload = {}<br/>    headers = {<br/>        "apikey": "[Insert your API key]"<br/>    }<br/><br/>    async with httpx.AsyncClient(timeout=50.0) as client:<br/>        r = await client.get(url, params={"start_date": "2016-01-<br/>                             02", "end_date": "2017-01-01"},<br/>                             headers=headers)<br/><br/>    return r.json()</span></pre><p id="1928" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在AsyncClient上设置超时来防止<code class="fe nr ns nt nj b">httpx.ReadTimeout</code>错误。如果您按下重启API调用的按钮:p。</p><p id="3599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是基于同步和异步函数的视图:</p><pre class="kg kh ki kj gt ni nj nu bn nv nw bi"><span id="3b69" class="nx lt iq nj b be ny nz l oa nq">def append_data_sync(request):<br/>    start = time.time()<br/>    e_list = []<br/>    data = [api_exchange_sync()]<br/>    for k in data:<br/>        e_list.append(k)<br/>    end = time.time()<br/>    print('read_sync time: ', end - start)<br/>    return HttpResponse()<br/><br/>async def append_data_async(request):<br/>    start = time.time()<br/>    e_list = []<br/>    data = await asyncio.gather(*[api_exchange_async()])<br/>    for d in data:<br/>        e_list.append(d)<br/>    end = time.time()<br/>    print('read_async time: ', end - start)<br/>    return HttpResponse()</span></pre><h2 id="d899" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">测试结果</strong></h2><ul class=""><li id="24c0" class="ob oc iq ky b kz mk lc ml lf oq lj or ln os lr op oh oi oj bi translated">异步:~2.23437秒</li><li id="238c" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr op oh oi oj bi translated">同步:~3.30023秒</li></ul><p id="cc62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们遍历从API函数接收的数据列表时，我们将它们添加到一个列表中。来自<code class="fe nr ns nt nj b">asyncio.gather()</code>的未来物体被证明是有利的，我相信如果我们使用数据流，我们会更快。Async在这次测试中赢得了比赛。</p><h1 id="3884" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="d233" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们等待API响应时，Async派上了用场。我们设法更快地接收数据，并且更好地利用时间。当需要内部数据处理和通过ORM与DB通信时，Sync表现出色。</p><p id="2ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有必要等待，屏蔽，多线程，因此额外的速度同步得到。没有必要比较同步和异步哪个更快——因为这在很大程度上取决于我们想要做的事情的上下文。重要的是要认识到CPU受限和I/O受限的情况，以便正确地利用异步和同步。</p><p id="8e28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不需要对遇到的每个小延迟都使用异步。我认为，在决定实现异步方法之前，必须注意到一种延迟模式(在我们的开发过程中)。</p><p id="2e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django 4.1异步更新不是一个速度更新——我更愿意把它看作是一个允许我们覆盖更好和更多情况的更新。</p><h1 id="472e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><ol class=""><li id="5502" class="ob oc iq ky b kz mk lc ml lf oq lj or ln os lr og oh oi oj bi translated">mendix.com，<a class="ae kv" href="https://www.mendix.com/blog/asynchronous-vs-synchronous-programming/" rel="noopener ugc nofollow" target="_blank">https://www . mendix . com/blog/asynchronous-vs-synchronous-programming/</a>，《异步和同步编程的区别》，大卫·贝文斯</li><li id="c0da" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">djangoproject.com，<a class="ae kv" href="https://docs.djangoproject.com/" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/</a>，‘异步相关页面，相关4.1变更和站点’</li><li id="ca28" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">djangoproject.com，<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/en/4.0/topics/testing/tools/</a></li><li id="2e65" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">djangoproject.com，<a class="ae kv" href="https://docs.djangoproject.com/en/4.1/topics/testing/advanced/" rel="noopener ugc nofollow" target="_blank">https://docs . django project . com/en/4.1/topics/testing/advanced/</a></li></ol></div></div>    
</body>
</html>