<html>
<head>
<title>Best Practices in SwiftUI Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI合成的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-in-swiftui-composition-282b02772a24?source=collection_archive---------0-----------------------#2019-06-15">https://betterprogramming.pub/best-practices-in-swiftui-composition-282b02772a24?source=collection_archive---------0-----------------------#2019-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1073fa970b258eda9e093e93a1588034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CmCi8YOsCOpkNnQz8tdew.png"/></div></div></figure><div class=""/><div class=""><h2 id="293d" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">关于SwiftUI视图组成、代码可读性和应用程序性能的一些想法</h2></div><p id="b34c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">SwiftUI将改变我们为iOS、iPadOS、macOS、tvOS和watchOS构建未来应用的方式。</p><p id="9b6b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是SwiftUI的全部影响不仅仅在于消除UIKit和用UIViews交换视图，或者用UITableViews交换列表，或者甚至完全消除对UIConstraints和UIView锚点的需求。</p><p id="4527" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也不在于我们的应用程序将通过消除故事板、IBOutlets、IBActions、Segues和所有其他长期束缚我们应用程序的相关样板文件来实现戏剧性的简化。更不用说清除那些由于意外断开插座和动作而潜伏在代码深处的错误了。</p><p id="6cb0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不要误解我。SwiftUI将为我们提供所有这些好处。还有更多。但从我的角度来看，SwiftUI的主要影响不在于我们如何构建我们的应用程序界面…</p><p id="d999" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">而是在于我们如何<em class="lp">设计</em>我们的应用程序。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a4cb" class="lx ly je bd lz ma mb mc md me mf mg mh kk mi kl mj kn mk ko ml kq mm kr mn mo bi translated">SwiftUI查看最佳实践</h1><p id="69d5" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">关于视图模型和视图状态管理，我有很多要说的。事实上，对于几篇文章来说绰绰有余。</p><p id="2d67" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是今天我将重点关注我认为在<em class="lp">编码</em>我们的用户<em class="lp">界面</em>以及我们的视图和视图层次中的一些最佳实践。</p><ul class=""><li id="8751" class="mu mv je kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated"><strong class="kv jf">查看构图</strong></li><li id="2947" class="mu mv je kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv jf">关注功能，而非外观</strong></li><li id="3384" class="mu mv je kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv jf">使用语义颜色</strong></li><li id="9226" class="mu mv je kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv jf">考虑其他平台的架构师</strong></li><li id="b138" class="mu mv je kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv jf">让系统做它该做的事情</strong></li><li id="ca6b" class="mu mv je kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv jf">绑定层级尽可能低的状态</strong></li></ul><p id="3aac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">准备好了吗？让我们开始吧…</p><h2 id="f7b8" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">查看合成</h2><p id="fd91" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">如果说在WWDC SwiftUI会议期间有一件事被反复提及，那就是swift ui视图是极其轻量级的，创建它们几乎没有性能损失。</p><p id="e148" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">与UIKit中的UIViews不同，大多数SwiftUI视图作为Swift结构存在，并作为值参数被创建、传递和引用。虽然在这个时候这可能会有一些不想要的<a class="ae nu" href="https://medium.com/better-programming/swiftui-101-how-not-to-initialize-bindable-objects-6e539d1b5344" rel="noopener">分支</a>，但是结构的使用避免了过多的内存分配和许多重子类和基于动态消息传递UIKit的UIViews的创建。</p><p id="16de" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，与UIView不同的是，在布局和显示周期中，嵌套SwiftUI视图上的参数和修饰符被合成到一个实体中。此外，视图树中的节点会被监控状态变化，如果没有变化，通常不需要重新呈现。</p><p id="a760" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">另一方面，每一个UIView都是作为布局渲染树上某处的链接子视图来分配和存在的，并且是布局过程的活动部分。</p><p id="5a13" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有这些都意味着，在SwiftUI中，您可以根据应用程序的需要创建尽可能多的独特和特殊用途的视图，这是您的独特优势。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="5e6d" class="ni ly je oa b gy oe of l og oh">struct FootnoteText : View {<br/>    let text: String<br/>    var body: some View {<br/>        MultiLineText(text: text, alignment: .center)<br/>            .font(.footnote)<br/>    }<br/>}</span><span id="0229" class="ni ly je oa b gy oi of l og oh">struct MultiLineText: View {<br/>    var text: String = ""<br/>    var alignment: HAlignment = .leading<br/>    var body: some View {<br/>        Text(text)<br/>            .lineLimit(nil)<br/>            .multilineTextAlignment(alignment)<br/>    }<br/>}</span></pre><p id="caba" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在上面的例子中，MultiLineText视图可能会在整个应用程序中经常使用。脚注视图只是附加了特定字体修饰符的专用多行文本。</p><p id="99f4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，在整个应用程序中，您可以简单地引用…</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="462c" class="ni ly je oa b gy oe of l og oh">FootnoteText(text: $model.disclamer)</span></pre><p id="2302" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">…根据需要，而不是在代码中分散以下内容:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="06c3" class="ni ly je oa b gy oe of l og oh">Text($model.disclamer)<br/>    .lineLimit(nil)<br/>    .multilineTextAlignment(.center)<br/>    .font(.footnote)</span></pre><p id="1ca0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">像<em class="lp"> FootnoteText </em> more <em class="lp"> </em>这样一个恰当命名的视图正式地向任何后来阅读你的代码的人宣布你的意图。</p><p id="da92" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">小的、包含良好的视图也更容易推理，并且不太可能包含错误和无意的副作用。</p><p id="2202" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从Smalltalk剧本中可以看出，在将功能委托给另一个功能之前，许多功能似乎都由一两行代码组成……而另一个功能反过来做同样的事情。</p><p id="565f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp"> UIKit的核心设计理念是传承。</em></p><p id="12bf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp"> SwiftUI的是作文。</em></p><h2 id="0fa5" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">关注功能，而不是外观</h2><p id="763e" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">突击测验，在下面的代码中，文本是什么颜色的？</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="7233" class="ni ly je oa b gy oe of l og oh">Text($model.disclamer)<br/>    .foregroundColor(.red)<br/>    .foregroundColor(.green)</span></pre><p id="d33e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">(背景播放危险音乐……)</p><p id="c0c9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">回答？文本为. red。在这种情况下，最接近的值绑定到视图。</p><p id="915c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这意味着什么呢？嗯，您可能会尝试将第一个示例中的脚注文本指定为:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="7be2" class="ni ly je oa b gy oe of l og oh">struct FootnoteText : View {<br/>    let text: String<br/>    var body: some View {<br/>        MultiLineText(text: text, alignment: .center)<br/>            .foregroundColor(.gray)<br/>            .font(.footnote)<br/>    }<br/>}</span></pre><p id="0ce6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你指定的颜色是灰色，因为这是你一直想要的颜色。但问题是你现在被它困住了，并试图…</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="d6ac" class="ni ly je oa b gy oe of l og oh">FootnoteText(text: $model.disclamer)<br/>    .foregroundColor(.red)</span></pre><p id="1102" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">仍然产生灰色文本。现在我们的例子中还有很多其他问题，比如我们可能因为指定了一个特定的单一文本颜色值而搞砸了自动黑暗模式适应，我们也可能搞砸了在其他具有不同外观和配色方案的平台上使用FootnoteText视图的可能性。</p><p id="f4aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，在视图组件中不要使用纯粹的视觉外观修饰符。尤其是颜色。</p><h2 id="8d50" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">使用语义颜色</h2><p id="9a40" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">但是如果你一定要设置颜色，强烈考虑使用语义颜色。</p><p id="e5e4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe oj ok ol oa b">Color.primary</code>、<code class="fe oj ok ol oa b">Color.secondary</code>、<code class="fe oj ok ol oa b">Color.accentColor</code>都只是系统和环境提供的颜色的例子。即使是像<code class="fe oj ok ol oa b">.orange</code>这样的颜色，也能够并将适当地适应明暗模式，在这个过程中略有变化。</p><p id="9037" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您也可以在Xcode中定义自己的语义颜色。和苹果一样，你甚至可以调整它们的明暗模式。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7c596ac187d1cfb17fc0174782f5295c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*dqEjrMe5UkgHhINEgMR6qw.png"/></div></figure><p id="f536" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这种方法的好处是，您可以在一个地方轻松地更改应用程序范围内的配色方案和品牌。您甚至可以修改每个平台的方案，而无需更改代码，只需在该平台的xcassets目录中提供不同的颜色集。</p><p id="db57" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">说到这个…</p><h2 id="d9e9" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">考虑其他平台的架构</h2><p id="5bee" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">有了SwiftUI，获取相同的代码并跨平台使用变得前所未有的简单。在某种程度上，您可以在将模型、API代码和业务逻辑从一个平台移植到另一个平台之前做到这一点，但是现在完全可以跨平台使用许多UI元素。</p><p id="227f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这一点在WWDC苹果<a class="ae nu" href="https://developer.apple.com/videos/play/wwdc2019/240/" rel="noopener ugc nofollow" target="_blank">所有设备</a>上的SwiftUI展示中显而易见。</p><p id="8378" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于本演示对此做了很好的介绍，所以我不会详细介绍，但请记住，iOS应用程序和iPadOS应用程序以及macOS应用程序和tvOS应用程序之间的许多跨平台用户界面共享都来自于将您在一个平台上创建的相同内容视图插入到另一个平台上的不同导航结构中。</p><p id="775e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，再次考虑您可能想要在哪里指定诸如字体、颜色之类的东西。SwiftUI有几种机制来提供或延迟那些规范。</p><p id="f042" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们上面讨论了语义颜色，但这里还有一个例子。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="e378" class="ni ly je oa b gy oe of l og oh">Group {<br/>    MyCustomTextField($model.username)<br/>    MyCustomTextField($model.password)<br/>    }<br/>    .font(.headline)<br/>    .background(Color.white.opacity(0.5))<br/>    .relativeWidth(1)</span></pre><p id="f298" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Group是一个强大的工具，它可以让您很好地将需要一起操作的事物分组，或者在这种情况下，将具有共同属性的事物分组。</p><p id="a2e2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这个示例中，组修饰符被应用到每个<code class="fe oj ok ol oa b">MyCustomTextField</code> <em class="lp">、</em>中，因此每个修饰符将选择标题字体、背景颜色，并调整到父容器的全宽。</p><p id="2f45" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe oj ok ol oa b">MyCustomTextField </code>处理功能性。让上下文来处理风格。</p><h2 id="d811" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">让系统做它的事情</h2><p id="fe49" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">还要记住，SwiftUI会自动将视图转换成适合给定平台的可视化界面元素。例如，Toogle视图在iOS、macOS、tvOS和watchOS上的渲染方式不同，但却是正确的。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7a90f2822490e9db2a2acd751c450dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*TLLGVjDqGimtjmidd_wKnA.png"/></div></figure><p id="1afd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，SwiftUI将基于平台、当前屏幕和/或容器大小、控件状态适当地调整颜色、间距、填充等。它还会考虑可能启用的任何辅助功能所需的任何更改，为亮/暗模式做正确的事情，等等。</p><p id="7ca5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">随便举一个例子，段落文本填充在iOS上是一种方式，但在iPad屏幕上往往会有更多的边框空间……除非你的内容现在被压缩，出现在滑动视图中。说实话，我们并不总是会考虑很多因素。</p><p id="1472" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在UIKit中，我们可能只是将值15插入到故事板的约束字段中，然后继续前进。</p><p id="b30c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这对我们此时此地的意义在于，我们需要放松，让系统发挥作用。不要纠结于试图匹配像素完美的设计布局，这种布局通常是为默认辅助功能模式的特定屏幕尺寸上的单个“最佳情况”布局而创建的。</p><p id="1139" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从web开发人员那里得到启示，他们已经从高度僵化的设计布局转向高度响应的布局，非常适合每个平台和个人用户的需求。</p><p id="e780" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这可能意味着要和你的UI/UX设计团队进行几次对话。</p><p id="b997" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">苹果费了很大的劲来确保SwiftUI在正确的时间做正确的事情，只要我们不挤它的胳膊肘。所以不要。</p><p id="ae10" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我想在这里说清楚。我也没说你不能。苹果给了我们很多展示的控制权。我们只需要知道什么时候放手，把特例留给<em class="lp">非常</em>特例。</p><p id="5953" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让系统做它该做的事情，你不仅会写更少的代码，而且我敢打赌你也会有更少的错误。</p><h2 id="43d5" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">将状态绑定到尽可能低的层次中</h2><p id="e699" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">如前所述，我将把我关于视图模型和状态管理的大部分想法留到以后的文章中去，但是这个概念与迄今为止展示的例子相吻合，所以我将用这一篇文章来结束。</p><p id="4ef6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在下面的代码中观察我们可信的<code class="fe oj ok ol oa b">FootnoteText </code>视图。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="933a" class="ni ly je oa b gy oe of l og oh">struct MyMainView : View {<br/>    @ObservedObject var model: MainViewModel<br/>    @EnvironmentObject var settings: UserSettings<br/>    var body: some View {<br/>        VStack {<br/>            MainContentView(model)<br/>            MainContentButtons(model)<br/>            FootnoteText(text: settings.fullVersionString)<br/>        }<br/>    }<br/>}</span></pre><p id="ed7d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，<code class="fe oj ok ol oa b">MyMainView </code>正在自动导入一个名为<em class="lp">设置</em>的环境对象，并将<code class="fe oj ok ol oa b">settings.fullVersionString</code> <em class="lp"> </em>传递给我们的<code class="fe oj ok ol oa b">FootnoteText </code>视图。</p><p id="9212" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一切都很好……但是为什么<code class="fe oj ok ol oa b">MyMainView </code>知道<code class="fe oj ok ol oa b">UserSettings </code>呢？如果我们做以下事情会怎么样？</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="c920" class="ni ly je oa b gy oe of l og oh">struct MyMainView : View {<br/>    @ObservedObject var model: MainViewModel<br/>    var body: some View {<br/>        VStack {<br/>            MainContentView(model)<br/>            MainContentButtons(model)<br/>            ApplicationVersionFootnote()<br/>        }<br/>    }<br/>}</span></pre><p id="1c0b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">并在别处将<code class="fe oj ok ol oa b">ApplicationVersionFootnote </code>定义为…</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="b233" class="ni ly je oa b gy oe of l og oh">struct ApplicationVersionFootnote : View {<br/>    @EnvironmentObject var settings: UserSettings<br/>    var body: some View {<br/>        FootnoteText(text: settings.fullVersionString)<br/>    }<br/>}</span></pre><p id="a916" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里，我们的环境变量被获取并在视图层次结构的较低位置使用。<code class="fe oj ok ol oa b">MyMainView </code>对<code class="fe oj ok ol oa b">UserSettings</code>一无所知，也不应该在乎。就此而言，<code class="fe oj ok ol oa b">MainViewModel</code>也没有。</p><p id="e981" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">后一点很关键。一段时间以来，我们试图通过采用某种形式的视图模型结构来避免大规模视图控制器综合症，无论是MVVM、VIPER还是其他什么。</p><p id="4d27" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，除非我们非常小心，否则我们所能做的就是用大视野<em class="lp">模型</em>替换我们的大视野<em class="lp">控制器</em>。</p><p id="2147" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在一个更传统的MVVM实现中，我们的<code class="fe oj ok ol oa b">UserSettings </code>对象可能会被注入到我们的<code class="fe oj ok ol oa b">MainViewModel</code>中，并且创建一些函数或变量或绑定来在我们的视图模型上公开<code class="fe oj ok ol oa b">fullVersionString </code>。这使我们的视图模型变得复杂，使我们的注入策略和初始化代码变得复杂，并使我们的应用程序组件更加紧密耦合和严格。</p><p id="8794" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是在我们最后的例子中，我们的<code class="fe oj ok ol oa b">ApplicationVersionFootnote </code>视图<em class="lp"> </em>实际上是一个小型的、高度特定的、特殊用途的视图<em class="lp">模型</em>，它将我们的环境<code class="fe oj ok ol oa b">UserSettings </code>数据耦合到一个<code class="fe oj ok ol oa b">FootnoteText </code>视图。</p><p id="9e39" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我认为这类事情在未来有很大的潜力，这非常符合SOLID的单一责任原则。</p><p id="e316" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">更新:请参阅我关于SwiftUI微服务的文章。</p><h2 id="0c57" class="ni ly je bd lz nj nk dn md nl nm dp mh lc nn no mj lg np nq ml lk nr ns mn nt bi translated">完成块</h2><p id="2b72" class="pw-post-body-paragraph kt ku je kv b kw mp kf ky kz mq ki lb lc mr le lf lg ms li lj lk mt lm ln lo im bi translated">你觉得怎么样？重点？不同意？我错过了什么吗？</p><p id="9675" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一如既往，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>