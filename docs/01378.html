<html>
<head>
<title>Angular Dependency Injection Provider Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度依赖注入提供程序对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-dependency-injection-provider-objects-f7dc363acc6c?source=collection_archive---------11-----------------------#2019-09-04">https://betterprogramming.pub/angular-dependency-injection-provider-objects-f7dc363acc6c?source=collection_archive---------11-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7081" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用角度依赖注入提供程序对象及其重要性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/582a4a3f92246ae758016aa0b4fa59bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXMVLKdGpcOMu42h5Pdx9Q.png"/></div></div></figure><p id="c0c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们将讨论角度依赖注入提供程序对象在角度应用程序中的重要性，以及如何在不同的情况下使用不同的角度依赖注入提供程序对象。</p><p id="b48e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过一个真实的应用程序用例来理解这一点。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="afce" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">用例</strong></h1><p id="af2d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在我们的角度应用程序中，我们有一个角度服务类<code class="fe mu mv mw mx b">app-service.ts</code>。它内部编写了一些方法来提供指定的功能。</p><p id="1196" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该类在根组件级<code class="fe mu mv mw mx b">app.module.ts</code>提供，使其可用于所有功能模块。</p><p id="219c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="eb48" class="nc ly it mx b gy nd ne l nf ng">@NgModule({</span><span id="7e6d" class="nc ly it mx b gy nh ne l nf ng">declarations: [ AppComponent ],</span><span id="a0e9" class="nc ly it mx b gy nh ne l nf ng">providers: [ AppService ],</span><span id="2585" class="nc ly it mx b gy nh ne l nf ng">})</span><span id="8f8d" class="nc ly it mx b gy nh ne l nf ng">export class AppModule { }</span></pre><p id="6ff3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设这个服务在1000个不同的应用程序组件中使用，因为应用程序变得越来越大，以服务于每个组件各自的数据。</p><p id="6546" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4bab" class="nc ly it mx b gy nd ne l nf ng">export class AppComponent implements OnInit {</span><span id="3833" class="nc ly it mx b gy nh ne l nf ng">constructor(private service: AppService){}</span><span id="df2f" class="nc ly it mx b gy nh ne l nf ng">}</span></pre><p id="b83e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">过了一段时间后，我们决定编写一个不同版本的服务，名为<code class="fe mu mv mw mx b">app-service-v1.ts</code>,对现有的方法功能进行了重大修改，但使用了相同的方法签名。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1310" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">问题</strong></h1><p id="f545" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在，我们希望这个新服务能够在所有有<code class="fe mu mv mw mx b">app-service.ts</code> <strong class="kw iu"> </strong>的地方实现。</p><p id="7177" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们不想放弃旧版本，因为如果项目在任何后期阶段需要，我们可能不得不切换回旧版本。</p><p id="0144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，我们该怎么做？</p><p id="f7ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有什么想法吗？</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3f88" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">解决方案</strong></h1><h2 id="8be4" class="nc ly it bd lz ni nj dn md nk nl dp mh ld nm nn mj lh no np ml ll nq nr mn ns bi translated"><strong class="ak"> 1。解决这个问题的一种方法</strong></h2><p id="8a87" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果我们考虑在根级别导入新服务<code class="fe mu mv mw mx b">app-service-v1.ts</code> <strong class="kw iu"> </strong>并在每个组件级别进行更改，我们必须记住我们有1000个地方来合并这些更改，根据应用程序的大小，这个数字可以更高。</p><p id="18da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们在完成了到最新版本的迁移后，被要求切换回以前的版本，该怎么办呢？</p><p id="86e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><p id="5a58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先前版本:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8b64" class="nc ly it mx b gy nd ne l nf ng">export class AppComponent implements OnInit {</span><span id="a956" class="nc ly it mx b gy nh ne l nf ng">constructor(<strong class="mx iu">private service: AppService</strong>){}}</span></pre><p id="fb8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最新版本:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="53e6" class="nc ly it mx b gy nd ne l nf ng">export class AppComponent implements OnInit {</span><span id="b51e" class="nc ly it mx b gy nh ne l nf ng">constructor(<strong class="mx iu">private service: AppServiceV1</strong>){}}</span></pre><h2 id="7e23" class="nc ly it bd lz ni nj dn md nk nl dp mh ld nm nn mj lh no np ml ll nq nr mn ns bi translated"><strong class="ak"> 2。另一种方法:角度依赖注入提供者</strong></h2><p id="08a6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在这种情况下，根级模块将如下所示:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a073" class="nc ly it mx b gy nd ne l nf ng">@NgModule({</span><span id="ed59" class="nc ly it mx b gy nh ne l nf ng">declarations: [ AppComponent ],</span><span id="c950" class="nc ly it mx b gy nh ne l nf ng">providers: [{ <strong class="mx iu">provide: AppService, useClass: AppServicev1</strong>}],</span><span id="3e09" class="nc ly it mx b gy nh ne l nf ng">})</span><span id="175d" class="nc ly it mx b gy nh ne l nf ng">export class AppModule { }</span></pre><p id="df3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们就完成了向新服务的迁移。</p><p id="d4e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有点像:我会一直要求<code class="fe mu mv mw mx b">AppService</code>，你却给我提供<code class="fe mu mv mw mx b">AppServicev1</code>。</p><p id="67d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nt">Angular Provider Object Literal</em>为我们如何在组件中接收服务类的实例带来了很多变化。</p><p id="f100" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular的两个流行的依赖注入提供者是:</p><ol class=""><li id="773a" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">别名提供者(如上所述)。</li><li id="0cb3" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">价值提供者。</li></ol><p id="9dbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有时，提供一个虚拟对象或现成的对象比提供一个实际的服务实例更有用。</p><p id="d2f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种技术通常用于为我们的应用程序编写<code class="fe mu mv mw mx b">unit-test</code>，我们不想使用实际的服务方法进行测试，这可能会对我们的后端服务进行实时<code class="fe mu mv mw mx b">HTTP</code> <strong class="kw iu"> </strong>调用。</p><p id="4593" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">Unit-test</code>模块示例:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d038" class="nc ly it mx b gy nd ne l nf ng">describe(‘TestLoginService’, () =&gt; {</span><span id="6b30" class="nc ly it mx b gy nh ne l nf ng"><strong class="mx iu">let service</strong> = {</span><span id="a641" class="nc ly it mx b gy nh ne l nf ng">login : ()=&gt; of({})};</span><span id="bb55" class="nc ly it mx b gy nh ne l nf ng">beforeEach(() =&gt; {</span><span id="5e7d" class="nc ly it mx b gy nh ne l nf ng">TestBed.configureTestingModule({</span><span id="f33e" class="nc ly it mx b gy nh ne l nf ng"><strong class="mx iu">providers: [{ provide: LoginService, useValue: service </strong>}]</span><span id="9425" class="nc ly it mx b gy nh ne l nf ng">imports: [HttpClientTestingModule] }); }); });</span></pre><p id="315d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章有助于增强您对角度依赖注入提供者的理解。</p><p id="5f38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nt">作者Amit实验室的Amit Yadav</em></p></div></div>    
</body>
</html>