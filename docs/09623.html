<html>
<head>
<title>7 Code Patterns in Go I Can’t Live Without</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中我不能没有的7种代码模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-code-patterns-in-go-i-cant-live-without-f46f72f58c4b?source=collection_archive---------0-----------------------#2021-09-19">https://betterprogramming.pub/7-code-patterns-in-go-i-cant-live-without-f46f72f58c4b?source=collection_archive---------0-----------------------#2021-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">代码模式使你的程序更可靠，更有效，并使你的生活更轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8582923b051babcd4e4cf1e4bd0445e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WYQi-8-AFBmIC8bb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@xps?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7年来，我一直在开发EDR解决方案。</p><p id="9048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我必须编写既有弹性又高效的长期运行的系统软件。</p><p id="d7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这项工作中大量使用Go，我想分享一些最重要的代码模式，你可以依靠它们使你的程序更加可靠和高效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eecc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将地图作为一个集合使用</h1><p id="e063" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们经常需要检查一些东西的存在。例如，我们可能想检查一个文件路径/URL/ID以前是否被访问过。在这些情况下，我们可以使用<code class="fe mz na nb nc b">map[string]struct{}</code>。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/21a991dc20380094407b2a3d9664b416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0GYVejiTBawRZL_FKuiaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-set-go" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure><p id="d368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用空结构<code class="fe mz na nb nc b">struct{}</code>，意味着我们不希望map的值部分占用任何空间。有时人们使用<code class="fe mz na nb nc b">map[string]bool</code>，但是基准测试表明<code class="fe mz na nb nc b">map[string]struct{}</code> <a class="ae ky" href="https://itnext.io/set-in-go-map-bool-and-map-struct-performance-comparison-5315b4b107b" rel="noopener ugc nofollow" target="_blank">在内存和时间</a>上都表现得更好。</p><p id="5e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外值得一提的是，map操作通常被认为具有<code class="fe mz na nb nc b">O(1)</code>时间复杂度(<a class="ae ky" href="https://stackoverflow.com/questions/29677670/what-is-the-big-o-performance-of-maps-in-golang" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>)，但是go runtime并没有提供这样的保证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fbb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用chan struct{}同步Goroutines</h1><p id="b5f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">信道可以承载数据，但不是必须的。有时，我们只是出于同步的目的需要它们。</p><p id="9b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，通道携带一个数据类型<code class="fe mz na nb nc b">struct{}</code>，这是一个不占用空间的空结构。这与上一个地图示例中的技巧相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b50d55ef823d3bd859afa75c1f4523b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsG09La74LUt_7i5X1SrZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-chan_struct-go" rel="noopener ugc nofollow" target="_blank">要诀链接</a></p></figure><h1 id="fa84" class="mc md it bd me mf ne mh mi mj nf ml mm jz ng ka mo kc nh kd mq kf ni kg ms mt bi translated">使用Close来广播</h1><p id="ec5e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">继续前面的例子，如果我们运行多个<code class="fe mz na nb nc b">go hello(quit)</code>，那么我们可以关闭<code class="fe mz na nb nc b">quit</code>通道来广播信号，而不是发送多个<code class="fe mz na nb nc b">struct{}{}</code>到<code class="fe mz na nb nc b">quit</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/1a0829529b436ff6ac29a78152b7e694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wK0RRlIdJTD7-eLItTGtIA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用接近广播(<a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-broadcast-go" rel="noopener ugc nofollow" target="_blank">要点</a>)</p></figure><p id="5650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，关闭一个频道来广播信号适用于任意数量的goroutines，因此<code class="fe mz na nb nc b">close(quit)</code>也适用于前面的示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c19e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用零通道阻止选择情况</h1><p id="dc34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们需要在select语句中禁用某些情况，如下面的函数，它从事件源读取事件，并将事件发送到调度通道。(这类函数通常涉及到原始数据的处理，以形成事件对象，但这里我们开门见山)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/14a5af1039a692a81f988870c4ee8638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHmt4rQ0b7axtlxAb6T3Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-eventloop_naive-go" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure><p id="8b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望改进的地方:</p><ul class=""><li id="6f81" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">当<code class="fe mz na nb nc b">len(pending) == 0</code>时禁用<code class="fe mz na nb nc b">case s.dispatchC</code>,这样代码就不会死机</li><li id="061c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">当<code class="fe mz na nb nc b">len(pending) &gt;= maxPending</code>时禁用<code class="fe mz na nb nc b">case s.eventSource</code>以避免分配过多内存</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/217657e7e131ffaea04c56433d140c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0SfNmdH1IvAZ5BkdfRQmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-eventloop_improved-go" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure><p id="fe1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的技巧是使用一个额外的变量来打开/关闭原始通道，然后将该变量用于select情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/3bf76644c255b2b7c991598aa7845473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md35tLW4O3va0MCd1EhD_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用新变量启用/禁用选择案例</p></figure><p id="d0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告:注意不要同时禁用所有情况，否则for-select循环将停止工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="546f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从通道进行非阻塞读取</h1><p id="f778" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们希望提供“尽力而为”的服务。也就是说，我们希望信道是故意“有损耗”的。</p><p id="e22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当我们有过多的事件要发送给接收者，而其中一些可能没有响应时，这是有意义的。我们可以忽略那些没有响应的接收器:</p><ol class=""><li id="66c4" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu ob nr ns nt bi translated">及时发送给其他接收者</li><li id="1809" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu ob nr ns nt bi translated">避免为未决事件分配太多内存</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/aa5d181c12e3847411c8e03e7ed83a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eijA0u9emxaUVTWoOaFuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从通道进行非阻塞读取(<a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-nonblocking_read-go" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="771c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">匿名结构</h1><p id="80e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候我们只是希望一个容器来容纳一组相关的值，这种分组不会出现在其他任何地方。在这些情况下，我们不关心它的类型。在Python中，我们可能会为这些情况创建一个字典或元组。在Go中，你可以为这种情况创建一个匿名结构。我将用两个例子来说明。</p><h2 id="0b00" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">案例1:配置</h2><p id="a516" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，您希望将配置值分组到一个变量中。但是为它创建一个类型似乎有些矫枉过正。</p><p id="bb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以代替这个的是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d588bb3a6c2395c14e78dc641e41c15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AUnNpYzuQWOKE0-P-8b9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为配置变量创建一次性类型</p></figure><p id="a5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ca89d877698dfbc24f755f08b3925d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*g1kYZ5caQJ_Eyij_h-wj4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为配置变量使用匿名结构</p></figure><p id="4fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mz na nb nc b">struct {...}</code>是变量<code class="fe mz na nb nc b">Config</code>的类型——现在你可以通过<code class="fe mz na nb nc b">Config.Timeout</code>访问你的配置值。</p><h2 id="fb24" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">案例2:测试案例</h2><p id="89ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设你想测试你的奇特的<code class="fe mz na nb nc b">Add()</code>函数，而不是像这样写很多if-else语句:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f44ce0ab65237f87a3c87d0ccdde351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSivMFyN_jZZ7ClfkPPNgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试没有匿名结构的函数(<a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-add_test_naive-go" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="1fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像这样分离您的测试用例以及测试逻辑:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/083766679938d7880368ea9ea0ee6d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adnvw2JCHhO_ZgnjtflOQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用一部分匿名结构来声明测试用例</p></figure><p id="e65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您有许多测试用例时，或者当您有时需要改变测试逻辑时，这是值得的。</p><p id="35a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您肯定会在更多的场景中发现匿名结构。例如，当你想解析下面的JSON时，你可以定义一个嵌套匿名结构的匿名结构，这样你就可以用<code class="fe mz na nb nc b">encoding/json</code>库来解析它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/31411fac5e74115ccc14f2303d418acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiBmAU5vOkSduAzsvcSQKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要解析的一些嵌套JSON对象(<a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-exercise-json" rel="noopener ugc nofollow" target="_blank">要点</a>)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="389e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带功能的包装选项</h1><p id="b785" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时我们有一个复杂的结构，其中有许多可选字段，你真的很怀念在Python中使用可选参数的日子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/6b7d49425760619e62c23941fc9a967e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEQOY876RwVFLsQ-dJgJbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-optional_args-py" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure><p id="e573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最喜欢在Go中实现这一点的方法是使用函数包装这些选项(端口、代理)。也就是说，我们可以构造函数来应用我们的选项值，这些值存储在函数的闭包中。</p><p id="afc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的例子，我们有2个可选字段(端口、代理)，用户可以在创建<code class="fe mz na nb nc b">Client</code>实例时指定:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/c8e1bbdb636b43b91a0e6d383f9e2429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piiERiPSMD0X_tJi6aNFtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-options_func-go" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure><p id="a154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式包装选项便于使用，更重要的是，便于阅读:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9458f403a82b38a2f5bc8947367fc012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tB9fwWnJO1Nq5wSk3nKNig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/Happyholic1203/6e5e2455e9db5b09770d4f3727af75cc#file-using_options_func-go" rel="noopener ugc nofollow" target="_blank">要点链接</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7690" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fe79" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以我们讨论了</p><ul class=""><li id="8089" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">使用设置的<code class="fe mz na nb nc b"> map[string]struct{}</code></li><li id="57fc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">使用<code class="fe mz na nb nc b">chan struct{}</code>有效地同步go routine，并使用<code class="fe mz na nb nc b">close()</code>向任意数量的go routine广播信号</li><li id="2dc4" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将通道变量设置为<code class="fe mz na nb nc b">nil</code>以禁用选择案例</li><li id="f49c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">通过<code class="fe mz na nb nc b">select-default</code>模式构建有损信道</li><li id="8e5a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">使用匿名结构对配置值和测试用例分组</li><li id="f544" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将选项包装为功能</li></ul><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个经验丰富的Go程序员，那么你可能以前见过这些代码模式。然而，当我第一次开始用Go编程时，这一点对我来说一点也不明显。</p><p id="ac72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go是一种非常强大的语言，与我们熟悉的大多数语言(如C/C++、Python、PHP、Java等)相比，它有着完全不同的结构。所以正确使用它漂亮的语法是非常重要的，否则你可能会得到非常讨厌的错误，要么很难触发，要么你可能不知道它来自哪里。</p><p id="88a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试图用上面的代码模式来描绘Go的本质，但是它们还远远没有完成。要了解更多，我建议查看谷歌的<a class="ae ky" href="https://talks.golang.org/" rel="noopener ugc nofollow" target="_blank">精彩演讲。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="651f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步阅读</h1><ul class=""><li id="8f6c" class="nl nm it lb b lc mu lf mv li ov lm ow lq ox lu nq nr ns nt bi translated"><a class="ae ky" href="https://talks.golang.org/2013/advconc.slide#1" rel="noopener ugc nofollow" target="_blank">高级Go并发模式</a></li><li id="b24d" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://talks.golang.org/2012/10things.slide#1" rel="noopener ugc nofollow" target="_blank">你(可能)不知道的10件事Go </a></li><li id="dc7f" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://itnext.io/set-in-go-map-bool-and-map-struct-performance-comparison-5315b4b107b" rel="noopener ugc nofollow" target="_blank">在Go中设置，map[]bool和map[]struct{}性能比较</a></li></ul></div></div>    
</body>
</html>