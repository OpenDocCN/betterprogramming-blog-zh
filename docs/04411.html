<html>
<head>
<title>5 Front-End Interview Coding Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个前端面试编码挑战</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-front-end-interview-coding-challenges-6cd9f31d1169?source=collection_archive---------1-----------------------#2020-04-12">https://betterprogramming.pub/5-front-end-interview-coding-challenges-6cd9f31d1169?source=collection_archive---------1-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">求职面试中你可能会遇到的问题及其解决方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c1e431dbfcf7e966333b30c63a24da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GUXw_sZxaEPGbpiN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@headwayio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">车头</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">档</a>拍照</p></figure><p id="d9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去年，我面试了几家不同科技公司的软件工程师职位。因为大部分职位都是web开发，所以不出所料，我必须回答很多与客户端开发相关的问题。有些是简单的问题，如<a class="ae ky" href="https://github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md#explain-event-delegation" rel="noopener ugc nofollow" target="_blank"> <em class="lv">什么是活动委托？</em> </a>和<a class="ae ky" href="https://github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md#explain-how-prototypal-inheritance-works" rel="noopener ugc nofollow" target="_blank"> <em class="lv">继承是如何在Javascript中实现的？</em> </a>，还有一些更具挑战性的动手编程问题，我将在本文中分享我最喜欢的五个。</p><p id="700c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，面试成功的关键是做好准备。所以，不管你是在积极地面试，还是只是好奇在科技公司的前端面试中你可能会被问到什么样的问题，我希望这篇文章能帮助你为即将到来的面试做好准备。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="13d7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">目录</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a812" class="na me it mw b gy nb nc l nd ne">· <a class="ae ky" href="#8e35" rel="noopener ugc nofollow">1. Emulate Vue.js</a><br/>· <a class="ae ky" href="#b65c" rel="noopener ugc nofollow">2. async series and parallel</a><br/>· <a class="ae ky" href="#742b" rel="noopener ugc nofollow">3. Draggable button that changes the background color</a><br/>· <a class="ae ky" href="#08e0" rel="noopener ugc nofollow">4. slide-out animation</a><br/>· <a class="ae ky" href="#ceba" rel="noopener ugc nofollow">5. Giphy client</a></span></pre><h2 id="8e35" class="na me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">1.模拟Vue.js</h2><p id="c723" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">这个挑战是在一次电话采访中提出的。我被要求前往<a class="ae ky" href="https://vuejs.org/v2/guide/#Declarative-Rendering" rel="noopener ugc nofollow" target="_blank"> Vue.js文档</a>，并将以下片段复制到我选择的编辑器中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="654e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所想象的，我们的目标是让<code class="fe nx ny nz mw b">{{ message }}</code>被<code class="fe nx ny nz mw b">Hello Vue!</code>取代，当然，不需要添加Vue.js作为依赖项。</p><p id="081a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在你开始写代码之前，一定要向面试官澄清你对这个问题的任何疑问，确保你完全理解什么是输入，什么是输出，以及你需要考虑的任何边缘情况。</em></p><p id="4c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建我们的<code class="fe nx ny nz mw b">Vue</code>类，并将其添加到Javascript代码片段之上。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1cfe" class="na me it mw b gy nb nc l nd ne">class Vue {<br/>    constructor(options) {<br/>    }<br/>}</span></pre><p id="1591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了它，我们的小项目至少应该运行无误。</p><p id="496d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了用提供的文本替换模板字符串，最简单的方法可能是，一旦我们访问了<code class="fe nx ny nz mw b">#app</code>元素，就对其<code class="fe nx ny nz mw b">innerHTML</code>属性使用<code class="fe nx ny nz mw b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="noopener ugc nofollow" target="_blank">String.replace()</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了工作，但我们肯定可以做得更好。例如，如果我们有两个同名的模板字符串，这个实现就不会像预期的那样工作。只会替换第一次出现的内容。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a0ea" class="na me it mw b gy nb nc l nd ne">&lt;div id="app"&gt;<br/>  {{ message }} and {{ message }}, what's the {{ message }}<br/>&lt;/div&gt;</span></pre><p id="d683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很容易解决——我们使用带有全局标志<code class="fe nx ny nz mw b"><em class="lv">new RegExp(`{{ ${key} }}`, “g”)</em></code> <em class="lv"> </em>的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener ugc nofollow" target="_blank"> RegExp </a>来代替<code class="fe nx ny nz mw b">`{{ ${key} }}`</code>。</p><p id="8b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe nx ny nz mw b">innerHTML</code>很昂贵，因为值被解析为HTML。我们应该用<code class="fe nx ny nz mw b">textContent</code>或者<code class="fe nx ny nz mw b">innerText</code>。要了解这三者之间的更多区别，请点击<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="6570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地用<code class="fe nx ny nz mw b">innerText</code>或<code class="fe nx ny nz mw b">textContent</code>替换<code class="fe nx ny nz mw b">innerHTML</code>对我们的简单标记有效，但是一旦我们的标记变得更复杂，它很快就会失效:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e342" class="na me it mw b gy nb nc l nd ne">&lt;div id="app"&gt;<br/>  {{ message }}<br/>  &lt;p&gt; another {{ message }} inside a paragraph &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="7543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到<code class="fe nx ny nz mw b">&lt;p&gt;</code>标签将从DOM中移除。这是因为<code class="fe nx ny nz mw b">innerText</code>和<code class="fe nx ny nz mw b">textContent</code>只返回文本，当它被用作setter时，它只用文本替换标记。</p><p id="2591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理这个问题的一个方法是<a class="ae ky" href="https://en.wikipedia.org/wiki/Tree_traversal" rel="noopener ugc nofollow" target="_blank">遍历</a>DOM，找到所有的文本节点，然后替换文本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="32b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事我们应该改进。每当我们找到一个文本节点，我们就寻找模板字符串<em class="lv"> n </em>次(<em class="lv"> n，在本例中，</em>是数据条目的数量)。因此，如果我们有200个条目，即使我们的DOM节点看起来像这样:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="61df" class="na me it mw b gy nb nc l nd ne">&lt;p&gt;Nothing to see here&lt;/p&gt;</span></pre><p id="200d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然会迭代200次，试图找到模板字符串。</p><p id="7848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的一种方法是实现一个简单的状态机，它只查看文本一次，并在它运行时替换模板字符串(如果有的话):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这离生产就绪还差得很远，但你应该能在30-45分钟内完成。</p><p id="c546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一定要谈论你如何能进一步改进它，性能问题(好的segway来炫耀你的<a class="ae ky" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a>知识)，如果你能谈论你将如何实现<a class="ae ky" href="https://vuejs.org/v2/guide/#Conditionals-and-Loops" rel="noopener ugc nofollow" target="_blank">循环和条件</a>和<a class="ae ky" href="https://vuejs.org/v2/guide/#Handling-User-Input" rel="noopener ugc nofollow" target="_blank">处理用户输入</a>的加分。</p><p id="1052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到上面的代码在下面的沙箱中运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nw l"/></div></figure><h2 id="b65c" class="na me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">2.异步串联和并联</h2><p id="85ef" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJs </a>之前，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promises </a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank"> async/await </a>是行业标准，编写异步Javascript并不容易，你经常会成为<a class="ae ky" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>(又名末日金字塔)的受害者。正因为如此，像<a class="ae ky" href="http://caolan.github.io/async/v3/" rel="noopener ugc nofollow" target="_blank"> async </a>这样的库在那时被创建。</p><p id="a37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下两部分挑战发生在一次现场面试中。我被要求带上自己的笔记本电脑，所以我知道会有一个现场编码会议。</p><p id="09fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://caolan.github.io/async/v3/docs.html#series" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">async . series</strong></a><strong class="lb iu"><br/></strong><em class="lv">连续运行</em> <code class="fe nx ny nz mw b"><em class="lv">tasks</em></code> <em class="lv">集合中的函数，每运行一次前一个函数就完成一次。如果系列中的任何函数向其回调函数传递错误，则不再运行任何函数，并立即使用错误值调用</em> <code class="fe nx ny nz mw b"><em class="lv">callback</em></code> <em class="lv">。否则，当</em> <code class="fe nx ny nz mw b"><em class="lv">tasks</em></code> <em class="lv">完成时，</em> <code class="fe nx ny nz mw b"><em class="lv">callback</em></code> <em class="lv">接收一个结果数组。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建异步对象开始:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1380" class="na me it mw b gy nb nc l nd ne">const async = {<br/>    series: (tasks, callback) =&gt; {}<br/>};</span></pre><p id="9bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个挑战的主要问题是，我们需要确保一个功能接一个功能地执行。换句话说，我们只在前一个函数完成后执行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用一个变量<code class="fe nx ny nz mw b">i</code>来跟踪当前正在执行的函数，我们创建一个内部回调来检查错误，递增<code class="fe nx ny nz mw b">i</code>并执行下一个函数。</p><p id="14d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们不验证输入或者使用try/catch来更好地处理错误，但是你应该总是和你的面试官讨论这个问题。</p><p id="d8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://caolan.github.io/async/v3/docs.html#parallel" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">async . parallel</strong></a><strong class="lb iu"><br/></strong><em class="lv">并行运行</em> <code class="fe nx ny nz mw b"><em class="lv">tasks</em></code> <em class="lv">函数集合，无需等待前一个函数完成。如果任何一个函数向它的回调函数传递了一个错误，那么主函数</em> <code class="fe nx ny nz mw b"><em class="lv">callback</em></code> <em class="lv">就会立即被调用，并返回错误的值。一旦</em> <code class="fe nx ny nz mw b"><em class="lv">tasks</em></code> <em class="lv">都完成了，结果就作为一个数组传递给最后的</em> <code class="fe nx ny nz mw b"><em class="lv">callback</em></code> <em class="lv">。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从向异步对象添加一个新的并行函数开始:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c2ae" class="na me it mw b gy nb nc l nd ne">const async = {<br/>    series: (tasks, callback) =&gt; {}<br/>    parallel: (tasks, callback) =&gt; {}<br/>};</span></pre><p id="5bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并联不同于串联，因为我们可以同时启动所有的功能。我们只需要在收集结果的时候小心一点，这样它们就被放到了数组的正确位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="faa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个<code class="fe nx ny nz mw b">done</code>标志开始，它防止在出错后调用回调，还有一个<code class="fe nx ny nz mw b">count</code>标志，它跟踪已经完成了多少个函数，这样我们就知道什么时候停止。我们有一个内部回调，负责收集结果并调用用户的回调。最后，我们一次触发所有的功能。</p><p id="62f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终代码可从以下网址获得:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nw l"/></div></figure><h2 id="742b" class="na me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">3.改变背景颜色的可拖动按钮</h2><p id="9313" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在一次现场面试中，我被要求在屏幕中间实现一个可以拖动的按钮。当它向边缘移动时，背景颜色从白色变为红色。</p><p id="5adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们谈论一个可能的解决方案之前，请看这里的结果和代码<a class="ae ky" href="https://codesandbox.io/s/drag-to-change-background-color-57dvw" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="608d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建标记开始:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="355a" class="na me it mw b gy nb nc l nd ne">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="overlay"&gt;&lt;/div&gt;<br/>    &lt;div id="button" draggable="true"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;html&gt;</span></pre><p id="5f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz mw b">#overlay</code>将覆盖整个屏幕，它是我们用来改变背景颜色的元素。<code class="fe nx ny nz mw b">#button</code>是我们的可拖动按钮。</p><p id="bbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是CSS，用来设计按钮和覆盖的样式:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d236" class="na me it mw b gy nb nc l nd ne">#button {<br/>    cursor: pointer;<br/>    background-color: black;<br/>    width: 50px;<br/>    height: 50px;<br/>    border-radius: 50px;</span><span id="8371" class="na me it mw b gy ob nc l nd ne">    position: absolute;<br/>    top: 50%;<br/>    left: 50%;<br/>    transform: translateX(-50%) translateY(-50%);<br/>}</span><span id="ace0" class="na me it mw b gy ob nc l nd ne">#overlay {<br/>    background-color: red;<br/>    width: 100vw;<br/>    height: 100vh;<br/>    z-index: -1;<br/>    opacity: 0;<br/>}</span></pre><p id="ae05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们改变颜色的方法是通过叠加不透明度。默认情况下是<code class="fe nx ny nz mw b">0</code>(透明的)，我们会用javascript做相应的修改。</p><p id="e9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这次挑战中，我被允许使用任何我想要的库。我知道公司用的是<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>和<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>，所以我决定用。我们需要做两件主要的事情——订阅和处理拖动事件，并根据事件的X和Y坐标确定覆盖不透明度。</p><p id="cc86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过使用<code class="fe nx ny nz mw b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent" rel="noopener ugc nofollow" target="_blank">fromEvent</a></code>和<code class="fe nx ny nz mw b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/index/class/Observable#subscribe" rel="noopener ugc nofollow" target="_blank">subscribe</a></code>来处理前者。这完全可以用普通的Javascript来完成(见<code class="fe nx ny nz mw b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank">addEventListener</a></code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们<code class="fe nx ny nz mw b">filter</code>排除所有目标不是<code class="fe nx ny nz mw b">#button</code>的拖动事件，并且用<code class="fe nx ny nz mw b">distinctUntilChanged</code>抑制任何重复的事件。</p><p id="1006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决后者，我们需要做一些数学计算。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz mw b">event.clientY</code>和<code class="fe nx ny nz mw b">event.clientX</code>代表屏幕上可拖动按钮的位置。基于这些，我们需要计算一个介于0和1之间的数字作为覆盖的不透明度。</p><p id="3ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe nx ny nz mw b">x</code>和<code class="fe nx ny nz mw b">y</code>的最大值分别设置为<code class="fe nx ny nz mw b">window.innerHeight</code>和<code class="fe nx ny nz mw b">window.innerWidth</code>除以2。我们将<code class="fe nx ny nz mw b">x</code>和<code class="fe nx ny nz mw b">y</code>归一化为介于0和它们的最大值之间的值。最后，我们计算<code class="fe nx ny nz mw b">pY</code>和<code class="fe nx ny nz mw b">pX</code>(这将是0和1之间的值)，并用较高的值设置不透明度。</p><h2 id="08e0" class="na me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">4.滑出动画</h2><p id="d566" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">以我的经验，关于元素如何动画化的问题很常见。在这个例子中，每当单击一个元素时，我被要求在不使用CSS动画和过渡的情况下实现滑出动画。</p><p id="e7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从HTML开始:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8d2b" class="na me it mw b gy nb nc l nd ne">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="box"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;html&gt;</span></pre><p id="a605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和CSS:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6219" class="na me it mw b gy nb nc l nd ne">#box {<br/>    width: 50px;<br/>    height: 50px;<br/>    background-color: blue;<br/>}</span></pre><p id="d691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Javascript实现动画的方法不止一种。我推荐使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">window . request animation frame</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了一个点击事件监听器，这样每次点击<code class="fe nx ny nz mw b">#box</code>时，就会用元素和动画的持续时间调用<code class="fe nx ny nz mw b">slideOut</code>。</p><p id="4bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz mw b">slideOut</code>函数定义了<code class="fe nx ny nz mw b">translateX</code>变换的<code class="fe nx ny nz mw b">initial</code>和<code class="fe nx ny nz mw b">target</code>值。创建一个<code class="fe nx ny nz mw b">loop</code>并使用<code class="fe nx ny nz mw b">requestAnimationFrame</code>调用它。循环将一直执行，直到<code class="fe nx ny nz mw b">#box</code>到达屏幕末端。每一个新的<code class="fe nx ny nz mw b">value</code>都是用线性方程计算出来的。</p><p id="9f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的后续问题是:你如何实现一个<a class="ae ky" href="https://easings.net/en#" rel="noopener ugc nofollow" target="_blank">缓和函数</a>？</p><p id="a7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们已经有了<a class="ae ky" href="http://blog.moagrius.com/actionscript/jsas-understanding-easing/" rel="noopener ugc nofollow" target="_blank">所有的参数</a>我们需要用<a class="ae ky" href="http://robertpenner.com/easing/penner_chapter7_tweening.pdf" rel="noopener ugc nofollow" target="_blank"> Penner方程中的一个</a>来交换我们的线性方程。让我们看看easeInQuad:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ccae" class="na me it mw b gy nb nc l nd ne">easeInQuad = function (t, b, c, d) { return c*(t/=d)*t + b; };</span></pre><p id="b772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将第9行改为:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="3a62" class="na me it mw b gy nb nc l nd ne">const value = target * (time / duration) * (time / duration) + initial;</span></pre><p id="790c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里看到结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nw l"/></div></figure><p id="d4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对Javascript动画感兴趣，我写了一篇关于它的文章:</p><div class="oc od gp gr oe of"><a href="https://medium.com/better-programming/creating-a-proximity-graph-animation-an-introduction-to-html5-canvas-and-the-animation-loop-45719d82d1a3" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">创建邻近图动画</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">2D HTML5画布和动画循环介绍</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><h2 id="ceba" class="na me it bd mf nf ng dn mj nh ni dp mn li nj nk mp lm nl nm mr lq nn no mt np bi translated">5.Giphy客户端</h2><p id="c862" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">对于我们要看的最后一个挑战，我的任务是实现一个小的web应用程序，允许用户从<a class="ae ky" href="https://developers.giphy.com/docs/api#quick-start-guide" rel="noopener ugc nofollow" target="_blank"> Giphy API </a>中搜索和浏览gif。</p><p id="d5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我被给予了完全的自由来选择我觉得最舒服的框架和库。对于本文，我将使用<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<code class="fe nx ny nz mw b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">fetch</a></code>。</p><p id="0b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建一个简单的React组件开始，该组件带有一个处理用户输入的表单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果时间允许，你应该考虑创建子组件来保持你的代码有条理。通常，在面试中，时间对你不利。所以，即使你没有时间去做，也要让面试官知道你对改进代码有什么想法。</p><p id="6a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了使用Giphy API，我们需要生成一个<a class="ae ky" href="http://y1ZFwiomdYKWy80gtSxU4iEdv165yeOD" rel="noopener ugc nofollow" target="_blank"> API密钥</a>。一旦我们有了它，我们可以添加一个函数到我们的组件中，从<a class="ae ky" href="https://developers.giphy.com/docs/api/endpoint#search" rel="noopener ugc nofollow" target="_blank">搜索端点</a>获取数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，对于任何API异常都没有错误处理。</p><p id="d1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要让<code class="fe nx ny nz mw b">&lt;form&gt;</code>在用户点击<strong class="lb iu">搜索</strong>或点击<strong class="lb iu">回车</strong>时调用<code class="fe nx ny nz mw b">search</code>方法。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="80c3" class="na me it mw b gy nb nc l nd ne">&lt;form<br/>  onSubmit={e =&gt; {<br/>    e.preventDefault(); // prevents the page from reloading<br/>    search();<br/>  }}<br/>&gt;</span></pre><p id="0f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们扩充我们的组件来呈现来自搜索结果的gif:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="dfb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一些基本的CSS，结果如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nw l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="97a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读——我希望你今天学到了一些新东西。</p><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保重，下次再见。</p></div></div>    
</body>
</html>