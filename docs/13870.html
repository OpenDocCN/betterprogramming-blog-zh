<html>
<head>
<title>AutoLayoutBuilder —My Swift Package to Reduce Boilerplate Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AutoLayoutBuilder——我用来减少样板代码的Swift包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/autolayoutbuilder-294badac5015?source=collection_archive---------5-----------------------#2022-10-06">https://betterprogramming.pub/autolayoutbuilder-294badac5015?source=collection_archive---------5-----------------------#2022-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db44" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用@resultBuilder为UIView约束创建DSL</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3f3f7d211994f48625b2972c9cabac06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTYKV0g80XLro3Wm_H178A.jpeg"/></div></div></figure><p id="ea64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将解决这个DSL的几个问题:</p><ol class=""><li id="bab2" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">将<code class="fe lw lx ly lz b"><a class="ae ma" href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco" rel="noopener ugc nofollow" target="_blank">translatesAutoresizingMaskToConstrants</a></code>设置为<code class="fe lw lx ly lz b">false</code></li><li id="aba9" class="ln lo iq kt b ku mb kx mc la md le me li mf lm ls lt lu lv bi translated">重复同样的<code class="fe lw lx ly lz b">anchor</code>两次</li><li id="1eae" class="ln lo iq kt b ku mb kx mc la md le me li mf lm ls lt lu lv bi translated">多次重复相同的<code class="fe lw lx ly lz b">constant</code></li><li id="5db6" class="ln lo iq kt b ku mb kx mc la md le me li mf lm ls lt lu lv bi translated">代码结构:布局代码可以随处可见，这个DSL旨在通过使用嵌套来解决这个问题</li></ol><p id="6c6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，当使用自动布局时，我们有许多代码块，如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4b5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这已经开始变得难以阅读，我们只添加了一个视图，当我们有10个视图时会发生什么？</p><p id="922f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">难怪开发人员讨厌它，当他们需要追捕一个自动布局的错误，有这么多的阅读涉及！</p><p id="5ab7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数开发者都很懒。记住这一点，让我们去掉所有的缺点，使它更简洁:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="1234" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看如何实现这一点…</p><p id="e0c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要一种方法来引用同一个块中的单数和数组<code class="fe lw lx ly lz b">NSLayoutConstraints</code>，我们可以用一个<code class="fe lw lx ly lz b">protocol</code>来做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1c93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二，<code class="fe lw lx ly lz b">addSubview</code>使用了一个<code class="fe lw lx ly lz b">@resultBuilder</code>，它允许我们收集所有我们想要应用的<code class="fe lw lx ly lz b">NSLayoutConstraints</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="992c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一点上，我们实际上已经拥有了这样做所需要的一切:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9f2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与开始时相比，这已经是一个巨大的进步，但让我们继续…</p><p id="fe88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使我们的约束更具可读性，我们需要存储一些关于它们的信息，为了这个例子，我将引用我们将要使用的四个边约束。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="26b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这提供了一些我们现在可以在<code class="fe lw lx ly lz b">ConstraintBuilder</code>中引用/组合的锚，让我们先实现<code class="fe lw lx ly lz b">ConstraintBuilding</code>协议…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b8a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里你可以看到我们的锚被用在这4个函数中，通过把它放在一个协议中，我们可以用<code class="fe lw lx ly lz b">build</code>扩展其他类型，这允许我们链接约束(即<code class="fe lw lx ly lz b">.leading().trailing()</code>)。</p><p id="f6dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们在我们的<code class="fe lw lx ly lz b">ConstraintBuilder</code>结构中实现这个协议。出于本文的考虑，我将对此进行简化，只创建<code class="fe lw lx ly lz b">equalToSuperview()</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0016" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，你可以看到我们可以在我们的<code class="fe lw lx ly lz b">build</code>函数中使用另一个约束<code class="fe lw lx ly lz b">combine</code>，这允许我们链接我们的约束。我们现在可以这样布置我们的<code class="fe lw lx ly lz b">redView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ffe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于所有这些值都是<code class="fe lw lx ly lz b">20</code>，我们可以将其合并成一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2064" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以做我们计划要做的事情了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="81ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们实际上也可以嵌套这些调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="fd72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p><p id="16ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有兴趣将它包含在您自己的项目中，下面有关于Swift包的信息，它允许您编写更简洁的代码，具有如下相对约束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="80b7" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">Swift包裹</h1><p id="da3f" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">Swift软件包包含的功能远不止上述功能，例如:</p><ul class=""><li id="b121" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm nm lt lu lv bi translated"><code class="fe lw lx ly lz b">@AutoLayoutBuilder</code>块内的配置块</li><li id="cbf1" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">调用<code class="fe lw lx ly lz b">equalTo</code>函数前的约束链接</li><li id="3dc4" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">允许我们链接到<code class="fe lw lx ly lz b">UILayoutGuide</code>或其他视图的各种<code class="fe lw lx ly lz b">equalTo</code>功能。</li><li id="8871" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated"><code class="fe lw lx ly lz b">[NSLayoutConstraint]</code>通过<code class="fe lw lx ly lz b">store(in:)</code>功能存储</li><li id="3a5e" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">运算符(<code class="fe lw lx ly lz b">==</code>、<code class="fe lw lx ly lz b">&lt;=</code>、<code class="fe lw lx ly lz b">&gt;=</code>)来清理布局代码</li><li id="f843" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">为<code class="fe lw lx ly lz b">NSLayoutDimensions</code>设置乘数</li><li id="b16b" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">在约束创建期间设置<code class="fe lw lx ly lz b">UILayoutPriority</code></li><li id="9424" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">使用<code class="fe lw lx ly lz b">NSLayoutConstraint.Attribute</code>识别的<code class="fe lw lx ly lz b">[NSLayoutConstraint]</code>数组内约束的目标管理(设置常数、优先级)</li><li id="6b53" class="ln lo iq kt b ku mb kx mc la md le me li mf lm nm lt lu lv bi translated">…还有更多！</li></ul><p id="49a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">包:<a class="ae ma" href="https://github.com/cjnevin/AutoLayoutBuilder" rel="noopener ugc nofollow" target="_blank">https://github.com/cjnevin/AutoLayoutBuilder</a></p></div></div>    
</body>
</html>