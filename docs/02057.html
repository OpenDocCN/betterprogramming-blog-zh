<html>
<head>
<title>React Experiments With Suspense for Data Fetching in Concurrent Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在并发模式下用暂停进行数据提取的反应实验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-experiments-with-suspense-for-data-fetching-in-concurrent-mode-da1bc6f62ea5?source=collection_archive---------8-----------------------#2019-11-03">https://betterprogramming.pub/react-experiments-with-suspense-for-data-fetching-in-concurrent-mode-da1bc6f62ea5?source=collection_archive---------8-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何探索这一期待已久的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4c2e7ff4cf111081401ee14fa55122f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fPdfTEXxa4O_RZsY.jpg"/></div></div></figure><h1 id="a679" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="64f2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们已经等待<a class="ae mi" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>中的数据获取悬念很久了。它现在作为一个实验性的特性在<a class="ae mi" href="https://reactjs.org/blog/2019/10/22/react-release-channels.html" rel="noopener ugc nofollow" target="_blank">实验频道</a>中提供。</p><p id="f7e8" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">详情请查阅官方文件。</p><ol class=""><li id="ee2a" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated"><a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">引入并发模式</a></li><li id="cce1" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">数据提取暂记</a></li><li id="c1bf" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">并发用户界面模式</li><li id="a998" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">采用并发模式</a></li><li id="3b17" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-reference.html" rel="noopener ugc nofollow" target="_blank">并发模式API引用</a></li></ol><p id="65b6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">它完全不同于传统的React，非常有前途。</p><p id="fd67" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这篇文章探讨了使用悬念获取数据。请注意，所有功能都是实验性的，将来可能会有变化。</p><p id="bc2e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为了在并发模式下获得数据获取的暂挂优势，我们应该使用“即取即渲染”模式。这将要求我们在渲染之前开始提取；一个新的心智模型，而不是我们所习惯的(获取<code class="fe nc nd ne nf b">useEffect</code>或<code class="fe nc nd ne nf b">componentDidMount</code>)。)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="65bc" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">createFetcher</h1><p id="daa5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们创建一个封装了获取函数的“<code class="fe nc nd ne nf b">fetcher</code>”。这可以是一个任意的返回承诺的<code class="fe nc nd ne nf b">async</code>函数。</p><pre class="kj kk kl km gt ns nf nt nu aw nv bi"><span id="f874" class="nw kv it nf b gy nx ny l nz oa">const fetcher = createFetcher(async url =&gt; (await fetch(url)).json());</span></pre><p id="7c04" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这是一个普通的GET fetcher，它接受一个URL作为输入，并假设一个JSON响应。通常情况下，我们会想创造更多的专业fetchers。</p><p id="3f43" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">一个取数器提供了两种方法:<code class="fe nc nd ne nf b">prefetch</code>和<code class="fe nc nd ne nf b">lazyFetch</code>。</p><p id="5229" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果你调用<code class="fe nc nd ne nf b">prefetch</code>，它将启动<code class="fe nc nd ne nf b">fetch</code>函数，你将得到一个<em class="ob">可挂起的</em>。suspendable是一个具有两个属性的对象:<code class="fe nc nd ne nf b">data</code>和<code class="fe nc nd ne nf b">refetch</code>。<code class="fe nc nd ne nf b">data</code>是获取承诺结果，但是如果承诺没有解决，它会抛出一个承诺。<code class="fe nc nd ne nf b">refetch</code>将再次运行fetch函数并返回一个新的suspendable。</p><p id="1ccb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果您调用<code class="fe nc nd ne nf b">lazyFetch</code>，您将得到一个类似suspendable的结果，带有回退数据和一个<code class="fe nc nd ne nf b">lazy</code>标志。它永远不会真正挂起，但是你可以把它当作可挂起的，就像<code class="fe nc nd ne nf b">prefetch</code>返回的一样。</p><p id="10c5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><code class="fe nc nd ne nf b">createFetcher</code>的打字稿如下:</p><pre class="kj kk kl km gt ns nf nt nu aw nv bi"><span id="fe79" class="nw kv it nf b gy nx ny l nz oa">type Suspendable&lt;Data, Input&gt; = {<br/>  data: Data;<br/>  refetch: (input: Input) =&gt; Suspendable&lt;Data, Input&gt;;<br/>  lazy?: boolean;<br/>};</span><span id="16c6" class="nw kv it nf b gy oc ny l nz oa">type Fetcher&lt;Data, Input&gt; = {<br/>  prefetch: (input: Input) =&gt; Suspendable&lt;Data, Input&gt;;<br/>  lazyFetch: (fallbackData: Data) =&gt; Suspendable&lt;Data, Input&gt;;<br/>};</span><span id="9835" class="nw kv it nf b gy oc ny l nz oa">export const createFetcher: &lt;Data, Input&gt;(<br/>  fetchFunc: (input: Input) =&gt; Promise&lt;Data&gt;,<br/>) =&gt; Fetcher&lt;Data, Input&gt;;</span></pre><p id="f5b3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这个实现有点长:</p><pre class="kj kk kl km gt ns nf nt nu aw nv bi"><span id="e577" class="nw kv it nf b gy nx ny l nz oa">export const createFetcher = (fetchFunc) =&gt; {<br/>  const refetch = (input) =&gt; {<br/>    const state = { pending: true };<br/>    state.promise = (async () =&gt; {<br/>      try {<br/>        state.data = await fetchFunc(input);<br/>      } catch (e) {<br/>        state.error = e;<br/>      } finally {<br/>        state.pending = false;<br/>      }<br/>    })();<br/>    return {<br/>      get data() {<br/>        if (state.pending) throw state.promise;<br/>        if (state.error) throw state.error;<br/>        return state.data;<br/>      },<br/>      get refetch() {<br/>        return refetch;<br/>      },<br/>    };<br/>  };<br/>  return {<br/>    prefetch: input =&gt; refetch(input),<br/>    lazyFetch: (fallbackData) =&gt; {<br/>      let suspendable = null;<br/>      const fetchOnce = (input) =&gt; {<br/>        if (!suspendable) {<br/>          suspendable = refetch(input);<br/>        }<br/>        return suspendable;<br/>      };<br/>      return {<br/>        get data() {<br/>          return suspendable ? suspendable.data : fallbackData;<br/>        },<br/>        get refetch() {<br/>          return suspendable ? suspendable.refetch : fetchOnce;<br/>        },<br/>        get lazy() {<br/>          return !suspendable;<br/>        },<br/>      };<br/>    },<br/>  };<br/>};</span></pre><p id="6586" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用<code class="fe nc nd ne nf b">prefetch</code>几乎总是首选。<code class="fe nc nd ne nf b">lazyFetch</code>仅作为<em class="ob">渲染时提取</em>模式的变通方法。</p><p id="0509" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">一旦你得到一个suspendable，你可以在渲染中使用它，React会处理剩下的事情。</p><p id="526c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">因为我们需要在创建React元素之前调用<code class="fe nc nd ne nf b">prefetch</code>,所以我们只能在render函数之外进行。在编写时，它是在组件文件中全局完成的，假设我们知道我们想要什么作为初始的suspendable。这可能会使测试变得困难。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a4a4" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">使用可暂停</h1><p id="6789" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由<code class="fe nc nd ne nf b">createFetcher</code>创建的fetcher在功能上是完整的，但是最好有方便的钩子来使用suspendables。</p><p id="301d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">最简单的就是<code class="fe nc nd ne nf b">useSuspendable</code>。它存储本地状态中的单个suspendable。</p><p id="371e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><code class="fe nc nd ne nf b">useSuspendable</code>的实现如下:</p><pre class="kj kk kl km gt ns nf nt nu aw nv bi"><span id="dd90" class="nw kv it nf b gy nx ny l nz oa">export const useSuspendable = (suspendable) =&gt; {<br/>  const [result, setResult] = useState(suspendable);<br/>  const origFetch = suspendable.refetch;<br/>  return {<br/>    get data() {<br/>      return result.data;<br/>    },<br/>    refetch: useCallback((nextInput) =&gt; {<br/>      const nextResult = origFetch(nextInput);<br/>      setResult(nextResult);<br/>    }, [origFetch]),<br/>    lazy: result.lazy,<br/>  };<br/>};</span></pre><p id="f776" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">由<code class="fe nc nd ne nf b">useSuspendable</code>钩子返回的结果几乎和普通的suspendable一样，但是有一点不同:如果你调用<code class="fe nc nd ne nf b">refetch</code>，不是返回一个新的suspendable，而是用新的suspendable替换状态值。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="752b" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">结束语</h1><p id="d873" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我犹豫要不要写这篇文章，因为它是高度实验性的，甚至可能在写完几天后就改变。然而，对于社区来说，尝试这个新的数据获取悬念世界并给出一些反馈是很重要的。</p></div></div>    
</body>
</html>