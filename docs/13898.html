<html>
<head>
<title>Jetpack Compose Swipe To Refresh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写轻扫刷新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-swipe-to-refresh-1d93775970e8?source=collection_archive---------2-----------------------#2022-10-11">https://betterprogramming.pub/jetpack-compose-swipe-to-refresh-1d93775970e8?source=collection_archive---------2-----------------------#2022-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2885" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加载项目时如何实现滑动刷新功能以及占位符的简短指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4c2bf0d023d3e1c376af0f4bacfed8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXDVw1F-BaWxSEsinEUHig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本图中使用的Jetpack Compose徽标是由Google创建的官方徽标</p></figure><p id="a164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，很多应用程序都有需要在某个时候刷新的数据。您可以在一段时间后刷新数据，或者使用套接字来获得最新的数据，但是如果您想要允许用户开始刷新数据的功能，该怎么办呢？</p><p id="8612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过一个按钮来完成，但在某些情况下，更好的UX应该是滑动刷新。今天，我们将使用<code class="fe ls lt lu lv b">Accompanist </code>库来实现它。</p><h1 id="9044" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">刷卡刷新</h1><p id="9dff" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">首先，让我们添加一个依赖项:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9a2c" class="mx lx iq lv b gy my mz l na nb">implementation "com.google.accompanist:accompanist-swiperefresh:0.25.1"</span></pre><p id="00b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>检查这个依赖项是否有更新的版本。</p><p id="2a94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是创建一个简单的<code class="fe ls lt lu lv b">ViewModel</code>,它将保存我们的数据和刷新逻辑。在这里，项目将包含随机图像和数字。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">isRefreshing</code>是一个布尔值，我们将在我们的<code class="fe ls lt lu lv b">swipeRefreshState</code>中使用，我们将在后面解释。<code class="fe ls lt lu lv b">items</code>是一个包含20个随机图片和数字的列表。</p><p id="7d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建我们的屏幕:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b8ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在收集我们的状态，并用值<code class="fe ls lt lu lv b">isRefreshing</code>创建<code class="fe ls lt lu lv b">swipeRefreshState</code>。我们将这个状态传递给<code class="fe ls lt lu lv b">SwipeRefresh</code>，但是如果需要的话，我们也可以访问它的属性<code class="fe ls lt lu lv b">isRefreshing</code>和<code class="fe ls lt lu lv b">isSwipeInProgress </code>。在<code class="fe ls lt lu lv b">SwipeRefresh</code>中，我们有标题、当前时间和项目列表。每一行项目只是显示一个图像和数字。</p><p id="cd86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">SwipeRefresh</code>有三个强制参数:</p><ul class=""><li id="701a" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">state: SwipeRefreshState</code> —一种状态对象，可以被提升以控制和观察SwipeRefresh的变化</li><li id="6626" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">onRefresh: () -&gt; Unit</code> —当完成滑动刷新手势时调用的Lambda</li><li id="6461" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">content: @Composable () -&gt; Unit</code> —包含可组合卷轴的内容</li></ul><p id="dbda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些有趣的可选参数是:</p><ul class=""><li id="1440" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">swipeEnabled: Boolean</code> —布局是否应对滑动手势做出反应</li><li id="164f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">refreshTriggerDistance: Dp</code> —触发刷新的最小刷卡距离</li><li id="0969" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">indicatorAlignment: Alignment</code> —指示器的校准。默认为<code class="fe ls lt lu lv b">Alignment.TopCenter</code></li><li id="0cc9" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">indicatorPadding: PaddingValues</code> —指示器的内容填充，如果需要，可插入指示器</li><li id="9de3" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">indicator: @Composable (state: SwipeRefreshState, refreshTrigger: Dp)</code> —表示当前状态的指示器。默认情况下，这将使用一个<code class="fe ls lt lu lv b">SwipeRefreshIndicator</code></li></ul><p id="322f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">indicator</code>参数，您可以创建自己的可组合组件，但是库为我们提供了<code class="fe ls lt lu lv b">SwipeRefreshIndicator</code>，这是一个我们可以使用的非常好的可组合组件。</p><p id="d13f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它需要两个参数:</p><ul class=""><li id="7a63" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">state: SwipeRefreshState</code> —传入SwipeRefresh指示块的SwipeRefresh状态</li><li id="792a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">refreshTriggerDistance: Dp</code> —触发刷新的最小刷卡距离</li></ul><p id="9790" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些可选参数是:</p><ul class=""><li id="33fb" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">fade: Boolean</code> —箭头滚动时是否应该淡入/淡出，默认为true</li><li id="27be" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">scale: Boolean</code> —指示器滚动时是否应放大/缩小，默认为false</li><li id="9bbf" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">arrowEnabled: Boolean</code> —是否在指示器上画箭头，默认为真</li><li id="fb4c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">backgroundColor: Color</code> —指示器背景表面的颜色</li></ul><p id="c36f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有更多的参数，但不需要遍历所有的参数。如果您想了解更多信息，请务必查看官方文档。</p><p id="64c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<code class="fe ls lt lu lv b">SwipeRefresh</code>的全部内容，现在让我们实现占位符，这是伴奏者提供的另一个不错的库。</p><h1 id="7417" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">占位符</h1><p id="6a2e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">通常，项目的装载由某种装载微调器显示。显示项目正在加载的另一种方式是使用占位符。</p><p id="d689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Accompanist</code>创建了一个库，为我们提供了一个显示占位符的修改器。实际上有两个占位符库。一个是<code class="fe ls lt lu lv b">Foundation</code>，另一个是<code class="fe ls lt lu lv b">Material</code>。建议我们使用<code class="fe ls lt lu lv b">Material</code>，但是您可以随意使用您需要的任何东西。区别不大，API大多相当。在这篇博客中，我们使用的是<code class="fe ls lt lu lv b">Material</code>。所以，让我们用这个命令导入它:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="3529" class="mx lx iq lv b gy my mz l na nb">implementation "com.google.accompanist:accompanist-placeholder-material:0.25.1"</span></pre><p id="b8aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>检查是否有此依赖关系的更新版本。</p><p id="385a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续处理<code class="fe ls lt lu lv b">MainScreen</code>之前，让我们快速编辑一下<code class="fe ls lt lu lv b">MainViewModel</code>。添加<code class="fe ls lt lu lv b">init </code>和<code class="fe ls lt lu lv b">isLoading</code> <code class="fe ls lt lu lv b">StateFlow</code>。同样，用20个默认<code class="fe ls lt lu lv b">RowItems</code>初始化<code class="fe ls lt lu lv b">items</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">ViewModel</code>现在长这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是在我们的屏幕中收集<code class="fe ls lt lu lv b">isLoading</code>，然后用它作为我们的占位符。我们正在向可组合的<code class="fe ls lt lu lv b">Item</code>、<code class="fe ls lt lu lv b">childModifier: Modifier</code>添加一个新参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f96e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，这个库提供了一个修饰符。必需的参数是<code class="fe ls lt lu lv b">visible: Boolean</code>，它决定是否应该显示占位符或内容。如果<code class="fe ls lt lu lv b">visible</code>为真，将会有一个占位符来填充它所应用的可组合组件的大小，而不是内容。</p><p id="d445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可选参数包括:</p><ul class=""><li id="8547" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">color: Color</code> —用于绘制占位符UI的颜色。如果提供了<code class="fe ls lt lu lv b">Color.Unspecified</code>，占位符将使用<code class="fe ls lt lu lv b">PlaceholderDefaults.color</code></li><li id="7292" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">shape: Shape</code> —占位符的所需形状。如果为空，占位符将使用<code class="fe ls lt lu lv b">MaterialTheme.shapes</code>中设置的小形状</li><li id="0929" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">highlight: PlaceholderHighlight</code> —可选的高亮动画。占位符有两个预先创建的动画，<code class="fe ls lt lu lv b">fade</code>和<code class="fe ls lt lu lv b">shimmer</code></li><li id="7492" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">placeholderFadeTransitionSpec: @Composable Transition.Segment&lt;Boolean&gt;.() -&gt; FiniteAnimationSpec&lt;Float&gt;</code> —将占位符淡入/淡出屏幕时使用的过渡规范。为过渡定义的布尔参数是可见的</li><li id="00a8" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">contentFadeTransitionSpec: @Composable Transition.Segment&lt;Boolean&gt;.() -&gt; FiniteAnimationSpec&lt;Float&gt;</code> —将内容淡出屏幕时使用的过渡规范。为过渡定义的布尔参数是可见的</li></ul><p id="832f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">MainScreen</code>现在看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。我希望你喜欢它。</p><p id="3cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的GitHub repo中找到所有的源代码。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="1361" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">Want to Connect?</strong></span><span id="305e" class="mx lx iq lv b gy ns mz l na nb"><a class="ae kv" href="https://github.com/Giga99" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kv" href="https://www.linkedin.com/in/igor-stevanovic/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><a class="ae kv" href="https://twitter.com/igor_s1999" rel="noopener ugc nofollow" target="_blank"><br/>Twitter</a><br/><a class="ae kv" href="https://giga99.github.io/portfolio-website/" rel="noopener ugc nofollow" target="_blank">Portfolio website</a></span></pre></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="ff49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想了解更多关于Jetpack Compose的信息，请阅读以下文章:</p><ul class=""><li id="ff45" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implement-horizontal-and-vertical-viewpager-in-jetpack-compose-a7a91f2ac746">在Jetpack Compose中实现水平和垂直view pager</a></li><li id="ed80" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://medium.com/better-programming/build-a-camera-android-app-in-jetpack-compose-using-camerax-4d5dfbfbe8ec" rel="noopener">使用CameraX在Jetpack Compose中构建一个相机Android应用</a></li><li id="912c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-clean-navigation-94b386f7a076"> Jetpack缀洁导航</a></li></ul><h1 id="93c8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">资源</h1><div class="oa ob gp gr oc od"><a href="https://google.github.io/accompanist/swiperefresh/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">向导—伴奏者</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">一个库，它提供了一个提供滑动刷新UX模式的布局，类似于Android的…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">google.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>