<html>
<head>
<title>Implement a Facial Recognition Authentication Using React.js and TailwindCSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.js和TailwindCSS实现面部识别身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/replace-your-auth-system-with-facial-recognition-using-reactjs-and-tailwindcss-9af4898ab5a2?source=collection_archive---------2-----------------------#2022-10-05">https://betterprogramming.pub/replace-your-auth-system-with-facial-recognition-using-reactjs-and-tailwindcss-9af4898ab5a2?source=collection_archive---------2-----------------------#2022-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d37" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过面部授权保护您的应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b7e06a538d765ba37f1bf36ce2b4a6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jhQr0uTjLyTH8akDzmXhg.jpeg"/></div></div></figure><p id="c8b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">认证是网站最关键的部分。如果处理不当，会导致无法想象的情况。随着最近的技术进步，许多不同的技术栈和框架被创建来构建最有效的web应用程序。但是开发人员很少关注改进身份验证系统和在web身份验证领域构建新的和创新的东西。</p><p id="a0a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着人工和机器学习技术的进步，人脸识别已经变得容易实现并且非常可靠。现在大多数智能手机都带有光学面部识别技术来解锁手机。但在web开发领域，我们看不到面部识别作为认证用户的一种手段。</p><p id="f6c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将讨论我们传统身份验证系统的问题，如何使用<a class="ae ln" href="https://faceio.net/" rel="noopener ugc nofollow" target="_blank">人脸识别</a>解决这个问题，以及使用reactjs和taiwindCSS实现相同功能的详细分步指南。</p><h1 id="71ee" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">当前认证系统的问题</h1><p id="577b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">目前，基于电子邮件密码的认证是网络上最流行的。但是这个系统的主要缺点是要记住你注册的每个网站的唯一密码。如果您忘记了密码，您需要您的电子邮件地址来重置密码。如果你失去了对电子邮件的控制，几乎不可能恢复你的帐户。</p><p id="d14d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决所有这些问题，oAuth应运而生。OAuth是一种使用OAuth提供商注册网站的协议。你可能会在各种网站上看到使用谷歌、脸书、GitHub等登录的选项。这是oAuth的一个例子。在我们的系统中，作为一个用户，你只需要维护一个账户，并允许使用其他网站上的信息。作为开发人员，您必须相信OAuth提供者能够提供正确的信息。</p><p id="6924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在无密码签到或者魔链认证很流行。在这个系统中，你需要在网站上输入你的电子邮件地址。然后，您会收到一封包含登录链接的电子邮件。如果您浏览此链接，您将通过验证并在相应的网站上注册。这是一个非常容易登录的系统，你不需要记住密码。</p><p id="4e14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上述所有例子中，你都可以找到一个熟悉的模式。所有这些认证过程都需要您的电子邮件。电子邮件在上述所有系统中是如此重要，以至于如果你不知何故失去了对它的控制，你就无法保持对你所有账户的控制。这是认证系统中的一个主要问题。但是正如问题有解决方案一样，这个问题也有一些解决方案。让我们在下一节讨论它。</p><h1 id="5588" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">人脸认证如何解决这个问题</h1><p id="aa90" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了从认证堆栈中删除电子邮件，我们有一些选项，如指纹认证和面部识别。</p><p id="2d8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指纹认证的问题在于它需要专门的硬件来工作。大多数计算机硬件都没有默认的指纹识别器。由于web上没有与设备指纹读取器交互的本地标准化API，指纹认证在不久的将来是可行的。</p><p id="8cf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于人工智能和机器学习的快速进步，面部识别不是很难。开源机器学习库的存在，让开发者更容易快速为其web应用开发函数AI。</p><p id="7077" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但这需要之前接触过一些机器学习。如果你没有这种经验，你可以使用机器学习SaaS产品，如faceIO，轻松地为你的网站创建一个面部识别认证系统。</p><p id="0aaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将使用<a class="ae ln" href="https://faceio.net/getting-started" rel="noopener ugc nofollow" target="_blank"> FaceIO库</a>来演示我们的web应用程序中的人脸认证。创建一个FaceIO 的<a class="ae ln" href="https://console.faceio.net/" rel="noopener ugc nofollow" target="_blank">免费账户。</a></p><h1 id="096b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用tailwind CSS创建Rectjs项目</h1><p id="19d5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本教程中，我们将使用vite来创建ReactJs项目。打开您的终端并运行以下命令，使用vite搭建React项目。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="efa7" class="mq lp iq mm b gy mr ms l mt mu">npm create vite@latest my-project — — template react</span></pre><p id="e7b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在按照终端提示来搭建您的项目。完成这一步后，在您喜欢的代码编辑器中打开这个项目。项目结构应该是这样的。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="10fb" class="mq lp iq mm b gy mr ms l mt mu">.<br/>├── index.html<br/>├── package.json<br/>├── package-lock.json<br/>├── public<br/>│ └── vite.svg<br/>├── src<br/>│ ├── App.css<br/>│ ├── App.jsx<br/>│ ├── assets<br/>│ │ └── react.svg<br/>│ └── main.jsx<br/>└── vite.config.js</span></pre><p id="7e99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，要在您的vite项目中安装tailwind CSS，请仔细遵循这些步骤。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="76b6" class="mq lp iq mm b gy mr ms l mt mu">npm install -D tailwindcss postcss autoprefixer<br/>npx tailwindcss init -p</span></pre><p id="08da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在打开您的<code class="fe mv mw mx mm b">tailwind.config.cjs</code>文件并添加您的项目源路径。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="06ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的<code class="fe mv mw mx mm b">src/App.css</code>文件中，添加tailwind CSS指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c2f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您已经在React和vite项目中成功安装了tailwind CSS。让我们在下一节中关注如何在我们的项目中集成人脸认证。</p><h1 id="4270" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在React应用程序中添加FaceIO auth</h1><p id="0062" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">FaceIO的伟大之处在于它们提供了一个非常易用的Javascript库。这个库有两个主要功能<code class="fe mv mw mx mm b">enroll</code>和<code class="fe mv mw mx mm b">authenticate</code>。但是在讨论这些函数之前，让我们将FaceIO库链接到react应用程序。</p><p id="4404" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开项目中的<code class="fe mv mw mx mm b">index.html</code>文件，并将FaceIO CDN链接到您的项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="86c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成功链接FaceIO CDN后，打开<code class="fe mv mw mx mm b">App.jsx</code>文件，删除<code class="fe mv mw mx mm b">App</code>组件内的所有样板代码。为了初始化我们的FaceIO库，我们添加了一个<code class="fe mv mw mx mm b">useEffect</code> react钩子。当组件被初始化时，这个钩子中的代码只运行一次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ad5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到我们在实例化<code class="fe mv mw mx mm b">faceIO</code>对象时使用了一个ID作为参数。当你注册一个faceIO账户时，你可以在<code class="fe mv mw mx mm b">faceIO</code>控制台中访问这些id。</p><p id="73ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在所有的设置都完成了，让我们把重点放在使用<code class="fe mv mw mx mm b">FaceIO</code>认证用户上。</p><h2 id="c76c" class="mq lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">使用FaceIO注册新用户</h2><p id="5eb7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">FaceIO提供了一个非常简单的界面来注册新用户。我们使用<strong class="kt ir">注册</strong>功能注册一个新用户。由于FaceIO需要您的网络摄像头许可，请在提示时接受许可对话框。</p><p id="4f12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注册函数有两个别名。您可以使用<code class="fe mv mw mx mm b">register</code>和<code class="fe mv mw mx mm b">record</code>功能替代<code class="fe mv mw mx mm b">enroll</code>。</p><p id="ee13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您在浏览器中运行这个函数时，它会启动faceIO小部件。首先，需要用户同意扫描他们的面部，然后提示接受摄像头许可。如果满足了所有要求，faceIO widget会打开您的相机并扫描您的面部。它将你的面部数据转换成一个浮点数数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/0925168abeb87d433e9898fae7bcfabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzImmTQqbaWsy-m4x_DELA.png"/></div></div></figure><p id="5135" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">收集面部数据后，faceIO会被提示输入PIN码。此PIN码用于区分面部极其相似的用户。当事情变糟时，你会认为这是一个双因素认证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/6ae7493ea102f3869459344e71d837fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xM8uHxHaycRAWtSKhZrdjA.png"/></div></div></figure><p id="c74c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在react应用程序中添加faceIO enroll。我们保持应用程序非常简单。因此，让我们创建一个名为<code class="fe mv mw mx mm b"><strong class="kt ir">register</strong></code>的按钮，当有人点击这个按钮时，我们运行<code class="fe mv mw mx mm b"><strong class="kt ir">enroll</strong></code>函数来注册一个新用户。</p><p id="8e80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在添加了注册按钮和按钮click上的javascript处理程序后，<code class="fe mv mw mx mm b">App.jsx</code>文件看起来像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="06f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，您可以看到我将代码包装在一个try-catch块中。如果出现问题，FaceIO会抛出一些错误。错误消息非常有用，您可以在官方文档中获得完整的错误代码列表。</p><p id="fd04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注册函数只接受可选的参数对象。这些可选参数接受属性来配置用户注册过程。在上面的例子中，我在注册函数的可选参数中定义了<code class="fe mv mw mx mm b">locale</code>和<code class="fe mv mw mx mm b">payload</code>属性。<code class="fe mv mw mx mm b">locale</code>属性代表用户的默认交互语言。在我们的例子中，我们提供了<code class="fe mv mw mx mm b">auto</code>来自动检测语言。</p><p id="f2eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mv mw mx mm b">payload</code>中，您可以添加任何对您的用户唯一的JSON可序列化值。在这个例子中，我们添加了用户的电子邮件作为有效负载。以后无论何时使用登录，我们都可以从FaceIO返回对象中访问电子邮件有效负载。</p><p id="3ef7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">FaceIO中的注册函数返回一个承诺。因此，在这个例子中，我使用javascript的async/await特性。如果不喜欢async/await，可以用<code class="fe mv mw mx mm b">.then</code>代替。</p><p id="a240" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当承诺完成时，它产生一个<code class="fe mv mw mx mm b"><strong class="kt ir">userInfo</strong></code>对象。通过使用对象，我们可以访问用户的唯一面部ID。除此之外，userInfo对象还提供了一个<code class="fe mv mw mx mm b"><strong class="kt ir">details</strong></code>属性，从中我们可以得到用户的大概年龄和性别。</p><h1 id="30cb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用FaceIO验证注册用户</h1><p id="6911" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">成功注册用户后，就该对注册用户进行身份验证了。为此，Pixlab提供了<code class="fe mv mw mx mm b">authenticate</code>函数。这个<code class="fe mv mw mx mm b">authenticate</code>函数也有3个别名，<code class="fe mv mw mx mm b">auth</code>、<code class="fe mv mw mx mm b">recognize</code>和<code class="fe mv mw mx mm b">identify</code>。</p><p id="2aa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">认证功能只需要用户识别单个帧。因此，它对带宽非常友好。认证成功后，它返回一个<code class="fe mv mw mx mm b">userData</code>对象。这个<code class="fe mv mw mx mm b">userData</code>包含您在注册中指定的有效载荷和用户的面部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/86de71b5e306776cd905037565932cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1WLDrdO1f8rlTL5-9v3Yg.png"/></div></div></figure><p id="ff22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的<code class="fe mv mw mx mm b">App.jsx</code>文件中，我们制作了另一个名为<strong class="kt ir">登录</strong>的按钮。当用户点击这个按钮时，它调用<code class="fe mv mw mx mm b">handleLogIn</code>助手函数。该函数最终负责调用“身份验证”函数。让我们看看所有这些代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mv mw mx mm b">handleLogIn</code>函数中，如果认证失败，我们使用try-catch块来捕捉错误。当<code class="fe mv mw mx mm b">authenticate</code>函数返回一个承诺时，我们使用了异步await方法来获取承诺完成时的值。</p><p id="7144" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mv mw mx mm b">authentication</code>函数接受一些可选参数来定制faceIO身份验证小部件。您主要可以使用权限超时、<code class="fe mv mw mx mm b">idleTimeout</code>和<code class="fe mv mw mx mm b">replyTimeout</code>参数自定义超时。编译后，我们的web应用程序应该是这样的。</p><h1 id="0280" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">FaceIO REST API</h1><p id="ceab" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在FaceIO中创建您的帐户时，您将被分配一个API密钥。您可以在faceIO控制台中找到这个API密钥。通过使用这个API键，您可以使用<a class="ae ln" href="https://faceio.net/rest-api" rel="noopener ugc nofollow" target="_blank"> RESTful API </a>与FaceIO后端进行交互。REST API的基本URL是“https://api.faceio.net/”。</p><p id="28f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，FaceIO REST API支持3个函数。删除用户的面部，将附加有效载荷设置为faceID，以及为faceID设置Pin码。切记从安全的环境或后端服务器使用这些API端点。不要从客户端运行这些API。</p><h2 id="f1bb" class="mq lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">删除faceID</h2><p id="0452" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要删除faceID，我们必须向<a class="ae ln" href="https://api.faceio.net/deletefacialid" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/deletefacialid</a>端点发出get请求。这个端点有两个请求参数。一个是接受API键的<strong class="kt ir">键</strong>，另一个是接受想要删除的faceID的<strong class="kt ir"> fid </strong>。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b4d1" class="mq lp iq mm b gy mr ms l mt mu">curl — request GET \</span><span id="de8c" class="mq lp iq mm b gy no ms l mt mu">— url '<a class="ae ln" href="https://api.faceio.net/deletefacialid?key=APIkey&amp;fid=FaceID'" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/deletefacialid?key=APIkey&amp;fid=FaceID'</a></span></pre><p id="fe51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为响应，FaceIO返回一个状态代码和一个“payload”布尔值，该值表明数据和有效载荷是否被成功删除。</p><h2 id="4420" class="mq lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">将有效负载设置为FaceID</h2><p id="d6c6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">通过使用这个API端点，您可以为已经存在的FaceID设置一个有效负载。请求的网址是<a class="ae ln" href="https://api.faceio.net/setfacialidpayload" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/setfacialidpayload</a>。此端点需要3个请求参数。<code class="fe mv mw mx mm b">key</code>是API键，<code class="fe mv mw mx mm b">fid</code>是你想要附加有效载荷的面部ID，<code class="fe mv mw mx mm b">payload</code>是定义你的定制有效载荷数据。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6089" class="mq lp iq mm b gy mr ms l mt mu">curl — request POST \</span><span id="ccba" class="mq lp iq mm b gy no ms l mt mu">— url '<a class="ae ln" href="https://api.faceio.net/setfacialidpayload?key=APIkey&amp;fid=FaceID&amp;payload=%22name%3AHrishikesh%22'" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/setfacialidpayload?key=APIkey&amp;fid=FaceID&amp;payload=%22name%3AHrishikesh%22'</a></span></pre><p id="75be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为响应，FaceIO返回一个状态代码和一个“payload”布尔值，该值表明数据和有效载荷是否被成功删除。</p><h2 id="04d8" class="mq lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">将密码设置为FaceID</h2><p id="ac8a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在faceID注册部分，我们讨论了使用密码来区分两张非常相似的脸的必要性。如果你想修改他们的密码，你可以很容易地这样做，通过使用<a class="ae ln" href="https://api.faceio.net/setfacialidpincode`" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/setfacialidpincode</a>端点。</p><p id="caae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像前面的端点一样，这也需要3个参数。一个是API密钥，另一个是faceID，最后一个是PIN。对端点的curl请求如下。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="4ff1" class="mq lp iq mm b gy mr ms l mt mu">curl — request POST \</span><span id="cf80" class="mq lp iq mm b gy no ms l mt mu">— url '<a class="ae ln" href="https://api.faceio.net/setfacialidpincode?key=APIkey&amp;fid=FaceID&amp;pin=12345'" rel="noopener ugc nofollow" target="_blank">https://api.faceio.net/setfacialidpincode?key=APIkey&amp;fid=FaceID&amp;pin=12345'</a></span></pre><h1 id="aba9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">FaceIO Webhooks</h1><p id="e4d2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Webhooks被用作服务器之间的通信方法。FaceIO提供了丰富的webhook体验，可以用来更新后端服务器。FaceIO在3个事件上发送一个<a class="ae ln" href="https://faceio.net/webhooks" rel="noopener ugc nofollow" target="_blank"> webhook </a>。<code class="fe mv mw mx mm b">enroll</code>当一个新用户注册到您的系统中时，<code class="fe mv mw mx mm b">auth</code>当一个已经注册的用户使用faceIO进行认证时，以及<code class="fe mv mw mx mm b">deletion</code>当一个faceID使用我们上面讨论过的REST API被删除时。</p><p id="dde6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个webhook请求都是来自faceIO服务器和JSON对象的POST请求。请求正文如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cc01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个字段的名称对于它包含什么值是不言自明的。</p><p id="4b22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照以下步骤用faceIO服务器配置webhook。</p><ol class=""><li id="528c" class="np nq iq kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">首先通过FACEIO控制台连接到您的帐户。</li><li id="cad1" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">在控制台主视图上，访问应用程序管理器。</li><li id="aa7f" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">选择要为其设置webhooks的目标应用程序。</li><li id="0f33" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">一旦选择了目标应用程序。输入用于接收事件的Webhook端点URL，并保存修改。</li><li id="7730" class="np nq iq kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">你都准备好了。一旦事件被触发，FACEIO将向您配置的URL发出HTTP POST请求。</li></ol><h1 id="1a72" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="55a6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是关于将面部认证添加到React应用程序的深入指南。如果你喜欢这个指南，想了解更多关于faceIO的信息，请访问官方<a class="ae ln" href="https://faceio.net/dev-guides" rel="noopener ugc nofollow" target="_blank">文档页面</a>。如果你有任何问题，你也可以查看他们的<a class="ae ln" href="https://faceio.net/faq" rel="noopener ugc nofollow" target="_blank"> FAQ页面</a>。如果你喜欢我的文章，你可以在<a class="ae ln" href="https://hrishikeshpathak.com/blog" rel="noopener ugc nofollow" target="_blank">我的网站</a>上阅读更多内容，我在Twitter上的名字是<a class="ae ln" href="https://twitter.com/hrishikshpathak" rel="noopener ugc nofollow" target="_blank">@ hriskshpathak</a>。</p></div></div>    
</body>
</html>