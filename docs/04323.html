<html>
<head>
<title>How to Master Protocols in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何掌握Swift中的协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/protocols-from-zero-to-hero-72423dfdfe21?source=collection_archive---------7-----------------------#2020-04-06">https://betterprogramming.pub/protocols-from-zero-to-hero-72423dfdfe21?source=collection_archive---------7-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">协议定义、继承、扩展等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8609c834ea9c16cc85eb9fc05a35964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u1j11jnemkNH0fDF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯文·米克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议<strong class="lb iu"> </strong>像许多其他语言一样表示接口。您可能已经知道，协议用于定义“适合特定任务或功能的方法、属性和其他需求的蓝图”</p><p id="27ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将深入讨论使用Swift 5.3的协议。让我们以协议为基础开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d646" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">确认协议</strong></h1><p id="77d5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">协议允许您对相似的方法、功能和属性进行分组。Swift允许您在<code class="fe mz na nb nc b">class</code>、<code class="fe mz na nb nc b">struct</code>和<code class="fe mz na nb nc b">enum</code>类型上指定这些接口保证。只有<code class="fe mz na nb nc b">class</code>类型可以使用基类和来自协议的继承。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在值类型和引用类型中符合协议</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议属性和功能</h1><p id="4a07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当在协议中定义属性时，我们必须指定它的类型，因为一致性类型不能推断属性类型。同样的，我们不能指定属性是存储的还是计算的属性，这就把规范留给了一致性类型。</p><p id="8f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还必须通过使用<code class="fe mz na nb nc b">get</code>和<code class="fe mz na nb nc b">set</code>关键字来指定属性是只读的还是可读写的。</p><p id="c1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议中不允许属性和方法参数的默认值。</p><p id="be22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个值类型符合我们的协议，并且这个协议有一个修改它所属的实例的函数时，我们必须用关键字<code class="fe mz na nb nc b">mutating</code>作为函数定义(在协议内)的前缀。</p><p id="2445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个引用类型(类)符合带有<code class="fe mz na nb nc b">mutating</code>关键字的那个函数，一旦我们在类中实现了那个func，我们就不需要写<code class="fe mz na nb nc b">mutating</code>关键字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协议属性和功能</p></figure><p id="bcc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协议构造变化</p></figure><p id="adb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，真正的只读协议应该符合常量(<code class="fe mz na nb nc b">let</code>)或计算属性。</p><p id="5a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议也可以定义可选的属性和功能，但是需要用<code class="fe mz na nb nc b">objc</code>属性来标记协议和属性和/或功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任择议定书</p></figure><p id="b777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结构和枚举不能采用标有<code class="fe mz na nb nc b">objc</code>属性的协议。只有类可以采用这些协议。现在，让我们来看看最好的协议特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f9b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议继承</h1><p id="e4b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中，协议可以继承一个或多个附加协议。让我们看看如何使用它以及为什么要使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户协议</p></figure><p id="99bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个<code class="fe mz na nb nc b">User</code>协议，每次我们添加一个新的<code class="fe mz na nb nc b">User</code>需求，这个协议都会变得更大。我们如何解决这个问题？让我们使用协议继承来使它变得更好一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用继承的用户协议</p></figure><p id="34a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，一旦我们创建了一个符合<code class="fe mz na nb nc b">User</code>协议的类型，我们必须实现<code class="fe mz na nb nc b">User</code>协议中定义的需求，以及<code class="fe mz na nb nc b">UserIdentity</code>协议中定义的需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">符合用户协议的结构</p></figure><p id="d7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是开始设计我们代码的好方法，现在让我们看看协议的其他伟大特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df7d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议组成</h1><p id="fea9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们知道了如何使用协议继承，让我们看看下一步。</p><p id="e6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用类型和OOP范例的主要缺点是类只能从一个超类继承。相反，对于协议和POP，您可以使用协议组合，这是一个让我们的类型采用多种协议的特性。</p><p id="a677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在单元格中使用对象和委托的常见示例</p></figure><p id="9004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在结构中做一些改变，是时候使用协议了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用协议组合的相同示例</p></figure><p id="f2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到这种方法的一些好处。首先，我们有一个<code class="fe mz na nb nc b">LocationCoordinate</code>协议可以随时使用。例如，如果我们将我们的应用程序从餐馆扩展到超市，这个新类型可以从<code class="fe mz na nb nc b">LocationCoordinate</code>继承来获得坐标属性。</p><p id="e44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看到一个巨大的好处。比如，看到并想象一下<code class="fe mz na nb nc b">getDirections</code> func会是什么样子。我们共享一家餐厅，可能只是召唤像地图或谷歌地图这样的API。</p><p id="e3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一直在共享整个对象(这意味着对象具有所有属性)对于这个特性，我们可能会想，我们真的需要所有这些属性吗？如果答案是<em class="nf">否</em>，请查看该解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用协议隔离</p></figure><p id="1e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经为我们的<code class="fe mz na nb nc b">RestaurantCellDelegate</code>更改了获取方向功能，所以现在我们将只共享<code class="fe mz na nb nc b">getDirections</code>功能显示去那家餐馆的方向所需的<code class="fe mz na nb nc b">Restaurant</code>属性和功能。</p><p id="5fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我将用一个例子来描述最后一个巨大的好处。假设我们在新的<code class="fe mz na nb nc b">ViewController</code>中实现了<code class="fe mz na nb nc b">RestaurantCellDelegate</code>，其中<code class="fe mz na nb nc b">ViewController</code>只需显示和处理与预订相关的一切。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">符合RestaurantCellDelegate的视图控制器</p></figure><p id="581d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会从我们的委托中实现<code class="fe mz na nb nc b">showMenu</code>、<code class="fe mz na nb nc b">getDirections</code>和<code class="fe mz na nb nc b">markFavorite</code>函数。</p><p id="44de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有两个选择，在我们的<code class="fe mz na nb nc b">RestaurantCellDelegate</code>中使用<code class="fe mz na nb nc b">@objc</code>和可选关键字，或者使用协议继承和组合。</p><p id="da94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们已经知道的，结构和枚举不能采用标有<code class="fe mz na nb nc b">objc</code>属性的协议，所以我们只剩下一个选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">避免@objc可选的协议组合</p></figure><p id="0373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的<code class="fe mz na nb nc b">ViewController</code>将看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">符合没有未使用功能的协议的视图控制器</p></figure><p id="ce23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，协议组合允许我们将需求分解成许多更小的组件，而不是从单个协议或单个超类继承所有需求。</p><p id="dd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们的类型家族在宽度上而不是高度上增长，这意味着我们避免创建臃肿的类型，这些类型包含并非所有符合的类型都需要的需求。</p><p id="f6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总是用一两个需求来评估协议的使用，这将导致处理一个难以维护和管理的设计。</p><p id="bf93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这不是规则。在某些情况下，例如委托，我们只需要一个或两个函数的协议，在编写代码之前进行评估。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c9b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议类型</h1><p id="4a7d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">协议只是蓝图而不实施任何东西的事件，它们是Swift中的类型。</p><p id="87d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以使用协议作为参数、函数的返回类型、var和let属性，以及在集合(如数组)中，正如我们在前面的例子中看到的，在我们的委托、单元和/或<code class="fe mz na nb nc b">ViewController</code>中使用了<code class="fe mz na nb nc b">Restaurant</code>协议。</p><p id="0ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们深入了解一下这个概念:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个餐馆实现</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个餐馆实现</p></figure><p id="0ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了两个餐馆实现，一个是鸡肉餐馆，另一个是海鲜餐馆。假设我们需要在应用程序中显示所有餐馆的菜单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个操场文件使用我们的func显示菜单</p></figure><p id="77f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们在任何地方都使用协议作为类型，我们可以使用它的特定实例，比如<code class="fe mz na nb nc b">ChickenFoodRestaurant</code>或<code class="fe mz na nb nc b">SeaFoodRestaurant</code>。</p><p id="f25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这些是该函数的日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/9ff1842827fe4cb9d6e2f093f91508ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*367vxtbZuGPj4NiaJEuIBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示菜单日志</p></figure><p id="b843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特点把我们引向下一个话题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议多态性</h1><p id="2cf0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nf">多态性</em>一词来源于希腊语<em class="nf"> poly </em>(意为<em class="nf">多</em>)和<em class="nf"> morphe </em>(意为<em class="nf">形成</em>)。</p><p id="df44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态性让我们通过一个单一的、统一的接口与多种类型进行交互。在面向对象的编程世界中，单一的统一接口通常来自超类，而在面向协议的编程世界中，单一接口通常来自协议。</p><p id="76d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上一节中看到的，我们在一个数组中使用了一个<code class="fe mz na nb nc b">ChickenFoodRestaurant</code>和<code class="fe mz na nb nc b">SeaFoodRestaurant</code>，但是两者都有一个特定的显示菜单func的实现。</p><p id="f9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是多态和协议协同工作创建不同实现的潜力，而不需要强制类型转换或重复代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e12" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议类型转换</h1><p id="6d50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类型转换是一种检查实例类型和/或将实例视为指定类型的方法。</p><p id="5d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，我们使用<code class="fe mz na nb nc b">is</code>关键字检查一个实例是否属于特定类型，使用<code class="fe mz na nb nc b">as</code>关键字将一个实例视为特定类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型转换是关键字示例</p></figure><p id="049d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象是特定的类型，<code class="fe mz na nb nc b">is</code>关键字返回<code class="fe mz na nb nc b">true</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为关键字的类型转换示例</p></figure><p id="b6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个关键字让我们对协议进行类型转换，以验证一个对象是否属于特定类型，并将其用作该类型，正如我们在示例中看到的那样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="945b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议泛型</h1><p id="da0d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果正确使用泛型和协议来避免重复代码，它们可能是一个强大的工具。假设您对泛型有一个大致的了解，让我们快速地看一下如何在协议中使用它。</p><p id="4337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议泛型说:“我们不知道要使用的确切类型；因此，当一个类型采用这个协议时，它就会定义它。”</p><p id="7c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议可以使用一个或多个<code class="fe mz na nb nc b">associatedtype</code>。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有一般项目的数据源协议</p></figure><p id="6732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，一旦我们需要一个特定的数据源，例如，一个餐馆数据源，我们有几个选择:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一种具体的数据源类型</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用数据源类型</p></figure><p id="5109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看两个数据源的运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用数据源</p></figure><p id="ddb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是一样的，但是一旦我们以这种方式设计我们的应用程序，就会有一些不同。这个话题我们以后再说。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">协议扩展</strong></h1><p id="9b52" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">协议扩展使协议成为一个了不起的工具。它们允许我们添加协议功能和属性的默认实现和值。</p><p id="b9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能注意到的，它是一个有用的工具，可以让需求变得可选，而不需要<code class="fe mz na nb nc b">@objc</code>和optional关键字。符合协议的类型可以提供自己的实现，也可以使用默认的实现。</p><p id="0f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉decorator模式，你可能知道协议扩展允许我们添加协议中没有描述的funcs的实现，“装饰<em class="nf">”</em>它。</p><p id="a1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很棒的特性，可以在不修改每个类型的情况下将特定的函数添加到多个一致性类型中。你看到我们在这里如何杀死经典的基类继承了吗？</p><p id="02be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个所有这些特性修改我们之前声明的<code class="fe mz na nb nc b">Restaurant</code>协议的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用扩展添加默认值和实现</p></figure><p id="eec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经更改了我们的<code class="fe mz na nb nc b">Restaurant</code>协议，为菜单属性添加了默认值，并为<code class="fe mz na nb nc b">displayMenu</code>添加了默认实现。让我们看看具体类型是如何变化的，比如我们的<code class="fe mz na nb nc b">SeaFoodRestaurant</code>和<code class="fe mz na nb nc b">ChickenFoodRestaurant</code>结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用默认值和实现的一致性协议</p></figure><p id="bab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe mz na nb nc b">SeaFoodRestaurant</code>结构不需要定义菜单，因为它的默认值取自扩展中声明的默认餐馆值。</p><p id="7768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">display menu func也是如此，它不是必需的，因为我们使用的是扩展中的默认实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用默认值和实现但覆盖它的一致性协议</p></figure><p id="c29a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的<code class="fe mz na nb nc b">ChickenFoodRestaurant</code>从默认实现和值中获益，但是覆盖了它的<code class="fe mz na nb nc b">displayMenu</code>实现。让我们看看调用这两个对象时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个操场文件使用我们的func显示菜单</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a5cd9ae985d6b69e628036e784cff3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkY-XCMEB3yV9yPFlwTLhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原木</p></figure><p id="0bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，<code class="fe mz na nb nc b">ChickenFoodRestaurant</code>使用其默认实现，而<code class="fe mz na nb nc b">SeaFoodRestaurant</code>使用协议默认实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用默认值作为func输入参数的协议扩展</p></figure><p id="e8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了一个名为<code class="fe mz na nb nc b">openingHours</code>的新func，并且在扩展中，我们给它的输入日期一个默认值(<code class="fe mz na nb nc b">day = Date()</code>)。</p><p id="5e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些扩展使我们能够向我们的协议func输入添加默认值。无论如何，如果你的一致性类覆盖了它的实现，它将不得不声明默认值。</p><p id="7964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们只在协议扩展中声明了<code class="fe mz na nb nc b">markFavorite</code> func。这是向我们的协议添加额外功能的一个很好的方式，作为所有符合我们协议的对象的基类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4558" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">具有协议扩展和多态性的模糊方法实现</h1><p id="778e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，当我们使用扩展和多态时，我们可能会遇到方法实现不明确的问题，因为我们没有明确指出应该使用方法的哪个实现，从而导致编译错误。</p><p id="c34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们必须将func的实现添加到一致性类型中。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在扩展上使用默认实现的新协议</p></figure><p id="478e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们让前面例子中的<code class="fe mz na nb nc b">SeaFoodRestaurant</code>符合这个新协议，会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/fe09edb7b5aaec7023fb22bf351f25d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZNx5SrdfgQOH1kEn3LJ0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有协议扩展和多态性的模糊方法实现</p></figure><p id="a327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遇到了一个不明确的实现问题，我们如何解决它？我们的<code class="fe mz na nb nc b">SeaFoodRestaurant</code> <em class="nf">必须实现</em>它的版本<code class="fe mz na nb nc b">openingHours(day: Date)</code>。</p><p id="1ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他令人困惑的情况需要解释，我们已经看到了。当我们谈论协议扩展时，它允许我们添加一些方法的默认实现，也可以添加新的方法实现，但是有什么区别呢？</p><h2 id="b34a" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated"><strong class="ak">当协议中存在方法声明时</strong></h2><p id="5dd6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该协议声明了<code class="fe mz na nb nc b">openingHours(day: Date)</code>方法，并提供了一个默认的实现。</p><p id="461c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法在<code class="fe mz na nb nc b">SeaFoodRestaurant</code>实现中被覆盖。因此，无论变量的类型如何，都会在运行时调用方法的正确实现。</p><h2 id="5bcf" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated"><strong class="ak">当协议中不存在方法声明时</strong></h2><p id="ab6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为该方法未在协议中声明，所以该类型无法重写它。这就是为什么被调用方法的实现依赖于变量的类型。</p><p id="1e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果变量是<code class="fe mz na nb nc b">SeaFoodRestaurant</code>类型的，则调用该类型的方法实现。如果变量是类型<code class="fe mz na nb nc b">Restaurant</code>，则调用协议扩展的方法实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c478" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法分派，协议中的动态与静态</h1><p id="83a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">方法分派是在调用方法时选择执行什么实现的方式。当编译器在编译时解析为静态分派时。当它在运行时被解析时，它是动态分派的。</p><p id="04da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，引用类型使用动态调度，在运行时从继承层次结构中选择实现。值类型使用静态分派，因为它们不需要继承。</p><p id="9d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有需要的协议方法都使用动态调度，因为编译器必须寻找该方法的具体实现。</p><p id="2ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些例外，例如，当你创建一个没有类型的变量，但它只符合协议，它总是在使用静态调度的存在容器中创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协议碎片</p></figure><p id="7c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> sambosTavern </strong>使用静态调度，而<strong class="lb iu">bubbagmp</strong>使用动态调度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9198" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Swift标准库扩展</h1><p id="c0d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了扩展您自己的协议，您还可以从<a class="ae ky" href="https://developer.apple.com/documentation/swift/swift_standard_library" rel="noopener ugc nofollow" target="_blank"> Swift标准库</a>扩展协议。我们来看一个小例子。</p><p id="9c82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还记得我们举的鸡肉菜单和切片的例子吗？又来了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示菜单和菜单</p></figure><p id="9be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何改变它，扩展Swift标准库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展Swift标准库</p></figure><p id="1c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的方式来获得有用的机制来支持我们自己的协议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ba53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议扩展与基类</h1><p id="8d95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们所见，协议扩展和基类可能看起来非常相似，但是使用协议扩展有几个好处。</p><p id="f101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为类、结构和枚举可以符合多个协议，所以它们可以采用多个协议的默认实现。这在概念上类似于其他语言中的多重继承。</p><p id="1c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个好处是，协议可以被类、结构和枚举所采用，而基类和继承只能用于类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e6f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">良好的API设计技巧</h1><p id="d1c8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然您已经了解了协议的行为方式，那么最好是回顾一下什么时候应该使用协议。最佳使用协议的一些建议:</p><ul class=""><li id="3a03" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">从具体的用例开始，进入协议。</li><li id="ee2a" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">考虑从标准库中定义的现有协议组成新协议。参考下面的<a class="ae ky" href="https://developer.apple.com/documentation/swift/adopting_common_protocols" rel="noopener ugc nofollow" target="_blank">苹果文档</a>可以得到一个很好的例子。</li><li id="f30c" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">首先，探索具有具体类型的用例，理解您想要共享什么代码，并找到它在哪里被重复。然后，用泛型将共享代码分解出来。这可能意味着您需要创建新的协议。发现对通用代码的需求。</li><li id="17fa" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">考虑定义一个泛型类型，而不是泛型协议。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议见证人</h1><p id="21fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在swift的以前版本中(&lt;5.3) when we try to use a protocol with enums, Swift restrict the protocol conforming matching model forcing us to use a manual implementation instead use the enum cases with the same name and arguments as the protocol, like this example:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Protocol Witness</p></figure><p id="1869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift 5.3 has lifted that restriction so we can make our enums to conform protocols matching the vars and funcs as enum cases, like this example</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Enum Protocol Witness</p></figure><h1 id="261c" class="mc md it bd me mf oi mh mi mj oj ml mm jz ok ka mo kc ol kd mq kf om kg ms mt bi translated">Conclusion</h1><p id="01ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Here you have some powerful tools to start using protocols.</p><p id="03ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">There are more benefits and mechanisms like copy on write and conditionals that we didn’t see in this article, but with all the information here, you should be able to go deeper with the use of protocols and maybe this article stimulates your curiosity.</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d827" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Bibliography</h1><ol class=""><li id="63a5" class="nu nv it lb b lc mu lf mv li on lm oo lq op lu oq oa ob oc bi translated"><a class="ae ky" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" rel="noopener ugc nofollow" target="_blank">协议定义</a></li><li id="91d2" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2019/415/" rel="noopener ugc nofollow" target="_blank">良好的API设计</a></li><li id="31b7" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank">仿制药</a></li><li id="1a15" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swift/adopting_common_protocols" rel="noopener ugc nofollow" target="_blank">采用通用协议</a></li><li id="57e0" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://www.amazon.com/Protocol-Oriented-Programming-Swift-Hoffman/dp/1785882945" rel="noopener ugc nofollow" target="_blank">面向协议的编程—乔恩·霍夫曼</a></li><li id="7a79" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oq oa ob oc bi translated"><a class="ae ky" href="https://www.tensorflow.org/swift/tutorials/protocol_oriented_generics" rel="noopener ugc nofollow" target="_blank">流行</a></li></ol></div></div>    
</body>
</html>