<html>
<head>
<title>9 Tips for Local Node.js Development Using Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose开发Local Node.js的9个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-tips-for-local-node-js-development-using-docker-compose-19789f44158?source=collection_archive---------4-----------------------#2020-01-22">https://betterprogramming.pub/9-tips-for-local-node-js-development-using-docker-compose-19789f44158?source=collection_archive---------4-----------------------#2020-01-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="70ff" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">创造良好的地方发展环境</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c0d709cba6af7d2b350546d1aaba9414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMWpJZcp2VIP5KihybGJ9w.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae kz" href="https://unsplash.com/s/photos/composition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="45a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker Compose 为设计和开发容器解决方案提供了一个很好的本地开发设置。无论您是测试人员、开发人员还是DevOps操作员，Docker Compose都能满足您的需求。</p><p id="ed87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想使用Docker Compose为Node.js创建一个优秀的本地开发和测试环境，我有以下10个技巧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9b2e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">1.在Docker合成文件中使用正确的版本</h1><p id="1713" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">docker-compose.yml</code>文件是一个YAML文件，它为Docker应用程序定义了服务、网络和卷。文件的第一行包含<code class="fe na nb nc nd b">version</code>关键字，并告诉Docker Compose您正在使用哪个版本的文件格式。</p><p id="27ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有两个主要版本可以使用，版本2和版本3；两者都有不同的用例。</p><p id="8be7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker Compose开发团队为本地开发创建了第2版，并创建了第3版以兼容容器编排器，如<a class="ae kz" href="http://swarmframework.org/" rel="noopener ugc nofollow" target="_blank"> Swarm </a>和Kubernetes。</p><p id="50f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们谈论本地Node.js开发时，我总是使用最新的版本2，在我写作的时候，版本2.4。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="5dd7" class="ni me iu nd b gz nj nk l nl nm">version: <strong class="nd iv">"2.4"</strong><br/>services:<br/>  web:<!-- --> </span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fcfa" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">2.正确使用装订架</h1><p id="b672" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">关于绑定挂载，我的第一个技巧是始终使用相对路径从主机挂载Node.js源代码。</p><p id="deac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用相对路径允许其他开发人员使用这个合成文件，即使他们在主机上有不同的文件夹结构。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="fa62" class="ni me iu nd b gz nj nk l nl nm">volumes:<br/>  - <strong class="nd iv">./src</strong>:/home/nodeapp/src</span></pre><h2 id="4cbc" class="ni me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">使用命名卷装载数据库</h2><p id="5b7e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">几乎所有Node.js应用程序都是使用Linux容器部署到生产环境中的。如果你使用Linux容器并在Windows或Mac上开发你的应用程序，你不应该绑定安装你的数据库文件。</p><p id="2a88" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，数据库服务器在读写数据库时必须跨越操作系统边界。相反，您应该使用命名卷，并让Docker处理数据库文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用命名卷挂载MongoDB数据库</p></figure><p id="1972" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">volumes:</code>关键字定义了docker-compose文件的命名卷。这里，我们定义了命名卷<code class="fe na nb nc nd b">workflowdatabase</code>，并在<code class="fe na nb nc nd b">workflowdb</code>服务中使用它。</p><h2 id="0f36" class="ni me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">使用委派配置提高性能</h2><p id="2ce8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我总是将<em class="ny">委托</em>配置添加到我的卷挂载中，以提高性能。通过在绑定挂载上使用委托配置，您告诉Docker它可能会延迟来自容器的更新在主机中出现。</p><p id="e85f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，对于本地开发，在容器中执行的写入不需要立即反映在主机上。委派标志是Docker Desktop for Mac特有的选项。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="bda3" class="ni me iu nd b gz nj nk l nl nm">volumes:<br/>  - ./src:/home/app/src:<strong class="nd iv">delegated</strong></span></pre><p id="f128" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据您需要的容器和主机之间的一致性级别，还有另外两个选项需要考虑，<code class="fe na nb nc nd b"><a class="ae kz" href="https://docs.docker.com/docker-for-mac/osxfs-caching/" rel="noopener ugc nofollow" target="_blank">consistent</a></code>和<code class="fe na nb nc nd b">cached</code>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c0cc" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">3.正确处理你的节点模块</h1><p id="c2b8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">由于操作系统的不同，你不能将<code class="fe na nb nc nd b">node_modules</code>目录从你的macOS或Windows主机绑定挂载到你的容器中。</p><p id="58ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些npm模块在npm安装期间执行动态编译，这些从macOS动态编译的模块不会在Linux上运行。</p><p id="fb43" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有两种不同的解决方案可以解决这个问题:</p><ol class=""><li id="c3ca" class="ob oc iu lc b ld le lg lh lj od ln oe lr of lv og oh oi oj bi translated">通过Docker容器填充主机上的<code class="fe na nb nc nd b">node_module</code>目录。</li></ol><p id="adc2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过使用<code class="fe na nb nc nd b">docker-compose run</code>命令运行<code class="fe na nb nc nd b">npm install</code>来通过Docker容器填充主机上的<code class="fe na nb nc nd b">node_module</code>目录。这将使用容器的操作安装正确的node_modules。</p><p id="d148" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比如一个标准的Node.js app，有下面的<code class="fe na nb nc nd b">Dockerfile</code>和<code class="fe na nb nc nd b">docker-compose.yml</code>文件。：</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Node.js应用程序的标准docker文件</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">标准Docker-Compose.yml文件</p></figure><p id="ff51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过执行命令<code class="fe na nb nc nd b">docker-compose run workflowengine npm install</code>，我通过运行Docker容器在主机上安装node_modules。</p><p id="e54b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着主机上的node_modules现在用于Dockerfile的架构和操作系统，并且<em class="ny">不能再从您的主机上使用。</em></p><p id="1e2e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2.使用空绑定挂载隐藏主机的node_modules。</p><p id="e906" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二个解决方案比第一个更灵活，因为您仍然可以像在Docker容器中一样从主机上运行和开发应用程序。这就是所谓的node_modules <em class="ny">卷技巧</em>。</p><p id="d235" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们必须更改docker文件，以便node_modules安装在比Node.js应用程序高一个目录的位置。</p><p id="1460" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">package.json</code>被复制并安装在<code class="fe na nb nc nd b">/node</code>目录中，而应用程序被安装在<code class="fe na nb nc nd b">/node/app</code>目录中。Node.js应用程序从当前应用程序文件夹向上查找<code class="fe na nb nc nd b">node_modules</code>目录。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="7bdd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">来自主机的node_modules与应用程序源代码位于同一个文件夹中。</p><p id="2ea5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了确保来自主机的node_modules不会将挂载绑定到Docker映像中，我们使用这个<code class="fe na nb nc nd b">docker-compose</code>文件挂载一个空卷。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="dca6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">volumes部分中的第二条语句实际上对主机隐藏了node_modules目录。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="079d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">4.使用Docker合成工具</h1><p id="85c3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你想在用Docker Compose开发时运行你的工具，你有两个选择:使用<code class="fe na nb nc nd b">docker-compose run</code>或者使用<code class="fe na nb nc nd b">docker-compose exe</code>。两者表现不同。</p><p id="13f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">docker-compose run [service] [command]</code>从服务的映像启动一个新容器并运行命令。</p><p id="62d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">docker-compose exec [service] [command]</code>在该服务的当前运行容器中运行命令。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8349" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">5.使用nodemon进行文件监视</h1><p id="7d55" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我总是使用<code class="fe na nb nc nd b"><a class="ae kz" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank">nodemon</a></code>来查看文件更改和重启Node.js。当您使用Docker Compose进行开发时，您可以通过以下Compose run命令安装<code class="fe na nb nc nd b">nodemon</code>来使用<code class="fe na nb nc nd b">nodemon</code>:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="3e77" class="ni me iu nd b gz nj nk l nl nm">docker-compose run workflowengine npm install nodemon —-save-dep</span></pre><p id="dc57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后在<code class="fe na nb nc nd b">docker-compose.yml</code>文件中的<code class="fe na nb nc nd b">workflowengine</code>服务下添加<code class="fe na nb nc nd b">command</code>。您还必须将<code class="fe na nb nc nd b">NODE_ENV</code>设置为development，以便安装dev依赖项。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8699" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">6.指定服务的启动顺序</h1><p id="7b9d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Docker Compose在启动其服务时不使用特定的顺序。如果您的服务需要特定的启动顺序，您可以在docker-compose文件中使用<code class="fe na nb nc nd b">depends_on</code>关键字来指定。</p><p id="a0dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe na nb nc nd b">depends_on</code>您可以指定您的服务A依赖于服务B。Docker Compose在服务A之前启动服务B，并确保在启动服务A之前可以通过DNS访问服务B。</p><p id="673c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您使用的是Docker Compose YAML的第2版，<code class="fe na nb nc nd b">depend_on</code>可以与<code class="fe na nb nc nd b">HEALTHCHECK</code>命令结合使用，以确保您所依赖的服务已经启动并且运行正常。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="266f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">7.健康检查与depends_on结合使用</h1><p id="fbe0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果您希望您的服务在您所依赖的服务已经启动并且健康之后启动，您必须将<code class="fe na nb nc nd b">depends on</code>与健康检查结合起来。</p><p id="082c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的例子来自上一篇文章，<a class="ae kz" href="https://itnext.io/mini-video-encoder-implementation-part-1-1fce5fb081c1" rel="noopener ugc nofollow" target="_blank"> <em class="ny">迷你视频编码器第1部分</em> </a>，其中我展示了如何使用<a class="ae kz" href="https://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiR1JPD2ZXnAhVKiI8KHbY1AYcYABAAGgJzYg&amp;ohost=www.google.com&amp;cid=CAESQOD2wdx_BER9wND2sFdQQXRBJBPKMSdnx1aeaQPgkbn_1mXJ3ad6tg70BNQDfPchaHlH8rii8t0Ek-Q0cXH0WcM&amp;sig=AOD64_3PMrAoKeHLeQx3adsyj1D_Pph2bA&amp;q=&amp;ved=2ahUKEwjClo3D2ZXnAhVExTgGHQv8C24Q0Qx6BAgNEAE&amp;adurl=" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和<a class="ae kz" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将depends_on与健康检查相结合</p></figure><p id="44ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须将<code class="fe na nb nc nd b">condition: service_healthy</code>添加到<code class="fe na nb nc nd b">depends_on</code>中，以表明您所依赖的服务在启动该服务之前应该是健康的。</p><p id="6a93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为MongoDB数据库指定的健康检查确保数据库服务器在报告健康状态之前已经启动并正在接受连接。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0727" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">8.使用扩展字段缩小撰写文件</h1><p id="9e2c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您可以使用环境变量和扩展字段增加合成文件的灵活性。可以使用<code class="fe na nb nc nd b">environment</code>关键字设置环境变量。</p><p id="8fe5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，更改API正在监听的数据库或端口的连接字符串。请参阅我的文章<a class="ae kz" href="https://medium.com/better-programming/docker-for-node-js-in-production-b9dc0e9e48e0" rel="noopener"><em class="ny">Node.js with Docker in production</em></a>了解如何在node . js应用程序中配置和使用环境变量。</p><p id="a45f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">扩展字段允许您在撰写文件中定义一个文本块，该文本块可以在同一个文件中重复使用。通过这种方式，您可以减小合成文件的大小，使其更加干燥。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="4667" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我使用语法<code class="fe na nb nc nd b">&lt;&lt;: *base-service-template</code>定义了一个包含<code class="fe na nb nc nd b">build</code>和<code class="fe na nb nc nd b">networks</code>的模板，它们在每个服务上都是相同的。我将定义的模板注入到服务定义中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d70f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">9.添加反向代理服务</h1><p id="6f5a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">一旦在组合文件中定义了多个公开HTTP端点的服务，就应该开始使用反向代理。您可以开始执行主机头路由，而不必管理HTTP端点的所有端口和端口映射。</p><p id="2ebf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用DNS名称在不同的服务之间进行路由，而不是使用不同的端口。容器解决方案中最常用的反向代理是<a class="ae kz" href="https://github.com/jwilder/nginx-proxy" rel="noopener ugc nofollow" target="_blank"> NGINX </a>、<a class="ae kz" href="https://hub.docker.com/_/haproxy" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>和<a class="ae kz" href="https://containo.us/traefik/" rel="noopener ugc nofollow" target="_blank"> Traefik </a>。</p><h2 id="857a" class="ni me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">使用NGINX</h2><p id="eb08" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你打算使用NGINX，我推荐Jason Wilder的<a class="ae kz" href="https://github.com/jwilder/nginx-proxy" rel="noopener ugc nofollow" target="_blank">jwilder/NGINX-proxy</a>Docker容器。Nginx-proxy使用<a class="ae kz" href="https://github.com/jwilder/docker-gen" rel="noopener ugc nofollow" target="_blank"> docker-gen </a>根据您的Compose文件中的服务生成Nginx配置模板。</p><p id="435a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每次您在撰写文件中添加或删除服务时，Nginx-proxy都会重新生成模板并自动重启Nginx。自动重新生成和重新启动意味着您总是拥有最新的反向代理配置，包括您的所有服务。</p><p id="2863" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过将<code class="fe na nb nc nd b">VIRTUAL_HOST</code>环境变量添加到服务定义中来指定服务的DNS名称。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用jwilder/nginx-proxy作为服务的反向代理</p></figure><p id="b022" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Nginx-proxy服务安装Docker套接字，这使它能够响应容器的添加或删除。在<code class="fe na nb nc nd b">VIRTUAL_HOST</code>环境变量中，我使用了<code class="fe na nb nc nd b">*.localhost</code>域。</p><p id="219b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Chrome自动将<code class="fe na nb nc nd b">.localhost</code>域名指向127.0.0.1。</p><h2 id="7660" class="ni me iu bd mf nn no dn mj np nq dp mn lj nr ns mp ln nt nu mr lr nv nw mt nx bi translated">使用Traefik</h2><p id="b40b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Traefik是一个专门的开源反向代理容器映像，用于基于HTTP和TCP的应用程序。</p><p id="805f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们的Docker Compose中使用Traefik作为反向代理或多或少与Nginx-proxy相同。Traefik提供了一个基于HTTP的仪表板，向您显示由Traefik处理的当前活动路由。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="a145" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Traefik使用<code class="fe na nb nc nd b">labels</code>而不是环境变量来定义您的DNS名称。参见上面的例子。</p><p id="3a22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Traefik提供的功能比上面显示的多得多，如果您感兴趣，我会引导您访问他们的<a class="ae kz" href="https://docs.traefik.io/" rel="noopener ugc nofollow" target="_blank">网站</a>，该网站提供了关于其他功能的完整文档，例如负载平衡、自动请求和更新<a class="ae kz" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>证书。</p><p id="abee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读，希望这九个技巧对使用Docker Compose进行Node.js开发有所帮助。如果你有任何问题，请随时回复。</p></div></div>    
</body>
</html>