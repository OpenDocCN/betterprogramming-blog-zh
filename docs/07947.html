<html>
<head>
<title>The Essential Angular Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本角度备忘单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-essential-angular-cheat-sheet-1f677e5bc83?source=collection_archive---------1-----------------------#2021-03-09">https://betterprogramming.pub/the-essential-angular-cheat-sheet-1f677e5bc83?source=collection_archive---------1-----------------------#2021-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0899" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发Angular应用程序时需要的所有命令和代码片段的10分钟总结</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f679c22965375058709215442d628e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*es9qFcrRX5wXYyTo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@qmikola?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">miko aj</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了无数的编程语言和开发框架，开发人员应该知道如何使用其中的多种。实际上，你可以擅长不同的框架和语言，但是除非你是天才，否则很难记住每种工具的所有指令、代码片段和操作方法。</p><p id="b0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我喜欢小抄，也是为什么我要给你带来我的第四本小抄——这次是Angular的。</p><p id="ff71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与React和Vue.js一起，<a class="ae ky" href="https://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>是顶尖的web前端框架之一，也是我最有信心的一个。为了更有效地使用它，我精心制作了一份备忘单，今天我很自豪地与你分享。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建并运行项目</h1><p id="c8f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，在我们的工作环境中安装了<a class="ae ky" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ky" href="https://angular.io/guide/setup-local#install-the-angular-cli" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>之后，让我们从CLI创建一个项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建完成后，我们可以使用以下任何命令构建和部署应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装一个库</h1><p id="4477" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大多数情况下，您需要安装外部库来帮助您开发Angular应用程序。第一种方法是最值得推荐的，因为它不仅会安装库，还会为您完成所有的配置。不幸的是，并不是所有的库都与此兼容，所以最好知道两种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f625" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建并实例化一个组件</h1><p id="0717" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nb">组件</em>是角度架构的基石。它们是可重用的实体，具有类型脚本定义的逻辑、HTML定义的布局和一些CSS定义的美学。默认情况下，所有Angular应用程序都带有一个名为<code class="fe nc nd ne nf b">app</code>的主组件，位于<code class="fe nc nd ne nf b">src/app</code>文件夹中。它在应用程序启动时呈现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的命令在文件夹<code class="fe nc nd ne nf b"><em class="nb">/</em>src/app/my-component/</code>中创建了一个名为<code class="fe nc nd ne nf b">myComponent</code>的新组件及其相应的TypeScript、HTML和CSS文件。将该组件实例化到另一个组件的HTML布局中再简单不过了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cbf7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">按指定路线发送</h1><p id="dd3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nb">路由</em>是Angular或React之类的单页面应用程序(SPA)开发框架最重要的方面之一。通过路由，你可以在你的应用程序中引入屏幕之间的导航(实际上是角度组件之间的导航)。</p><p id="2077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先你要在<code class="fe nc nd ne nf b">app-routing.module.ts</code>文件中定义路线，这个文件很可能是Angular在你初始化项目的时候为你创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在主组件HTML文件(<code class="fe nc nd ne nf b">app.component.html</code>)中，如下所示实例化路由器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将用户重定向到任何已定义的路线，您只需使用一个<code class="fe nc nd ne nf b">routerLink</code>指令，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7189" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据绑定</h1><p id="36d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">角度组件在三个文件中定义:布局(视图)的HTML文件、逻辑(控制器)的TypeScript文件和样式的CSS文件。</p><p id="5e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单向数据绑定是一种机制，用于呈现控制器中定义的视图对象(属性绑定)，并允许视图调用控制器中的方法(事件绑定)。让我们在下面的组件中看看这些概念的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件控制器(TypeScript类)中，声明了一个名为<code class="fe nc nd ne nf b">currentUser</code>、类型为<code class="fe nc nd ne nf b">User</code>(在另一个TypeScript类中定义)的变量。从组件视图(HTML文件)中，使用<code class="fe nc nd ne nf b">{{ object }}</code>符号，其属性<code class="fe nc nd ne nf b">name</code>和<code class="fe nc nd ne nf b">age</code>被呈现在布局中。这被称为<em class="nb">属性绑定。</em></p><p id="6238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在逻辑中如何定义了一个叫做<code class="fe nc nd ne nf b">loadNextUser()</code>的方法。通过事件绑定，使用<code class="fe nc nd ne nf b">(event)=”call” notation</code>，每当视图中定义的按钮被点击，方法<code class="fe nc nd ne nf b">loadNextUser()</code>将被触发。</p><p id="3143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种叫做<em class="nb">双向数据绑定的东西，</em>使用符号<code class="fe nc nd ne nf b">[(object)]</code>，在视图和控制器之间建立了双向关系，因此控制器对绑定对象的任何更改都将在视图中再现，反之亦然。在本文后面的模板驱动表单部分，您将看到这个概念的实际应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3679" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结构指令</h1><p id="ceb6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nb">结构化指令</em>允许开发者以一种非常快速和简单的方式在HTML模板中包含一些代码逻辑，以便决定一个HTML元素何时以及需要渲染多少次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，使用的三个基本结构指令是<code class="fe nc nd ne nf b">ngIf</code>、<code class="fe nc nd ne nf b">ngFor</code>和<code class="fe nc nd ne nf b">ngSwitch</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7331" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模板引用变量</h1><p id="8564" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在组件的模板中，我们可以给HTML元素分配一个引用，这样我们就可以从DOM中的其他元素访问它的内容。如果这对你来说听起来像是胡说八道，不要担心，通过下面的例子你就会明白了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对理解模板驱动的表单很重要，这将在本文后面讨论。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">具有灵活布局的响应式布局</h1><p id="6b8d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如今，对每个网站来说，响应都是必须的。用户希望网站能够在智能手机、平板电脑和电脑上正常呈现，因此需要一个库来创建一个响应性的布局。<a class="ae ky" href="https://github.com/angular/flex-layout" rel="noopener ugc nofollow" target="_blank">灵活布局</a>是角度的首选解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用npm安装好之后，别忘了导入到<code class="fe nc nd ne nf b">imports</code>数组里面的<code class="fe nc nd ne nf b">src/app/app.module.ts</code>文件中。现在，您可以使用HTML模板中的<code class="fe nc nd ne nf b">fxLayout</code>和<code class="fe nc nd ne nf b">fxFlex</code>标签来创建响应式组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d7e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，响应式布局是用<code class="fe nc nd ne nf b">fxLayout</code>标签定义的，在这里我们指定元素是必须按行还是按列布局。正是在这里，我们还找出了一些额外的属性，如元素对齐或元素之间的间隙。对于布局内部的元素，使用了<code class="fe nc nd ne nf b">fxFlex</code>标签。注意我们如何使用点来定义特定窗口大小的属性(e<strong class="lb iu">sm</strong>all，e<strong class="lb iu">x</strong>tra-<strong class="lb iu">s</strong>mall，<strong class="lb iu">g</strong>rea<strong class="lb iu">t</strong>er than<strong class="lb iu">sm</strong>all……)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ae4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">角状材料</h1><p id="4866" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://material.io" rel="noopener ugc nofollow" target="_blank"> Material </a>是Google创建的一个设计框架，它广泛存在于Android生态系统中。由于Angular也是由Google创建的，所以Material是事实上的设计库，为开发人员提供了大量漂亮且易于实现的组件、样式、图标和布局。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令(如果你在项目初始化助手被要求安装Angular Material时说不，你只需要使用它)将为你的应用程序设置一个漂亮的配色方案，并为你提供一组现成的组件，如按钮，工具栏，列表等等。</p><h2 id="5dd8" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">小跟班</h2><p id="d643" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，将<code class="fe nc nd ne nf b">MatButtonModule</code>导入到<code class="fe nc nd ne nf b">src/app</code>中的<code class="fe nc nd ne nf b">app.module.ts</code>文件中，并添加到imports数组中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="edcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在应用程序的任何组件的HTML布局中添加材料按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/14ef694b1eac1f06cd970a20e6927bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwqG7fhgqme63Tb_hizyMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同类型的材料按钮。图片来源于<a class="ae ky" href="https://material.angular.io" rel="noopener ugc nofollow" target="_blank"> material.angular.io </a>。</p></figure><p id="ad71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关<code class="fe nc nd ne nf b">MatButton</code>的更多信息，请查阅<a class="ae ky" href="https://material.angular.io/components/button/overview" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h2 id="d7d9" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">卡片</h2><p id="c31f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在<code class="fe nc nd ne nf b">app.module.ts</code>文件中导入<code class="fe nc nd ne nf b">MatCardModule</code>后，我们来看看如何创建<a class="ae ky" href="https://material.angular.io/components/card/overview" rel="noopener ugc nofollow" target="_blank">物料卡片</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a9a141601fb32fbed0d9e08f1c410cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwzh8XJRau8A6az_RSVv3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">材料卡示例。图片来自<a class="ae ky" href="https://material.angular.io" rel="noopener ugc nofollow" target="_blank"> material.angular.io </a>。</p></figure><p id="6232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码可能看起来有点复杂，但实际上非常简单。它创建了一个带有标题(标题、副标题和头像)、正文和一组按钮的卡片。</p><h2 id="c052" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">列表</h2><p id="82c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">和上面的例子一样，导入<code class="fe nc nd ne nf b">MatListModule</code>后，可以创建一个<a class="ae ky" href="https://material.angular.io/components/list/overview" rel="noopener ugc nofollow" target="_blank">物料清单</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/2a9193e03497ca3dbec648e7aba7a662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueRtdHR2QifgPqkxKpZ6uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">材料清单示例。图片via<a class="ae ky" href="https://material.angular.io" rel="noopener ugc nofollow" target="_blank">material . angular . io</a>。</p></figure><p id="0262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看在这个例子中如何使用<code class="fe nc nd ne nf b">ngFor</code>结构指令:对于在组件中定义的数组<code class="fe nc nd ne nf b">employers</code>的每个对象，创建一个<code class="fe nc nd ne nf b">mat-list-item</code>，使用单向数据绑定显示雇主的图像、姓名和年龄。</p><h2 id="35d6" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">工具栏</h2><p id="d13f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">导入<code class="fe nc nd ne nf b">MatToolbarModule</code>后，可以在一个组件内实例化一个<a class="ae ky" href="https://material.angular.io/components/toolbar/overview" rel="noopener ugc nofollow" target="_blank">材质工具栏</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/47bdd0023be93ba566d2f608363bf51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etmFfycCaVK2S_sswEUG_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是上面工具栏的样子。图片来自<a class="ae ky" href="https://material.angular.io" rel="noopener ugc nofollow" target="_blank"> material.angular.io </a>。</p></figure><p id="90e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看第二个<code class="fe nc nd ne nf b">span</code>元素。看到<code class="fe nc nd ne nf b">flex-spacer</code>类了吗？这是一个灵活的间隔，所以菜单按钮和<code class="fe nc nd ne nf b">My App</code>跨度将对齐工具栏的左侧，而收藏夹和共享按钮将对齐右侧。让我们在组件或全局CSS中定义它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bbe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用了另一个叫做<code class="fe nc nd ne nf b"><a class="ae ky" href="https://material.angular.io/components/icon/overview" rel="noopener ugc nofollow" target="_blank">mat-icon</a></code>的材料资源。这是一个很大的图标库，所以如果你感兴趣，完整的列表在这里。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f529" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">形式</h1><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">web上到处都是表单:从登录或注册屏幕到联系页面，表单是从用户那里获取数据的最方便的方式。</p><p id="6a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Angular中<a class="ae ky" href="https://angular.io/guide/forms-overview#choosing-an-approach" rel="noopener ugc nofollow" target="_blank">有两种形式</a> : <em class="nb">模板驱动</em>和<em class="nb">反应式。</em>前者更容易使用，但后者更推荐用于大型表单，提供更健壮的输入验证。让我们看看如何创建一个非常简单的注册表单，通过这两种方法提交用户名、电子邮件和密码。</p><h2 id="f21c" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">模板驱动的表单</h2><p id="6292" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，将<code class="fe nc nd ne nf b">FormsModule</code>导入到<code class="fe nc nd ne nf b">app.module.ts</code>文件中。下一步是定义一个字典来存储用户提交的数据，并定义一个方法来处理提交的数据。这些都是在组件控制器中完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用<a class="ae ky" href="https://material.angular.io/components/input/overview" rel="noopener ugc nofollow" target="_blank">材料输入元素</a>，为您的表单定义模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看在第二行中，当定义表单时，一个事件绑定被用来告诉Angular当用户点击提交按钮时哪个组件方法必须被调用。在同一行中，模板引用变量用于根据表单验证状态启用或禁用提交按钮。</p><p id="fc94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个表单字段(<code class="fe nc nd ne nf b">username</code>、<code class="fe nc nd ne nf b">email</code>和<code class="fe nc nd ne nf b">password</code>，您必须定义一个<a class="ae ky" href="https://material.angular.io/components/form-field/overview#error-messages" rel="noopener ugc nofollow" target="_blank">材料表单字段</a> ( <code class="fe nc nd ne nf b">mat-form-field</code>)，它将一个<a class="ae ky" href="https://material.angular.io/components/input/overview" rel="noopener ugc nofollow" target="_blank">材料输入</a> ( <code class="fe nc nd ne nf b">input matInput</code>)，用户将在其中键入、选择或选择并回答，以及一个<a class="ae ky" href="https://material.angular.io/components/form-field/overview#error-messages" rel="noopener ugc nofollow" target="_blank">材料错误</a> ( <code class="fe nc nd ne nf b">mat-error</code>)，以防输入无效。</p><p id="409c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入双向绑定到控制器中定义的<code class="fe nc nd ne nf b">user</code>字典的相应键。您还必须定义一个模板引用变量，以便仅在输入有效时显示<code class="fe nc nd ne nf b">mat-error</code>。</p><p id="6dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，定义了一个提交按钮，如果表单没有被正确填写，这个按钮将被禁用，这将调用方法<code class="fe nc nd ne nf b">onSubmit()</code>，因为它已经在表单定义的开始处设置好了。</p><h2 id="55ba" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">反应形式</h2><p id="616b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，在创建表单之前，必须用TypeScript类定义表单的模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在将<code class="fe nc nd ne nf b">ReactiveFormsModule</code>导入到<code class="fe nc nd ne nf b">app.module.ts</code>文件中的<code class="fe nc nd ne nf b">imports</code>数组后，您必须创建放置表单的组件。与模板驱动的表单相比，在这种方法中，所有的表单逻辑都在控制器中实现。您还会注意到，使用这种技术时，输入验证更加精确:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，您必须将表单声明为一个<code class="fe nc nd ne nf b">FormGroup</code>对象，并实例化您之前创建的模型类的一个对象。然后使用自动注入的<code class="fe nc nd ne nf b">FormBuilder</code>，您必须创建表单，为每个字段设置所需的验证，并指定每次表单中的数据更改时必须调用的函数。</p><p id="6694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，该函数将迭代所有字段，检查数据是否有效，并在数据无效时显示相应的错误消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们对模板驱动的表单所做的那样，我们再次使用素材库来布置表单，但这次是在控制器中执行验证任务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d29f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">与外部API的通信</h1><p id="065e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们刚刚看到了如何创建一个表单，现在该怎么办呢？表单最常见的用例是向用户请求一些数据，然后使用HTTP将数据发送给某个服务器。使用HTTP与外部API通信是每个web开发人员的基本要求。</p><p id="547c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在深入这个问题之前，我们应该回顾一下其他一些概念，比如服务、承诺和可观察性，以便更好地理解HTTP请求在Angular。</p><h2 id="6208" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">服务</h2><p id="f940" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以将<em class="nb">服务</em>视为没有UI的组件——因此，它们只包含一个类型脚本文件。</p><p id="e224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们通常执行从后端获取数据或处理用户输入等任务。尽管这些任务可以在一个组件中完成，但是让组件尽可能简单，利用服务来完成所有复杂的任务是一个更好的方法。服务可以在一行代码中自动注入到组件中，因此它们也是一种非常好的代码回收方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们必须告诉Angular将这个服务注入到所有请求它的应用程序组件中，所以让我们将它添加到<code class="fe nc nd ne nf b">app.module.ts</code>文件的<code class="fe nc nd ne nf b">providers</code>部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在我们应用程序的任何组件中使用它，您只需在构造函数中请求它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="46c8" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">承诺</h2><p id="70db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nb"> Promises </em>是一个用于<a class="ae ky" href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" rel="noopener ugc nofollow" target="_blank">异步编程</a>的JavaScript机制，其中返回一个待定值，该值可能很快(<code class="fe nc nd ne nf b">resolve</code>)可用，也可能永远(<code class="fe nc nd ne nf b">reject</code>)不可用。</p><p id="9d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的情况是向外部服务器发出请求，在这种情况下，您不会立即得到答复，因为您需要等待请求到达服务器并得到处理，然后才能收到答复。</p><p id="1469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但也有可能因为服务器或网络故障而收不到答案。为了在这段等待时间内不阻止你的应用程序，Promises允许你指定当你的请求得到答复或出错时该做什么，同时你可以继续执行你的程序。</p><p id="b464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个服务有一个返回承诺的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cc1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它由一个组件消耗:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="4314" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">RxJS可观测量</h2><p id="df54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://rxjs.dev" rel="noopener ugc nofollow" target="_blank"> RxJS </a>是JavaScript中用于<a class="ae ky" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>的库，这是一种异步编程范式，其中存在一个名为<code class="fe nc nd ne nf b">Observable&lt;T&gt;</code>的实体，该实体包含一个随时间变化的<em class="nb"> T </em>类型的值。</p><p id="ba05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序组件可以订阅这个可观察对象，通过实现一个回调来成为<em class="nb">观察者</em>，这个回调将在值改变时被触发。在讨论反应式表单时，我曾向您展示过一个可观察的例子，当时我们创建了一个名为<code class="fe nc nd ne nf b">onValueChanged()</code>的函数来对表单字段中的变化做出反应。</p><p id="98da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可观察对象的主要方法是<code class="fe nc nd ne nf b">subscribe(data =&gt; {})</code>，它使我们能够在数据发生变化时要求Angular通知我们。还有许多其他有趣的函数可以链接在一起，比如<code class="fe nc nd ne nf b">map</code>、<code class="fe nc nd ne nf b">pipe</code>、<code class="fe nc nd ne nf b">filter</code>、<code class="fe nc nd ne nf b">delay</code>等。—但我们不会在这里讨论它们。如果你有兴趣，可以查看一下<a class="ae ky" href="https://rxjs.dev/api" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>。</p><h2 id="7096" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">HTTP请求</h2><p id="1ed8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在回顾了这些概念之后，理解Angular中的HTTP请求再简单不过了。Angular通过<code class="fe nc nd ne nf b">@angular/common/http</code>库内置了对HTTP请求的支持。<code class="fe nc nd ne nf b"><a class="ae ky" href="https://angular.io/api/common/http/HttpClient" rel="noopener ugc nofollow" target="_blank">HttpClient</a></code>类是JavaScript <code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">XMLHttpRequest</a></code>对象的基础，并返回一个可观察对象，其服务器响应主体编码为指定类的对象。</p><p id="e813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想从本地部署的API向<code class="fe nc nd ne nf b"><a class="ae ky" href="http://localhost:1234/items," rel="noopener ugc nofollow" target="_blank">http://localhost:1234/items</a></code>发出GET请求，该请求将返回商店中销售的商品列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是创建一个类来模拟这些商店商品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="88fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe nc nd ne nf b">app.module.ts imports array</code>中导入了<code class="fe nc nd ne nf b">HttpClientModule</code>之后，创建一个服务来处理到这个API的连接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们从构造函数中直接注入了<code class="fe nc nd ne nf b">HttpClient</code>，然后我们定义了一个检索条目<code class="fe nc nd ne nf b">(getItems(): GET request</code>的方法和一个上传新条目的方法(<code class="fe nc nd ne nf b">addItem(): POST request</code>)。请注意，在这两种情况下，Angular不会处理GET响应或POST请求的JSON主体，而是会处理这些内容，并允许我们直接处理自己创建的类。</p><p id="7dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以从应用程序的任何组件中注入该服务，并使用其方法返回的可观察值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b2fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5452" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你喜欢这个小抄。我知道我没有涉及一些有角度的主题，比如动画、模块或属性指令，但是我不想让这篇文章太长。欢迎任何问题和建议，在说再见之前，我将把我在Medium上发布的其他小抄留给大家:</p><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-essential-bash-cheat-sheet-e1c3df06560"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Bash的基本备忘单</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">掌握Linux和macOS终端所需的所有命令</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">better编程. pub</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-essential-docker-dockerfile-and-docker-compose-cheat-sheet-8bf1c42876c1"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">基本Docker、Dockerfile和Docker组成备忘单</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">所有基本的Docker CLI、Dockerfile和Docker在一个地方编写命令，并带有简单的示例</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">better编程. pub</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-mysql-cheatsheet-we-all-need-d1af0377bdc6"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">我们都需要的MySQL备忘单</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">你总是忘记的所有重要的MySQL命令</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">better编程. pub</p></div></div><div class="oi l"><div class="op l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>