<html>
<head>
<title>An In-Depth Explanation of package.json’s Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对package.json依赖项的深入解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/package-jsons-dependencies-in-depth-a1f0637a3129?source=collection_archive---------0-----------------------#2019-12-23">https://betterprogramming.pub/package-jsons-dependencies-in-depth-a1f0637a3129?source=collection_archive---------0-----------------------#2019-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5fd473d3e394dbe19b8ee81a01abc4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6HdydOYopjELZShK"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/photos/2zGTh-S5moM" rel="noopener ugc nofollow" target="_blank">贷方:unsplash </a></p></figure><div class=""/><div class=""><h2 id="6b42" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">依赖、开发依赖和对等依赖:它们是什么意思？</h2></div><p id="350c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用npm(节点包管理器)来管理一个JavaScript项目，那么在您的<code class="fe lu lv lw lx b">package.json</code>中正确构建依赖关系是至关重要的。只需一个npm命令<code class="fe lu lv lw lx b">npm install</code>，就可以根据规范安装所有依赖包。</p><p id="5791" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着微前端和monorepo方法的出现，依赖性之间的相互关系变得越来越具有挑战性。</p><p id="1d8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章描述了<code class="fe lu lv lw lx b">package.json</code>中不同类型的依赖，并展示了我们在产品开发过程中针对<code class="fe lu lv lw lx b">peerDependencies</code>问题采用的一些解决方案。最后，我们讨论外部依赖性。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2310" class="mf mg jj bd mh mi mj mk ml mm mn mo mp kp mq kq mr ks ms kt mt kv mu kw mv mw bi translated">依赖类型</h1><p id="e088" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在<a class="ae jg" href="https://docs.npmjs.com/cli/commands/npm" rel="noopener ugc nofollow" target="_blank"> npm文档</a>中定义了五种类型的依赖关系:</p><h2 id="9dd2" class="nc mg jj bd mh nd ne dn ml nf ng dp mp lh nh ni mr ll nj nk mt lp nl nm mv nn bi translated">1.正常相关性</h2><p id="0920" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">正常的依赖关系:这些依赖包作为库来使项目工作。</p><p id="d3ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终产品必须捆绑这些包，可能是框架(比如React、Angular、Vue等。)、实用程序(如<a class="ae jg" href="https://www.i18next.com/" rel="noopener ugc nofollow" target="_blank"> i18next </a>、<a class="ae jg" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>、<a class="ae jg" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>等。)，以及组织中的子组件。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="9c53" class="nc mg jj lx b gy nw nx l ny nz">"dependencies": {    <br/>  "axio": "0.19.0",<br/>  "i18next": "~17.0.6",<br/>  "react": "^16.12.0",<br/>  "react-dom": "^16.12.0",<br/>  "react-i18next": "~10.11.4",<br/>  "react-router-dom": "~5.1.2"<br/>}</span></pre><h2 id="0f1b" class="nc mg jj bd mh nd ne dn ml nf ng dp mp lh nh ni mr ll nj nk mt lp nl nm mv nn bi translated">2.开发依赖性</h2><p id="45e2" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这些依赖包充当开发工具。最终产品不需要这些包，它们可能是:</p><ul class=""><li id="21eb" class="oa ob jj la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">格式化工具(<a class="ae jg" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>、<a class="ae jg" href="https://beautifier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>、<a class="ae jg" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>等。).</li><li id="47a2" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">Transpilers ( <a class="ae jg" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>，打字稿等。).</li><li id="bfc9" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">类型定义(<code class="fe lu lv lw lx b">@types/react</code>、<code class="fe lu lv lw lx b">@types/jest</code>等)。</li><li id="0dad" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">捆扎机(<a class="ae jg" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">网袋</a>、<a class="ae jg" href="https://github.com/gulpjs/gulp" rel="noopener ugc nofollow" target="_blank">大口</a>、<a class="ae jg" href="https://github.com/rollup/rollup" rel="noopener ugc nofollow" target="_blank">卷起</a>等。).</li><li id="5b05" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">测试库(<a class="ae jg" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，TestCafe，<a class="ae jg" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酵素</a>，<a class="ae jg" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>等。).</li><li id="4884" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">文档库(<a class="ae jg" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>)，文档等。).</li><li id="91b5" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">Monorepos工具(<a class="ae jg" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> lerna </a>、<a class="ae jg" href="https://blog.bitsrc.io/monorepo-architecture-simplified-with-bit-and-npm-b1354be62870" rel="noopener ugc nofollow" target="_blank"> Bit </a>等。).</li><li id="46af" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">和许多其他类型的库。</li></ul><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="84b7" class="nc mg jj lx b gy nw nx l ny nz">"devDependencies": {    <br/>  "@types/jest": "24.0.18",<br/>  "@types/react": "16.8.23",<br/>  "@typescript-eslint/eslint-plugin": "2.8.0",<br/>  "@typescript-eslint/parser": "2.8.0",<br/>  "eslint": "^5.16.0",<br/>  "husky": "^3.0.0",<br/>  "lerna": "^3.16.4",<br/>  "prettier": "^1.18.2",<br/>  "rollup": "^1.0.0",<br/>  "typescript": "^3.6.4"<br/>}</span></pre><h2 id="d157" class="nc mg jj bd mh nd ne dn ml nf ng dp mp lh nh ni mr ll nj nk mt lp nl nm mv nn bi translated"><strong class="ak"> 3。对等依赖</strong></h2><p id="8c59" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这些依赖包是产品所需要的，类似于正常的依赖。然而，该产品不是最终产品。相反，它是一个供主机应用程序使用的库或插件。</p><p id="ff8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这种情况，建议将依赖项放在<code class="fe lu lv lw lx b">peerDependencies</code>中，并期望主机应用程序包含它。</p><p id="9857" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法有几个原因:</p><ol class=""><li id="6ec8" class="oa ob jj la b lb lc le lf lh oc ll od lp oe lt oo og oh oi bi translated">它可以在没有外包装的情况下保持中间产品的包装尺寸较小。</li><li id="9b93" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt oo og oh oi bi translated">它不会不必要地将中间产品与固定版本的第三方依赖项捆绑在一起。</li><li id="bf2c" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt oo og oh oi bi translated">消费主机应用程序本身可能需要相同的包。</li><li id="cb80" class="oa ob jj la b lb oj le ok lh ol ll om lp on lt oo og oh oi bi translated">消费主机应用程序可能依赖于许多需要相同包、相同版本或兼容版本的库或插件。</li></ol><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="852b" class="nc mg jj lx b gy nw nx l ny nz">"peerDependencies": {    <br/>  "jest": "&gt;=24 &lt;25"<br/>}</span><span id="953e" class="nc mg jj lx b gy op nx l ny nz"># This way, npm will issue a warning when some peer dependencies are missing.</span><span id="63c4" class="nc mg jj lx b gy op nx l ny nz">npm WARN ts-jest@24.2.0 requires a peer of jest@&gt;=24 &lt;25 but none is installed. You must install peer dependencies yourself.</span></pre><p id="9711" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从版本4开始，由于重复数据删除算法的技术挑战，npm不再支持自动安装<code class="fe lu lv lw lx b">peerDependencies</code>。</p><p id="6492" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是从版本7开始，npm使用树状算法来自动安装<code class="fe lu lv lw lx b">peerDependencies</code>。</p><p id="3975" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">peerDependenciesMeta</code>提供了关于如何使用<code class="fe lu lv lw lx b">peerDependencies</code>的附加信息。具体来说，它允许将<code class="fe lu lv lw lx b">peerDependencies</code>标记为可选。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="c8d9" class="nc mg jj lx b gy nw nx l ny nz">"peerDependencies": {    <br/>  "jest": "&gt;=24 &lt;25"<br/>}<br/>"peerDependenciesMeta": {<br/>  "jest": {<br/>    "optional": true<br/>  }<br/>}</span></pre><p id="0d3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当用户安装软件包时，如果<code class="fe lu lv lw lx b">peerDependencies</code>中指定的软件包尚未安装，npm将发出警告。将对等依赖项标记为可选可确保如果主机上没有安装<code class="fe lu lv lw lx b">jest</code>软件包，npm不会发出警告。</p><h2 id="54b0" class="nc mg jj bd mh nd ne dn ml nf ng dp mp lh nh ni mr ll nj nk mt lp nl nm mv nn bi translated"><strong class="ak"> 4。可选依赖性</strong></h2><p id="5eff" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这些依赖包是产品所需要的，类似于正常的依赖。</p><p id="95ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果npm找不到它们或安装失败，它将继续运行。产品应该有能力处理这些类型的问题。这是一种很少使用的类型。</p><h2 id="0ea9" class="nc mg jj bd mh nd ne dn ml nf ng dp mp lh nh ni mr ll nj nk mt lp nl nm mv nn bi translated"><strong class="ak"> 5。捆绑依赖关系</strong></h2><p id="42e1" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这些依赖包在发布包时捆绑在一起。这将在本地保留npm软件包，或者通过单个文件下载使它们可用。</p><p id="4356" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">bundledDependencies</code>列在一个数组中，没有版本。这是一种很少使用的类型。</p><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="52fa" class="mf mg jj bd mh mi mj mk ml mm mn mo mp kp mq kq mr ks ms kt mt kv mu kw mv mw bi translated">对等依赖的问题和解决方案</h1><p id="6391" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在<code class="fe lu lv lw lx b">package.json</code>中的所有依赖类型中，<code class="fe lu lv lw lx b">dependencies</code>和<code class="fe lu lv lw lx b">devDependencies</code>是使用最频繁的，并且概念很简单。</p><p id="6823" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，<code class="fe lu lv lw lx b">optionalDependencies</code>和<code class="fe lu lv lw lx b">bundledDependencies</code>很少使用。有趣又麻烦的是<code class="fe lu lv lw lx b">peerDependencies</code>。</p><blockquote class="os ot ou"><p id="8021" class="ky kz ov la b lb lc kk ld le lf kn lg ow li lj lk ox lm ln lo oy lq lr ls lt im bi translated">正如我们之前提到的<!-- -->，从<a class="ae jg" href="https://medium.com/better-programming/the-step-by-step-guide-to-understanding-and-adopting-npm-7-914504f7090f" rel="noopener">版本7 </a>开始，npm使用Arborist算法自动安装<code class="fe lu lv lw lx b">peerDependencies</code>。因此，以下问题和解决方案仅适用于npm版本4 - 6或在安装时使用<code class="fe lu lv lw lx b">--legacy-peer-deps</code>标志的npm 7。</p></blockquote><p id="1a58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们前面提到的，<code class="fe lu lv lw lx b">peerDependencies</code>提供了主机应用程序应该提供的规范。它对生产很有效。</p><p id="c2e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在库或插件开发期间，<code class="fe lu lv lw lx b">npm install</code>不会安装<code class="fe lu lv lw lx b">peerDependencies</code>中指定的包。如果<code class="fe lu lv lw lx b">peerDependencies</code>设置如下:</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="6039" class="nc mg jj lx b gy nw nx l ny nz">"peerDependencies": {    <br/>  "react": "^16.12.0",<br/>  "react-dom": "^16.12.0"<br/>}</span></pre><p id="a5fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，开发构建的ESLint可能会报告一个警告:</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="c8c7" class="nc mg jj lx b gy nw nx l ny nz">Unable to resolve path to module ‘react’ import/no-unresolved </span></pre><p id="960a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，单元测试用例将失败，并显示以下错误:</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="2bc9" class="nc mg jj lx b gy nw nx l ny nz">Cannot find module: ‘react’. Make sure this package is installed.</span></pre><p id="1edc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决办法是把<code class="fe lu lv lw lx b">peerDependencies</code>加到<code class="fe lu lv lw lx b">devDependencies</code>里。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="e256" class="nc mg jj lx b gy nw nx l ny nz">"devDependencies": {    <br/>  "react": "^16.12.0",<br/>  "react-dom": "^16.12.0"<br/>}</span></pre><p id="8d9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么开发版本也将在<code class="fe lu lv lw lx b">node_modules</code>下安装React。这解决了我们的库或插件开发的问题。</p><p id="9f36" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的环境中，我们构建主机应用程序和插件。</p><p id="8e09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Lerna是一个monorepo工具，它优化了使用Git和npm管理多包存储库的工作流程。在开发模式下，<a class="ae jg" href="https://github.com/lerna/lerna/tree/master/commands/bootstrap" rel="noopener ugc nofollow" target="_blank"> lerna bootstrap </a>创建一个符号链接到已安装的插件<code class="fe lu lv lw lx b">devDependencies</code>。</p><p id="b4c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，我们从<code class="fe lu lv lw lx b">host-app</code>的依赖项和<code class="fe lu lv lw lx b">plugin</code>的<code class="fe lu lv lw lx b">devDependencies</code>中为<code class="fe lu lv lw lx b">react</code>和<code class="fe lu lv lw lx b">react-dom</code>找到了下面的树形结构。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="860a" class="nc mg jj lx b gy nw nx l ny nz">host-app<br/>  <!-- -->└─┬ <!-- -->node_modules<br/>    <!-- -->├── <!-- -->react<br/>    <!-- -->├── <!-- -->react-dom<br/>    <!-- -->└── <!-- -->plugin<br/>          <!-- -->└─┬<!-- -->node_modules<br/>            <!-- -->├── <!-- -->react<br/>            <!-- -->└── <!-- -->react-dom</span></pre><p id="84d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题也可能是由<a class="ae jg" href="https://docs.npmjs.com/cli/link.html" rel="noopener ugc nofollow" target="_blank"> npm链接</a>引起的，它在主机应用程序和插件之间使用符号链接。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="e6ce" class="nc mg jj lx b gy nw nx l ny nz"># link the plugin<br/>$ cd host-app<br/>$ npm link path/to/plugin</span></pre><p id="69ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Npm的重复数据删除功能会忽略符号链接。</p><p id="529e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，它仍然适用于包的多个副本。但是，当包含两次时，React会中断(即使版本相等)。您可能会看到这个闪烁的红色错误:</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/c67422b80b5246a96809c8475997856d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JewnuneJB3omw92eAVh4og.png"/></div></div></figure><p id="b01e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">丹·阿布拉莫夫提到了<a class="ae jg" href="https://github.com/facebook/react/issues/14257" rel="noopener ugc nofollow" target="_blank">这个问题</a>:</p><blockquote class="pa"><p id="f88e" class="pb pc jj bd pd pe pf pg ph pi pj lt dk translated">“事实上一直都是这样(当有两个React模块副本时，React应用程序会被巧妙地破坏)。胡克斯立即浮出水面，我认为这很好。”</p></blockquote><p id="67d6" class="pw-post-body-paragraph ky kz jj la b lb pk kk ld le pl kn lg lh pm lj lk ll pn ln lo lp po lr ls lt im bi translated">对于npm链接问题，如果将自身链接回主机应用程序，将会起作用:</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="ddce" class="nc mg jj lx b gy nw nx l ny nz"># link the plugin<br/>$ cd host-app<br/>$ npm link path/to/plugin</span><span id="27a3" class="nc mg jj lx b gy op nx l ny nz"># link its copy of React back to the host-app's React<br/>$ cd path/to/plugin<br/>$ npm link path/to/host-app/node_modules/react</span></pre><p id="09b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为与webpack捆绑在一起的React项目采用了<a class="ae jg" href="https://github.com/ianstormtaylor/slate/issues/3164" rel="noopener ugc nofollow" target="_blank">更通用的解决方案</a>:</p><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="bfb8" class="mf mg jj bd mh mi mj mk ml mm mn mo mp kp mq kq mr ks ms kt mt kv mu kw mv mw bi translated">外部依赖性</h1><p id="2e53" class="pw-post-body-paragraph ky kz jj la b lb mx kk ld le my kn lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">依赖关系还不够复杂吗？</p><p id="32ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">捆绑器引入了一些外部依赖项，如rollup和webpack。外部依赖对于构建库是最有用的。它提供了一种从输出包中排除依赖项的方法。相反，创建的包依赖于最终产品中存在的依赖性。这听起来像对等依赖吗？</p><p id="5ffa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，外部依赖项指定了普通版本。对等依赖关系指定范围。</p><p id="e664" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要配置外部依赖项，需要将包指定为普通依赖项，并在配置文件中将它们设置为外部依赖项。</p><pre class="no np nq nr gt ns lx nt nu aw nv bi"><span id="4d9f" class="nc mg jj lx b gy nw nx l ny nz">external: ['packageName1', 'packageName2', 'packageName3']</span></pre><p id="586d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么它们不会被捆扎机捆扎。</p><p id="38c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于对等依赖，如果它们不存在于最终产品中，<code class="fe lu lv lw lx b">npm install</code>将抛出一个错误。但是，对于外部依赖项，如果它们不存在于最终产品中，打包程序会安装它们。</p><p id="f060" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果外部依赖项和最终产品的依赖项指定了不同的版本怎么办？它提供了一种可能性，即库使用外部依赖中定义的一个版本，而最终产品使用自己的版本。但是，不鼓励捆绑包的多个版本。它扩大了包的大小并引入了错误(例如多重反应错误)。</p><p id="a9e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让事情变得更复杂的是，有rollup和webpack插件可以自动使所有依赖成为外部的。</p><p id="4e7a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">听起来探索起来很有趣！</p><p id="5006" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae jg" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>