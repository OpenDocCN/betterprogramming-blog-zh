<html>
<head>
<title>The Basics of Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号的基础</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-basics-of-big-o-notation-e67228e549d2?source=collection_archive---------6-----------------------#2020-02-19">https://betterprogramming.pub/the-basics-of-big-o-notation-e67228e549d2?source=collection_archive---------6-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ccd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写快速高效代码的关键</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5fdd481f8a92c74da2eda5b4b782b1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVu8MFL3zQ29bch7lS_gpA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/s/photos/drama?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@panosskier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Panos Deligiannidis </a>拍摄</p></figure><p id="b9b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名开发人员，您可能听说过“大O符号”这个短语。到底是什么？你为什么要在乎？</p><p id="3e4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，学习大O符号不仅是技术面试的必要条件，也是编写快速高效代码的一个重要概念。</p><p id="2fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我从来都不是一个数学迷——老实说，这是我在学校最讨厌的科目——所以光是听到算法和大O就够吓人的了。然而，这是一个很容易掌握的概念，所以让我们深入研究一下吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8621" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么用大O符号？</h1><p id="f188" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">大O解决了是什么让一个功能比另一个更好。解决一个问题有多种方法，但最好的解决方案是<em class="mw">而不是</em>总是有效的。这就是大O的用武之地。大O基本上是一种系统分类算法运行时的方式——越快越好。虽然不同的机器硬件也会影响运行时间，但大O没有考虑这个问题——它不在乎精度，只在乎持续时间的总趋势。因此，当我们谈论一个函数的处理速度时，它被称为<em class="mw">时间复杂度</em>。当我们谈论<em class="mw">空间复杂度</em>时，我们指的是算法本身以及它占用了多少内存。在这篇文章中，我们将只关注大o的时间复杂度。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0e49" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">大O到底是什么<em class="mx">？</em></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/17838a00e08cb6c76de8a4f1b1492bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kIxfN2goP8qfFWjZmUvMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可能以前见过这个坏蛋；来源:<a class="ae kv" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></p></figure><p id="dbda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看上面的图表，x轴标记为“元素”, y轴标记为“操作”。<em class="mw"> " </em>元素说明一个函数可能需要处理多少输入，操作说明处理这些输入需要多少操作。该图方便地用绿色到红色的光谱来着色，绿色表示“优秀”，红色表示“糟糕”</p><p id="3ace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想谈谈我们看到的七个操作系统中的三个——O(1)、O(n)和O(n)——因为这是三个最基本的概念。让我们从O(1)的绿色区域开始。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1329" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">大O(1)——“1的O”——常数</h1><p id="0426" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">O(1)本质上是最快的运行时。它被认为是一个恒定的时间复杂度，因为随着元素或输入数量的增加，运行时不会有变化。一个简单的类比就是告诉队伍中的第十个人到前台来。只有一个人占据第10个位置，只有一个前台可以去。</p><p id="78a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，我们通过索引<code class="fe mz na nb nc b">m</code>访问数组中的一个元素。即使<code class="fe mz na nb nc b">myArr</code>有无限多的元素，<code class="fe mz na nb nc b">findElementInArr()</code>仍然只返回该索引的一个元素。这个函数不会遍历或迭代每一个元素——它只会像快捷方式一样直接遍历那个元素。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="1d6d" class="nh ma iq nc b gy ni nj l nk nl"><strong class="nc ir">O(1) Example:<br/></strong>let myArr = ["a", "b", "c", "d"]</span><span id="4076" class="nh ma iq nc b gy nm nj l nk nl">const findElementInArr = (m, arr) =&gt; {<br/>  return arr[m];<br/>};<br/>findElementInArr(3, myArr); //=&gt; d</span></pre><p id="c9eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据经验，注意到基本的数学运算、变量赋值、访问数组和对象中的元素都是常量是很有帮助的。让我们来看看O(n)与O(1)相比如何。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5a6b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">大O(n)——“n的O”——线性</h1><p id="3f09" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在图表上，我们从O(n)的极好的绿色区域<strong class="ky ir">移动到更不确定但是公平的黄色区域。</strong></p><p id="a830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">O(n)被认为是一个<em class="mw">线性时间复杂度</em>，因为一个函数处理所花费的时间是以n<em class="mw">n</em>的倍数为界的。换句话说，操作完成处理所需的时间与输入<em class="mw"> n </em>的大小直接相关。如果<em class="mw"> n </em>的大小很大，那么运行算法所需的时间也会很长。我们可以想到任何循环，或者“查找”函数，比如像<code class="fe mz na nb nc b">map</code>、<code class="fe mz na nb nc b">filter</code>或者<code class="fe mz na nb nc b">forEach</code>这样的内置JavaScript方法都是O(n)。</p><p id="36dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我简单的类比，我们可以认为那条线上的每个人都在一个接一个地显示他们的数字位置。在下面的例子中，我们看到这个函数有一个基本的for循环，它必须查找数组中的每一个元素来查看匹配的内容，然后控制台一个接一个地记录每个元素。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="7f4b" class="nh ma iq nc b gy ni nj l nk nl"><strong class="nc ir">O(n) Example:</strong> <br/>let myArr = ["a", "b", "c", "d"]</span><span id="01ad" class="nh ma iq nc b gy nm nj l nk nl">const printEachLetter = (arr) =&gt; {<br/>   for(i =0; i &lt; arr.length; i++){<br/>      console.log(arr[i])<br/>   }<br/>}<br/>printEachLetter(myArr);<br/>//=&gt; a<br/>//=&gt; b<br/>//=&gt; c<br/>//=&gt; d</span></pre><p id="763c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">O(n)的运行时间不是很好，但也不差。这可能是一个安全的选择。让我们进入最后一个概念，O(n)。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a25c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">O(n)——“n的平方的O”——二次型</strong></h1><p id="95fc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后但并非最不重要的(嗯，可能是最不重要的，因为它<em class="mw">被</em>认为是最差的运行时)，我们有O(n)。</p><p id="8ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当你看到有嵌套循环的算法，你总是可以假设时间复杂度是O(n)。O(n)里面的O(n)，aka O(n *n) aka O(n)的意思是随着<em class="mw"> n </em>的增长，运行时也在二次增长。二次时间复杂度相当慢，因为算法必须运行嵌套迭代。</p><p id="c6f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用我最后一次简单的类比，O(n)代表一个接一个地穿过那一排人，注意他们衣服的颜色，然后把所有穿同样颜色的人聚集在一起。在下面的例子中，我们使用嵌套循环遍历<code class="fe mz na nb nc b">myArr</code>,根据数组中元素的长度将所有颜色与每种可能的颜色组合配对。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="ac6c" class="nh ma iq nc b gy ni nj l nk nl"><strong class="nc ir">O(n²)Example: </strong><br/>let myArr = ["green", "blue", "purple", "green", "red"]</span><span id="ada9" class="nh ma iq nc b gy nm nj l nk nl">const allPossibleColorCombinations = (arr) =&gt; {<br/>    for (var i = 0; i &lt; arr.length; i++){<br/>         for(var j = 0; j &lt; arr.length; j++) {<br/>             console.log(arr[i],arr[j])<br/>         };<br/>    };<br/>};<br/>printAllPairs(myArr)<br/>//=&gt;green green<br/>green blue<br/>green purple<br/>green yellow<br/>green red<br/>blue green<br/>blue blue<br/>blue purple<br/>blue yellow<br/>blue red<br/>purple green<br/>purple blue<br/>purple purple<br/>purple yellow<br/>purple red<br/>yellow green<br/>yellow blue<br/>yellow purple<br/>yellow yellow<br/>yellow red<br/>red green<br/>red blue<br/>red purple<br/>red yellow<br/>red red</span></pre><p id="4d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所想象的，考虑到输出的庞大规模，该算法的运行时间比O(1)和O(n)要长得多。根据您可能编写的代码库，O(n)算法可能会大大降低运行时间。对于像脸书或Twitter这样的大型应用程序，O(n)算法并不好用！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a269" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">后续步骤</h1><p id="a02e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在你有了，三个基本的大O符号，你可以开始在你的代码中实现了！</p><p id="2003" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了这些知识，下一步是什么？好吧，作为一个开发者，我们写代码的时候一定要考虑解决问题。理解你试图解决的问题将会把合适的解决问题的模式反馈给你。诸如冒泡排序、递归和暴力等概念都是不同的问题解决模式。幸运的是，这些解决问题的模式是可靠的，所以我们可以比较我们的代码进行优化。了解这些概念将是一个很好的下一步。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bc2c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><p id="4744" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">以下是一些大O评分的常用算法:</p><div class="nn no gp gr np nq"><a href="https://www.bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">了解你的复杂性！</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.bigocheatsheet.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div><p id="964b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈推荐参加柯尔特·斯蒂尔在Udemy上的JavaScript算法和数据结构大师课:</p><div class="nn no gp gr np nq"><a href="https://www.udemy.com/share/101X5sAEAfdV1bTHQ=/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">JavaScript (JS)算法和数据结构大师班</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">这门课程将几个月的计算机科学和面试准备材料压缩成20小时的视频。内容基于…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.udemy.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe kp nq"/></div></div></a></div></div></div>    
</body>
</html>