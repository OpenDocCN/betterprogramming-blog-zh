<html>
<head>
<title>Clean Architecture with ent and gqlgen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用ent和gqlgen的干净架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-architecture-with-ent-and-gqlgen-a789933a3665?source=collection_archive---------2-----------------------#2021-12-13">https://betterprogramming.pub/clean-architecture-with-ent-and-gqlgen-a789933a3665?source=collection_archive---------2-----------------------#2021-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6900" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在GraphQL应用中编写可维护的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/639497fa9cfa9d5877b4d1cb15baaab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihMpYB7tAYcTwC7-cLBAmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ruthanium" rel="noopener ugc nofollow" target="_blank">露丝D </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="dc54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将带您了解如何使用ent和gqlgen包实现一个具有干净架构的GraphQL应用程序。</p><p id="e3bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Clean Architecture允许我们通过使用明确的规则将代码设计成几层来创建可维护和可测试的项目。这篇文章不是介绍干净架构的基本概念，而是强调如何在GraphQL应用程序中实际实现它。如果你想在继续之前了解这个概念，看一看<a class="ae ky" href="https://manakuro.medium.com/clean-architecture-with-go-bce409427d31" rel="noopener">这篇文章</a>。</p><p id="1910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/ent/ent" rel="noopener ugc nofollow" target="_blank"> ent </a>是一个用于Go的ORM框架，而<a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>是一个用于构建GraphQL服务器的库。它们都基于模式优先的方法，并使用生成器提供静态类型的API。我在之前的文章中介绍了这些的整合，所以你可以看看。</p><h1 id="a374" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">示例存储库</h1><p id="a532" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">以下是GitHub的最终代码:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/manakuro/golang-clean-architecture-ent-gqlgen" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">GitHub-manakuro/golang-Clean-Architecture-ent-gqlgen:带有ent和gqlgen的清洁建筑</h2><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ks mv"/></div></div></a></div><h1 id="7529" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">文件夹结构</h1><p id="9676" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最终的文件夹结构如下:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="089a" class="no lw it nk b gy np nq l nr ns">├── bin<br/>├── cmd<br/>│  ├── app<br/>│  └── migration<br/>├── config<br/>├── docker<br/>├── ent<br/>├── graph<br/>├── pkg<br/>│  ├── adapter<br/>│  │  ├── controller<br/>│  │  ├── handler<br/>│  │  ├── repository<br/>│  │  └── resolver<br/>│  │<br/>│  ├── const<br/>│  ├── entity<br/>│  │  └── model<br/>│  │<br/>│  ├── infrastructure<br/>│  │  ├── datastore<br/>│  │  ├── graphql<br/>│  │  └── router<br/>│  │<br/>│  ├── registry<br/>│  │<br/>│  ├── usecase<br/>│  │  ├── repository<br/>│  │  └── usecase</span></pre><p id="6f1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将逐步设置这些。</p><h1 id="57aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施概述</h1><ul class=""><li id="078a" class="nt nu it lb b lc mn lf mo li nv lm nw lq nx lu ny nz oa ob bi translated">设置开发环境</li><li id="5cf7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">设置回显</li><li id="69e6" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">设置ent</li><li id="1faa" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">设置gqlgen</li><li id="9e67" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">询问</li><li id="3a86" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">变化</li><li id="2418" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">干净的建筑</li><li id="ecb1" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">处理ULIDs</li><li id="35d7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">节点接口</li><li id="15f7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">页码</li><li id="e298" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">输入过滤器</li><li id="789b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">处理错误</li><li id="e775" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">处理交易</li><li id="43e7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">测试</li><li id="1a2e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">E2E</li></ul><h1 id="5eff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置开发环境</h1><p id="0cf4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本节中，我们将设置这些环境:</p><ul class=""><li id="946a" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">带有docker的MySQL</li><li id="7ff5" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">数据库的初始化</li><li id="edd5" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">配置文件</li></ul><h2 id="4642" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">带有docker的MySQL</h2><p id="aaba" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">本帖将使用MySQL8.0搭配docker。</p><p id="727b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加<code class="fe ov ow ox nk b">docker/docker-compose.yml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a54e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行起来就可以连接MySQL了。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3f17" class="no lw it nk b gy np nq l nr ns">$ cd docker<br/>$ docker compose up</span></pre><h2 id="cd67" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">数据库的初始化</h2><p id="df52" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要在MySQL中初始化数据库，在<code class="fe ov ow ox nk b">docker/mysql/sql/reset_database.sql</code>中创建SQL文件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，为了执行这个SQL，创建<code class="fe ov ow ox nk b">bin/init_db.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fb1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把docker容器中的<code class="fe ov ow ox nk b">./mysql_data/sql</code>移动到<code class="fe ov ow ox nk b">/var/lib/mysql/</code>，并通过docker命令执行SQL。</p><p id="1b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，运行命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c849" class="no lw it nk b gy np nq l nr ns">$ ./bin/init_db.sh</span></pre><p id="26f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到在MySQL中创建的数据库。</p><p id="c3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化命令，让我们创建<code class="fe ov ow ox nk b">Makefile</code>并添加脚本来初始化数据库。</p><p id="2674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根项目中创建<code class="fe ov ow ox nk b">Makefile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以通过运行以下命令轻松完成初始化:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a028" class="no lw it nk b gy np nq l nr ns">$ make setup_db</span></pre><h2 id="63f2" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">配置文件</h2><p id="6466" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了方便地访问共享配置文件，我们将引入<a class="ae ky" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank"> viper </a>包。</p><p id="e2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先安装它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3d4a" class="no lw it nk b gy np nq l nr ns">$ go get github.com/spf13/viper</span></pre><p id="60cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并创造出这样的<code class="fe ov ow ox nk b">config/config.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将读取名为<code class="fe ov ow ox nk b">./config.yml</code>的YAML文件，并允许您在整个应用程序中使用它。</p><p id="255a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们这样补充一下<code class="fe ov ow ox nk b">config/config.yml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="15f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件旨在用作开发模式中的数据库连接和服务器端口。</p><p id="1616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在应用程序中使用它，导入配置包并像这样调用<code class="fe ov ow ox nk b">ReadConfig</code>:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5437" class="no lw it nk b gy np nq l nr ns">config.ReadConfig(config.ReadConfigOption{})</span><span id="7d14" class="no lw it nk b gy pa nq l nr ns">fmt.Println(config.C.Server.Address) // 8080</span></pre><h1 id="aacc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置回显</h1><p id="8b24" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了快速开始，我们将使用<a class="ae ky" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank"> echo </a>包设置一个服务器。</p><p id="8f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装软件包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ea97" class="no lw it nk b gy np nq l nr ns">$ go get github.com/labstack/echo/v4<br/>$ go get github.com/labstack/echo/v4/middleware</span></pre><p id="2d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加<code class="fe ov ow ox nk b">cmd/app/main.go</code>中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="939b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这将在<a class="ae ky" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080: </a>成功响应</p><h2 id="faf6" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">热重装</h2><p id="9604" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/cosmtrek/air" rel="noopener ugc nofollow" target="_blank"> air </a>是Go项目的现场重装包。让我们把它引入到我们的应用程序中，以便更快地开发。</p><p id="8f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a33d" class="no lw it nk b gy np nq l nr ns">$ go install github.com/cosmtrek/air@v1.27.3</span></pre><p id="b440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根项目中创建<code class="fe ov ow ox nk b">.air.toml</code>,并编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种配置允许我们观察新的变化并自动重建。</p><p id="a03c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4dcc" class="no lw it nk b gy np nq l nr ns">$ air</span></pre><p id="f012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以看到这样的日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/9894fe9a76c6f4c8aad452215cbfcb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dq0g_mtzGLq_85f-7sCodQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">空气</p></figure><p id="09de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化命令，让我们添加脚本来启动服务器。</p><p id="c571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">Makefile</code>并添加脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e15f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以通过运行以下命令来启动服务器:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2bf3" class="no lw it nk b gy np nq l nr ns">$ make start</span></pre><h1 id="3b24" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置ent</h1><p id="057d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将把<a class="ae ky" href="https://github.com/ent/ent" rel="noopener ugc nofollow" target="_blank"> ent </a>包引入到我们的应用程序中，并配置数据库。</p><p id="0e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，假设将创建这些表:</p><ul class=""><li id="fa1e" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">用户—用户可以有多个待办事项</li><li id="e676" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">todos—todos可以有一个用户</li></ul><p id="c5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两者的关系是一对多的关系。</p><h2 id="64b1" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">安装ent</h2><p id="1f99" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们安装它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="dbd1" class="no lw it nk b gy np nq l nr ns">$ go get -d entgo.io/ent/cmd/ent</span></pre><h2 id="905c" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">创建用户模式</h2><p id="9b68" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们将创建一个用户模式。</p><p id="25da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="dff0" class="no lw it nk b gy np nq l nr ns">$ ent init User</span></pre><p id="7a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，<code class="fe ov ow ox nk b">ent</code>目录应该是这样的:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6951" class="no lw it nk b gy np nq l nr ns">ent<br/>├── generate.go<br/>└── schema<br/>    └── user.go</span></pre><p id="617e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">ent/schema/user.go</code>并添加如下字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c9c0" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><h2 id="0d5e" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">数据库迁移</h2><p id="24f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经准备好将模式迁移到数据库。</p><p id="6b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了运行迁移，创建<code class="fe ov ow ox nk b">cmd/migration/main.go</code>并编写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将迁移脚本添加到<code class="fe ov ow ox nk b">Makefile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行以下命令:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6459" class="no lw it nk b gy np nq l nr ns">$ make migrate_schema</span></pre><p id="216f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迁移后，您可以看到数据库中创建的用户表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/ef28d09a739d7463a955beb6a181b696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVz2aMGPy_l11GW0_YOs7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户表</p></figure><h2 id="3db5" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">创建todo架构</h2><p id="ce4a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将向我们的应用程序添加一个todo模式，并将其连接到<code class="fe ov ow ox nk b">users</code>边缘。</p><p id="34d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将通过运行以下命令创建一个todo模式:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a0a7" class="no lw it nk b gy np nq l nr ns">$ ent init Todo</span></pre><p id="bb07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到创建的todo模式文件:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2dbf" class="no lw it nk b gy np nq l nr ns">ent/schema<br/>├── todo.go<br/>└── user.go</span></pre><p id="ab5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">ent/schema/todo.go</code>，添加一些字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="cc07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要连接用户模式，将edge类型添加到<code class="fe ov ow ox nk b">Edges</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fe9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要配置边缘，打开<code class="fe ov ow ox nk b">ent/schema/user.go</code>，像这样添加边缘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然todo表已经将user_id作为外键。</p><p id="046e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1ad7" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><p id="f28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并迁移它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="affc" class="no lw it nk b gy np nq l nr ns">$ make migrate_schema</span></pre><p id="7847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，todos表创建如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/e32e85b6cbf9d7b8d4e6a8138155c660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OO9Bwt_Svbkm7KAcObpd4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">todos表</p></figure><p id="20b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pe">注意:ent默认使外键</em><a class="ae ky" href="https://github.com/ent/ent/blob/master/entc/gen/graph.go#L459" rel="noopener ugc nofollow" target="_blank"><em class="pe"/></a><em class="pe">为空。</em> <a class="ae ky" href="https://github.com/ent/ent/pull/1703" rel="noopener ugc nofollow" target="_blank"> <em class="pe"> PR </em> </a> <em class="pe">合并后，可以根据需要边设置</em> <code class="fe ov ow ox nk b"><em class="pe">NOT NULL</em></code> <em class="pe">为外键。</em></p><h2 id="feb0" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">模式描述</h2><p id="ce9a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ent提供了<code class="fe ov ow ox nk b"><a class="ae ky" href="https://entgo.io/docs/code-gen/#schema-description" rel="noopener ugc nofollow" target="_blank">ent describe</a></code>来获取您图形模式的描述。</p><p id="3b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="51a5" class="no lw it nk b gy np nq l nr ns">$ ent describe ./ent/schema</span></pre><p id="7f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/64243b163d9c3d692c87af7628294a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqel6aKOcKYarc1wWX8dxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输入shema描述</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="820a" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">设置gqlgen</h1><p id="7dbf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了将GraphQL集成到ent包中，<a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>包是可用的，<code class="fe ov ow ox nk b">entgql</code>包作为插件提供。</p><p id="5321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，安装gqlgen:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ff08" class="no lw it nk b gy np nq l nr ns">$ go get github.com/99designs/gqlgen</span></pre><p id="32a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要设置gqlgen，请运行以下初始化:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7c4d" class="no lw it nk b gy np nq l nr ns">$ gqlgen init</span></pre><p id="b8d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在根项目下生成以下布局:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f060" class="no lw it nk b gy np nq l nr ns">├── gqlgen.yml<br/>├── graph<br/>│   ├── generated<br/>│   │   └── generated.go<br/>│   ├── model<br/>│   │   └── models_gen.go<br/>│   ├── resolver.go<br/>│   ├── schema.graphqls<br/>│   └── schema.resolvers.go</span></pre><p id="3800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动GraphQL服务器，打开<code class="fe ov ow ox nk b">cmd/app/main.go</code>并编写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="15ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在<a class="ae ky" href="http://localhost:8080/playground:" rel="noopener ugc nofollow" target="_blank">可以看到操场页面http://localhost:8080/playground:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/ffa1a51d42a74b29d14629395eb457eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-voFsCd3J492sDOsY9j2AA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL游乐场</p></figure><h2 id="86ed" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">将ent连接到gqlgen</h2><p id="9731" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先安装插件包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="91fa" class="no lw it nk b gy np nq l nr ns">$ go get entgo.io/contrib/entgql</span></pre><p id="fd11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在ent项目中使用<code class="fe ov ow ox nk b">gqlgen</code>，需要对我们的项目启用ent扩展。</p><p id="4d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，创建一个名为<code class="fe ov ow ox nk b">ent/entc.go</code>的新文件，并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="181c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，打开<code class="fe ov ow ox nk b">ent/generate.go</code>并将代码改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="9267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7556" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><p id="e2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，为了在<code class="fe ov ow ox nk b">gelgen</code>解析器中使用<code class="fe ov ow ox nk b">ent.Client</code>,打开<code class="fe ov ow ox nk b">graph/resolver.go</code>,并将其作为附加的依赖项传递给模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="eaca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将<code class="fe ov ow ox nk b">ent.Cleint</code>传给<code class="fe ov ow ox nk b">cmd/app/main.go</code>中的<code class="fe ov ow ox nk b">graph.NewSchema</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="9a7a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">询问</h1><p id="adc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们现在已经完成了GraphQL的配置。在下一步中，让我们创建一个查询，并尝试用ent客户机检索数据。</p><h2 id="9d4b" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">用户查询</h2><p id="efab" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，打开<code class="fe ov ow ox nk b">graph/schema.graphqls</code>并更改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并创建<code class="fe ov ow ox nk b">graph/user.graphqls</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将用户类型绑定到ent模型，需要在<code class="fe ov ow ox nk b">gqlgen.yml</code>中修改<code class="fe ov ow ox nk b">autobind</code>选项，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="764a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并注释掉模型选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ead0" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="c7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/user.resolvers.go</code>并写下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在操场上，运行用户查询，您可以看到响应的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/266248cda80cf28dea056b2c9b64026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWEdDme7005Naul4cCUVbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure><h2 id="5c8f" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">待办事项查询</h2><p id="8396" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们在下一步中向我们的应用程序添加一个todo查询。</p><p id="d34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">graph/todo.graphqls</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="0ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">TestTodoStatus</code>需要绑定到ent模型，因此，打开<code class="fe ov ow ox nk b">gqlgen.yml</code>并将<code class="fe ov ow ox nk b">TodoStatus</code>添加到<code class="fe ov ow ox nk b">models</code>选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2c50" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="5960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/todo.resolvers.go</code>并写下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="cdce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询结果应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/6c4ecc37e5157e69b3c9c740e007f0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBHeLFEcSo_ly8mucNTeKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">待办事项查询</p></figure><p id="eecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经实现了todos查询，所以我们可以将它包含在用户查询中。</p><p id="b5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/user.graphqls</code>并将<code class="fe ov ow ox nk b">todos</code>添加到用户查询中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="840c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2479" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="812d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询用户，结果应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/eaee40e1a7dd0a92f1c573d23a130808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_bN4ITxazTZeoeeZ7C-3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户查询</p></figure><h1 id="6776" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">变化</h1><p id="39e5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步，我们将使用ent客户机实现变异。</p><p id="9a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在<code class="fe ov ow ox nk b">graph/schema.graphqls</code>中添加突变类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="cba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/user.graphqls</code>并添加突变类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将<code class="fe ov ow ox nk b">CreateUserInput</code>和<code class="fe ov ow ox nk b">UpdateUserInput</code>绑定到gqlgen，需要在ent包中创建模型。</p><p id="8a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了自动绑定模型，我们将使用ent包提供的<a class="ae ky" href="https://entgo.io/docs/templates/" rel="noopener ugc nofollow" target="_blank">模板</a>特性。</p><p id="78ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">ent/templates/mutation_input.tmpl</code>并粘贴:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ce38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">ent/entc.go</code>并像这样添加选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="bc1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e8ed" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><p id="bb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，<code class="fe ov ow ox nk b">ent/mutation_input.go</code>已经用<code class="fe ov ow ox nk b">CreateTodoInput</code>和<code class="fe ov ow ox nk b">UpdateTodoInput</code>类型生成，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="23df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经准备好将这些绑定到gqlgen，所以运行这个:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2e9a" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="746d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将解析器添加到<code class="fe ov ow ox nk b">graph/user.resolvers.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在操场上执行<code class="fe ov ow ox nk b">createUser</code>，结果应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/37d32e8c4a144e84905a35ee37a5a245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5l4bbdCzZ0VsROk15HGNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="d4a2" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">干净的建筑</h1><p id="918b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了将Clean Architecture集成到我们的应用程序中，将引入四个层，并与文件夹匹配如下。</p><ul class=""><li id="fce8" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">实体层-实体</li><li id="272f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">用例层-用例</li><li id="ad84" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">接口适配器层—适配器</li><li id="8e8c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">框架和驱动因素层—基础设施</li></ul><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="cdb4" class="no lw it nk b gy np nq l nr ns">pkg<br/>├── adapter<br/>│ ├── controller   # Controller<br/>│ ├── repository   # Specific implementaion of repository<br/>│ └── resolver     # GraphQL resolvers<br/>│ <br/>│ <br/>├── entity<br/>│ └── model        # Entity of model, (e.g. ent.User, ent.Todo)<br/>│ <br/>│ <br/>├── infrastructure<br/>│ ├── datastore    # MySQL configuration<br/>│ ├── graphql      # GrahpQL configuration<br/>│ └── router       # Echo router<br/>│ <br/>│ <br/>├── usecase<br/>│ ├── repository   # Interface for adapter<br/>│ └── usecase      # Usecase for application logic</span></pre><h2 id="ffe1" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实体层</h2><p id="b11e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">实体层应该包括整个应用程序的领域模型。在我们的应用程序中，ent包对此负责，但是我们不希望在每一层都导入ent包，并让它们依赖于特定的技术，这会导致违反依赖规则。不断变化的技术对代码库的影响需要最小化。</p><p id="9c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，只需在<code class="fe ov ow ox nk b">entity/model</code>中导入ent包。然后，其他层可以从<code class="fe ov ow ox nk b">entity/model</code>导入它们作为领域模型。</p><p id="a2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们创造<code class="fe ov ow ox nk b">pkg/entity/model/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="87d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用现有的方法和结构类型，需要将模型定义为别名声明，而不是嵌入式结构或类型定义。</p><p id="7884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pe">注意:可以使用允许您在Go中扩展方法的嵌入式结构，但在某些情况下，gqlgen生成器可能不符合其类型。</em></p><p id="d113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于todo，创建<code class="fe ov ow ox nk b">pkg/entity/model/todo.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="7aab" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">用例层</h2><p id="ec5c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">用例层有两个目录:</p><ul class=""><li id="3188" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">仓库</li><li id="e32e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">用例</li></ul><h2 id="c6c6" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">仓库</h2><p id="6354" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">知识库目录为实体模型提供CRUD API接口。这是为了在用例文件夹中使用。</p><p id="8e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/usecase/repository/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="4505" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">用例</h2><p id="4257" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在usecase文件夹中，创建<code class="fe ov ow ox nk b">pkg/usecase/usecase/user.go</code>并调用接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="b5ce" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">接口适配器层</h2><p id="b2a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接口适配器层有三个目录:</p><ul class=""><li id="4c0f" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">控制器</li><li id="025e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">仓库</li><li id="9b76" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">分解器</li></ul><h2 id="0f1b" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">控制器</h2><p id="09b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">控制器目录旨在从GraphQL解析器中使用，并调用usecase包。</p><p id="faa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建<code class="fe ov ow ox nk b">pkg/adapter/controller/controller.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并创建<code class="fe ov ow ox nk b">pkg/adapter/controller/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="68df" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">仓库</h2><p id="95c1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在repository文件夹中，用例存储库的具体实现将被包含进来，并符合它的类型。为了持久化数据库，将使用ent包。</p><p id="ceb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/adapter/repository/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="67b9" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">分解器</h2><p id="502a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">解析器目录包括一组由gqlgen命令生成的解析器。为了将文件从<code class="fe ov ow ox nk b">graph</code>移动到<code class="fe ov ow ox nk b">pkg/adapter/resolver</code>，打开<code class="fe ov ow ox nk b">gqlgen.yml</code>并修改解析器部分，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="654f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6eaf" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="1e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该目录应该如下所示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0cb6" class="no lw it nk b gy np nq l nr ns">pkg/adapter/resolver<br/>├── resolver.go<br/>├── schema.resolvers.go<br/>├── todo.resolvers.go<br/>└── user.resolvers.go</span></pre><h2 id="f899" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">登记处</h2><p id="c21e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要使用<code class="fe ov ow ox nk b">pkg/adapter/repository</code>中的ent客户端，需要初始化各层的函数并向下传递。</p><p id="1364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创造<code class="fe ov ow ox nk b">pkg/registry/registry.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个生成所有控制器的根注册表函数。</p><p id="f424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建<code class="fe ov ow ox nk b">pkg/registy/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将ent客户端传递给<code class="fe ov ow ox nk b">pkg/adapter/repository</code>，并符合<code class="fe ov ow ox nk b">pkg/usecase/repositry</code>中存储库的接口。</p><h2 id="40ca" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">在解析器中使用控制器</h2><p id="fd25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了使用来自解析器函数的控制器，将其传递给解析器初始化。</p><p id="6f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">pkg/adapter/resolver/resolver.go</code>并像这样添加控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="be3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，打开<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>并调用解析器功能中的控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="5478" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">框架和驱动程序层</h2><p id="7bd5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">框架和驱动程序层有三个目录:</p><ul class=""><li id="8872" class="nt nu it lb b lc ld lf lg li oh lm oi lq oj lu ny nz oa ob bi translated">数据存储</li><li id="b18f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">graphql</li><li id="4cad" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">路由器</li></ul><h2 id="cc82" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">数据存储</h2><p id="1b11" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">数据存储目录包含与初始化数据库和客户端相关的代码。</p><p id="a0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/infrastructure/datastore/datastore.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="e245" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">graphql</h2><p id="f596" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">graphql目录负责生成一个graphql服务器。</p><p id="1d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/infrastructure/graphql/graphql.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="d7fe" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">路由器</h2><p id="c7ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">路由器目录实现了HTTP路由器。</p><p id="69ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/infrastructure/router/router.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="ff4f" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">主要功能</h2><p id="a727" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经完成了每一层的组织，所以最后，打开<code class="fe ov ow ox nk b">pkg/cmd/app/main.go</code>并编写如下初始化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="f781" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">组织创建和更新功能</h2><p id="f6d2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">类似于上面的步骤，创建和更新功能需要根据干净的架构来组织。</p><p id="d946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到下面的更改:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/manakuro/golang-clean-architecture-ent-gqlgen/pull/1" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">通过manakuro拉动式请求#1组织创建和更新功能…</h2><div class="px l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">将此建议添加到可以作为单次提交应用的批处理中。此建议无效，因为没有更改…</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="py l nf ng nh nd ni ks mv"/></div></div></a></div><h1 id="5ed5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">处理ULIDs</h1><p id="56a3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在ent包中，<code class="fe ov ow ox nk b">int</code> type默认用作数据库中的id字段，并自动递增。对于某些应用程序，需要避免递增的数字，最好使用UUIDs或ULIDs。因为我们在应用程序中使用MySQL，所以由于性能问题，可以排序的id最好用作主键。</p><p id="4ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<a class="ae ky" href="https://github.com/ent/contrib/pull/34" rel="noopener ugc nofollow" target="_blank"> PR </a>的贡献，ent包有了它的<a class="ae ky" href="https://github.com/ent/contrib/tree/master/entgql/internal/todopulid" rel="noopener ugc nofollow" target="_blank">例子</a>和ULIDs。</p><p id="3513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们按照示例在我们的应用程序中实现ULIDs。</p><p id="b56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增加</p><p id="1cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，为Go安装ULIDs包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="de59" class="no lw it nk b gy np nq l nr ns">$ go get github.com/oklog/ulid/v2</span></pre><h2 id="f350" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">将ID字段更改为ULIDs</h2><p id="ddf1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">ent/schema/ulid/ulid.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ed68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了配置要定制的id字段，打开<code class="fe ov ow ox nk b">ent/schema/user.go</code>并将id类型添加到<code class="fe ov ow ox nk b">Fields</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="48b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">GoType</code>用于转换为Go基本类型或实现<a class="ae ky" href="https://pkg.go.dev/entgo.io/ent/schema/field?tab=doc#ValueScanner" rel="noopener ugc nofollow" target="_blank"> ValueScanner </a>接口的类型。</p><p id="e601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">ent/schema/todo.go</code>，添加类型如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">user_id</code>也需要改成ulid类型。</p><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2e35" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><p id="cee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于ent迁移<a class="ae ky" href="https://github.com/ent/ent/issues/953#issuecomment-727808386" rel="noopener ugc nofollow" target="_blank">不支持</a>更改表的主键，所以我们需要在迁移模式之前更改或删除表，如下所示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="11f1" class="no lw it nk b gy np nq l nr ns">alter table users modify id varchar(255);<br/>alter table todos modify id varchar(255);</span></pre><p id="6cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行迁移:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4336" class="no lw it nk b gy np nq l nr ns">$ make migrate_schema</span></pre><h2 id="d854" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">将ULIDs绑定到gqlgen</h2><p id="dca0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，让我们更改gqlgen的ID模型，并将其绑定到ulid。</p><p id="e8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用pkg目录下的ulid类型，创建一个id类型到<code class="fe ov ow ox nk b">pkg/entity/model/id.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ab85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，打开<code class="fe ov ow ox nk b">gqlgen.yml</code>并将类型绑定到ID模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="fcf4" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="106f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c4e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到id参数已经从<code class="fe ov ow ox nk b">int</code>更改为<code class="fe ov ow ox nk b">ulid.ID</code>，因此让我们更改所有层中的id类型。</p><p id="04fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">pkg/adapter/controller/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2d8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">pkg/usecase/usecase/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">pkg/usecase/repository/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">pkg/adapter/repository/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="562d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，运行变异，响应应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/b815a52d9bf0941aec6935de14cd155f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uT9FQnIZIA_8PCKHy7KXUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ULIDs</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="d90b" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">节点接口</h1><p id="51b0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://relay.dev/graphql/objectidentification.htm" rel="noopener ugc nofollow" target="_blank">节点接口</a>是GraphQL中的一个标准方式，它通过在具有单一ID的根上查询来提供数据。</p><p id="3340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是这样的:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0ed6" class="no lw it nk b gy np nq l nr ns">{<br/>  node(id: "4") {<br/>    id<br/>    ... on User {<br/>      name<br/>    }<br/>  }</span></pre><p id="5d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ent包通过其GraphQL集成支持节点接口，所以让我们来实现它。</p><h2 id="2da0" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">向GraphQL添加节点接口</h2><p id="db62" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先打开<code class="fe ov ow ox nk b">graph/schema.graphqls</code>，添加节点界面和节点查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="27bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并打开<code class="fe ov ow ox nk b">graph/user.graphqls</code>，给用户添加界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ecc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建<code class="fe ov ow ox nk b">pkg/entity/model/node.go</code>的节点模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="1593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其绑定到<code class="fe ov ow ox nk b">gqlgen.yml</code>中的节点模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="fa75" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="c48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成后，节点的解析器已经在<code class="fe ov ow ox nk b">pkg/adapter/resolver/schema.resolvers.go</code>中创建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="ccc2" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">将ID映射到表</h2><p id="b2b7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在节点接口中，GraphQL服务器必须根据发送给。为此，我们需要确定ID包含在哪个表中。</p><p id="eb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，ULID被用作主键。通过给它添加前缀，我们可以检测出它是哪个表。</p><p id="c52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以像这样对users表使用<code class="fe ov ow ox nk b">0AA</code>,对todos表使用<code class="fe ov ow ox nk b">0AB</code>:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f11f" class="no lw it nk b gy np nq l nr ns">// users table<br/><strong class="nk iu">0AA</strong>01FPBT4QKAA...<br/><strong class="nk iu">0AA</strong>01FPBT4QKAA...<br/><strong class="nk iu">0AA</strong>01FPBT4QKAA...</span><span id="603b" class="no lw it nk b gy pa nq l nr ns">// todos table<br/><strong class="nk iu">0AB</strong>01FPBT4QKAA...<br/><strong class="nk iu">0AB</strong>01FPBT4QKAA...<br/><strong class="nk iu">0AB</strong>01FPBT4QKAA...</span></pre><p id="5d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们实现这一点。创建<code class="fe ov ow ox nk b">pkg/const/globalid/globalid.go</code>并这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个globalid包处理id和表的map对象，并提供一个函数来标识id包含在哪个表中。</p><p id="86d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，向用户模式和todo模式添加前缀。</p><p id="5396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">ent/schema/user.go</code>并给<code class="fe ov ow ox nk b">MustNew</code>函数添加前缀:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="471c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">todo模式也是如此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">MustNew</code>功能自动将前缀添加到ULID。</p><p id="c12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建<code class="fe ov ow ox nk b">ent/ulid.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="d891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这旨在用于解析器函数中，并返回表类型。</p><h2 id="af63" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实现解析器</h2><p id="41c6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经准备好提供来自节点解析器的数据。</p><p id="b72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">pkg/adapter/resolver/schema.resolvers.go</code>并写下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ov ow ox nk b">ent.WithNodeType</code>设置将ID映射到表的节点类型解析器功能。</p><p id="20a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们来测试一下。</p><p id="a144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，像这样创建用户:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/eed671330a07f56ef8f330e45404a4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1N91Ky4e8YXCAVyxlwXXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">节点接口</p></figure><p id="bcb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到前缀<code class="fe ov ow ox nk b">00A</code>已经附加到id上。</p><p id="ae1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并查询节点，它成功响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/dc8e0328032e7e25cb51b1d924cad233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hV0-PbUIS0xCeN-GYQ1CQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">节点接口</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="82c4" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">页码</h1><p id="d1db" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在GraphQL中处理分页时，最好实现<a class="ae ky" href="https://relay.dev/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank">中继光标连接</a>模式。ent包通过GraphQL集成支持这个规范。</p><h2 id="1950" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">添加Graphql类型</h2><p id="126d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，向GrahpQL文件添加一些类型。</p><p id="5da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/schema.graphqls</code>增加<code class="fe ov ow ox nk b">Cursor</code>和<code class="fe ov ow ox nk b">PageInfo</code>类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="c16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，打开<code class="fe ov ow ox nk b">graph/user.graphqls</code>并添加连接类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="3406" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">绑定模型</h2><p id="0c33" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经在GraphQL文件中创建了<code class="fe ov ow ox nk b">Cursor</code>和<code class="fe ov ow ox nk b">PageInfo</code>类型。为了在gqlgen中配置这些，我们需要在<code class="fe ov ow ox nk b">pkg/entity/model</code>中为它们创建类型。</p><p id="72c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/entity/model/pagination.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="f572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">pkg/entity/model/user.go</code>并添加类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="d3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="498b" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="5598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成后，在<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>中创建了用户解析器功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="c750" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实现分页</h2><p id="348b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">那么让我们在应用程序中实现分页。</p><p id="2647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在<code class="fe ov ow ox nk b">pkg/usercase/repository/user.go</code>中创建<code class="fe ov ow ox nk b">List</code>接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，像这样调用<code class="fe ov ow ox nk b">pkg/usecase/usecase/user.go</code>中的接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，调用<code class="fe ov ow ox nk b">pkg/adapter/controller/user.go</code>中的用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，将分页实现添加到<code class="fe ov ow ox nk b">pkg/adapter/repository/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，从<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>中的解析器功能调用控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="d8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经完成了分页，所以让我们测试一下。结果应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/865b53fecf0f157a25327627eb718a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iudl4S2oiFxz3VGCttRzSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="869f" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">过滤输入</h1><p id="c828" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将向GraphQL突变的输入中添加更多的条件。ent包允许我们在整个生成过程中使用类型安全的GraphQL过滤器。</p><h2 id="d026" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">配置ent</h2><p id="53e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要在ent中配置它，打开<code class="fe ov ow ox nk b">ent/entc.go</code>文件并添加这些扩展名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行生成:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d75c" class="no lw it nk b gy np nq l nr ns">$ go generate ./ent</span></pre><p id="96c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就产生了定义与输入过滤器相关的类型的<code class="fe ov ow ox nk b">graph/ent.graphql</code>。</p><h2 id="a2c9" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">配置gqlgen</h2><p id="82bd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">graph/user.graphqls</code>并将<code class="fe ov ow ox nk b">where: UserWhereInput</code>添加到<code class="fe ov ow ox nk b">users</code>查询中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="2335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要绑定模型，将类型添加到<code class="fe ov ow ox nk b">pkg/entity/model/user.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="17da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行发电机:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7997" class="no lw it nk b gy np nq l nr ns">$ gqlgen</span></pre><p id="8807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在生成之后，您可以看到<code class="fe ov ow ox nk b">where</code>参数已经被添加到位于<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>的用户解析器中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="2dcb" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实施过滤器输入</h2><p id="95e9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">pkg/usecase/repository/user.go</code>添加参数到<code class="fe ov ow ox nk b">List</code>界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="9b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其添加到<code class="fe ov ow ox nk b">pkg/usecase/usecase/user.go</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="930a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，打开<code class="fe ov ow ox nk b">pkg/adapter/controller/user.go</code>并将<code class="fe ov ow ox nk b">where</code>参数添加到<code class="fe ov ow ox nk b">List</code>界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="1818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ov ow ox nk b">pkg/adapter/repository/user.go</code>并将过滤器添加到<code class="fe ov ow ox nk b">List</code>方法中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="1cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将参数传递给<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>的控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="6670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在操场上，你可以在文档中看到过滤器列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/e07dbc1f9855037b6e8966bfad98754a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFfUrlFlr29Pr3UlpquD8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输入过滤器</p></figure><p id="1215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要一个30岁以上的用户列表，你可以这样写:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/4f95f2e14d4612542d161fe6bd5fb7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UCMcG8pfYnih6F7N43r0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="9652" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">处理错误</h1><p id="12bd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">gqlgen中生成的所有解析器都应该返回一个错误，并发送给最终用户。要返回多个错误，可以像这样使用<code class="fe ov ow ox nk b">graphql.AddError</code>函数:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="97b6" class="no lw it nk b gy np nq l nr ns">graphql.AddError(ctx, gqlerror.Errorf("error1!"))<br/>graphql.AddError(ctx, gqlerror.Errorf("error2!"))</span></pre><p id="fa0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应的错误应该是这样的:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="71eb" class="no lw it nk b gy np nq l nr ns">{<br/>  "data": {<br/>    "todo": null<br/>  },<br/>  "errors": [<br/>    { "message": "error1!", "path": [ "todo" ] },<br/>    { "message": "error2!", "path": [ "todo" ] },<br/>  ]<br/>}</span></pre><p id="d170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们将按照调用的顺序返回。</p><p id="3c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，我们将创建一个名为<code class="fe ov ow ox nk b">error</code>的模型，它处理所有被捕获的错误，并对最终用户做出适当的响应。此外，确保输出堆栈跟踪。</p><p id="1d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于堆栈跟踪，我们将介绍<a class="ae ky" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank">github.com/pkg/errors</a>。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="36c4" class="no lw it nk b gy np nq l nr ns">$ go get github.com/pkg/errors@v0.9.1</span></pre><p id="e1fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并像这样创建<code class="fe ov ow ox nk b">pkg/entity/model/error.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了在任何层中返回错误时调用。如果您处理一个数据库错误，那么需要在<code class="fe ov ow ox nk b">pkg/adapter/repository/user.go</code>中调用它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适配器层下的，它可以被多次调用，因为它包装了一个错误并返回一个新的错误。</p><p id="85ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在响应之前处理错误，我们将创建<code class="fe ov ow ox nk b">pkg/adapter/handler/error.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="f942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将展开所有错误，并通过<code class="fe ov ow ox nk b">graphql.AddError</code>功能将它们添加到响应中。</p><p id="0f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将此应用于旋变器。打开<code class="fe ov ow ox nk b">pkg/adapter/resolver/user.resolvers.go</code>并将处理器添加到<code class="fe ov ow ox nk b">CreateUser</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="836e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果名字的大小超过了，它会这样回应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/1c8ae31167ab450ad0fa4daf030dd84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2PYxEbn1jBM0OgE_h5xvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操场</p></figure><p id="12fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆栈跟踪如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/cef0135a1de8e9e6964d8fdc6ec77065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gI0dXoGmKPtct7lNzYohA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆栈跟踪</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="35d8" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">处理交易</h1><p id="6122" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ent包允许我们在一个数据库事务中执行每个GraphQL变化，方法是用一个事务自动包装这些变化，事务在最后提交，或者在GrahpQL出错时回滚。</p><p id="e51a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要进行配置，打开<code class="fe ov ow ox nk b">pkg/infrastructure/graphql/graphql.go</code>并添加选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ff3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/repository/with_transactional_mutation.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe ov ow ox nk b">CreateWithTodo</code>函数在一个事务中创建了一个用户和一个todo，我们可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="b5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果创建用户失败，则成功回滚事务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/81ead48ae0bed0dc137f34c5d339e005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvHqTGH-q-yJqufP8WxB9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反转</p></figure></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="7b55" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">测试</h1><p id="6177" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们的应用程序中，我们将使用数据库来测试存储库，而不是模仿界面。</p><h2 id="5f2d" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">设置数据库</h2><p id="aac0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，创建<code class="fe ov ow ox nk b">docker/mysql_date/sql/reset_database.test.sql</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建<code class="fe ov ow ox nk b">bin/init_db_test.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="4695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行这个:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3e1f" class="no lw it nk b gy np nq l nr ns">$ ./bin/init_db_test.sh</span></pre><h2 id="e337" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">设置环境</h2><p id="d5f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了配置数据库，创建<code class="fe ov ow ox nk b">testutil/config.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="a497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并创造了<code class="fe ov ow ox nk b">testutil/database.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="37c4" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实施测试</h2><p id="1a94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了简化测试，我们将通过表驱动测试和<a class="ae ky" href="http://wiki.c2.com/?ArrangeActAssert" rel="noopener ugc nofollow" target="_blank"> AAA (Arrange Act Assert) </a>模式来编写。</p><p id="3653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">pkg/adapter/repository/user_test.go</code>并写下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="054a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在安排部分，三个用户已经在数据库中准备好了。然后，在act部分，从存储库中调用List函数并断言结果。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d539" class="no lw it nk b gy np nq l nr ns">go test ./pkg/adapter/repository/...                                                                                                                                                         </span><span id="f412" class="no lw it nk b gy pa nq l nr ns">ok   golang-clean-architecture-ent-gqlgen/pkg/adapter/repository 0.556s</span></pre></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="f453" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">E2E</h1><p id="57e9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="http://httpexpect" rel="noopener ugc nofollow" target="_blank"> httpexpect </a>是针对Go的端到端HTTP和API测试。这基本上是为了用于Rest API，而不是GraphQL。但实际上，要测试GraphQL服务器，您需要做的就是使用POST方法并发送一个查询。</p><h2 id="2b5c" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">安装httpextect</h2><p id="be25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">安装httpextect:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="580f" class="no lw it nk b gy np nq l nr ns">$ go get github.com/gavv/httpexpect/v2</span></pre><h2 id="6b05" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">设置数据库</h2><p id="b395" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样，我们将首先为E2E测试准备一个数据库。</p><p id="0c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">docker/mysql_date/sql/reset_database.e2e.sql</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fb17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并添加了<code class="fe ov ow ox nk b">bin/init_db_e2e.sh</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="5e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，运行脚本:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5628" class="no lw it nk b gy np nq l nr ns">./bin/init_db_e2e.sh</span></pre><h2 id="923c" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">设置环境</h2><p id="7640" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了配置数据库，将<code class="fe ov ow ox nk b">ReadConfigE2E</code>添加到<code class="fe ov ow ox nk b">testutil/config.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="401e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">testutil/e2e/e2e.go</code>并添加一些实用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="ab2a" class="no lw it bd lx ok ol dn mb om on dp mf li oo op mh lm oq or mj lq os ot ml ou bi translated">实施测试</h2><p id="e564" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">创建<code class="fe ov ow ox nk b">test/e2e/mutation/user_test.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向GraphQL服务器发送查询，请使用POST方法并添加一个字符串形式的查询，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="9b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行测试:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e0e8" class="no lw it nk b gy np nq l nr ns">$ go test ./test/e2e/...</span><span id="0516" class="no lw it nk b gy pa nq l nr ns">ok   golang-clean-architecture-ent-gqlgen/test/e2e/mutation 0.525s</span></pre></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h1 id="f10c" class="lv lw it bd lx ly pn ma mb mc po me mf jz pp ka mh kc pq kd mj kf pr kg ml mm bi translated">结论</h1><p id="4cf5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如您所看到的，使用ent和gqlgen包，它们是强类型安全的API，使您的应用程序更加可靠和可维护。此外，构建干净的架构使其更加灵活和可测试。</p><p id="b0a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里查看最终代码:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/manakuro/golang-clean-architecture-ent-gqlgen" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">GitHub-manakuro/golang-Clean-Architecture-ent-gqlgen:带有ent和gqlgen的清洁建筑</h2><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="qf l nf ng nh nd ni ks mv"/></div></div></a></div></div></div>    
</body>
</html>