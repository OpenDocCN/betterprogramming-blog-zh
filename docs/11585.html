<html>
<head>
<title>Dockerizing a Go App — and Optimising Its Image Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Go应用程序归档，并优化其图像大小</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-a-go-app-45ca034263ca?source=collection_archive---------6-----------------------#2022-04-01">https://betterprogramming.pub/dockerizing-a-go-app-45ca034263ca?source=collection_archive---------6-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a68f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">多阶段构建比单阶段构建提高了约51倍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f807604b8229651fe07faf9d21c086f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqZ0foonHNLKRqYsbhLcxw.jpeg"/></div></div></figure><h1 id="e8f2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">Docker是什么？</h1><p id="e8be" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Docker是一个开源工具，可以为您的后端服务或应用程序生成和运行可移植的、自给自足的容器。容器可以在任何支持Docker的设备上运行——云服务、本地设备，甚至是您的本地开发机器。</p><p id="4981" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">开发人员(您)能够以可重复的、基础设施即代码的方式定义程序可用的环境和依赖关系。</p><p id="e018" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">构建过程使用<code class="fe mk ml mm mn b">Dockerfile</code>定义，设置说明可以在<a class="ae mo" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="8a2d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么要用Docker？</h1><p id="098a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Docker有一个<a class="ae mo" href="https://www.docker.com/why-docker/" rel="noopener ugc nofollow" target="_blank">伟大的解释者</a>，但它归结为开发者效率。通过定义代码运行的确切环境，每个人都可以在同一个页面上，无论他们是在本地以开发模式运行、调试生产中断，还是探索多云部署。不再需要花费几天时间来设置开发环境，并且“在我的机器上运行良好”的紧张感消失了。Docker并不是唯一提供这些好处的工具，但是它确实很受欢迎，并且有一个庞大的社区围绕着它。</p><h1 id="08d4" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">我们的第一个容器</h1><p id="5b0f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们将集中在容器化Chuck Norris笑话服务器T10上，这是我之前写的。</p><p id="4493" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们将从<a class="ae mo" href="https://www.alpinelinux.org" rel="noopener ugc nofollow" target="_blank"> Alpine Linux </a>开始构建，这是一个轻量级发行版，它有一个包管理器和其他我们在构建代码时可能需要的工具。在这种情况下，我们将使用一个特定于Golang 1.17的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6bd5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来，我们将使用我们的包管理器<code class="fe mk ml mm mn b">apk</code>，安装构建我们的应用程序所需的任何依赖项。在这种情况下，我们只需要<code class="fe mk ml mm mn b">ca-certificates</code>来提供客户端和服务器之间的安全连接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1db4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来，我们将建立一个工作目录来构建我们的应用程序。从Dockerfile文件的这一点开始，我们将在这个目录中工作。在这里，我们将本地目录中的所有内容复制到Docker映像的工作目录中，但是如果有构建映像不需要的文件，您可以更有选择性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9688" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mk ml mm mn b">Copy</code>的形式是<code class="fe mk ml mm mn b">Copy &lt;source location&gt; &lt;destination location&gt;</code>，所以我们说“将本地机器上这个目录中的内容复制到我们正在构建的映像的工作目录中。”</p><p id="a8f1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来，我们将构建我们的代码。对于Go，我们从源材料编译并构建一个二进制文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d0d2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果你已经构建了许多Go应用程序，这看起来会很熟悉，但如果没有，它实际上是在说“使用这个代码构建一个名为<code class="fe mk ml mm mn b">joke-web-server</code>的二进制文件，并将这个二进制文件放在‘这里’”。这个二进制可以静态链接(二进制不会依赖于操作系统的库)，我们打算在linux上运行它。”</p><p id="1791" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们将通过记录应用程序监听的端口(在容器内部)来完成我们的<code class="fe mk ml mm mn b">Dockerfile</code>，并且我们将定义当结果映像运行时如何运行应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0dda" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mk ml mm mn b">EXPOSE</code>实际上并没有做太多，它本质上是应用程序在Docker 内部的端口5000 <em class="mr">上监听的文档。应用程序代码监听端口5000，所以我们在这里记录下来。我们将在运行映像时在主机上设置端口。</em></p><p id="ea72" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mk ml mm mn b">ENTRYPOINT</code>是运行映像时运行的命令。所以在这种情况下，它运行的是位于<code class="fe mk ml mm mn b">WORKDIR</code>的二进制代码，称为<code class="fe mk ml mm mn b">joke-web-server</code>。</p><h1 id="a113" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">建立和运行我们的形象</h1><p id="6b85" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们可以通过跑步来建立我们的形象:</p><pre class="kg kh ki kj gt ms mn mt mu aw mv bi"><span id="9681" class="mw ks iq mn b gy mx my l mz na">docker build -t joke-web-server .</span></pre><p id="aa93" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">该命令的格式是<code class="fe mk ml mm mn b">docker build [OPTIONS] PATH</code>，所以我们说“使用位于当前目录中的Dockerfile(和其他东西)来构建一个名为‘joke-we b-server’的映像”。流程完成后，我们可以看到我们的图像是通过用<code class="fe mk ml mm mn b">docker image ls</code>列出Docker图像构建的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/1aa44561f73b79c2d514dc5eec6c4cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8xopNMti8aKozEBLi8yXg.png"/></div></div></figure><p id="d979" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了运行映像，我们需要将<em class="mr"> Docker端口</em> <strong class="ll ir"> <em class="mr"> </em> </strong>(由我们之前的<code class="fe mk ml mm mn b">EXPOSE</code>指令粗略定义)链接到我们主机上的端口。这是一个形式为<code class="fe mk ml mm mn b">p &lt;local machine port&gt;:&lt;docker port&gt;</code>的命令行选项。所以，如果我们把我们的形象表现为:</p><p id="ad0d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe mk ml mm mn b">docker run -p 5001:5000 joke-web-server</code></p><p id="8444" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们告诉Docker将内部端口5000(我们的应用程序正在侦听的端口)链接到本地端口5001(您将用来访问Docker外部的应用程序的端口)。</p><p id="e332" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">旧的、可靠的<code class="fe mk ml mm mn b">ctrl-c</code>可以用来在你完成后停止服务器。</p><p id="ebf3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们做到了！这个通用公式可以应用于运行各种程序，内置Go或其他。</p><h1 id="83b4" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">但是我们能做得更好吗？</h1><p id="6669" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">上面的结果是一个370MB的图像——对于这样一个小应用程序来说不太好。如果我在我的开发机器(Max MacBook Pro)上做一个<code class="fe mk ml mm mn b">go build</code>，我最终得到一个6.7MB的图像。这是怎么回事？</p><p id="5cce" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们Dockerfile中的每条指令都向图像添加了一层，这可以被认为是到前一状态的<code class="fe mk ml mm mn b">diff</code>。当我们构建的时候，我们会带着许多构建应用程序所需的工件进入最终的容器。我们为映像选择的操作系统也在那里，可能有我们不需要的东西，我们安装的任何包也包括在内。甚至用于构建我们的二进制文件的文件也仍然存在！所有这些都增加了最终结果的规模，更不用说当我们在现实世界中部署它时会增加潜在的攻击面。</p><p id="81fa" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们可以在进行过程中集中精力清理所有不必要的部分，但是这样会大大增加复杂性(以及将来出现bug或安全问题的机会)。输入Docker多阶段构建。</p><p id="879e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">多阶段构建基本上是一个管道，我们通过构建一系列图像来构建各种输出工件。这些工件然后被转移到构建的下一个“阶段”。</p><p id="f494" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">但是！我们不再需要保留<em class="mr">创建</em> <strong class="ll ir"> <em class="mr"> </em> </strong>工件所需的位。我们一直这样做，直到我们得到一个最终的容器，它包含了部署我们的应用程序的最小依赖集。通常，这表现为两个阶段的构建:一个阶段构建应用程序的二进制文件，另一个阶段存储应用程序(以及任何依赖项)以供部署。</p><p id="4e4e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于我们上面的例子，看起来如下:</p><p id="2c93" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">阶段1:构建</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="62ae" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">注意第一行<code class="fe mk ml mm mn b">FROM Golang:1.17-alpine as build-stage</code>——我们称这个第一阶段为<code class="fe mk ml mm mn b">build-stage</code>，下一步我们可以从它的文件系统中提取工件。</p><p id="688e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">阶段2:建立我们的最终形象</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3a97" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这里，我们复制了在<code class="fe mk ml mm mn b">build-stage</code>中创建的<code class="fe mk ml mm mn b">ca-certificates</code>依赖项和应用程序二进制文件。我们留下了用于构建二进制文件(及其依赖项)的所有位。</p><p id="0716" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">因为我们的应用程序二进制文件是静态链接的，所以我们能够为一个极简的Docker图像构建<code class="fe mk ml mm mn b">FROM scratch</code>。你可以在这里阅读更多关于<code class="fe mk ml mm mn b">scratch</code>关键词<a class="ae mo" href="https://www.cloudsavvyit.com/14340/how-to-create-your-own-docker-base-images-from-scratch/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="037d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们现在有了一个7.2MB的可部署映像——比单阶段构建提高了大约51倍，比为我的机器构建原始二进制文件只增加了大约7%。对于一个可移植的、易于部署的应用程序来说，这似乎是一个很好的权衡。</p><p id="f00b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">您可以像运行单级映像一样运行此映像，但现在它要小得多，相对攻击面非常小。</p><h1 id="3366" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">包扎</h1><p id="39c7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Docker是一个大项目，有许多许多可能的配置，这些配置将特定于你的应用程序，但对我来说，开始是最难的部分。我希望这可以作为一个很好的跳板，并希望得到任何关于如何改进的反馈！</p></div></div>    
</body>
</html>