<html>
<head>
<title>Modernize Legacy Code in Production — Rebuild Your Airplane Midflight Without Crashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代化生产中的遗留代码——在不崩溃的情况下，在飞行途中重建您的飞机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modernize-legacy-code-in-production-rebuild-your-airplane-midflight-without-crashing-a85fb86ff0a0?source=collection_archive---------18-----------------------#2022-05-09">https://betterprogramming.pub/modernize-legacy-code-in-production-rebuild-your-airplane-midflight-without-crashing-a85fb86ff0a0?source=collection_archive---------18-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9da7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">迁移旧代码总是一个挑战——而敏捷实践在这项工作中至关重要</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5169d8f02a830f35ec5a823f6417d503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14wy9XIMUOrN3atjGtciUw.png"/></div></div></figure><p id="a8da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我花了十多年的时间作为顾问为许多领域和追求的许多公司工作。每个代码库的多样性是巨大的。本文将尝试定义对遗留代码进行现代化的通用规则，这些规则有望适用于所有人，但它是从Java开发人员的角度出发的。</p><p id="06fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在撰写本文时，我主要关注的是将旧的Java 6时代风格的J2EE代码更新为更现代的Spring Boot/雅加达EE代码。然而，我不想深入代码并试图保持这种通用性。我也讨论COBOL和类似的遗留系统。大多数重要的指导方针也应该适用于移植任何其他类型的代码库。</p><p id="36b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数情况下，重写一个项目并不是一个巨大的挑战——然而，当用户在不中断服务的情况下积极地敲打现有的系统时，你能做到吗？</p><p id="fede" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这需要大量的计划和协调。</p><h1 id="f8f7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">为什么要现代化？</h1><p id="cba6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我认为我们不应该为了“最新最好的”而更新项目像COBOL这样常见的遗留系统仍然被使用是有原因的。有价值的代码不会因为年代久远而失去光彩。“有效的代码”有很多优点，尤其是如果它是几十年前由数百名开发人员构建的。这里面有很多隐藏的业务逻辑模型知识。</p><p id="4455" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，维护往往会成为瓶颈。您可能需要添加使该过程不可行的特性。在几百万行代码中很难找到什么东西。利用新功能的能力可能是最终的决定因素。多亏了更新的框架和工具，创建一个没有同样复杂性的类似项目是可能的。</p><p id="00d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不应该轻率地决定修改生产中的现有代码。你需要创建一个计划，评估风险，并有一个退出的方法。</p><p id="773e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其他原因包括安全性、可伸缩性、我们所依赖的系统的寿命终止、缺乏熟练的工程师等。</p><p id="dc4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，您不应该为了更好的工具而迁移，而是为了更好的可观察性、编排等。这些都是巨大的好处。</p><p id="432a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现代化让你有机会重新思考原来的系统设计。然而，这是一个有风险的提议，因为它很容易引入微妙的行为差异。</p><h1 id="6a10" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">挑战</h1><p id="bbbd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在我们着手准备之前，有几个深层次的挑战需要我们回顾和缓解。</p><h2 id="0be1" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">访问遗留源代码</h2><p id="ea85" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有时，遗留代码库的源代码不再可用。这可能意味着我们甚至不能给原始项目添加基本的特性/功能。这可能是由于多种原因(法律或技术)造成的，并且会使迁移变得更加困难。不熟悉的代码是一个巨大的问题，会使迁移变得具有挑战性，但却是可能的。</p><p id="91ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在遗留系统中公开内部调用以实现平滑迁移是非常常见的。例如，我们可以通过检查遗留系统来提供回退能力。我开发的一个老产品有一个定制的内部认证。为了在迁移过程中保持兼容性，我们使用了专用的web服务。如果当前服务器上的用户身份验证失败，系统会对照旧服务器进行检查，以提供“无缝”体验。</p><p id="ddba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在迁移阶段很重要，但并不总是有效。如果我们不能访问遗留代码，那么在移植期间，像scraping这样的工具可能是获得完美向后兼容性的唯一途径。</p><p id="db15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时，源不再可用或丢失。这使得准备工作更加困难。</p><h2 id="37e1" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">无法隔离遗留系统</h2><p id="7003" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为了分析遗留系统，我们需要能够孤立地运行它，这样我们就可以测试和验证它的行为。这是一种常见且重要的做法，但并不总是可行的。</p><p id="ba0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，在专用硬件或操作系统上运行的COBOL代码库。可能很难隔离这样的环境。</p><p id="5ce6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能是你能面对的最大问题/挑战。有时，具有领域专业知识的外部承包商可以在这方面提供帮助。如果是这样的话，一分钱一分货！</p><p id="4206" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个解决方法是设置一个租户进行测试。例如，如果一个系统管理工资单，为测试设置一个假雇员，并针对生产执行下面讨论的任务。这是一个巨大的危险和问题，因此这种情况远非理想，只有在没有其他选择的情况下，我们才应该采取这种做法。</p><h2 id="5d3b" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">奇数格式和自定义存储</h2><p id="6b33" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一些遗留系统可能依赖历史悠久的编码方法。COBOL就是一个很好的例子。在其中，它们根据形式存储数字，更接近BCD (Java的BigDecimal是最接近的例子)。这还不错。对于金融系统来说，这实际上是一条正确的道路。但是，当处理数字数据时，它可能会引入不兼容性，这可能会阻止系统并行运行。</p><p id="a545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更糟糕的是，COBOL有一个复杂的文件存储解决方案，它不是标准的SQL数据库。远离这样的东西(或者甚至一些新的利基系统)可能会很有挑战性。幸运的是，解决方案是有的，但是它们可能会限制并行运行旧产品和新产品的实用性。</p><h1 id="fe7f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">准备</h1><p id="197a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在我们考虑这种尝试之前，我们需要评估并准备好迁移。无论你做什么，迁移都将是痛苦的，但是这个阶段让你缩小你需要的创可贴的尺寸。</p><p id="2862" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在进行代码迁移之前，您需要遵循许多常规规则和设置。每一个都是你需要非常熟悉的。</p><h2 id="9e88" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">特征抽出</h2><p id="774a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当我们有一个长期运行的遗留系统时，几乎不可能跟踪它的每个特性以及它在最终产品中扮演的角色。文件是有，但是复习的时候很难去读，去过。问题追踪器是很好的跟进工具，但它们不是很好的地图。</p><p id="e256" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发现系统中的特性和“实际使用的”特性是有问题的。尤其是当我们想关注细节的时候。我们想要每一个小细节。这并不总是可能的，但是如果您可以使用可观察性工具来指示使用了什么，这将非常有帮助。迁移不被使用的东西是令人沮丧的，如果可能的话，我们希望避免它。</p><p id="aa70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不总是可行的，因为大多数提供非常细粒度细节的可观察性工具是为较新的平台(例如，Java、Python、Node等)设计的。).但是如果你有一个像老J2EE项目这样的平台，使用像Lightrun这样的工具并在特定行放置一个<a class="ae mw" href="https://docs.lightrun.com/actions/metrics/#counter" rel="noopener ugc nofollow" target="_blank">计数器</a>可以告诉你什么被使用了，什么可能没被使用。我将在下面进一步讨论这个问题。</p><p id="6955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我经常使用电子表格，在表格中列出每一个特性和微小的行为。这些电子表格可能很大，我们可以根据子模块来划分它们。这个过程可能需要几个星期，因为有许多步骤:检查代码、文档和用法。然后与应用程序的用户进行迭代，以验证我们没有错过一个重要的特性。</p><p id="711d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个阶段偷工减料很容易。你以后可能会付钱。有时候，我将这个需求分配给一个初级软件开发人员，而没有适当地审查输出。我最终后悔了，因为在有些情况下，我们忽略了文档或代码中的细微差别。</p><h2 id="6e84" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">符合性测试</h2><p id="dc4e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这是迁移过程中最重要的方面。虽然单元测试是好的，但是符合性和集成测试对于迁移是至关重要的。</p><p id="f692" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要特征提取以符合要求。我们需要检查遗留系统的每个特性和行为，并编写一个通用测试来验证这个行为。这对于验证我们对代码的理解并确保文档是正确的非常重要。</p><p id="d694" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们有了验证现有遗留系统的符合性测试，我们就可以用它们来测试新代码库的兼容性。</p><p id="4946" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最根本的挑战是编写可以在两个完全不同的系统上运行的代码。例如，如果您打算更改用户界面，那么修改这些测试将会很有挑战性。</p><p id="8dd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我建议使用外部工具编写测试，甚至可以使用不同的编程语言。这鼓励您考虑外部接口，而不是特定于语言和平台的问题。它还有助于发现“奇怪”的问题，比如导致新旧系统之间HTTP协议实现不兼容的微小差异。</p><p id="c3da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还建议为UI差异使用完全独立的“瘦”适配器。当针对遗留代码库和当前代码库运行时，测试本身必须相同。</p><p id="c788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们进行测试创作的流程是在问题跟踪器中为上一步中电子表格中的每个功能/行为打开一个问题。完成后，我们将电子表格的行涂成黄色。</p><p id="cefd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们集成了一个测试并且问题被关闭，我们就将该行涂成绿色。</p><p id="198e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们仍然需要用单元测试来测试独立的元素。符合性测试有助于验证兼容性。单元测试检查质量，并且完成得更快，这对生产力很重要。</p><h2 id="c75b" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">代码覆盖率</h2><p id="59bc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">代码覆盖率工具可能不适用于您的遗留系统。然而，如果它们是，你需要使用它们。</p><p id="b15f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">验证您的符合性测试是否足够广泛的最好方法之一就是通过这些工具。您需要对每个覆盖率报告进行代码审查。我们应该验证没有涉及到的每一行或每一个语句，以确保没有我们遗漏的隐藏功能。</p><h2 id="620d" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">记录和备份</h2><p id="1b55" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果可能的话，记录对当前服务器的网络请求进行测试。您可以使用当前数据库和记录的请求的备份来为新版本创建一个“真实世界使用”的集成测试。在开发过程中尽可能使用实时数据，以防止生产中出现意外。</p><p id="cff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能是站不住脚的。在开发过程中，您的实时数据库可能受到访问限制，或者可能太大而无法使用。很明显，记录网络流量会涉及隐私和安全问题，所以这只有在实际可行时才适用。</p><h2 id="47ba" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">规模</h2><p id="7d7f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">迁移现有项目的一个好处是我们有一个完美的规模感。我们知道交通状况。我们知道数据量，也了解业务限制。</p><p id="8322" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不知道新系统能否处理我们需要的峰值负载吞吐量。我们需要提取这些细节，并为系统的关键部分创建压力测试。理想情况下，我们需要验证性能，将其与传统进行比较，以确保我们不会在性能方面倒退。</p><h1 id="dd39" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">目标</h1><p id="9d5c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们应该迁移哪些部分，以什么方式迁移？</p><p id="de4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们应该首先瞄准什么，我们应该如何优先考虑这项工作？</p><h2 id="c2eb" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">认证和授权</h2><p id="c305" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">许多旧系统将授权模块作为整体流程的一部分嵌入。无论您采取何种策略，这都将使您的迁移充满挑战。迁移也是更新这些旧概念并引入更安全/可伸缩的授权方法的绝佳机会。</p><p id="6346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，当用户需要使用新系统时，一种常见的策略是让用户“重新注册”或“迁移他们的帐户”。对于用户来说，这是一个繁琐的过程，并将引发许多支持问题，例如，“我尝试了密码重置，但它不起作用。”</p><p id="ca5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当旧系统中的用户不执行迁移并试图在新系统上重置密码时，可能会发生这类故障。有一些变通办法，比如明确地检测这样的特定情况，并无缝地重定向到“迁移过程”。但在这一点上，摩擦是意料之中的。</p><p id="6f41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，分离身份验证和授权的好处将有助于未来的迁移和模块化。共享数据库中的用户详细信息通常是最难迁移的内容之一。</p><h2 id="4a70" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">数据库ˌ资料库</h2><p id="e405" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当处理遗留系统时，我们可以在现有数据库的基础上实现新版本。这是一种常见的方法，并且有一些优点:</p><ul class=""><li id="12fc" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">即时迁移—这可能是最大的优势。所有数据都已经在新系统中，没有停机时间</li><li id="0ad7" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">简单——这可能是最简单的迁移方法之一，您可以使用现有的“真实”数据来测试新系统，然后再投入使用</li></ul><p id="b593" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也有一些严重的缺点:</p><ul class=""><li id="03e7" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">数据污染——新系统可能会插入有问题的数据并破坏旧系统，使恢复变得不可能。如果您打算提供新旧系统并行运行的分阶段迁移，这可能是一个问题</li><li id="097f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">缓存问题—如果两个系统并行运行，缓存可能会导致它们的行为不一致</li><li id="c956" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">持续限制—这将旧系统的限制带入新系统</li></ul><p id="2722" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果存储系统足够现代、足够强大，以这种方式迁移数据的方法是有意义的。它消除或至少推迟了迁移过程中的一个有问题的部分。</p><h2 id="0a10" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">贮藏</h2><p id="805d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">以下三个技巧是应用程序性能的基础。如果你做对了，你的应用会很快:</p><ol class=""><li id="3e99" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nl nd ne nf bi translated">贮藏</li><li id="44f1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nl nd ne nf bi translated">贮藏</li><li id="a1aa" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nl nd ne nf bi translated">贮藏</li></ol><p id="f4e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。然而很少有开发人员使用足够的缓存。这是因为适当的缓存可能会非常复杂，并且会打破知识的单一来源原则。正如上一节所提到的，这也使得迁移变得非常困难。</p><p id="5959" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在迁移期间禁用缓存可能不是一个现实的选择，但是减少保留时间可能会减轻一些问题。</p><h1 id="af1d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">战略</h1><p id="1a57" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有几种方法可以解决大规模迁移问题。我们可以着眼于迁移中的“大局”，例如，从整体迁移到微服务。但通常情况下，在这个过程中会有更多细微的区别。</p><p id="1301" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将跳过明显的“完全重写”,即我们立即用新产品替换旧产品。我认为这是显而易见的，我们都明白风险/影响。</p><h2 id="0378" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">逐个模块</h2><p id="0b08" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果您可以选择这种策略，并慢慢地用新模块替换遗留代码的各个部分，那么这是一种理想的方式。这也是微服务背后最大的卖点之一。</p><p id="0d90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果仍然有团队管理和更新遗留代码，这种方法可以很好地工作。如果不存在，这种方法可能会有严重的问题。</p><h2 id="60dd" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">并行部署</h2><p id="ac3c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这适用于共享数据库部署。我们可以将新产品部署到单独的服务器上，如上所述，两个产品使用相同的数据库。这种方法有许多挑战，但我经常选择它，因为它可能是最简单的开始。</p><p id="d61b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为旧产品仍然可用，所以现有用户有一个缓解方法。通常建议为遗留服务器计划停机时间，以迫使现有用户进行迁移。否则，在这种情况下，用户可能会拒绝使用新产品。</p><h2 id="196d" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">隐藏部署</h2><p id="4e60" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在这种策略中，我们对公众隐藏现有的产品，并在其位置上建立新的系统。为了简化迁移，新产品会向旧产品查询缺失的信息。</p><p id="ca2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果用户试图登录而没有在系统中注册，代码可以查询遗留系统来无缝地迁移用户。这很有挑战性，理想情况下，需要对遗留代码进行一些修改。</p><p id="3aba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">巨大的好处是，我们可以在保持兼容性的同时迁移数据库，而不用一次性迁移所有数据。</p><p id="a9e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个主要的缺点是，这可能会使遗留代码永久存在。结果可能会与我们的发展目标背道而驰。</p><h1 id="7749" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">履行</h1><p id="ed58" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">你写完代码了。我们已经准备好扣动扳机，开始迁移。现在我们需要更新用户迁移将要发生。你不希望一个愤怒的顾客抱怨某样东西突然停止工作。</p><h2 id="f42a" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">排练</h2><p id="e157" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果可能，执行一次试运行，并为迁移过程准备一个脚本。当我说“脚本”时，我不是指代码。我指的是需要执行的职责和任务的脚本。</p><p id="75bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要验证迁移完成时一切正常。如果有东西坏了，需要有一个脚本来撤销一切。你最好撤退，改天再重新部署。我宁愿有一个我们可以“走回来”的早期失败的迁移，而不是生产中“半生不熟”的东西。</p><h2 id="9863" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">谁啊。</h2><p id="bf69" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在我看来，您应该使用一个较小的团队来实际部署迁移的软件。太多人会造成混乱。您需要以下人员:</p><ul class=""><li id="515a" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">IT/运营—处理部署和恢复(如有必要)</li><li id="0189" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">支持—解答用户的疑问和问题。在用户报告严重错误的情况下引发标志</li><li id="8d22" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">开发人员——找出是否存在与代码相关的部署问题</li><li id="850b" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">经理——我们需要有即时决策权的人。没人想取消部署。我们需要一个了解公司利害关系的人</li></ul><p id="a628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一种趋势是通过修改代码来完成迁移。这对较小的创业公司来说没问题，我自己对此也很内疚。但是如果你在大规模工作，就没有办法做到。“当场”完成的代码更改不能通过测试，并且可能引入可怕的问题。这可能是个坏主意。</p><h2 id="bf27" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">什么时候？</h2><p id="783b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">公理“不要在星期五部署”在这种情况下可能是错误的。我发现当我愿意牺牲一个周末的时候，星期五是一个伟大的迁徙时期。显然，我并不主张强迫人们周末工作。但是如果有兴趣这样做(以换取假期时间)，低流量的日子是做出重大改变的理想时间。</p><p id="1aaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在多个时区工作，最不活跃时区的开发人员可能最适合处理迁移。我建议让各个时区的团队跟踪任何可能的后果。</p><p id="0911" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这些情况下，敏捷性至关重要。快速响应变化可以决定是恢复部署还是继续部署。</p><h2 id="52d7" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">分阶段展示</h2><p id="ed10" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们可以用小的更新来发布我们的产品，并将更新推送给一部分用户。不幸的是，当我们做出重大改变时，我发现这更是一个障碍。如果两个系统都在运行，就很难区分错误的来源。两个系统需要同时运行，这可能会导致额外的摩擦。</p><h1 id="b108" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">迁移后</h1><p id="1a6f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">几周过去了，事情平静下来，迁移成功了。最终。</p><p id="f554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在怎么办？</p><h2 id="67dd" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">退休金计划</h2><p id="cacc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">作为迁移的一部分，我们带来了大量来自legacy的特性。我们可能需要其中一些，而另一些可能不必要。完成部署后，我们需要决定退休计划。哪些来自遗留系统的特性应该被淘汰，如何淘汰？</p><p id="4769" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以很容易地看到我们是否使用了一个特定的方法，或者它是否在代码中没有被使用。但是用户使用的是特定的代码行吗？具体特征？</p><p id="0305" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们有可观察性。</p><p id="1b51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以回到特征提取电子表格，检查每个潜在的特征。然后使用可观察性系统来查看有多少用户调用了一个特性。通过在代码中放置一个<a class="ae mw" href="https://docs.lightrun.com/metrics/#counter" rel="noopener ugc nofollow" target="_blank">计数器指标</a>，我们可以用类似<a class="ae mw" href="https://lightrun.com/" rel="noopener ugc nofollow" target="_blank"> Lightrun </a>的工具轻松做到这一点(你可以在这里免费下载<a class="ae mw" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="f4e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据这些信息，我们可以开始缩小产品使用的功能范围。我以前讨论过这个问题，所以如果这个功能在遗留系统中工作，它可能不适用。</p><p id="c49d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更重要的是运行遗产的退役。如果您选择了遗留实现仍在运行的迁移路径，这是决定何时拔掉插头的时候了。除了成本之外，安全性和维护问题从长远来看也是不切实际的。一种常见的策略是定期关闭遗留系统一个小时，以检测我们可能不知道的依赖性/使用情况。</p><p id="597b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">网络监视器等工具也有助于衡量使用水平。如果您能够编辑遗留或遗留中的代理，这是收集有关使用情况的数据的时候。发现仍然依赖于此的用户，并计划电子邮件活动/流程来推动他们。</p><h2 id="c2f6" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">使用工具避免将来遗留问题</h2><p id="3341" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一个现代化的系统可以拥有许多我们可以使用的新功能。CI/CD流程包括复杂的linters，可以检测安全问题和bug，并执行远优于人类同行的审查。代码质量工具可以极大地提高项目的可维护性。</p><p id="eef3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的产品需要利用这些新工具，这样它就不会退化回遗留代码状态。安全补丁作为拉取请求“无缝”交付。变更得到隐含的审查，以消除常见的错误。这使得长期维护更加容易。</p><h2 id="e1c5" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">保持符合性测试</h2><p id="5dfd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在迁移过程之后，人们通常会放弃符合性测试。如果可能/必要的话，将它们转换成集成测试是有意义的，但是如果你已经有了集成测试，它们可能是多余的，并且比你的标准测试更难维护。</p><p id="4788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特征提取电子表格也是如此。它不是可维护的东西，只是迁移期间的一个工具。一旦我们这样做了，我们应该抛弃它，我们不应该认为它是权威的。</p><h1 id="1dae" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">最后</h1><p id="831e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">迁移旧代码总是一个挑战，因为敏捷实践在这项工作中至关重要。这个过程中有如此多的陷阱和失败点。当系统处于生产状态，且迁移很重要时，尤其如此。我希望这个技巧和方法的列表将有助于指导您的开发工作。</p><p id="d599" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我觉得这个过程中的痛苦是不可避免的。有些失败也是如此。我们的工程团队必须对这种情况反应敏捷。在流程中发现潜在问题并快速解决。关于这一点，我还有很多可以说的，但我想保持它足够的普遍性，这样它将适用于更广泛的情况。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="68ae" class="mk lo iq nn b gy nr ns l nt nu"><strong class="nn ir">Want to Connect?</strong></span><span id="0b34" class="mk lo iq nn b gy nv ns l nt nu">If you have thoughts on this, reach out to me on Twitter — <a class="ae mw" href="https://twitter.com/debugagent" rel="noopener ugc nofollow" target="_blank">@debugagent</a> — to let me know.</span></pre></div></div>    
</body>
</html>