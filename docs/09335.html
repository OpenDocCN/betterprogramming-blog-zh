<html>
<head>
<title>Build the App Store-Like Downloading Animation in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中构建类似应用商店的下载动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-basic-animation-combat-e9218479888a?source=collection_archive---------15-----------------------#2021-08-11">https://betterprogramming.pub/swiftui-basic-animation-combat-e9218479888a?source=collection_archive---------15-----------------------#2021-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SwiftUI基础动画战斗</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/279c78144ab37773627a017ec0c2a699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPhytYSpSkryhKfNx4PvKQ.jpeg"/></div></div></figure><p id="3aac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SwiftUI无疑是苹果迄今为止最完美的杰作之一。通过使用SwiftUI，我们可以用更简洁的代码实现非常复杂的功能。</p><p id="2697" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近学习了一些动漫方面的知识。有了这个最新的框架，我们可以轻松实现非常流畅的动画效果。</p><p id="e5db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前一张图片是我接下来将引导您完成的演示。和我们从app Store下载App时的动画差不多，只是有些地方不一样。点击输入按钮，按钮将变成一个装载圆圈。当系统完成加载时，会出现一个勾号，表示动画结束。</p><p id="7c03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想了解详情可以参考下面的GIF。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/d1e9a98d20baddcf96fddd3cfd6c1f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1nQnItljIIaqWo9CowymIA.gif"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="8167" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">复选标记</h2><p id="d3fe" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们先来画一下复选标记的动画。</p><p id="f4a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建一个新的SwiftUI文件，我将其命名为<code class="fe mt mu mv mw b">CheckView</code>，你可以将其设置为任何名称。画图的时候需要用到<code class="fe mt mu mv mw b"><a class="ae mx" href="https://developer.apple.com/documentation/swiftui/path" rel="noopener ugc nofollow" target="_blank">Path</a></code>类。</p><p id="d3b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">画线的原理其实很简单。在数学中，我们知道两点定义一条直线。为了画出复选标记的形状，我们需要三个点来实现。由于不在一条直线上的三个点可以确定一个三角形，所以画完三角形后，我们只需选择它的两条边就可以成功地画出勾号的形状。</p><p id="324c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mt mu mv mw b">addLines(_ lines: [CGPoint])</code>功能，您可以添加想要放置的点。</p><p id="1bf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更好地布局勾号，我们需要使用<code class="fe mt mu mv mw b"><a class="ae mx" href="https://developer.apple.com/documentation/swiftui/geometryreader/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">GeometryReader</strong></a></code> <strong class="kt ir"> </strong>绘图工具。<code class="fe mt mu mv mw b"><strong class="kt ir">GeometryReader</strong></code> <strong class="kt ir">，</strong>用苹果的话说，就是一个<strong class="kt ir"> </strong>容器视图，把它的内容定义为自己大小和坐标空间的函数。此视图向其父布局返回灵活的首选大小。</p><p id="a355" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将复选标记放在视图的中心。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/a709923f30ab2566df928bf806aaffb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lt0ITz7IVrC3wI2a8Rzr7Q.png"/></div></div></figure><p id="68f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这段代码，您会看到模拟器上出现一个紫色的小勾号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/f14bed945df8fe7cdefafddebfeb9ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWcvVyoHKduhNjNR5Ea8kw.png"/></div></div></figure><p id="189c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我们如何让它移动呢？</p><p id="886b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要一个类型为<code class="fe mt mu mv mw b">Bool</code>的变量，我将其设置为<code class="fe mt mu mv mw b">checkViewAppear</code>。我们需要在主体之前声明这个变量。</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="d4b6" class="lv lw iq mw b gy ne nf l ng nh">@State <strong class="mw ir">private</strong> <strong class="mw ir">var</strong> checkViewAppear = <strong class="mw ir">false</strong></span></pre><p id="8269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe mt mu mv mw b">.animation()</code>函数可以给勾号添加动画，所以在我们的路径后面添加这个函数，并修改<code class="fe mt mu mv mw b">.trim(from:, to :)</code>中的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/e7493070d56357b6c121149137b3b196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F4PrzIxJJ1AaV2hexlsfQ.png"/></div></div></figure><p id="b366" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实例方法<code class="fe mt mu mv mw b">onAppear(perform:)</code> <strong class="kt ir"> <em class="nj"> </em> </strong>让您有机会添加一个在该视图出现时要执行的动作。</p><p id="ae44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在点击实时预览，当复选标记出现时，您将看到动画。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="84f2" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">按钮视图</h2><p id="8af9" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">创建一个新的SwiftUI视图，我将其命名为<code class="fe mt mu mv mw b">ButtonAnimationView.swift</code> <em class="nj">。</em></p><p id="91a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看我们稍后将创建的视图。它包含一个圆角矩形作为背景视图，圆角矩形上方是一个包含图像视图和文本视图的<code class="fe mt mu mv mw b">HStack</code>视图。那么我们就从<code class="fe mt mu mv mw b">ZStack</code>视图开始吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/012bf568210c26d54263f3f821086837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOU_3r7wM00mr4cjDIBuqQ.png"/></div></div></figure><p id="73a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们创建一个圆角矩形，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/6b31c6c161e2280e900778e68c86da3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JK32Kb_HuNjhMDE94Q3eBw.png"/></div></div></figure><p id="a140" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在添加包含图像视图和文本视图的<code class="fe mt mu mv mw b">HStack</code>视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/920409cd425296aa5bb3cb481f9bc7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U949lOaFkhNB7GeHVASh_A.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/648b43569030f23f24dcdce491cb2247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiGLqgrXXLwiWZMTnjDwYA.png"/></div></div></figure><p id="7abc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在按钮视图已经完成，我们只需要添加动画到视图中。</p><p id="d113" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回到之前展示过的gif，我们会看到在我们点击按钮后，视图变成了圆形视图。还有呢？圆形视图的颜色不同于按钮视图。</p><p id="2a26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理这种变化，我们需要一个属性包装器类型，它可以读取和写入一个值，当这个值被写入另一个值时，它可以改变视图。我设置了<code class="fe mt mu mv mw b">downloadButtonTapped</code>:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="d53d" class="lv lw iq mw b gy ne nf l ng nh">@State <strong class="mw ir">private</strong> <strong class="mw ir">var</strong> downloadButtonTapped = <strong class="mw ir">false</strong></span></pre><p id="ae04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，点击按钮时，更改按钮视图的宽度。</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="85b1" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    ···<br/>    .frame(width: <strong class="mw ir">self</strong>.downloadButtonTapped ? 60 : 300, height: 60)<br/>    ···</span></pre><p id="6a57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击按钮后，视图的背景色将变成白色，而<code class="fe mt mu mv mw b">foregroundColor</code>将变成紫色:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="7cad" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    ···<br/>    .foregroundColor(<strong class="mw ir">self</strong>.downloadButtonTapped ? .purple : Color(red: 230/255, green: 230/255, blue: 230/255))<br/>    .background(<strong class="mw ir">self</strong>.downloadButtonTapped ? .white : Color(red: 230/255, green: 230/255, blue: 230/255))<br/>    ···</span></pre><p id="9cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在使用实例方法<code class="fe mt mu mv mw b">onTapGesture(count:perform:)</code> <strong class="kt ir"> <em class="nj"> </em> </strong>添加一个当圆角矩形视图识别出点击手势时要执行的动作。</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="64f7" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    ···<br/>    .onTapGesture {<br/>        withAnimation(.default) {<br/>            <strong class="mw ir">self</strong>.downloadButtonTapped = <strong class="mw ir">true<br/>        </strong>}<br/>    }</span></pre><p id="948f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在轻击手势后隐藏<code class="fe mt mu mv mw b">HStack</code>视图，我们只需要检查<code class="fe mt mu mv mw b">downloadButtonTapped</code>的值是否等于<code class="fe mt mu mv mw b">true</code>。</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="3941" class="lv lw iq mw b gy ne nf l ng nh"><strong class="mw ir">if</strong> !downloadButtonTapped {<br/>    HStack {<br/>        Image("riding").resizable().frame(width: 30, height: 30)<br/>        Text("Enter")<br/>    }.font(.headline)<br/>}</span></pre><p id="2ec3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开实时预览，您将看到显示圆角矩形视图如何变成圆形视图的动画。</p><p id="bbb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要使圆圈缺少一小部分，并旋转起来。添加两个新的属性包装类型:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="cf03" class="lv lw iq mw b gy ne nf l ng nh">@State <strong class="mw ir">private</strong> <strong class="mw ir">var</strong> loading = <strong class="mw ir">false<br/></strong>@State <strong class="mw ir">private</strong> <strong class="mw ir">var</strong> fullcircle = <strong class="mw ir">false</strong></span></pre><p id="7086" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更改以下代码以使圆不完整:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="ed8d" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    .trim(from: 0, to: <strong class="mw ir">self</strong>.fullcircle ? 0.95 : 1)<br/>    ···</span></pre><p id="da8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加实例方法<code class="fe mt mu mv mw b">rotationEffect(_:anchor:)</code> <strong class="kt ir"> <em class="nj"> </em> </strong>就在<strong class="kt ir"><em class="nj"/></strong><code class="fe mt mu mv mw b"><strong class="kt ir">onTapGesture</strong></code><strong class="kt ir"><em class="nj"/></strong>方法之前旋转圆形视图:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="3584" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    ···<br/>    .rotationEffect(Angle(degrees: <strong class="mw ir">self</strong>.loading ? 0 : -1440))<br/>    ···</span></pre><p id="a77e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并更新<code class="fe mt mu mv mw b">onTapGesture</code> <strong class="kt ir"> <em class="nj"> </em> </strong>的方法:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="9243" class="lv lw iq mw b gy ne nf l ng nh">RoundedRectangle(cornerRadius: 30)<br/>    ···<br/>    .onTapGesture {<br/>        withAnimation(.default) {<br/>            <strong class="mw ir">self</strong>.downloadButtonTapped = <strong class="mw ir">true<br/>            self</strong>.fullcircle = <strong class="mw ir">true        <br/>        </strong>}<br/>    }</span></pre><p id="1dd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会感到困惑，<code class="fe mt mu mv mw b">loading</code>属性没有包含在<code class="fe mt mu mv mw b">onTapGesture</code>方法中。因为旋转动画是在圆角矩形视图变成圆形视图的动画之后——如果给<code class="fe mt mu mv mw b">onTapGesture</code>方法添加属性，你会发现这个动画不是我们需要的，而且动画的时长太短。</p><p id="b549" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理圆形旋转动画，我们需要一个新函数<code class="fe mt mu mv mw b">startProcessing()</code>。让我们创建它:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="45e0" class="lv lw iq mw b gy ne nf l ng nh"><strong class="mw ir">struct</strong> ButtonAnimationView: View {<br/>    <strong class="mw ir">···<br/>    private</strong> <strong class="mw ir">func</strong> startProcessing() {<br/>        withAnimation(Animation.linear(duration: 5)) {<br/>            <strong class="mw ir">self</strong>.loading = <strong class="mw ir">true<br/>        </strong>}<br/>    }<br/>}</span></pre><p id="58df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么时候调用这个函数？显然，在图像视图和文本视图消失后，需要在<code class="fe mt mu mv mw b">HStack</code>视图中添加<code class="fe mt mu mv mw b">onDisappear</code>方法:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="ab6e" class="lv lw iq mw b gy ne nf l ng nh"><strong class="mw ir">if</strong> !downloadButtonTapped {<br/>    HStack {<br/>        Image("riding").resizable().frame(width: 30, height: 30)<br/>        Text("Enter")<br/>    }.font(.headline)<br/>     .onDisappear() {<br/>         <strong class="mw ir">self</strong>.startProcessing()<br/>     }<br/>}</span></pre><p id="5aeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您将在点击圆角矩形视图后看到旋转动画。</p><h2 id="8cf4" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">组合检查视图和按钮视图</h2><p id="7dda" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在旋转动画的几秒钟之前，<code class="fe mt mu mv mw b">CheckView</code>会出现在圆形视图的上方。它们甚至会同时完成。所以我们需要一个新的属性包装器类型来显示<code class="fe mt mu mv mw b">CheckView</code>何时显示:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="8c38" class="lv lw iq mw b gy ne nf l ng nh">@State <strong class="mw ir">private</strong> <strong class="mw ir">var</strong> completed = <strong class="mw ir">false</strong></span></pre><p id="ad97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe mt mu mv mw b">startProcessing</code>方法中，我们假设动画将在5秒内完成，所以我们现在假设4秒后<code class="fe mt mu mv mw b">CheckView</code>将显示:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="ed65" class="lv lw iq mw b gy ne nf l ng nh"><strong class="mw ir">struct</strong> ButtonAnimationView: View {<br/>    <strong class="mw ir">···<br/>    private</strong> <strong class="mw ir">func</strong> startProcessing() {<br/>        withAnimation(Animation.linear(duration: 5)) {<br/>            <strong class="mw ir">self</strong>.loading = <strong class="mw ir">true<br/>        </strong>}</span><span id="570b" class="lv lw iq mw b gy no nf l ng nh">        DispatchQueue.main.asyncAfter(deadline: .now() + 4) {<br/>            <strong class="mw ir">self</strong>.completed = <strong class="mw ir">true<br/>            self</strong>.fullcircle = <strong class="mw ir">false<br/>        </strong>}    <br/>    }<br/>}</span></pre><p id="4d71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在将<code class="fe mt mu mv mw b">CheckView</code>添加到<code class="fe mt mu mv mw b">ZStack</code>视图中:</p><pre class="kg kh ki kj gt na mw nb nc aw nd bi"><span id="e502" class="lv lw iq mw b gy ne nf l ng nh"><strong class="mw ir">if</strong> completed {<br/>    CheckView()<br/>        .offset(x: -5, y: 9)<br/>        .foregroundColor(.purple)<br/>}</span></pre><p id="7e52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在现场预览中，您将看到完整的动画。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="6458" class="lv lw iq bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm mn bi translated">启动视图</h2><p id="2a7e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">创建一个名为<code class="fe mt mu mv mw b">BootView.swift</code>的新SwiftUI文件，检查该视图中将包含什么。一个图像、两个不同颜色的文本视图和<code class="fe mt mu mv mw b">ButtonAnimationView</code>。</p><p id="3ae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建这样的视图很简单，所以我只把代码放在这里。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2e5fd5995ab15c19d72ad80a642b1652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0xZiVRkxXXPmn3PvJN79Q.png"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="17a3" class="nq lw iq bd lx nr ns nt ma nu nv nw md jw nx jx mg jz ny ka mj kc nz kd mm oa bi translated">演示链接</h1><p id="791a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">整个项目已经上传到<a class="ae mx" href="https://github.com/HuangRunHua/EnterButtonAnimation" rel="noopener ugc nofollow" target="_blank"> Github </a>，感觉下载起来很轻松。</p></div></div>    
</body>
</html>