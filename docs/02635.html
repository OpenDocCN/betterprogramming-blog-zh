<html>
<head>
<title>How Unix Works: Everything You Were Too Afraid to Ask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix如何工作:你不敢问的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-unix-works-everything-you-were-too-afraid-to-ask-f8396aeb2763?source=collection_archive---------1-----------------------#2019-12-14">https://betterprogramming.pub/how-unix-works-everything-you-were-too-afraid-to-ask-f8396aeb2763?source=collection_archive---------1-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5643" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">文件和进程的故事。成为更好的软件工程师</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd613dfe6720f691588452f848be08f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaJI0oJfc2LEd_iNnoKz3w.jpeg"/></div></div></figure><p id="c509" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix很美。请允许我为你在<a class="ae lq" href="https://youtu.be/0n4f-VDjOBE?t=39" rel="noopener ugc nofollow" target="_blank">画一些快乐的小树</a>。我不打算解释一大堆命令——那很无聊，网上已经有一百万个这样的教程了。</p><p id="e7ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将留给你思考这个系统的能力。</p><p id="65bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你想做的每一件新奇的事情只需一次谷歌搜索。但是，理解为什么解决方案能达到您的目的是不一样的。<br/>这就是给你真正力量的东西，不害怕的力量。[1]</p><p id="32be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且，既然押韵，那肯定是真的。</p><p id="7aca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您是从零开始，我将放入足够的命令让我们一起玩。我们将探索概念，在<code class="fe lr ls lt lu b">shell</code>中看到它们的实践，然后大喊:“我明白了！”。</p><p id="8928" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个过程中，我们还将弄清楚<code class="fe lr ls lt lu b">shell</code>到底是什么。</p><p id="b2b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们不能不进入创造者的头脑:探索Unix的哲学。</p><p id="ae40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以假设Linux是Unix。如果你想知道为什么事实并非如此，你可以跳到底部再回来。我们将一劳永逸地结束Unix与Linux的混淆。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2d62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">哲学</h1><p id="837f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">让我们从核心开始Unix背后的哲学。</p><ul class=""><li id="26aa" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">写程序做一件事，并把它做好。</li><li id="095f" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">写程序一起工作。(没有额外输出，不坚持交互输入。)</li><li id="ac5e" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">编写处理文本流的程序，因为那是一个通用接口。</li></ul><p id="75a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix也信奉<a class="ae lq" href="https://blog.codinghorror.com/worse-is-better/" rel="noopener ugc nofollow" target="_blank"> <em class="nn">越差越好</em> </a>的哲学。</p><p id="7718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种思维是强大的。在更高的层面上，我们在函数式编程中看到很多:构建专注于一件事的原子函数，没有额外的输出，然后将它们组合在一起做复杂的事情。</p><p id="002e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组合中的所有函数都是纯函数。没有要跟踪的全局变量。</p><p id="628a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许直接的结果是，Unix的设计集中在两个主要组件上:进程和文件。Unix中的一切不是进程就是文件。没别的了。</p><p id="df4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进程和文件之间存在循环依赖关系，如果我们开始深入解释其中任何一个，我们将需要另一个来支持它。为了打破这种循环，我们将从简单概述每一个开始，然后深入研究。我们将重复几次，以弄清真相。</p><h2 id="f71b" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">处理</h2><p id="aad3" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">你运行的浏览器是一个进程。终端也是，如果你开着的话。[2]如果没有，现在是打开它的好时机。如果你用的是Windows系统，Docker也很好用。如果你在Mac上，使用终端——这是一个Unix环境。</p><p id="dd51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更抽象地说，进程是代码的运行实例。操作系统给进程提供资源(比如内存)，然后附加一些元数据(比如谁是所有者)，然后运行代码。</p><p id="cbf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">操作系统作为资源的一部分，也为每个进程提供了三个打开的文件:<code class="fe lr ls lt lu b">stdin</code>、<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>。</p><h2 id="8944" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">文件</h2><p id="6d52" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">所有不是进程的东西都是文件。</p><p id="d29d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，这意味着你的打印机，扫描仪，终端屏幕，任何进程的代码！它们都是文件。如果这听起来令人困惑，请继续阅读。我们会澄清的。</p><p id="5f8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件系统中的文件就是文件——一串字节串在一起产生有意义的东西。你的照片是文件。你的目录也是文件！它们只包含当前目录中的文件/目录列表，就像一棵树一样。</p><p id="5623" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的美妙之处在于，我可以“打开”一个目录文件来查看内容！</p><p id="7e39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="5fbb" class="no md it lu b gy oe of l og oh">$ vim .<br/>" ====================================================================<br/> " Netrw Directory Listing                                 <strong class="lu iu">(</strong>netrw v162<strong class="lu iu">)</strong><br/> "   /Users/Neil/examples<br/> "   Sorted by size<br/> "   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by x:special<br/> " ===================================================================<br/> ../<br/> ./                                                                                                <br/> git-example/<br/> unix-git/<br/> unix-file-system-example/</span></pre><p id="38a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我用<code class="fe lr ls lt lu b">Vim</code>打开了一个名为<code class="fe lr ls lt lu b">.</code>的文件。这听起来熟悉吗？这就是Unix存储当前目录的方式。如您所见，它包含当前目录中的文件/目录列表。</p><p id="2a0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件只是一个数据流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文件和文件系统</h1><p id="d901" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">有了<a class="ae lq" href="https://en.wikipedia.org/wiki/Everything_is_a_file" rel="noopener ugc nofollow" target="_blank"> <em class="nn">的想法，一切都是一个文件</em> </a>和<em class="nn">一个文件是一个数据流</em>就位后，我们可以进一步探索事情是如何运作的。</p><p id="92f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Unix系统上，获取输入和写入输出的流是预定义的。这正是标准输入<code class="fe lr ls lt lu b">stdin</code>、标准输出<code class="fe lr ls lt lu b">stdout</code>和标准误差<code class="fe lr ls lt lu b">stderr</code>的用途。</p><ul class=""><li id="3c72" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">stdin</code>是输入数据源。</li><li id="ed35" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">stdout</code>是输出数据源。</li><li id="14bb" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">stderr</code>是标准误差输出源。</li></ul><p id="ad77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lr ls lt lu b">shell</code>【3】中，<code class="fe lr ls lt lu b">stdin</code>是从键盘输入数据，<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>都是屏幕。[4]</p><p id="65a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以将这些流重定向到其他地方，我们的程序不需要知道！不管输入来自哪里(键盘或文本文件)，对于任何正在运行的进程，它都来自<code class="fe lr ls lt lu b">stdin</code>。</p><p id="de90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，对于<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>。当我们谈到处理这些流的过程时，我们将对此进行更多的讨论。</p><h2 id="333f" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">信息节点</h2><p id="affc" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">为了有一个合适的文件系统，您需要一个管理文件系统的结构。不仅仅要处理文件中的数据，还要处理关于数据本身的信息，称为元数据。这包括数据存储在哪里，谁拥有它，以及谁可以看到它。</p><p id="1542" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是<em class="nn">inode</em>的含义——文件元数据的数据结构。每个文件都有一个唯一的索引节点号。这将成为文件存在时的唯一标识符。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="8936" class="no md it lu b gy oe of l og oh">$ ls -li<br/>total 0<br/>2015005 drwxr-xr-x   6 neil  X  192 23 Oct 07:36 git-example<br/>2514988 drwxr-xr-x   4 neil  X  128  9 Oct 11:37 unix-git/<br/>2020303 drwxr-xr-x   4 neil  X  128 23 Sep 11:46 unix-file-system-example/</span></pre><p id="1fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看到第一栏的数字了吗？这些是索引节点！[5]</p><p id="4700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个inode存储所有元数据。<code class="fe lr ls lt lu b">stat</code>对于查看这些元数据也很有用。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="7de3" class="no md it lu b gy oe of l og oh">$ stat -LF .<br/>drwxrwxrwx 7 A B 224 Oct 28 07:15:48 2018 ./</span></pre><p id="8e18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">A</code>和<code class="fe lr ls lt lu b">B</code>是用户名和组名。Unix是一个多用户系统。Unix就是这样做的——用户和组是文件的属性。</p><p id="bfe0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户属性设置为X的文件意味着X拥有该文件。对于Unix来说，这就是用户的全部。</p><p id="1ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">224</code>是文件大小，或者文件中的字节数。</p><p id="04cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">Oct 28 07:15:48 2018</code>是最后修改的日期。[6]</p><p id="e5f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我从哪里得到这些信息的？<code class="fe lr ls lt lu b">man ls</code>。</p><p id="5651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在是我漏掉的有趣的数字和字符:<code class="fe lr ls lt lu b">drwxrwxrwx</code>和<code class="fe lr ls lt lu b">7</code>。</p><h2 id="7183" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">文件权限</h2><p id="609c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">每个文件都有与之关联的权限。</p><p id="e2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得与文件关联的用户和组吗？每个文件存储谁拥有该文件以及该文件属于哪个组。同样，每个用户也有一个用户名和组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a03a5c1e391ac419b59cb895154b0de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Szp7CHZ0GO5T5n2V.jpg"/></div></div></figure><p id="64fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来到<code class="fe lr ls lt lu b">-rwxrwxrwx</code>字符串:这是所有者、组和其他人的权限。</p><ul class=""><li id="f1d5" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">r</code>是为了读书。</li><li id="22ba" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">w</code>是为了写作。</li><li id="f17f" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe lr ls lt lu b">x</code>用于执行。对于目录，这意味着可搜索。</li></ul><p id="7465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您只需要三位来表示每个用户、组和其他人的权限。</p><p id="bc3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到该字符串有10个字符。第一个是特殊的条目类型字符，用于区分目录、符号链接、字符流(stdin)和其他一些字符。<code class="fe lr ls lt lu b">man ls</code>了解更多。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="985f" class="no md it lu b gy oe of l og oh">$ stat -LF<br/>crw--w---- 1 neil tty 16,1 Dec 12 07:45:00 2019 <strong class="lu iu">(</strong>stdin<strong class="lu iu">)</strong></span></pre><p id="ae86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想改变权限呢？说，我不希望任何人搜我的个人文件夹(咳咳)。</p><p id="b496" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix的创造者考虑到了这一点。有一个叫做<code class="fe lr ls lt lu b">chmod</code>的实用程序，可以修改文件的权限。在后端，您现在知道了<code class="fe lr ls lt lu b">chmod</code>正在与文件的inode交互。</p><p id="b761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们需要三位来表示每个权限，所以我们可以将它转换成一个整数，并将其传递给<code class="fe lr ls lt lu b">chmod</code>。</p><p id="6eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:<code class="fe lr ls lt lu b">chmod 721 .</code>将意味着<code class="fe lr ls lt lu b">rwx-w---x</code>，这意味着所有者的所有权限，对组的写权限，对其他人的执行权限。</p><p id="d005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我更喜欢冗长的形式:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="b896" class="no md it lu b gy oe of l og oh">$ chmod u+rwx . <em class="nn"># enable user for rwx</em><br/>$ chmod g+w .   <em class="nn"># enable group for w</em><br/>$ chmod o+x .   <em class="nn"># enable others for x</em></span></pre><p id="c117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你在做同样的事情。给每个人设置权限，<code class="fe lr ls lt lu b">chmod a+x &lt;file&gt;</code>就简单多了！你也可以删除权限，使用<code class="fe lr ls lt lu b">-</code>而不是<code class="fe lr ls lt lu b">+</code>。</p><p id="f3e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要限制对我个人文件夹的访问，我会做:<code class="fe lr ls lt lu b">chmod og-x nothing-interesting-here/</code>。</p><p id="02d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以限制自己的访问权限，删除自己的所有读、写和执行权限。如果文件元数据存储在文件本身中，您将不能再次更改权限(因为您不能写入该文件)。</p><p id="fb8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是inodes很酷的另一个原因:它们总是可以被文件所有者和root修改，因此您可以恢复您的权限。试着这样做。</p><h2 id="4b97" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">文件链接</h2><p id="1241" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">有没有想过为什么把一个千兆字节的文件从一个目录移动到另一个目录非常快，而复制同样的文件可能要花很长时间？你能猜到为什么吗？</p><p id="ba92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为当我们<code class="fe lr ls lt lu b">mv</code>时，我们移动的是目录结构，而不是实际的文件数据。索引节点是对文件系统非常有用的抽象。</p><p id="302c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以做其他种类的移动。我们可以将文件从一个地方链接到另一个地方，或者让两个文件名指向同一个文件。</p><p id="38af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指向同一个文件的两个文件名是<em class="nn">硬链接</em>。把它们想象成一个文件的别名。您已经看到了两个硬链接:<code class="fe lr ls lt lu b">.</code>和<code class="fe lr ls lt lu b">..</code>是指向系统中当前目录和父目录的硬链接。</p><p id="c323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从一个地方到另一个地方的链接是符号链接。符号链接是一个新文件，独立于原始文件，链接到原始文件。</p><p id="7103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您想要修复需要在新环境中运行的脚本时，或者为了满足希望文件位于另一个位置的新程序的安装要求而制作文件的副本时，这些选项非常有用。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="e657" class="no md it lu b gy oe of l og oh">$ ls -li<br/>total 0<br/>25280489 -rw-r--r--  1 neil  X  0  8 Dec 08:48 a</span><span id="0be7" class="no md it lu b gy oj of l og oh">$ man ln <em class="nn"># to check syntax for hard links</em></span><span id="039d" class="no md it lu b gy oj of l og oh">$ ln a x <em class="nn"># create x as a hard link to a</em></span><span id="fc8d" class="no md it lu b gy oj of l og oh">$ ls -li<br/>total 0<br/>25280489 -rw-r--r--  2 neil  X  0  8 Dec 08:48 a<br/>25280489 -rw-r--r--  2 neil  X  0  8 Dec 08:48 x</span><span id="51bb" class="no md it lu b gy oj of l og oh"><em class="nn"># Notice both files have the same inode number.</em><br/><em class="nn"># Modifying x or a is the same thing - both files get modified together.</em></span><span id="9d6c" class="no md it lu b gy oj of l og oh">$ ln -s a y <em class="nn"># create symbolic link to a</em></span><span id="e97a" class="no md it lu b gy oj of l og oh">$ ls -li<br/>total 0<br/>25280489 -rw-r--r--  2 neil  X  0  8 Dec 08:48 a<br/>25280489 -rw-r--r--  2 neil  X  0  8 Dec 08:48 x<br/>25280699 lrwxr-xr-x  1 neil  X  1  8 Dec 08:54 y -&gt; a</span><span id="20ab" class="no md it lu b gy oj of l og oh"><em class="nn"># y is a symbolic link, a new small file - see size is 1. </em></span><span id="5b59" class="no md it lu b gy oj of l og oh">$ cat y <em class="nn"># shows that y (a) is empty</em></span><span id="dcba" class="no md it lu b gy oj of l og oh">$ echo lsd <strong class="lu iu">&gt;&gt;</strong> y<br/>$ cat y<br/>lsd<br/>$ cat a <em class="nn"># modifying y modifies a</em><br/>lsd<br/>$ cat x <em class="nn"># a is x</em><br/>lsd</span></pre><p id="d8f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经在评论中解释了发生的事情。</p><p id="7b43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果你删除<code class="fe lr ls lt lu b">y</code>指向的文件<code class="fe lr ls lt lu b">a</code>，会发生什么？</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="a9e3" class="no md it lu b gy oe of l og oh">$ rm a</span><span id="ff3a" class="no md it lu b gy oj of l og oh">$ cat y<br/>cat: y: No such file or directory</span><span id="fafb" class="no md it lu b gy oj of l og oh"><em class="nn"># y becomes useless</em></span><span id="854e" class="no md it lu b gy oj of l og oh">$ ls -li<br/>25280489 -rw-r--r--  1 neil  X  12  8 Dec 08:56 x<br/>25280699 lrwxr-xr-x  1 neil  X   1  8 Dec 08:54 y -&gt; a</span></pre><p id="c9aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个悬空符号链接。没用的。</p><p id="6fb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">读写权限之后的数字，或者说从我们做<code class="fe lr ls lt lu b">stat -LF .</code>开始的<code class="fe lr ls lt lu b">7</code>是指向一个文件的硬链接的计数。</p><p id="6cf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我创建<code class="fe lr ls lt lu b">x</code>的时候，这个数字上升到了2。当我移除<code class="fe lr ls lt lu b">a</code>时，数字又回到1。</p><p id="a752" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以确认<code class="fe lr ls lt lu b">.</code>和<code class="fe lr ls lt lu b">..</code>确实是硬链接。你能想到怎么做吗？</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="6b24" class="no md it lu b gy oe of l og oh">$ ls -ail<br/>25280488 drwxr-xr-x   7 neil  X   224  9 Dec 20:19 .<br/> 1289985 drwxr-xr-x+ 83 neil  X  2656 10 Dec 08:13 ..<br/>25390377 drwxr-xr-x   5 neil  X   160  9 Dec 19:13 sample_dir</span><span id="09c3" class="no md it lu b gy oj of l og oh">$ cd sample_dir<br/>$ ls -ail<br/>25390377 drwxr-xr-x  5 neil  X  160  9 Dec 19:13 .<br/>25280488 drwxr-xr-x  7 neil  X  224  9 Dec 20:19 ..<br/>25390378 -rw-r--r--  1 neil  X    0  9 Dec 19:13 a</span></pre><p id="55ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查索引节点号。<code class="fe lr ls lt lu b">sample_dir</code>中的<code class="fe lr ls lt lu b">..</code>为25280488，与父目录中的<code class="fe lr ls lt lu b">.</code>相同。还有，父目录中的<code class="fe lr ls lt lu b">sample_dir</code>是25390377，和<code class="fe lr ls lt lu b">sample_dir</code>里面的<code class="fe lr ls lt lu b">.</code>一样。</p><h2 id="700c" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">文件结构</h2><p id="f628" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">它帮助我把文件系统想象成一个树状数据结构(事实上，它就是这样)。每个节点(inode)都有一个指向其父节点、自身节点和所有子节点的指针。这就形成了目录结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b6e758ecfa882e2100a80d0f89539e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yfYn8hgD6bG0fuO9.jpg"/></div></div></figure><p id="c886" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根目录<code class="fe lr ls lt lu b">/</code>的父级是什么？</p><p id="f2dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你现在有足够的知识来回答这个问题。我做的第一件事是<code class="fe lr ls lt lu b">vim /</code>看看<code class="fe lr ls lt lu b">/</code>是否有父指针。确实如此。然后，我做了<code class="fe lr ls lt lu b">ls -ail</code>来查看父节点的inode。它指向<code class="fe lr ls lt lu b">.</code>，也就是<code class="fe lr ls lt lu b">/</code>。</p><p id="9ced" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，</p><ul class=""><li id="ef30" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">文件系统是使用索引节点和目录文件构建的。</li><li id="8d7c" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">用户是文件和进程的属性。该信息存储在inodes中。</li><li id="dfe0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">索引节点在文件系统中是唯一的。</li><li id="fab8" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">可以将多个文件系统挂载并抽象到一个逻辑树中。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d152" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理</h1><p id="88ea" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">首先，让我们把定义放在一边。需要记住流程的三个组成部分:</p><ol class=""><li id="b626" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ol nf ng nh bi translated">程序文件:代码和数据。</li><li id="5a4c" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">进程映像:存储堆栈、当前定义的变量、数据、地址空间、<a class="ae lq" href="http://www.tldp.org/LDP/LG/issue23/flower/psimage.html" rel="noopener ugc nofollow" target="_blank">和更多</a>。到了运行的时候，操作系统确切地知道如何使用这个映像重新创建进程。</li><li id="2c09" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">进程:内存中正在运行的程序。</li></ol><p id="7f64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个进程开始运行时，它从父进程继承用户ID和组ID。此信息控制对流程的访问级别。</p><p id="39d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<strong class="kw iu"> </strong>访问控制对于一个安全的系统至关重要。这就是为什么在生产中运行裸露的Docker容器会成为一个问题的原因之一:它需要以root身份运行，这意味着可能会发生不好的事情。</p><p id="9d40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe lr ls lt lu b">setuid</code>或<code class="fe lr ls lt lu b">setgid</code>来使一个进程继承文件所有者权限。<code class="fe lr ls lt lu b">setuid</code>允许进程继承相关文件的<code class="fe lr ls lt lu b">userID</code>。</p><p id="b5c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，要在Linux上更改密码(参见<a class="ae lq" href="https://unix.stackexchange.com/questions/241927/why-mac-os-x-does-not-set-uid-bit-for-usr-bin-passwd" rel="noopener ugc nofollow" target="_blank">这个链接</a>用于Mac)，我们需要修改文件<code class="fe lr ls lt lu b">/etc/passwd</code>。然而，在检查权限时，我们看到只有<code class="fe lr ls lt lu b">root</code>有权写入该文件。[7]</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="9d06" class="no md it lu b gy oe of l og oh">$ ls -ail /etc/passwd<br/>3541354 -rw-r--r-- 1 root root 681 Nov 28 08:47 /etc/passwd</span></pre><p id="c36f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当我们调用<code class="fe lr ls lt lu b">/usr/bin/passwd</code>，帮助修改密码的工具，它将继承我们的用户ID，这将拒绝对<code class="fe lr ls lt lu b">/etc/passwd</code>的访问。这就是<code class="fe lr ls lt lu b">setuid</code>派上用场的地方——它允许我们将<code class="fe lr ls lt lu b">usr/bin/passwd</code>作为<code class="fe lr ls lt lu b">root</code>开始。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="6923" class="no md it lu b gy oe of l og oh">$ ls -al /usr/bin/passwd <br/>-rwsr-xr-x 1 root root 27936 Mar 22  2019 /usr/bin/passwd</span></pre><p id="1998" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行权限中的<code class="fe lr ls lt lu b">s</code>而不是<code class="fe lr ls lt lu b">x</code>表明该进程将以root身份运行。</p><p id="dd16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要设置和移除该位，我们可以再次使用<code class="fe lr ls lt lu b">chmod</code>。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="8563" class="no md it lu b gy oe of l og oh">$ chmod u-s /usr/bin/passwd <br/>$ ls -al /usr/bin/passwd <br/>-rwxr-xr-x 1 root root 27936 Mar 22  2019 /usr/bin/passwd</span></pre><p id="774c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在Docker中这样做了，所以我真正的文件系统是安全的。</p><h2 id="def8" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">属性</h2><p id="99f6" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">就像文件系统中的所有文件都有一个惟一的索引节点一样，进程也有它们惟一的标识符，称为进程id，或<code class="fe lr ls lt lu b">pid</code>。</p><p id="b1f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像所有文件都有一个到其父目录的链接一样，每个进程都有一个到产生它的父进程的链接。</p><p id="6fac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像文件系统的根是如何存在的一样(<code class="fe lr ls lt lu b">/</code>)，有一个特殊的根父进程叫做<code class="fe lr ls lt lu b">init</code>。它通常有<code class="fe lr ls lt lu b">pid</code> 1。</p><p id="ae4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nn">不像</em>文件系统的根，它的父目录是它自己(<code class="fe lr ls lt lu b">/</code>),<code class="fe lr ls lt lu b">init</code>的<code class="fe lr ls lt lu b">ppid</code>是0，这通常意味着它没有父目录。<code class="fe lr ls lt lu b">pid</code> 0对应于内核调度程序，它不是一个用户进程。</p><h2 id="2dea" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">生命周期</h2><p id="d91a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在Unix中，进程如何工作有一个共同的模式。</p><p id="646f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过克隆现有的父进程创建一个新的子进程(<code class="fe lr ls lt lu b">fork()</code>)。这个新的子进程调用(<code class="fe lr ls lt lu b">exec()</code>)来用子进程想要运行的进程替换子进程中运行的父进程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/942e48527cc75d1452fe27ae934c4230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZLA-iEiGNxZ54MAK.jpg"/></div></div></figure><p id="3cf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，子进程调用<code class="fe lr ls lt lu b">exit()</code>来终止自身。它只向外传递一个退出代码。<code class="fe lr ls lt lu b">0</code>意味着成功，其他一切都是错误代码。</p><p id="0b5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">父进程需要调用<code class="fe lr ls lt lu b">wait()</code>系统调用来访问这个退出代码。这种循环对每个产生的进程重复进行。</p><p id="31df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一些事情可能会出错。</p><p id="5d77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">家长不叫<code class="fe lr ls lt lu b">wait()</code>怎么办？这会导致一个僵尸进程，这是一种资源泄漏，因为在进程的退出代码被父进程使用之前，操作系统无法清理进程。</p><p id="787c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果父进程先于子进程死亡怎么办？这导致了一个孤儿进程(我保证这不是我编的)。一个孤儿流程被<code class="fe lr ls lt lu b">init</code>流程(特殊的根父流程)采用，然后<code class="fe lr ls lt lu b">waits</code>在子流程上完成。</p><p id="eecf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在计算机世界的自然秩序中，孩子先于父母死去。</p><p id="b208" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">父母如何从孩子那里获得更多信息？它不能通过退出代码，因为这是一个进程唯一可以返回给父进程的东西。</p><p id="eda4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">流程不像常规函数，在常规函数中，您可以将响应返回给调用函数。然而，<a class="ae lq" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank">还有其他方法进行进程间通信</a></p><p id="81fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将通过一个例子来更详细地说明事情是如何工作的。在此之前，我们需要更多的信息。</p><h2 id="d991" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">文件重定向</h2><p id="fdf3" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">还记得操作系统如何为每个正在运行的进程提供三个打开的文件吗？我们有能力把这些文件重定向到任何我们想要的地方。</p><p id="e750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">&gt;</code>重定向<code class="fe lr ls lt lu b">stdout</code>、<code class="fe lr ls lt lu b">2&gt;</code>重定向<code class="fe lr ls lt lu b">stderr</code>、<code class="fe lr ls lt lu b">&lt;</code>重定向<code class="fe lr ls lt lu b">stdin</code>。</p><p id="06e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，<code class="fe lr ls lt lu b">./someBinary 2&gt;&amp;1</code>将<code class="fe lr ls lt lu b">stderr</code>重定向到<code class="fe lr ls lt lu b">stdout</code>。</p><p id="d19b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">0、1和2分别是<code class="fe lr ls lt lu b">stdin</code>、<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>文件的简写。</p><p id="10be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<code class="fe lr ls lt lu b">./someBinary 2&gt;1</code>不会像你期望的那样工作，因为语法是<code class="fe lr ls lt lu b">file-descriptor &gt; file</code>。<code class="fe lr ls lt lu b">2&gt;1</code>表示<code class="fe lr ls lt lu b">stderr</code>将被重定向到一个名为<code class="fe lr ls lt lu b">1</code>的文件。<code class="fe lr ls lt lu b">&amp;</code>操作符给出文件的文件描述符。</p><p id="005e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件重定向发生在命令运行之前。当操作系统打开新文件时(通过<code class="fe lr ls lt lu b">&gt;</code>，它会删除那些文件中已经存在的所有内容。</p><p id="b355" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，<code class="fe lr ls lt lu b">sort res.txt &gt; res.txt</code>是行不通的。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="9307" class="no md it lu b gy oe of l og oh">$ cat res.txt <em class="nn"># check contents of res</em><br/>d<br/>c<br/>b<br/>a</span><span id="03d4" class="no md it lu b gy oj of l og oh">$ sort res.txt <em class="nn"># sort res</em><br/>a<br/>b<br/>c<br/>d</span><span id="72cd" class="no md it lu b gy oj of l og oh">$ sort res.txt <strong class="lu iu">&gt;</strong> res.txt<br/>$ cat res<br/><em class="nn"># empty</em></span></pre><p id="585a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提示:通过在shell中设置<code class="fe lr ls lt lu b">noclobber</code>选项，您可以确保您的重定向不会破坏现有文件。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="751a" class="no md it lu b gy oe of l og oh">$ set -o noclobber<br/>$ sort res.txt <strong class="lu iu">&gt;</strong> res.txt<br/>-bash: res.txt: cannot overwrite existing file</span></pre><p id="5dc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，它可以与<code class="fe lr ls lt lu b">&gt;&gt;</code>一起工作，因为在这种情况下，您将追加到文件中。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="9de1" class="no md it lu b gy oe of l og oh">$ sort res.txt <strong class="lu iu">&gt;&gt;</strong> res.txt<br/>$ cat res.txt <br/>d<br/>c<br/>b<br/>a<br/>a<br/>b<br/>c<br/>d</span></pre><p id="bd33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读更多关于重定向的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="071f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Unix中的层</h1><p id="a421" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们可以把Unix想象成洋葱。中心是硬件——主板、CPU和许多我不太明白的晶体管。外面一层是内核。</p><h2 id="35b6" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">内核</h2><p id="ea61" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">内核是负责与文件系统和设备交互的核心。它还处理进程调度、任务执行、内存管理和访问控制。</p><p id="87e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内核公开了API调用，供构建在其上的任何东西使用。最受欢迎的是<code class="fe lr ls lt lu b">exec()</code>、<code class="fe lr ls lt lu b">fork()</code>和<code class="fe lr ls lt lu b">wait()</code>。</p><h2 id="6e28" class="no md it bd me np nq dn mi nr ns dp mm ld nt nu mo lh nv nw mq ll nx ny ms nz bi translated">Unix实用程序</h2><p id="758b" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">另一层是Unix实用程序。这些都是非常有用的过程，可以帮助我们与内核进行交互。它们通过内核提供的系统调用<code class="fe lr ls lt lu b">exec()</code>和<code class="fe lr ls lt lu b">fork()</code>来实现。</p><p id="1b0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经听说过许多实用程序。你可能用过最著名的一个:<code class="fe lr ls lt lu b">shell</code>。</p><p id="4a5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他还有:<code class="fe lr ls lt lu b">python</code>、<code class="fe lr ls lt lu b">gcc</code>、<code class="fe lr ls lt lu b">vi</code>、<code class="fe lr ls lt lu b">sh</code>、<code class="fe lr ls lt lu b">ls</code>、<code class="fe lr ls lt lu b">cp</code>、<code class="fe lr ls lt lu b">mv</code>、<code class="fe lr ls lt lu b">cat</code>、<code class="fe lr ls lt lu b">awk</code>。</p><p id="2d03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以从<code class="fe lr ls lt lu b">shell</code>中调用它们中的大部分。<code class="fe lr ls lt lu b">bash</code>、<code class="fe lr ls lt lu b">zsh</code>、<code class="fe lr ls lt lu b">ksh</code>只是一个<code class="fe lr ls lt lu b">shell</code>的不同变体。他们做同样的事情。</p><p id="29a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个让人望而生畏的工具是文本编辑器<a class="ae lq" href="https://www.vim.org/" rel="noopener ugc nofollow" target="_blank"> Vim </a>。Vim应该有自己的帖子，<a class="ae lq" href="https://neilkakkar.com/How-not-to-be-afraid-of-Vim-anymore.html" rel="noopener ugc nofollow" target="_blank">，这就是我在这里创建的</a></p><p id="89cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的事实:一个<code class="fe lr ls lt lu b">shell</code>被称为一个<code class="fe lr ls lt lu b">shell</code>，因为它是内核之外最接近的层。它将内核包裹在一层保护性的……外壳中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8702" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外壳如何工作</h1><p id="11a9" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">还记得shell是一个怎样的过程吗？这意味着当它启动时，操作系统提供了三个文件供它使用:<code class="fe lr ls lt lu b">stdin</code>、<code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>。</p><p id="ab5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当从终端运行时，<code class="fe lr ls lt lu b">stdin</code>连接到键盘输入。你写的东西被传入终端。这是通过一个叫做<a class="ae lq" href="https://en.wikipedia.org/wiki/Tty_(unix)" rel="noopener ugc nofollow" target="_blank">远程打字机</a>或<code class="fe lr ls lt lu b">tty</code>的文件实现的。</p><p id="2839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">stdout</code>和<code class="fe lr ls lt lu b">stderr</code>也连接到<code class="fe lr ls lt lu b">tty</code>，这就是为什么你运行的任何命令的输出和错误都会显示在终端上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/481ca5c0bfab40cb38307469dd65bc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Doui7gchS69U5Pgb.jpg"/></div></div></figure><p id="1492" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你打开的每个终端都会通过<code class="fe lr ls lt lu b">tty</code>分配一个新文件，这样来自一个终端的命令就不会干扰另一个终端。您可以通过<code class="fe lr ls lt lu b">tty</code>命令找到您的终端附加的文件。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="61b9" class="no md it lu b gy oe of l og oh">$ tty<br/>/dev/ttys001 <em class="nn"># on linux, this looks like: /dev/pts/0</em></span></pre><p id="8e4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你可以做一些有趣的事情:因为<code class="fe lr ls lt lu b">shell</code>从这个文件中读取数据，你可以让另一个shell也向这个文件中写入数据，或者将这些shell放在一起。让我们试试。(还记得如何从上面的过程部分重定向文件吗？)</p><p id="5df1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开第二个终端。键入:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="be0a" class="no md it lu b gy oe of l og oh">$ echo "Echhi" <strong class="lu iu">&gt;</strong> /dev/ttys001 <em class="nn"># replace /dev/ttys001 with your tty output</em></span></pre><p id="ae9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意第一个终端发生了什么。</p><p id="7cfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次尝试回显列出文件的命令<code class="fe lr ls lt lu b">ls</code>。为什么第一个终端不运行该命令？</p><p id="5dde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不运行命令，因为写入终端的流是第二个终端的<code class="fe lr ls lt lu b">stdout</code>，而不是第一个终端的<code class="fe lr ls lt lu b">stdin</code>流。</p><p id="af96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，只有通过<code class="fe lr ls lt lu b">stdin</code>进入的输入才作为输入传递给<code class="fe lr ls lt lu b">shell</code>。其他的都只是显示在屏幕上。即使在这种情况下碰巧是同一个文件，它也与进程无关。</p><p id="9093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述内容的自然延伸是，当您重定向<code class="fe lr ls lt lu b">stdin</code>时，命令应该会运行。听起来很合理，我们试试吧。</p><p id="e985" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">警告:</strong>一种方法是<code class="fe lr ls lt lu b">bash &lt; /dev/ttys001 </code>。这并不太好，因为现在有两个进程期待来自这个文件的输入。</p><p id="fcce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个未定义的状态，但在我的Mac上，一个字符去了一个终端，另一个字符去了第二个，这样继续下去。这很有趣，因为要退出新的shell，我必须键入<code class="fe lr ls lt lu b">eexxiitt</code>。然后两个弹壳都丢了。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="6602" class="no md it lu b gy oe of l og oh">$ echo ls <strong class="lu iu">&gt;</strong> ls.txt <em class="nn"># write "ls" to a file</em><br/>$ cat ls.txt <em class="nn"># check what's in file</em><br/>ls</span><span id="b2ba" class="no md it lu b gy oj of l og oh">$ bash &lt; ls.txt <br/>Applications<br/>Music<br/>Documents<br/>Downloads</span></pre><p id="7995" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一种更好的方法，我们稍后会谈到。</p><p id="b7fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了一些微妙的事情。这个新的<code class="fe lr ls lt lu b">bash</code>进程(我们从一个现有的bash进程开始)是如何知道在哪里输出东西的呢？</p><p id="18a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们从未指定输出流，只指定了输入流。这是因为进程从它们的父进程继承而来。</p><p id="7226" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次你在终端上写一个命令，<code class="fe lr ls lt lu b">shell</code>就会创建一个重复的进程(通过<code class="fe lr ls lt lu b">fork()</code>)。</p><p id="c18c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<code class="fe lr ls lt lu b">man 2 fork</code>开始:</p><blockquote class="om on oo"><p id="c603" class="ku kv nn kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated">子进程拥有自己的父进程描述符副本。这些描述符引用相同的底层对象，例如，文件对象中的文件指针在子进程和父进程之间共享，因此子进程中描述符上的lseek(2)可以影响父进程的后续读取或写入。</p><p id="f8f4" class="ku kv nn kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated">这个描述符复制还被shell用来为新创建的进程建立标准的输入和输出，以及建立管道。</p></blockquote><p id="7941" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦分叉，这个新的子进程从父进程继承文件描述符，然后调用<code class="fe lr ls lt lu b">exec</code> ( <code class="fe lr ls lt lu b">execve()</code>)来执行命令。这将替换流程图像。</p><p id="6960" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<code class="fe lr ls lt lu b">man 3 exec</code>开始:</p><blockquote class="om on oo"><p id="0fb3" class="ku kv nn kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated">本手册页中描述的功能是功能<code class="fe lr ls lt lu b">execve</code> (2)的前端。</p></blockquote><p id="547f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来自<code class="fe lr ls lt lu b">man 2 execve</code>【8】:</p><blockquote class="om on oo"><p id="9c77" class="ku kv nn kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated">在调用进程映像中打开的文件描述符在新的进程映像中保持打开，除了那些设置了close-on-exec标志的文件描述符</p></blockquote><p id="f76b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们的文件描述符与原始的bash进程相同，除非我们通过重定向来改变它们。</p><p id="7325" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这个子进程正在执行时，父进程<code class="fe lr ls lt lu b">waits</code>为子进程完成。发生这种情况时，控制权会返回给父进程。</p><p id="dcbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，子进程不是<code class="fe lr ls lt lu b">bash</code>，而是取代<code class="fe lr ls lt lu b">bash</code>的进程。使用<code class="fe lr ls lt lu b">ls</code>，程序在将文件列表输出到<code class="fe lr ls lt lu b">stdout</code>后立即返回。</p><p id="718f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:并不是shell上的所有命令都会产生<code class="fe lr ls lt lu b">fork</code>和<code class="fe lr ls lt lu b">exec</code>。不支持的命令称为内置命令。有些是出于需要而内置的；由于子进程不能将信息传递回父进程，所以其他进程可以使事情变得更快。</p><p id="a94a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，设置环境变量在子shell中不起作用，它不能将值传递回父shell。你可以在这里找到名单。</p><p id="f6aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个我喜欢的演示。</p><p id="e840" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您有没有想过，当某个程序正在运行并向终端输出内容时，您可以编写下一个命令，并在现有进程完成时让它们工作，这有多奇怪？</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="568b" class="no md it lu b gy oe of l og oh">$ sleep 10;<br/>ls<br/>cat b.txt<br/>brrr<br/><em class="nn"># I stop typing here</em><br/>$ ls<br/>b	c	y</span><span id="81a6" class="no md it lu b gy oj of l og oh">$ cat b.txt<br/>defbjehb</span><span id="9e8b" class="no md it lu b gy oj of l og oh">$ brrr<br/>-bash: brrr: command not found</span></pre><p id="ed2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只是进程被阻塞了，输入流仍在接受数据。因为我们正在读/写的文件是相同的(<code class="fe lr ls lt lu b">tty</code>)，我们看到我们键入的内容，当<code class="fe lr ls lt lu b">sleep 10;</code>返回时，shell为<code class="fe lr ls lt lu b">ls</code>创建另一个进程，再次等待，然后为<code class="fe lr ls lt lu b">cat b.txt</code>创建同样的进程，然后再次为<code class="fe lr ls lt lu b">brrr</code>创建进程。</p><p id="6d7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我使用<code class="fe lr ls lt lu b">sleep 10;</code>来演示，因为其他命令发生得太快，在控制返回到父进程<code class="fe lr ls lt lu b">bash</code>之前，我无法输入任何内容。</p><p id="76e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在是尝试<code class="fe lr ls lt lu b">exec</code>内置命令的好时机(它取代了当前进程，因此它将终止您的shell会话)。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="734e" class="no md it lu b gy oe of l og oh">exec echo Bye</span></pre><p id="a7c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">echo</code>也是内置命令。</p><p id="1d12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想自己用C实现shell，<a class="ae lq" href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lec/14/lec.html" rel="noopener ugc nofollow" target="_blank">这里有一个我推荐的资源</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d39b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">管子</h1><p id="c181" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">有了关于shell如何工作的知识，我们可以冒险进入管道的世界:<code class="fe lr ls lt lu b">|</code>。</p><p id="9829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将两个过程联系在一起，其工作方式很有趣。</p><p id="b7e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得我们开始时的哲学吗？做一件事，并把它做好。既然我们所有的实用程序都运行良好，我们如何让它们一起工作呢？</p><p id="31ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是管子，<code class="fe lr ls lt lu b">|</code>，管子在哪里。它表示对<code class="fe lr ls lt lu b">pipe()</code>的系统调用，它所做的只是为进程重定向<code class="fe lr ls lt lu b">stdin</code>和<code class="fe lr ls lt lu b">stdout</code>。</p><p id="e5b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然东西设计得如此之好，这个原本复杂的功能就简化成了这个。无论何时你使用管道或者终端上的任何东西，只要想象一下输入和输出文件是如何设置的，你就永远不会有问题。[9]</p><p id="7bbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从一种更好的方式开始，将输入定向到bash，而不是像前面那样使用临时文件(<code class="fe lr ls lt lu b">ls.txt</code>)。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="7781" class="no md it lu b gy oe of l og oh">$ echo ls | bash<br/>Applications<br/>Music<br/>Documents<br/>Downloads</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d2cd0696fd5587528d929bbb57bdf0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9srb5bbOIZ6uNrr4.jpg"/></div></div></figure><p id="7236" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解释管道重定向，这个图像有点简化。你现在知道shell是如何工作的了，所以你知道顶部的<code class="fe lr ls lt lu b">bash</code>分叉了另一个连接到<code class="fe lr ls lt lu b">tty</code>的<code class="fe lr ls lt lu b">bash</code>，产生了<code class="fe lr ls lt lu b">ls</code>的输出。</p><p id="5bd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还知道顶层bash是从底层bash派生出来的，这就是为什么它继承了底层bash的文件描述符。您也知道较低的bash没有派生新的进程，因为<code class="fe lr ls lt lu b">echo</code>是一个内置命令。</p><p id="d1a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一个更复杂的例子来结束这一部分:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="e98d" class="no md it lu b gy oe of l og oh">$ ls -ail | sort -nr -k 6 | head -n 1 | cut -f 9 -d ' '<br/>2656</span></pre><p id="400b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个管道计算出当前目录中最大的文件，并输出其大小。</p><p id="c0ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能有一种更优雅的方式来做到这一点，那就是<a class="ae lq" href="https://superuser.com/questions/228853/how-to-find-the-largest-file-in-a-directory" rel="noopener ugc nofollow" target="_blank">只需一次谷歌搜索</a>，但这作为一个例子效果很好。谁知道这个已经内置在<code class="fe lr ls lt lu b">ls</code>里了？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f2cae53c4526e9ffdd2053487652513d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6eNw_xiGvqiLYqzP.jpg"/></div></div></figure><p id="b989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意到<code class="fe lr ls lt lu b">stderr</code>总是直接路由到<code class="fe lr ls lt lu b">tty</code>吗？如果你想重定向<code class="fe lr ls lt lu b">stderr</code>而不是<code class="fe lr ls lt lu b">stdout</code>到管道呢？您可以在管道之前切换流。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="38f4" class="no md it lu b gy oe of l og oh">$ error-prone-command 2&gt;&amp;1 <strong class="lu iu">&gt;</strong>/dev/null</span></pre><p id="0756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来源:<a class="ae lq" href="https://stackoverflow.com/questions/2342826/how-to-pipe-stderr-and-not-stdout" rel="noopener ugc nofollow" target="_blank">这个美女</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="96f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关于路径的一切</h1><p id="e34c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">局部变量是可以在shell中创建的变量。它们在贝壳上是本地的，因此不会传给孩子。(记住，每个非内置命令都在一个新的shell中，它没有这些局部变量。)</p><p id="79fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">环境变量(<code class="fe lr ls lt lu b">env</code> vars)类似于全局变量。它们会传给孩子。但是，对子进程中环境变量的更改不能传递给父进程。记住，除了退出代码，孩子和父母之间没有任何交流。</p><p id="fa61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">试试这个:从<code class="fe lr ls lt lu b">bash</code>调用<code class="fe lr ls lt lu b">bash</code>的<code class="fe lr ls lt lu b">bash</code>。第一个<code class="fe lr ls lt lu b">bash</code>等待第二个<code class="fe lr ls lt lu b">bash</code>退出，第二个等待第三个。</p><p id="ca23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您调用<code class="fe lr ls lt lu b">exec</code>时，退出自动发生。如果没有，您希望自己键入<code class="fe lr ls lt lu b">exit</code>来将退出代码发送给父进程。退出两次，你又回到原点。</p><p id="e68e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，思想实验:当你在shell中输入<code class="fe lr ls lt lu b">ls</code>会发生什么？你知道发生的<code class="fe lr ls lt lu b">fork()</code>、<code class="fe lr ls lt lu b">exec()</code>和<code class="fe lr ls lt lu b">wait()</code>循环，以及<code class="fe lr ls lt lu b">tty</code>。</p><p id="c544" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，即使在这种情况发生之前，<code class="fe lr ls lt lu b">ls</code>只是另一个效用函数，对吗？这意味着在某个地方有一个程序文件，里面有做<code class="fe lr ls lt lu b">fork()</code>和其他事情的C代码。</p><p id="1580" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个二进制文件不在你当前的目录中(你可以用<code class="fe lr ls lt lu b">ls -a</code>来检查)。如果这些文件在我当前的目录中，我可以通过在shell中键入它们的名称来执行它们，这对我来说是有意义的。它们是可执行文件。</p><p id="51b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">ls</code>程序文件到底在哪里？</p><p id="0f24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得文件系统树是如何分层的吗？疯狂是有秩序的。</p><p id="4bac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有基层目录都有特定的功能。例如，所有的Unix实用程序和一些额外的程序都进入<code class="fe lr ls lt lu b">/bin</code>目录。Bin代表二进制。如果你想了解更多，有上百万的教程。</p><p id="a05c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对我们来说是足够的知识。<code class="fe lr ls lt lu b">ls</code>住在<code class="fe lr ls lt lu b">/bin</code>。所以，你可以这样做:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="c51b" class="no md it lu b gy oe of l og oh">$ /bin/ls<br/>a  b  c</span></pre><p id="7e80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与运行<code class="fe lr ls lt lu b">ls</code>相同。</p><p id="bb28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，shell是如何知道在<code class="fe lr ls lt lu b">bin</code>中寻找<code class="fe lr ls lt lu b">ls</code>的呢？</p><p id="a595" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是神奇的环境变量<code class="fe lr ls lt lu b">PATH</code>的用武之地。我们先来看看。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="bfa7" class="no md it lu b gy oe of l og oh">$ echo $PATH<br/>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></pre><p id="ad29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了查看所有环境变量，我们可以:</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="5c85" class="no md it lu b gy oe of l og oh">$ env<br/>HOSTNAME<strong class="lu iu">=</strong>12345XXXX<br/>TERM<strong class="lu iu">=</strong>xterm<br/>TMPDIR<strong class="lu iu">=</strong>/tmp<br/>PATH<strong class="lu iu">=</strong>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br/>PWD<strong class="lu iu">=</strong>/test<br/>LANG<strong class="lu iu">=</strong>en_US.UTF-8<br/>SHLVL<strong class="lu iu">=</strong>1<br/>HOME<strong class="lu iu">=</strong>/root<br/>LANGUAGE<strong class="lu iu">=</strong>en_US:en<br/>LESSOPEN<strong class="lu iu">=||</strong>/usr/bin/lesspipe.sh %s<br/>container<strong class="lu iu">=</strong>oci<br/>_<strong class="lu iu">=</strong>/bin/env</span></pre><p id="add5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">PATH</code>是一个冒号分隔的目录列表。当shell看到一个没有绝对路径的命令时，它会在这个<code class="fe lr ls lt lu b">$PATH</code>环境变量中查找，按顺序进入每个目录，并尝试在那里找到文件。它执行找到的第一个文件。</p><p id="2d50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe lr ls lt lu b">/bin</code>在<code class="fe lr ls lt lu b">PATH</code>中的位置，这就是为什么<code class="fe lr ls lt lu b">ls</code>能够正常工作。</p><p id="9013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我移除<code class="fe lr ls lt lu b">PATH</code>中的所有内容会发生什么？没有绝对路径，任何东西都不应该工作。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="3f9c" class="no md it lu b gy oe of l og oh">$ PATH<strong class="lu iu">=</strong>'' ls<br/>-bash: ls: No such file or directory</span></pre><p id="b3b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上语法仅用于为一个命令设置环境变量。旧的<code class="fe lr ls lt lu b">PATH</code>值仍然存在于shell中。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="e330" class="no md it lu b gy oe of l og oh">$ echo $PATH<br/>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></pre><p id="3c33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:<strong class="kw iu"> </strong>做<code class="fe lr ls lt lu b">PATH='' echo $PATH</code>不会起作用，因为<code class="fe lr ls lt lu b">echo</code>是一个内置的shell。然而，如果您用<code class="fe lr ls lt lu b">PATH=''</code>启动了一个新的shell进程，然后执行了<code class="fe lr ls lt lu b">echo</code>，它将会工作。</p><p id="9117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">$ <strong class="kw iu">(</strong>PATH<strong class="kw iu">=</strong>''; echo $PATH<strong class="kw iu">)</strong></code></p><p id="fc7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">()</code>是新subshell的语法。我知道，有很多信息我不会首先解释，但这都是语法层面的，只需要一次谷歌搜索。从好的方面来说，它确保了这篇博文不会变成一本书。</p><p id="98dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你听说过<code class="fe lr ls lt lu b">./</code>是运行你创建的文件的方式吗？为什么不能像运行<code class="fe lr ls lt lu b">bash</code>那样运行它们呢？现在你知道了。当您执行<code class="fe lr ls lt lu b">./</code>时，这是您想要执行的文件的确切路径。<code class="fe lr ls lt lu b">bash</code>有效，因为它在<code class="fe lr ls lt lu b">PATH</code>上。</p><p id="1f12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果当前目录总是在<code class="fe lr ls lt lu b">PATH</code>上，那么您的脚本将按名称工作是有道理的。</p><p id="fec3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们试试这个。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="14e3" class="no md it lu b gy oe of l og oh">$ vim script.sh<br/><em class="nn"># echo "I can work from everywhere?"</em><br/>$ chmod a+x script.sh <br/>$ ls<br/>script.sh</span><span id="6ba1" class="no md it lu b gy oj of l og oh">$ script.sh<br/>-bash: script.sh: command not found <em class="nn"># not on PATH</em></span><span id="beeb" class="no md it lu b gy oj of l og oh">$ ./script.sh <em class="nn"># path to file is defined</em><br/>I can work from everywhere?</span></pre><p id="a179" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们把它加到电流<code class="fe lr ls lt lu b">PATH</code>上。然后运行刚<code class="fe lr ls lt lu b">script.sh</code>。</p><pre class="kj kk kl km gt oa lu ob oc aw od bi"><span id="1ac2" class="no md it lu b gy oe of l og oh">$ PATH<strong class="lu iu">=${</strong>PATH<strong class="lu iu">}</strong>:. script.sh <em class="nn"># this appends . to PATH, only for this command</em><br/>I can work from everywhere?<br/>$ export PATH<strong class="lu iu">=${</strong>PATH<strong class="lu iu">}</strong>:. <em class="nn"># this sets the PATH variable permanently to include .</em></span><span id="ab62" class="no md it lu b gy oj of l og oh">$ script.sh <em class="nn"># calling script.sh without the ./</em><br/>I can work from everywhere?</span><span id="99eb" class="no md it lu b gy oj of l og oh">$ cd .. <em class="nn"># go one directory up</em><br/>$ script.sh <em class="nn"># this shows that PATH directories aren't searched recursively</em><br/>-bash: script.sh: command not found <em class="nn"># so script doesn't run anymore</em></span></pre><p id="58f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">警告:</strong>在你的路径中包含当前目录是不好的做法。有几个问题。您永远无法确定任何命令的执行是否符合预期。</p><p id="9937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有一个名为<code class="fe lr ls lt lu b">ls</code>的二进制文件，它是你当前目录中的一个病毒(从互联网上下载的)，但你本打算做<code class="fe lr ls lt lu b">/bin/ls</code>，那该怎么办？</p><p id="0236" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://unix.stackexchange.com/questions/254711/history-of-unix-not-including-current-directory-in-path" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p><p id="6a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次您看到“没有这样的文件或目录”错误时，当您知道该文件存在时(可能您刚刚安装了它)，您就知道问题出在哪里了。<code class="fe lr ls lt lu b">PATH</code>被终结了！</p><p id="1b8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它安装在不在您的<code class="fe lr ls lt lu b">PATH</code>上的位置，所以您只能从您安装它的地方调用它。要解决这个问题，您现在知道可以将该目录添加到<code class="fe lr ls lt lu b">PATH</code>，或者通过其绝对路径调用该文件。</p><p id="2871" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的事实:<strong class="kw iu"> </strong> Python在搜索导入时也有类似的结构，使用了<code class="fe lr ls lt lu b">PYTHONPATH</code> env变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编写Shell脚本</h1><p id="6724" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这篇文章已经变得比我预期的要长。此外，使用shell编程在网上有很多报道。但是为了完整起见，这里有一个<a class="ae lq" href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Compound-Commands" rel="noopener ugc nofollow" target="_blank">到手册</a>的链接，和一个<a class="ae lq" href="https://www.shellscript.sh/first.html" rel="noopener ugc nofollow" target="_blank">像样的教程</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包管理器</h1><p id="3620" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">假设你写了一个新工具。它在你的机器上运行得非常好，现在你想把它卖给其他用户。等等，我的意思是，本着开源的精神，你想让别人也能使用。</p><p id="7e08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也要让他们免于头痛。更好的是，您希望将东西安装在正确的位置:二进制文件放入<code class="fe lr ls lt lu b">/usr/bin/</code>(它已经在<code class="fe lr ls lt lu b">PATH</code>上了)，依赖项放在主二进制文件可以找到它的地方。</p><p id="862f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">包管理器正好解决了这个问题。它们不会让您头疼，而是让事情正常运行。</p><p id="916d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据我所知，有三个主要的软件包管理器:<code class="fe lr ls lt lu b">dpkg</code>、<code class="fe lr ls lt lu b">rpm</code>和<code class="fe lr ls lt lu b">homebrew</code>。它们每个都工作在不同的Linux发行版上(如果您不确定这意味着什么，这将在下一节中介绍)。</p><p id="64d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，<a class="ae lq" href="https://en.wikipedia.org/wiki/List_of_software_package_management_systems" rel="noopener ugc nofollow" target="_blank">野生的有几百只</a>，就像分布的数量一样。</p><p id="a02a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">dpkg</code>是<a class="ae lq" href="https://www.debian.org/" rel="noopener ugc nofollow" target="_blank"> Debian </a>包管理器，但是你可能听说过一个构建在它之上的非常有用的工具来管理包:<code class="fe lr ls lt lu b">apt</code>。</p><p id="1604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次你使用<code class="fe lr ls lt lu b">apt install</code>来安装一个新的包，你都在利用这个包管理器的能力，它确保所有的东西都在它们需要的地方。</p><p id="c056" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开发方面，这意味着确保您正在创建的工具与包管理器兼容。下面举例说明如何在<a class="ae lq" href="https://ubuntuforums.org/showthread.php?t=910717" rel="noopener ugc nofollow" target="_blank"> C </a>和<a class="ae lq" href="https://the-hitchhikers-guide-to-packaging.readthedocs.io/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank"> Python </a>中实现。</p><p id="7d0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">rpm</code>是<a class="ae lq" href="https://www.redhat.com/en" rel="noopener ugc nofollow" target="_blank"> Red Hat </a> package manager，它也有一个构建在上面的有用工具:<code class="fe lr ls lt lu b">yum</code>，它也处理依赖关系。</p><p id="051d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b"><a class="ae lq" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">homebrew</a></code>是macOS上的包管理器，你每次使用它<code class="fe lr ls lt lu b">brew install</code>的时候。</p><p id="e4cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们让生活变得简单。</p><p id="960f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们非常方便，编程语言也有自己的包管理器！例如，<code class="fe lr ls lt lu b">pip</code>是一个流行的Python工具安装程序。有<a class="ae lq" href="https://www.ruby-lang.org/en/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>的<code class="fe lr ls lt lu b">bundler</code>，Swift/iOS的<code class="fe lr ls lt lu b">cocoa</code>，还有其他几个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4023" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Unix简史</h1><p id="8c3c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">Unix是第一个允许多个用户使用的操作系统，每个用户可以同时运行多个程序。</p><p id="52e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能听起来微不足道，因为几乎每个操作系统都有这种功能，但它刚出现时是革命性的。在大型主机上租赁时间的日子结束了。你可以让你的程序在后台运行，而其他人做他们的工作。</p><p id="b973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顾名思义，Unix是一个多用户多任务操作系统。</p><p id="b62c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是专利，美国电话电报公司是唯一一家可以出售它的公司。(贝尔实验室在20世纪70年代开发的)。他们选择了许可模式，并很快推出了一个规范，叫做<a class="ae lq" href="https://en.wikipedia.org/wiki/Single_UNIX_Specification" rel="noopener ugc nofollow" target="_blank">单一UNIX规范</a>。</p><p id="574c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一组指导原则，遵循这些原则的任何系统都可以被认证为Unix系统。</p><p id="b5f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大约在同一时间，一些人对Unix的专有性质感到不满，并提出了另一种称为Linux的开源操作系统内核。</p><p id="f0f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">受Unix哲学的启发，为了实现可移植性，这些系统遵循了T2的POSIX标准T3，这是Unix的一个子集。因此，这些系统也被称为类Unix系统。[10]</p><p id="12ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的事情变得有点混乱。Linux是基于Linux内核的一系列操作系统。没有一个单一的操作系统叫做Linux。</p><p id="be12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有的是Debian，Ubuntu，Fedora，CentOS，Red Hat，Gentoo等等。这些是Linux内核的发行版(俗称<em class="nn">发行版</em>)。成熟的操作系统。</p><p id="a17a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有什么区别？有些是为特定目的而构建的(例如:Kali Linux自带安全测试工具)。</p><p id="5684" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数在软件包管理、软件包更新频率和安全性方面有所不同。</p><p id="71bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多，请访问opensource.com。</p><p id="d413" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的事实:<strong class="kw iu"> </strong> Mac OS X是Unix认证的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ec7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="cd8a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们已经谈了很多。让我们花一点时间来把它们放在一起。</p><p id="be54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Unix是一个成熟的操作系统，而Linux是一个内核——操作系统的核心——受Unix的启发。他们专注于做一件事，并把它做好。</p><p id="2e32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切要么是一个过程，要么是一个文件。内核是核心，它公开系统调用，实用程序利用这些调用。进程使用文件作为输入和输出。我们可以控制这些文件，我们可以重定向它们，这不会对流程产生影响。</p><p id="eda1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">管道可以将一个进程的输出重定向到另一个进程的输入。来自shell的每个命令首先分叉，然后执行，并将退出代码返回给等待的父级。</p><p id="89ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有很多。如果有可能进行无损压缩，我会在文章中进行。</p><p id="d5f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，欢迎来到野外，你可以走了。</p><p id="36d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">exit</code></p><p id="cc57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢Vatika Harlalka、<a class="ae lq" href="https://medium.com/@asnani04" rel="noopener"> Nishit Asnani </a>、<a class="ae lq" href="https://www.quora.com/profile/Hemanth-Kumar-Veeranki" rel="noopener ugc nofollow" target="_blank"> Hemanth K. Veeranki </a>和<a class="ae lq" href="https://twitter.com/ParityB1t" rel="noopener ugc nofollow" target="_blank"> Hung Hoang </a>阅读本文的草稿。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">脚注</h1><ol class=""><li id="950a" class="mz na it kw b kx mu la mv ld os lh ot ll ou lp ol nf ng nh bi translated">这刚刚变成诗了吗？</li><li id="468f" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">终端也有正在运行的子流程，比如<code class="fe lr ls lt lu b">shell</code>。您可以通过<code class="fe lr ls lt lu b">ps -ef</code>查看所有正在运行的进程。</li><li id="84dd" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">一个<code class="fe lr ls lt lu b">shell</code>是你用来和操作系统交互的接口。它可以是命令行界面(CLI)和图形用户界面(GUI)。在这篇文章中，我们只关注CLI。当你打开终端时，迎接你的默认程序是一个<code class="fe lr ls lt lu b">shell</code>。<a class="ae lq" href="https://en.wikipedia.org/wiki/Shell_(computing)" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li><li id="7089" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">这不是100%正确的，有一点更细微的差别，我们很快就会看到。</li><li id="0e87" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">我花了太多时间在iPhones和iOS上。是inode，不是iNode。</li><li id="5048" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">还有，我开始写这个指南的时间。我差不多该完成它了。注意年份。</li><li id="90f0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">这些信息我都是从<code class="fe lr ls lt lu b"><a class="ae lq" href="http://man7.org/linux/man-pages/man5/passwd.5.html" rel="noopener ugc nofollow" target="_blank">man 5 passwd</a></code>得到的。</li><li id="9b97" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">本手册有八个部分，每个部分都有特定的用途。<a class="ae lq" href="http://man7.org/linux/man-pages/man7/man-pages.7.html" rel="noopener ugc nofollow" target="_blank">阅读更多。</a></li><li id="d46e" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">这是一个强有力的想法，因为Unix的设计是这样的:“一切都是一个文件”。</li><li id="16fc" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ol nf ng nh bi translated">有趣的事实——它们不能被称为Unix，因为它们没有经过认证，Unix是一个商标。</li></ol></div></div>    
</body>
</html>