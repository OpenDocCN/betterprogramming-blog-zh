<html>
<head>
<title>Introduction to Android Multi-Touch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android多点触控简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-android-multi-touch-bdae5f8002f4?source=collection_archive---------12-----------------------#2022-02-22">https://betterprogramming.pub/introduction-to-android-multi-touch-bdae5f8002f4?source=collection_archive---------12-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="76ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在应用中添加手势控制</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c03750712ca0a9e5aaec8c70a3954fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q056ZGQtRdsHt-0o1_gZ3g.png"/></div></div></figure><p id="c774" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多指触摸是指监控多个手指的触摸事件。我们可以覆盖<code class="fe ln lo lp lq b">View</code>中的<code class="fe ln lo lp lq b">onTouchEvent</code>方法，或者使用<code class="fe ln lo lp lq b">setOnTouchListener</code>方法来处理触摸事件。</p><p id="5902" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们来看看如何确定多指触摸的事件类型。</p><h1 id="fa1e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">MotionEvent中的事件类型</h1><p id="ec7d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">一般来说，我们通过判断<code class="fe ln lo lp lq b">MotionEvent</code>的动作来判断输入事件的类型，从而做出相应的处理。<br/>在不考虑多个手指的情况下，我们一般只关注以下事件类型:</p><ul class=""><li id="4140" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_DOWN</code> <br/>用食指轻点屏幕</li><li id="6a1e" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_UP</code> <br/>最后一根手指离开屏幕</li><li id="a8b7" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_MOVE</code> <br/>一根手指正在屏幕上划动</li><li id="ca11" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_CANCEL</code> <br/>事件被阻止</li></ul><p id="1649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以对于多指触摸，除了上面提到的常见事件类型，我们还需要注意另外两种事件类型:</p><ul class=""><li id="8208" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_POINTER_DOWN</code> <br/>一个手指已经存在于屏幕前轻点</li><li id="6e3e" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">MotionEvent.ACTION_POINTER_UP</code> <br/>当屏幕上的一个手指抬起时，屏幕上还有其他手指</li></ul><p id="f8bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是，以上两种类型不能像以前一样使用<code class="fe ln lo lp lq b">MotionEvent#getAction</code>方法获得，需要使用<code class="fe ln lo lp lq b">getActionMasked</code>。</p><p id="249a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以在处理多指触摸的时候，我们的<code class="fe ln lo lp lq b">onTouch</code>方法一般可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ceb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当多个手指同时触摸屏幕时，我们需要跟踪不同的手指。这里还涉及到其他几个概念。</p><h1 id="3796" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">手指跟踪</h1><p id="562a" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">MotionEvent</code>中有几种方法可以跟踪不同的手指。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f83b6cb23cf5b17cbe3bd4d9a1d25cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*h597DR0PR1XCmQCwy2dN9g.png"/></div></div></figure><h1 id="48b2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">动作索引(事件索引)</h1><p id="4a4e" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">ActionIndex</code>可以通过<code class="fe ln lo lp lq b">getActionIndex</code>方法直接获得，可以粗略理解为描述当前事件发生的手指数。比如我们在监测手指抬起的时候，可能想知道哪根手指抬起来了，那么就可以通过<code class="fe ln lo lp lq b">ActionIndex</code>来判断。</p><p id="75c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，对于同一个手指，<code class="fe ln lo lp lq b">ActionIndex</code>的值可能会随着手指的按下和抬起而变化，所以我们不能用它来识别一个手指。<br/>看来<code class="fe ln lo lp lq b">ActionIndex</code>的唯一目的就是得到<code class="fe ln lo lp lq b">PointerId</code>。</p><p id="6797" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别要注意的是，这个方法只对<code class="fe ln lo lp lq b">ACTION_POINTER_DOWN</code>和<code class="fe ln lo lp lq b">ACTION_POINTER_UP</code>事件有效。<code class="fe ln lo lp lq b">ACTION_MOVE</code>事件无法准确获取值。需要结合其他事件综合判断。</p><h1 id="39f1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">指针Id(指针ID)</h1><p id="2830" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">通过<code class="fe ln lo lp lq b">getPointerId(int)</code>方法获得<code class="fe ln lo lp lq b">PointerId</code>，参数为<code class="fe ln lo lp lq b">ActionIndex</code>。</p><p id="9275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过<code class="fe ln lo lp lq b">PointerId</code>来识别一个手指。对于同一个手指，<code class="fe ln lo lp lq b">PointerId</code>从按压到抬起的整个过程都是固定的。</p><p id="bfc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还要注意，该值可以重复使用，例如，当手指抬起后再次按下时，<code class="fe ln lo lp lq b">id</code>为0的手指的<code class="fe ln lo lp lq b">id</code>也可以为0。</p><h1 id="ba76" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">指针指数</h1><p id="6b10" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">PointerIndex</code>通过<code class="fe ln lo lp lq b">findPointerIndex(int)</code>获得，参数为<code class="fe ln lo lp lq b">PointerId</code>。</p><p id="fddf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该值用于获取事件的更多内容。</p><p id="1ef6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想得到事件的点击点位置，当我们通过<code class="fe ln lo lp lq b">getX()</code> / <code class="fe ln lo lp lq b">getY()</code>方法得到坐标时，只能得到第一个手指的位置，但是这两个方法提供了一个重载:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="d288" class="nj ls iq lq b gy nk nl l nm nn">float getX(int pointerIndex);<br/>float getY(int pointerIndex);</span></pre><h1 id="8768" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">使用</h1><p id="4ad5" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">通过上面的介绍，我们已经大致了解了多点触控的一些关键点，现在就让我们来实际应用一下。</p><p id="be13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我做一个<code class="fe ln lo lp lq b">DrawView</code>用于绘制手指运动轨迹，它可以同时跟踪多个手指的运动轨迹。效果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e08d2b340647f28a2a3e6a073a2b432d.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/1*0XEBZxtsJDA-iKdKU3QXbg.gif"/></div></figure><p id="0a63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上图是四指同时滑动时的效果。</p><h1 id="418b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">分析</h1><p id="f178" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">为了达到这种效果，有两个主要问题需要考虑:</p><p id="510f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先是如何准确的跟踪手指的滑动轨迹，因为如上所述，<code class="fe ln lo lp lq b">ACTION_MOVE</code>无法获得<code class="fe ln lo lp lq b">ActionIndex</code>。但上帝关上门的时候，一定会打开一扇窗。我们可以通过<code class="fe ln lo lp lq b">PointerId</code>追踪。先监听<code class="fe ln lo lp lq b">ACTION_DOWN</code>和<code class="fe ln lo lp lq b">ACTION_POINTER_DOWN</code>两个事件，在这里得到新手指的<code class="fe ln lo lp lq b">PointerId</code>，遍历<code class="fe ln lo lp lq b">ACTION_MOVE</code>事件中的所有手指，然后比较<code class="fe ln lo lp lq b">PointerId</code>可以是要么。</p><p id="7877" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二，因为<code class="fe ln lo lp lq b">MotionEvent</code>会把多个连续的滑动轨迹打包成一个<code class="fe ln lo lp lq b">MotionEvent</code>，所以我们需要用<code class="fe ln lo lp lq b">getHistoricalX</code>来得到这个滑动的历史轨迹。方法签名如下:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="6891" class="nj ls iq lq b gy nk nl l nm nn">float getHistoricalX(int pointerIndex, int pos);</span></pre><p id="199f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个参数<code class="fe ln lo lp lq b">pointerIndex</code>，很容易解决。第一个问题已经提到了，主要是第二个参数。</p><p id="7939" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe ln lo lp lq b">HistoricalX</code>是一个列表，我们需要通过索引逐个读取，第二个pos参数就是索引，但前提是我们知道列表的长度。这个只需要一个<code class="fe ln lo lp lq b">for</code>循环就可以解决。</p><p id="6708" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">MotionEvent</code>提供了一种获取该列表长度的方法:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="4bf3" class="nj ls iq lq b gy nk nl l nm nn">int getHistorySize();</span></pre><p id="f31d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这个提供了这个方法，没有其他重载，所以你这次无法通过<code class="fe ln lo lp lq b">pointerIndex</code>得到某个手指滑动的历史轨迹列表的长度！</p><p id="3316" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过经过我的测试，无论哪根手指滑动，都可以通过<code class="fe ln lo lp lq b">getHistorySize</code>方法得到历史轨迹的长度，然后调用<code class="fe ln lo lp lq b">getHistoricalX</code>方法得到历史轨迹的坐标。</p><p id="0dee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然不知道为什么这样设计，但是确实解决了这个问题。</p><h1 id="64bd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">完成</h1><p id="a0ad" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">我们首先定义一个内部类作为绘图元数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4044" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的<code class="fe ln lo lp lq b">DrawPath</code>对应的是手指滑动的生命周期，也就是中间经历的从下往上的轨迹。</p><p id="ffd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后定义一个<code class="fe ln lo lp lq b">DrawPath</code>和变量的列表，比如画笔、轨迹颜色数组等。：</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="258b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始化它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2b0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们覆盖<code class="fe ln lo lp lq b">onTouchEvent</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面有评论，就不赘述了。</p><p id="20d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后重写<code class="fe ln lo lp lq b">onDraw</code>方法。虽然这是一个用于绘制轨迹的控件，但在<code class="fe ln lo lp lq b">onDraw</code>方法中没有多少代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b691" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样就实现了一个支持多指画图的简单控件，我们还可以给它添加一些撤销上一步等方法。这里就不说了。</p><p id="05ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">DrawView</code>的完整代码已经放在GitHub上了。</p><p id="6ad1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎你来<a class="ae np" href="https://github.com/0xZhangKe/Collection/blob/master/DrawView/DrawView.java" rel="noopener ugc nofollow" target="_blank">看看</a>。</p></div></div>    
</body>
</html>