<html>
<head>
<title>Understanding the Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解依赖倒置原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-the-most-commonly-used-design-principle-dependency-inversion-principle-f9a8401ab6fb?source=collection_archive---------11-----------------------#2022-03-28">https://betterprogramming.pub/exploring-the-most-commonly-used-design-principle-dependency-inversion-principle-f9a8401ab6fb?source=collection_archive---------11-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4a1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">细节并不重要</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9ab0290c4314853a08fdb84b5638fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5amHhAE-5k35pyM1vzbUUg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@mac-mullins-1319876/" rel="noopener ugc nofollow" target="_blank">麦克·穆林斯</a>在<a class="ae kv" href="https://www.pexels.com/photo/close-up-photo-of-person-holding-lensball-2534487/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><blockquote class="kw"><p id="4bd6" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">让一个程序运行起来并不需要大量的知识和技能——罗伯特·c·马丁</p></blockquote><p id="9b88" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc lg ij bi translated">每个软件系统都提供两种价值，行为和结构。</p><p id="b39c" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">开发人员的责任是确保软件不仅是可操作的，而且是干净的，可读的，容易修改的。</p><p id="af22" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这就是坚实的原则派上用场的地方。它们是指导开发人员创造更好的设计和避免代码糟糕的灯塔。</p><ul class=""><li id="3f33" class="mi mj iq lk b ll md lo me lr mk lv ml lz mm lg mn mo mp mq bi translated">单一责任原则</li><li id="b3cf" class="mi mj iq lk b ll mr lo ms lr mt lv mu lz mv lg mn mo mp mq bi translated">o:开闭原则</li><li id="a506" class="mi mj iq lk b ll mr lo ms lr mt lv mu lz mv lg mn mo mp mq bi translated">李:里斯科夫替代原理</li><li id="0a38" class="mi mj iq lk b ll mr lo ms lr mt lv mu lz mv lg mn mo mp mq bi translated">I:界面分离原理</li><li id="0145" class="mi mj iq lk b ll mr lo ms lr mt lv mu lz mv lg mn mo mp mq bi translated"><strong class="lk ir"> D:依存倒置原则</strong></li></ul><p id="64b8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在本文中，我将带您了解最重要和最常用的原则之一——依赖倒置原则(DIP)。</p><h1 id="0436" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">什么是依赖？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/a490fa23dc0c85ed31fe34f0e43d5351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAdyD9Xog3Tve3jzq0nC6Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.pexels.com/@tatianasyrikova/" rel="noopener ugc nofollow" target="_blank"> Tatiana Syrikova </a>在<a class="ae kv" href="https://www.pexels.com/photo/anonymous-baby-holding-skirt-of-crop-woman-near-river-in-winter-countryside-3932883/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="1f26" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在我们讨论下降之前，首先澄清一下什么是依赖是有好处的。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e337" class="nu mx iq nq b gy nv nw l nx ny">def funcA():<br/>   funcB()</span></pre><p id="1352" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">简单来说，如果<code class="fe nz oa ob nq b">function A</code>调用<code class="fe nz oa ob nq b">function B</code>，那么<code class="fe nz oa ob nq b">function A</code>依赖<code class="fe nz oa ob nq b">function B</code>。</p><p id="0b17" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">每当<code class="fe nz oa ob nq b">function B</code>变异的时候，<code class="fe nz oa ob nq b">function A</code>就会容易发生变化，被迫重新编译。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/45979158a2e96d2928467c9af3274844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GdiU7kRmv3BrqC1bDLHSw.png"/></div></div></figure><p id="2be8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">一个典型的程序看起来如上。它从调用一些高级函数的<code class="fe nz oa ob nq b">main</code>函数开始，然后是中级和低级函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/958d0ac2c9ed8e6cc25585324e9f22bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*EhOWtIvoawe_rGUh_h_M9w.png"/></div></figure><p id="cce1" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">简单来说，依赖反转就是<strong class="lk ir">反转依赖方向</strong>。</p><p id="2997" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在我们深入研究如何做之前，让我们先讨论一下为什么要做这件事。</p><h1 id="7ac6" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">为什么蘸？</h1><p id="71fe" class="pw-post-body-paragraph li lj iq lk b ll oe jr ln lo of ju lq lr og lt lu lv oh lx ly lz oi mb mc lg ij bi translated">假设有一个应用程序查询SQL数据库并将数据输出到打印机。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/a140a3e30c62ebe354b27f429eb1c58c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULVj09-nfRJH5C2XOK5LfA.png"/></div></div></figure><p id="695e" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">处理程序查询数据，并通过调用printer函数输出数据。</p><p id="d5c0" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这个程序乍一看似乎很好，但是如果我们想</p><ul class=""><li id="47c6" class="mi mj iq lk b ll md lo me lr mk lv ml lz mm lg mn mo mp mq bi translated">从SQL数据库转换到NoSQL数据库？</li><li id="c752" class="mi mj iq lk b ll mr lo ms lr mt lv mu lz mv lg mn mo mp mq bi translated">将数据输出为WhatsApp消息而不是打印出来？</li></ul><p id="1994" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">我们将不可避免地需要编辑处理程序中的函数调用，并改变部分逻辑以确保数据兼容性。</p><p id="8247" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">更糟糕的是，如果我们有很多调用这些函数的处理程序，我们将需要编辑它们！一个简单的需求给代码库带来了巨大的变化。</p><p id="11e1" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这就是DIP出手相救的地方。</p><p id="2bf4" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">处理程序应该只关心从某处的<strong class="lk ir">检索数据，并将其输出到某处</strong>的<strong class="lk ir">。它应该对细节一无所知。</strong></p><p id="e839" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">细节不重要，就这样。</p><blockquote class="kw"><p id="e27f" class="kx ky iq bd kz la ok ol om on oo lg dk translated"><em class="lh">高层功能不应依赖于低层模块；两者都应该依赖于抽象。</em></p></blockquote><h1 id="6a85" class="mw mx iq bd my mz na nb nc nd ne nf ng jw op jx ni jz oq ka nk kc or kd nm nn bi translated">什么是DIP？</h1><p id="f4da" class="pw-post-body-paragraph li lj iq lk b ll oe jr ln lo of ju lq lr og lt lu lv oh lx ly lz oi mb mc lg ij bi translated">如前所述，DIP意味着颠倒依赖的方向。通过在调用者和被调用者之间增加一个<strong class="lk ir">稳定抽象接口</strong>来实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi gj"><img src="../Images/e077d736fbde212791d86f3439490c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwZXn4ANVPC4O70Mhy_h9g.png"/></div></div></figure><p id="d445" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">处理程序调用一个接口，而不是直接调用数据库或打印机。接口是一个策略，它定义了<strong class="lk ir">方法签名</strong>——参数和输出。</p><p id="5f48" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">处理程序在不知道细节的情况下调用接口。它只关心<strong class="lk ir">输入</strong>和<strong class="lk ir">输出</strong>，而低级功能则负责细节和实现接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi gj"><img src="../Images/e939224056c345316001cef67c4b1d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dOX35KQRDJ3fIt2yoHzSg.png"/></div></div></figure><p id="7037" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">注意，反转不仅仅是关于依赖关系，它也是关于接口所有权的。高级功能定义了接口。</p><p id="9729" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">低级功能<strong class="lk ir">的实现取决于</strong>高级功能如何定义接口。因此，依赖性是颠倒的！</p><h1 id="5c93" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">例子</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/318fff8fe68c55cee7d6ac2ec5e94ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAMnP3n9qxcAKK6njBLAXg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.pexels.com/@goumbik/" rel="noopener ugc nofollow" target="_blank">卢卡斯</a>在<a class="ae kv" href="https://www.pexels.com/photo/blue-retractable-pen-574070/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="568c" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">让我们深入一些代码片段，以便更好地理解什么是DIP。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="40c2" class="nu mx iq nq b gy nv nw l nx ny">class SqlDb:<br/>    def get(self):<br/>        print("Getting data from sql db")</span><span id="bdcd" class="nu mx iq nq b gy ot nw l nx ny">def main():<br/>    sqlDb = SqlDb()</span><span id="098d" class="nu mx iq nq b gy ot nw l nx ny">    data = sqlDb.get()</span></pre><p id="7629" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">如果没有DIP，我们定义一个<code class="fe nz oa ob nq b">SqlDb</code>类并在<code class="fe nz oa ob nq b">main</code>中直接调用它。在这种情况下，<code class="fe nz oa ob nq b">main</code>依赖于<code class="fe nz oa ob nq b">SqlDb</code>。<code class="fe nz oa ob nq b">SqlDb</code>的任何变化都可能要求<code class="fe nz oa ob nq b">main</code>的变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="bae6" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在上面的例子中，我们定义了一个指定策略的抽象类— <code class="fe nz oa ob nq b">DataInterface</code>。这意味着，类必须实现<code class="fe nz oa ob nq b">get</code>函数才能成为<code class="fe nz oa ob nq b">DataInterface</code>。</p><p id="31a8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><code class="fe nz oa ob nq b">SqlDb</code>和<code class="fe nz oa ob nq b">NoSqlDb</code>都通过具有<code class="fe nz oa ob nq b">get</code>功能来实现<code class="fe nz oa ob nq b">DataInterface</code>。</p><p id="07ad" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><code class="fe nz oa ob nq b">main</code>函数调用<code class="fe nz oa ob nq b">getDataHandler</code>来获得一个<code class="fe nz oa ob nq b">DataInterface</code>。它并不关心一只<code class="fe nz oa ob nq b">dataHandler</code>是什么。它所关心的是，<code class="fe nz oa ob nq b">dataHandler </code>必须实现一个<code class="fe nz oa ob nq b">get</code>函数并返回一组数据。</p><p id="d2ae" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">如果我们要切换到一个新的DB，比如说<code class="fe nz oa ob nq b">firebase</code>，我们只需要创建一个新的<code class="fe nz oa ob nq b">Firebase</code>类，实现<code class="fe nz oa ob nq b">get</code>函数，并在<code class="fe nz oa ob nq b">getDataHandler</code>中替换它。<code class="fe nz oa ob nq b">main</code>功能完全不受影响！</p><p id="653e" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这通常也被称为<strong class="lk ir">开闭原理</strong>。</p><h1 id="e5dc" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">优势</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/4b17410dbaed563ca67e80a676a63059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RoLK25pqE8ijJYPgSSZgA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.pexels.com/@rodnae-prod/" rel="noopener ugc nofollow" target="_blank"> Rodnae Productions </a>在<a class="ae kv" href="https://www.pexels.com/photo/a-man-driving-a-camper-van-8230948/" rel="noopener ugc nofollow" target="_blank">像素上拍摄的照片</a></p></figure><p id="3c69" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">现在，蘸酱的好处对你来说应该是显而易见的。在结束这篇文章之前，让我们先来看看一些流行的观点。</p><h1 id="8cae" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">细节上的变化不会影响业务逻辑</h1><p id="e9e6" class="pw-post-body-paragraph li lj iq lk b ll oe jr ln lo of ju lq lr og lt lu lv oh lx ly lz oi mb mc lg ij bi translated">细节易变。我们可能会随时改变我们的数据库或输出的实施。</p><p id="5e4b" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">接口比实现更不稳定</strong>。</p><p id="7fb7" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">实现的改变不一定需要接口的改变。</p><p id="a7c2" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">因此，我们可以在实现中添加更多的功能，而不会影响调用它们的业务逻辑。</p><h1 id="1d20" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">推迟关于细节的决定</h1><p id="155d" class="pw-post-body-paragraph li lj iq lk b ll oe jr ln lo of ju lq lr og lt lu lv oh lx ly lz oi mb mc lg ij bi translated">DIP允许业务逻辑对细节一无所知。因此，它为我们以后实现细节提供了更多的时间。</p><p id="dc14" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">我们等待做出这些决定的时间越长，我们就有越多的信息来做出正确的决定！</p><blockquote class="kw"><p id="3feb" class="kx ky iq bd kz la ok ol om on oo lg dk translated"><em class="lh">一个好的建筑师会最大化没有做出的决定的数量——罗伯特·c·马丁</em></p></blockquote><p id="4fe0" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc lg ij bi translated">通过一个接口，我们可以通过暂时使用本地存储来推迟我们的数据库选择。将来可以在不影响业务逻辑的情况下更改实现。</p><p id="41ca" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">好的架构师设计政策，以便关于细节的决策可以尽可能长时间地推迟和延期。</p><h1 id="42ca" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">结论</h1><p id="1772" class="pw-post-body-paragraph li lj iq lk b ll oe jr ln lo of ju lq lr og lt lu lv oh lx ly lz oi mb mc lg ij bi translated">关于依赖倒置原则就是这样！在我看来，这是5个坚实原则中最重要和最基本的概念之一。</p><p id="6be5" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">我希望这篇文章对你有所帮助，我们下次再见，再见！</p><blockquote class="kw"><p id="8e00" class="kx ky iq bd kz la ok ol om on oo lg dk translated">干净的代码总是看起来像是由关心它的人写的——罗伯特·c·马丁</p></blockquote></div></div>    
</body>
</html>