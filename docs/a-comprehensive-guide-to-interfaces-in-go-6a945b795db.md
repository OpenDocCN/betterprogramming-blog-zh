# 围棋界面综合指南

> 原文：<https://betterprogramming.pub/a-comprehensive-guide-to-interfaces-in-go-6a945b795db>

## 了解各种类型以及如何实现它们

![](img/c6488335bddb84866e4b3b83967acca6.png)

地鼠贴纸由[上田拓也](https://github.com/tenntenn/gopher-stickers)，地鼠设计由[芮妮·弗伦奇](http://reneefrench.blogspot.com/)

在围棋中，界面占据了中心舞台。它们比其他语言中的同类更灵活、更强大。当从另一种语言开始时，这一点可能并不明显，但是这种认识对于我们编写结构良好的解耦代码的能力是非常重要的。

让我们探索一下它们到底有多灵活，以及我们如何才能最好地利用它们。

## 序文

我将假设您至少对 Go 编程语言和接口有一点熟悉。在下面，我将同时提到函数和方法。它们不一样，所以你应该知道区别。此外，我将同时引用形参和实参——同样，也不是同一个。说完了，我们走吧！

# 介绍

接口支持 polymorphism⁴，也就是说，它们允许我们忽略变量的类型，而是专注于我们可以用它做什么(它通过它的方法提供给我们的行为)，我们获得了处理任何类型的能力，只要它满足接口。Go 的接口是结构类型化的，这意味着任何类型都与一个接口兼容，只要该类型与该接口在结构上等价。

如果接口和类型都定义了一组同名的方法，并且每个方法都共享相同数量的参数和相同数据类型的返回值，则它们在结构上是等效的。这与显式接口相反，显式接口必须通过实现 it⁵.的类型的名称来引用本质上，我们说类型满足接口。

当且仅当一个类型实现了一个接口描述的所有方法时，该类型才满足该接口。一个简单的例子:

代码片段 01(操场中的[示例)](https://play.golang.org/p/GlydTvXJvlP)

在这里，我们定义了一个接口`foobar`，以及两个通过实现该接口授权的两个方法来满足该接口的项目:`foo`和`bar`。

功能`doFoo`可以与`itemA`和`itemB`一起工作。一般来说，`doFoo`不会知道它收到的是`itemA`还是`itemB`类型的函数参数，也不应该关心。`doFoo`接受任何有两个方法`foo`和`bar`的东西，这意味着它可以在其参数上调用这两个方法。`itemA`和`itemB`都可以实现接口要求之外的其他方法，但是`doFoo`看不到它们，也不能调用它们。至少在它对参数`item`一无所知时不会。但是正如我们将看到的，我们可以尝试类型和接口转换来扩展我们对接口值所能做的限制。

以下特点值得强调:

1.  `itemA`和`itemB`都实现(满足)`foobar`，因此可以在任何接受`foobar`的地方互换使用。
2.  我们可以发明一种新型的`itemC`(或者我们想叫它什么都行)，只要`itemC`也满足`foobar`的要求，`doFoo`就可以不加修改地使用。
3.  `doFoo`接受任何实现`foo()`和`bar()`的参数，因此可以在这些类型上调用这两个方法。
4.  接口只规定一个类型必须实现哪些方法，而不是它们做什么。实现所有强制方法取决于每种类型。
5.  除了规定必须实现哪些方法，接口还规定了它们的参数和返回值应该是什么样子。

最后一点值得探讨一下。这里有两个在各方面都相同的界面:

代码片段 02

同样，这两个接口是相同的。它们都定义了相同的四个方法，采用相同类型的相同参数，并且顺序相同。与此无关的是，`alsoStudent`接口交换了最后两个方法的顺序，并且它包含了方法参数的名称。为什么？因为当 Go 的编译器需要确定某个类型是否在结构上等同于接口时，这并不重要。

也就是说，`alsoStudent`对于其他开发人员来说可读性更强，因为我们已经为每个参数添加了一个名称，所以这样做通常更好。最后，参数名不必与实现中的对应项匹配，但是没有理由因为不匹配而让我们的编码人员感到困惑。

> “抽象的目的不是模糊，而是创造一个新的语义层次，在这个层次上，人们可以绝对精确。”埃德格·w·迪杰斯特拉

# 隐式和结构类型化

当我第一次接触 Java 中的接口时，它们似乎马上就有用了，因为它们允许多态性，而不像 C++那样要求每种类型都从同一个基类继承。但是它们也奇怪地僵化，并且受限于你自己的代码库。直到我拿起 Go，我才意识到 Go 的界面支持要优雅灵活得多。Go 的接口是隐式的，结构上是 typed⁶的，这使得它们非常强大。让我们看一个 Java⁷:的(简化的)例子

代码片段 03

`Car`必须明确声明它“实现了`Vehicle`”这意味着我们自己的接口只对我们自己的代码库起作用。而在围棋中，则没有这样的限制。上面的例子在 Go 中是这样的:

代码片段 04

如果`Car`是在第三方包中定义的(在我们的直接控制之外)，`Vehicle`仍然可以在我们自己的代码库中任何可能接受`Car`的地方使用。在 Java 中，我们必须首先编写一个实现接口的类，并通过包装该类的每个方法来包装第三方包的类型，并调用包装类型的相应方法，就像在装饰设计 pattern⁸.中一样

# 界面兼容性

如果 Go 的接口是隐式的，即一个类型不需要声明它必须满足接口，那么我们如何知道该类型是否满足接口？和 Java 一样，Go 的编译器会为我们检查它们。让我们看两个场景:

代码片段 05(示例在[游乐场](https://play.golang.org/p/GnyHatMXNgG)中)

在 main 的第一行，我们创建了一个新的`acmeToaster`。在第二行中，我们将`acmeToaster`传递给`doToast`。`doToast`接受`toaster`类型的参数。Go 可以在编译时检查`acmeToaster`是否满足`toaster`。但是，在第三行，我们将`acmeToaster`传递给`maybeDoToast`，它带有一个空的接口参数。`maybeDoToast`里面的接口转换是运行时检查，可能会失败。这里的要点不是检查可能会失败，而是问问你自己，如果`acmeToaster`只在这些运行时检查中使用，我们如何确定`acmeToaster`满足`toaster`？

您可以编写一个单元测试来检查它，但是有一种更快、更好的方法来强制进行编译时检查，从而允许我们更早地发现问题:只需将自定义类型的空值赋给接口类型的未使用变量。

如果这没有意义，那就继续读下去。在 Go 中，如果一个变量未被使用，编译器会很快报错，但是如果我们给一个名为`_`(下划线)的变量赋值，编译器不会报错，因为这个特殊的变量是专门用来丢弃未使用的值的。我们还可以用它来检查一个类型在编译时是否满足一个接口，而不会导致不必要的分配，就像这样:

代码片段 06

这在 Go 中很常见，这是检查接口兼容性的一种简单方法。

# 空界面

如果我们定义了一个没有方法的接口，我们会得到什么？空界面:

代码片段 07

空接口没有要求，因此我们可以将任何东西赋给这种类型的变量或参数。这也意味着我们失去了类型安全。因为我们不知道我们得到了什么，我们不能对它做任何假设。当然，如果我们总是知道我们传递的是什么，那么我们可以假设一个类型并强制进行类型转换。但是程序会改变，今天有效的可能明天就会崩溃。空界面什么都不说，应该避免，除非在极少数情况下，我们真的不知道我们在接收什么。

> “空界面什么都没说。”—罗布·派克

即使当我们与第三方 API 交互时，我们也会对响应和解组有某种期望，例如，从 JSON 到带有一些期望字段的自定义类型。JSON 解组本身是一个完整的主题，超出了这篇博客的范围。

空接口很难推理，但并非完全不安全。诀窍是不要对它们做任何假设，并且每一步都要检查它们。与常规接口一样，空接口可以转换为自定义类型和命名接口。这里有一个例子:

代码片段 08 ( [操场](https://play.golang.org/p/rteP0INrlEq)中的示例)

在 main 的第一行，我们知道我们有一个`attacker`。然而，在第二行，我们调用了`attackOrDefend`，它接受了一个`interface{}`类型的参数。因为我们不知道我们在函数里得到了什么，我们必须检查。

在 main 的第三行，我们用一个无效的参数调用了`attackOrDefend`——除了技术上它不是真正无效的，因为在 Go 中任何东西都满足空接口。然而，参数“Hello”不是我们所期望的类型。我们可以根据具体情况，通过返回错误或忽略错误来处理这种情况。这里我们做的是后者。

当处理多个没有共同点的不同类型(即没有共享方法)时，有时会使用空接口。随着 Go 1.18 中引入[泛型，我们应该会看到更少的空接口用例，尽管它不会完全消失。](https://github.com/golang/go/issues/43651)

# Nil 接口

接口有一个基础类型。接口表示一组方法，可以在满足该接口的任何给定类型上调用这些方法。但是为了让运行时能够对接口值执行方法调用，实际值必须可以从接口本身到达。

例如，在前面关于接口兼容性的章节中，我们有一个接口`toaster`被`acmeToaster`满足了:

代码片段 09

将`acmeToaster`赋值给`toaster`时(就像将它作为一个变量传递给使用`toaster`参数的函数时一样):

代码片段 10

然后`doToast`收到一个`toaster`类型的接口值，但是底层类型是`acmeToaster`。基于我们代替接口提供的值，底层类型总是变化的。每当运行库需要检查一个接口值是否与另一个接口兼容，或者需要检查一个接口是否可以转换为特定类型时，它都会引用基础类型。

当我们检查`nil`值时，这变得很重要。原因是接口值本身可以是`nil`，或者底层类型可以是`nil`。在第一种情况下，`nil`意味着没有底层类型分配给接口。在第二种情况下，意味着有一个底层类型，但是那个值本身就是`nil`(比如一个指针或者一个未初始化的片)。

让我们来看看一个棘手的案例:

代码片段 11 ( [操场中的示例](https://play.golang.org/p/017t8TDHVts))

即使`myError`明确满足了`error`接口，并且`doSomething`明确返回了`nil`的位置，我们仍然得到“我们收到了一个错误！”。为什么？因为我们已经将`*myError`赋给了变量`err`，它是一个接口类型。所以我们实际上是在检查接口值是否是`nil`，而它不是。`err`被赋了一个底层类型(`*myError`，所以不能是`nil`。

但是，底层类型的值是`nil`。解决方法如下:

代码片段 12 ( [操场](https://play.golang.org/p/j_CeQC75rYe)中的示例)

我们已经将`doSomething`的返回类型从`*myError`更改为`error`。基本上，我们现在返回的是接口值`nil`而不是`nil *myError`。

界面就像一个盒子。盒子可以是空的(`nil`)，但也可以装一个物品。因为项目可以是任何东西，所以项目也可以是空的(`nil`)。

那你怎么检查盒子里的项(底层类型)是不是`nil`？这就是事情变得复杂的地方。您可以[通过反射或各种类型的类型化 nils](https://codefibershq.com/blog/golang-why-nil-is-not-always-nil) 进行检查。事实上，没有一种简单的方法可以覆盖你的所有基础，这是 Go 社区一段时间以来争论的焦点。查一下[这个语言提案](https://github.com/golang/go/issues/22729)，比如一直追溯到 2017 年，现在还在争论。

作为对这个问题的结束语，我将引用 Go 核心团队成员伊恩·兰斯·泰勒的话:

> “Go 在一个为零的接口和一个拥有某个类型的值的接口之间做了一个清晰而必要的区分。”伊恩·兰斯·泰勒

更具体地说，Go 允许我们调用`nil`指针上的方法，如果类型实现为支持它的话。因此，在不知道`nil`值是什么类型的情况下，检查它的底层类型可能没有多大价值？

一般来说，最好采取措施确保接口的底层类型永远不会是`nil`，或者它们与`nil`指针接收器一起工作良好。

# 作为值的接口

接口不是具体的值。它们更像是一个契约，规定我们可以使用我们喜欢的任何值，只要该值满足接口。因此，使用接口作为指针是没有意义的。采用接口参数的函数可以接收指针或离散(非指针)值作为基础类型。对这种参数调用方法在两种情况下都有效。接口不能是指针([技术上可以](https://stackoverflow.com/questions/27178635/cast-a-struct-pointer-to-interface-pointer-in-golang)，但实际用途有限)。

在下面的例子中，`cat`和`dog`都满足`speaker`接口，尽管`cat`通过一个指针接收器来实现，而`cat`通过一个值接收器来实现。尽管在实现上有所不同，函数`doSpeak`能够在两个参数上不加区别地调用`speak`。

代码片段 13 ( [操场](https://play.golang.org/p/rWXAQSFMvqn)中的示例)

但是当我们想把一个接口参数转换成一个具体的类型时，这就很重要了。如果到目前为止您已经密切关注了这些示例，那么您应该已经知道如何设置检查值和指针的类型转换。

# 保持界面小

> "客户不应该被迫依赖他们不使用的方法."罗伯特·马丁

在任何给定的情况下，Go 中的接口不必比我们需要的大。这是一个虚构的角色扮演游戏的例子:

代码片段 14 ( [操场](https://play.golang.org/p/igjkbZJ28SR)中的示例)

> "界面越大，抽象性越弱."—罗布·派克

尽管这是可行的，函数`getStatus`只接受有两个方法的参数:`status`和`sleep`。强迫它要求这两种方法可能是不必要的，而且所需的额外方法`sleep`会使`getStatus`更难测试(模拟更多的方法)和更难用有效类型调用。假设我们引入了一个新类型，我们也想获得它的状态，如下所示:

代码片段 15

但是`sword`不是`character`，为`sword`提供一个`sleep`方法没有什么意义，这将是它与`getStatus`函数一起工作的一个要求。这是个问题。因此，最好总是使用仍然有意义的用例的尽可能最小的接口。这是一种安全的方法，因为我们总是可以在以后通过组合来组合接口。

# 界面组成

Go 支持组合接口，即从一个或多个其他命名接口构造一个命名接口。注意，组成接口与继承无关。这是一种通过组合重用较小接口来创建较大接口的方法。这对于避免共享公共行为的类型的不必要的运行时转换特别有用。

为了演示，我将避开平凡的`ReadWriteCloser`例子，而是继续之前的电脑游戏例子。想象一下拥有共同特征或行为的各种武器的实现。我们定义了两个涵盖近战和远程武器的接口:`meleeWeapon`和`rangedWeapon`。此外，由于所有武器都可以装备/不装备，我们可以定义一个单独的接口`equippable`来描述这种行为，并将其嵌入到`meleeWeapon`和`rangedWeapon`中，如下所示:

代码片段 16

如果我们没有以这种方式嵌入`equippable`，我们将不得不在每次想要装备或不装备武器时执行一次运行时接口转换，这是一项乏味且重复的工作。通过嵌入`equippable`，我们确保`meleeWeapon`和`rangedWeapon`获得了它的两种方法。

注意:如果你想知道如果一个接口嵌入了另外两个包含相同方法签名的接口会发生什么(例如，它们互相重叠)，那么答案是这将是一个错误，直到 Go 1.14 中重叠的接口是 permitted⁹.

# 界面转换

接受接口参数的函数或方法不限于该接口上定义的方法。通常，我们可以用接口参数做三件事:

1.  调用定义为其接口一部分的任何方法
2.  将其转换为一种类型
3.  将其转换为另一个界面

我们已经讨论了第一项。让我们更深入地看看另外两个。

## 转换成一种类型

当一个值被表示为一个接口时，Go 的运行时仍然知道底层的类型。当运行库需要确定接口值是否可以转换为另一个接口或特定类型时，这是必要的信息。下面是一个简单的类型转换示例:

代码片段 17(操场中的[示例)](https://play.golang.org/p/CA3lrrs9Wk-)

从接口到类型的转换发生在`isCar`的第一行。这是因为运行时知道`v`是一个`*car`。毕竟我们在`main`的第一行给`v`赋值了一个`*car`(指向一个`car`的指针)。要做到这一点，我们需要知道底层类型是否是指针。如果你不确定，你可以测试这两种情况…只是不要把指针转换成离散值，除非你知道你在做什么，因为你将失去修改它所指向的值的能力。

了解类型转换的后果很重要。一旦我们将接口类型(`vehicle`)转换为`*car`，我们就不再使用任何车辆，而是使用特定的`vehicle`。在转换的范围内，我们失去了多态性。

从这一点开始，我们根据车辆类型对逻辑进行分支的代码部分——即，如果我们有一个`car`，则执行 A，如果我们有一个`bus`，则执行 B，等等。—变得不稳定。它今天可以工作，但是如果我们明天在代码库中引入一辆新车(比如说一辆`truck`)，我们将需要手动找到并更新这些易变的部分，并确保在代码返回到可靠的操作状态之前，我们在每种情况下都能准确地处理`truck`。

> “适当的抽象将代码解耦，这样每个变化就不会在整个代码库中回响。”—罗娜·斯坦堡

## 转换到另一个界面

类型断言还可以将一个接口转换成另一个接口，这是一个强大的特性。Go 的运行时将检查底层类型是否满足我们希望转换到的接口，并让我们知道转换是否可能。这里有一个例子:

代码片段 18 ( [操场](https://play.golang.org/p/HO42Wmyi-tu)中的示例)

这已经很好了，但是我们还可以动态地检查某些方法的可用性。这并不奇怪，也没有什么复杂的，因为我们是通过匿名接口实现的。下面是上面例子的一个变体:

代码片段 19 ( [操场](https://play.golang.org/p/1F5voE2u63X)中的示例)

虽然激动人心的部分——常规的`car`到`BatMobile`的实际转换——已经被忽略了，但是这个例子应该展示 Go 的结构类型化接口的强大和灵活性。

最后，类型开关可以用于接口，甚至匿名接口！这里有一个例子:

代码片段 20 ( [操场中的示例](https://play.golang.org/p/93ggk5Nacu0))

在每个`case`语句的范围内，我们已经断言`v`满足我们正在检查的接口，这使得方法调用有效。

# 界面嵌入

结构可以嵌入接口，这类似于类型嵌入。但是我们可以嵌入任何满足接口的类型，而不是具体的类型。这是我们角色扮演游戏中的一个例子:

代码片段 21 ( [操场上的例子](https://play.golang.org/p/TKpKSRpiGOX))

在这个例子中，`persona`接口嵌入在`player`中。`dwarf`和`wizard`都满足`persona`接口。因此，这两种类型都可以嵌入`player`(并可互换)。这种嵌入形式对于由独立的和可互换的部分组成更大的结构特别有用。

如果我们创建了一个`player`但是省略了嵌入一个`persona`会发生什么？事实证明，这仍然有效，但是方法调用被视为有一个`nil`指针接收器，当我们试图调用一个未实现的方法时，它会出现混乱:

代码片段 22 ( [操场上的例子](https://play.golang.org/p/dVuLYbKIFQS))

有趣的是，事实证明，一个类型可以嵌入一个接口，从而满足一个接口，即使实际上只实现了那些方法的一个子集。这对于我们只测试特定功能的模拟很有用。例如，知道函数`summarize`只使用其接口类型`calculator`的参数`calc`的`add`方法，我们可以用只实现`add`方法的`calculator`的模拟来测试它:

代码片段 23 ( [操场](https://play.golang.org/p/LA2mxhQP8mY)中的示例)

然而，调用任何其他方法(`sub`、`div`、`mul`)都会出错，所以这种技术可能只用于单元测试，而不是产品代码。不过，对于编写模拟来说，它可能非常有用。

另一个有趣的用例来自优步的日志包 Zap，其中接口用于扩展现有功能，方法是将一个`Core`结构包装在一个嵌入了`Core`接口的结构中，然后实现必要的方法来提供向核心数据类型添加挂钩(函数回调)的新功能。正如我们将看到的，没有必要包装所有的接口方法。那些没有被包装器类型重新定义的方法只是暴露了嵌入的`Core`类型的方法。

代码片段 24 —引用⁰

为了简洁起见，原始源代码中的注释和实现细节被省略了，但是如果您对这些方法是如何实现的感到好奇，请随意访问 GitHub 上的公共存储库。

`RegisterHooks`接受一个`Core`类型的参数，这是 core.go 中定义的接口。`RegisterHooks`然后创建一个函数片(使用可变函数参数)并将它们存储在`hooked`中，这个结构嵌入了`Core`接口并重新定义了一些`Core`方法，以便利用钩子函数(未显示)。

请注意来自`Core`接口的`Sync`错误方法从未被重新定义。这是完全正确的。如果我们调用它，由于方法提升，它是被调用的嵌入类型的`Sync`方法。这是非常聪明和强大的。它还表明，单个类型不一定要自己满足一个接口；我们可以组合不能单独满足接口要求的类型，但是一旦它们组合在一起就可以了。

查看来自 Ardan Labs 的[这篇文章](https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html)了解更多关于这是如何工作的细节。

# 部分导出的接口

未导出的接口(首字母小写)只能从自己的包中引用。导出的接口可以从其他包中引用，但是包含导出和未导出方法的导出接口怎么办？

以接口`School`为例:

代码片段 25

类型`University`旨在满足接口`School`，但未能满足。不可能满足`School`，因为它包含一个未导出的方法，`students`。示例最后一行中给出的错误如下:

代码片段 26

基本上，这意味着我们可以在包`school`中实现接口`School`，但是由于未导出的方法，不能在包`schools`中实现。

那么，部分导出接口的用例是什么呢？让我们试试嵌入接口`School`:

代码片段 27

只要我们不试图重新定义方法`students`，这就可以工作。

因此，通过定义一个包含未导出方法的接口，我们可以保证任何想要满足该接口的类型都不会重新定义这些方法。本质上，我们强制实现嵌入由我们自己的包导出的类型，并且对这样一个方法的任何调用将总是由我们自己的包的实现在内部处理。

如果您决定使用这个技巧，那么值得强调的是，实现也不能调用未导出的方法。只有您自己的代码可以做到这一点。因此，部分导出的接口主要是一种机制，用于确保您自己的包提供一些有用的方法供内部使用。您的包的外部用户可以引用该接口，但不能将其嵌入到他们自己的类型中。

# 应用界面

当在代码库中应用接口时，获得正确的方法参数可能会很棘手。对我来说是这样——至少在我意识到我需要在围棋中用不同的方式思考它们之前是这样。

为了处理不同实现之间不同的接口方法，我们不得不彻底改变这个概念。

例如，考虑一个通过 ID 从数据库加载各种实体的接口`EntityLoader`。该接口被用作抽象存储库实现之间差异的一种方式(每个实体一个)。

初稿可能是这样的:

代码片段 28

这个不太管用。我们失去了类型安全，我们必须手动将第一个返回值转换成正确的实体，无论它是`User`、`Address`、`PurchaseOrder`还是其他。为了获得所有事物的准确类型，我们可以这样做:

代码片段 29

这完全违背了接口的目的。更糟糕的是，每个存储库需要实现所有三个方法，并为未实现的两个方法返回一个错误。

我们需要认识到，方法接收者不是接口契约的一部分，因此，它是处理可变部分的一个很好的候选者。为了实现这一点，repository 方法可以接受一个命名的接口值，该接口值可以由任何类型实现。

让我们试一试。我们将调用新的接口`Hydrater`,因为它的参数是一个数据库行，并且它必须通过用该行中各自的列填充/合并各个字段来实现:

代码片段 30

看看实体`User`的实现:

代码片段 31

就是这样，我们可以这样使用它:

代码片段 32

从而避免了这种丑陋:

代码片段 33 ( [操场中使用自定义行和扫描方法](https://play.golang.org/p/Xd1_iVzS1yA)的示例)

注意我们如何颠倒了`UserRepository`和`User`之间的关系。我们不再依赖存储库来填充/水合`User`，而是授权`User`基于一些公共参数来水合自身。

在这种情况下，我使用了 Go 标准库中的`database.Row`(我们可以在 Reddit 上讨论的`Scan` on — [，如果需要的话，这种抽象可以更进一步，以消除对数据库行的依赖)，但这种方法通常应该工作得很好，并且您会发现它在 Go 标准库中被大量使用。](https://www.reddit.com/r/golang/comments/pfwj78/comment/hb9rz7v/?utm_source=share&utm_medium=web2x&context=3)

一些例子是 [json。解组编码包中的](https://pkg.go.dev/encoding/json@go1.17#Unmarshal)和[行。扫描数据库包中的](https://pkg.go.dev/database/sql@go1.17#Rows.Scan)。尽管这两种方法都将参数作为空接口，但是我们自己声明变量并传递它，这样就不需要我们在方法调用后进行接口转换。

这可能需要一点尝试和错误来得到这个概念，但它在实践中工作得很好。

# 结论

Go 中的接口是隐式的，并且是结构化类型的。正如我们已经看到的，它们也非常通用。空接口匹配任何东西，非空接口可以转换为特定类型和命名接口，也可以转换为匿名接口和具有不同结构的专用接口。

接口有一个基础类型。它们的值可以是指针，也可以是离散值。无需完全实现它们的方法就可以组合和使用它们。它们也可以由几个不同的类型来满足，每个类型只满足接口的一部分，但合在一起可以完全满足接口。

为了充分理解它们的用处，认识到 Go 应用的接口与我们习惯的其他语言的接口有些不同可能是有用的。

我希望你在阅读这篇文章的过程中感到有趣，甚至可能学到一些东西。

这篇文章最初发表在我的个人博客上。

# 参考

1.  [https://golangbyexample . com/difference-between-method-function-go/](https://golangbyexample.com/difference-between-method-function-go/)
2.  [https://stack overflow . com/questions/155609/方法和功能有什么区别](https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function)
3.  [https://stack overflow . com/questions/1788923/parameter-vs-argument](https://stackoverflow.com/questions/1788923/parameter-vs-argument)
4.  [https://en . Wikipedia . org/wiki/Polymorphism _(computer _ science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
5.  [https://en.wikipedia.org/wiki/Structural_type_system](https://en.wikipedia.org/wiki/Structural_type_system)
6.  [https://en . Wikipedia . org/wiki/Go _(programming _ language)# Interface _ system](https://en.wikipedia.org/wiki/Go_(programming_language)#Interface_system)
7.  [https://www . freecodecamp . org/news/Java-interfaces-explained-with-examples/](https://www.freecodecamp.org/news/java-interfaces-explained-with-examples/)
8.  [https://www.javatpoint.com/decorator-pattern](https://www.javatpoint.com/decorator-pattern)
9.  [https://go . Google source . com/proposal/+/master/design/6977-overlapping-interfaces . MD](https://go.googlesource.com/proposal/+/master/design/6977-overlapping-interfaces.md)
10.  [https://github . com/Uber-go/zap/blob/master/zap core/core . go # L25](https://github.com/uber-go/zap/blob/master/zapcore/core.go#L25)
11.  [https://github.com/uber-go/zap/blob/master/zapcore/hook.go](https://github.com/uber-go/zap/blob/master/zapcore/hook.go)
12.  [https://golangdocs.com/variadic-functions-in-golang](https://golangdocs.com/variadic-functions-in-golang)

# 其他资源

*   [https://golangbyexample . com/Interface-in-golang/# Inner _ Working _ of _ Interface](https://golangbyexample.com/interface-in-golang/#Inner_Working_of_Interface)
*   [https://www . tapir games . com/blog/golang-interface-implementation](https://www.tapirgames.com/blog/golang-interface-implementation)
*   [https://golangbot.com/interfaces-part-1/](https://golangbot.com/interfaces-part-1/)
*   [https://golangbot.com/interfaces-part-2/](https://golangbot.com/interfaces-part-2/)
*   [http://www.hydrogen18.com/blog/golang-embedding.html](http://www.hydrogen18.com/blog/golang-embedding.html)