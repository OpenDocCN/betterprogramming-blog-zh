<html>
<head>
<title>RxSwift, Observables, and Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift、可观察数据和核心数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxswift-observable-and-core-data-55ab87fc02ea?source=collection_archive---------4-----------------------#2020-02-16">https://betterprogramming.pub/rxswift-observable-and-core-data-55ab87fc02ea?source=collection_archive---------4-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b605" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建从核心数据到用户界面的连续信息流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e6c00fda1a330000cc68e69bdee0318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUsxVRtmD8j23AjcnyJJ7g.jpeg"/></div></div></figure><p id="8f7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多iOS应用程序最常见的一些用例是显示存储在核心数据中的对象。这个问题有很多解决方法，<em class="lq"> </em>和<em class="lq"> </em>有些真的挺好的。然而，我宁愿用函数方法来解决这个问题。</p><p id="9c01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，我们希望更新我们的用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/ee65a9c82fe5f72751f6e6b2fedfbc2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZWls773dc3l3wECB2YZY9g.gif"/></div></div></figure><ul class=""><li id="d9c0" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">当数据库项更改时。</li><li id="3678" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">当我们向数据库添加新项目时。</li><li id="b0ac" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">当我们从数据库中删除项目时。</li></ul><p id="e9df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">苹果为我们提供了<a class="ae mg" href="https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller" rel="noopener ugc nofollow" target="_blank">NSFetchedResultsController</a>，它的工作做得相当不错。但是真的显老了。</p><p id="f09f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，我希望有一个可观察对象，它能给我当前存储的对象，并在任何更新发生时发送新的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/d04b7bef2e941848522319481a4c4486.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*nmpTzvKZMpODG1EWi46MEw.png"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b2f2" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">解决办法</h1><p id="33eb" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">我把我对这个问题的解决方案命名为<code class="fe nm nn no np b">CDObservable</code>。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="e145" class="nu mq it np b gy nv nw l nx ny"><strong class="np iu">class</strong> CDObservable&lt;T&gt;: ObservableType <strong class="np iu">where</strong> T: NSManagedObject</span></pre><p id="e035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个名为<code class="fe nm nn no np b">Customer</code>的核心数据实体:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/870267dbd230bd993e6e9f8c7ef0afb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*ZJ6T6MzHZ98IVVVDH6jfeA.png"/></div></figure><p id="1f76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将用一个<code class="fe nm nn no np b">FetchRequest</code>和一个<code class="fe nm nn no np b">NSManagedObjectContext</code>初始化我们的<code class="fe nm nn no np b">CDObservable</code>，并用一个<code class="fe nm nn no np b">BehaviorSubject</code>向所有订户发送值。</p><p id="a5ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码的工作方式如下:</p><ol class=""><li id="ec5e" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp oa ly lz ma bi translated">当第一个观察者订阅这个可观察对象时，就会创建一个<code class="fe nm nn no np b">NSFetchedResultsController</code>,它给出的每个结果都会被发送给这个观察者。</li><li id="279e" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp oa ly lz ma bi translated">如果另一个观察者订阅，它将使用相同的<code class="fe nm nn no np b">NSFetchedResultsController</code>来获得结果。</li><li id="0051" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp oa ly lz ma bi translated">当所有观察者都放弃他们的订阅时，<code class="fe nm nn no np b">NSFetchResultController</code>被释放。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="3913" class="nu mq it bd mr od oe dn mv of og dp mz ld oh oi nb lh oj ok nd ll ol om nf on bi translated">从这里做什么</h2><ul class=""><li id="e9d0" class="ls lt it kw b kx nh la ni ld oo lh op ll oq lp lx ly lz ma bi translated">使用<code class="fe nm nn no np b">RxDataSources</code>填充一个<code class="fe nm nn no np b">tableView</code>:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="0235" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">使用不同的数据源更新您的<code class="fe nm nn no np b">tableView</code>:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="ff8a" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">你也可以使用传统的<code class="fe nm nn no np b">reload()</code>方法更新你的<code class="fe nm nn no np b">tableView</code>，但是我不推荐这样做。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="80c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我有一个与Swift Combine类似的解决方案，但那是另一个作品。快乐编码。</p></div></div>    
</body>
</html>