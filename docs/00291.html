<html>
<head>
<title>Find the Most Frequently Occurring Element in an Array With Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby查找数组中出现频率最高的元素</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-ways-of-finding-the-element-that-occurs-the-most-in-an-array-with-ruby-7fb484ea1a6d?source=collection_archive---------1-----------------------#2019-02-20">https://betterprogramming.pub/two-ways-of-finding-the-element-that-occurs-the-most-in-an-array-with-ruby-7fb484ea1a6d?source=collection_archive---------1-----------------------#2019-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c4fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迭代数组的两种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d6d76969afb7a820d50d59574d1e7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfT5f1rbVB-qidTQavpHPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clemono2?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克莱姆·奥诺杰霍</a>在<a class="ae ky" href="https://unsplash.com/search/photos/smarties?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的文章中，我将讨论一个对数组进行操作的特定任务，这个任务对我来说有点有趣，我喜欢它。这也体现了Ruby的想法，即执行一项任务有多种方式，单一的一种方式是不正确的。这难道不是一个非常令人接受的观点吗？</p><p id="c9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，我已经多次遇到一个任务，它要求我迭代一个数组，目的是试图选择在那个数组中出现最多的元素。我将讲述一个有趣的例子。</p><p id="e155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡罗尔是一个动物囤积者。她就是控制不住自己。她遇到的任何流浪狗，她都要带回家。这确实是个问题。</p><p id="280c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这成了一个问题，动物控制中心告诉她，她需要记录她有哪些宠物，因为她必须处理掉其中一些动物。她住在一个一居室的公寓里！</p><p id="f091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">她决定扔掉她最喜欢的一只宠物。但是这么多，她又不想用手数。</p><p id="2cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是卡罗尔的宠物阵列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="517c" class="ma mb it lw b gy mc md l me mf">pets = [ “dog”, “dog”, “cat”, “bird”, “chinchilla”, “rat”, “hampster”, “dog”, “rat”, “bird”, “cat”, “giraffe”, “cat”, “bird”,”dog”, “snake”, “hamster”, “dog” , “mouse”, “spider”, “dog”, “cat”]</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="49b6" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">方法一。</h1><p id="1b0e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我将使用的第一种方法是将数组转换成带有值的散列。我们假设您了解如何设置hash的键和值。这个方法所做的是遍历数组，将数组中的一个元素设置为哈希的键，并且对于每个元素的出现，将其值增加1。因此，如果它遇到散列中已经存在的宠物，它会将该宠物的值加1，同时保持密钥的唯一性。</p><p id="fbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是第一种方法的样子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0a7a" class="ma mb it lw b gy mc md l me mf">pet_count = Hash.new(0)<br/>pets.each {|pet| pet_count[pet] += 1}<br/>pet_count.sort_by { |pet,number| number}.last[0]</span></pre><p id="f186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微分解一下。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="497e" class="ma mb it lw b gy mc md l me mf">pet_count = Hash.new(0)<br/>#creates a new hash, sets its default values to 0.</span><span id="afd4" class="ma mb it lw b gy nj md l me mf">pets.each {|pet| pet_count[pet] += 1}<br/>#iterates each element, sets our empty hashes key to that of a pet. # “+=“ is the operator on the value of a keys occurrence in the hash.</span></pre><p id="f168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如第一次迭代:<code class="fe nk nl nm lw b">pet_count = {“dog” =&gt; 1 }</code>。这是第一次出现“狗”)</p><p id="8cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的第二次迭代在我们的hash中包含了一个键的相同元素，那么它将那个键的值加1，同时保持键的唯一性，这就是所发生的情况。(例如第二次迭代:<code class="fe nk nl nm lw b">pet_count = {“dog” =&gt; 2}</code>。这是第二次出现“狗”)</p><p id="a634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第三次迭代设置了一个新的键和一个新的值，因为我们的<code class="fe nk nl nm lw b">carols_pets</code>数组中的下一个元素对我们的散列来说是新的。我们的散列不包含“cat”的键，所以创建了一个新的键，并自动将值设置为1。现在我们的<code class="fe nk nl nm lw b">pet_count = {“dog”=&gt;2, “cat”=&gt; 1}</code>。</p><p id="cbae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说这是美丽的。它涉及到迭代和散列创建的结构，以及块中的键和值设置。如果您是操作数组和散列的新手，这是一个很好的分析方法。查看结果也很满意。这是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e1ac" class="ma mb it lw b gy mc md l me mf">pet_count = {“dog"=&gt;6, "cat"=&gt;3, "bird"=&gt;3, "chinchilla"=&gt;1, "rat"=&gt;2, "hamster"=&gt;2, "snake"=&gt;1, "mouse"=&gt;1, "spider"=&gt;1}</span></pre><p id="ab3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们的散列不太整齐。</p><p id="a815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以使用下面的方法对这个散列进行操作，以返回最常出现的pet。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a9d3" class="ma mb it lw b gy mc md l me mf">pet_count.sort_by{|pet,number| number}.last[0]<br/>#hash gets sorted by number</span></pre><p id="93aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们稍微分解一下:</p><p id="c364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm lw b">.sort_by</code>是哈希方法，块是哈希排序的依据(宠物出现的次数)。</p><p id="c45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只是跑:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bed3" class="ma mb it lw b gy mc md l me mf">pet_count.sort_by {|pet,number| number}<br/>#returns <br/>[["snake", 1], ["spider", 1], ["mouse", 1], ["chinchilla", 1], ["rat", 2], ["hamster", 2], ["bird", 3], ["cat", 3], ["dog", 6]]</span></pre><p id="5782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法对整数的默认排序是从低到高，所以实际上最后一个键值对是最常见的。你所要做的就是调用方法“last”</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39e5" class="ma mb it lw b gy mc md l me mf">pet_count.sort_by{|pet,number| number}.last<br/>returns [“dog”=&gt; 6]</span></pre><p id="19c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你所要做的就是加上[0]，它对一个数组索引号进行操作。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="231e" class="ma mb it lw b gy mc md l me mf">pet_count.sort_by{|pet,occurrences| occurrences}.last[0]<br/>returns "dog"</span></pre><p id="a975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走吧。我们有最受欢迎的宠物。虽然有点冗长复杂。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b13f" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">方法二。</strong></h1><p id="e7e7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这个要短得多，给出了您需要的确切答案，并且不需要您将数组转换成散列。这也很好。如果我只想归还最常出现的宠物，我可能会从现在开始使用它。</p><p id="ed63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们的卡罗尔宠物系列吗:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7578" class="ma mb it lw b gy mc md l me mf">pets = [ “dog”, “dog”, “cat”, “bird”, “chinchilla”, “rat”, “hamster”, “dog”, “rat”, “bird”, “cat”, “giraffe”, “cat”, “bird”,”dog”, “snake”, “hamster”, “dog” , “mouse”, “spider”, “dog”, “cat”]</span></pre><p id="01a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="21f5" class="ma mb it lw b gy mc md l me mf">pets.max_by {|i| pets.count(i)}</span></pre><p id="23f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事？方法中的方法。方法的起源。</p><h2 id="fb34" class="ma mb it bd mo nn no dn ms np nq dp mw li nr ns my lm nt nu na lq nv nw nc nx bi translated"><strong class="ak">什么。max_by does </strong></h2><p id="580b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">它返回最大值的对象。如果我们想查看哪种动物的名字最长，我们可以使用:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c3bf" class="ma mb it lw b gy mc md l me mf">pets.max_by{|pet| pet.length}<br/>returns "chinchilla"</span></pre><p id="1d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪个是名字最长的宠物？</p><p id="9f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b665" class="ma mb it lw b gy mc md l me mf">chinchilla.length = 10</span></pre><p id="f601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm lw b">.max_by</code>返回对象。</p><h2 id="1c2f" class="ma mb it bd mo nn no dn ms np nq dp mw li nr ns my lm nt nu na lq nv nw nc nx bi translated"><strong class="ak">什么。计数※</strong></h2><p id="d679" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">不言自明:它计算数组中的项数。如果我们这样做，它将返回数组中的项数，20。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c94" class="ma mb it lw b gy mc md l me mf">pets.count = 20</span></pre><p id="35eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们给它一个参数，比如<code class="fe nk nl nm lw b">pets(“cat”)</code>，它会返回猫在数组中出现的次数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e8d1" class="ma mb it lw b gy mc md l me mf">pets(“cat”) = 4</span></pre><p id="2a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用下面的方法时，我们只是简单地结合了这些方法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="46ba" class="ma mb it lw b gy mc md l me mf">pets.max_by{|pet| pets.count(pet)} </span></pre><p id="0316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道一个宠物对象将被返回，用<code class="fe nk nl nm lw b">max_by</code>，数组中的每个宠物都用<code class="fe nk nl nm lw b">pets.count(pet)</code>计数。每个元素都被迭代和计数，然后<code class="fe nk nl nm lw b">max_by</code>挑选出计数最高的对象——也就是“狗”</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2d1d" class="ma mb it lw b gy mc md l me mf">pets = [ “dog”, “dog”, “cat”, “bird”, “chinchilla”, “rat”, “hamster”, “dog”, “rat”, “bird”, “cat”, “giraffe”, “cat”, “bird”,”dog”, “snake”, “hamster”, “dog” , “mouse”, “spider”, “dog”, “cat”]</span><span id="72fa" class="ma mb it lw b gy nj md l me mf">pets.max_by {|pet| pets.count(pet)}<br/>returns "dog"</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c18b" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">结论</strong></h1><p id="a107" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">每种方法都有自己的好处。假设您想要更多信息，比如有多少最受欢迎的宠物，hash方法是一个不错的选择。</p><p id="7d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你特别希望回报是宠物，并且不需要任何额外的信息，第二种方法是可行的。只有一句好听的台词。</p><p id="83a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在卡罗尔必须除掉老拉斯蒂。他是一只好狗，我相信他会让一些家庭非常高兴。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a37a" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">资源</strong></h1><p id="0aee" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果你刚开始，这里有一些资源可能会有帮助。</p><p id="faac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<a class="ae ky" href="https://ruby-doc.org/" rel="noopener ugc nofollow" target="_blank">Ruby-Doc.org</a>习惯数组和散列方法</p><p id="4258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://ruby-doc.org/core-2.2.0/Array.html" rel="noopener ugc nofollow" target="_blank"> Ruby Doc数组方法</a></p><p id="c51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://ruby-doc.org/core-2.2.0/Hash.html" rel="noopener ugc nofollow" target="_blank"> Ruby Doc哈希方法</a></p><p id="2044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.informit.com/articles/article.aspx?p=26943&amp;seqNum=3" rel="noopener ugc nofollow" target="_blank">使用哈希</a></p><p id="c911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/412169/ruby-how-to-find-item-in-array-which-has-the-most-occurrences" rel="noopener ugc nofollow" target="_blank">更多方法！</a></p></div></div>    
</body>
</html>