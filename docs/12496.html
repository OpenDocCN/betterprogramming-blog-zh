<html>
<head>
<title>What Does React Actually Do?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React实际上是做什么的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-does-react-actually-do-c9412c08bfe6?source=collection_archive---------4-----------------------#2022-06-09">https://betterprogramming.pub/what-does-react-actually-do-c9412c08bfe6?source=collection_archive---------4-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="348e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在后台</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/647a5eea8a54d9675009ec4564aff263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uA4SCcHgx-Nuqxzg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·拉德福德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多么吸引人的标题，对吧？但是忽略这一点，你有多了解React实际上做了什么？当然，在高层次上，React是“一个用于构建ui的JavaScript库”但是这个JavaScript到底是做什么的？它与其他框架或简单地编写普通JS有什么不同？</p><p id="e718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React是我日常使用的工具。然而，直到最近，我对它在幕后所做的事情只有粗浅的了解。我觉得在React中做事情很熟练，并且理解它的API和核心概念。然而，<em class="ls">如何</em>和<em class="ls">为什么</em>会这样反应，对我来说仍然是个谜。在阅读了无数的文档、博客文章和源代码之后，React逐渐变得不那么神奇，同时也变得更加特别。虽然许多细节不适用于日常开发，但我也对React的真正功能有了更清晰的了解。</p><p id="cb79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的文章中，我的目标是描述React是如何工作的，同时省略一些乏味的、不太重要的细节。希望这能激发其他人更深入地研究React的机制——或者至少对这个web非常依赖的库给予更多的赞赏。</p><h1 id="b973" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么对React有更深入的理解很重要？</h1><p id="5f4b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">事实上，<em class="ls">和</em>没有关系。React做了大量工作，使得这些实现细节对于生成令人难以置信的web应用程序来说是不必要的。也就是说，我们越了解我们的工具，我们就能越好地利用它们来完成我们需要的东西。React(以及整个JS，真的)是一个非常灵活的环境，开发人员可以用许多不同的方式解决同一个问题。挑战通常是决定哪种解决方案对于给定的情况是最好的。根据我的经验，完全理解React的功能有助于评估可能的实现，并提高代码库的整体质量。</p><h1 id="716d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">React库与框架</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c118dacda9eb91da683ebcc67a50621f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSi5gYMkSKOx_45AFM0W6Q.png"/></div></div></figure><p id="5bab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有大量的文章致力于React和其他前端框架之间的比较。然而，对于这篇文章，只需要强调React试图填补的角色。</p><p id="8201" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们在React中构建的任何东西都可以用纯JavaScript和各种<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs" rel="noopener ugc nofollow" target="_blank">Web API</a>实现。那么为什么还要费神去反应呢？很简单，更容易。与普通的JS相比，React的声明式语法(JSX)和低层关注点的抽象极大地提高了开发速度和代码的可读性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/cbe0b0f7ce25e29b291490243e5d304e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JyNpC8IsJYM5d8MxFe8CA.png"/></div></div></figure><p id="7059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个更有趣的问题:为什么React被称为<em class="ls">库</em>而不是Vue、Ember或Angular之类的框架？与这些“包含电池”的框架不同，React的目的更加“单一”。它没有提供路由、获取数据甚至全局状态管理的工具。React专注于一件事，并且做得非常好——高效地将数据渲染到您的显示器上。但是这有多重要呢？<em class="ls">继续读下去！</em></p><blockquote class="ms mt mu"><p id="ec8a" class="kw kx ls ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">注意:当我们讨论React用于web应用程序开发时，我们通常指的是两个独立的包:<code class="fe my mz na nb b">react</code>和<code class="fe my mz na nb b">react-dom</code>。<code class="fe my mz na nb b">react</code>包只负责定义组件的功能。它通常与一个“渲染器”成对出现，比如<code class="fe my mz na nb b">react-dom</code>，为我们提供我们通常称为React的特性集。但稍后会详细介绍。</p></blockquote><h1 id="73c8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">浏览器渲染过程</h1><p id="2e64" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经说过，React是专门为尽可能高效地在浏览器中呈现内容而构建的。为了更好地理解React给我们带来的功能，我们需要简单描述一下浏览器呈现和更新网页的过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/c68a32d4bd4c3ecc0a71e6a5bacb668a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Av5GkTVmz5DQyu8F3QPDGQ.png"/></div></div></figure><p id="ffb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户访问典型web应用程序的页面时，会向浏览器返回一个HTML文件，其中包含特定视图所需的资源。浏览器解析文件的内容，下载并执行任何链接的JS、CSS和图像资源。在这个过程中还构建了两个树状结构，称为<strong class="ky ir"> DOM </strong>(文档对象模型)和<strong class="ky ir"> CSSOM </strong> (CSS对象模型)。DOM的节点表示组成视图的元素和内容，而CSSOM包含每个DOM节点的样式信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/5394470eac88d57ec2df064e1f3aca61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1ahjWLs0GoHhF__Iy3Raw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图表改编自<a class="ae kv" href="https://web.dev/critical-rendering-path-render-tree-construction/" rel="noopener ugc nofollow" target="_blank">渲染树结构、布局和油漆</a>。</p></figure><p id="1cb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦DOM和CSSOM树构建完成，浏览器就可以开始将它们拼接成第三种结构，称为<strong class="ky ir">渲染树</strong>。渲染树不仅仅是DOM和CSSOM的合并。它只是呈现页面所需的节点的精确映射。这意味着不占用任何空间的节点，比如脚本标签或者具有<code class="fe my mz na nb b">display: none</code>风格属性的元素，将从这个树中被忽略。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f56ef04d4d758df5a55bb1eb990c309d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rR8ro9tPVhXD6_MWYyxFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图表改编自<a class="ae kv" href="https://web.dev/critical-rendering-path-render-tree-construction/" rel="noopener ugc nofollow" target="_blank">渲染树构造、布局和油漆</a>。</p></figure><p id="c082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然浏览器知道什么内容需要呈现在屏幕上，它必须确定每一部分在页面上的位置。这一步称为<strong class="ky ir">布局</strong>阶段。浏览器从渲染树的根开始，并根据设备的视口计算每个节点的位置和大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/95b47aacae8b094bce97dd6d586200d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBv78nwYHqX7GVBUYoXpJQ.png"/></div></div></figure><p id="25f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，浏览器已经确定了应该显示什么内容，应该是什么样子，应该放在什么位置。但是它实际上并没有向用户呈现任何可见的东西。这就是<strong class="ky ir">上色</strong>和<strong class="ky ir">合成</strong>步骤的用武之地。绘画需要填充页面上的像素，通常在多个层中绘制内容。然后，这些层被缝合在一起，并在一个称为合成的过程中以正确的顺序应用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/403991f8d4f0376b09854d017d3998a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*VqvO7-9QQqAxsZlpY8qpCA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图改编自<a class="ae kv" href="https://web.dev/rendering-performance/" rel="noopener ugc nofollow" target="_blank">渲染性能</a>。</p></figure><p id="0e2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，这个过程被称为“<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path" rel="noopener ugc nofollow" target="_blank">关键渲染路径</a>”，它代表了浏览器的大量工作。高性能UI的关键是尽可能最低限度和高效地触发这个流程。实际上，这意味着:</p><ul class=""><li id="a447" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">只要有可能，批量更新DOM以防止浏览器不必要地频繁重新呈现。</li><li id="2f59" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">优化渲染每一帧所需的JS，使其尽可能快而短。</li><li id="0bd1" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">寻找机会仅触发该流程的<em class="ls">部分</em>。例如，更新元素的颜色或不透明度比添加/删除一个元素要简单得多。如果页面上元素的位置没有变化，那么可以跳过布局阶段，避免额外的工作。请看一下<a class="ae kv" href="https://csstriggers.com/" rel="noopener ugc nofollow" target="_blank"> CSS触发器</a>以获得影响渲染路径不同阶段的属性的更全面列表。</li></ul><blockquote class="ms mt mu"><p id="859c" class="kw kx ls ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">注意:这是对渲染过程和关键渲染路径的高度概括。如果您想更深入地了解每个阶段的实际情况，请查看页面底部参考资料部分的链接。</p></blockquote><h1 id="c4b7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">React适合在哪里？</h1><p id="8773" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">记住上面描述的关键呈现路径，考虑一个典型的web应用程序。在任何给定的页面上，它可能从各种来源获取数据，并向用户显示格式化的结果。它包含响应用户交互而定期更新或更改的动态内容。有表单域、动画、模态和弹出窗口。换句话说，应用程序需要处理大量的DOM更新。管理所有这些更新，同时确保页面保持高性能是一项艰巨的任务。这就是React介入的地方。有效地、声明性地对DOM应用更新是其架构的核心。接下来让我们看看React是如何做到这一点的。</p><h1 id="fffc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">React虚拟DOM及协调算法</h1><p id="dc0c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">React应用程序由组件组成。这些组件包装了组成UI的功能块。他们可以接受<code class="fe my mz na nb b">props</code>作为输入，并可以管理自己的<code class="fe my mz na nb b">state</code>。然而，组件的真正本质是定义一组由它的<code class="fe my mz na nb b">render()</code>方法返回的<a class="ae kv" href="https://reactjs.org/docs/rendering-elements.html" rel="noopener ugc nofollow" target="_blank"> React元素</a>。元素是简单、廉价的JS对象，代表React应用程序的最小构建块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您观察上面代码片段中的元素对象，您会注意到第一个元素有一个<code class="fe my mz na nb b">Card</code>的<code class="fe my mz na nb b">type</code>。<code class="fe my mz na nb b">Card</code>元素还有一个道具叫<code class="fe my mz na nb b">children</code>。<code class="fe my mz na nb b">children</code>的值只是另一个元素，在本例中是一个<code class="fe my mz na nb b">h1</code>。通过这种映射，React元素以我们在DOM树中观察到的类似结构建立父子链接。在React中，这种元素树通常被描述为<a class="ae kv" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">虚拟DOM </strong> </a>。为了更具体地了解虚拟DOM的作用，让我们来看一个基本的React应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nw l"/></div></figure><p id="0e91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的应用程序由一个按钮和一个随机生成的数字列表组成。单击该按钮会向列表中添加一个新号码。当React应用程序运行时，它遍历每个组件并调用其<code class="fe my mz na nb b">render()</code>方法。<code class="fe my mz na nb b">render()</code>方法返回组成组件的元素树。这是应用程序的外观，用元素表示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="485c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，可视化为元素的组合树:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><blockquote class="ms mt mu"><p id="4eaf" class="kw kx ls ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">注意:这个<strong class="ky ir">组合的</strong>对象只是为了更好地可视化元素之间的关系。它不是React创建的结构的实际表示。</p></blockquote><p id="be23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦React构建了这个元素树，它就开始将树与页面上当前显示的内容进行比较。React确定一个精确的差异列表，并将更改列表交给一个“渲染器”，比如<a class="ae kv" href="https://github.com/facebook/react/tree/main/packages/react-dom" rel="noopener ugc nofollow" target="_blank"> ReactDOM </a>。ReactDOM负责获取这一批指令，并将更新应用到浏览器，将应用程序绑定到前面描述的渲染路径。</p><p id="ba43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当应用程序首次初始化时，比较是很容易的。虚拟DOM中的任何内容当前都不存在于实际DOM中。因此发送到ReactDOM的指令列表必须包括从头开始创建一切的步骤。但是当你点击“添加随机数”按钮时会发生什么呢？视觉上，一个新的数字被添加到屏幕上的列表中。以编程方式，<code class="fe my mz na nb b">state</code>变量<code class="fe my mz na nb b">numList</code>被更新以包含新条目。然而，再深入一步，虚拟DOM的角色变得更加普遍。当一个组件的<code class="fe my mz na nb b">state</code>值改变时，React再次调用该组件的<code class="fe my mz na nb b">render()</code>方法。和以前一样，调用<code class="fe my mz na nb b">render()</code>将返回一个类似的元素树。不过，这一次，树将包含一个新元素，其<code class="fe my mz na nb b">type</code>为<code class="fe my mz na nb b">li</code>，表示附加的列表项。React now有一个旧的树来描述页面上当前可见的内容，有一个新的树来描述我们希望更新后的页面是什么样子。现在React必须比较这两棵树，并向ReactDOM提供指令来同步所有发生变化的内容。这导致新号码被附加到屏幕上的列表中。</p><p id="76fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么虚拟DOM对于构建高性能的web应用程序如此关键呢？虚拟DOM使开发人员能够专注于描述他们希望更新后的UI是什么样子。React然后获取这个描述并构建一个元素树——这比创建和遍历浏览器DOM元素要便宜得多。有了这个专门构建的树，React可以有效地精确协调视图需要做的更改。然后，可以对实际的DOM进行高度优化的批量更新。很聪明，对吧？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/320b021ffadfdc6f51dd1df0bcc1a63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOlbfjTe0jecw6DlkuR1MA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">什么是差分算法？</p></figure><p id="a235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再翻一块重要的石头来反应React的效率。React cheaply如何确定新旧元素树之间发生了什么变化？一个web应用程序可以很容易地由成千上万个元素组成。使用传统的试探法将花费太长的时间来识别从如此巨大的树中应该发生什么更新。为此React开发了<strong class="ky ir">调和算法</strong>。这种算法是一套可预测的、易于遵循的规则，使开发人员能够根据自己的意愿进行优化。</p><p id="2d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">关于对账规则的文档</a>阅读速度快，内容全面，这里就不赘述了。但简而言之，当一个组件的<code class="fe my mz na nb b">render()</code>方法被调用时，通常是在一个<code class="fe my mz na nb b">state</code>或<code class="fe my mz na nb b">prop</code>改变之后，返回的组成组件的元素树将与它先前生成的树进行比较。从每棵树的根开始，如果两个元素之间的<code class="fe my mz na nb b">type</code>不同，例如<code class="fe my mz na nb b">div</code>变为<code class="fe my mz na nb b">span</code>，那么该节点以及树中它下面的所有节点将立即被标记为“新的”,而无需进一步比较。任何嵌套的组件都将被拆除并销毁，所有生成的DOM节点都将从头开始重新创建。然而，如果元素共享相同的类型，则比较它们的<code class="fe my mz na nb b">props</code>。对于DOM元素，如<code class="fe my mz na nb b">div</code>，React识别出发生变化的特定属性，并只更新现有DOM节点上的这些值。但是，对于具有组件<code class="fe my mz na nb b">type</code>、<code class="fe my mz na nb b">NumList</code>的元素，例如，组件的<code class="fe my mz na nb b">render()</code>方法用最新的<code class="fe my mz na nb b">prop</code>值调用，并且该过程在返回的元素树上递归重复。</p><h1 id="301e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">外卖食品</h1><p id="e827" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">简而言之，React为开发人员提供了一种声明性的机制，用于描述网页应该是什么样子，而无需经常关注浏览器呈现过程中的许多细微差别。它通过JS对象树和明确表达的规则来实现这一点，以确定何时发生了变化。这些规则使开发人员能够进一步优化性能，以满足其应用程序的需求。以下是开发过程中需要牢记的一些概念:</p><ul class=""><li id="b4ca" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">React中的“渲染”(或“重新渲染”)是比浏览器渲染更便宜的操作。尽管注意组件何时触发重新渲染很重要，但在大多数情况下，没有必要消除所有不重要的渲染。事实上，在某些情况下，这甚至会<a class="ae kv" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">伤害<strong class="ky ir">表现</strong>。</a></li><li id="a317" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">我们可以在代码中采用一些策略来更好地与React的协调算法保持一致。确保在生成组件列表时使用足够独特的<code class="fe my mz na nb b">key</code>属性，并注意改变元素的<code class="fe my mz na nb b">type</code>，尤其是在应用程序的根目录附近。有条件地将<code class="fe my mz na nb b">div</code>更改为<code class="fe my mz na nb b">span</code>或者使用三元组在两个父组件之间切换可能会有惊人的成本。</li><li id="8b34" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">反应不是魔法。开发人员仍然需要知道DOM何时以及如何更新。是否经常在DOM中添加和删除组件？可以用CSS来限制浏览器渲染路径的哪一部分被触发吗？如果React组件的<code class="fe my mz na nb b">state</code>更新很快，有什么办法可以减缓被推送到DOM的更改吗？也许是一个合适的去抖？</li><li id="bd13" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">我们日常使用的库和框架不必是一个谜。这就是开源的美妙之处。投入进去，做出贡献，学习事情是如何运作的。您可能会带着一两个可以改进您自己的应用程序的概念离开。</li></ul><h1 id="a3cf" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">资源</h1><ul class=""><li id="c5f4" class="nh ni iq ky b kz ml lc mm lf nz lj oa ln ob lr nm nn no np bi translated"><a class="ae kv" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> React Docs </a></li><li id="5ec4" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://github.com/facebook/react/tree/main/packages/react" rel="noopener ugc nofollow" target="_blank">React</a>/<a class="ae kv" href="https://github.com/facebook/react/tree/main/packages/react-dom" rel="noopener ugc nofollow" target="_blank">React DOM</a>源代码</li><li id="04a0" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://www.freecodecamp.org/news/is-react-a-library-or-a-framework/" rel="noopener ugc nofollow" target="_blank">React是库还是框架？</a></li><li id="3e18" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">浏览器<a class="ae kv" href="https://web.dev/critical-rendering-path-render-tree-construction/" rel="noopener ugc nofollow" target="_blank">渲染树构建、布局和绘制</a></li><li id="d251" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">浏览器<a class="ae kv" href="https://web.dev/rendering-performance/" rel="noopener ugc nofollow" target="_blank">渲染性能</a></li><li id="0e37" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" rel="noopener">浏览器如何呈现网页</a></li><li id="fdb9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" rel="noopener ugc nofollow" target="_blank">反应组件、元素和实例</a></li><li id="b86c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://overreacted.io/react-as-a-ui-runtime/" rel="noopener ugc nofollow" target="_blank">作为UI运行时反应</a></li></ul><h1 id="b466" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">延伸阅读</strong></h1><ul class=""><li id="abcb" class="nh ni iq ky b kz ml lc mm lf nz lj oa ln ob lr nm nn no np bi translated"><a class="ae kv" href="https://web.dev/user-centric-performance-metrics/?utm_source=devtools" rel="noopener ugc nofollow" target="_blank">以用户为中心的绩效指标</a></li><li id="83b9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><a class="ae kv" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank"> React光纤架构</a>(实施概述)</li></ul></div></div>    
</body>
</html>