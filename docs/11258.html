<html>
<head>
<title>Unit Test React Applications With Jest and Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest和Enzyme进行单元测试反应应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-test-react-applications-with-jest-and-enzyme-7c076c2abfb0?source=collection_archive---------1-----------------------#2022-03-03">https://betterprogramming.pub/unit-test-react-applications-with-jest-and-enzyme-7c076c2abfb0?source=collection_archive---------1-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6905" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建健壮的React应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b7fef4cb02abc9bf92facd8b6e41026b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4S0KxtOknQCtlUrh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">替代代码</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a86b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家好！</p><p id="e4c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将教你如何用Jest和Enzyme对react应用程序进行单元测试。</p><p id="719c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写自动化测试在任何现实世界的项目中都非常重要，但是众所周知它很难弄清楚，尤其是在前端世界。</p><p id="4da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jest是来自脸书的一个测试工具，它使得用JavaScript执行单元测试变得很容易。另一方面，酶具有反应特异性。它提供了一系列有用的方法来增强我们测试React组件的方式。</p><p id="eae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何利用Jest和Enzyme来创建更健壮的React应用程序。</p><h1 id="3518" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="4437" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要完成本教程，您需要在您的机器上安装<a class="ae kv" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> (v6和更高版本)和<a class="ae kv" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank"> npm </a>。你还需要安装<code class="fe mp mq mr ms b">yarn</code>，因为那是<code class="fe mp mq mr ms b">create-react-app</code>使用的。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8716" class="mx lt iq ms b gy my mz l na nb">npm install -g yarn</span></pre><h1 id="5d4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置React应用程序</h1><p id="b518" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在编写任何测试之前，我们需要创建一个可以测试的应用程序。我们将创建一个简单的计数器应用程序，一旦点击一个按钮，它就会增加计数。让我们用<a class="ae kv" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>来启动这个项目，这样我们就可以以最小的忙乱开始运行了。</p><p id="0819" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的终端中运行以下命令来安装<code class="fe mp mq mr ms b">create-react-app</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5206" class="mx lt iq ms b gy my mz l na nb">npm install -g create-react-app</span></pre><p id="b8a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用以下命令创建React应用程序:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="dc47" class="mx lt iq ms b gy my mz l na nb">create-react-app counter-app</span></pre><p id="1834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦应用程序被创建，进入<code class="fe mp mq mr ms b">counter-app</code>目录并运行<code class="fe mp mq mr ms b">yarn start</code>来启动开发服务器。您应该会看到一条消息，确认编译成功以及可以访问应用程序的端口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/2fd2bde6ea9bfc06501a54ef90ee391a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8T-Z0HGa0h7Ul40YGfmgQ.png"/></div></div></figure><p id="66a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在您喜欢的文本编辑器中打开<code class="fe mp mq mr ms b">counter-app</code>文件夹并找到<code class="fe mp mq mr ms b">src/App.js</code>。将其内容更改为如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2beb" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.js</em><br/>    <br/>    import React, { Component } from 'react';<br/>    <br/>    class App extends Component {<br/>      constructor() {<br/>        super();<br/>        this.state = {<br/>          count: 0,<br/>        }<br/>      }<br/>    <br/>      makeIncrementer = amount =&gt; () =&gt;<br/>        this.setState(prevState =&gt; ({<br/>          count: prevState.count + amount,<br/>        }));<br/>    <br/>      increment = this.makeIncrementer(1);<br/>    <br/>      render() {<br/>        return (<br/>          &lt;div&gt;<br/>            &lt;p&gt;Count: {this.state.count}&lt;/p&gt;<br/>            &lt;button className="increment" onClick={this.increment}&gt;Increment count&lt;/button&gt;<br/>          &lt;/div&gt;<br/>        )<br/>      }<br/>    }<br/>    <br/>    export default App;</span></pre><p id="745b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的React应用程序有一些初始状态<code class="fe mp mq mr ms b">count</code>，它被设置为零，还有一个按钮，一旦被点击，它通过<code class="fe mp mq mr ms b">increment</code>函数增加这个<code class="fe mp mq mr ms b">count</code>状态，这个函数简单地将<code class="fe mp mq mr ms b">count</code>的值加1并更新应用程序状态。</p><h1 id="3ea0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">笑话基础</h1><p id="1f6b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常，我们需要在编写任何测试之前安装和配置Jest，但是由于<code class="fe mp mq mr ms b">create-react-app</code>已经安装了Jest，我们不需要做任何事情。我们可以直接开始编写我们的第一个测试。</p><p id="13ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看一下<code class="fe mp mq mr ms b">src/App.test.js</code>，你会发现一个测试已经为我们写好了。它测试应用程序组件可以在不崩溃的情况下呈现。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ba7e" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    import React from 'react';<br/>    import ReactDOM from 'react-dom';<br/>    import App from './App';<br/>    <br/>    it('renders without crashing', () =&gt; {<br/>      const div = document.createElement('div');<br/>      ReactDOM.render(&lt;App /&gt;, div);<br/>      ReactDOM.unmountComponentAtNode(div);<br/>    });</span></pre><p id="6309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<code class="fe mp mq mr ms b">App.test.js</code>的这个下面增加一个模拟测试:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a190" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    ...<br/>    <br/>    describe('Addition', () =&gt; {<br/>      it('knows that 2 and 2 make 4', () =&gt; {<br/>        expect(2 + 2).toBe(4);<br/>      });<br/>    });</span></pre><p id="41d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以继续使用运行<code class="fe mp mq mr ms b">jest</code>的<code class="fe mp mq mr ms b">yarn test</code>命令来运行这两个测试。屏幕上应该会打印出一条成功消息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/25f952f66e784ad3c7d98673d2dfeb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUYk8JhyjLlq6HCbN6Z9Zw.png"/></div></div></figure><p id="3485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们更改其中一个测试，使其失败。在<code class="fe mp mq mr ms b">src/App.test.js</code>内，将<code class="fe mp mq mr ms b">Addition</code>测试更改为如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="bc8c" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    describe('Addition', () =&gt; {<br/>      it('knows that 2 and 2 make 4', () =&gt; {<br/>        expect(2 + 2).toBe(5);<br/>      });<br/>    });</span></pre><p id="3385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查您的终端输出。您可以看到第一个测试像以前一样通过了，而第二个测试失败了，失败的原因也被打印出来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/229418364704b635cf4965c79f8dda9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JVjH1NiFSVH1fsmbpw6dRg.png"/></div></figure><p id="1434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe mp mq mr ms b">describe()</code>函数将相关的测试组合在一个测试套件中。它带有一个<code class="fe mp mq mr ms b">name</code>参数，该参数应该描述您正在测试的组件，以及一个回调函数，其中用<code class="fe mp mq mr ms b">it</code>定义了各个测试。</p><p id="c470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会在一些项目中看到带有<code class="fe mp mq mr ms b">test</code>的单独测试。可以肯定的是，<code class="fe mp mq mr ms b">it</code>和<code class="fe mp mq mr ms b">test</code>是<a class="ae kv" href="https://jestjs.io/docs/en/api.html#testname-fn-timeout" rel="noopener ugc nofollow" target="_blank">同一个东西</a>。<code class="fe mp mq mr ms b">it</code>只是<code class="fe mp mq mr ms b">test</code>的别名。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fa28" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    describe('Addition', () =&gt; {<br/>      it('knows that 2 and 2 make 4', () =&gt; {<br/>        expect(2 + 2).toBe(4);<br/>      });<br/>      <br/>      <em class="nd">// is equaivalent to</em><br/>      <br/>      test('knows that 2 and 2 make 4', () =&gt; {<br/>        expect(2 + 2).toBe(4);<br/>      });<br/>    });</span></pre><p id="63a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用所谓的“匹配器”函数之前，您想要测试的内容被包装在对<code class="fe mp mq mr ms b">expect()</code>函数的调用中。在上面的例子中，<code class="fe mp mq mr ms b">toBe()</code>是使用的matcher函数。它检查提供的值是否等于<code class="fe mp mq mr ms b">expect()</code>函数中的代码产生的值。</p><h1 id="2d78" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编写您的第一个测试</h1><p id="9162" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始编写自己的测试之前，我们需要向我们的应用程序添加几个包，以便它能够通过Enzyme的浅层渲染器进行测试:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0290" class="mx lt iq ms b gy my mz l na nb">yarn add enzyme enzyme-adapter-react-16 --dev</span></pre><p id="af5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Enzyme旨在支持不同版本的React。在本教程中，我使用的是React 16 . 4 . 2的稳定版本，但您可能会使用React的旧版本，比如React 15.x。因此您还必须安装与您正在使用的React版本相对应的适配器。</p><p id="b61e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还需要在您的<code class="fe mp mq mr ms b">src</code>文件夹中创建一个<code class="fe mp mq mr ms b">setupTests.js</code>文件，告诉Jest和Enzyme您将使用哪些适配器。<code class="fe mp mq mr ms b">create-react-app</code>已被配置为在我们的任何测试之前自动运行该文件，以便正确设置酶。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0ca4" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/setupTests.js</em><br/>    <br/>    import { configure } from 'enzyme';<br/>    import Adapter from 'enzyme-adapter-react-16';<br/>    <br/>    configure({ adapter: new Adapter() });</span></pre><p id="952d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，可以开始为我们的应用程序编写测试了。跳转到<code class="fe mp mq mr ms b">src/App.test.js</code>,将其内容更改如下:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="eb53" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    import React from 'react';<br/>    import { shallow } from 'enzyme';<br/>    import App from './App';<br/>    <br/>    describe('App component', () =&gt; {<br/>      it('starts with a count of 0', () =&gt; {<br/>        const wrapper = shallow(&lt;App /&gt;);<br/>        const text = wrapper.find('p').text();<br/>        expect(text).toEqual('Count: 0');<br/>      });<br/>    });</span></pre><p id="bf71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在利用Enzyme的浅层渲染来测试我们的应用程序的初始状态。浅层呈现是不需要DOM的组件树的模拟呈现。它只呈现组件的一个层次，并支持组件内容的检查以及用户交互的模拟。</p><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，我们的<code class="fe mp mq mr ms b">App</code>组件的浅层渲染存储在<code class="fe mp mq mr ms b">wrapper</code>变量中。然后，我们获取组件输出中的<code class="fe mp mq mr ms b">p</code>标签内的文本，并检查该文本是否与我们传递给<code class="fe mp mq mr ms b">toEqual</code>匹配器函数的文本相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/627493ef2075a102435501f87e9cb060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*AusY9bIguK9bEwFLxfoNjQ.png"/></div></figure><h1 id="3559" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试用户交互</h1><p id="bfce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们继续编写一个新的测试，模拟点击按钮并确认计数输出增加1。</p><p id="47b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将此添加到第一个测试下面:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="bacb" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    describe('App component', () =&gt; {<br/>      ...<br/>      <br/>      it('increments count by 1 when the increment button is clicked', () =&gt; {<br/>        const wrapper = shallow(&lt;App /&gt;);<br/>        const incrementBtn = wrapper.find('button.increment');<br/>        incrementBtn.simulate('click');<br/>        const text = wrapper.find('p').text();<br/>        expect(text).toEqual('Count: 1');<br/>      });<br/>    });</span></pre><p id="a56b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量<code class="fe mp mq mr ms b">button</code>上的<code class="fe mp mq mr ms b">simulate()</code>函数可以模拟一个元素上的多个DOM事件。这里我们模拟按钮上的<code class="fe mp mq mr ms b">click</code>事件。我们还设置了一个期望值，即<code class="fe mp mq mr ms b">count</code>应该等于now。</p><p id="5d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查终端输出，您应该观察到测试按预期通过。</p><p id="6243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续做一些不同的事情。我们将为一些尚不存在的功能添加一个测试，然后继续编写代码使测试通过。这种在编写代码之前编写测试的方法被称为测试驱动开发(TDD)。</p><p id="f8a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mp mq mr ms b">describe()</code>函数中创建另一个测试，如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="3d91" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    describe('App component', () =&gt; {<br/>      ...<br/>    <br/>      it('decrements count by 1 when the decrement button is clicked', () =&gt; {<br/>        const wrapper = shallow(&lt;App /&gt;);<br/>        const decrementBtn = wrapper.find('button.decrement');<br/>        decrementBtn.simulate('click');<br/>        const text = wrapper.find('p').text();<br/>        expect(text).toEqual('Count: -1');<br/>      });<br/>    });</span></pre><p id="6981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您应该在终端中有一个失败的测试:<code class="fe mp mq mr ms b">Method</code> <code class="fe mp mq mr ms b">"``simulate``"</code> <code class="fe mp mq mr ms b">is only meant to be run on a single node. 0 found instead</code>。如果您不习惯使用Enzyme，您可能会发现这个错误消息相当神秘。这意味着在一个尚不存在的元素上调用了<code class="fe mp mq mr ms b">simulate()</code>方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e37e76c459046ddc8584eed43ff9fa76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*DgXqasmbMFXEjzAY7Z1oTw.png"/></div></figure><p id="a3c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们进入React组件，并编写将修复该测试的代码:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6644" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.js</em><br/>    <br/>    import React, { Component } from 'react';<br/>    <br/>    class App extends Component {<br/>      constructor() {<br/>        super();<br/>        this.state = {<br/>          count: 0,<br/>        }<br/>      }<br/>    <br/>      makeIncrementer = amount =&gt; () =&gt;<br/>        this.setState(prevState =&gt; ({<br/>          count: prevState.count + amount,<br/>        }));<br/>    <br/>      increment = this.makeIncrementer(1);<br/>    <br/>      decrement = this.makeIncrementer(-1);<br/>    <br/>      render() {<br/>        return (<br/>          &lt;div&gt;<br/>            &lt;p&gt;Count: {this.state.count}&lt;/p&gt;<br/>            &lt;button className="increment" onClick={this.increment}&gt;Increment count&lt;/button&gt;<br/>            &lt;button className="decrement" onClick={this.decrement}&gt;Decrement count&lt;/button&gt;<br/>          &lt;/div&gt;<br/>        )<br/>      }<br/>    }<br/>    <br/>    export default App;</span></pre><p id="eb9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe mp mq mr ms b">render()</code>函数中的增量按钮后添加了一个减量按钮，并添加了一个<code class="fe mp mq mr ms b">decrement()</code>函数，用于将<code class="fe mp mq mr ms b">count</code>的值减1并更新应用程序状态。此时，所有三个测试都应该成功通过。</p><h1 id="653b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用快照测试React组件</h1><p id="d82f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">快照测试有助于您检查组件的呈现输出是否始终正确。当您运行快照测试时，Jest呈现正在测试的React组件，并将输出存储在一个JSON文件中。</p><p id="18ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进一步的测试运行中，Jest将检查组件的输出没有偏离之前保存的内容。如果您更改了组件的输出，Jest会通知您，您可以将快照更新到最新版本，或者修复组件，使其再次匹配快照。这种测试组件的方法可以帮助您避免组件的意外更改，因为Jest会在检测到差异时通知您。</p><p id="b8eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用Jest的快照功能，我们需要一个额外的包，<a class="ae kv" href="https://www.npmjs.com/package/react-test-renderer" rel="noopener ugc nofollow" target="_blank"> react-test-renderer </a>，它可以通过yarn安装:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fb5f" class="mx lt iq ms b gy my mz l na nb">yarn add react-test-renderer --dev</span></pre><p id="d8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe mp mq mr ms b">App.test.js</code>顶部导入:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d453" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    import renderer from 'react-test-renderer';<br/>    <br/>    ...</span></pre><p id="2f30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在所有先前创建的测试下创建一个测试:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5a8c" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.test.js</em><br/>    <br/>    it('matches the snapshot', () =&gt; {<br/>      const tree = renderer.create(&lt;App /&gt;).toJSON();<br/>      expect(tree).toMatchSnapshot();<br/>    });</span></pre><p id="3828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次运行这个测试时，这个组件没有快照，所以Jest创建了它。您可以检查<code class="fe mp mq mr ms b">src/__snapshots__</code>目录中快照的内容。</p><p id="7f06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mp mq mr ms b">App.test.js.snap</code>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7fa8" class="mx lt iq ms b gy my mz l na nb">// src/__snapshots__/App.test.js.snap<br/>    <br/>    // Jest Snapshot v1, https://goo.gl/fbAQLP<br/>    <br/>    exports[`App component matches the snapshot 1`] = `<br/>    &lt;div&gt;<br/>      &lt;p&gt;<br/>        Count: <br/>        0<br/>      &lt;/p&gt;<br/>      &lt;button<br/>        className="increment"<br/>        onClick={[Function]}<br/>      &gt;<br/>        Increment count<br/>      &lt;/button&gt;<br/>      &lt;button<br/>        className="decrement"<br/>        onClick={[Function]}<br/>      &gt;<br/>        Decrement count<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>    `;</span></pre><p id="85c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到<code class="fe mp mq mr ms b">App</code>组件的渲染输出保存在这个文件中。下次运行这个测试时，Jest将确认输出是相同的。我们可以通过稍微改变<code class="fe mp mq mr ms b">App</code>的渲染输出来演示这个概念。</p><p id="2be2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设我们不小心把<code class="fe mp mq mr ms b">App.js</code>中的增量按钮的文本改成了<code class="fe mp mq mr ms b"><strong class="ky ir">Increment count2</strong>.</code>测试应该会失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/055c723ffe25b0c3efe6384a5d00c180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*WkvaaS-ufXee7K1-MiGXoQ.png"/></div></figure><p id="cf7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们不打算做这个改变，我们可以简单地撤销这个改变，测试将再次通过。</p><p id="25a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们对<code class="fe mp mq mr ms b">App</code>组件做一个实际的修改。将增量按钮的文本改为<code class="fe mp mq mr ms b"><strong class="ky ir">Increment</strong></code>，将减量按钮改为<code class="fe mp mq mr ms b"><strong class="ky ir">Decrement</strong></code> <strong class="ky ir">。</strong>你的渲染函数应该是这样的:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="1862" class="mx lt iq ms b gy my mz l na nb"><em class="nd">// src/App.js</em><br/>    <br/>    render() {<br/>      return (<br/>        &lt;div&gt;<br/>          &lt;p&gt;Count: {this.state.count}&lt;/p&gt;<br/>          &lt;button className="increment" onClick={this.increment}&gt;Increment&lt;/button&gt;<br/>          &lt;button className="decrement" onClick={this.decrement}&gt;Decrement&lt;/button&gt;<br/>        &lt;/div&gt;<br/>      )<br/>    }</span></pre><p id="199c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试应该会再次失败。但是，由于我们实际上打算进行这种更改，我们需要将快照更新到这个最新版本。我们可以通过在运行测试的终端窗口中按下<code class="fe mp mq mr ms b">u</code>来实现。一切又要变绿了！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="2924" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经了解了Jest如何使测试React组件变得更加容易，以及如何将它与Enzyme结合起来进行单元测试和快照测试。</p><p id="37b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在GitHub 上抓取本教程<a class="ae kv" href="https://github.com/sbwengineer/react-jest-boilerplate" rel="noopener ugc nofollow" target="_blank">中编写的所有代码，供你在本地检查和运行。</a></p></div></div>    
</body>
</html>