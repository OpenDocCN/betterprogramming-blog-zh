<html>
<head>
<title>Flappy Bird With React-Native-Game-Engine and Matter.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React-Native-Game-Engine和Matter.js的Flappy Bird</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flappy-bird-with-react-native-game-engine-and-matter-js-d5673f50eb9?source=collection_archive---------2-----------------------#2019-09-04">https://betterprogramming.pub/flappy-bird-with-react-native-game-engine-and-matter-js-d5673f50eb9?source=collection_archive---------2-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0dec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重现烦人的病毒游戏</h2></div><p id="35db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Flappy Bird是大多数人都知道的游戏之一，即使他们从来没有玩过。它最初是由越南开发者Dong Nguyen于2013年5月发布的，但直到2014年初才开始流行，当时它一飞冲天，成为iOS应用商店的第一名。</p><p id="13ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个游戏不可否认地会让人上瘾，同时也让人讨厌，但更大的问题是:它能在React Native中制作吗？答案显然是肯定的，否则这个帖子就不存在了！</p><p id="fb54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；博士1:更喜欢看视频格式的？</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="04de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；博士2:只想要代码？来了:<a class="ae ll" href="https://github.com/lepunk/react-native-videos/tree/master/FlappyBird" rel="noopener ugc nofollow" target="_blank">https://github . com/lepunk/react-native-videos/tree/master/flappy bird</a></p><p id="570a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了重新制作这个游戏，我决定再次使用<a class="ae ll" href="https://github.com/bberak/react-native-game-engine" rel="noopener ugc nofollow" target="_blank">react-native-game-engine</a>(RNGE)。如果你还没有这样做，考虑阅读<a class="ae ll" href="https://medium.com/@tamasszikszai/building-snake-with-react-native-game-engine-bbc8abfdebda" rel="noopener">我之前的帖子</a>作为对引擎的介绍。然而，与Snake不同，Flappy Bird具有一些基本的物理特性——仅靠react-native游戏引擎是不够的。</p><p id="192b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进入<a class="ae ll" href="http://brm.io/matter-js/" rel="noopener ugc nofollow" target="_blank"> Matter.js </a>，一个为Javascript开发的成熟的2d物理引擎:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="35d9" class="lr ls it ln b gy lt lu l lv lw">npm install react-native-game-engine matter-js --save</span></pre><p id="439a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像这样，我们拥有了制作Flappy Bird基本版本所需的一切。</p><p id="fede" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像往常一样，让我们从设置一些常数开始:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="e632" class="lr ls it ln b gy lt lu l lv lw">import { Dimensions } from 'react-native';<br/><br/>export default Constants = {<br/>    MAX_WIDTH: Dimensions.get("screen").width,<br/>    MAX_HEIGHT: Dimensions.get("screen").height,<br/>    GAP_SIZE: 200, // gap between the two parts of the pipe<br/>    PIPE_WIDTH: 100 // width of the pipe<br/>}</span></pre><p id="a3fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要为RNGE设置我们的“实体”和“系统”。首先，让我们创建我们的世界，画一只“鸟”,用一个鲜红色的正方形来表示。</p><p id="082f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的App.js将如下所示:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="576b" class="lr ls it ln b gy lt lu l lv lw">import React, { Component } from 'react';<br/>import { StyleSheet, View, } from 'react-native';<br/>import Matter from "matter-js";<br/>import { GameEngine } from "react-native-game-engine";<br/>import Bird from './Bird';<br/>import Constants from './Constants';<br/><br/><br/>export default class App extends Component {<br/>    constructor(props){<br/>        super(props);<br/><br/>        this.state = {<br/>            running: true<br/>        };<br/><br/>        this.gameEngine = null;<br/><br/>        this.entities = this.setupWorld();<br/>    }<br/><br/>    setupWorld = () =&gt; {<br/>        let engine = Matter.Engine.create({ enableSleeping: false });<br/>        let world = engine.world;<br/><br/>        let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 4, Constants.MAX_HEIGHT / 2, 50, 50);<br/><br/>        Matter.World.add(world, [bird]);<br/><br/><br/>        return {<br/>            physics: { engine: engine, world: world },<br/>            bird: { body: bird, size: [50, 50], color: 'red', renderer: Bird},<br/>        }<br/>    }<br/><br/><br/>    render() {<br/>        return (<br/>            &lt;View style={styles.container}&gt;<br/>                &lt;GameEngine<br/>                    ref={(ref) =&gt; { this.gameEngine = ref; }}<br/>                    style={styles.gameContainer}<br/>                    running={this.state.running}<br/>                    entities={this.entities}&gt;<br/>                    &lt;StatusBar hidden={true} /&gt;<br/>                &lt;/GameEngine&gt;<br/>            &lt;/View&gt;<br/>        );<br/>    }<br/>}<br/><br/>const styles = StyleSheet.create({<br/>    container: {<br/>        flex: 1,<br/>        backgroundColor: '#fff',<br/>    },<br/>    gameContainer: {<br/>        position: 'absolute',<br/>        top: 0,<br/>        bottom: 0,<br/>        left: 0,<br/>        right: 0,<br/>    },<br/>});</span></pre><p id="0222" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里重要的部分在<code class="fe lx ly lz ln b">setupWorld</code>方法中。</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="4b12" class="lr ls it ln b gy lt lu l lv lw">let engine = Matter.Engine.create({ enableSleeping: false });<br/>let world = engine.world;</span><span id="4e6a" class="lr ls it ln b gy ma lu l lv lw">let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 4, Constants.MAX_HEIGHT / 2, 50, 50);</span><span id="81d1" class="lr ls it ln b gy ma lu l lv lw">Matter.World.add(world, [bird]);</span></pre><p id="a09a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创造了一种新的物质“引擎”。然后我们创建一个虚拟尺寸为50x50的鸟“身体”,垂直居中，水平位于屏幕的前25%。最后，我们将鸟的身体添加到我们创建的世界中。</p><p id="3247" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是要注意，Matter不会处理我们的鸟的渲染，它只会计算它在屏幕上的位置。在setupWorld的return语句中定义的React Native和RNGE将在每个节拍进行渲染:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="9ad0" class="lr ls it ln b gy lt lu l lv lw">return {<br/>    physics: { engine: engine, world: world },<br/>    bird: { body: bird, size: [50, 50], color:'red',renderer: Bird},<br/>}</span></pre><p id="3b6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了看到一些东西，我们需要创建一个Bird.js组件，看起来像这样:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mc lk l"/></div></figure><p id="fb1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里没什么花里胡哨的。我唯一想指出的是<em class="mb"> x </em>和<em class="mb"> y </em>值。我们从Matter.js管理的鸟的身体道具中提取了这个。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/e54fcd1d98f8733b9262c20f78abd7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Gwazk1xLcc6sZiM4kAdRQ.png"/></div></div></figure><p id="9d44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。在超过100行代码后，我们在白屏上看到一个红色方块。现在怎么办？</p><p id="d495" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在物质中创造的世界默认有一个重力，设置为1.0。为了让它工作，我们需要定期调用引擎上的update方法，以便Matter可以重新计算每个物体的位置。正如我在上一篇文章中所讨论的，RNGE提供了一种方便的方法来周期性地调用一组函数，称为“系统”。</p><p id="7826" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过添加include来修改我们的App.js:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="54d0" class="lr ls it ln b gy lt lu l lv lw">import Physics from './Physics';</span></pre><p id="f6ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并将物理系统添加到我们的游戏引擎中</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="29ab" class="lr ls it ln b gy lt lu l lv lw">&lt;GameEngine<br/>    ref={(ref) =&gt; { this.gameEngine = ref; }}<br/>    style={styles.gameContainer}<br/>    running={this.state.running}<br/>    systems={[Physics]}<br/>    entities={this.entities}&gt;<br/>&lt;/GameEngine&gt;</span></pre><p id="5231" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在需要的是一个Physics.js文件，它将在每次滴答时被调用</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mc lk l"/></div></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6119b0494588b0f685856b8ed6df8257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*K2PoAFAqxqSpyhRBe03BsQ.gif"/></div></figure><p id="7836" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有进展了！</p><p id="3a55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，我们再加一个天花板和地板。将App.js中的setupWorld()方法改为:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="f53a" class="lr ls it ln b gy lt lu l lv lw">setupWorld = () =&gt; {<br/>        let engine = Matter.Engine.create({ enableSleeping: false });<br/>        let world = engine.world;<br/><br/>        let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 4, Constants.MAX_HEIGHT / 2, 50, 50);<br/>        let floor = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, Constants.MAX_HEIGHT - 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/>        let ceiling = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/><br/>        Matter.World.add(world, [bird, floor, ceiling]);<br/><br/>        return {<br/>            physics: { engine: engine, world: world },<br/>            bird: { body: bird, size: [50, 50], color: 'red', renderer: Bird},<br/>            floor: { body: floor, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>            ceiling: { body: ceiling, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>        }<br/>    }</span></pre><p id="0ef8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的就是给物质世界增加两个新的身体:<em class="mb">地板</em>和<em class="mb">天花板</em>。它们类似于鸟，除了它们的<em class="mb"> isStatic </em>属性为真，这告诉物质物理不影响它们。</p><p id="0024" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们的渲染器叫做Wall —让我们来实现它:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="fffb" class="lr ls it ln b gy lt lu l lv lw">import React, { Component } from "react";<br/>import { View } from "react-native";<br/><br/>export default class Wall extends Component {<br/>    render() {<br/>        const width = this.props.size[0];<br/>        const height = this.props.size[1];<br/>        const x = this.props.body.position.x - width / 2;<br/>        const y = this.props.body.position.y - height / 2;<br/><br/>        return (<br/>            &lt;View<br/>                style={{<br/>                    position: "absolute",<br/>                    left: x,<br/>                    top: y,<br/>                    width: width,<br/>                    height: height,<br/>                    backgroundColor: this.props.color<br/>                }} /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="9316" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Wall的代码实际上与Bird完全相同——从技术上讲，它们可能是同一个组件——但我喜欢将它们分开。</p><p id="0066" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，我们有一个红色的正方形自由落体到一个绿色的长方形。让我们实现一些更令人兴奋的东西。如果用户点击屏幕上的任何地方，我们希望我们的鸟改变方向一会儿，并开始向上弹跳。</p><p id="12a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，我们必须修改Physics.js:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="0501" class="lr ls it ln b gy lt lu l lv lw">import Matter from "matter-js";<br/><br/>const Physics = (entities, { touches, time }) =&gt; {<br/>    let engine = entities.physics.engine;<br/>    let bird = entities.bird.body;<br/><br/>    touches.filter(t =&gt; t.type === "press").forEach(t =&gt; {<br/>        Matter.Body.applyForce( bird, bird.position, {x: 0.00, y: -0.10});<br/>    });<br/><br/>    Matter.Engine.update(engine, time.delta);<br/><br/>    return entities;<br/>};<br/><br/>export default Physics;</span></pre><p id="f0c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，这里发生了什么？</p><ul class=""><li id="706d" class="ml mm it kk b kl km ko kp kr mn kv mo kz mp ld mq mr ms mt bi translated">RNGE方便地将所有触摸事件传递给传递给引擎的每个系统。</li><li id="f647" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">因为我们只关心“点击”事件，所以我们需要过滤这些事件。</li><li id="3c1d" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">每当我们遇到一个水龙头，我们施加一个力，我们的鸟的中心与-0.10(稍微向上)。</li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7cad4d63e53a431e09d4532fb6ad5ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*IFVt_aJyb0ojbnDQjR-b3A.gif"/></div></figure><p id="b774" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事情进展顺利。我们来加点障碍吧！</p><p id="9108" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在《Flappy Bird》中，障碍物用管子来表示。一个从顶部，一个从底部，它们之间有恒定的间隙。最初，我将在屏幕上总共添加两组管道(总共四个管道)。一个在屏幕右侧(<code class="fe lx ly lz ln b">Constants.MAX_WIDTH-Constants.PIPE_WIDTH / 2</code>)，另一个在屏幕右侧(<code class="fe lx ly lz ln b">Constants.MAX_WIDTH * 2-(Constants.PIPE_WIDTH / 2</code>)</p><p id="ef74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们在每一次点击时将这些管道向左移动一个像素。如果一组管道移出屏幕，我们将它们向右移动一个屏幕的像素。</p><p id="a3f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">管道的Y位置应该是随机的，所以我们在App.js中定义了两个函数(但是在组件定义之外，因为这些函数可以在以后重用)。</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="9d98" class="lr ls it ln b gy lt lu l lv lw">export const randomBetween = (min, max) =&gt; {<br/>    return Math.floor(Math.random() * (max - min + 1) + min);<br/>}<br/><br/>export const generatePipes = () =&gt; {<br/>    let topPipeHeight = randomBetween(100, (Constants.MAX_HEIGHT / 2) - 100);<br/>    let bottomPipeHeight = Constants.MAX_HEIGHT - topPipeHeight - Constants.GAP_SIZE;<br/><br/>    let sizes = [topPipeHeight, bottomPipeHeight]<br/><br/>    if (Math.random() &lt; 0.5) {<br/>        sizes = sizes.reverse();<br/>    }<br/><br/><br/>    return sizes;<br/>}</span></pre><p id="fa3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这实际上是生成一个由两个数字组成的数组:一个表示顶部管道的高度，一个表示底部管道的高度。</p><p id="0d15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以更新我们的<code class="fe lx ly lz ln b">setupWorld</code>方法了:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="3181" class="lr ls it ln b gy lt lu l lv lw">setupWorld = () =&gt; {<br/>        let engine = Matter.Engine.create({ enableSleeping: false });<br/>        let world = engine.world;<br/><br/>        let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 4, Constants.MAX_HEIGHT / 2, 50, 50);<br/>        let floor = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, Constants.MAX_HEIGHT - 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/>        let ceiling = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/><br/>        let [pipe1Height, pipe2Height] = generatePipes();<br/><br/>        let pipe1 = Matter.Bodies.rectangle( Constants.MAX_WIDTH - (Constants.PIPE_WIDTH / 2), pipe1Height / 2, Constants.PIPE_WIDTH, pipe1Height, { isStatic: true });<br/>        let pipe2 = Matter.Bodies.rectangle( Constants.MAX_WIDTH - (Constants.PIPE_WIDTH / 2), Constants.MAX_HEIGHT - (pipe2Height / 2), Constants.PIPE_WIDTH, pipe2Height, { isStatic: true });<br/><br/>        let [pipe3Height, pipe4Height] = generatePipes();<br/><br/>        let pipe3 = Matter.Bodies.rectangle( Constants.MAX_WIDTH * 2 - (Constants.PIPE_WIDTH / 2), pipe3Height / 2, Constants.PIPE_WIDTH, pipe3Height, { isStatic: true });<br/>        let pipe4 = Matter.Bodies.rectangle( Constants.MAX_WIDTH * 2 - (Constants.PIPE_WIDTH / 2), Constants.MAX_HEIGHT - (pipe4Height / 2), Constants.PIPE_WIDTH, pipe4Height, { isStatic: true });<br/><br/><br/>        Matter.World.add(world, [bird, floor, ceiling, pipe1, pipe2, pipe3, pipe4]);<br/><br/>        return {<br/>            physics: { engine: engine, world: world },<br/>            bird: { body: bird, size: [50, 50], color: 'red', renderer: Bird},<br/>            floor: { body: floor, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>            ceiling: { body: ceiling, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>            pipe1: { body: pipe1, size: [Constants.PIPE_WIDTH, pipe1Height], color: "green", renderer: Wall },<br/>            pipe2: { body: pipe2, size: [Constants.PIPE_WIDTH, pipe2Height], color: "green", renderer: Wall },<br/>            pipe3: { body: pipe3, size: [Constants.PIPE_WIDTH, pipe3Height], color: "green", renderer: Wall },<br/>            pipe4: { body: pipe4, size: [Constants.PIPE_WIDTH, pipe4Height], color: "green", renderer: Wall }<br/>        }<br/>    }</span></pre><p id="e6aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更新Physics.js来移动这些管道:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="7f7f" class="lr ls it ln b gy lt lu l lv lw">import Matter from "matter-js";<br/><br/>const Physics = (entities, { touches, time }) =&gt; {<br/>    let engine = entities.physics.engine;<br/>    let bird = entities.bird.body;<br/><br/>    touches.filter(t =&gt; t.type === "press").forEach(t =&gt; {<br/>        Matter.Body.applyForce( bird, bird.position, {x: 0.00, y: -0.10});<br/>    });<br/><br/>    for(let i=1; i&lt;=4; i++){<br/>        if (entities["pipe" + i].body.position.x &lt;= -1 * (Constants.PIPE_WIDTH / 2)){<br/>            Matter.Body.setPosition( entities["pipe" + i].body, {x: Constants.MAX_WIDTH * 2 - (Constants.PIPE_WIDTH / 2), y: entities["pipe" + i].body.position.y});<br/>        } else {<br/>            Matter.Body.translate( entities["pipe" + i].body, {x: -1, y: 0});<br/>        }<br/>    }<br/><br/>    Matter.Engine.update(engine, time.delta);<br/><br/>    return entities;<br/>};<br/><br/>export default Physics;</span></pre><p id="ba0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我所说的，在每个滴答，我们将管道1px向左移动。如果管道看不见了，我们把它移到右边，给用户一种有无数管道的感觉。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/997bc4fda24125307c9c9a99eac94cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*nOWYYrt1tB3JWDG18znlmA.gif"/></div></figure><p id="e63c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一切都很好，但不完全具有挑战性，考虑到球员不能失败。用Matter.js添加碰撞检测很简单。</p><p id="5cad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe lx ly lz ln b">setupWorld</code>方法中添加这些行</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="3a02" class="lr ls it ln b gy lt lu l lv lw">Matter.Events.on(engine, 'collisionStart', (event) =&gt; {<br/>    var pairs = event.pairs;<br/>    this.gameEngine.dispatch({ type: "game-over"});         <br/>});</span></pre><p id="832b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将设置一个事件侦听器，它将在Matter发出的“collisionStart”事件上被触发。侦听器将使用RNGE的分派方法发出另一个类型为“game-over”的事件</p><p id="0a8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，剩下要做的就是监听这个事件，并在用户失败时在屏幕上显示一个游戏。你可以通过给你的&lt;游戏引擎&gt;添加一个<code class="fe lx ly lz ln b">onEvent</code>道具来收听RNGE事件</p><p id="8734" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终的App.js应该是这样的:</p><pre class="le lf lg lh gt lm ln lo lp aw lq bi"><span id="2f7e" class="lr ls it ln b gy lt lu l lv lw">import React, { Component } from 'react';<br/>import { Dimensions, StyleSheet, Text, View, StatusBar, Alert, TouchableOpacity } from 'react-native';<br/>import Matter from "matter-js";<br/>import { GameEngine } from "react-native-game-engine";<br/>import Bird from './Bird';<br/>import Wall from './Wall';<br/>import Physics from './Physics';<br/>import Constants from './Constants';<br/><br/>export const randomBetween = (min, max) =&gt; {<br/>    return Math.floor(Math.random() * (max - min + 1) + min);<br/>}<br/><br/>export const generatePipes = () =&gt; {<br/>    let topPipeHeight = randomBetween(100, (Constants.MAX_HEIGHT / 2) - 100);<br/>    let bottomPipeHeight = Constants.MAX_HEIGHT - topPipeHeight - Constants.GAP_SIZE;<br/><br/>    let sizes = [topPipeHeight, bottomPipeHeight]<br/><br/>    if (Math.random() &lt; 0.5) {<br/>        sizes = sizes.reverse();<br/>    }<br/><br/><br/>    return sizes;<br/>}<br/><br/>export default class App extends Component {<br/>    constructor(props){<br/>        super(props);<br/><br/>        this.state = {<br/>            running: true<br/>        };<br/><br/>        this.gameEngine = null;<br/><br/>        this.entities = this.setupWorld();<br/>    }<br/><br/>    setupWorld = () =&gt; {<br/>        let engine = Matter.Engine.create({ enableSleeping: false });<br/>        let world = engine.world;<br/>        world.gravity.y = 1.2;<br/><br/>        let bird = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 4, Constants.MAX_HEIGHT / 2, 50, 50);<br/>        bird.restitution = 20;<br/>        let floor = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, Constants.MAX_HEIGHT - 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/>        let ceiling = Matter.Bodies.rectangle( Constants.MAX_WIDTH / 2, 25, Constants.MAX_WIDTH, 50, { isStatic: true });<br/><br/>        let [pipe1Height, pipe2Height] = generatePipes();<br/><br/>        let pipe1 = Matter.Bodies.rectangle( Constants.MAX_WIDTH - (Constants.PIPE_WIDTH / 2), pipe1Height / 2, Constants.PIPE_WIDTH, pipe1Height, { isStatic: true });<br/>        let pipe2 = Matter.Bodies.rectangle( Constants.MAX_WIDTH - (Constants.PIPE_WIDTH / 2), Constants.MAX_HEIGHT - (pipe2Height / 2), Constants.PIPE_WIDTH, pipe2Height, { isStatic: true });<br/><br/>        let [pipe3Height, pipe4Height] = generatePipes();<br/><br/>        let pipe3 = Matter.Bodies.rectangle( Constants.MAX_WIDTH * 2 - (Constants.PIPE_WIDTH / 2), pipe3Height / 2, Constants.PIPE_WIDTH, pipe3Height, { isStatic: true });<br/>        let pipe4 = Matter.Bodies.rectangle( Constants.MAX_WIDTH * 2 - (Constants.PIPE_WIDTH / 2), Constants.MAX_HEIGHT - (pipe4Height / 2), Constants.PIPE_WIDTH, pipe4Height, { isStatic: true });<br/><br/>        Matter.World.add(world, [bird, floor, ceiling, pipe1, pipe2, pipe3, pipe4]);<br/>        Matter.Events.on(engine, 'collisionStart', (event) =&gt; {<br/>            var pairs = event.pairs;<br/><br/>            this.gameEngine.dispatch({ type: "game-over"});<br/><br/>        });<br/><br/>        return {<br/>            physics: { engine: engine, world: world },<br/>            floor: { body: floor, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>            ceiling: { body: ceiling, size: [Constants.MAX_WIDTH, 50], color: "green", renderer: Wall },<br/>            bird: { body: bird, size: [50, 50], color: 'red', renderer: Bird},<br/>            pipe1: { body: pipe1, size: [Constants.PIPE_WIDTH, pipe1Height], color: "green", renderer: Wall },<br/>            pipe2: { body: pipe2, size: [Constants.PIPE_WIDTH, pipe2Height], color: "green", renderer: Wall },<br/>            pipe3: { body: pipe3, size: [Constants.PIPE_WIDTH, pipe3Height], color: "green", renderer: Wall },<br/>            pipe4: { body: pipe4, size: [Constants.PIPE_WIDTH, pipe4Height], color: "green", renderer: Wall }<br/>        }<br/>    }<br/><br/>    onEvent = (e) =&gt; {<br/>        if (e.type === "game-over"){<br/>            //Alert.alert("Game Over");<br/>            this.setState({<br/>                running: false<br/>            });<br/>        }<br/>    }<br/><br/>    reset = () =&gt; {<br/>        this.gameEngine.swap(this.setupWorld());<br/>        this.setState({<br/>            running: true<br/>        });<br/>    }<br/><br/>    render() {<br/>        return (<br/>            &lt;View style={styles.container}&gt;<br/>                &lt;GameEngine<br/>                    ref={(ref) =&gt; { this.gameEngine = ref; }}<br/>                    style={styles.gameContainer}<br/>                    systems={[Physics]}<br/>                    running={this.state.running}<br/>                    onEvent={this.onEvent}<br/>                    entities={this.entities}&gt;<br/>                    &lt;StatusBar hidden={true} /&gt;<br/>                &lt;/GameEngine&gt;<br/>                {!this.state.running &amp;&amp; &lt;TouchableOpacity style={styles.fullScreenButton} onPress={this.reset}&gt;<br/>                    &lt;View style={styles.fullScreen}&gt;<br/>                        &lt;Text style={styles.gameOverText}&gt;Game Over&lt;/Text&gt;<br/>                    &lt;/View&gt;<br/>                &lt;/TouchableOpacity&gt;}<br/>            &lt;/View&gt;<br/>        );<br/>    }<br/>}<br/><br/>const styles = StyleSheet.create({<br/>    container: {<br/>        flex: 1,<br/>        backgroundColor: '#fff',<br/>    },<br/>    gameContainer: {<br/>        position: 'absolute',<br/>        top: 0,<br/>        bottom: 0,<br/>        left: 0,<br/>        right: 0,<br/>    },<br/>    gameOverText: {<br/>        color: 'white',<br/>        fontSize: 48<br/>    },<br/>    fullScreen: {<br/>        position: 'absolute',<br/>        top: 0,<br/>        bottom: 0,<br/>        left: 0,<br/>        right: 0,<br/>        backgroundColor: 'black',<br/>        opacity: 0.8,<br/>        justifyContent: 'center',<br/>        alignItems: 'center'<br/>    },<br/>    fullScreenButton: {<br/>        position: 'absolute',<br/>        top: 0,<br/>        bottom: 0,<br/>        left: 0,<br/>        right: 0,<br/>        flex: 1<br/>    }<br/>});</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a8d5540be2e5908010f894df2ae6dd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*VbwSLB4w-xNXeuJDQhm7Yw.gif"/></div></figure><p id="8b55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是:一个丑陋的，几乎没有功能的flappy鸟克隆体。</p><p id="e976" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让事情变得更好的几个“要做的事”(如果你愿意的话):</p><ul class=""><li id="0bf2" class="ml mm it kk b kl km ko kp kr mn kv mo kz mp ld mq mr ms mt bi translated">目前管道正在重复。每次我们把它们送回屏幕右侧时，应该很容易改变它们的Y位置</li><li id="3155" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">鸟应该根据它前进的方向稍微上下旋转</li><li id="c796" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated">一些图片会让事情变得更令人兴奋(无意冒犯红色方块)</li></ul><p id="dec8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你觉得可以改进，请随时<a class="ae ll" href="https://github.com/lepunk/react-native-videos/tree/master/FlappyBird" rel="noopener ugc nofollow" target="_blank">发送PR/fork回购</a>。</p></div></div>    
</body>
</html>