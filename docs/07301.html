<html>
<head>
<title>Demystify Spring Boot (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Spring Boot的神秘面纱(下)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystify-spring-boot-part-2-dc957069b584?source=collection_archive---------10-----------------------#2020-12-30">https://betterprogramming.pub/demystify-spring-boot-part-2-dc957069b584?source=collection_archive---------10-----------------------#2020-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fce6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Spring中构建一个连接到MariaDB数据库的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d77403e8be7d7b2a124ce526d1744d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XM3MOJ9PYKE_Lofj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jakubkriz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jakub Kriz </a>拍摄</p></figure><p id="b25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spring是一个允许您创建企业级应用程序的框架。问题出现在启动一个初始应用程序需要许多配置的地方。这是Spring Boot出现的地方。</p><blockquote class="lv lw lx"><p id="4911" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“Spring Boot允许你抽象(隐藏)这些配置。因此您可以获得一个预配置的模板应用程序。”— <a class="ae ky" href="https://medium.com/better-programming/demystifying-spring-boot-245e71feffc0" rel="noopener">来自本系列的第1部分</a></p></blockquote><p id="cbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将看到如何在Spring Boot创建Rest API。这个API将是一个CRUD(创建、读取、更新、删除)应用程序，它连接到一个SQL数据库——在本例中是一个MariaDB数据库。</p><p id="9154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是Spring的新手，或者您只是需要复习Spring及其概念，前一篇文章解释了基础知识。</p><div class="mc md gp gr me mf"><a href="https://medium.com/better-programming/demystifying-spring-boot-245e71feffc0" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">揭秘Spring Boot</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">Spring Boot API开发的基础</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="60a8" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">我们开始吧！</h1><p id="91fc" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">首先，我们将创建一个Spring Boot项目。我们将通过前往<code class="fe ny nz oa ob b"><a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a></code>来实现这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/5304d31fbc76fa2652ab93610f7123a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQt4_9iqwTlNBuQm9v1CtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置。作者截图来自<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a>。</p></figure><p id="1c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是您的应用程序所需的配置。</p><p id="e0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意依赖性:</p><ul class=""><li id="cddd" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated">Spring Web:用于创建Web应用程序</li><li id="c83a" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">Spring Data JPA:允许您使用对象与数据库进行交互</li><li id="e37b" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">MySQL驱动程序:为您的应用程序添加对MySQL数据库的支持</li></ul><p id="54bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成此项目。生成项目后，它会以ZIP文件的形式下载下来，您需要解压缩该文件。</p><p id="e62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将在IntelliJ中打开这个项目。IntelliJ应该会自动安装您的依赖项。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="2946" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">连接到数据库</h1><p id="1a48" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">让我们首先将我们的应用程序连接到Spring Boot。首先，我们必须创建我们的数据库。</p><p id="8bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe ny nz oa ob b">employee_management</code>的数据库。</p><p id="2db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用XAMPP附带的MySQL创建我的数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1d58a92fa73c64ba4623d109399e4b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5cH-snYdLKcTUIfz34grw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="4f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要把这个数据库连接到Spring Boot。我们只要进入我们的<code class="fe ny nz oa ob b">application.properties</code>文件就可以做到这一点。在本项目中，它将位于<code class="fe ny nz oa ob b">src</code> &gt; <code class="fe ny nz oa ob b">main</code> &gt; <code class="fe ny nz oa ob b">resources</code>。</p><p id="d311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">application.properties</code>文件是您向Spring Boot应用程序添加配置的地方。在这种情况下，我们将把数据库连接放在其中。</p><p id="472c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>许多配置可以包含在<code class="fe ny nz oa ob b">application.properties</code>文件中。例如，您可以配置应用程序将要驻留的端口号。一个非详尽的列表可以在<a class="ae ky" href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>中找到。</p><p id="0fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接数据库所需的配置来自<code class="fe ny nz oa ob b">spring.datasource.* </code>家族。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是需要放在<code class="fe ny nz oa ob b">application.properties</code>文件中的配置信息。</p><ol class=""><li id="12bf" class="od oe it lb b lc ld lf lg li of lm og lq oh lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">spring.datasource.url</code>:包含数据库的JDBC URL。格式为<code class="fe ny nz oa ob b"> jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;Database&gt;?serverTimezone=&lt;time zone&gt;</code>。</li><li id="eb51" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">spring.datasource.username </code>:数据库的用户名。</li><li id="6894" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">spring.datasource.password</code>:数据库的密码。</li></ol><p id="ffae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们现在有能力与数据库进行交互。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="18cc" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">实体</h1><p id="0ba4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">有了Spring Boot，我们能够用对象和类来操作我们的数据库。我们可以通过类和列的属性来表示我们的表。这种操作是通过使用Spring数据JPA来完成的。</p><p id="ea9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在这个应用程序中实现的第一个表是一个<code class="fe ny nz oa ob b">employee </code>表。</p><p id="8aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先需要在之前创建的数据库中创建<code class="fe ny nz oa ob b">employee </code>表。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="93ec" class="oz nc it ob b gy pa pb l pc pd">create table employee (id int primary key auto_increment, first_name varchar(30),last_name varchar(30),email varchar(30));</span></pre><p id="0c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用上面的脚本来创建我们的<code class="fe ny nz oa ob b">employee</code>表。</p><p id="62df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别注意表的模式(名称和类型)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/8b3534a193ff79ba5b951ec785ba0c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*RgDEzWy9ZHPnyls0I3Su2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><ol class=""><li id="73e1" class="od oe it lb b lc ld lf lg li of lm og lq oh lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">id</code>(主键):<code class="fe ny nz oa ob b">int</code></li><li id="45ba" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">first_name</code> : <code class="fe ny nz oa ob b">varchar</code></li><li id="0248" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">last_name</code> : <code class="fe ny nz oa ob b">varchar</code></li><li id="b6b6" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">email</code> : <code class="fe ny nz oa ob b">varchar</code></li></ol><p id="8e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们创建映射到该表的类时，将需要这些。</p><p id="b877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了表示雇员表，我们将创建一个<code class="fe ny nz oa ob b">Employee </code>类。这些类被称为实体。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/c162f22ed8c3e20ab6b1859bc1744d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*priAU6_xoZTItQ55L-_r4g.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="0e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，该类不是一个实体。为了使它成为一个实体，需要将<code class="fe ny nz oa ob b">@Entity</code>注释添加到类的声明中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/7883cc7d4b11ae82be6b77cb3b3f4108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vAbOOrC_vX3M0QI2rHMuGA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="9c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要在<code class="fe ny nz oa ob b">Employee</code>类中表示<code class="fe ny nz oa ob b">employee</code>表中的不同列。这可以通过在我们的<code class="fe ny nz oa ob b">Employee</code>类中将每个列和类型表示为属性/特性来实现。</p><p id="f53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回忆一下我们的<code class="fe ny nz oa ob b">employee</code>表的模式:</p><ol class=""><li id="e772" class="od oe it lb b lc ld lf lg li of lm og lq oh lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">id</code>(主键):<code class="fe ny nz oa ob b">int</code></li><li id="e152" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">first_name</code> : <code class="fe ny nz oa ob b">varchar</code></li><li id="e33b" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">last_name</code> : <code class="fe ny nz oa ob b">varchar</code></li><li id="f6a8" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">email</code> : <code class="fe ny nz oa ob b">varchar</code></li></ol><p id="f43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些列名将是我们的类属性的名称。我们将把列类型表示为它们的Java等价物。</p><p id="5f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">int</code>在Java中已经是一个类型。对于<code class="fe ny nz oa ob b">varchar</code>，这将使用<code class="fe ny nz oa ob b">String</code>来表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="12b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们完成的<code class="fe ny nz oa ob b">entity</code>类。注意，属性的名称与它们在<code class="fe ny nz oa ob b">employee</code>表中对应的列名相匹配。</p><ol class=""><li id="6e0f" class="od oe it lb b lc ld lf lg li of lm og lq oh lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">id</code> : <code class="fe ny nz oa ob b">id</code></li><li id="8ad6" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">first_name</code> : <code class="fe ny nz oa ob b">firstName</code></li><li id="1eff" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">last_name</code> : <code class="fe ny nz oa ob b">firstName</code></li><li id="ead3" class="od oe it lb b lc om lf on li oo lm op lq oq lu ou oj ok ol bi translated"><code class="fe ny nz oa ob b">email</code> : <code class="fe ny nz oa ob b">email</code></li></ol><p id="6451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，camelCased属性字段，比如<code class="fe ny nz oa ob b">firstName</code>和<code class="fe ny nz oa ob b">lastName</code>字段，分别与<code class="fe ny nz oa ob b">first_name</code>和<code class="fe ny nz oa ob b">last_name</code>列匹配。这是因为SQL是不区分大小写的，为了保持一般的Java惯例，Spring本质上是在将字段连接到表时，将字段中的camelCase转换为下划线分隔的字段。</p><p id="a75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">@Id</code>表示什么属性代表主键。<code class="fe ny nz oa ob b">@GeneratedValue</code>注释用于控制如何生成值。在这种情况下，我们希望ID属性不是输入的，而是自动生成的。为此，我们必须指定我们将使用什么策略来自动生成它。于是，<code class="fe ny nz oa ob b">@GeneratedValue(strategy = GenerationType.<em class="ly">IDENTITY</em>)</code>。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4e0c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">仓库</h1><p id="99cf" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在Spring Boot，存储库是一种用于执行开箱即用的通用数据库操作的服务。这些存储库一旦配置到您的实体，就可以执行基本的CRUD操作。</p><p id="1227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库是由Spring Data JPA依赖项提供的。它为我们提供了一个名为<code class="fe ny nz oa ob b">JpaRepository&lt;T,ID&gt;</code>的类。这个类为我们提供了这些通用的数据库操作。<code class="fe ny nz oa ob b">T</code>是您想要对其执行操作的实体的类型。<code class="fe ny nz oa ob b">ID</code>代表该实体的主键类型。在我们的例子中，我们的实体是类型<code class="fe ny nz oa ob b">Employee</code>，我们的主键是类型<code class="fe ny nz oa ob b">Integer</code>。</p><p id="2652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Spring(甚至Java)中的一些好的实践，我们将创建一个接口并从<code class="fe ny nz oa ob b">JpaRepository&lt;T,ID&gt;</code>继承。这将允许我们对这个<code class="fe ny nz oa ob b">JpaRepository&lt;T,ID&gt;</code>有多种不同的实现。如果有情况发生，我们可以随时更改我们的<code class="fe ny nz oa ob b">JpaRepository&lt;T,ID&gt;</code>，这不会影响我们的申请。你现在还不需要理解这些。只要知道创建接口是最好的。</p><p id="7779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建接口<code class="fe ny nz oa ob b">EmployeeRepository</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/15f67d27e405fae48f0e52c9e4bd40e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PkBfS5KkSy25kVEaIJBu_w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="9612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前所说的，我们将扩展<code class="fe ny nz oa ob b">JpaRepository&lt;T,ID&gt;</code>。在这种情况下，它将是<code class="fe ny nz oa ob b">JpaRepository&lt;Employee,Integer&gt;</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/9687a1213d28ae6d986c5e3836a52b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*B1M40JcqL_-uXFJHXO1B-Q.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者生成的屏幕共享</p></figure><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="53ce" class="oz nc it ob b gy pa pb l pc pd">package com.employee.crudapi;<br/><br/><br/>import org.springframework.data.jpa.repository.JpaRepository;<br/><br/>public interface EmployeeRepository <strong class="ob iu">extends JpaRepository&lt;Employee,Integer&gt;</strong> {<br/>}</span></pre><p id="fc07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上就是全部了！我们的存储库现在已经设置好了，我们现在可以执行CRUD操作了。</p><p id="dd38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经做好了开始创建API的一切准备。为此，我们将创建控制器来处理我们的请求。</p><p id="f748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建我们的<code class="fe ny nz oa ob b">EmployeeController</code>类。</p><p id="dc05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类将是一个rest控制器。rest控制器由<code class="fe ny nz oa ob b">@RestController</code>标注表示。</p><p id="da26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe ny nz oa ob b">EmployeeController</code>类中，我们将从添加我们之前创建的存储库开始。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="f5db" class="oz nc it ob b gy pa pb l pc pd">package com.employee.crudapi;<br/><br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>@RestController<br/>public class EmployeeController {<br/><br/>    <strong class="ob iu">@Autowired<br/>    EmployeeRepository employeeRepository;</strong><br/><br/><br/>}</span></pre><p id="704e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码现在应该看起来像上面的代码片段。这样，我们的存储库就完全实现了。</p><p id="0936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果您不习惯使用Spring语法，这可能看起来有点奇怪。注意，我们不必用类似于<code class="fe ny nz oa ob b">EmployeeRepository employeeRepository = new EmployeeRepository(some argument);</code>的东西来实例化<code class="fe ny nz oa ob b">EmployeeRepository</code>对象。这就是<code class="fe ny nz oa ob b">@Autowired</code>注释的神奇之处。它会检查您的项目，找到与声明匹配的适当类型(类),并使用必要的参数(如果有)自动实例化该对象。这被称为<em class="ly">依赖注入</em>。</p><p id="0399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建第一个端点。这将是一个<code class="fe ny nz oa ob b">/employees</code> GET请求，获取我们的<code class="fe ny nz oa ob b">employee</code>表中的所有雇员。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="8f1d" class="oz nc it ob b gy pa pb l pc pd">@GetMapping("/employees")<br/>public List&lt;Employee&gt; findAll(){<br/><br/>    return employeeRepository.findAll();<br/>}</span></pre><p id="d61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在我们的方法中，我们调用了<code class="fe ny nz oa ob b">employeeRepository.</code>,正如我们之前所说的，我们有现成的CRUD操作。<code class="fe ny nz oa ob b">.findAll()</code>返回所有的实体。在本例中，实体是雇员——这意味着它将返回所有雇员。</p><p id="3736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在Postman中测试这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/3b569487ceb54009df37adf3ffb32592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6ypKj38HNQltV-Hb3CgZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="c4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，目前还没有数据，因为我们还没有添加任何员工记录。让我们添加一个端点，以便向数据库添加数据。</p><p id="a827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个<code class="fe ny nz oa ob b">/employees</code>帖子请求。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="f0af" class="oz nc it ob b gy pa pb l pc pd">@PostMapping("/employees")<br/>public Employee addEmployee(@RequestBody Employee theEmployee) {<br/><br/>    employeeRepository.save(theEmployee);<br/><br/>    return theEmployee;<br/>}</span></pre><p id="8145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe ny nz oa ob b">/employees</code>端点中，我们调用<code class="fe ny nz oa ob b">.save()</code>方法。这将给定的实体添加到我们的数据库中。该实体的类型为<code class="fe ny nz oa ob b">Employee</code>。我们还应该注意到，如果数据库中的一个实体有相同的主键(<code class="fe ny nz oa ob b">@ID</code>)，那么<code class="fe ny nz oa ob b">.save()</code>方法将覆盖它。</p><p id="1da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们通过Postman添加我们的第一个员工。</p><p id="c0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">端点:</strong> <code class="fe ny nz oa ob b">/employees</code></p><p id="dfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求:</strong>发布</p><p id="9c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">正文:</strong></p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="4a33" class="oz nc it ob b gy pa pb l pc pd">{</span><span id="3ead" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Eren",</span><span id="f6af" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Yeager",</span><span id="f161" class="oz nc it ob b gy ph pb l pc pd">"email": "Erene@crudapi.com"</span><span id="f807" class="oz nc it ob b gy ph pb l pc pd">}</span></pre><p id="e300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们发出这个请求。注意，我们不必放置<code class="fe ny nz oa ob b">id</code>,因为我们之前指定它将通过每次递增来自动生成。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="ab3c" class="oz nc it ob b gy pa pb l pc pd">{</span><span id="f171" class="oz nc it ob b gy ph pb l pc pd">"id": 1,</span><span id="4e82" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Eren",</span><span id="3a52" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Yeager",</span><span id="1a72" class="oz nc it ob b gy ph pb l pc pd">"email": "Eren@crudapi.com"</span><span id="a027" class="oz nc it ob b gy ph pb l pc pd">}</span></pre><p id="9c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于我们将如何设置端点，它将返回最近添加的雇员。这表明我们的请求是成功的。</p><p id="500d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再这样做四次，直到我们的数据库中有五个雇员。</p><p id="b3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我们有四个帖子请求。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="3bc6" class="oz nc it ob b gy pa pb l pc pd">{</span><span id="d313" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Mikasa",</span><span id="0e29" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Ackerman",</span><span id="2049" class="oz nc it ob b gy ph pb l pc pd">"email": "Mikasa@crudapi.com"</span><span id="cd70" class="oz nc it ob b gy ph pb l pc pd">}</span><span id="af20" class="oz nc it ob b gy ph pb l pc pd">{</span><span id="ca91" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Armin",</span><span id="73e9" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Arlert",</span><span id="76e5" class="oz nc it ob b gy ph pb l pc pd">"email": "Armin@crudapi.com"</span><span id="8977" class="oz nc it ob b gy ph pb l pc pd">}</span><span id="c64c" class="oz nc it ob b gy ph pb l pc pd">{</span><span id="0b06" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Reiner",</span><span id="ff5e" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Braun",</span><span id="3ccd" class="oz nc it ob b gy ph pb l pc pd">"email": "Reiner@crudapi.com"</span><span id="817b" class="oz nc it ob b gy ph pb l pc pd">}</span><span id="1536" class="oz nc it ob b gy ph pb l pc pd">{</span><span id="ca27" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Erwin",</span><span id="3cea" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Smith",</span><span id="5576" class="oz nc it ob b gy ph pb l pc pd">"email": "Erwin@crudapi.com"</span><span id="7ad0" class="oz nc it ob b gy ph pb l pc pd">}</span></pre><p id="723b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加完所有员工后，我们可以发出<code class="fe ny nz oa ob b">/employees</code> GET请求，查看应用程序中的所有员工。</p><p id="c169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">端点:</strong> <code class="fe ny nz oa ob b">/employees</code></p><p id="bb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求:</strong>得到</p><p id="1870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回应:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="95df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们所有的员工。</p><p id="8993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在能够添加和查看我们所有的员工。然而，在实际的应用程序中，您可能希望搜索单个雇员。</p><p id="48df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe ny nz oa ob b">/employees/{employeeId} </code> GET方法来做这件事。里面是代表我们正在搜索的雇员的变量。</p><p id="98cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法希望我们的代码片段如下:</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="fb10" class="oz nc it ob b gy pa pb l pc pd">@GetMapping("/employees/{employeeId}")<br/>public Employee getEmployee(@PathVariable(name ="employeeId" ) int employeeId  ) {<br/><br/>    Employee theEmployee = employeeRepository.findById(employeeId).get();<br/>    return theEmployee;<br/>}</span></pre><p id="904d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们首先放置了一个<code class="fe ny nz oa ob b">{employeeId}</code>，它是雇员ID的变量占位符。这个变量可以使用<code class="fe ny nz oa ob b">@PathVariable</code>连接，它将您决定使用的变量的名称作为参数——在本例中，它是<code class="fe ny nz oa ob b">employeeId</code>。</p><p id="8116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，类似于<code class="fe ny nz oa ob b">.findAll()</code>，在这种情况下我们使用<code class="fe ny nz oa ob b">.findById</code>，这里我们只需要提供指定的主键(<code class="fe ny nz oa ob b">@ID</code>)。<code class="fe ny nz oa ob b">.findById</code>返回一个名为<code class="fe ny nz oa ob b">Optional&lt;T&gt;</code>的对象。要从中获取对象，请键入<code class="fe ny nz oa ob b">.get()</code>方法。</p><p id="84de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们测试这个端点。</p><p id="c63c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">端点:</strong> <code class="fe ny nz oa ob b">/employees/2</code></p><p id="364f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求:</strong>获取</p><p id="4a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">响应:</strong></p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="0b7a" class="oz nc it ob b gy pa pb l pc pd">{</span><span id="bc53" class="oz nc it ob b gy ph pb l pc pd">"id": 2,</span><span id="bb94" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Mikasa",</span><span id="377f" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Ackerman",</span><span id="8ab9" class="oz nc it ob b gy ph pb l pc pd">"email": "Mikasa@crudapi.com"</span><span id="f34c" class="oz nc it ob b gy ph pb l pc pd">}</span></pre><p id="3356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们愿意，现在可以在我们的系统中查找任何员工。</p><p id="7eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有用的特性是能够删除任何员工。假设一名员工不再在那里工作。</p><p id="deeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe ny nz oa ob b">/employees/{employeeId}</code> DELETE方法来做这件事。</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="2eec" class="oz nc it ob b gy pa pb l pc pd">@DeleteMapping("/employees/{employeeId}")<br/>public String deleteEmployee(@PathVariable(name ="employeeId" ) int employeeId) {<br/><br/>    employeeRepository.deleteById(employeeId);<br/>    return "Delete employee id - "+ employeeId;<br/>}</span></pre><p id="95f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方法，我们使用<code class="fe ny nz oa ob b">.findById</code>找到我们想要删除的员工，它只是用来显示我们想要删除的员工。为了实际删除一个雇员，我们使用了<code class="fe ny nz oa ob b">.deleteById</code>方法，该方法只接受您想要删除的雇员的主键(<code class="fe ny nz oa ob b">@ID</code>)。</p><p id="adc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将删除:</p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="5b92" class="oz nc it ob b gy pa pb l pc pd">{</span><span id="8dc6" class="oz nc it ob b gy ph pb l pc pd">"id": 2,</span><span id="eb65" class="oz nc it ob b gy ph pb l pc pd">"firstName": "Mikasa",</span><span id="d00e" class="oz nc it ob b gy ph pb l pc pd">"lastName": "Ackerman",</span><span id="b236" class="oz nc it ob b gy ph pb l pc pd">"email": "Mikasa@crudapi.com"</span><span id="30e0" class="oz nc it ob b gy ph pb l pc pd">}</span></pre><p id="eee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试用下面的端点删除此记录。</p><p id="b682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">端点:</strong> <code class="fe ny nz oa ob b">/employees/2</code></p><p id="bde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求:</strong>删除</p><p id="0a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回应:</strong></p><pre class="kj kk kl km gt ov ob ow ox aw oy bi"><span id="95ab" class="oz nc it ob b gy pa pb l pc pd">Delete employee id - 2</span></pre><p id="fb35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚删除了一名<code class="fe ny nz oa ob b">id</code>为<code class="fe ny nz oa ob b">2</code>的员工。</p><p id="86dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们检查一下该员工是否真的被删除了。</p><p id="6e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">终点:</strong> <code class="fe ny nz oa ob b">/employees</code></p><p id="c1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求:</strong>获取</p><p id="bfeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回应:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="4e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该员工实际上已被删除！</p><p id="46b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们更新后的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="8027" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="3e0f" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">从上一篇文章中，你学习了Spring Boot的基本知识。现在，有了这些原则，您就可以创建一个连接到数据库的简单CRUD应用程序。</p><p id="efa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://github.com/jordan-medium/Employee-CRUD-API" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p></div></div>    
</body>
</html>