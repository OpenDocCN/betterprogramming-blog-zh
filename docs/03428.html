<html>
<head>
<title>Hands on Go Concurrency With the Producer-Consumer Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产者-消费者模式下的并行操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hands-on-go-concurrency-the-producer-consumer-pattern-c42aab4e3bd2?source=collection_archive---------1-----------------------#2020-02-10">https://betterprogramming.pub/hands-on-go-concurrency-the-producer-consumer-pattern-c42aab4e3bd2?source=collection_archive---------1-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f305" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录以了解关系</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61cfeda061d9a7302901ac4e3d492bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_QlAvDKkLLR7rFJU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">莎士比亚，没有他我的文章是不完整的！(由<a class="ae ky" href="https://unsplash.com/@yessijes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰西卡·潘普</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="91dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去三个月我一直在写围棋。</p><p id="4ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可避免地，我最终了解了Go漂亮的并发原语。</p><p id="77a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如一位智者曾经说过的，“宇宙只不过是一组不同的模式。”因此，我开始研究Go领域中一些常见的并发模式！</p><p id="44b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我想讨论经典的并发模式:<em class="lv">生产者-消费者问题。</em>希望把自己理解的东西固化下来，为自己，也希望为你，建立一个未来的参考。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ba6b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">生产者-消费者问题到底是什么？</h1><p id="67c8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">先来点背景。让我们定义一下我们正在讨论的问题:</p><ul class=""><li id="dd80" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">有一个<em class="lv">生产者</em>即<em class="lv">生产</em>作业。</li><li id="0d1a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">有一个<em class="lv">消费者</em>是<em class="lv">消费</em>他们。</li><li id="4f13" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它们(生产者和消费者)共享一个有限大小的<em class="lv">缓冲区</em>。</li><li id="f5a3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><em class="lv">生产者将其工作放入缓冲区。</em></li><li id="c1b0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">消费者<em class="lv">从缓冲区中获取</em>一个作业，然后<em class="lv">处理</em>该作业。</li></ul><p id="510d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:你可以把生产者/消费者想象成函数，把作业想象成预定的任务或数据，或者传入的请求，或者本质上是许多其他的实体。问题定义中使用的术语是通用的，您可以将它们映射到许多不同的场景。</p><p id="8936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到问题上。</p><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们想同步生产者和消费者之间的关系。如果缓冲区还有一些剩余空间，生产者可以将作业放入其中。类似地，如果缓冲区有一个或多个未消耗的作业，消费者可以选择并处理它们。</p><p id="1512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是要确保消费者永远不会试图从一个空的缓冲区消费，生产者永远不会试图将作业放入一个满满的缓冲区。此外，生产者和消费者访问缓冲区的方式应该是安全的，不能危及缓冲区上的任何状态或数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7b2e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">戈朗对问题的回答</h1><p id="0392" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在大学，我在操作系统课程中学习了这些并发模式。课程是艰难的。然后，加上我们必须使用C++ <code class="fe no np nq nr b">pthread</code>库来完成这些实验作业的事实。</p><p id="38fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多语言，如Java或C++，都有这种用<em class="lv">线程</em>来处理并发的概念。我想，作为Golang的读者，你至少多少意识到了这一点。虽然您当然可以使用它们来满足您的并发需求，但是线程通常很难使用。</p><p id="20c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang采用了不同的方法来回答并发性的终极问题。如你所知，围棋有<em class="lv"> goroutines </em>和<em class="lv">通道</em>。</p><p id="19c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何解决Golang的生产者-消费者问题呢？在这篇文章中，我们将看看四种不同的变化。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5a85" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单一生产者和单一消费者</h1><p id="47ea" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们试着理解最简单的场景——一个生产者发送消息，一个消费者接收消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">一个建议:你会发现在打开两个浏览器窗口的情况下阅读这篇文章的其余部分很方便——一个窗口包含上面的代码，另一个显示下面的解释。</em></p><p id="9cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我来试着解释一下上面的代码。</p><ul class=""><li id="e36a" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">声明了两个不同的通道，一个能够处理字符串，另一个用于布尔值。</li><li id="80b0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们为每个函数运行两个独立的<em class="lv">例程</em>:<code class="fe no np nq nr b">producer</code>和<code class="fe no np nq nr b">consumer</code>。</li><li id="55d0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe no np nq nr b">producer</code>简单地将消息从全局声明的数组发送到通道<code class="fe no np nq nr b">link</code>。在成功发送所有消息后(没有陷入死锁或进入睡眠状态)，它在<code class="fe no np nq nr b">close(link)</code>关闭通道。</li><li id="e614" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">那么，<code class="fe no np nq nr b">consumer</code>内部发生了什么？<code class="fe no np nq nr b">Consumer</code>正在接收来自<code class="fe no np nq nr b">link</code>通道的消息。Go中通道的一个特点是它们可以通过<code class="fe no np nq nr b">range</code>被<em class="lv">迭代</em>。因此，当一个通道关闭时，我们可以在该通道上迭代以接收值。迭代继续，直到通道关闭。Go中频道的这一功能相当方便。</li><li id="feb9" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果您还不知道，在封闭通道上接收返回两个值:<code class="fe no np nq nr b">zero value</code>和<code class="fe no np nq nr b">false</code>。<code class="fe no np nq nr b">zero value</code>不是数字<code class="fe no np nq nr b">0 </code> —它是通道正在处理的相应数据类型的零值。<code class="fe no np nq nr b">false</code>是指出通道不再打开。这里有一篇关于这方面的简明文章:<a class="ae ky" href="https://dave.cheney.net/2014/03/19/channel-axioms" rel="noopener ugc nofollow" target="_blank">戴夫·切尼的渠道公理</a>。</li><li id="4c06" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">请注意，我们的通道<code class="fe no np nq nr b">link</code>是一个<em class="lv">无缓冲</em>通道。它只是在<code class="fe no np nq nr b">producer</code>和<code class="fe no np nq nr b">consumer</code>之间充当一个<em class="lv">链接器</em>。从信道的基本知识中你已经知道，<code class="fe no np nq nr b">producer</code>不能通过<code class="fe no np nq nr b">link</code>发送下一条消息，除非它已经消耗了上一条发送的消息。</li><li id="f5c7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">因此，当<code class="fe no np nq nr b">producer</code>关闭第32行的通道时，意味着消息发送成功，所以关闭是安全的。</li><li id="ca86" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">那<code class="fe no np nq nr b">done</code>频道呢？如你所知，围棋为<code class="fe no np nq nr b">main</code>产生了一个goroutine。这个主goroutine不会等待任何其他go routine完成。但是我们不希望这样——我们希望我们的生产者——消费者做好他们的工作。所以，我们使用<code class="fe no np nq nr b">done</code>通道来确保主<code class="fe no np nq nr b">goroutine </code>只能在其他完成时退出。在第47行，主goroutine被阻塞，直到有人通过<code class="fe no np nq nr b">done</code>通道发送一个值，这样它就可以立即接收和退出。该值由<code class="fe no np nq nr b">consumer</code>在线路39上发送。</li></ul><p id="b923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常简单明了。我们来看第二个。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="16f1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单一生产者多重消费者</h1><p id="10b0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">第二个变化是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">这些“信息”包含了一段美丽节目《机器人先生》中的引言。如果你没有，那就去看看吧！</em></p></figure><p id="55d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下代码。这与我们上一个例子非常相似，除了我们运行多个Goroutines。这是唯一的区别。输出示例:</p><pre class="kj kk kl km gt nv nr nw nx aw ny bi"><span id="4188" class="nz me it nr b gy oa ob l oc od">Message "just one big hoax." is consumed by worker 1.<br/>Message "The world itself's" is consumed by worker 3.<br/>Message "masquerading as insight, our social media" is consumed by worker 3.<br/>Message "Spamming each other with our" is consumed by worker 2.<br/>Message "running commentary of bullshit," is consumed by worker 1.<br/>Message "Not with our rigged elections," is consumed by worker 1.<br/>Message "but with our things, our property, our money." is consumed by worker 1.<br/>Message "I'm not saying anything new." is consumed by worker 1.<br/>Message "We all know why we do this," is consumed by worker 1.<br/>Message "faking as intimacy." is consumed by worker 3.<br/>Message "books make us happy," is consumed by worker 3.<br/>Message "but because we wanna be sedated." is consumed by worker 3.<br/>Message "Because it's painful not to pretend," is consumed by worker 3.<br/>Message "because we're cowards." is consumed by worker 3.<br/>Message "Or is it that we voted for this?" is consumed by worker 2.<br/>Message "not because Hunger Games" is consumed by worker 1.</span></pre><p id="41a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所知，由于Goroutines固有的不可预测性，每次运行相同的代码都会产生不同的输出结果，就像我们的生活一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/3f63aac68795c3e7c27d35f277677fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ck_5KrcOybCAt4M8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dwntara?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞维里努斯·德万塔拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8ec2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单一消费者多重生产者</h1><p id="d4a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">是时候看看我们的第三个变化了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样本输出:</p><pre class="kj kk kl km gt nv nr nw nx aw ny bi"><span id="6c67" class="nz me it nr b gy oa ob l oc od">Producer 1 sending message "but with our things, our property, our money."<br/>Producer 1 sending message "I'm not saying anything new."<br/>Consumed message "but with our things, our property, our money."<br/>Consumed message "I'm not saying anything new."<br/>Producer 0 sending message "The world itself's"<br/>Producer 1 sending message "We all know why we do this,"<br/>Producer 2 sending message "masquerading as insight, our social media"<br/>Producer 0 sending message "just one big hoax."<br/>Producer 3 sending message "but because we wanna be sedated."<br/>Consumed message "The world itself's"<br/>Consumed message "We all know why we do this,"<br/>Consumed message "masquerading as insight, our social media"<br/>Consumed message "just one big hoax."<br/>Consumed message "but because we wanna be sedated."<br/>Producer 3 sending message "Because it's painful not to pretend,"<br/>Producer 3 sending message "because we're cowards."<br/>Consumed message "Because it's painful not to pretend,"<br/>Consumed message "because we're cowards."<br/>Producer 3 sending message "- Elliot Alderson"<br/>...(truncated)</span></pre><p id="afb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们浏览一下代码:</p><ul class=""><li id="5e27" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">正如你所看到的，我们有一个2D字符串的消息。这只是为了模拟这样一个事实，即每个生产者都有一组专用的消息要发送给消费者。他们每个人从自己的消息池中选取一条消息——我们有四个生产者，所以有四个消息池。</li><li id="b0a6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在主函数中，我们现在有了一个<code class="fe no np nq nr b">WaitGroup</code>。我假设你知道Go的<code class="fe no np nq nr b">sync</code>包。我们使用这个是出于通常的原因——等待制作人Goroutines完成。当我们等待的时候，Goroutines成功地完成了他们的工作，我们可以关闭67行的<code class="fe no np nq nr b">jobs</code>频道。</li><li id="c306" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">你可能会立即想到的问题是<em class="lv">为什么我们不从生产商内部关闭渠道？</em>很明显——当你有多个go routine时，你不知道它们中的哪一个会最后结束，所以从<code class="fe no np nq nr b">produce</code>方法关闭<code class="fe no np nq nr b">jobs</code>通道是不安全的——这基本上会在一些go routine完成它们的<em class="lv">职责线</em>之前关闭通道。</li><li id="3c71" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">很简单，<code class="fe no np nq nr b">produce</code>函数为每个单独的生产者Goroutine产生工作。我们将它传递给我们的<code class="fe no np nq nr b">jobs</code>渠道，让消费者提货。</li><li id="cc4f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">就像前面的例子一样，<code class="fe no np nq nr b">consume</code>函数使用消息和信号<code class="fe no np nq nr b">done</code>。</li></ul><p id="18d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候进入我们的最后一个变体了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/39e6b329ed7fb4c1e50927871dc0b8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5nKtR26lVD7us9oI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timtrad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·特拉德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9b54" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">多生产者多消费者</h1><p id="eef4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我给你们看两个版本。第一个现在应该很容易理解了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ab72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用两个<code class="fe no np nq nr b">WaitGroups</code>。我们等待制片人结束，然后关闭频道。然后，最后，我们等待消费者完成。看一下示例输出:</p><pre class="kj kk kl km gt nv nr nw nx aw ny bi"><span id="b090" class="nz me it nr b gy oa ob l oc od">Message "The world itself's" is consumed by consumer 1<br/>Message "but because we wanna be sedated." is consumed by consumer 2<br/>Message "Because it's painful not to pretend," is consumed by consumer 2<br/>Message "masquerading as insight, our social media" is consumed by consumer 0<br/>Message "faking as intimacy." is consumed by consumer 0<br/>Message "I'm not saying anything new." is consumed by consumer 0<br/>Message "Spamming each other with our" is consumed by consumer 0<br/>Message "because we're cowards." is consumed by consumer 0<br/>Message "- Elliot Alderson" is consumed by consumer 0<br/>Message "Mr. Robot" is consumed by consumer 0<br/>Message "just one big hoax." is consumed by consumer 2<br/>Message "but with our things, our property, our money." is consumed by consumer 1<br/>...(truncated)</span></pre><p id="69b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候看看我们的最终代码了——这是<em class="lv">实现上述内容的另一种方式:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="06e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要一些解释:</p><ul class=""><li id="2adb" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">我们在这里想做什么？目的是避免使用<code class="fe no np nq nr b">WaitGroup</code>。一般来说，Go的<code class="fe no np nq nr b">sync</code>包提供了对低级并发原语的支持。在上面的代码中，我们尽量保持在<code class="fe no np nq nr b">channels</code>内部。</li><li id="be38" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">这是好的做法吗？我们应该避免使用<code class="fe no np nq nr b">sync</code>包吗？我不知道。把它想成是解决同一个问题的不同方法。</li></ul><p id="a082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是代码。这个有点长，和其他的不一样。让我解释一下:</p><p id="6387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:以上代码中的任何</em> <code class="fe no np nq nr b"><em class="lv">worker</em></code> <em class="lv">均指生产者。</em></p><ul class=""><li id="572f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">我们声明了一个包含三个不同字段的<code class="fe no np nq nr b">type producers struct</code>:<code class="fe no np nq nr b">myQ</code>、<code class="fe no np nq nr b">quit</code>和<code class="fe no np nq nr b">id</code>。把<code class="fe no np nq nr b">myQ</code>想象成一个由制片人自己拥有的频道。所以如果我们声明一个<code class="fe no np nq nr b">producers struct</code>的数组，那么它们每个都会有自己交换字符串的通道。<code class="fe no np nq nr b">quit</code>通道用于安全退出每个制作人。最后，<code class="fe no np nq nr b">id</code>只是一个标识。</li><li id="5ad7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们在80线有一个交换<code class="fe no np nq nr b">*producers</code>的通道。注意这里声明的<code class="fe no np nq nr b">workerPool</code>是指针的通道，不是实际值。我们还有一个<code class="fe no np nq nr b">jobQ</code>通道，用于向制片人发送工作，还有一个<code class="fe no np nq nr b">allDone</code>通道，用于在一切完成后安全退出。</li><li id="e61a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">你可能想知道为什么我们使用一个渠道来发送工作。难道它本身就不会表现出生产者的行为吗？这是一个很好的问题，事实上，这只是模仿了这样一个事实，即生产者可能从一些外部来源生产工作，对它们进行处理，然后将它们发送给消费者。</li><li id="501c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们在第82行创建一些生产者，在第88行生成我们的Goroutines。我们也为消费者做类似的事情。</li><li id="f298" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在中间，在第91行，我们运行我们的<code class="fe no np nq nr b">execute</code>函数。这就像一个管理程序——它通过<code class="fe no np nq nr b">jobQ</code>发送任务，关闭任务，给每个工人发信号<code class="fe no np nq nr b">quit</code>，关闭<code class="fe no np nq nr b">workerPool</code>通道，最后，发信号通知<em class="lv">一切都完成了</em>。</li><li id="1dd5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">是时候看看<code class="fe no np nq nr b">produce</code>功能了。我们在这里利用Golang的<code class="fe no np nq nr b">select case</code>陈述。如你所知，<code class="fe no np nq nr b">select</code>会执行第一个非阻塞通道，即使前面几个都在阻塞。</li><li id="e27f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在我们的<code class="fe no np nq nr b">select</code>块的第一个例子中，生产者Goroutine试图接收来自<code class="fe no np nq nr b">jobQ</code>的消息。如果是这样，它将一个指向自己实体的指针传递给<code class="fe no np nq nr b">workerPool</code>。仔细想想——<em class="lv">它本质上是通过</em> <code class="fe no np nq nr b">workerPool</code> <em class="lv">来传递自身的。</em></li><li id="1c92" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在第58行，消息被发送到<code class="fe no np nq nr b">producer p</code>自己的通道。</li><li id="4719" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们也在<code class="fe no np nq nr b">p</code>的<code class="fe no np nq nr b">quit</code>频道收听。每当这里接收到一个值，Goroutine就返回。</li><li id="4a94" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">现在来了<code class="fe no np nq nr b">consume</code>函数。它只是从<code class="fe no np nq nr b">workerPool</code>中选取一个<code class="fe no np nq nr b">*producer</code>，并在其通道上迭代。</li><li id="2cf7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">本质上，为了避免使用<code class="fe no np nq nr b">WaitGroup</code>，这在我们的例子中要简单得多，我们将每个生产者视为一个单独的实体来通过一个通道。我们的消费者选择一个随机的生产者，迭代生产者的<code class="fe no np nq nr b">myQ</code>，然后消费。</li><li id="4764" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">正如我们前面提到的，<code class="fe no np nq nr b">execute</code>函数试图优雅地停止一切。</li></ul><p id="d4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码的输出示例:</p><pre class="kj kk kl km gt nv nr nw nx aw ny bi"><span id="adb5" class="nz me it nr b gy oa ob l oc od">Job "The world itself's" produced by worker 0<br/>Job "Spamming each other with our" produced by worker 2<br/>Job "just one big hoax." produced by worker 1<br/>Message "The world itself's" is consumed by consumer 0 from worker 0<br/>Job "running commentary of bullshit," produced by worker 2<br/>Message "just one big hoax." is consumed by consumer 1 from worker 1<br/>Job "masquerading as insight, our social media" produced by worker 0<br/>Message "running commentary of bullshit," is consumed by consumer 0 from worker 2<br/>Job "faking as intimacy." produced by worker 1<br/>Message "masquerading as insight, our social media" is consumed by consumer 1 from worker 0<br/>Job "Or is it that we voted for this?" produced by worker 2<br/>Message "Or is it that we voted for this?" is consumed by consumer 1 from worker 2<br/>Job "Not with our rigged elections," produced by worker 0<br/>Message "faking as intimacy." is consumed by consumer 0 from worker 1<br/>Message "Not with our rigged elections," is consumed by consumer 1 from worker 0<br/>Job "I'm not saying anything new." produced by worker 2<br/>Job "but with our things, our property, our money." produced by worker 1<br/>Message "Spamming each other with our" is consumed by consumer 2 from worker 2<br/>...(truncated)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a014" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="30a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我忘记之前，这里发布的最后一个代码有一些值得注意的问题。我想讨论一下。但相反，你为什么不停下来好好想想呢？思考这些代码的问题，以及我们如何解决它们。这将是一个很好的事情弄清楚。</p><p id="33c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果你有任何不同的方法来为上面讨论的模式编写代码，请在评论中与我们联系。</p><p id="e38a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望我的解释足够清楚。</p><p id="eac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有趣。在写这篇文章的时候，我有机会对Go对并发性的支持进行了调整。我希望你也玩得开心！</p><p id="3f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="53eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，考虑订阅我推荐的媒体！<a class="ae ky" href="https://medium.com/subscribe/@mottakin" rel="noopener">https://medium.com/subscribe/@mottakin</a></p></div></div>    
</body>
</html>