<html>
<head>
<title>Introduction to CSS Custom Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS自定义属性介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-css-custom-properties-66b9474d3012?source=collection_archive---------3-----------------------#2019-12-24">https://betterprogramming.pub/introduction-to-css-custom-properties-66b9474d3012?source=collection_archive---------3-----------------------#2019-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们应该使用<em class="ki"> CSS自定义属性</em>而不是预处理程序吗？嗯，看情况</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/535f5d08c08d7e65f81f53719814d94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTX-DDsK4cwbEY7wakpCFg.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae kz" href="https://unsplash.com/s/photos/palette?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="97e5" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">简短的历史课</h1><p id="48f4" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">自1994年提出并于1996年在网络的摇篮CERN首次发布以来，级联样式表(CSS)从简单样式的静态描述发展成为现代网页设计的基石。</p><p id="9dc9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">甚至追溯到1996年，样式表的概念并不是一个新的想法。自从<a class="ae kz" href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" rel="noopener ugc nofollow" target="_blank">标准通用标记语言(SGML) </a>以来，它们就以某种形式存在了，但是它们没有被用于web。与今天相比，功能集非常有限:</p><ul class=""><li id="5e58" class="mt mu it lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">颜色；色彩；色调</li><li id="5369" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">字体属性和字体</li><li id="0411" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">文本属性(例如，单词/字母间距)</li><li id="0d2e" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">边缘相关属性(例如，边距、填充、边框)</li><li id="5576" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">对齐</li></ul><p id="680c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">它真正的第一个继任者CSS 2.1在2004年成为W3C候选推荐标准。又过了七年，它终于在2011年成为W3C推荐标准，尽管之前它是通过浏览器的方式使用和实现的。尽管CSS 2已经存在，但2.1版本对其进行了改进，删除了支持不佳或被社区拒绝的功能，并加入了浏览器已经实现的功能。</p><p id="3e88" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">从1999年开始，下一个版本CSS 3被开发出来。为了更好地理解和分离CSS规范，它引入了模块的概念。它的一些模块仍在工作草案中，但它们已经被广泛使用，如果没有它们，网络将不再一样。</p><ul class=""><li id="307d" class="mt mu it lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><a class="ae kz" href="http://www.w3.org/TR/css3-selectors/" rel="noopener ugc nofollow" target="_blank">三级选择器</a>(如属性选择器:<code class="fe nh ni nj nk b">[attr^=val]</code>)</li><li id="ae3d" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout" rel="noopener ugc nofollow" target="_blank">柔性框布局(flexbox) </a></li><li id="7f18" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><a class="ae kz" href="http://www.w3.org/TR/css3-mediaqueries/" rel="noopener ugc nofollow" target="_blank">媒体查询</a></li><li id="7a24" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><a class="ae kz" href="http://www.w3.org/TR/css3-background/" rel="noopener ugc nofollow" target="_blank">改进的背景和边框</a></li><li id="1bb9" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><a class="ae kz" href="http://www.w3.org/TR/css3-color" rel="noopener ugc nofollow" target="_blank">更多颜色系统</a>(例如，rgba、hsl、hsla、渐变)</li><li id="432b" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">…以及更多</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/33e0f5f323347e5c14f758e1494ed307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CB__pRpcDWGVJEdbO8UW3Q.png"/></div></div></figure><h1 id="d15d" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">需要更灵活的解决方案</h1><p id="7e97" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">CSS的目的是用来描述网页内容的表现，而不是作为一种编程语言。动态特性非常有限。重用样式和创建基本选择器通常意味着复制粘贴，或者改变父子关系，这会损害<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="noopener ugc nofollow" target="_blank">选择器的特异性</a>。不支持基类或变量意味着改变可能会影响整个CSS文件，如果需求改变，很容易遗漏一些东西。</p><p id="9b02" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">为了弥补这些缺点，CSS预处理器被创造出来，最著名的是<a class="ae kz" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank">萨斯/SCSS </a>、<a class="ae kz" href="http://lesscss.org/" rel="noopener ugc nofollow" target="_blank"> LESS </a>、<a class="ae kz" href="http://stylus-lang.com/" rel="noopener ugc nofollow" target="_blank">手写笔</a>和<a class="ae kz" href="https://postcss.org/" rel="noopener ugc nofollow" target="_blank"> PostCSS </a>。</p><p id="3b29" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">所有这些预处理程序都试图通过提供新功能来提高CSS开发人员的UX，这些新功能有时采用类似CSS的语法(例如，SCSS、Less、PostCSS)，有时采用“改进的”语法(例如，Sass、Stylus)。通过将CSS转换成完整的编程语言，许多动态和方便的功能变得可用，使它更具可读性和更易于维护:</p><ul class=""><li id="caa6" class="mt mu it lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">变量</li><li id="c3d0" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">嵌套选择器</li><li id="6af3" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">函数/混合/继承</li><li id="7c01" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">颜色操作(例如，变暗、变亮、色调改变)</li><li id="4895" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">逻辑运算符(if-else)，循环</li><li id="5cf2" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">进口</li><li id="5bd0" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">…以及更多</li></ul><p id="e29a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是预处理程序最大的缺点就在它的名字上:它需要经过<em class="nm"> pre </em>处理才能交付给客户机。这意味着我们需要某种资产管道，或者至少是构建环境中的特定任务，来处理CSS。这些不能在运行时动态改变，并且不知道DOM的结构，导致了词汇范围的变量和相当静态的CSS。此外，CSS预处理程序也没有标准，它们彼此之间也不(完全)兼容。</p><p id="4d6b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我们项目中更多的齿轮需要维护，可能会损坏。</p><p id="aabf" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">一个更好的方法是直接与客户端兼容的更动态的CSS，因此不需要额外的步骤。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="2a06" class="la lb it bd lc ld nu lf lg lh nv lj lk jz nw ka lm kc nx kd lo kf ny kg lq lr bi translated">自定义CSS属性</h1><p id="00b3" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">2015年，模块<em class="nm">级联变量的CSS自定义属性模块级别1 </em>成为W3C候选推荐。该模块引入了所有CSS属性都可以接受的级联变量。与预处理器相比，该特性集似乎过于简单，但它们仍然能够完成预处理器的许多功能。它们不是为了复制预处理器的某些功能，而是为了实现以前不可能实现的工作流——即使有预处理器的帮助。</p><h2 id="5b28" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">申报</h2><p id="6a97" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">变量的一般语法是<code class="fe nh ni nj nk b">--*</code>。它们必须在CSS选择器中定义，并且具有与任何其他属性相同的级联语义。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4dee" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我们可以使用CSS支持的每一个属性值，比如颜色、大小、<code class="fe nh ni nj nk b">url(...)</code>、<code class="fe nh ni nj nk b">inherit</code> / <code class="fe nh ni nj nk b">unset</code> / <code class="fe nh ni nj nk b">initial-value</code>等等。</p><h2 id="5225" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">使用</h2><p id="4745" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">对变量的访问由<code class="fe nh ni nj nk b">var(...)</code>功能授予:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="29f3" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">计算</h2><p id="3f9f" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">还支持<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" rel="noopener ugc nofollow" target="_blank">calc(...)</a></code>函数及其所有运算符(<code class="fe nh ni nj nk b">+</code>、<code class="fe nh ni nj nk b">-</code>、<code class="fe nh ni nj nk b">*</code>、<code class="fe nh ni nj nk b">/</code>):</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="6373" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">范围</h2><p id="9ec0" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">如前所述，定制属性的作用域是默认继承和级联的，就像标准的CSS属性一样，而不是像预处理变量一样在词汇上有作用域。</p><p id="3164" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">为了在全局范围内创建一个对所有后代都可用的变量，可以使用<code class="fe nh ni nj nk b">:root</code>伪类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9572" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">通过作用域，我们还可以构建易于修改的规则集:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b0b7" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">随着<code class="fe nh ni nj nk b">.monochrome</code>变得更加<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="noopener ugc nofollow" target="_blank">特定</a>，我们可以修改一个锚点并得到单色调色板。</p><h2 id="c694" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">媒体查询</h2><p id="82dc" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">当然，范围/继承也可以用于媒体查询，使响应设计变得容易:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5d8f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">但是要注意一个限制——变量<em class="nm">不能用于媒体查询中的值:</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5a39" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">乍一看，这似乎很奇怪，但很容易解释。媒体查询不是选择器，也不会通过层叠来继承任何属性。</p><h2 id="50cc" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">默认值</h2><p id="2977" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">默认值是受支持的，并且是修改某些选择器的好方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="c037" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我们甚至不需要事先声明<code class="fe nh ni nj nk b">--color</code>。只要有一个带有合理默认值的工作的<code class="fe nh ni nj nk b">.my-class</code>,并且有机会通过在另一个选择器中重新分配属性来修改它。</p><p id="7b84" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">由于CSS的级联性质，我们还可以使用默认值实现主题化，并通过HTML激活特定的值，甚至在客户端也是如此:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="647b" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">内嵌CSS</h2><p id="1fbc" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">变量也可以内联设置，这是从外部修改样式的好方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4dfc" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在HTML中，我们可以用<code class="fe nh ni nj nk b">style</code>属性覆盖<code class="fe nh ni nj nk b">--color</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="f687" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">动态更新</h2><p id="0985" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">一个很大的区别(与预处理器相比)是对值变化的处理。预处理程序需要在处理过程中计算所有值；该值将是静态的。这就是为什么在使用后重新赋值没有效果:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a6ca" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><em class="nm"> CSS自定义属性</em> cascade值发生变化，所有相关的属性都会即时更新:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="498b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">结合内联样式，我们可以动态地重新分配和重新计算CSS属性。</p><h2 id="ac05" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">Java Script语言</h2><p id="fc8a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><code class="fe nh ni nj nk b">window</code>-对象提供函数<code class="fe nh ni nj nk b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle" rel="noopener ugc nofollow" target="_blank">getComputedStyle(element [, pseudoElt])</a></code>，该函数返回当前计算的元素样式。</p><p id="874e" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">改变变量就像设置一个<em class="nm">标准</em>属性:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="1524" class="la lb it bd lc ld nu lf lg lh nv lj lk jz nw ka lm kc nx kd lo kf ny kg lq lr bi translated">最佳实践</h1><h2 id="3afc" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">值&gt;变量</h2><p id="bb45" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">更改变量的值比创建另一个变量更好:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="489c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我们应该改变已经存在的变量，而不是引入另一个变量:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2935" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如果我们不需要在一个地方声明所有变量，只在<code class="fe nh ni nj nk b">.my-class</code>中使用，我们可以进一步缩短CSS:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="32ae" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">变量应该是“可变的”</h2><p id="4a96" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">不是所有的事情都是可变的。不要陷入过早的优化，让每一个属性都成为在<code class="fe nh ni nj nk b">:root</code>中定义的变量，以防将来你可能想要改变它。</p><p id="404a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">变量的良好候选是实际上正在变化的属性，或者是由于外部约束，如媒体查询，或者是内部需求，如伪类(例如，悬停状态)，或者是主题化组件。</p><h2 id="501e" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">关注点分离</h2><p id="4341" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">有了自定义属性，我们最终可以将内容的设计与实际的布局逻辑分离开来:</p><p id="81c8" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">媒体查询不应再改变任何标准的CSS属性。应该只更改自定义属性的值。</p><p id="d69b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这样，我们可以在文档的顶部声明所有的变量，以及它们的修改媒体查询。默认值和属性如何改变的逻辑是文件中首先可见的东西。实际的设计没有逻辑，可以很容易地阅读，没有任何复杂性或隐藏的惊喜。</p><h2 id="db83" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">范围界定和命名</h2><p id="a9dd" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">像所有编程语言一样，我们必须考虑我们想要什么范围，以及我们实际上需要什么。过大的范围会污染变量空间并产生副作用，但过小的范围会限制变量的可重用性。并非所有东西都需要在<code class="fe nh ni nj nk b">:root</code>中，但是我们需要在级联选择器树中找到一个变量的最佳位置来实现它的目的。</p><p id="7aa9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">由于级联性质，实际范围可能与我们想象的不同。为了不意外地通过重用名称覆盖任何属性，我们应该坚持命名约定。用大写的<em class="nm"/>命名全局作用域的变量，或者至少用大写的首字母命名，可以清楚地知道如何使用它们。</p><p id="17d4" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">全局范围的变量也应该被视为静态值。如果我们需要改变一个全局值，我们可以在一个更窄的范围内把它重新赋值给另一个变量。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="b624" class="la lb it bd lc ld nu lf lg lh nv lj lk jz nw ka lm kc nx kd lo kf ny kg lq lr bi translated">警告</h1><p id="d24a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">每一个闪亮的新玩具都有一些缺点。<em class="nm"> CSS自定义属性</em>也不例外。</p><h2 id="0c45" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">浏览器支持</h2><p id="e645" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">具有讽刺意味的是，唯一不支持CSS的相关浏览器是第一个支持CSS的商业浏览器:Internet Explorer。</p><p id="864e" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">取决于目标受众，这可能是一个交易破坏者，但是如果我们仍然想要支持Internet Explorer，有多个JavaScript polyfill选项可用(<a class="ae kz" href="https://jhildenbiddle.github.io/css-vars-ponyfill/#/" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae kz" href="https://github.com/nuxodin/ie11CustomProperties" rel="noopener ugc nofollow" target="_blank"> 2 </a>)。</p><p id="84f0" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">除了IE11，浏览器支持都很优秀:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi on"><img src="../Images/98c781e9c2a49704d9cc315a3bcfef83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxVq0RwKru7oI5rNHXmlfQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://caniuse.com/#feat=css-variables" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/#feat=css-variables</a>—2019–12–23</p></figure><h2 id="57f0" class="nz lb it bd lc oa ob dn lg oc od dp lk mb oe of lm mf og oh lo mj oi oj lq ok bi translated">缺失功能</h2><p id="f3a1" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">与预处理程序相比，CSS自定义属性缺少多个功能。以下是最重要的缺失特征(在我看来):</p><p id="eaf9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">嵌套选择器</strong>:通过更好地可视化组件的树形结构，嵌套选择器可以极大地提高可读性。可悲的是，CSS自定义属性仍然是CSS，不支持嵌套选择器。</p><p id="2af4" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu"> Mixins </strong>:一组可以在另一个选择器中重用的CSS声明。</p><p id="e0fb" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">函数</strong>:预处理器中包含了字符串操作的助手，支持变量列表，可以循环等等。</p><p id="6a54" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">导入</strong>:能够用预处理程序将CSS分成多个文件，但仍然只有一个优化的输出文件，这将改善任何项目的结构。有了CSS自定义属性，我们也可以把CSS拆分成多个文件但是需要用<code class="fe nh ni nj nk b">&lt;link&gt;</code>标签分别加载，这不如单个文件好，至少没有HTTP/2。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="a9a7" class="la lb it bd lc ld nu lf lg lh nv lj lk jz nw ka lm kc nx kd lo kf ny kg lq lr bi translated">结论</h1><p id="4fab" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们应该使用CSS自定义属性而不是CSS预处理程序吗？嗯，看情况。</p><p id="de73" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">能够放弃CSS的资产管道是很棒的！可能损坏的东西越来越少，但是我们错过了一些很棒的功能。另一方面，我们获得了强大的客户端动态样式，这是用预处理器无法实现的，并且它将与CSS的未来添加兼容。</p><p id="27ae" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">我不建议用自定义属性替换任何现有的预处理样式，因为我们可以这样做，但是，可以考虑在一个新项目中尝试一下。混合两种CSS处理方式可能会产生新的问题，应该避免，或者至少相应地分开。</p><p id="24d9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">例如，我们的一个项目使用定制的SASS管道，通过编译带有修改变量的源SASS文件来创建与项目相关的主题，从而动态地修改多个引导版本。如果我们必须用CSS自定义属性重做项目，我们仍然会使用SASS进行引导，但会尝试对任何新开发的组件使用CSS自定义属性。</p><p id="d509" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">不是CSS自定义属性vs. CSS预处理程序。明智地选择你的工具。两者都有不完全一致的存在理由。因此，在不同的方面使用这两者可能是一个可行的解决方案。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oo"><img src="../Images/c0ccc9050e9229dd22d99ba1faeb2613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaumlzwQgwIGFYknw893Mw.png"/></div></div></figure><h1 id="2a56" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="d662" class="mt mu it lu b lv lw ly lz mb op mf oq mj or mn my mz na nb bi translated">CSS自定义属性是用实际的动态运行时样式替换或扩充编译时资产管道的好方法。</li><li id="3146" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">预处理器可能有更多的特性，但也有缺点，比如维护一个资产管道，它可能随时改变或中断。</li><li id="d286" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">只对实际的动态样式使用CSS自定义属性，并从将它们重构为变量中获益良多。仅仅通过添加一个内联样式就可以在客户端与我们的样式进行交互，这带来了许多新的可能性。</li><li id="763f" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">对于静态样式，使用静态CSS，甚至可以预处理。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="d0ee" class="la lb it bd lc ld nu lf lg lh nv lj lk jz nw ka lm kc nx kd lo kf ny kg lq lr bi translated">资源</h1><ul class=""><li id="79bf" class="mt mu it lu b lv lw ly lz mb op mf oq mj or mn my mz na nb bi translated"><a class="ae kz" href="https://caniuse.com/#feat=css-variables" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/#feat=css-variables</a></li><li id="2b1b" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">【https://developer.mozilla.org/en-US/docs/Web/CSS/-*】【T2 T3】</li><li id="9139" class="mt mu it lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">【https://www.w3.org/TR/css-variables-1/ T4】</li></ul></div></div>    
</body>
</html>