<html>
<head>
<title>Clean and Scalable Architecture in Android and KMM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android和KMM中干净且可扩展的架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-setup-a-clean-and-scalable-architecture-in-android-and-kotlin-for-multiplatform-mobile-apps-eeba0948545c?source=collection_archive---------5-----------------------#2022-08-16">https://betterprogramming.pub/how-to-setup-a-clean-and-scalable-architecture-in-android-and-kotlin-for-multiplatform-mobile-apps-eeba0948545c?source=collection_archive---------5-----------------------#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3971" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您轻松开发的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c146757e1d3c8c8f92ca98e530a309b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnSQRivx6jLLlVOOXKrFGQ.png"/></div></div></figure><p id="c113" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于我们应该选择哪种架构，以及我们为什么需要架构，诸如此类，一直存在公开的争论。在Android开发中，人们总是在选择MVVM、MVP和MVC架构时感到困惑。</p><p id="73e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是没错。大多数人选择MVVM是因为模型-视图-视图-模型的关系。但实际上，选择其中任何一个都不是强制性的。您可以尝试适合您需求的架构。在这里，我们将针对一个适合大型项目并充分利用开发能力的架构设计。最后，你会发现你所遵循的架构没有你自己的好。所以，让我们来揭开建筑的秘密。</p><p id="40fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很多人认为我们应该写干净的代码。当然，我们应该。但是如果我们不理解干净的代码原则，它将成为一个严重的问题/bug。因为在编写干净的代码时，我们只考虑通过将一些代码放入单独的类来最小化代码。</p><p id="ed64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你是一名Android开发人员，在将代码放入单独的类时应该小心。因为它伴随着线程安全、内存泄漏、并行执行问题等代价。还有，在Android里，大部分东西都是用上下文的。将上下文传递给另一个类是一种不好的做法。</p><h1 id="ce52" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">干净的架构和模块化</h1><p id="c0e1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Clean architecture以更简单和可扩展的形式解决了项目的复杂性。在clean architecture中，我们将应用程序的代码库分成不同级别/范围的不同层。通过使用可靠的原则，我们可以使它更加美观和可伸缩。坚实的原则是包括如下问题的设计原则</p><ul class=""><li id="7252" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">组件可扩展吗？</li><li id="6cc7" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">DI是如何管理的？</li><li id="29f4" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">什么样的模式用于防止复杂性？</li><li id="3d08" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">组件如何共享代码，以何种方式共享？</li></ul><p id="02c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模块化是一种将层/特性分成模块的技术。通过使用多模块架构，复杂的项目可以很容易地转换成可读性更强、可测试、可重用和可伸缩的形式。并提高梯度构建性能。</p><p id="47d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干净的架构和模块化都有助于新团队成员轻松理解代码流。它使采用过程变得顺利和容易。</p><h1 id="f5ff" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">通用架构原则</h1><p id="ebeb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">随着Android应用程序规模的增长，设计允许应用程序扩展、增加应用程序的健壮性并使应用程序更容易测试的架构非常重要。这里有一些我们可以遵循的设计原则来设计我们的应用程序:</p><h2 id="179d" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">逻辑分离</h2><p id="891a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">将所有代码都写在一个活动或片段中是一个常见的错误。我们应该尝试将一些代码分离到其他类中，以使它们可重用和可读。但这并不意味着我们必须将所有代码放到其他类中。在分离代码时，您应该非常小心地传递上下文，正确地注册或取消注册回调，并避免分离特定于活动/片段的API相关代码。</p><p id="4986" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，尝试使用Kotlin设计模式，如<code class="fe nk nl nm nn b">Factory</code>、<code class="fe nk nl nm nn b">Builder</code>等。如果你在考虑<code class="fe nk nl nm nn b">Singleton</code>模式，是的，你也可以用这个。但这也带来了复杂测试、线程安全等代价。</p><h1 id="56fe" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">用户界面和数据模型</h1><p id="d9cc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这是我们应该遵循的最重要的设计之一。从一个清晰的角度来看，我们应该将网络和本地数据模型分开，保持一个用于网络，另一个用于本地。这将使您免于在<code class="fe nk nl nm nn b">UI</code>中呈现过多不必要的数据。与其共享从<code class="fe nk nl nm nn b">ViewModel</code>直接到<code class="fe nk nl nm nn b">UI</code>的数据模型，我们应该试着只共享只保存有初始值的<code class="fe nk nl nm nn b">UI</code>特定数据的状态。</p><p id="b54f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一般来说，我们将验证放在<code class="fe nk nl nm nn b">activity</code>、<code class="fe nk nl nm nn b">fragment</code>和<code class="fe nk nl nm nn b">Viewmodel</code>中，但实际上，这是非常糟糕的做法。为了解决这个问题，我们应该创建一个<code class="fe nk nl nm nn b">validation </code>助手或者<code class="fe nk nl nm nn b">usecase</code>类来验证输入。此外，我们应该尝试只在存储库中进行映射，而不是在<code class="fe nk nl nm nn b">viewmodel</code>或<code class="fe nk nl nm nn b">activity/fragment</code>中。</p><h1 id="b8e0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">真理的单一来源</h1><p id="fdca" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当一个新的数据类型在你的应用中被定义时，你应该给它分配一个单一的真实来源(SSOT)。SSOT是该数据的所有者，只有SSOT可以修改或改变它。为了实现这一点，SSOT使用不可变类型公开数据，而为了修改数据，SSOT公开函数或接收其他类型可以调用的事件。</p><p id="63bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一般来说，在应用程序中，我们有数据库和网络数据源。为了实现SSOT，我们获取网络数据并将其插入到一个不能直接访问<code class="fe nk nl nm nn b">UI</code>的数据库中。为了访问数据，<code class="fe nk nl nm nn b">UI </code>将只使用数据库。</p><h1 id="ba3a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">公开数据</h1><p id="45e7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在定义新的数据类型时，您不应该将网络数据直接暴露给<code class="fe nk nl nm nn b">UI</code>。在进行API调用时，您应该只将<code class="fe nk nl nm nn b">UI</code>状态或<code class="fe nk nl nm nn b">UI</code>相关的数据模型暴露给表示层。通过增加不变性，它使得<code class="fe nk nl nm nn b">UI</code>只关注一个角色——读取和显示数据。</p><p id="2b32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，除非<code class="fe nk nl nm nn b">UI</code>本身是其数据的唯一来源，否则不应该直接修改<code class="fe nk nl nm nn b">UI</code>中的<code class="fe nk nl nm nn b">UI</code>状态。我们最常犯的错误是将可变数据共享给<code class="fe nk nl nm nn b">UI</code>，或者直接通过params将数据从<code class="fe nk nl nm nn b">UI</code>传递给<code class="fe nk nl nm nn b">ViewModel</code>。</p><h1 id="0812" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">秘密</h1><p id="afea" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">让我们实践一下包括模块化在内的清晰的可扩展架构。首先，让我分享一些关于在建筑中保持整洁的技巧:</p><ol class=""><li id="4b03" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm no mq mr ms bi translated">这是一个基于Kotlin-DSL的模块，为Kotlin的Gradle脚本提供外部支持。在<code class="fe nk nl nm nn b">buildSrc</code>中，我们在Gradle脚本之外定义属性，然后在Gradle脚本中使用它们，而不会陷入混乱。</li></ol><p id="1cf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们使用<code class="fe nk nl nm nn b">buildSrc</code>时<code class="fe nk nl nm nn b">build.gradle.kts</code>的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5d10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于<code class="fe nk nl nm nn b">buildSrc</code>的实现，可以简单地创建一个名为<code class="fe nk nl nm nn b">buildSrc</code>的目录。在<code class="fe nk nl nm nn b">buildSrc</code>内部，创建<code class="fe nk nl nm nn b">src/main/java</code>目录。同样，创建<code class="fe nk nl nm nn b">build.gradle.kts</code>并添加<code class="fe nk nl nm nn b">kotlin-dsl</code>作为插件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="31a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并创建一个名为<code class="fe nk nl nm nn b">Libs.kt</code>的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="63bb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Kotlin中的扩展函数</h1><p id="4dd6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Kotlin是一种强大的语言，拥有许多功能，如高阶函数、智能转换、内联或中缀函数等。扩展函数使代码更加整洁，可读性更强。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="c026" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">构建器模式</h2><p id="a9ed" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">构建器模式是最漂亮的模式之一。您必须遵循干净架构的设计模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="b823" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">用例</h1><p id="84fb" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">用例是将复杂逻辑转换成更简单和可重用代码的最佳方式。一般来说，<code class="fe nk nl nm nn b">usecase</code>定义了单个数据操作。它没有自己的生命周期。这意味着您可以在应用程序的任何地方调用它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="83c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">领域层的用例必须是主安全的；换句话说，从主线程调用它们必须是安全的。如果用例类执行长时间运行的阻塞操作，它们负责将逻辑移动到适当的线程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="8daa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">多层干净的建筑</h1><p id="298f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在深入研究项目结构之前，让我们先了解一下架构的层次。我们通常有三层:数据、领域和表现。</p><h1 id="a978" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">数据层</h1><p id="29bd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">数据层是业务逻辑的一部分。它包括本地存储或缓存、网络、模型和映射器等。它管理数据操作，如从网络或本地数据库获取数据。</p><p id="796e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们为网络和数据库定义单独的数据源，这是一个很好的实践。通常，我们会陷入合并网络和数据库数据源的混乱中。我们应该像下面这样定义单独的数据源:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f7df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，当涉及到业务模型时，我们应该按照网络和本地数据库的情况来区分这些模型，如下所示:</p><h2 id="a81a" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">利益</h2><ol class=""><li id="d211" class="mk ml iq kt b ku mf kx mg la nr le ns li nt lm no mq mr ms bi translated">防止可空数据</li><li id="4e61" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm no mq mr ms bi translated">轻松映射</li><li id="dcee" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm no mq mr ms bi translated">降低注释的复杂性。</li><li id="3b78" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm no mq mr ms bi translated">有时，我们的屏幕不需要来自网络模型的全部数据。在这种情况下，我们可以只向<code class="fe nk nl nm nn b">UI</code>提供需要的数据。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c689" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在进行API调用或任何本地数据库操作时，对主线程来说应该是安全的。使用<code class="fe nk nl nm nn b">DI</code>注射<code class="fe nk nl nm nn b">CoroutineDispatcher</code>是一个很好的练习。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="941e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时，我们需要内存缓存来保存数据。假设为<code class="fe nk nl nm nn b">News</code>应用程序引入了一个新的需求:当用户打开屏幕时，如果之前有请求，缓存的新闻必须呈现给用户。否则，应用程序应该请求网络获取最新新闻。</p><p id="f4c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过添加内存中的数据缓存，您可以在用户在您的应用程序中时保留数据。缓存是为了在特定时间内将一些信息保存在内存中——在这种情况下，只要用户在应用程序中。使用Kotlin协同程序中的互斥体，我们可以锁定线程安全的写操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="343f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设用户在网络请求过程中导航离开屏幕，它将被取消，并且结果不会被缓存。在这种情况下，您可以在某个外部协程范围内进行API调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="898e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">畴层</h1><p id="38e0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">领域层负责封装复杂的业务逻辑。它使用一个可重用的<code class="fe nk nl nm nn b">usecase</code>或<code class="fe nk nl nm nn b">interactor</code>来连接<code class="fe nk nl nm nn b">UI</code>和数据层，这些数据可以很容易地被多个数据提供者重用，比如<code class="fe nk nl nm nn b">viewmodel</code>。<code class="fe nk nl nm nn b">Usecase</code>负责单一数据操作，如从用户处获取数据、将数据插入本地数据库、验证输入类型等。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="900a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以使用一些基本的<code class="fe nk nl nm nn b">interactor</code>或<code class="fe nk nl nm nn b">usecase</code>类，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="581f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用<code class="fe nk nl nm nn b">Interactor</code>作为基类，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="d925" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">表示层</h1><p id="e3b1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">表示层也称为<code class="fe nk nl nm nn b">UI</code>层。它负责在屏幕上显示应用程序数据。简单地说，它处理应用程序的<code class="fe nk nl nm nn b">UI</code>部分。在表示层，<code class="fe nk nl nm nn b">UI</code>将事件触发到viewmodel或其他源，反之亦然。</p><p id="3799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一些你应该知道的原则:</p><h2 id="05ea" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">用户界面状态</h2><p id="9562" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">将来自<code class="fe nk nl nm nn b">viewmodel</code>或其他来源的数据直接暴露给<code class="fe nk nl nm nn b">UI</code>层是一种不好的做法。与其用多个状态或属性来更新<code class="fe nk nl nm nn b">UI</code>，不如考虑建立一个只保存必需的<code class="fe nk nl nm nn b">UI</code>数据的单一状态模型。这样做的主要好处是<code class="fe nk nl nm nn b">UI</code>能够专注于读取数据这一角色，而不是写入或映射数据。</p><p id="44d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，你不应该直接修改<code class="fe nk nl nm nn b">UI</code>中的<code class="fe nk nl nm nn b">UI</code>状态，除非<code class="fe nk nl nm nn b">UI</code>本身是其数据的唯一来源。应该只允许数据的来源或所有者更新数据，而不是直接更新<code class="fe nk nl nm nn b">UI</code>。</p><h2 id="3d4d" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">公开数据</h2><p id="0a8a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您应该考虑<code class="fe nk nl nm nn b">UI</code>状态的不变性，因为将更新/写数据的权利直接暴露给<code class="fe nk nl nm nn b">UI</code>并不是一个好主意。这个原则的关键是，只允许向其所有者公开数据，而不是<code class="fe nk nl nm nn b">UI</code>。</p><p id="600d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个使用状态、组合流、管理<code class="fe nk nl nm nn b">UI</code>消息等的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="f013" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">模块化</h1><p id="879d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在不断增长的代码库中，可伸缩性、可读性、可测试性和整体代码质量通常会随着时间的推移而下降。这是由于代码库的规模不断扩大，而维护人员却没有采取积极的措施来加强易于维护的结构。模块化是一种以提高可维护性和帮助避免这些问题的方式构建代码库的方法。</p><p id="3efc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模块化是一种将代码库组织成松散耦合的独立部分的实践。每个部分都是一个模块。每个模块都是独立的，有明确的用途。</p><p id="89b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在模块化中，根据特性或架构层将应用程序划分为不同的模块取决于您。在某些时候，您可能会对选择模块分离感到困惑。你应该用架构层的特性来区分它。但是每个特征模块不应该依赖于其他特征模块。你应该尽可能保持它的独立性。它提高了模块的可重用性。</p><p id="c7b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在模块化中，每个功能模块不能与其他功能模块直接通信。实际上，<code class="fe nk nl nm nn b">App</code>模块拥有app所有模块的访问权限。</p><h1 id="52bd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">模块化实践</h1><p id="f763" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以遵循一些实践、想法和解决方案来创建具有模块化的可伸缩架构。</p><ol class=""><li id="4fe4" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm no mq mr ms bi translated">管理数据库:你可能会想，我们可以根据app特性拥有多个数据库吗？或者我们应该只为一个应用程序保存一个数据库吗？作为解决方案，您可以采用这两种方法。这取决于你的应用需求。如果您的应用程序需要与数据库表连接相关的数据，您不应该使用多数据库方法。如果您的应用程序不必处理多个数据库的表连接，您可以轻松地采用多数据库方法。</li><li id="881e" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm no mq mr ms bi translated">应用程序导航:在处理应用程序导航时，你应该保持一个中心位置，在那里你所有的导航屏幕被组合在一起，以制作令人敬畏的应用程序导航。您可以选择<code class="fe nk nl nm nn b">App Module</code>作为中心位置，并在此轻松管理您的应用导航。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="eac9" class="my lo iq bd lp mz na dn lt nb nc dp lx la nd ne lz le nf ng mb li nh ni md nj bi translated">良好的结构就是一切</h2><p id="847f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在采用干净架构的同时，你应该把你的app分成多个层次，做出一个好的项目结构。</p><p id="5801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不浪费你的时间，让我们直接进入项目结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c85d8d4f6bfe4a2bd2a66b40c5bf7a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVeWaYgbMVen89HOj-oROg.png"/></div></div></figure><div class="nv nw gp gr nx ny"><a href="https://github.com/Mukuljangir372/NFT-App" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub——mukuljangir 372/NFT——App:NFT App是建立在模块化和干净……</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">NFT应用程序是一个开源项目，基于模块化和android上干净的现代架构——GitHub…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><p id="380e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道你也在为Kotlin多平台手机寻找一个项目结构。别担心。我也有一个很好的项目结构。您可以对以前的项目模块进行小的更改，并将其转换为KMM结构。你可以看看我的KMM项目作为参考。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/Mukuljangir372/SpaceX-Kotlin-Multiplatform-Mobile" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-mukuljangir 372/SpaceX-kot Lin-多平台-移动:该项目包括kotlin…</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">该项目包括kotlin多平台移动设备，包括Android和/或IOS中使用的最新APIs技术。— GitHub …</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kp ny"/></div></div></a></div></div></div>    
</body>
</html>