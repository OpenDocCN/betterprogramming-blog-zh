<html>
<head>
<title>Rust: Ownership and Borrowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈:所有权和借款</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-ownership-and-borrowing-9cf7f081ade0?source=collection_archive---------5-----------------------#2020-01-14">https://betterprogramming.pub/rust-ownership-and-borrowing-9cf7f081ade0?source=collection_archive---------5-----------------------#2020-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它们是什么，我们如何使用它们？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2d7f9b492bf9b93ecb9eb0d99d59fc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gjx7l5IwyOqzulXyua_z_g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@amyhirschi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾米·赫斯基</a>在<a class="ae kv" href="https://unsplash.com/s/photos/own?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2e22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在学习<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>并做了一些关于<code class="fe ls lt lu lv b">Ownership</code>和<code class="fe ls lt lu lv b">Borrowing</code>概念的笔记。</p><p id="a590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在“与Rust借用检查器战斗”的同时，我仍在努力掌握这些概念…</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="84ee" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">生锈的所有权</h1><p id="0e78" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">所有权=值与变量的绑定/关联。规则是:</p><ul class=""><li id="639a" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">一次只能有一个主人。</li><li id="87d2" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">如果绑定被“释放”，则所有权“消失”，数据被“释放”。</li></ul><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="0308" class="ns me iq lv b gy nt nu l nv nw">let p1 = Person::new(); //1<br/>p2 = p1; //2</span><span id="6320" class="ns me iq lv b gy nx nu l nv nw">let p1 = Person::new();<br/>do_something(p1); //out of scope</span></pre><p id="6a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在2号线上，<code class="fe ls lt lu lv b">p1</code>将被释放。它不在范围内，因为它已经将所有权转移给了<code class="fe ls lt lu lv b">p2</code>。将<code class="fe ls lt lu lv b">p1</code>传递给另一个函数也有同样的效果。</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="c0e7" class="ns me iq lv b gy nt nu l nv nw">let p1 = Person::new();<br/>p2 = p1;<br/>println!("person {#:?}", p2)<br/>println!("person {#:?}", p1) //compile error</span></pre><p id="1fda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是Rust不允许您再次使用该值的原因。它在编译时使用借位检查器强制实现这一点。</p><h2 id="7e63" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><code class="fe ls lt lu lv b"><strong class="ak">Drop</strong></code></h2><p id="493c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果需要自定义清理逻辑，可以从<code class="fe ls lt lu lv b">Drop</code>特征实现<code class="fe ls lt lu lv b">drop</code>方法。当该值超出范围时，Rust会自动调用它</p><p id="5ba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦一个变量超出了作用域，也就是说，它的所有权被放弃了，Rust编译器就不允许你再使用它，因为它需要被“释放”。这也叫<code class="fe ls lt lu lv b">Moving</code>，即<code class="fe ls lt lu lv b">p1</code>的所有权移到了<code class="fe ls lt lu lv b">p2</code>。</p><p id="ab48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有权仅适用于堆数据，<em class="oj">不适用于</em>堆栈数据，因为它(堆栈数据)是“复制的”，而不是“移动的”。</p><h2 id="9d3e" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><code class="fe ls lt lu lv b"><strong class="ak">Copy</strong></code></h2><p id="7fb9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">特性<code class="fe ls lt lu lv b">Copy</code>允许复制一个值。所有的原始类型(如<code class="fe ls lt lu lv b">i32</code>、<code class="fe ls lt lu lv b">bool</code>等)。)隐式实现<code class="fe ls lt lu lv b">Copy</code>。</p><p id="6d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义类型(如<code class="fe ls lt lu lv b">struct</code> s)可以实现<code class="fe ls lt lu lv b">Copy</code>，如果其所有组件也实现<code class="fe ls lt lu lv b">Copy</code>。要实现，您可以使用<code class="fe ls lt lu lv b">#[derive(Copy)]</code>或使用显式实现</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1637" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">转让所有权的方式</h1><p id="a669" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">让编译器开心。</p><ul class=""><li id="4424" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">使用<code class="fe ls lt lu lv b">clone()</code>方法。</li><li id="8aed" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">从函数返回。</li><li id="c181" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">传递引用。</li><li id="c06f" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">传递可变引用。</li></ul><h2 id="bc5e" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><strong class="ak">使用克隆()</strong></h2><p id="93c0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">可以把它想象成一个类似于<code class="fe ls lt lu lv b">deep copy</code>的操作，它在堆上创建一个单独的数据副本，并把新的所有者指向它，而旧的值保持不变(或不动)。</p><p id="95ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些类型默认实现了<code class="fe ls lt lu lv b">Clone</code>特征(例如<code class="fe ls lt lu lv b">String</code>，但是您可以使用<code class="fe ls lt lu lv b">#[derive(Clone)]</code>将您的定制类型标记为可克隆的。</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="5a53" class="ns me iq lv b gy nt nu l nv nw">let p1 = Person::new();<br/>let p2 = p1.clone();<br/>do_something(p2);<br/>println!("{:?}, p1); //works ok</span></pre><h2 id="98b1" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><strong class="ak">从功能</strong>返回</h2><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="00f9" class="ns me iq lv b gy nt nu l nv nw">let p1 = Person::new();<br/>do_something(p1);<br/>...</span><span id="c797" class="ns me iq lv b gy nx nu l nv nw">fn do_something(p: Person) -&gt; Person {<br/>//logic<br/>}</span><span id="d628" class="ns me iq lv b gy nx nu l nv nw">...</span><span id="08fa" class="ns me iq lv b gy nx nu l nv nw">println!("p = {}",p1); //continue using p1 since ownership has been passed back</span></pre><p id="2333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这太奇怪了。你被迫返回一些东西，只是因为你想保持变量在范围内</p><h2 id="713f" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><strong class="ak">传递参考</strong></h2><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="2923" class="ns me iq lv b gy nt nu l nv nw">let p1 = Person::new();<br/>do_something(&amp;p1);<br/>println!("p = {}",p1); //continue using p1 since ownership has been was never passed on<br/>...</span><span id="fe4f" class="ns me iq lv b gy nx nu l nv nw">fn do_something(p: &amp;Person) {<br/>//logic<br/>}</span><span id="d5db" class="ns me iq lv b gy nx nu l nv nw">...</span></pre><p id="cc1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">p1</code>的值没有<em class="oj">不动</em>——这叫<code class="fe ls lt lu lv b">Borrowing</code>。<code class="fe ls lt lu lv b">do_something</code>从未获得所有权，因为我们所做的只是传递一个对<code class="fe ls lt lu lv b">p1</code>的引用——请注意<code class="fe ls lt lu lv b">&amp;</code>。</p><h2 id="94d9" class="ns me iq bd mf ny nz dn mj oa ob dp mn lf oc od mp lj oe of mr ln og oh mt oi bi translated"><strong class="ak">可变引用</strong></h2><p id="85f7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果您想让<code class="fe ls lt lu lv b">do_something</code>逻辑更新<code class="fe ls lt lu lv b">Person</code>引用的名称，您需要传递一个可变引用。</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="3146" class="ns me iq lv b gy nt nu l nv nw">let mut p1 = Person::new();<br/>do_something(&amp;mut p1);<br/>println!("mutated info {}",p2)<br/>...</span><span id="f575" class="ns me iq lv b gy nx nu l nv nw">fn do_something(p: &amp;mut Person, new_name: String) {<br/>   p.name = String::from(new_name);<br/>}<br/>...</span></pre><p id="7af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变化:</p><ul class=""><li id="2b86" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">变量<code class="fe ls lt lu lv b">p1</code>被声明为<code class="fe ls lt lu lv b">mut</code>(可变的)。</li><li id="f1c6" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">将<code class="fe ls lt lu lv b">&amp;mut</code>传递给<code class="fe ls lt lu lv b">do_something</code>而不仅仅是<code class="fe ls lt lu lv b">&amp;</code>——表示可变引用。</li><li id="b830" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe ls lt lu lv b">do_something</code>签名更新为<code class="fe ls lt lu lv b">&amp;mut</code> —表示可变引用。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1ff7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="c0d3" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了更深入，你可以阅读《Rust编程语言》 一书中的以下章节。</p><ul class=""><li id="9098" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="noopener ugc nofollow" target="_blank">第四章</a> —所有权和借款</li><li id="30fe" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html" rel="noopener ugc nofollow" target="_blank">第十章</a> —生命周期</li><li id="daa1" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html" rel="noopener ugc nofollow" target="_blank">第十五章</a> —智能指针</li></ul></div></div>    
</body>
</html>