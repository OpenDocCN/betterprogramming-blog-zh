<html>
<head>
<title>Styled Components: A CSS-in-JS Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">样式化组件:一种CSS-in-JS方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/styled-components-a-css-in-js-approach-755f6a196c42?source=collection_archive---------14-----------------------#2020-07-21">https://betterprogramming.pub/styled-components-a-css-in-js-approach-755f6a196c42?source=collection_archive---------14-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ebd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Create React应用程序中采用样式化组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5000babe4d0969137defb79d995f8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-Rjx8JX-QyZmafHXkqN5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mcarsience_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Meagan car science</a>在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ce16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">标记的模板文字</a>和CSS的威力，<a class="ae ky" href="https://github.com/styled-components/styled-components" rel="noopener ugc nofollow" target="_blank">样式化组件</a>让我们编写CSS代码来样式化组件。</p><p id="e852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种CSS-in-JS方法——一个JavaScript库，它将每个JavaScript组件与其所有的CSS规则和依赖项捆绑在一起。因此，组件可以独立运行，不依赖任何外部CSS文件。</p><p id="0847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是styled components的联合创始人马克斯·斯托伊伯在2019年2月的一段话:</p><blockquote class="lv lw lx"><p id="4251" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">三年来，我在没有任何<code class="fe mc md me mf b">.css</code>文件的情况下设计了我的网络应用。相反，我用JavaScript编写了所有的CSS。</p></blockquote><p id="af92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样式组件与React(针对web)和React Native都兼容。我们将使用<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a>来展示如何使用样式化组件。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="02c0" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建不带样式的React应用程序</h1><p id="b83b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这是您在Create React应用程序中看到的内容——一个大头针标识和一些文本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe mc md me mf b">src/App.css</code>文件，它设计了应用程序的样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在下面的<code class="fe mc md me mf b">src/App.js</code>中注释掉第三行，我们会看到什么？：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="0cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到创建不带样式的React应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/af55a1bb8f85c819e2176605f8af680e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1eNFRyHcX1TtJM1dufnnw.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="609c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建样式化组件</h1><p id="fa28" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们将使用样式组件来重建Create React应用程序。第一步是用命令<code class="fe mc md me mf b">npm i styled-components</code>安装。<code class="fe mc md me mf b">styled-components</code>在<code class="fe mc md me mf b">package.json</code>中成为<code class="fe mc md me mf b"><a class="ae ky" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="f865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mc md me mf b">src/App.css</code>中，<code class="fe mc md me mf b">App-header</code>类的样式如下:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="1063" class="ns mo it mf b gy nt nu l nv nw">.App-header {<br/>  background-color: #282c34;<br/>  min-height: 100vh;<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>  justify-content: center;<br/>  font-size: calc(10px + 2vmin);<br/>  color: white;<br/>}</span></pre><p id="3f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">styled-components</code>里是怎么写的？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="46e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要从<code class="fe mc md me mf b">styled-components</code>导入<code class="fe mc md me mf b">styled</code>(第三行)。<code class="fe mc md me mf b">styled</code>是一个低级工厂创造的<code class="fe mc md me mf b">styled.tagname</code>助手方法。这里，模板文字用于创建一个组件，该组件将呈现具有某些样式的DOM元素。在本例中，我们在第五行创建了一个名为<code class="fe mc md me mf b">AppHeader</code>的组件。它由<code class="fe mc md me mf b">styled</code>定义，后跟一个句点和元素名称<code class="fe mc md me mf b">header</code>。详细的样式在第5-14行用反斜线引用。</p><p id="abce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第19行的<code class="fe mc md me mf b">header</code>标记被我们刚刚创建的<code class="fe mc md me mf b">AppHeader</code>组件替换。确保样式化组件是大写的，以便React可以将它们识别为自定义组件。</p><p id="d06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe mc md me mf b">AppHeader</code>是由一个样式化组件进行样式化的，所以第19行不再需要<code class="fe mc md me mf b">className</code>。</p><p id="1b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了部分样式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/16c410c8b26da4495126f0c8488149ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IBjRhBObNCd_4k7zQ3shw.png"/></div></div></figure><p id="9fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切水平居中，设置背景色，文字信息为白色。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5703" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">构建更多样式的组件</h1><p id="7b3e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们继续为<code class="fe mc md me mf b">div</code>和<code class="fe mc md me mf b">a</code>标签构建样式化组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="cb87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">AppDiv</code>在第五行创建，样式在第5-7行。<code class="fe mc md me mf b">AppDiv</code>在第26行将<code class="fe mc md me mf b">div</code>替换为<code class="fe mc md me mf b">className</code>。</p><p id="d776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">AppLink</code>在第20行创建，样式在第20-22行。第32行<code class="fe mc md me mf b">AppLink</code>替换<code class="fe mc md me mf b">a</code>为<code class="fe mc md me mf b">className</code>。</p><p id="85d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多的东西被设计成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/733284df30363641897ad210b37a6a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87Xyk1PzJgHHUGrGiaJ8lQ.png"/></div></div></figure><p id="810b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe mc md me mf b">AppDiv</code>的文本对齐不明显，但蓝色链接让我们离最初的Create React应用更近了一步。</p><p id="c199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用了<code class="fe mc md me mf b">styled.tagname</code>助手方法。标记名可以是组件名吗？</p><p id="5b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不。如果我们想在一个带标签的模板文字上构建，<code class="fe mc md me mf b">styled</code>应该像<code class="fe mc md me mf b">styled(Component)</code>一样被用作构造函数。新组件继承了<code class="fe mc md me mf b">Component</code>的样式。</p><p id="7be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe mc md me mf b">Button1</code>的样式是带有<code class="fe mc md me mf b">white</code>背景的<code class="fe mc md me mf b">red</code>文本。<code class="fe mc md me mf b">Button2</code>继承了<code class="fe mc md me mf b">red</code>的文字，有了<code class="fe mc md me mf b">yellow</code>的背景。<code class="fe mc md me mf b">Button3</code>继承了<code class="fe mc md me mf b">yellow</code>背景，并使用<code class="fe mc md me mf b">green</code>文本进行样式化。</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="d7e7" class="ns mo it mf b gy nt nu l nv nw">const Button1 = styled.button`<br/>  color: red;<br/>  background: white;<br/>`;</span><span id="ba10" class="ns mo it mf b gy nz nu l nv nw">const Button2 = styled(Button1)`<br/>  background: yellow;<br/>`;</span><span id="b257" class="ns mo it mf b gy nz nu l nv nw">const Button3 = styled(Button2)`<br/>  color: green;<br/>`;</span></pre><p id="5320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它们放在一起:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="bc66" class="ns mo it mf b gy nt nu l nv nw">&lt;Button1&gt;Button1&lt;/Button1&gt;<br/>&lt;Button2&gt;Button2&lt;/Button2&gt;<br/>&lt;Button3&gt;Button3&lt;/Button3&gt;</span></pre><p id="ed67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f4bc2af455a75cce3d7924a863255aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjJC_FZ62JV0SWHLxP8g5g.png"/></div></div></figure><p id="9b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果样式化的目标是一个简单的元素(<code class="fe mc md me mf b">styled.tagName</code>)，样式化的组件通过任何已知的HTML属性传递给DOM。如果是自定义的React组件(<code class="fe mc md me mf b">styled(Component)</code>)，样式化的组件会通过所有道具。</p><p id="19a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的按钮示例可以通过插值中使用的传递属性来完成:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="30e4" class="ns mo it mf b gy nt nu l nv nw">const Button = styled.button`<br/>  color: ${(props) =&gt; props.clr || "red"};<br/>  background: ${(props) =&gt; props.bg || "white"};;<br/>`;</span></pre><p id="c73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用法:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="e1ac" class="ns mo it mf b gy nt nu l nv nw">&lt;Button&gt;Button1&lt;/Button&gt;<br/>&lt;Button bg="yellow"&gt;Button2&lt;/Button&gt;<br/>&lt;Button clr="green" bg="yellow"&gt;Button3&lt;/Button&gt;</span></pre><p id="a603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在render方法之外定义样式化组件很重要，否则，在每次渲染过程中都会重新创建它们。</p><p id="e92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于生成的三个按钮，每个按钮都有两个与之连接的类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/cd5537e2a8cc0210194fcd5f09134b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_psIWS2AI7ihCo3r3dKdA.png"/></div></div></figure><p id="60e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是静态类，它没有附加任何样式。它用于快速识别一个DOM对象属于哪个样式的组件。</p><p id="9168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是动态类，每个元素都不一样。它用于设置组件的样式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/2bbdf307c8f2c82f159db561654937e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*618wmZhLyFyhejp1ABVjfQ.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0610" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">构造动画风格的组件</h1><p id="c1fe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<code class="fe mc md me mf b">src/App.css</code>中，<code class="fe mc md me mf b">App-logo</code>类的样式如下:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="60b6" class="ns mo it mf b gy nt nu l nv nw">.App-logo {<br/>  height: 40vmin;<br/>  pointer-events: none;<br/>}</span><span id="2daf" class="ns mo it mf b gy nz nu l nv nw">@media (prefers-reduced-motion: no-preference) {<br/>  .App-logo {<br/>    animation: App-logo-spin infinite 20s linear;<br/>  }<br/>}</span><span id="1f66" class="ns mo it mf b gy nz nu l nv nw">@keyframes App-logo-spin {<br/>  from {<br/>    transform: rotate(0deg);<br/>  }<br/>  to {<br/>    transform: rotate(360deg);<br/>  }<br/>}</span></pre><p id="6868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">@keyframes</code> CSS at-rule通过定义动画序列中关键帧的样式来控制CSS动画序列中的中间步骤。</p><p id="ebf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何配置它来恢复旋转图标？样式化组件提供了一种辅助方法来创建动画的关键帧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="5cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">keyframes</code>是从<code class="fe mc md me mf b">styled-components</code>(第三行)导入的。用于定义第20行的<code class="fe mc md me mf b">appLogoSpin</code>。<code class="fe mc md me mf b">appLogoSpin</code>被插入到第33行的<code class="fe mc md me mf b">AppLogo</code>中。现在标志又开始旋转了！</p><p id="858d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道我们是否可以像<code class="fe mc md me mf b">src/App.css</code>一样单独定义媒体。是的，我们可以，只要有个小帮手:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="0c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个小助手是<code class="fe mc md me mf b">css</code>，是从<code class="fe mc md me mf b">styled-components</code>(3线)进口的。这是一个辅助函数，通过插值从模板文本生成CSS。在第29行创建的<code class="fe mc md me mf b">media</code>被插入到第38行的<code class="fe mc md me mf b">AppLogo</code>中。</p><p id="fcd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想知道媒体关于偏好减速运动的质疑是什么吗？它用于检测用户是否要求系统尽量减少不必要的动作。有两种<a class="ae ky" href="https://medium.com/better-programming/10-steps-to-building-web-applications-with-accessibility-a11y-81cd2c1dd499" rel="noopener">可访问性</a>选择:</p><ul class=""><li id="9588" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated"><code class="fe mc md me mf b">no-preference</code>表示用户没有偏好。</li><li id="bc97" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><code class="fe mc md me mf b">reduce</code>表示用户更喜欢删除会引发前庭运动障碍患者不适的动画。</li></ul><p id="5391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下视频显示，当选择<code class="fe mc md me mf b">Reduce motion</code>时，旋转图标停止动画。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nl l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0c59" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">样式组件工具</h1><p id="b03f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">安装<code class="fe mc md me mf b">styled-components</code>后，<code class="fe mc md me mf b">package-lock.json</code>中会附带<code class="fe mc md me mf b"><a class="ae ky" href="https://github.com/styled-components/babel-plugin-styled-components" rel="noopener ugc nofollow" target="_blank">babel-plugin-styled-components</a></code>和<code class="fe mc md me mf b"><a class="ae ky" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank">babel-plugin-macros</a></code>。</p><p id="78ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了对服务器端渲染、样式缩小和更好的调试体验的支持。可以通过<code class="fe mc md me mf b">.babelrc</code>进行配置。如果没有显式地将标志设置为真，则默认值为假。</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="4622" class="ns mo it mf b gy nt nu l nv nw">{<br/>  "plugins": [<br/>    [<br/>      "babel-plugin-styled-components",<br/>      {<br/>        "ssr": false, // enable server-side rendering<br/>        "displayName": false, // display component name<br/>        "fileName": false // display file name<br/>        "minify": false, //  remove all whitespace and comments<br/>        "transpileTemplateLiterals": false, // keep valuable bytes out<br/>        "pure": true // remove dead code<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="bdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不知何故，<code class="fe mc md me mf b">babel-plugin-styled-components</code>的配置<a class="ae ky" href="https://github.com/styled-components/babel-plugin-styled-components/issues/261" rel="noopener ugc nofollow" target="_blank">不够稳定，无法正常运行</a>。</p><p id="8de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">babel-plugin-macros</code>作为一个全功能选项正在迅速发展，它允许零配置项目的高级代码编译，例如Create React应用程序。您需要做的就是从宏目录中导入项目:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="02d7" class="ns mo it mf b gy nt nu l nv nw">import styled, { css, keyframes } from 'styled-components<strong class="mf iu">/macro</strong>';</span></pre><p id="2145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管<code class="fe mc md me mf b">babel-plugin-macros</code>将默认值设置为true，但在<code class="fe mc md me mf b">babel-plugin-macros.config.js</code>中显式设置它们总是一个好主意:</p><pre class="kj kk kl km gt no mf np nq aw nr bi"><span id="2180" class="ns mo it mf b gy nt nu l nv nw">module.exports = {<br/>  styledComponents: {<br/>    displayName: true,<br/>    fileName: true,<br/>    pure: true,<br/>  },<br/>}</span></pre><p id="0542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe mc md me mf b">fileName</code>和<code class="fe mc md me mf b">displayName</code>都设置为真时，下面代码中的类名可读性更好，使调试过程更容易:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/eb69f7a70bd03834314fd6a4a8592886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcjrSbDBec1UZQb_Nyjbaw.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8a2b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="6205" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">样式化组件为开发人员用JavaScript编写CSS提供了更好的体验。</p><p id="9453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您构建一个库，建议您不要将<code class="fe mc md me mf b">styled-components</code>模块与库捆绑在一起。使<code class="fe mc md me mf b">styled-components</code>成为对等依赖，并在bundler (rollup或webpack)中将其标记为<code class="fe mc md me mf b">external</code>。</p><p id="9f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><p id="f258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣，看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af#266e" rel="noopener">其他风格的组件文章</a>。</p></div></div>    
</body>
</html>