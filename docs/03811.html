<html>
<head>
<title>Understanding gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解gRPC</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-grpc-60737b23e79e?source=collection_archive---------0-----------------------#2020-03-06">https://betterprogramming.pub/understanding-grpc-60737b23e79e?source=collection_archive---------0-----------------------#2020-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e5b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及REST和RPC架构之间的区别</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2616cf860e845258d2da012be6d9deff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkUq9tODX7fFNd7C9J2Z6A.png"/></div></div></figure><p id="f4f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文的目标是对gRPC有一个高层次的了解。它还将解释gRPC与web应用程序通信所遵循的现有协议和架构之间的相似之处和不同之处。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="76a1" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">什么是gRPC？</strong></h1><p id="96d3" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">gRPC是一个开源的远程过程调用框架，用于服务之间的高性能通信。这是一种连接用不同语言编写的服务的有效方式，支持负载平衡、跟踪、健康检查和身份验证。默认情况下，gRPC使用协议缓冲区来序列化结构化数据。一般来说，gRPC被认为是微服务架构REST协议的更好替代方案。gRPC中的“g”可以归功于最初开发这项技术的谷歌。</p><p id="6f2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在深入了解gRPC的更多细节之前，我们先来看看微服务架构。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="efce" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">微服务与整体服务</h1><p id="98d1" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">整体架构是设计应用程序的传统方式。它包含一个不可分割的代码库，为客户端用户界面、服务器端应用程序和数据库服务。从事该项目的所有开发人员都将把代码贡献给同一个存储库。我最喜欢的一个与整体建筑相关的类比是把它想象成一个工作室公寓。一个单间会根据需要分成各种空间。</p><p id="6d9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">整体架构的优势在于，由于只有一个单元，日志记录、性能监控和缓存等操作都可以轻松完成。此外，开发、测试、调试和部署都很简单。</p><p id="6648" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是随着应用程序的增长，维护、扩展甚至理解都变得很困难。此外，它可能变得非常复杂，以至于代码中的一个小变化都会影响整个应用程序。</p><p id="dd8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">monoliths的另一个重要缺点是它是对单一技术的严格承诺。采用新的框架或语言可能需要整个系统重写。</p><p id="c92c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">进入微服务架构！</p><p id="80ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果单体建筑是一个工作室公寓，那么微服务建筑可以被认为是一个有许多房间的房子。这意味着整个应用程序将被细分成多个更小的应用程序或服务。</p><p id="efe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这给了开发团队选择最适合他们需求的技术的灵活性，并且可以让他们独立地扩展他们的服务。微服务应用中的任何故障只会影响特定的服务，而不会影响整个应用。</p><p id="9d9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些服务可以独立开发、维护和部署，它们通过称为API(应用程序编程接口)的已定义方法相互通信。</p><p id="4a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">微服务之间通过HTTP的通信可以通过多种方式完成。最广泛使用的方法是遵循REST协议。gRPC是执行这种通信的另一种方式。它旨在克服微服务通信中REST的局限性。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="02e8" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">REST架构</h1><p id="b089" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">REST是一个使用HTTP协议的web架构。它被广泛用于web应用程序的开发。简而言之，REST是一种客户机-服务器关系，后端数据通过JSON/XML等简单表示提供给客户机。正如罗伊·菲尔丁所描述的，REST代表具象状态转移。REST是一种协议，它并不强制执行任何规则来决定如何在较低的级别上实现它。它为高级架构实现提供了指导原则。</p><p id="c4e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使任何应用程序真正RESTful，必须遵循六个架构约束:</p><ol class=""><li id="10bb" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated"><strong class="kt ir"> </strong>统一接口:意思是API接口必须呈现给web应用中的资源给API的消费者。</li><li id="3467" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">客户端-服务器:<strong class="kt ir"> </strong>客户端和服务器必须相互独立，客户端应该只知道对资源的URIs。</li><li id="bb0d" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">无状态:<strong class="kt ir"> </strong>服务器不得存储任何与客户端请求相关的内容。客户端负责维护应用程序的状态。</li><li id="ceef" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">可缓存:<strong class="kt ir"> </strong>资源必须是可缓存的。</li><li id="978c" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">分层系统:<strong class="kt ir"> </strong>架构必须是分层的，也就是说架构的组件可以在多个服务器中。</li><li id="dfe7" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">按需编码:客户端必须能够获得可执行代码作为响应。这是一个可选约束。</li></ol><p id="8c4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于REST的Web服务被称为RESTful web服务。在这些应用程序中，每个组件都是一个资源，这些资源可以通过一个公共接口使用HTTP标准方法来访问。基于REST的架构中通常使用以下四种HTTP方法:</p><ul class=""><li id="8d23" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm nf mx my mz bi translated"><code class="fe ng nh ni nj b">GET</code> —对资源的只读访问。</li><li id="8381" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm nf mx my mz bi translated"><code class="fe ng nh ni nj b">POST</code> —创建新资源。</li><li id="ed6c" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm nf mx my mz bi translated"><code class="fe ng nh ni nj b">DELETE</code> —删除资源。</li><li id="a296" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm nf mx my mz bi translated"><code class="fe ng nh ni nj b">PUT</code> —更新现有资源/创建新资源。</li></ul></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="0b6e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">RPC体系结构</h1><p id="fe0d" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">RPC代表远程过程调用。顾名思义，我们可以在远程服务器上调用一个函数/方法。RPC协议允许以相同的格式获得问题的结果，而不管它在哪里执行。它可以是本地的，也可以是使用更好资源的远程服务器。</p><p id="4c57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RPC是比REST更古老的协议。自20世纪70年代阿帕网时代以来，它就被用于执行网络操作。术语RPC是由Bruce Jay Nelson在1981年首次提出的。但是正如我们将要看到的，RPC仍然是相关的，并且以不同的方式在基于API的现代应用程序中实现。</p><p id="df0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想法是一样的。API是通过定义公共方法构建的。然后用参数调用这些方法。RPC只是一堆函数，但是在HTTP API的上下文中，它需要将方法放在URL中，将参数放在查询字符串或查询体中。</p><p id="4577" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RPC APIs将使用类似于带有主体<code class="fe ng nh ni nj b">{ “id”: 1 }</code>的<code class="fe ng nh ni nj b">POST /deleteResource</code>来代替REST方法，后者将是<code class="fe ng nh ni nj b">DELETE /resource/1</code>。</p><p id="7afa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RPC在物联网设备和其他需要为低功耗设备定制合约通信的解决方案中非常受欢迎，因为许多计算操作可以卸载到另一台设备上。传统上，RPC可以实现为RPC-XML和RPC-JSON。</p><p id="5682" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">gRPC是基于RPC协议创建的最新框架。它利用其优势，试图纠正传统RPC的问题。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="1960" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">什么是gRPC来着？</h1><p id="51de" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">从我们目前所读到的，我们可以重新定义gRPC。它是对传统RPC框架的改编。那么它与现有的RPC框架有什么不同呢？</p><p id="7d4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最重要的区别是gRPC使用协议缓冲区作为序列化和通信的接口定义语言，而不是JSON/XML。协议缓冲区可以描述数据的结构，并且可以从该描述中生成代码，用于生成或解析表示结构化数据的字节流。这就是gRPC更适合多语言<strong class="kt ir"> </strong>(用不同技术实现)的web应用程序的原因。二进制数据格式允许通信更简单。gRPC也可以和其他数据格式一起使用，但是首选的是协议缓冲区。要详细了解协议缓冲区，请查看这篇文章。</p><p id="19ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，gRPC构建在HTTP/2之上，它支持双向通信以及传统的请求/响应。gRPC允许服务器和客户机之间的松散耦合。在实践中，客户机打开与gRPC服务器的长期连接，并且为每个RPC调用打开一个新的HTTP/2流。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="ed58" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">REST与gRPC</h1><p id="182b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">与使用JSON(大部分)的REST不同，gRPC使用协议缓冲区，这是一种更好的数据编码方式。由于JSON是基于文本的格式，它将比protobuf格式的压缩数据重得多。</p><p id="9586" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">gRPC相对于传统REST的另一个显著改进是它使用HTTP 2作为传输协议。主要由REST使用的HTTP 1.1基本上是一个请求-响应模型。(其余的也可以用HTTP2实现)gRPC利用了HTTP 2的双向通信特性以及传统的响应-请求结构。在HTTP 1.1中，当多个请求来自多个客户端时，它们会被逐一处理。这可能会降低系统速度。HTTP 2允许多路复用，因此可以同时处理多个请求和响应。</p><p id="3590" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以得出结论，当用例涉及使用惯用API的多语言通信或大规模微服务通信时，gRPC是一个很好的选择。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="4e8d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">参考</h1><div class="nl nm gp gr nn no"><a href="https://www.n-ix.com/microservices-vs-monolith-which-architecture-best-choice-your-business/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">微服务vs Monolith:哪种架构最适合您的企业？</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Romana Gnatyk *年10月03日仅在几年前，微服务已成为一种加速发展的…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.n-ix.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://restfulapi.net/rest-architectural-constraints/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">REST架构约束</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">REST是一种通过HTTP设计松耦合应用程序的架构风格。RESTful原则并不强制…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">restfulapi.net</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc kp no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://www.xenonstack.com/insights/what-is-grpc/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">采用GRPC - XenonStack的优势和最佳实践</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">gRPC是一个高性能、开源的通用RPC框架。简而言之，它使服务器和客户端能够…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.xenonstack.com</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc kp no"/></div></div></a></div></div></div>    
</body>
</html>