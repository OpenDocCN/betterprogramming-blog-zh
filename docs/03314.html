<html>
<head>
<title>5 Examples of Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中高阶函数的5个例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-examples-of-higher-order-functions-in-javascript-21aabb4c00ac?source=collection_archive---------14-----------------------#2020-02-03">https://betterprogramming.pub/5-examples-of-higher-order-functions-in-javascript-21aabb4c00ac?source=collection_archive---------14-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0742" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用函数式编程让您的编码生活更轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bdffd724e2a50ce20aff5c3c7b26e055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9orRs8mdPArz-Is6bNSlvg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hudsoncrafted?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/five?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数可以说是JavaScript语言中最好的事情之一。它们被广泛使用是有原因的。</p><p id="3b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道什么是高阶函数，它们只是以其他函数作为参数的函数，或者返回一个函数作为结果的函数。</p><p id="df7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我刚接触JavaScript时，我花了一段时间才理解它们是什么，所以如果你在这个位置，那么希望在看完这篇文章后，你会对它们有更清晰的理解。</p><p id="9246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这里有五个JavaScript中高阶函数的例子，以便更好地理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.<code class="fe mu mv mw mx b">.map</code>、<code class="fe mu mv mw mx b">.forEach</code>等。</h1><p id="7bee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你使用JavaScript才一天，你很可能已经通过原生JavaScript数组方法处理过高阶函数，比如<code class="fe mu mv mw mx b">.map</code>。</p><p id="2335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段遍历一个数组，并对每一项调用一个函数，直到到达最后一项。获取可以调用的函数的能力使其成为高阶函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9158" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.使用高阶函数支持操作的多种变化</h1><p id="ab94" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，我们最终决定创建一个高阶函数，这样我们就可以用它来创建所需操作的更多变体。</p><p id="833a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，一个基本的<code class="fe mu mv mw mx b">utilizePrefixer</code>函数是一个高阶函数，它返回一个以<code class="fe mu mv mw mx b">word</code>作为参数的函数，并将前缀应用于返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.逆转控制</h1><p id="11da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">每当你需要重构一堆指向一个函数的代码时，你可以创建一个增强的函数来反转代码的运行方向。</p><p id="c2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从一篇旧文章中复制并粘贴一个例子，因为这是一个很好的例子来说明这一点:</p><p id="9208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我以前的工作中，我们使用<a class="ae ky" href="https://github.com/fkhadra/react-toastify" rel="noopener ugc nofollow" target="_blank">来显示通知。我们在任何地方都使用它。此外，他们还为UX最后一分钟的快速决策提供了绝佳的逃生通道:“我们应该如何处理这个错误？只显示一个祝酒通知！”完成了。</a></p><p id="8398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们开始注意到，当应用程序变得越来越大，复杂程度越来越高时，我们的toast通知变得过于频繁。这很好，但是，我们没有办法防止重复。这意味着一些toast通知会在屏幕上出现多次，即使它们与上面的toast完全相同。</p><p id="3ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们最终利用该库提供的API来帮助使用<code class="fe mu mv mw mx b">toast.dismiss()</code>通过ID删除活动的toast通知。</p><p id="c69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释前面的部分，在继续之前显示我们从中导入祝酒词的文件可能是个好主意:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="747e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在忍耐一下，我知道这可能看起来不吸引人，但我保证两分钟后会好起来的。</p><p id="0416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在一个单独的组件中检查先前的toast是否已经在屏幕上，如果有，它会尝试删除那个toast并重新显示新的toast。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这工作得很好——然而，我们在整个应用程序中有其他的祝酒词需要以同样的方式修改。我们不得不仔细检查每一个显示toast通知的文件来删除重复的文件。</p><p id="8733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想到在2019年检查每一个文件时，我们立即知道这不是解决方案。因此，我们查看了<code class="fe mu mv mw mx b">util/toast.js</code>文件，并对其进行了重构，以解决我们的问题。这是后来的样子:</p><p id="9d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">src/util/toast.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的解决方案是创建一个高阶函数，而不是遍历每个文件。这样做可以让我们互换角色，这样我们就不用搜索文件，而是把祝酒词指向我们的高阶函数。</p><p id="f901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，文件中的代码就不会被修改或改动。它仍然一切正常，我们获得了删除重复祝酒词的能力，最终不用去任何地方写不必要的代码。这节省了时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dcb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.组成</h1><p id="96ec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你开始创作高阶函数时，它们开始变得更加耀眼。一个人可以出于许多原因选择作曲。对于下面的例子，我们编写的原因是我们希望防止JavaScript在每个<code class="fe mu mv mw mx b">.filter</code>操作中反复循环青蛙数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="86ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以避免我们在应用程序中到处重复编写这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.内部状态</h1><p id="0331" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">值得一提的是，当我们创建一个高阶函数时，我们也可以在作用域内创建一些局部状态，并且它将被缓存以供将来的操作使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1fda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="bfbb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这就是这篇文章的结尾。我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>