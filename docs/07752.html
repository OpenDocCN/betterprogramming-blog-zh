<html>
<head>
<title>Using Jest Mocks + TypeScript the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确使用Jest Mocks + TypeScript</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-jest-mocks-typescript-the-right-way-da025da7a284?source=collection_archive---------1-----------------------#2021-02-16">https://betterprogramming.pub/using-jest-mocks-typescript-the-right-way-da025da7a284?source=collection_archive---------1-----------------------#2021-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9077" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写更好的单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d83ff41a12f577c611186a022b8aebb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_j57ixJOz-c-C-QHq9dIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托尼·昆卡在<a class="ae ky" href="https://unsplash.com/s/photos/plastic-flamingo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="97d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:本文假设读者对Jest和React测试库有基本的了解。如果你不熟悉React的一般测试结构，我推荐从</em> <a class="ae ky" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener"> <em class="lv">这个系列</em> </a> <em class="lv">开始。</em></p><p id="da09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿是对React应用程序进行单元测试的核心原则。它是遵循RTL不测试实现细节的最佳实践的关键工具，也是所有单元测试中隔离的基本思想。</p><p id="557c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest文档涵盖了各种嘲弄的方法和几个非常有用的用例。但是它缺少的是对<em class="lv">你在嘲笑什么东西的时候</em>在做什么的基本概述。我发现这是将他们概述的方法成功应用到您自己的应用程序中的必要条件。</p><p id="a113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唉，我们今天的主题是:如何正确模拟生产React应用程序所需的东西？我们将在哲学层面上讨论模仿，并浏览本地<code class="fe lw lx ly lz b">Config</code>文件的基本模仿以及<a class="ae ky" href="https://github.com/auth0/auth0-react" rel="noopener ugc nofollow" target="_blank"> Auth0的React SDK </a>。</p><p id="107e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之所以选择Auth0 SDK，是因为它有非常具体的用于在浏览器中运行的用例，并且通常是您想要在代码中测试的核心。换句话说，这是一个完美的用例，用于需要被嘲笑的东西，并且需要被适当地嘲笑<em class="lv">以便测试。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/985651411d6b38aff3a8a6b33b672b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzpf7eeE0uGFH5XpulOElQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae ky" href="https://unsplash.com/s/photos/goal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><h1 id="5349" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">单元测试实现了什么？</h1><p id="c43f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">单元测试的目标是确认您(或您团队中的某个人)编写的代码块按预期工作。就是这样。</p><p id="7d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试<em class="lv">不是</em>想要做的，并且<em class="lv">也不应该</em>测试从第三方依赖项导入的函数和模块是否工作，或者代码获取的API的状态——或者任何特定于浏览器的东西，比如网络或安全问题。</p><p id="8c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地进行单元测试，我们需要将被测试的代码单元与所有这些其他关注点隔离开来。这允许我们自信地断言代码块的结果。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/47fd5faf8d55c63f9c8038b6b105d999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vkq8AxV6fZ4fL99LuvXzPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fabian Mardi </a>在<a class="ae ky" href="https://unsplash.com/s/photos/isolation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><h1 id="ac53" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">寻求与世隔绝</h1><p id="95a1" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果你正在开发一个React应用程序，这个应用程序不可避免地会用到我刚刚提到的所有东西——第三方依赖、浏览器、API等等。我们不希望这些东西破坏我们的测试<em class="lv">。</em></p><p id="c5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个明显的例子是一个依赖于从API获取成功返回的代码单元。在测试环境中，它不能从这个API获取数据，因此每次都会失败。它失败是因为API的失败。然而，正如所讨论的，API不是我们想要测试的<em class="lv">。</em></p><p id="1c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是嘲讽的由来。模拟允许您接管这些东西中的任何一个的功能，并出于测试的目的控制它。您可以伪造从API调用返回的数据集，规避浏览器安全要求，模拟环境变量，等等。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/df593bf2b8616279a75c77f343febe22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msgICCjyRnfp11Oow55DWQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tim_arterbury?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·阿特伯里</a>在<a class="ae ky" href="https://unsplash.com/s/photos/mock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><h1 id="2538" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">准备模拟练习</h1><p id="b28f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果你还没有浏览过<a class="ae ky" href="https://jestjs.io/docs/en/mock-functions" rel="noopener ugc nofollow" target="_blank"> Jest的嘲讽文档</a>，请花点时间浏览一下。您将大致了解到，我们使用<code class="fe lw lx ly lz b">jest.mock()</code>,将路径或依赖项名称作为参数传入。有时会有一个回调作为第二个参数传入。有时候没有。有时看起来我们只是直接将<code class="fe lw lx ly lz b">jest.fn()</code>存储在一个变量中，然后调用它。正如文档所述，这里的例子是人为设计的，所以我们将使用我们自己的例子。</p><h2 id="733a" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated"><code class="fe lw lx ly lz b">jest.mock()</code></h2><p id="241e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这个函数是一切开始的地方——至少就我们的模拟来说是这样。</p><p id="93ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将相对路径或第三方模块的名称传递给这个函数时，您是在对Jest测试运行人员说，“嘿，在我们现在测试的代码中，您会发现我们使用了来自<code class="fe lw lx ly lz b">&lt;relative path or third-party module name&gt;</code>的代码。但是我们实际上并不想在这里使用这段代码，因为它在测试环境中是行不通的。此外，我们正在争取隔离。所以当你运行<em class="lv">我的</em>代码，并从<code class="fe lw lx ly lz b">&lt;relative path or third-party module name&gt;</code>得到这个其他代码时，不要使用你将在<code class="fe lw lx ly lz b">&lt;relative path or third-party module name&gt;</code>中找到的实际代码。我们将为测试伪造代码。”</p><p id="3ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于依赖关系，这看起来像这样:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="135f" class="nh mj it lz b gy nx ny l nz oa">jest.mock('@auth0/auth0-react');</span></pre><p id="7a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于相对路径，它应该是:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="b072" class="nh mj it lz b gy nx ny l nz oa">jest.mock('../Config');</span></pre><p id="77eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单单这一行就得到了“嘿，笑话。不要使用实际的代码。我们要假装“任务完成。然而，它没有告诉笑话<em class="lv">你如何</em>想要伪造它。</p><p id="9f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了告诉Jest如何伪造它，我们传递一个回调作为第二个参数。回调应该返回与实际代码形状相同的东西，因为这是您编写的代码所期望的。<code class="fe lw lx ly lz b">@auth0/auth0-react</code>包返回一个<code class="fe lw lx ly lz b">useAuth0</code>钩子、一个用于上下文的<code class="fe lw lx ly lz b">Auth0Provider</code>组件，以及像<code class="fe lw lx ly lz b">withAuthenticationRequired</code>这样的助手函数，等等。假设我们的代码使用了这些，我们可能会这样模仿这个包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的配置文件返回了一个环境变量的对象，比如<code class="fe lw lx ly lz b">NODE_ENV</code>、<code class="fe lw lx ly lz b">API_KEY</code>和<code class="fe lw lx ly lz b">API_SECRET</code>，我们将会:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="30b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当Jest运行您的代码并到达<code class="fe lw lx ly lz b">@auth0/auth0-react</code>和<code class="fe lw lx ly lz b">'../Config'</code>代码时，它将分别实现从模拟代码而不是实际代码的返回。</p><h2 id="6670" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">jest.fn()</h2><p id="614b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">你会注意到上面我们在<code class="fe lw lx ly lz b">@auth0/auth0-react</code>模拟中使用了<code class="fe lw lx ly lz b">jest.fn()</code>。这是因为，在这个包的实际实现中，这个包将每个<code class="fe lw lx ly lz b">useAuth0</code>、<code class="fe lw lx ly lz b">Auth0Provider</code>和<code class="fe lw lx ly lz b">withAuthenticationRequired</code>作为可调用函数返回。对这些属性使用<code class="fe lw lx ly lz b">jest.fn()</code>允许我们进一步模拟从我们的包返回的函数的实现。</p><p id="ae0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lw lx ly lz b">jest.mock()</code>，<code class="fe lw lx ly lz b">jest.fn()</code>简单地说，“我们要模仿这个函数做什么”，但是它没有告诉Jest <em class="lv">我们想要如何模仿它。但是将它分配给<code class="fe lw lx ly lz b">jest.fn()</code>允许我们使用Jest的功能，比如<code class="fe lw lx ly lz b">.mockResolvedValue()</code>、<code class="fe lw lx ly lz b">.toHaveBeenCalled()</code>、<code class="fe lw lx ly lz b">.toHaveBeenCalledWith()</code>等等。</em></p><p id="d97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，简单地模仿函数——使其可调用，以便您的代码可以继续运行——就足够了。但通常，我们希望控制返回或确认它已被调用，这就是这些助手的作用。但是…我们怎么称呼它们呢？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1699" class="mi mj it bd mk ml od mn mo mp oe mr ms jz of ka mu kc og kd mw kf oh kg my mz bi translated">模仿实现</h1><p id="36e8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">坚持使用<code class="fe lw lx ly lz b">@auth0/auth0-react</code>，我们现在已经告诉Jest去模拟模块，但是没有可以操作的模块。我们不能访问<code class="fe lw lx ly lz b">useAuth0</code>、<code class="fe lw lx ly lz b">Auth0Provider</code>和<code class="fe lw lx ly lz b">withAuthenticationRequired</code>来告诉他们我们希望他们如何行动。</p><p id="98a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常首先将模块或函数导入到文件中，这样我们就有了要操作的函数的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="35b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个导入，连同下面的mock，现在给了我们<code class="fe lw lx ly lz b">useAuth0</code>、<code class="fe lw lx ly lz b">Auth0Provider</code>和<code class="fe lw lx ly lz b">withAuthenticationRequired</code>作为模仿的Jest函数。尽管从语法上来说，我们是从<em class="lv">实际的第三方依赖关系</em>中导入的，但就Jest环境而言，这些导入实际上是模拟的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/12427f6017113978b6d9c819905011e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTgKMrhTnzIJnPCrLayxJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">J. Kelly Brito 在<a class="ae ky" href="https://unsplash.com/s/photos/coloring-book?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><h1 id="314f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">利用模拟函数进行测试</h1><p id="a38b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">从根本上说，模拟为我们的测试提供了两个绝佳的机会。通过模拟，我们可以:</p><p id="2b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.控制退货、已解决或已拒绝的值。</p><p id="f8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.“观察”mock是如何在我们的代码中使用的。</p><p id="c962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript使这个问题稍微复杂了一些，但是我们将讨论如何避开TypeScript的类型检查。</p><h2 id="df7c" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">。mockReturnValue()和。mockReturnValueOnce()</h2><p id="6de9" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这是事情变得真正有趣的地方。现在我们已经用Jest嘲笑了我们的函数，我们获得了对它们返回的内容的控制，允许我们在不陷入实现细节的情况下做出断言。顾名思义，<code class="fe lw lx ly lz b">.mockReturnValue()</code>为函数设置一个默认的模拟返回，而<code class="fe lw lx ly lz b">.mockReturnValueOnce()</code>只模拟一次函数的返回。这很有帮助，因为您经常想要基于不同的返回值进行测试和断言。</p><p id="1329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有TypeScript的保护，您可以这样做:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="0a73" class="nh mj it lz b gy nx ny l nz oa">useAuth0.mockReturnValueOnce({<br/>  isAuthenticated: true,<br/>  <!-- -->loginWithRedirect: jest.fn(),<br/>  logout: jest.fn(),<br/>});</span></pre><p id="110e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，该返回值的形状必须与模块函数的实际返回值<em class="lv">的形状相匹配。这是当务之急。它不需要包括一切。例如，<code class="fe lw lx ly lz b">useAuth0()</code>除了我们嘲笑的属性和函数之外，还返回了许多其他的属性和函数。但是如果我们的代码没有实现其他属性，那么我们不需要模仿它们。</em></p><p id="129b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，我们在这里假设我们的代码只使用了来自<code class="fe lw lx ly lz b">useAuth0</code>钩子的<code class="fe lw lx ly lz b">isAuthenticated</code>、<code class="fe lw lx ly lz b">loginWithRedirect</code>和<code class="fe lw lx ly lz b">logout</code>。</p><p id="9d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于TypeScript，情况稍微复杂一些，因为我们会遇到类型错误。TypeScript看不到我们已经模仿了<code class="fe lw lx ly lz b">useAuth0</code>——它仍然认为我们在使用实际的实现而不是模仿的实现。因此，您会看到如下错误:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="95a5" class="nh mj it lz b gy nx ny l nz oa">Error: Property mockReturnValueOnce does not exist on type useAuth0<!-- -->.</span></pre><p id="641e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们使用Jest提供给我们的类型，让TypeScript知道这个模块现在是一个被模仿的函数:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="19f1" class="nh mj it lz b gy nx ny l nz oa">(useAuth0 as <!-- -->jest.MockedFunction&lt;any&gt;<!-- -->).mockReturnValueOnce({<br/>  isAuthenticated: true,<br/>  <!-- -->loginWithRedirect: jest.fn(),<br/>  logout: jest.fn(),<br/>});</span></pre><p id="4146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单说一下:我对在我的代码库中不使用类型<code class="fe lw lx ly lz b">any</code>非常严格。然而，我个人认为担心使测试类型安全是不值得的，所以我允许在我的测试中相当自由地使用<code class="fe lw lx ly lz b">any</code>。</p><p id="64a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当Jest到达您的代码中调用<code class="fe lw lx ly lz b">useAuth0</code>的部分时，它将简单地返回以下内容，而不是实际调用它，这正是您的代码所期望的:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="d531" class="nh mj it lz b gy nx ny l nz oa">{<br/>  isAuthenticated: true,<br/>  loginWithRedirect: jest.fn(),<br/>  logout: jest.fn(),<br/>};</span></pre><h2 id="a297" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">。toHaveBeenCalled()和。toHaveBeenCalledWith()</h2><p id="f309" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">例如，为了让我们的代码单元运行，我们不一定需要特定的返回值，但是我们只想确保我们的代码正确地调用一个函数，我们可以使用<code class="fe lw lx ly lz b">.toHaveBeenCalled()</code>和<code class="fe lw lx ly lz b">.toHaveBeenCalledWith()</code>断言。前者只是检查它是否被调用，而后者检查它是否被调用并传递了特定的参数。</p><p id="74cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有进一步模仿函数，这些只是特殊的断言<em class="lv">只能在模仿函数上使用。</em>它们的用法如下:</p><pre class="kj kk kl km gt nt lz nu nv aw nw bi"><span id="db8d" class="nh mj it lz b gy nx ny l nz oa">expect(<!-- -->withAuthenticationRequired)<!-- -->.toHaveBeenCalled();</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a0d4" class="mi mj it bd mk ml od mn mo mp oe mr ms jz of ka mu kc og kd mw kf oh kg my mz bi translated">结论</h1><p id="d1da" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">仅此而已。一旦你完全理解了什么是玩笑，这就相当简单了。在正确的地方模仿正确的属性/模块/函数对于在测试中利用模仿是至关重要的，并且大部分归结为正确的语法。一旦你进入这种状态，嘲笑将成为你新的最好的朋友。</p><p id="a54f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样的理解，我现在建议你研究一下<a class="ae ky" href="https://jestjs.io/docs/en/mock-functions" rel="noopener ugc nofollow" target="_blank"> Jest关于嘲讽的文档</a>。现在你明白了背景中发生的事情，希望事情会变得更清楚。</p></div></div>    
</body>
</html>