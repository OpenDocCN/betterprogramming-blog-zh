<html>
<head>
<title>Delegate Interfaces with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript委托接口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/delegate-interfaces-with-typescript-1768e7677c6b?source=collection_archive---------1-----------------------#2019-05-04">https://betterprogramming.pub/delegate-interfaces-with-typescript-1768e7677c6b?source=collection_archive---------1-----------------------#2019-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d741" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用TypeScript让你的代码更优雅</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/bee367e2c9ea79637a20ac282c12340e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*lniHZ3eu7pbMK5kf6aCMUg.png"/></div></figure><p id="c6f1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">委托接口是在类中实现事件的一种方式(但不限于此)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="98bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">委托接口在OOP语言中被广泛使用，如<a class="ae lo" href="https://chromium.googlesource.com/chromium/src/+/master/services/content/service_delegate.h#16" rel="noopener ugc nofollow" target="_blank"> C++ </a>和<a class="ae lo" href="https://github.com/elastic/elasticsearch/blob/0cd03d358140193cc84434d385947e84e0b70607/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/common/IteratingActionListener.java#L45" rel="noopener ugc nofollow" target="_blank"> Java </a>，通常被称为<a class="ae lo" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>。</p><p id="241c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在函数式编程语言(如JavaScript)中很少看到它的使用，在这些语言中，事件发射器是更受欢迎的方式。</p><h1 id="56de" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated"><strong class="ak">为什么要打字稿？</strong></h1><p id="32c3" class="pw-post-body-paragraph kq kr it ks b kt mh ju kv kw mi jx ky kz mj lb lc ld mk lf lg lh ml lj lk ll im bi translated">用普通的JavaScript实现委托接口是可能的，但是它非常混乱和不自然，因为没有简单的方法来表达接口。</p><p id="65ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">“TypeScript起源于JavaScript对于大规模应用开发的不足。”它通过添加诸如类型注释<strong class="ks iu"> </strong>和接口等特性来实现这一点。</p><p id="85ff" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">TypeScript使实现和使用委托接口变得简单，同时使您的代码更加优雅和富于表现力:</p><h1 id="f49c" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated"><strong class="ak">优雅的代码</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/73c73a5725b21015997a3554f3da20a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*_fwc6T1wwTbGegG7.png"/></div></figure><p id="a85b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以用回调来实现我们的事件，或者创建一个<a class="ae lo" href="https://stackoverflow.com/questions/12881212/does-typescript-support-events-on-classes" rel="noopener ugc nofollow" target="_blank">通用事件发射器类</a>——看起来像这样(我忽略了封装规则以使它更短):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8a62" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是调用者使用它的方式(当使用<strong class="ks iu"> EventEmitter </strong>示例时):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="065b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">添加新事件需要在<strong class="ks iu">日历</strong>和<strong class="ks iu">客户端</strong>中添加更多的定义和初始化代码。在某些情况下，您可能还需要对某些/所有事件调用removeListener。</p><p id="fab0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您想要一个也期望从客户端返回一个值的事件(例如，返回true以在onReminder之后暂停)，该怎么办？</p><p id="9f33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是相当麻烦的。</p><p id="cc47" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">带代理界面的<strong class="ks iu">日历</strong>代码可以在这篇文章的开头找到。</p><p id="b0b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是来电者的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="6b8e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这需要较少的初始化代码，添加新事件只需要在<strong class="ks iu"> ICalendarDelegate </strong>中添加一个新的函数定义+在<strong class="ks iu">客户端</strong>中添加事件处理程序。</p><p id="59f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果有不止一个类使用<strong class="ks iu"> ICalendarDelegate </strong>来触发事件(<strong class="ks iu"> MayaCalendar </strong>)的话，这个好处会更加明显。).</p><p id="1c5e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> ICalendarDelegate </strong>也可以包含可选事件，这样<strong class="ks iu">客户端</strong>就不需要<strong class="ks iu">拥有</strong>来实现每一个功能——为此，只需添加<strong class="ks iu">？</strong>(问号)在界面中的函数名称后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h1 id="3e42" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated"><strong class="ak">更有表现力</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1fad1e9631835320b56074f22357326f.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*LNEbUPNGJsPNUALd1prlXg.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0a7f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">仅仅通过查看类图或类定义，就可以清楚地看出<strong class="ks iu">客户端</strong>是<strong class="ks iu">日历</strong>事件的消费者。</p><p id="b897" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还可以预测在哪里可以找到事件处理函数，它们被称为什么，以及代码序列如何流动。</p><p id="5df8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">也很清楚(多亏了TypeScript)哪些事件处理程序是<strong class="ks iu">日历</strong>需要实现的，哪些不是需要的(使用？符号)。</p><p id="6a5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">任何想要实现类似<strong class="ks iu">日历</strong>的功能的新类(例如<strong class="ks iu"> MayaCalendar </strong>)都可以接受<strong class="ks iu"> ICalendarDelegate </strong>并拥有与其调用者通信的标准方式。</p><h1 id="2add" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">结论</h1><p id="535e" class="pw-post-body-paragraph kq kr it ks b kt mh ju kv kw mi jx ky kz mj lb lc ld mk lf lg lh ml lj lk ll im bi translated">来自OOP语言的程序员可能不会对在TypeScript中使用委托接口的想法感到惊讶。</p><p id="0fb8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">函数式程序员可能会觉得有点陌生——但是如果您已经决定使用TypeScript(和类/接口)——我相信通过使用委托接口，您可以创建更简洁、更易于维护的代码。</p></div></div>    
</body>
</html>