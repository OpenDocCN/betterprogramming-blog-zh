<html>
<head>
<title>Mixing Typescript and GraphQL Code Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混合Typescript和GraphQL代码生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mixing-typescript-and-graphql-code-generator-c34e68b92dd3?source=collection_archive---------2-----------------------#2021-02-03">https://betterprogramming.pub/mixing-typescript-and-graphql-code-generator-c34e68b92dd3?source=collection_archive---------2-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动化您的GraphQL类型脚本的类型生成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11c097011e7227e3923b807db676d3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0QtiLWLOiQDnLzH3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="50c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是一种用于API的开源数据查询和操作语言，也是一种用现有数据完成查询的运行时语言。</p><p id="4015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再也不用像休息时那样玩猜谜游戏了。它是强类型的。给定一个查询，在执行之前，工具可以确保该查询在GraphQL类型系统中语法正确并且有效。</p><p id="07ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Typescript是一种类型化语言，它是GraphQL的完美匹配。通过一起使用它们，你可以确保正确的类型在你的BE和FE中是一致的。</p><p id="dd4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么为什么我们必须手动定义我们的Typescript接口呢？手动工作意味着可能会发生人为错误。带着这个动机<code class="fe lv lw lx ly b">graphql-codegen</code>诞生了。</p><blockquote class="lz ma mb"><p id="cad2" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">GraphQL代码生成器是一个CLI工具，它可以从GraphQL模式中生成类型脚本类型。当我们开发一个GraphQL后端时，会有很多情况，我们会发现自己写的东西和GraphQL模式已经描述的一样，只是格式不同；例如:解析器签名、MongoDB模型、角度服务等。</p><p id="ef79" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><strong class="lb iu">graphql-code-generator.com</strong></p></blockquote><p id="1163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:这是一个CLI工具，它将为我们完成所有繁重的工作。让我们深入研究一下，看看使用<code class="fe lv lw lx ly b">Typescript</code>、<code class="fe lv lw lx ly b">React</code>和<code class="fe lv lw lx ly b">Apollo</code>生成我们的第一个查询是多么容易。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d52f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">GraphQL代码生成器设置</h1><p id="6947" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们从安装GraphQL库开始:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="b4a4" class="no mo it ly b gy np nq l nr ns">yarn add graphql</span><span id="3476" class="no mo it ly b gy nt nq l nr ns">npm install — save graphql</span></pre><p id="54a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要添加<code class="fe lv lw lx ly b">cli</code>:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="ecbd" class="no mo it ly b gy np nq l nr ns">yarn add -D @graphql-codegen/cli</span><span id="a647" class="no mo it ly b gy nt nq l nr ns">npm install --save-dev @graphql-codegen/cli</span></pre><p id="4b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL代码生成器从<code class="fe lv lw lx ly b">codegen.yml</code>读取所有配置。我们可以使用向导特性来为我们生成它。让我们运行它:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="f1e4" class="no mo it ly b gy np nq l nr ns">yarn graphql-codegen init</span><span id="1017" class="no mo it ly b gy nt nq l nr ns">npx graphql-codegen init</span></pre><p id="deb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个特殊的例子，我们将选择<code class="fe lv lw lx ly b">Typescript</code>和<code class="fe lv lw lx ly b">Apollo</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c3e35ed823120a8606e7a7fecbf8ae18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNsJCpJcLBA4b66nn7s6bg.png"/></div></div></figure><p id="34e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有设置后，我们只需运行典型的安装命令:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="5b20" class="no mo it ly b gy np nq l nr ns">npm install / yarn install</span></pre><p id="55df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将使用一个现有的GraphQL演示端点。这里有大量GraphQL演示端点可用。</p><p id="731e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置完成后，我们的<code class="fe lv lw lx ly b">codegen.yml</code>看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">schema</code>参数告诉我们的工具GraphQL端点在哪里。对于本文的展示，我们将使用前面显示的端点列表中的<code class="fe lv lw lx ly b">Star Wars</code>端点。</p><p id="92a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中，我们使用URL模式，但是也可以使用一个<code class="fe lv lw lx ly b">.gql</code>本地文件来指定模式。像这样:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="a3e2" class="no mo it ly b gy np nq l nr ns">schema: 'src/**/*.graphql'</span></pre><p id="a9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者指定多个模式文件:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="13b4" class="no mo it ly b gy np nq l nr ns">// multiple patterns<br/>schema:<br/>- 'src/app1/**/*.graphql'<br/>- 'src/app2/**/*.graphql'</span><span id="112d" class="no mo it ly b gy nt nq l nr ns"><br/>// ignores files<br/>schema:<br/>- 'src/**/*.graphql'<br/>- '!src/app2/**/*.graphql'</span></pre><p id="a3c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">documents</code>参数告诉我们的CLI工具从哪里拉我们的<code class="fe lv lw lx ly b">gql</code> <code class="fe lv lw lx ly b">fragments/mutations/queries</code>。</p><p id="ab82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，GraphQL代码生成器是一个通过插件接受粒度配置的基本工具。注意<code class="fe lv lw lx ly b">codegen.yml</code>上的<code class="fe lv lw lx ly b">plugins</code>部分。核心就是这么配置的。</p><p id="f1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将重点放在带有<code class="fe lv lw lx ly b">Apollo</code>和<code class="fe lv lw lx ly b">Typescript</code>的<code class="fe lv lw lx ly b">react</code>上，但是它也可以用于任何其他供应商或环境。我们甚至可以用其他编程语言输出代码，比如<code class="fe lv lw lx ly b">Java</code>、<code class="fe lv lw lx ly b">.Net</code>和<code class="fe lv lw lx ly b">Kotlin</code>。</p><p id="d901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要为我们生成所有类型，我们必须运行以下命令:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="1dc6" class="no mo it ly b gy np nq l nr ns">yarn generate</span></pre><p id="71ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，现在它将失败，因为我们还没有创建任何用于工具解析的<code class="fe lv lw lx ly b">gql</code>文件。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="66cb" class="no mo it ly b gy np nq l nr ns">Error: Unable to find any GraphQL type definitions for the following pointers: 'src/**/*.gql'</span></pre><p id="a387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过创建第一个GraphQL查询来解决这个问题。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a48f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建我们的第一个GraphQL查询</h1><p id="8722" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让乐趣开始吧！让我们创建第一个查询，看看会得到什么。在本例中，我们将创建一个分页查询来列出《星球大战》中的所有星球。</p><p id="ec53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里访问《星球大战》的GraphQL端点<a class="ae ky" href="https://swapi-graphql.netlify.app" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ae79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的查询将会是这样的:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="1f9a" class="no mo it ly b gy np nq l nr ns">{<br/>  allPlanets (first:5, after: "YXJyYXljb25uZWN0aW9uOjQ=") {<br/>    planets {<br/>      id,<br/>      name,<br/>      diameter,<br/>      population,<br/>      gravity<br/>    },<br/>    pageInfo {<br/>      endCursor<br/>    }<br/>  }<br/>}</span></pre><p id="2314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们基于前面的查询创建<code class="fe lv lw lx ly b">planets.gql</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何声明它是一个带有<code class="fe lv lw lx ly b">query</code>前缀的查询的。我们使用<code class="fe lv lw lx ly b">$</code>来声明我们的变量<code class="fe lv lw lx ly b">$after</code>，并赋予它类型<code class="fe lv lw lx ly b">String</code>。它是可选的，因此不会像在我们的初始页面中那样使<code class="fe lv lw lx ly b">String!</code>值为空。</p><p id="35f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们终于可以使用以下代码生成我们的第一个GraphQL查询了:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="9db0" class="no mo it ly b gy np nq l nr ns">npm generate / yarn generate</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8d90529b89fd6a785ca7cc5bbf975bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*ef4V7RPP9NTdIcOWqtO5aQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成功生成代码</p></figure><p id="8517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功！因为我们有一个查询要在<code class="fe lv lw lx ly b">src/queries/planets.gql</code>上生成，所以这次不会失败。您可以去检查生成的文件<code class="fe lv lw lx ly b">src/generated/graphql.tsx</code>并开始在您的项目中使用它。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8b59" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">微调发电机</h1><p id="211c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们之前已经用基本配置生成了一个查询。让我们看看如何通过深入配置来改进生成的代码。</p><p id="7694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个CLI工具附带了一组配置默认值，您可以在这里检查<a class="ae ky" href="https://graphql-code-generator.com/docs/plugins/typescript-react-apollo" rel="noopener ugc nofollow" target="_blank"/>。默认情况下，以下是一些默认值:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="6058" class="no mo it ly b gy np nq l nr ns">config:<br/>  withHooks: true<br/>  withComponent: false<br/>  withHOC: false</span></pre><p id="33a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着<code class="fe lv lw lx ly b">Component</code>和<code class="fe lv lw lx ly b">HOC</code>方法被弃用，你将得到推荐的<code class="fe lv lw lx ly b">hook</code>版本。如果你总是遵循建议，你会没事的。</p><p id="5d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些非常有用的配置值得检查。以下是我的前三条:</p><h2 id="5c9c" class="no mo it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">1.函数式编程</h2><p id="1dd8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让您生成的代码采用函数式编程风格:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="3e09" class="no mo it ly b gy np nq l nr ns">config:<br/>  constEnums: true<br/>  immutableTypes: true</span></pre><p id="df98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将防止您改变查询结果对象，并选择不可变的代码风格。通过使用<code class="fe lv lw lx ly b">readonly</code>属性修饰符，Typescript在防止突变方面做得很好。</p><h2 id="f898" class="no mo it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">2.前缀</h2><p id="01a5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">例如，有些团队喜欢给枚举和接口加前缀。这个CLI工具有一些相应的配置选项:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="8096" class="no mo it ly b gy np nq l nr ns">config:<br/>  typesPrefix: I<br/>  typesSuffix: I<br/>  enumPrefix: false</span></pre><h2 id="5102" class="no mo it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">3.编程风格</h2><p id="2997" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有些团队不喜欢可选字段，或者有特殊的使用方式。该工具允许您微调<code class="fe lv lw lx ly b">optional</code>字段行为:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="f56d" class="no mo it ly b gy np nq l nr ns">config:<br/>  avoidOptionals:<br/>  field: true<br/>  inputValue: true<br/>  object: true<br/>  defaultValue: true</span></pre><p id="6d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里还有更多关于<a class="ae ky" href="https://graphql-code-generator.com/docs/plugins/typescript-operations" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="cc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成微调配置后，我的最终<code class="fe lv lw lx ly b">codegen.yml</code>配置如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="cd9f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">配置Apollo客户端</h1><p id="260f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在能够使用和执行我们生成的查询之前，我们需要安装Apollo客户机。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="086b" class="no mo it ly b gy np nq l nr ns">yarn add @apollo/client graphql</span><span id="fa49" class="no mo it ly b gy nt nq l nr ns">npm install @apollo/client graphql</span></pre><blockquote class="lz ma mb"><p id="c907" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">@apollo/client</code>:这个软件包几乎包含了安装Apollo客户端所需的所有东西。它包括内存缓存、本地状态管理、错误处理和基于React的视图层。</p><p id="d29f" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">graphql</code>:这个包提供了解析GraphQL查询的逻辑。</p><p id="d7ea" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">apollographql.com</p></blockquote><p id="6d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在<code class="fe lv lw lx ly b">codegen.yml</code>中使用了<code class="fe lv lw lx ly b">typescript-react-apollo</code>，它已经生成了特定于Apollo的查询。</p><p id="7717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在React应用程序中配置Apollo客户端和提供者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="363d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以开始使用我们生成的查询了！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4095" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用生成的GraphQL查询</h1><p id="0e0a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">所有的环境都设置好了，是时候使用我们生成的查询了。使用Apollo集成时，生成器将提供自动或手动查询:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="c9b7" class="no mo it ly b gy np nq l nr ns">// trigger automatically when components renders<br/>const { data, loading} = useAllPlanetsQuery();</span><span id="b626" class="no mo it ly b gy nt nq l nr ns"><br/>// triggered manually by calling "getPlanets" method<br/>const [getPlanets, { loading, data }] = useAllPlanetsLazyQuery();</span></pre><p id="a945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据不同的场景，您将使用其中的一种，它们的数据类型是相同的。让我们看看<code class="fe lv lw lx ly b">PlanetsQuery</code>的返回类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="486f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这一切是如何运作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fe18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到整件事是多么天衣无缝了吗？由于一切都是生成的，我们不必担心FE运行不同步——它已经为我们完成了。我们的后端和前端完全同步。</p><p id="bca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从生成的文件中提取通用类型，如下所示:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="36cc" class="no mo it ly b gy np nq l nr ns">import type { Planet } from ‘../generated/graphql’;</span></pre><p id="1816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者获取确切的查询结果类型，并从查询中提取自定义类型:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="f3fa" class="no mo it ly b gy np nq l nr ns">import type { AllPlanetsQuery } from '../generated/graphql';</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8b11" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/bcef92982d192fc6ec9a15b19285abd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NPzicXpBl1UZDtzj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="bb3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们已经看到了一个简单的GraphQL查询生成，但是这个工具还可以做更多的事情。你可以使用像<code class="fe lv lw lx ly b">Fragments</code>、<code class="fe lv lw lx ly b">Mutations</code>这样的特性——有相当多的插件可供选择。</p><p id="3c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Graphql Code Generator</code>是一个伟大的工具，为我们做所有繁重的工作。根据我们的需求进行配置和定制非常容易。它将减少所需的人工工作量，而人工工作量总是容易出现人为错误。</p><p id="2a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的实践是让<code class="fe lv lw lx ly b">yarn generate</code>任务在CI中运行，以确保在开发时没有任何东西被破坏。</p><p id="f35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多GrahpQL内容将很快呈现在您面前！</p><p id="e719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您渴望获得更多的Typescript内容，请查看我的关于映射类型有多有趣的文章。：</p><div class="ok ol gp gr om on"><a href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">掌握TypeScript的映射类型</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">了解如何像专家一样处理Typescript映射类型</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>