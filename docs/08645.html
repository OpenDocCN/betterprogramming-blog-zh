<html>
<head>
<title>A Brief History Of Low-Code Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">低代码开发简史</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/low-code-history-b756c095494f?source=collection_archive---------7-----------------------#2021-05-25">https://betterprogramming.pub/low-code-history-b756c095494f?source=collection_archive---------7-----------------------#2021-05-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="c25f" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">软件工程</a></h2><div class=""/><div class=""><h2 id="bee1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">回到可视化编程的根源</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/1d3e98b56b6db31af7f9602151a71352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jUvF1pppUi16lm9l"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@ryoji__iwata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">岩田良治</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4def" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">“低代码”是一种可视化编程方法，允许公司使用图形界面相对快速地组装软件应用程序，而不必直接编写代码。</p><p id="0ac5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">尽管“低代码开发”一词是由一家市场研究机构在2016年作为许多提供商的通用术语引入的，但低代码背后的想法并不新鲜。在这篇文章中，我们将看到这种范式是如何随着时间的推移而发展的，以及它曾经面临过哪些问题。</p><pre class="kt ku kv kw gu mf mg mh mi aw mj bi"><span id="d343" class="mk ml iu mg b gz mm mn l mo mp"><strong class="mg je">Table of Contents</strong></span><span id="3d60" class="mk ml iu mg b gz mq mn l mo mp">∘ <a class="ae li" href="#c552" rel="noopener ugc nofollow">1970s - 1990s: 4GL</a><br/>∘ <a class="ae li" href="#2949" rel="noopener ugc nofollow">1990s: Rapid Application Development (RAD)</a><br/>∘ <a class="ae li" href="#377c" rel="noopener ugc nofollow">2001: Model-Driven Architecture (MDA)</a><br/>∘ <a class="ae li" href="#3abf" rel="noopener ugc nofollow">2007: Mobile Platforms</a><br/>∘ <a class="ae li" href="#5f53" rel="noopener ugc nofollow">2016: Low-Code &amp; LCDP</a><br/>∘ <a class="ae li" href="#1988" rel="noopener ugc nofollow">2020: An Urgent Need For Digital Transformation</a><br/>∘ <a class="ae li" href="#9524" rel="noopener ugc nofollow">Has Low-Code Learned From History?</a></span></pre></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><h1 id="c552" class="my ml iu bd mz na nb nc nd ne nf ng nh kj ni kk nj km nk kn nl kp nm kq nn no bi translated">20世纪70年代至90年代:4GL</h1><p id="0928" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">低代码开发平台可以追溯到第四代编程语言(4GL)，这是一个从20世纪70年代到90年代开发的概念，与3GL的大部分开发重叠。</p><ul class=""><li id="e3cc" class="nu nv iu ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated"><strong class="ll je"> 3GL示例:</strong> C，C++，Java，Python，PHP，Perl，C#，BASIC，Pascal，Fortran，ALGOL，COBOL</li><li id="18f9" class="nu nv iu ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated"><strong class="ll je"> 4GL示例:</strong> ABAP、Unix Shell、SQL、PL/SQL、Oracle Reports、R</li></ul><p id="15d3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在他1982年的书《没有程序员的应用程序开发》(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)(没有程序员的应用程序开发)。</p><p id="0efd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第四代编程语言是指非过程化和高级规范语言，包括对数据库管理、报告生成、数学优化、<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-library-dynamic-stepper-2ba05ab40228">图形用户界面(GUI) </a>开发和<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/programming-buzzwords-9e94a3544eed"> web开发</a>的支持。</p><h1 id="2949" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">20世纪90年代:快速应用开发</h1><p id="dab0" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">作为对瀑布模型的回应，我们已经看到快速应用程序开发(RAD)在20世纪90年代获得了发展势头，当时通过使用像Visual Basic、Delphi和Oracle Forms这样的工具可视化地“组装”桌面应用程序的概念变得流行起来。</p><p id="0a6a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">瀑布模型是一个计划驱动的过程，被软件开发行业使用了很长时间。它是在20世纪70年代和80年代开发的，基于传统的工程模型:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oo"><img src="../Images/e727ec9221cf85b4b4a3d018f2d7c520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KpPcr0C_bi7zwkKd.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">瀑布模型:进度从上到下流动，就像瀑布一样(<a class="ae li" href="https://en.wikipedia.org/wiki/Waterfall_model#/media/File:Waterfall_model.svg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8fc3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">RAD工具作为易学的环境脱颖而出:最终用户应该关注GUI，业务逻辑是逐步添加的。</p><p id="0790" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">UI和逻辑都可以作为组件存储在组件面板中。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj op"><img src="../Images/5ef1e60309920c2e77401072f0dd61ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FPPw5pS8iBGaUkBs.JPG"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">詹姆斯·马丁的快速发展方法的各个阶段(<a class="ae li" href="https://en.wikipedia.org/wiki/Rapid_application_development#/media/File:RADModel.JPG" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="faa7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，RAD工具有其局限性:</p><ul class=""><li id="1c34" class="nu nv iu ll b lm ln lp lq ls nw lw nx ma ny me nz oa ob oc bi translated">它们通常是专有的。这意味着离开工具的环境是不可能的，或者只能在有限的范围内。目标环境通常是指定的，例如，用于Visual Basic和Delphi的Microsoft Windows、Oracle应用服务器和用于Oracle Forms的数据库。</li><li id="ecd2" class="nu nv iu ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">在一个应用程序上协同工作是困难的，或者至少是有限制的，因为缺乏模块化。</li><li id="ba86" class="nu nv iu ll b lm od lp oe ls of lw og ma oh me nz oa ob oc bi translated">RAD工具，如Visual Cafe和Borlands JBuilder，在速度和资源需求上苦苦挣扎。它们是用Java编写的，这在当时意味着对资源的巨大需求。</li></ul><h1 id="377c" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">2001:模型驱动架构(MDA)</h1><p id="53ff" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">为了缩短部门和开发之间的距离，对象管理小组(OMG)在2021年推出了模型驱动架构(MDA ),作为一种软件设计方法，提供了一套将规范结构化和表达为模型的指南。</p><p id="2004" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">模型支持领域的整体视图，考虑技术和业务需求，并且随后将被转换成可执行代码。生成器和<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/compiler-vs-interpreter-d0a12ca1c1b6">解释器</a>在开发和运行时用于从模型中生成或解释代码。</p><p id="584d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">随着MDA和<a class="ae li" href="https://en.wikipedia.org/wiki/Software_factory_(Microsoft_.NET)" rel="noopener ugc nofollow" target="_blank">微软软件工厂</a>的出现，模型驱动软件开发(MDSD)已经成为使用UML(统一建模语言)和BPMN(业务流程建模符号)等工具来应用它的<a class="ae li" href="https://levelup.gitconnected.com/a-day-in-the-life-of-a-software-engineer-cb817cf13d0" rel="noopener ugc nofollow" target="_blank">程序员</a>的兴趣中心。</p><h1 id="3abf" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">2007年:移动平台</h1><p id="7bf6" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">2007年苹果iPhone iOS加入移动设备市场，一年后谷歌Android出现，各种移动平台应运而生。</p><p id="4c24" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">开发人员积极使用Android Studio和Xcode等可视化编辑器来实现在Android和iOS上本地运行的应用。</p><p id="98aa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是移动设备上桌面应用的复兴。</p><p id="6b0a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-dynamic-layout-with-ngtemplate-8b6faa995a8f">响应式网页设计</a>和进步网络应用(PWA)等技术已经威胁到了移动应用，因为它们能够为小型设备提供网络应用，具有良好的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-onpush-change-detection-f629cbce0bfa">用户体验</a> (UX)，并且不需要移动开发平台。</p><h1 id="5f53" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">2016:低码&amp; LCDP</h1><p id="ee1c" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">在2016年由Forrester Group 出版后,“低代码”一词变得公开。</p><p id="ff6c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们已经看到了低代码开发平台(LCDP)的出现——其起源可以追溯到2011年——目的是在一个屋檐下获得尽可能多的概念，使编写代码变得不必要或至少显著减少。</p><p id="87f6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">低代码平台包含了RAD和MDSD的过程，并考虑了ALM(应用生命周期管理)以及开发、测试和生产环境的持续集成(CI)或持续部署(CD)。</p><p id="8dcd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了支持整个环境的“拖放”创建，必须提供PaaS(平台即服务)。为此，有内部提供，如<a class="ae li" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>容器平台，但通常是相应的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/serverless-bcc0d2b65b41">云服务</a>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/2a0e111ec451bc4c2852fafb554b6d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*hwNzsMSVmcmFRjuhvc8vYA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Lofi Dewanto和Manuel Klein的低代码平台的组件和架构(<a class="ae li" href="https://www.heise.de/developer/artikel/Low-Code-Low-Quality-4134288.html?seite=2" rel="noopener ugc nofollow" target="_blank">德文原图</a>)</p></figure><p id="bdef" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">aPaaS(应用程序平台即服务)提供了应用程序整个生命周期所需的一切:从第一个规划阶段到开发、验收和运营。</p><h1 id="1988" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">2020:迫切需要数字化转型</h1><p id="3425" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">2020年，新冠肺炎疫情向许多公司展示了他们在数字化方面的落后。</p><p id="5a24" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了保持业务运营并满足员工和客户的需求，他们被迫升级应用程序并构建新的应用程序来填补现有的流程缺口。</p><p id="e4d1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，低代码的受欢迎程度有所提高。这一势头将在2021年延续。</p><h1 id="9524" class="my ml iu bd mz na oj nc nd ne ok ng nh kj ol kk nj km om kn nl kp on kq nn no bi translated">Low-Code有没有吸取历史的教训？</h1><p id="ece9" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">像4GL这样的技术，在几十年前很流行，曾承诺快速满足客户需求，但最终因为许多限制而失败，并且自推出以来其受欢迎程度已经下降。</p><p id="07e0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在21世纪，许多RAD环境从雷达上消失了。像Swing和SWT这样的“经典”UI工具包变得越来越没有意义，因为趋势是为<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-custom-autocomplete-7ffb479477e7"> web </a>编写应用程序。</p><p id="9b04" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">UI设计越来越多地使用HTML、CSS和<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/javascript-history-and-future-71b0ceb737aa"> JavaScript </a>来完成，这创造了网页设计师这一额外的职业。不同的web浏览器、操作系统(如Linux、macOS)以及从PC到智能手机再到可穿戴设备的设备都被用作目标系统。</p><p id="c009" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我们看低代码供应商时，我们注意到他们中的大多数都学习过历史。他们知道哪些问题困扰着4GL和拉德，并试图修复他们系统中的这些问题。</p><p id="501b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">随着企业将目光投向人工智能、机器人、机器学习和物联网等新技术，低代码解决方案也在不断增长，以提供这些能力。</p></div><div class="ab cl mr ms hy mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="in io ip iq ir"><p id="fa89" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯，独家获取</strong> </a> <strong class="ll je"> </strong>或在此注册Medium <a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">。</a></p></div></div>    
</body>
</html>