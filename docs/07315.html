<html>
<head>
<title>Is PHP Still Relevant in 2021?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP在2021年还相关吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-php-still-relevant-in-2021-19580c75855?source=collection_archive---------1-----------------------#2021-01-04">https://betterprogramming.pub/is-php-still-relevant-in-2021-19580c75855?source=collection_archive---------1-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">话题已经从PHP转移到了JavaScript和Python。PHP还重要吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a29088d4a58209dc5a283e122974b8a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlXcsAg6CcjB0T6ScLOdtQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ollila?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米隆·奥利拉</a>在<a class="ae ky" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e276" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">PHP简史</strong></h1><p id="1e45" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">PHP是由拉斯马斯·勒德尔夫在1994年开发的。勒多夫开发了一系列脚本来跟踪对他的在线简历的访问，并将其命名为“个人主页工具”，后来演变为“PHP工具”他不断向这个套件添加更多的工具，并在某个时候完成了工具的重写，包括添加数据库交互等功能——从而将它变成了一个更完整的框架。</p><p id="be84" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从那时起，这些工具演变成了更复杂的原语，并在1995年开源后不断赢得更多用户。更详细的语言历史可以在PHP官方网站上找到。</p><p id="ac89" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">截至目前，PHP语言的最新版本是8.0。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f3c4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">PHP有什么问题？</strong></h1><p id="8397" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这种语言多年来一直是众矢之的，人们理所当然地提出了他们对这种语言的问题——尤其是旧版本。这种语言的开发意图是成为一种模板语言，而不是一种成熟的编程语言。因此，它有一些缺点，使得维护较大的应用程序特别困难。</p><h2 id="c082" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">弱打字</strong></h2><p id="32d1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我个人不喜欢这种语言的一个部分是弱类型，它允许组合不同的类型并隐式地转换它们。考虑下面的例子:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="05c1" class="mz lh it nm b gy nq nr l ns nt">echo "1" + 3;<br/>echo 1 + "3";<br/>echo "1" + "3";</span></pre><p id="d2be" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所有这些操作的结果是<code class="fe nu nv nw nm b">4</code>，这意味着该语言在加法运算符的上下文中将字符串中的数字转换为整数。这在某些情况下可能是可取的，或者可能会节省一些代码，但是项目越大，维护起来就越困难。</p><p id="2ad2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">该语言的最新版本已经开始引入对这类奇怪和无效操作的警告，这意味着它们要么已经被否决，要么正在被否决的路上。</p><h2 id="ed48" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">缺少名称空间</strong></h2><p id="e8bf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">PHP 5.3版引入了对名称空间的支持，这意味着所有早期的项目都必须构建自己的名称空间，这通常依赖于向类名和方法名添加名称空间。这要求到处都有长得荒谬的名字。对于使用以前版本开发的项目，经常会看到名为<code class="fe nu nv nw nm b">Payments_Provider_ProcessorProvider_SomeExternalServiceProvider</code>的类，而它本来可以简单地命名为<code class="fe nu nv nw nm b">SomeExternalServiceProvider</code>。在大多数情况下，这会导致非常冗长的代码，使得阅读和浏览代码变得更加困难。</p><p id="eaa4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不过，这种语言的最新版本没有这个问题。</p><h2 id="1748" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">标准库函数不一致</strong></h2><p id="d37a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我并不是说这种语言的标准库不好，但是有人会说它可以变得更好。公平地说，这种语言已经改进了很多，但是标准库的早期版本——由于向后兼容的结果，它已经被使用、引用和支持——缺乏一致性。虽然这是一个小小的干扰，但这意味着许多标准库函数有不同的命名约定、参数名和顺序，这使得假设默认值和行为变得更加困难。</p><p id="bd5a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从文档中可以看出，字符串方法的命名存在一些不一致:</p><ul class=""><li id="fb49" class="nx ny it ma b mb mu me mv mh nz ml oa mp ob mt oc od oe of bi translated"><code class="fe nu nv nw nm b"><a class="ae ky" href="https://www.php.net/manual/en/function.strpos.php" rel="noopener ugc nofollow" target="_blank">strpos(string $haystack, string $needle, int $offset = 0): int|false</a></code>:查找子串在字符串中第一次出现的位置。</li><li id="c953" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><code class="fe nu nv nw nm b"><a class="ae ky" href="https://www.php.net/manual/en/function.str-split.php" rel="noopener ugc nofollow" target="_blank">str_split(string $string, int $length = 1): array</a></code>:将字符串转换成数组。</li><li id="664c" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><code class="fe nu nv nw nm b"><a class="ae ky" href="https://www.php.net/manual/en/function.explode.php" rel="noopener ugc nofollow" target="_blank">explode(string $separator, string $string, int $limit = PHP_INT_MAX): array</a></code>:一串一串的拆。</li></ul><p id="85ca" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">三种不同的功能:一种带有<code class="fe nu nv nw nm b">str</code>前缀，另一种带有<code class="fe nu nv nw nm b">str_</code>前缀，第三种没有前缀。<code class="fe nu nv nw nm b">$string</code>参数是<code class="fe nu nv nw nm b">str_split</code>的第一个参数，但第二个参数是<code class="fe nu nv nw nm b">explode</code>的参数。你可以在文档中查看所有的字符串方法<a class="ae ky" href="https://www.php.net/manual/en/ref.strings.php" rel="noopener ugc nofollow" target="_blank">，每个模式都有许多遵循相似模式的函数，这意味着这些函数没有太多的一致性。</a></p><h2 id="589b" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">超级全局变量</strong></h2><p id="3a44" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这更多的是个人选择，但是我讨厌使用全局变量，因此也讨厌使用<a class="ae ky" href="https://www.php.net/manual/en/language.variables.superglobals.php" rel="noopener ugc nofollow" target="_blank">超全局变量</a>。尤其是如果你遇到一些自制的老项目，很可能会遇到像<code class="fe nu nv nw nm b">$_SERVER</code>或<code class="fe nu nv nw nm b">$_REQUEST</code>这样臭名昭著的变量。不要误解我的意思:这些有时非常有用，最终会被用到。然而，为了能够安全地使用这些值，将它们封装到可重用的类中应该是第一步。如果没有，接触这些值或者在稍微大一点的项目中做任何改变都会产生非常复杂的体验，其中有许多对这些值的隐藏依赖。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a480" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">PHP有什么好的？</strong></h1><p id="8539" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">尽管它在许多人的嘴里留下了不好的印象，但在过去的几年里，这门语言本身已经有了很大的进步。随着PHP 7的发布，这种语言经历了一个现代化的过程，在这个过程中，许多好的特性被引入到语言的基础中，速度得到了提高，可用性也增加了很多。</p><h2 id="d085" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">类型提示</strong></h2><p id="30ab" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是我最喜欢的使遗留PHP代码现代化的方法之一:使用非强制类型提示来处理类型转换并为代码提供文档。看看下面这个简单的函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="48d4" class="mz lh it nm b gy nq nr l ns nt">function isValueSomething($value) {}</span></pre><p id="4496" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您包括类型提示，它将变成如下形式:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6e32" class="mz lh it nm b gy nq nr l ns nt">function isValueSomething(string $value): bool {}</span></pre><p id="c0a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">仅仅通过查看签名，我们就能够知道它需要一个字符串值，并将返回一个布尔结果。有人可能会说，命名约定在这里也很有用，但是这些类型提示确保了值是这些类型的，并为IDE提供了很多自动完成和带有警告等的静态分析的能力。</p><p id="5ecc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从PHP 7.4开始，PHP也允许为类定义类型属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="45ad" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这意味着您的<code class="fe nu nv nw nm b">Person</code>对象将有一个字符串名和姓，一个整数年龄，以及一个可为空的作业字符串值。当你拥有越多的类时，能够定义这一点变得非常有用。</p><h2 id="1dc1" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">语法改进</strong></h2><p id="9304" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">PHP现在有很多语法上的改进:</p><ul class=""><li id="0516" class="nx ny it ma b mb mu me mv mh nz ml oa mp ob mt oc od oe of bi translated"><a class="ae ky" href="https://www.php.net/manual/en/functions.arrow.php" rel="noopener ugc nofollow" target="_blank">箭头功能</a> : <code class="fe nu nv nw nm b">fn ($x, $y) =&gt; $x + $y;</code></li><li id="9ba9" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">零合并运算符:<code class="fe nu nv nw nm b">$value = $array['key'] ?? 'default value';</code></li><li id="a44a" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">零合并分配:<code class="fe nu nv nw nm b">return $cache['key'] ??= computeSomeValue('key');</code></li><li id="de8b" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">阵列展开:<code class="fe nu nv nw nm b">$first = ['a', 'b']; $second = ['c', 'd']; $final= [...$first, ...$second];</code></li><li id="8db2" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><a class="ae ky" href="https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments" rel="noopener ugc nofollow" target="_blank">命名论据</a> : <code class="fe nu nv nw nm b">array_fill(start_index: 0, num: 100, value: 50);</code></li><li id="13e6" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">数字文字分隔符:<code class="fe nu nv nw nm b">299_792_458</code></li></ul><p id="3bdd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">除了这些语法上的改进，它还包括更复杂的改进。</p><h2 id="cca8" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">建造师晋升</strong></h2><p id="b27a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">看看下面的<code class="fe nu nv nw nm b">Person</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7271" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">没有这些不必要的冗长代码，<a class="ae ky" href="https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion" rel="noopener ugc nofollow" target="_blank"> PHP 8支持</a>编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6d97" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">很整洁，不是吗？</p><h2 id="10e4" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">空安全操作符</strong></h2><p id="24c6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是JavaScript等其他语言中已经存在的东西，但PHP不支持这一点。看看我从<a class="ae ky" href="https://www.php.net/manual/en/language.oop5.basic.php#language.oop5.basic.nullsafe" rel="noopener ugc nofollow" target="_blank"> PHP文档</a>中抓取的以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="71de" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就是用旧版本PHP编写的关于空检查的逻辑。新的nullsafe操作符允许您将它简单地转换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3d5c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">是不是很华丽？</p><h2 id="16d6" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">联合类型</strong></h2><p id="271d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">尽管这不是我最喜欢的特性，但对于已经有多种可能类型并且我们没有任何类型提示的情况，它仍然是有价值的。<a class="ae ky" href="https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.union" rel="noopener ugc nofollow" target="_blank">联合类型</a>简单地允许你定义多种类型的值作为选项。由于联合类型，下面的代码变得有效:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d588" class="mz lh it nm b gy nq nr l ns nt">function doSomething(int|string $value): bool|array {}</span></pre><p id="798c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通常，拥有多种返回类型表明有改进的机会，但是以前的PHP版本根本不允许我们为这样的情况定义类型，所以拥有这种类型仍然是一种改进。</p><h2 id="3573" class="mz lh it bd li na nb dn lm nc nd dp lq mh ne nf ls ml ng nh lu mp ni nj lw nk bi translated"><strong class="ak">性能</strong></h2><p id="c7ca" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">与其他语言相比，我没有任何硬性的数字，但与以前的版本相比，PHP随着时间的推移已经有了显著的改进。除了PHP 7超越PHP 5.6之外，所有后续版本都带来了一些改进，而且这一趋势还在继续。Phoronix 做的一些基准测试<a class="ae ky" href="https://www.phoronix.com/scan.php?page=article&amp;item=php-74-benchmarks&amp;num=2" rel="noopener ugc nofollow" target="_blank">显示，最新的PHP 8比PHP 5.6快三倍多。原帖里有更详细的测试，一定要看一下。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/c89b85bcb849e536e1e5bf41db1ddc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzGXHmY6jA8CjBYdTNEycQ.png"/></div></div></figure><p id="5e8f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">除了这些基准测试，<a class="ae ky" href="https://kinsta.com/blog/php-benchmarks/" rel="noopener ugc nofollow" target="_blank"> Kinsta还使用WordPress等工具进行了一些真实世界的基准测试。以下是WordPress 5.3的结果:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/c789634014985dd7fec3d15cdfc66518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJznnvyszYNmghlb7v0qsw.png"/></div></div></figure><p id="c7d5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">他们分享的数字结果如下:</p><ul class=""><li id="1bbc" class="nx ny it ma b mb mu me mv mh nz ml oa mp ob mt oc od oe of bi translated">WordPress 5.3 PHP 5.6基准测试:<code class="fe nu nv nw nm b">97.71 req/sec</code></li><li id="db88" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">WordPress 5.3 PHP 7.0基准测试结果:<code class="fe nu nv nw nm b">256.81 req/sec</code></li><li id="36b4" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">WordPress 5.3 PHP 7.1基准测试结果:<code class="fe nu nv nw nm b">256.99 req/sec</code></li><li id="c260" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">WordPress 5.3 PHP 7.2基准测试结果:<code class="fe nu nv nw nm b">273.07 req/sec</code></li><li id="2013" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">WordPress 5.3 PHP 7.3基准测试结果:<code class="fe nu nv nw nm b">305.59 req/sec</code></li><li id="fdd9" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated">WordPress 5.3 PHP 7.4基准测试结果:<code class="fe nu nv nw nm b">313.42 req/sec</code></li></ul><p id="1f23" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这些基准还不包括PHP 8，但是7.4能够处理的请求是5.6的三倍，这是一个非常显著的改进。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f29c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">结论</strong></h1><p id="6c95" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">总的来说，PHP在过去的几年里有了很大的改进，并且已经成为一种乐趣。我专业地使用Golang、PHP和Python，并且我对PHP有最多的经验，所以我在这里有很大的偏见。然而，我认为PHP是介于灵活性和可维护性之间的最佳选择。它拥有做疯狂事情的所有灵活性，它有一个灵活的类型系统，允许逐步改进遗留代码，它对许多用例来说足够快，并且仍在改进，它背后有一个令人难以置信的开源社区。</p><p id="cad1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于那些对旧版本的PHP有不好的体验的人，我建议再试一次。有可能你仍然不喜欢它，但是我相信随着最新版本的出现，许多老版本的语言会有所改变。</p><p id="0f9b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢阅读！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d3ce" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">资源</h1><ul class=""><li id="b8ec" class="nx ny it ma b mb mc me mf mh op ml oq mp or mt oc od oe of bi translated"><a class="ae ky" href="https://www.php.net/docs.php" rel="noopener ugc nofollow" target="_blank"> PHP文档</a></li><li id="6b0d" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><a class="ae ky" href="https://www.php.net/releases/8.0/en.php" rel="noopener ugc nofollow" target="_blank"> PHP 8发布公告</a></li><li id="726d" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><a class="ae ky" href="https://www.phoronix.com/scan.php?page=article&amp;item=php-74-benchmarks&amp;num=2" rel="noopener ugc nofollow" target="_blank"> Phoronix PHP基准测试</a></li><li id="7311" class="nx ny it ma b mb og me oh mh oi ml oj mp ok mt oc od oe of bi translated"><a class="ae ky" href="https://kinsta.com/blog/php-benchmarks/" rel="noopener ugc nofollow" target="_blank"> Kinsta PHP基准测试</a></li></ul></div></div>    
</body>
</html>