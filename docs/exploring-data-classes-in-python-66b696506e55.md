# 探索 Python 中的数据类

> 原文：<https://betterprogramming.pub/exploring-data-classes-in-python-66b696506e55>

## 了解数据类

![](img/b0313e808dcc190c3a01e4410ad9dc25.png)

安妮·斯普拉特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

我们经常创建主要目的是保存数据的类。在这样的类中，一些标准功能和效用函数通常可以从数据中机械地推导出来。在 Python 中，这被称为*数据类*，并用`@dataclass`进行注释。

现在我们知道了什么是数据类，下一个问题是我们如何在实时用例中使用它。如果您有一个数据列表，其中每个项目包含一组属性，我们可以创建一个具有所需属性的数据类，并将其用作列表类型。

例如，如果您想要显示一个雇员列表，那么我们可以创建一个`Employee`数据类，并将其用作列表类型。数据类在各种编程语言中都很有名，因为它们具有保存实体属性的一般性质，这是实时编码中的常见用例。

# 数据类

数据类是用`@dataclass`装饰器标注的常规类。通常，它的主要目的是保存数据。除了注释之外，其余的语法与常规类相似。看一看:

我们可以使用构造函数来分配数据。开箱即用，数据类带有像`instantiate`、`compare`和`print`这样的基本特性。一旦我们创建了数据类的实例，我们就可以通过它们的名称直接访问属性。看一看:

Python 的优势之一是我们可以使用命名参数，当我们的数据类有太多属性时，命名参数就不那么模糊了。除此之外，我们不再需要按照属性声明的顺序来分配属性。看一看:

```
employee = Employee(**name=**"Jessica", **designation=**"Manager", **salary=**10000, **id=**2)
```

# 数据类的优势

我们可以使用一个普通的类来保存数据，但是我们需要手工编写所有的样板代码，比如`__init__`、`__repr__`、`__eq__`等等。功能。为了更好地理解核心优势，让我们在没有数据类装饰器的情况下创建相同的`Employee`类。看一看:

如果我们使用数据类装饰器，我们可以获得所有这些现成的特性。

# 默认值

我们已经看到了在创建实体或实体列表时，数据类是如何变得方便的。现在，是时候探索高级用例了，比如为数据类中的属性分配默认值。

根据我的经验，为数据类中的一个属性指定一个默认值是很方便的，因为大多数时候，特定的属性可能不会改变。举个例子，你拿一个创业软件公司来说，大部分员工都是开发人员。因此将`developer` 作为默认值赋给属性`designation` 是有意义的。看一看:

我们声明默认值需要遵循的一个主要条件是，默认值属性应该只在所有没有默认值的属性之后声明。如果不这样做，它会显示以下编译时错误:

```
Fields with a default value must come after any fields without a default.
```

# 类型提示

大多数开发人员喜欢 Python 的原因之一是它的简单性。例如，我们不需要像在 Java 中那样提到变量的数据类型。这种行为可以在稍加修改的数据类中实现。

在数据类中，必须提到属性的数据类型。所以我们可以在声明数据类的属性时使用`Any`,并在运行时根据需要赋值。看一看:

# 数据类中的函数

属性通常在数据类中起着关键作用，但是有时候我们需要的不仅仅是属性。例如，如果我们以员工为例，有时当我们需要计算他们的年薪时，这可以通过在数据类内部编写函数来轻松处理。看一看:

# 不可变数据类

对于许多类型的数据类来说，这是一个好主意！为了使数据类不可变，在创建时设置`frozen=True`。只能通过构造函数为冻结数据类的属性赋值。看一看:

如果您试图更新一个冻结的类属性的值，它将抛出以下编译时错误:

```
‘Employee’ object attribute ‘name’ is read-only
```

# 遗产

Python 是面向对象的，正如它是函数式编程一样。这开启了数据类继承的可能性。该实现类似于普通类的实现。例如，有一个名为`EmployeeWithBenifits`的类，它从`Employee`数据类继承了雇员的基本信息。看一看:

我们应该记住，如果`EmployeeWithBenifits`类至少有一个属性没有默认值，那么`Employee`数据类中就不应该有任何默认值属性。

目前就这些。希望你学到了有用的东西。感谢阅读！