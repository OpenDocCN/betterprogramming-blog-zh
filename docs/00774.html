<html>
<head>
<title>One Express Server, Unlimited React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个快速服务器，无限的反应应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/one-express-server-unlimited-react-apps-9ea875863f2e?source=collection_archive---------8-----------------------#2019-07-11">https://betterprogramming.pub/one-express-server-unlimited-react-apps-9ea875863f2e?source=collection_archive---------8-----------------------#2019-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4de8950540f2b5acc313d086dceacda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVtCyRdJ6KOr4YswTtwMeA.jpeg"/></div></div></figure><p id="ec70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React 和<a class="ae kz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>显然是web开发技术方面的佼佼者。它们是MEAN ( <a class="ae kz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Mongo </a>，Express，<a class="ae kz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>，<a class="ae kz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node </a>)或MERN (Mongo，Express，React，Node)栈的一部分，被开发者广泛使用。</p><p id="cac7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多资源可以学习如何构建完整的stack React应用程序，其中很多都使用类似的模式来实现这一目标。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="4921" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">将一个Express服务器路由到多个React应用程序</h1><p id="a983" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">一段时间以来，我遇到的一个问题是将一个Express服务器路由到多个React应用程序，以简化生产过程。它将使事情变得易于维护、可伸缩和部署到云服务。</p><p id="9e2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的情况是一个包含三个不同部分的网站:管理员面板、销售者面板和前端，这基本上是世界(用户)可以访问的。</p><p id="6618" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最初着手解决这个问题的方法是将每个部分拆分到它自己的React应用程序中，有自己的<a class="ae kz" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>文件夹。</p><p id="66d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当涉及到部署时，我会在服务器的一个端口上运行我自己的API，并构建每个应用程序，以便将它们部署到我的<a class="ae kz" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>服务器上的public_html文件夹中。</p><p id="906d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React应用程序显然指向AWS EC2实例链接，该链接带有我为API打开的端口。</p><p id="7b98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下图更好地展示了我过去使用的架构。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b72ecff6868eb5f1ea30b6da66731932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*NrBAB6E7ro97V8GZlPYIZQ.png"/></div></figure><p id="bf63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以基本上，API使用永久npm模块运行。React应用程序是单独构建的，放在你正在使用的服务器的公共文件夹中。</p><p id="6ea3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本index.html和静态文件夹是前端React构建的输出，其他的在文件夹中，你可以通过链接并在你的资源中添加一个斜杠来访问它们。</p><p id="72b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如:</p><ul class=""><li id="6b9f" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><a class="ae kz" href="https://www.domain.com" rel="noopener ugc nofollow" target="_blank">https://www.domain.com</a>(用于前端)</li><li id="fe1b" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><a class="ae kz" href="https://www.domain.com/seller" rel="noopener ugc nofollow" target="_blank">https://www.domain.com/seller</a>(卖家面板)等。</li></ul><p id="bf91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个让多个React应用程序连接到一个API的解决方案，而不需要Express服务器为应用程序提供服务。</p><p id="0a14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它可以工作，但不是最有效的解决方案，尤其是在开发和部署方面。你必须不断地构建这三个应用程序。</p><p id="7635" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，如果您决定添加越来越多的出口供不同类型的用户访问，那么它将无法很好地扩展。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="b353" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">如何实现这一点</h1><p id="ea92" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">在研究并回到如何开发full stack React应用程序的最初方式后，我决定让一个Express服务器为应用程序提供服务，并根据用户访问的路径为正确的服务器提供服务。</p><p id="5b40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在网上找到了几个关于如何使用Express服务器为多个React应用提供服务的教程，但是它们要么不能正常工作，要么不是很简单。</p><p id="c034" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了遵循我的解决方案，你需要克隆我的<a class="ae kz" href="https://github.com/PierreJC/react-full-stack-multiple" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。自述文件为您提供了许多您需要的信息，但我将在下面讨论关键部分。</p><p id="57c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个repo中，我参考了<a class="ae kz" href="https://github.com/crsandeep/simple-react-full-stack" rel="noopener ugc nofollow" target="_blank"> crsanddeep </a>对典型的全栈React应用的repo，扩展了<a class="ae kz" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>配置，并改变了服务器为不同文件提供服务的方式。</p><p id="d9ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关键的部分是webpackwebpack是一个模块捆绑器。它的主要目的是捆绑JavaScript文件，以便在浏览器中使用。</p><p id="cefb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">webpack配置文件是奇迹发生的地方，我们将从它开始。</p><ol class=""><li id="5078" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky nd mv mw mx bi translated">确保你已经安装了webpack插件<code class="fe ne nf ng nh b">HtmlWebpackPlugin</code>。</li><li id="0997" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky nd mv mw mx bi translated">之后，我们开始将它导入文件。</li></ol><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/1ba5ba596c59c50251023a0942fc4020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4clD2uTKcFYhFHPpz4GHoQ.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">导入HtmlWebpackPlugin。CleanWebpackPlugin只是一个额外的工具，在重新生成之前清理构建文件夹。路径是导入的，因为它用于计算不同的路径，等等。</p></figure><p id="d20f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.定义多个入口路径，并使用<code class="fe ne nf ng nh b">[]</code>语法将输出名称更改为动态名称。这将为每个路径生成一个包，并存储在分发文件夹<code class="fe ne nf ng nh b">dist/static/js/<strong class="kd iu">x</strong>.bundle.js</code>下。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3c478852e519959d5c850c0bd57a9572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ltHaUX27syEHdJ5-VzWlYg.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">src文件夹中的每个react应用程序都有多个条目，并且<strong class="bd no"> filename </strong>属性使用[name]标签来标识使用上面定义的条目名称来更改包名称。</p></figure><p id="9a6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.最后，您需要为每个React应用程序定义多个<code class="fe ne nf ng nh b">HtmlWebpackPlugin</code>实例。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7dfcce873b37bb18529e4fae0e78e435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*ZMW0oxqjxkIcOpyMu4CJDg.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">三个页面的三个HtmlWebpackPlugin条目。如你所见，这可以很容易地扩展。</p></figure><p id="a6e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的<code class="fe ne nf ng nh b">HtmlWebpackPlugin</code>告诉webpack为路径中的每个条目生成一个<code class="fe ne nf ng nh b">index.html</code>，并将其存储在一个子文件夹中。</p><p id="402c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，主前端存储在根中；filename <code class="fe ne nf ng nh b">index.html</code>和其他文件都有各自目录下的文件名。</p><p id="6cd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在定义了webpack配置文件(这应该很简单)之后，您可以进入位于<code class="fe ne nf ng nh b">src/server/index.js</code>中的服务器文件，您将看到服务器指向您的构建文件夹(在我们的例子中是<code class="fe ne nf ng nh b">dist/</code>)。</p><p id="e2a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您有服务器端开发的经验，您应该能够扩展并让您的Express服务器基于所访问的路径做更多疯狂的事情。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/71f17b06480d939e08adbe05708b312c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOMEHCLlNCCqdzbWBAwU_A.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">app.use("/"，…)告诉Express静态文件在哪里。</p></figure><p id="4075" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码片段展示了如何根据用户访问的链接，定制Express来为存储在<code class="fe ne nf ng nh b">dist</code>文件夹中的不同目录提供服务。</p><p id="e3d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以看出这种做事方式是非常可扩展的。</p><p id="35a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加越来越多的React应用程序(或页面，无论你想叫它们什么)，拥有自己独立的模块，非常容易做到。您需要添加一个条目和一个新的<code class="fe ne nf ng nh b">HtmlWebpackPlugin</code>实例。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="25ad" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="06a8" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">感谢阅读。我一直想找到这个问题的解决方案，我很高兴与你分享。</p></div></div>    
</body>
</html>