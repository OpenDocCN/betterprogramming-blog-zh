<html>
<head>
<title>Get Started With the Combine Framework in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的Combine框架入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-the-combine-framework-in-ios-208c47b54ea1?source=collection_archive---------5-----------------------#2020-04-21">https://betterprogramming.pub/getting-started-with-the-combine-framework-in-ios-208c47b54ea1?source=collection_archive---------5-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="34cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解苹果新的声明式编程库中的协议和底层函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d35c8683494feaeab8be7ad03773381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ANgxFDXcS9hWjUGXgeHlw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹妮弗·博瑙尔在<a class="ae ky" href="https://unsplash.com/s/photos/start?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程语言是一种用来控制计算机行为的语言。这是一个写程序的符号。有成千上万种计算机编程语言，而且每年都在创造更多的语言。</p><p id="7279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多编程语言是以命令形式(即，作为要执行的操作序列)编写的，而其他语言使用声明形式(即，指定期望的结果，而不是如何实现它)。</p><p id="5d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS的UIKit，watchOS的WatchKit，MacOs APIs的AppKit它们都遵循命令式编程。假设我们可能有一个函数，当一个按钮被点击时，这个函数就会被调用。</p><p id="863b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令式框架带来的一些问题通常与代码中存储的值的状态有关。正在跟踪这些状态，以执行依赖于当前状态的工作类型。</p><p id="e9d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个简单的灯泡开关可以有两种状态，开或关。如果使用两个开关，并且每个组合根据状态导致不同的动作，会怎么样？这是四种不同的组合。如果现在使用三个或四个开关会怎么样？如你所见，它会很快变得复杂。</p><p id="9817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与命令式编程相反，使用声明式编程，可以对应用程序在不同状态下应该做什么和看起来像什么进行编程，并让它自己处理这些状态之间的移动。</p><p id="5fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式编程就是这样一种关注数据流和变化传播的范例。</p><p id="014c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年，苹果推出了一个名为Combine的原生第一方框架，基于编程的功能反应范式。在本文中，我们将会看到Combine框架的一些概念，并熟悉它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">异步编程</strong></h1><p id="d6a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">异步编程是一种编程类型，在这种编程中，一个工作单元在不同的线程上单独运行，不阻塞结果，并通知调用线程它已完成。</p><p id="6587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用异步编程的主要好处是提高应用程序性能和增强用户体验。</p><p id="9e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS中，有多种接口可以用来执行异步工作——KVO、通知中心、委托、闭包或块等。</p><p id="ae6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，实现所有这些模式会变得势不可挡。那么，有什么解决办法呢？解决这个问题的一种方法是使用反应式编程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ea9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">无功编程</strong></h1><p id="3c05" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据维基百科:</p><blockquote class="mz na nb"><p id="bb7c" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">在计算中，反应式编程是一种声明式编程范例，涉及数据流和变化的传播。</p><p id="b6e8" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">利用这种范例，可以容易地表达静态(例如，数组)或动态(例如，事件发射器)数据流，并且还传达相关联的执行模型内存在推断的依赖性，这有助于改变的数据流的自动传播。"</p></blockquote><p id="7bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应式编程是异步编程的一种方式。在反应式编程中，一切都可以是数据流。想象你的脸书源是一个数据流。人们可以听这个数据流并相应地作出反应。</p><p id="b495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种类型的编程，将要执行的代码和线程是分离的。这种方法对于一些只有一个线程来执行Node.js这样的代码的服务器端架构非常重要。</p><p id="810e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它只有一个线程来执行代码，如果它被阻塞，整个服务器将处于暂停状态，进一步的请求将无法执行。</p><p id="582a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Reactive Extensions ( <a class="ae ky" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank"> Rx </a>)是一个使用可观察序列和LINQ风格的查询操作符来编写异步和基于事件的程序的库。</p><p id="3f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Rx，可以表示多个异步数据流(来自不同来源，例如股票报价、tweets、计算机事件、web服务请求等。)，并使用<code class="fe ng nh ni nj b">IObserver&lt;T&gt;</code>接口订阅事件流。</p><p id="a902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当事件发生时，<code class="fe ng nh ni nj b">IObservable&lt;T&gt;</code>接口通知订阅的<code class="fe ng nh ni nj b">IObserver&lt;T&gt;</code>接口。</p><p id="0751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>是一个与Swift编程语言交互的框架。ReactiveX框架为跨不同编程语言重复使用的任务提供了一个公共词汇表。</p><p id="6095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得人们更容易关注语言本身的语法，而不是弄清楚如何将一个共同的任务映射到每一种新语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e0f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">组合框架</h1><p id="45d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>是苹果在WWDC 2019上展示的一个框架。它允许随着时间的推移处理值。它是函数式反应式编程的原生Swift实现，由苹果公司制造。</p><p id="6129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据苹果公司称“</p><blockquote class="nk"><p id="1581" class="nl nm it bd nn no np nq nr ns nt lu dk translated">"通过组合事件处理运算符来自定义异步事件的处理."</p></blockquote><p id="979e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">使用Swift Combine框架编程是声明性的、反应性的和功能性的。它涉及到链接函数和将值从一个传递到另一个。这些值可以表示多种异步事件。这就产生了价值流，从输入流向输出。</p><p id="75bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，合并可以表示为:</p><ul class=""><li id="ac87" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">联合=出版商+订户+运营商</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="02be" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">联合收割机的基本原理</strong></h1><p id="ed1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Combine声明发布者公开可以随时间变化的值。随着时间的推移可能发生的任何事情都可以由发布者来表示。订阅者用于接收发布者发出的值。</p><ul class=""><li id="0ec8" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">发布者协议声明了一种可以随时间传递一系列值的类型。发布者让操作者对从上游发布者接收的值进行操作，并重新发布它们</li><li id="3911" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">在发布者链的末端，订阅者在收到元素时对其进行操作。发布者仅在订阅者明确请求时发出值。这使您的订阅者代码可以控制它从所连接的发布者那里接收事件的速度。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b04f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">仅仅</h1><p id="ff3a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">只向每个订阅者发出一次输出，然后结束的发布者。它提供一个值，然后自动终止。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b83d66f06c5897c7cd3f255587d3d736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RbUvdFR0knGhO-qvmf7UA.png"/></div></div></figure><p id="8364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Combine有两个内置订户:<code class="fe ng nh ni nj b">assign</code>和<code class="fe ng nh ni nj b">sink</code>。发布者可以通过在发布者上调用这两者中的任何一个来连接它们。</p><h2 id="f352" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">分配(给:在:)</h2><p id="9c91" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将发行者的输出分配给对象的属性。</p><h2 id="d8c1" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">接收器(接收完成:接收值:)</h2><p id="6de6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">订阅者可以通过在发布者上调用<code class="fe ng nh ni nj b">sink</code>来连接到发布者。</p><p id="007d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个闭包在接收到<code class="fe ng nh ni nj b">Subscribers.Completion</code>时执行，这是一个枚举，指示发布者是正常完成还是出错失败。</p><p id="134e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个闭包在从发布者那里接收到元素时执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/92505072293262602ce9b2a05485c132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfOXJWMqIeBCStmXpaTFkQ.png"/></div></div></figure><p id="447e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户也可以在任何时候被取消，以避免收到简单的呼叫<code class="fe ng nh ni nj b">cancel()</code>事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/689f625d482d7f25dc6beb4d12edbd68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEEteVhbm0Es2--VE5IYOQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="989a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">任何可取消的</strong></h1><p id="25b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个类型擦除可取消对象，当取消时执行一个提供的闭包。</p><p id="97f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe ng nh ni nj b">AnyCancellable</code>实例在反初始化时自动调用<code class="fe ng nh ni nj b">cancel()</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="11ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">内置发行商</strong></h1><h2 id="85a7" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">通知中心</h2><p id="fa29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以使用发布者订阅通知。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/c09d447fdaa23c8a6339010f3e0ca759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH-91bPfJmTgA5dAYtOE0g.png"/></div></div></figure><h2 id="4eee" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated"><strong class="ak">定时器</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/a61028b176c53e6afb6c6ea1a7fdbb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8TR80Z_IW4sHsczntfNww.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">主题</strong></h1><p id="3b17" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">主题是一个发布者，它向外部调用方公开一个方法来发布元素。它用于通过调用其<code class="fe ng nh ni nj b">send(_:)</code>方法将值注入到流中。</p><h2 id="0815" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated"><strong class="ak">穿越主题</strong></h2><p id="42c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">向下游订户广播元素的主题。</p><p id="da2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">PassthroughSubject</code>提供了一种使现有命令式代码适应组合模型的便捷方式。</p><p id="24a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe ng nh ni nj b">CurrentValueSubject</code>不同，<code class="fe ng nh ni nj b">PassthroughSubject</code>没有初始值，也没有最近发布元素的缓冲区。如果没有订户，则<code class="fe ng nh ni nj b">PassthroughSubject</code>会丢弃值。</p><h2 id="9650" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated"><strong class="ak">当前值主题</strong></h2><p id="c0c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">包装单个值并在值改变时发布新元素的主题。</p><p id="ac8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe ng nh ni nj b">PassthroughSubject</code>不同，<code class="fe ng nh ni nj b">CurrentValueSubject</code>维护最近发布的元素的缓冲区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/bf53c0110874e1867befce19ccd06fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCKPW__sZyl7WqRMJvIBOA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6de2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">接收(开:选项:)</h1><p id="156c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">指定从发布者接收元素的计划程序。它将订阅调度程序设置在流的上游。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/9570faabd76ceabbd24f715bdb608ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UzeZvzGfORzSma18bMAnQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5956" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">发表</strong></h1><p id="493d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Published是用于将发布者附加到属性的属性包装。</p><p id="c8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，<code class="fe ng nh ni nj b">@Published</code>属性是受<em class="nc">类约束的</em>，这意味着它只能用于类的属性，而不能用于像结构这样的非类类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/e52c66d57b0cdc466a94cfbcfcf81e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3WNH1qMQXL7IUbDbCIS1g.png"/></div></div></figure><p id="836e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">$</code>符号和<code class="fe ng nh ni nj b">assign</code>函数，创建一个绑定来订阅并将<code class="fe ng nh ni nj b">textLabelValue</code>变量的值的任何变化分配给<code class="fe ng nh ni nj b">textLabel</code>文本属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a44" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">操作员</strong></h1><p id="af89" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Publisher上的扩展定义了各种各样的操作符，可以组合这些操作符来创建复杂的事件处理链。每个运算符返回一个实现发布者协议的类型。</p><h2 id="c55e" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">地图(_:)</h2><p id="9439" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它的行为类似于Swift中的地图。它用给定的闭包转换来自发布者的所有元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/54031077c016058a2c17070d5575d8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eG59bkvZd39x8OfM-Vv3TA.png"/></div></div></figure><h2 id="63ca" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">替换Nil(用:)</h2><p id="47e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用提供的元素替换发布者流中的nil元素。</p><h2 id="5171" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">过滤器(_:)</h2><p id="6c7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Filter从提供的闭包中移除所有不匹配条件的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/cf87a8e10d47804a5c3f3b1f772fdae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjhOI8v5YMnRczvrLRvfcA.png"/></div></div></figure><h2 id="2227" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">删除重复项()</h2><p id="b6fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">仅发布与前一个元素不匹配的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/b98d65ed886a494eb92c650f43892d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6WSa1Nqfg-4m6pIqGN0rg.png"/></div></div></figure><h2 id="a620" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated"><code class="fe ng nh ni nj b">reduce(_:_:)</code></h2><p id="82ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对所有接收到的元素应用闭包，完成后产生一个累积值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="decf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">用操作符链接发布者</strong></h1><p id="2104" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">运算符是在发布者上调用并返回另一个发布者的方法。</p><p id="2563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许通过一个接一个地应用它们来将它们链接在一起。每个操作者接收由链中的前一个操作者创建的发布者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/48d57892ce6ae8e9eb01ba2546ac735b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JvnGA4o2WxnH39ETiA4u4Q.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7ab8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">结论</strong></h1><p id="489c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Combine似乎是苹果做的一些很有前景的工作。联合收割机有如此多的优点。作为第一方，去除外部依赖并在本机获得相同功能的想法是一个巨大的胜利。</p><p id="402f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与SwiftUI配合得非常好。Combine的一个缺点是，它只支持基于iOS 13和更高版本的应用程序，这可能会限制一些开发者现在采用它。</p><p id="6341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读完本文后，我希望您现在对Combine框架以及如何使用它来简化同步工作有了基本的了解。</p><p id="c823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过采用Combine，通过集中事件处理代码和消除麻烦的技术，如嵌套闭包和基于约定的回调，可以使他们的代码更容易阅读和维护。</p></div></div>    
</body>
</html>