<html>
<head>
<title>Use Bull to Manage Job Queues in a Node.js Micro-Service Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Bull管理Node.js微服务堆栈中的作业队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-bull-to-manage-job-queues-in-a-node-js-micro-service-stack-7a6257e64509?source=collection_archive---------4-----------------------#2020-02-04">https://betterprogramming.pub/using-bull-to-manage-job-queues-in-a-node-js-micro-service-stack-7a6257e64509?source=collection_archive---------4-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当您切换到面向微服务的架构时，新的问题出现了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/881f37521d09922600424ea144f1c0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPrDWnp_VKb1bS6wB4_sfg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米奇·奥尼尔在<a class="ae ky" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="60f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当切换到面向微服务的架构而不是单一的整体架构时，新的问题出现了。过去简单的作业处理器不适合这种新的体系结构。作业可能不再由单个应用程序实例处理，而是由多个应用程序实例处理。</p><p id="10e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我找到了<a class="ae ky" href="https://optimalbits.github.io/bull/" rel="noopener ugc nofollow" target="_blank"> Bull </a>，一个基于Redis的Node队列，可以满足我的需求，但需要调整才能在这个新世界中工作。由于这个模块是开源的，我知道我对它的改进可以反馈到软件包中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">专业工作</h1><p id="2ef5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">比方说，我们想做一些专门的工作，例如扫描图像以提取文本。</p><p id="5f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，在你的主应用程序中做这项工作对大多数人来说没有意义。图像处理的需求不同于web服务器，可以优化为使用一组非常不同的硬件，如GPU。</p><p id="438b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需要进行图像处理时，一个作业队列就会派上用场，我们可以在远离面向用户的界面的独立进程中完成这项工作。</p><ul class=""><li id="9e0f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">从web UI从用户处获取要处理的图像。</li><li id="e06d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">将新的图像处理作业排入队列。</li><li id="15e3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">工作开始了。</li><li id="f249" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">作业结果被发送回应用程序。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3413" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">现有解决方案</h1><p id="0ca6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">两个在野外流行的软件包可以帮助你做前面提到的工作，它们是<a class="ae ky" href="https://github.com/collectiveidea/delayed_job/" rel="noopener ugc nofollow" target="_blank">延迟工作</a>和<a class="ae ky" href="http://www.celeryproject.org/" rel="noopener ugc nofollow" target="_blank">芹菜</a>。这些允许您使用键值存储来管理作业，比如<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>。</p><p id="7c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些假设<em class="nn">作业的处理和作业队列生活在同一个服务中。</em></p><p id="5fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与典型的微服务架构非常不同。如果您有一个执行任务的服务，例如图像处理器，和另一个充当作业队列的服务，我们不能在没有一些额外工作的情况下使用这些类型的包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b52e73c3fa87884211470a7d4ffb6ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*w4ds0M2ZVMykd6sE6B3IJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">典型设置(图1)</p></figure><p id="11a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e281eb76023b9e6a76549a2605053666.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*2ljI2y9V3DyGX07mbD_msQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">微服务设置(图2)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">搜索和搜索</h1><p id="9a21" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我最近遇到了这种情况，在搜索Node.js作业队列解决方案时，我发现了<a class="ae ky" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank"> Bull </a>。这个包非常快，是为了与Redis一起工作而构建的，并且有一个活跃的社区。</p><p id="d4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，开箱即用，这个包不支持跨服务作业排队(见图2)。</p><p id="13e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一下我们希望如何管理作业的生命周期。Bull的文档非常好，他们最近绘制了一个生命周期图，这将节省我们一些时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f5bf441bf00af480af2ddea75229b91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*mxP5T8NjbuqKVyRwiN2Y_Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">公牛的工作生命周期<a class="ae ky" href="https://github.com/OptimalBits/bull/blob/develop/docs/job-lifecycle.png" rel="noopener ugc nofollow" target="_blank">图</a></p></figure><p id="3480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bull有一个简单的方法来定义处理逻辑，即作业在<code class="fe nr ns nt nu b">active</code>队列中做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ef9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个任务进入<code class="fe nr ns nt nu b">waiting</code>队列时，Bull知道如何处理它并将其移动到<code class="fe nr ns nt nu b">completed</code>队列。使用Bull，它将自己管理所有的状态转换，这对于在同一进程中工作的应用程序来说是有意义的。</p><p id="1a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要切换到手动。您可能会想:“为了以这种新的方式工作，我们不定义这个<code class="fe nr ns nt nu b">process</code>方法怎么样？”我试过这个，它<em class="nn">起作用了！</em>前进到杂草中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3556" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><p id="cc57" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们新的Bull服务将介于可以排队作业的服务和可以工作的服务之间。我们现在需要做的是学习如何手动跨队列移动作业，并将这些方法公开为其他服务可以使用的API。</p><p id="1db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看代码库，方法<code class="fe nr ns nt nu b">queue.add()</code>、<code class="fe nr ns nt nu b">queue.getNextJob()</code>、<code class="fe nr ns nt nu b">job.moveToFailed()</code>和<code class="fe nr ns nt nu b">job.moveToCompleted()</code>都是我们需要的。</p><p id="d8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的问题是<code class="fe nr ns nt nu b">job.moveToFailed()</code>和<code class="fe nr ns nt nu b">job.moveToCompleted()</code>是私有的。这意味着作者没有编写这些公开使用的方法。</p><p id="d481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是有道理的，因为Bull从来就不是设计来做我们正在尝试做的事情的。调查回购中的GitHub问题，<a class="ae ky" href="https://github.com/OptimalBits/bull/issues/790" rel="noopener ugc nofollow" target="_blank">我发现有人试图做同样的事情</a>。</p><p id="9288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们新的作业队列服务器的实际实现相当简单，因为我们已经有了这些方法。看看我提出这个新模式后写的文档。</p><p id="9bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是我想要实现的，有人已经想到这么做了，这让我感觉更好。</p><p id="c36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始在生产中使用这段代码之前，一个好主意是打开一个pull请求来<a class="ae ky" href="https://github.com/OptimalBits/bull/pull/1017/files#diff-375fc823554b090375d9c47199cb5ee2R201" rel="noopener ugc nofollow" target="_blank">添加关于这个模式</a>的文档。Bull是一个相当活跃的项目，所以维护者或贡献者可以给我们很好的洞察力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8598" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">贡献的</h1><p id="29c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了验证我们新的作业队列服务，在参考文档<a class="ae ky" href="https://github.com/OptimalBits/bull/pull/1017/files#diff-375fc823554b090375d9c47199cb5ee2R201" rel="noopener ugc nofollow" target="_blank">中添加了</a>，使其成为社区中的已知模式。这鼓励了特性的使用，并可能导致其他用户在生产中使用它时发现问题。</p><p id="cf5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对这个项目的结果非常满意，因为我们不仅满足了我们的需求，还让我做出了开源贡献。</p><p id="684b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我理解了包的内部，也让我能够很容易地为我的用例添加特性。拥有一个了解细节的积极的项目维护者也使得整个过程顺利进行。</p></div></div>    
</body>
</html>