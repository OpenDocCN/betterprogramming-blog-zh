<html>
<head>
<title>How to Create a Custom Request Model in React Using RxJs, TypeScript, and Fetch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用RxJs、TypeScript和Fetch在React中创建自定义请求模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-fetch-model-for-react-using-rxjs-typescript-e2aecf113023?source=collection_archive---------6-----------------------#2020-05-15">https://betterprogramming.pub/creating-a-fetch-model-for-react-using-rxjs-typescript-e2aecf113023?source=collection_archive---------6-----------------------#2020-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2690" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让您的API请求更容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/965aa7b7c88ff5a4fb5fd3e5b4fbc013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kVcQFk27EFloVn1DRzjSw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="b7b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从角度到反应的转变并不容易。这不是因为框架之间的难度不同，而是因为我知道我会多么想念无缝的TypeScript集成，以及服务和管道，但最重要的是可能不得不放弃RxJs。也就是说，直到我做了一些研究，并意识到我不必这样做。因此，在本文中，我们将研究如何实现一个基本模型来使用JavaScript已经提供的Fetch API，以及TypeScript和RxJs。</p><p id="e25c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们使用以下命令创建一个全新的React项目，该项目立即支持TypeScript:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="2b31" class="lw lx iq ls b gy ly lz l ma mb">npx create-react-app rxjs-react --template typescript</span></pre><p id="e4fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想给当前的React项目添加类型脚本支持，请参考这个链接:<a class="ae mc" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank">https://create-react-app.dev/docs/adding-typescript/</a></p><p id="d6cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">设置好之后，切换到项目的根目录，运行以下命令来安装RxJs:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="23f6" class="lw lx iq ls b gy ly lz l ma mb">npm i rxjs</span></pre><p id="12cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装完成后，我们就可以开始工作了。现在，您可以在首选的代码编辑器中打开项目并开始编码。下面是我们将在项目中遵循的文件结构。请注意，这些必须放在我们的<code class="fe md me mf ls b">src</code>文件夹下。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="34ce" class="lw lx iq ls b gy ly lz l ma mb">-services<br/>|-api.service.ts<br/>|-index.ts</span><span id="9d6a" class="lw lx iq ls b gy mg lz l ma mb">-utils<br/>|-types.ts<br/>|-base-request-model.ts</span></pre><p id="4247" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从创建我们的<code class="fe md me mf ls b">types.ts</code>开始。在这里，我们将声明在执行我们的<code class="fe md me mf ls b">fetch</code>请求时将使用的允许类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c2c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将创建我们的<code class="fe md me mf ls b">base-request-model.ts</code>。这是我们将用来从我们的应用程序发出任何请求的模型。然后我们将这些类型导入到我们的<code class="fe md me mf ls b">BaseRequestModel</code>中，如下所示:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="6256" class="lw lx iq ls b gy ly lz l ma mb">import { Method, _Headers, Body } from "./types";</span></pre><p id="cada" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个例子，我们将使用<a class="ae mc" href="http://dummy.restapiexample.com/api/v1" rel="noopener ugc nofollow" target="_blank">http://dummy.restapiexample.com/api/v1</a>作为我们的<strong class="kx ir"> </strong> <code class="fe md me mf ls b">baseUrl</code> <strong class="kx ir"> </strong>，并在我们的构造函数中将我们的默认方法设置为<code class="fe md me mf ls b">GET</code> <strong class="kx ir"> </strong>。我们还将为属性实现我们自己的接口。该模型将包含以下内容:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="ae04" class="lw lx iq ls b gy ly lz l ma mb">const baseUrl = 'http://dummy.restapiexample.com/api/v1';</span><span id="e104" class="lw lx iq ls b gy mg lz l ma mb">interface Props {<br/>  url: string;<br/>  method?: Method;<br/>  headers: _Headers,<br/>  body?: Body<br/>}</span></pre><p id="c485" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们发出一个<code class="fe md me mf ls b">get</code>请求，而我们没有提供一个主体，我们就让主体可选。然后，我们通过使用关键字“implements”<strong class="kx ir"/>来实现接口，在我们的类名之后是接口名。然后，我们创建一个返回observable的方法，但在此之前，我们必须将observable接口导入到我们的文件中，以便使用它。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="7fd8" class="lw lx iq ls b gy ly lz l ma mb">import {Observable} from 'rxjs'</span></pre><p id="5c01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们在<code class="fe md me mf ls b">BaseModel</code>构造器中初始化我们的属性。一个<em class="mj">构造函数</em>基本上是一个特殊的方法，用于初始化对象，当一个类的对象被实例化时被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f1ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们实现请求方法。在这个方法中，我们将使用内置的Fetch API:</p><p id="30ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a></p><p id="708f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将返回包装在一个新的可观察对象中的已解决的承诺，其中我们使用可观察对象提供的<code class="fe md me mf ls b">next()</code> <strong class="kx ir"> </strong>方法传递我们的值，并使用<code class="fe md me mf ls b">complete()</code>关闭流。我们也可以使用<code class="fe md me mf ls b">error()</code> <strong class="kx ir"> </strong>方法抛出错误，类似于承诺如何使用<code class="fe md me mf ls b">resolve()</code> <strong class="kx ir"> </strong>和<code class="fe md me mf ls b">reject()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="40a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe md me mf ls b">BaseRequestModel</code>到此为止。下面是完整的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6941" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将创建我们的<code class="fe md me mf ls b">api.service.ts</code>。这里我们将声明我们自己的<code class="fe md me mf ls b">fetch</code>方法并返回一个observable，以及创建我们可能需要传递的任何自定义头。现在，我们将只关注<code class="fe md me mf ls b">post</code> <strong class="kx ir"> </strong>和<code class="fe md me mf ls b">get</code> <strong class="kx ir">，</strong>但是如果需要的话，可以随意添加您自己的方法并进一步开发。</p><p id="3fcb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将导入之前创建的<code class="fe md me mf ls b">BaseRequestModel</code>和在<code class="fe md me mf ls b">types.ts</code>中声明的<code class="fe md me mf ls b">Body</code>接口。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="e61a" class="lw lx iq ls b gy ly lz l ma mb">import BaseRequestModel from '../utils/base-request-model';<br/>import { Body } from '../utils/types';</span></pre><p id="58a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们实现包装在对象中的<code class="fe md me mf ls b">get</code>方法，这样我们就可以轻松地访问它们，就像这样:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="c3ee" class="lw lx iq ls b gy ly lz l ma mb">const ApiService = {<br/>  get: (route: string): Observable&lt;any&gt; =&gt; {<br/>  const headers = {<br/>    'Access-Control-Allow-Origin': '*'<br/>  };<br/>  const newBase = new BaseRequestModel(route, 'GET', headers);<br/>  return newBase.request();<br/>  },<br/>}</span></pre><p id="2f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这里所做的基本上是创建我们的<code class="fe md me mf ls b">BaseRequestModel</code>的一个新实例。我们传递由构造函数定义的路由、方法和头，然后返回<code class="fe md me mf ls b">request()</code> <strong class="kx ir"> </strong>方法属性，这是一个可观察的流，我们可以在以后订阅它来访问我们发出的请求的值。</p><p id="7e6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们对post方法重复这个步骤，除了一个表单参数，它的类型是从我们的头中的类型和内容类型导入的。然后，我们将表单传递给新的<code class="fe md me mf ls b">BaseRequestModel</code>(这就是为什么我们将body设置为可选的)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="933a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了结束这一部分，我们将使用我们的<code class="fe md me mf ls b">index.ts</code> <strong class="kx ir">，</strong>导出这些方法，我们将在我们的服务文件夹的根目录下创建这些方法。我们只需要将export关键字添加到我们的<code class="fe md me mf ls b">ApiService</code> <strong class="kx ir"> </strong>变量中。下面是完整的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fbdc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们可以通过简单地将<code class="fe md me mf ls b">ApiService</code>从我们的服务导入到任何我们想从中获取方法的组件中来测试这一点。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="50ba" class="lw lx iq ls b gy ly lz l ma mb">import { ApiService } from "./services";</span></pre><p id="e28d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们将在我们的<code class="fe md me mf ls b">App.tsx</code> <strong class="kx ir">中使用它。</strong>我们首先为我们的员工创建一个界面。</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="67a3" class="lw lx iq ls b gy ly lz l ma mb">interface Employee {                         <br/>   id: string;                         <br/>   employee_name: string;                         <br/>   employee_salary: string;                         <br/>   employee_age: string;                        <br/>   profile_image?: string;                       <br/>}</span></pre><p id="a38e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">猫王接线员"？"表明<code class="fe md me mf ls b">profile_image</code> <strong class="kx ir"> </strong>属性将是可选的，我们不必给它赋值。我们将从<code class="fe md me mf ls b">get</code>请求开始。您可以将它放在一个函数中，并在需要时调用它，但是现在，我们将在我们的<code class="fe md me mf ls b">useEffect()</code>中使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7729" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，在挂载时，我们将我们的订阅赋值，这样当组件卸载时，我们就可以很容易地取消订阅我们的可观察的on cleanup。我们还使用从<code class="fe md me mf ls b">‘rxjs/operators’</code> <strong class="kx ir"> </strong>导入的<code class="fe md me mf ls b">take()</code> <strong class="kx ir"> </strong>操作符，并传递<code class="fe md me mf ls b">(1)</code> <strong class="kx ir"> </strong>以便我们只获得流的第一个结果，以及<code class="fe md me mf ls b">map()</code> <strong class="kx ir"> </strong>操作符，以便在将接收到的任何数据赋给组件内的任何值之前对其进行操作。在这种情况下，我只想从响应中返回<code class="fe md me mf ls b">res.data</code> <strong class="kx ir"> </strong>。</p><p id="303c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们将结果映射到模板上，并为每个div注释添加一些样式，以声明组件范围之外的样式对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f544" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将是结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/a3128e3e879bda0b9b29eede3eccc3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeEdyQP9nXyiuKWDx0QuIg.png"/></div></div></figure><p id="5ecf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们包含一个按钮来测试雇员的添加，以及在组件范围之外声明的适当样式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/13c4653c2ac7f33a25facb0cf6b3a7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIqnQZMdO3mRgRodeAUnyw.png"/></div></div></figure><p id="8f1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们定义我们的<code class="fe md me mf ls b">addEmployee</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7363" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从ApiService向post方法传递一个包含id、年龄、工资和雇员姓名的对象，然后在订阅成功或post请求成功时将该对象推到雇员数组的前面。保存，然后单击Add Employee按钮，查看添加到员工列表中的新员工。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/a0857f9462a6e9aea4e249f27aad39c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaqgjAGsjOJEGasbpWtgIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本·索洛加入了这个名单</p></figure><p id="8f7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是完整的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bd04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总之，RxJs集成是可能的，并且做了很多非常棒的事情。它允许您创建定制的事件流，您甚至可以添加多个侦听器。Observables转换也可以像我们使用<code class="fe md me mf ls b">map()</code>那样被链接起来，这对于帮助保持我们的代码在一起非常有用。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="33a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>