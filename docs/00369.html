<html>
<head>
<title>Smooth Scrolling With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现平滑滚动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/smooth-scrolling-with-javascript-a4cd787e447f?source=collection_archive---------0-----------------------#2019-05-06">https://betterprogramming.pub/smooth-scrolling-with-javascript-a4cd787e447f?source=collection_archive---------0-----------------------#2019-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="686d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始创建库的技术视角</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e8e64c394e0b80ffc37a75307998eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5Z5h5vq0tQu1v-Q5vYFmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/5-ckoJTWhrc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Damon Lam </a>在<a class="ae ky" href="https://unsplash.com/search/photos/scroll?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄(是卷轴。明白了吗？)</p></figure><p id="2a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将通过从头构建一个平滑滚动库来探索平滑滚动在web上是如何工作的，该库将具有以下特性:</p><ul class=""><li id="5c7e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">零依赖性</li><li id="fcdf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">带有三次贝塞尔曲线和缓动预设的动画——最有趣的部分！</li><li id="bb0e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">能够在任何元素内部滚动，而不仅仅是<code class="fe mj mk ml mm b">window</code></li><li id="ec6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">指定滚动的方向</li><li id="8561" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在<code class="fe mj mk ml mm b">px</code>中指定滚动量(可选)</li><li id="f91e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">指定滚动的持续时间</li><li id="1622" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">回调以随时取消滚动事件</li></ul><p id="af15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库将公开一个函数，该函数将接受所需的不同输入参数，如要滚动的元素、滚动量等。作为一个物体的一部分。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="04c3" class="mr ms it mm b gy mt mu l mv mw">function smoothScroll(scrollParams = {}) {<br/>  const elementToScroll = scrollParams.element;<br/>  ...<br/>}</span></pre><h2 id="ce59" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated"><strong class="ak">检测元素类型</strong></h2><p id="347a" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">为了简单起见，让我们假设我们想要在元素内部从左向右滚动。第一项任务是找出元素的类型——是否是<code class="fe mj mk ml mm b">window</code>。这是因为与其他HTML元素相比，<code class="fe mj mk ml mm b">window</code>有不同的DOM APIs来计算宽度、高度和操作滚动位置。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="7416" class="mr ms it mm b gy mt mu l mv mw">function smoothScroll(scrollParams) {<br/>  const elementToScroll = scrollParams.element;<br/>  <strong class="mm iu">const isWindow = elementToScroll === window;</strong><br/>  ...<br/>}</span></pre><p id="7fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于元素的类型，我们使用适当的属性，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="8d5c" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated"><strong class="ak">检测滚动量</strong></h2><p id="c9fc" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果参数中没有指定滚动量，下一步是计算滚动量。否则，我们根据元素的宽度和它的初始滚动位置来计算它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="0d16" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">触发平滑滚动</h2><p id="5d14" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在，我们需要根据参数中提供的持续时间开始滚动元素。向<code class="fe mj mk ml mm b">requestAnimationFrame</code>提供一个持续自执行的函数作为回调。<code class="fe mj mk ml mm b">requestAnimationFrame</code>是一种调用函数的非阻塞方式，该函数在浏览器的每次重画循环之前执行动画。</p><p id="34f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每次滴答，也就是每次调用回调函数时，该函数将计算需要滚动的量。这将取决于两个相互依赖的因素:</p><ul class=""><li id="be8f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">自开始以来经过的时间</li><li id="fe6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">指定的动画参数，它将决定滚动的速度</li></ul><h2 id="1b67" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated"><strong class="ak">动画和定时功能</strong></h2><p id="4b75" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在CSS中，我们可以通过以下方式定义一些属性的动画，如<code class="fe mj mk ml mm b">background-color</code>和<code class="fe mj mk ml mm b">opacity</code>:</p><ul class=""><li id="a053" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">缓动预设(<code class="fe mj mk ml mm b">ease-in</code>、<code class="fe mj mk ml mm b">ease-out</code>、<code class="fe mj mk ml mm b">ease-in-out</code>等)。)</li><li id="3c82" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">三次贝塞尔曲线点</li></ul><p id="c044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这两种方法都使用了计时函数的概念。</p><p id="2422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计时函数是时间的函数，它定义了动画在给定持续时间内的速度变化，即其加速度。</p><p id="c907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于定时功能<a class="ae ky" href="https://tympanus.net/codrops/css_reference/timing-function_value/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">可以在这里</strong> </a>深入阅读。</p><p id="23b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，没有现成的方法来定义滚动动画。所以，我们得自己装上电线！</p><p id="86ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们问题的上下文中，计时函数将把经过的时间和动画的总持续时间的比率作为输入。例如，如果指定的持续时间为2s，并且已经过了0.5s，则计时函数的输入将为0.5 / 2 = 0.25。</p><p id="4d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回值介于0和1之间，它定义了元素必须滚动到总滚动量的多少。例如，如果返回值为0.50，总滚动量为500像素，这意味着元素必须滚动到500的50%，即250像素。</p><p id="e7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看一些缓动预置的定时功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bd5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更清楚，让我们取一个预置，比如说<code class="fe mj mk ml mm b">easeOutQuad</code>，我们想在2s内滚动200px的总量。以下是不同时间点的滚动位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">easeOutQuad</code>规定一个动画应该开始时很快，然后逐渐变慢，如上表所示。用户可以看到元素在第一秒从0到150像素滚动，然后在剩下的一秒只滚动50像素。</p><h2 id="1320" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">三次贝塞尔曲线</h2><p id="2217" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">缓动预设非常具体，很难定义。例如，上面定义的<code class="fe mj mk ml mm b">easeInOutQuint</code>有一个非常复杂的公式，但与三次贝塞尔曲线相比，它只能实现非常简单的动画。对于高级定制动画，我们需要三次贝塞尔曲线，它能够轻松定义复杂的加速度模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/c71f42d60abd3ada27e5c57aae6985c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*syQo-R2KO9RTYcvQkgWPpA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://buildingvts.com/mathematical-intuition-behind-bezier-curves-2ea4e9645681" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="dcbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画的三次贝塞尔曲线是在2D平面中借助于称为控制点的4个点定义的，这4个点是P0 (0，0)，P1，P2，P3(1，1)。X轴指定经过的时间，Y轴告诉我们动画的进度百分比(在我们的例子中，滚动了总滚动量的百分之几)。你可以(也应该！)点击阅读更多关于贝塞尔曲线<a class="ae ky" href="https://www.smashingmagazine.com/2014/04/understanding-css-timing-functions/" rel="noopener ugc nofollow" target="_blank">的信息。这里有一个包含交互式三次贝塞尔曲线实现的笔，可以感受一下它们是如何工作的。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nu l"/></div></figure><p id="d5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三次贝塞尔函数是一个数学公式，它将经过的时间百分比、P1和P2控制点作为输入，并返回进度百分比。在我们的例子中，它将被翻译成如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义一个函数，它将根据经过的时间返回动画进度的百分比。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="bdf0" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">滴答函数</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步来理解发生了什么。</p><ol class=""><li id="2c0d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated"><code class="fe mj mk ml mm b">scrollOnNextTick</code>是第一次调用，包在<code class="fe mj mk ml mm b">requestAnimationFrame</code>里面。<code class="fe mj mk ml mm b">requestAnimationFrame</code>提供了自1970年以来经过的毫秒数作为默认参数，我们将它存储在<code class="fe mj mk ml mm b">startTime</code>中，它也是<code class="fe mj mk ml mm b">scrollOnNextTick</code>在每个时钟周期的参数。</li><li id="a67f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe mj mk ml mm b">runTime</code>是根据每个节拍计算的，它告诉我们从动画开始到现在已经过了多长时间。</li><li id="d6cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated"><code class="fe mj mk ml mm b">getProgress</code>以<code class="fe mj mk ml mm b">runTime</code>为参数，返回动画进度百分比(0到1之间的值)，乘以需要滚动的总滚动量，得出我们在这个tick需要滚动的滚动量。</li><li id="2bb5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">基于初始滚动位置和该刻度的滚动量来计算和设置滚动位置。</li><li id="5eb0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">如果提供了<code class="fe mj mk ml mm b">onRefUpdateCallback</code>，它将在每个节拍被调用。<code class="fe mj mk ml mm b">requestAnimationFrame(scrollOnNextTick)</code>作为参数传递，通过将其作为参数传递给<code class="fe mj mk ml mm b">cancelAnimationFrame</code>，可以用来取消滚动动画。</li><li id="042f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">如果<code class="fe mj mk ml mm b">runTime</code>大于<code class="fe mj mk ml mm b">duration</code>，则表示动画完成。如果提供了可选的回调函数<code class="fe mj mk ml mm b">onAnimationCompleteCallback</code>，则调用该函数。</li></ol><h2 id="6160" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">使用</h2><p id="d32c" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如何使用<code class="fe mj mk ml mm b">smoothScroll</code>功能的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="df1b" class="mr ms it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">结束了！</h2><p id="9edd" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">最后一步是公开应用程序要使用的<code class="fe mj mk ml mm b">smoothScroll</code>函数。为此，需要做的事情很少:</p><ul class=""><li id="b260" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将<code class="fe mj mk ml mm b">smoothScroll</code>导出为默认功能:</li></ul><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="284e" class="mr ms it mm b gy mt mu l mv mw">export default smoothScroll</span></pre><ul class=""><li id="51c5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将ES6编译成ES5以便在浏览器中使用，因为所有的浏览器都不能完全理解ES6。为此，我们可以使用任何捆绑器(例如:Webpack)。</li><li id="7b4d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">(可选)可以创建一个npm包，以便我们的库可由npm安装。</li></ul><p id="2cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过以下链接查看完整的代码:</p><p id="61a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">GitHub:</strong>T3】https://github.com/tarun-dugar/easy-scroll<br/><strong class="lb iu">NPM:</strong><a class="ae ky" href="https://www.npmjs.com/package/easy-scroll" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/easy-scroll</a></p></div></div>    
</body>
</html>