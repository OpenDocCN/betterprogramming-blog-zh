<html>
<head>
<title>Create a Custom Web Editor Using TypeScript, React, ANTLR, and Monaco-Editor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript、React、ANTLR和Monaco-Editor创建自定义Web编辑器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor-bcfc7554e446?source=collection_archive---------4-----------------------#2020-06-01">https://betterprogramming.pub/create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor-bcfc7554e446?source=collection_archive---------4-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="77b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:实现语言服务、自动完成、语法和语义验证以及自动格式化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0d0192df2b1c948a3f388ca1be4f32d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTPLcisrU29n-qvpnVytPw.jpeg"/></div></div></figure><p id="da15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你好，欢迎来到我的文章的第2部分，介绍如何使用<strong class="kt ir"> Typescript </strong>、<strong class="kt ir"> React </strong>、<a class="ae ln" href="https://www.antlr.org/" rel="noopener ugc nofollow" target="_blank">、<strong class="kt ir"> ANTLR、</strong> </a>和<a class="ae ln" href="https://microsoft.github.io/monaco-editor/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">Monaco-Editor</strong></a>。如果还没有阅读第一部分，这里有一个链接。</p><p id="d7d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示如何实现语言服务，它将负责在编辑器中解析当前键入的文本的繁重工作。然后，我们使用由解析器返回的生成的<a class="ae ln" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="lo">【抽象语法树(AST) </em> </strong> </a> <strong class="kt ir"> </strong>来检测任何语法或语义错误，格式化键入的文本或在用户开始键入时向他们建议定义的待办事项(自动完成，我不打算实现这一项。我就给个提示，怎么做和需要的API)。</p><p id="217a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，该服务将公开三个功能:</p><ul class=""><li id="669d" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">format(code: string): string</code></li><li id="4955" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">validate(code: string): Errors[]</code></li><li id="4972" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated"><code class="fe ly lz ma mb b">autoComplete(code: string, currentPosition: Position): string[]</code></li></ul><p id="5d4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以让我们开始吧。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="619a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">添加鹿角，从语法中生成词法分析器和语法分析器</h1><p id="9c6c" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">我将添加<strong class="kt ir"> ANTLR </strong>库，并添加一个脚本来从我们的<code class="fe ly lz ma mb b"><em class="lo">TODOLang.g4</em></code>语法文件生成解析器和词法分析器。</p><p id="6641" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以先说第一件事，添加必要的库:<a class="ae ln" href="https://www.npmjs.com/package/antlr4ts" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> antlr4ts </strong> </a>和<a class="ae ln" href="https://www.npmjs.com/package/antlr4ts-cli" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> antlr4ts-cli </strong> </a>。</p><p id="577a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> antlr4ts </strong>是<strong class="kt ir"><em class="lo">typescript</em></strong><a class="ae ln" href="https://www.npmjs.com/package/antlr4ts-cli" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">ANTLR 4 ts-cli</strong></a>中<strong class="kt ir"> ANTLR </strong>的运行时库，另一方面顾名思义就是我们将用来为该语言生成解析器和词法分析器的CLI。</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="4667" class="np mp iq mb b gy nq nr l ns nt">npm add antlr4ts</span><span id="2874" class="np mp iq mb b gy nu nr l ns nt">npm add -D antlr4ts-cli</span></pre><p id="e34c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在根目录中添加以下包含<code class="fe ly lz ma mb b">TodoLang</code>语法规则的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d68f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们在<code class="fe ly lz ma mb b">package.json</code>文件中添加一个脚本，通过<strong class="kt ir"> antlr-cli </strong>为我们生成解析器和词法分析器:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="69c2" class="np mp iq mb b gy nq nr l ns nt">"antlr4ts": "antlr4ts ./TodoLangGrammar.g4 -o ./src/ANTLR"</span></pre><p id="6275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">文件将在<code class="fe ly lz ma mb b">./src/ANTLR</code>目录下生成。</p><p id="b3e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们运行<strong class="kt ir"> antlr4ts </strong>脚本，看看生成的文件:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="cbab" class="np mp iq mb b gy nq nr l ns nt">npm run antlr4ts</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b71184564f254c3a317b5854272529cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*6GylBGWygAonqJHqHe5Wtw.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">生成的ANTLR文件</p></figure><p id="ed7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，有一个词法分析器和一个语法分析器。如果检查解析器文件，会发现它导出了一个类<code class="fe ly lz ma mb b">TodoLangGrammarParser</code>；这个类有一个构造函数<em class="lo"> </em> <code class="fe ly lz ma mb b">constructor(input: TokenStream)</code>，它将<code class="fe ly lz ma mb b">TodoLangGrammarLexer</code>为给定代码生成的<code class="fe ly lz ma mb b">TokenStream</code>作为参数。</p><p id="3e6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">TodoLangGrammarLexer</code>有一个构造函数<code class="fe ly lz ma mb b">constructor(input: CharStream)</code>，它将代码作为参数。</p><p id="4b3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解析器包含一个方法<code class="fe ly lz ma mb b">public todoExpressions(): TodoExpressionsContext</code>，它返回代码中定义的所有<code class="fe ly lz ma mb b">TodoExpressions</code>的上下文。猜猜<code class="fe ly lz ma mb b">TodoExpressions</code>这个名字是怎么来的？这是我们语法规则中第一条规则的名字:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="86f6" class="np mp iq mb b gy nq nr l ns nt">todoExpressions : (addExpression)* (completeExpression)*;</span></pre><p id="b6ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">TodoExpressionsContext</code>是我们<a class="ae ln" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>的根；其中的每个节点都是另一个规则的另一个上下文。有终端和节点上下文，终端持有最终的令牌(可能是ADD令牌、todo令牌或“TODO的名称”令牌)。</p><p id="94c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">TodoExpressionsContext</code>包含<code class="fe ly lz ma mb b">addExpressions</code>和<code class="fe ly lz ma mb b">completeExpressions</code>，分别来自以下三个规则:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="9f54" class="np mp iq mb b gy nq nr l ns nt">todoExpressions : (addExpression)* (completeExpression)*; addExpression : ADD TODO STRING;<br/>completeExpression : COMPLETE TODO STRING;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b2641394c0a08d67368398105c31a499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpdarYwcg_bOCJIdW1UA-A.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">TodoExpressionsContext根节点</p></figure><p id="4127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，每个上下文类都包含终端节点，终端节点主要保存文本(代码片段或标记，如“ADD”、“COMPLETE”、“表示TODO的字符串”)。AST的复杂性取决于你的语法规则；在我们的例子中，非常简单。</p><p id="20ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ly lz ma mb b"><strong class="kt ir">TodoExpressionsContext</strong></code>中我们可以看到，它包含<code class="fe ly lz ma mb b">ADD</code>、<code class="fe ly lz ma mb b">TODO</code>和<code class="fe ly lz ma mb b">STRING</code>终端节点，分别对应这些规则:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="8cfa" class="np mp iq mb b gy nq nr l ns nt">addExpression : ADD TODO STRING;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/977a8614abfee50a9cfb94f77cff171b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZVuX2WWc2jyP_b8tPiikA.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">AddExpressionContext</p></figure><p id="808e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">字符串终端节点保存我们试图添加的Todo的文本。</p><p id="a141" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们解析一个简单的<code class="fe ly lz ma mb b">TodoLang</code>代码，看看AST是什么样子的。</p><p id="a308" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在目录<code class="fe ly lz ma mb b">./src/language-service</code>中创建一个包含以下内容的<code class="fe ly lz ma mb b">parser.ts</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0fb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个文件所做的就是导出一个函数<code class="fe ly lz ma mb b">parseAndGetASTRoot(code)</code>，它接受TodoLang代码并生成相应的AST。</p><p id="f67f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解析下面的<code class="fe ly lz ma mb b">TodoLang</code>代码:</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="9f8b" class="np mp iq mb b gy nq nr l ns nt">parseAndGetASTRoot(`</span><span id="df6c" class="np mp iq mb b gy nu nr l ns nt">ADD TODO "Create an editor"</span><span id="a640" class="np mp iq mb b gy nu nr l ns nt">COMPLETE TODO "Create an editor"</span><span id="7c67" class="np mp iq mb b gy nu nr l ns nt">`)</span></pre><p id="e375" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将产生以下AST:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/11cd5cae3140efd8b4000b979cf1f5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*u5Mr5Zj_1LvHWuJhPOP_1A.png"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1089" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">实现词法和语法验证</h1><p id="5a29" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">在这一节中，我将带您了解如何在编辑器ANTLR中添加语法验证，它会为我们生成现成的词法和语法错误。我们只需要实现一个<code class="fe ly lz ma mb b">ANTLRErrorListner</code>，并将其提供给词法分析器和解析器，这样我们就可以在ANTLR解析代码时收集错误。</p><p id="6e01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ly lz ma mb b">./src/language-service</code>目录中创建一个实现<code class="fe ly lz ma mb b">ANTLRErrorListner</code>的类<code class="fe ly lz ma mb b">TodoLangErrorListener</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="320a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次ANTLR在代码解析过程中遇到错误时，它都会调用这个侦听器，向它提供有关错误的信息。</p><p id="e2ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们返回一个错误列表，其中包含错误在代码中出现的位置以及生成的错误消息。</p><p id="6d8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们将监听器添加到<code class="fe ly lz ma mb b">parser.ts</code>文件中的词法分析器和语法分析器，将其内容更改为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4926" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在<code class="fe ly lz ma mb b">./src/language-service</code>目录中，创建一个文件<code class="fe ly lz ma mb b">LanguageService.ts</code>，该文件导出以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0a06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以向编辑器添加错误了。为此，首先我将创建我在上一篇文章<a class="ae ln" href="https://medium.com/@amazzal.elhabib/create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor-part-1-2f710c69c18c" rel="noopener">中提到的web worker，并添加我们的worker服务代理，它将使用语言服务来完成这项工作。</a></p><h2 id="7d74" class="np mp iq bd mq oe of dn mu og oh dp my la oi oj na le ok ol nc li om on ne oo bi translated">创建web worker:</h2><p id="6d30" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">首先让我们创建<code class="fe ly lz ma mb b">TodoLangWorker</code>，它是将由<strong class="kt ir"> monaco代理的工人。</strong> <code class="fe ly lz ma mb b">TodoLangWorker</code> <strong class="kt ir"> </strong>将使用语言服务方法来执行编辑器功能，那些在web worker中执行的方法将由<strong class="kt ir"> monaco </strong>代理，所以调用web worker中的方法就是调用主线程中被代理的方法。</p><p id="128e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ly lz ma mb b">./src/todo-lang</code>文件夹中，创建一个文件<code class="fe ly lz ma mb b">TodoLangWorker.ts</code>，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9945" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，我们创建了语言服务的一个实例，并添加了一个调用语言服务validate的<code class="fe ly lz ma mb b">doValidation()</code>方法。其他东西只是为了从编辑器中获取文档文本。如果你想支持多文件编辑，有很多东西需要添加。</p><p id="a9b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b">_ctx: IWorkerContext</code>是编辑器的上下文，它保存模型(打开文件…</p><p id="40cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们在<code class="fe ly lz ma mb b">./src/todo-lang</code>目录下创建一个web worker文件<code class="fe ly lz ma mb b">todolang.worker.ts </code>，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="de36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用内置的<code class="fe ly lz ma mb b">worker.initialize</code>来初始化我们的worker，并从<code class="fe ly lz ma mb b">TodoLangWorker</code>中创建必要的方法代理。</p><p id="3e75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那是一个web worker，所以我们必须告诉<strong class="kt ir"> webpack </strong>捆绑它自己的文件。直接转到<strong class="kt ir"> webpack配置文件</strong>并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f9a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将我们的工人文件命名为<code class="fe ly lz ma mb b">todoLangWorker.js</code>。</p><p id="6f05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们应该进入编辑器设置功能，并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3348" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<strong class="kt ir"> monaco </strong>如何获取web worker的URL。注意，如果工人的标签是ID<strong class="kt ir">todo lang</strong>，我们返回我们在<strong class="kt ir"> webpack </strong>中捆绑工人时使用的相同文件名。</p><p id="6bc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您现在构建项目，您会发现有一个名为<code class="fe ly lz ma mb b">todoLangWorker.js</code>的文件(或者在dev-tools中，您会在thread部分找到两个workers)。</p><p id="8c26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们创建一个<code class="fe ly lz ma mb b">WorkerManager</code>,它管理worker的创建，并帮助我们获得代理worker的一个客户机，这样我们可以在以后使用它来进行调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="324d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果web worker还没有创建，我们使用<code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.editor.html#createwebworker" rel="noopener ugc nofollow" target="_blank">createWebWorker</a></code>来创建或运行它。否则，我们获取并返回代理客户端。</p><p id="0242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用<code class="fe ly lz ma mb b">workerClientProxy</code>来调用被代理的方法。</p><p id="8356" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建<code class="fe ly lz ma mb b">DiagnosticsAdapter</code>类，该类将把语言服务返回的错误修改为<strong class="kt ir"> monaco </strong>需要在编辑器中标记的错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我所做的是为用户所做的每一个改变添加一个<code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html#ondidchangecontent" rel="noopener ugc nofollow" target="_blank">onDidChangeContent</a></code>监听器。我们对更改进行500毫秒的去抖，然后调用工作人员来验证代码，并在修改后添加标记。</p><p id="4d42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当文件(模型)被创建时，API <code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.editor.html#ondidcreatemodel" rel="noopener ugc nofollow" target="_blank">onDidCreateModel</a></code>被调用，所以在那时我们添加了用于改变的监听器。</p><p id="f383" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.editor.html#setmodelmarkers" rel="noopener ugc nofollow" target="_blank">setModelMarkers</a></code>告诉<strong class="kt ir"> monaco </strong>添加错误标记，或者简单地说，给给定的错误加下划线。</p><p id="52d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要应用这些验证，请确保在设置函数中调用它们，并注意我们正在使用<code class="fe ly lz ma mb b">WorkerManager</code>来获取被代理的工人。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4263" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在一切都正常了。运行项目，开始输入一些不好的<code class="fe ly lz ma mb b">TodoLang</code>代码；您应该会看到错误被加了下划线。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/7daeef5e7af8ffada60db2ea2d890c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppMblQInjSwGUcwrU113LA.png"/></div></div></figure><p id="3da3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是目前为止的项目:</p><div class="oq or gp gr os ot"><a href="https://github.com/amazzalel-habib/TodoLangEditor/tree/add-syntax-validation" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">amazzalel-habib/TodoLangEditor</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这是一个自定义语言的web编辑器。通过创建一个……</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="e978" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">实现语义验证</h1><p id="358a" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">现在让我们为编辑器添加语义验证。还记得我在上一篇文章中提到的两条语义规则吗？</p><ul class=""><li id="0405" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">如果TODO是使用<code class="fe ly lz ma mb b">ADD TODO</code>指令定义的，我们不能重新添加它。</li><li id="fa8b" class="lp lq iq kt b ku mc kx md la me le mf li mg lm lu lv lw lx bi translated">完整指令不应应用于未使用<code class="fe ly lz ma mb b">ADD TODO</code>声明的TODO</li></ul><p id="3580" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要检查TODO是否已定义，我们所要做的就是遍历AST，获取每个ADD表达式，并将它们推送到一个列表中。然后，我们检查已定义的待办事项列表中是否存在待办事项。如果存在，这是一个语义错误，所以从ADD表达式的上下文中获取错误的位置，并将错误推送到一个数组中。第二条规则也是如此。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e896" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在调用这个函数，在validate函数中将语义错误和语法错误连接起来。</p><p id="5261" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在有了支持语义验证的编辑器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/df43bfd34e30818983263b81c7e51b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*dszEBBHWiGait_nuEEKQeA.png"/></div></figure><div class="oq or gp gr os ot"><a href="https://github.com/amazzalel-habib/TodoLangEditor/tree/add-semantic-validation" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">amazzalel-habib/TodoLangEditor</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这是一个自定义语言的web编辑器。通过创建一个……</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="7a70" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">实现自动格式化</h1><p id="5091" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">对于自动格式化，您需要通过调用API <code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.languages.html#registerdocumentformattingeditprovider" rel="noopener ugc nofollow" target="_blank">registerDocumentFormattingEditProvider</a></code>为Monaco提供并注册格式化提供程序。有关更多详细信息，请查看文档。调用和迭代AST将为您提供以漂亮的格式重写代码所需的所有信息。</p><p id="5013" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是<code class="fe ly lz ma mb b">LanguageService</code>中的格式化方法。它获取代码并检查代码中是否有错误，然后返回格式化的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b262" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们将格式提供程序添加到<strong class="kt ir"> monaco </strong>，并使用这个服务。这里我在<code class="fe ly lz ma mb b">todoLangWorker</code>中添加了<code class="fe ly lz ma mb b">format</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f247" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们创建一个类<code class="fe ly lz ma mb b">TodoLangFomattingProvider</code>，它将实现接口<code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/interfaces/monaco.languages.documentformattingeditprovider.html" rel="noopener ugc nofollow" target="_blank">DocumentFormattingEditProvider</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="435f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它所做的就是获取代码并使用worker对其进行格式化，然后向<strong class="kt ir"> monaco </strong>提供格式化后的代码和我们想要替换的代码范围，在我们的例子中是所有代码。您可以更改代码以支持部分格式。</p><p id="b213" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在进入设置功能，使用<code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.languages.html#registerdocumentformattingeditprovider" rel="noopener ugc nofollow" target="_blank">registerDocumentFormattingEditProvider</a></code> <strong class="kt ir"> </strong> API注册格式提供程序。</p><pre class="kg kh ki kj gt nl mb nm nn aw no bi"><span id="3dbc" class="np mp iq mb b gy nq nr l ns nt">monaco.languages.registerDocumentFormattingEditProvider(languageID, <strong class="mb ir">new</strong> TodoLangFormattingProvider(worker));</span></pre><p id="a2e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您现在运行该应用程序，您应该会看到它支持格式化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/6c9b1c37b53a1d33dbd6053fb14f8ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzoZG92iK7i7qnexgj9qeA.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">格式化前编码</p></figure><p id="5897" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">试着点击<strong class="kt ir">格式文档</strong>或<strong class="kt ir"><em class="lo">“Shift+Alt+F”</em></strong>，应该会得到如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/4685e45b86cd3722d55b56f5f885daff.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*8H1SLH7v3JW1QGfDHaWaWQ.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">代码格式化</p></figure><div class="oq or gp gr os ot"><a href="https://github.com/amazzalel-habib/TodoLangEditor/tree/add-auto-formatting" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">amazzalel-habib/TodoLangEditor</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这是一个自定义语言的web编辑器。通过创建一个……</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="9788" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">实现自动完成</h1><p id="e791" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">要使自动完成支持已定义的to do，您所要做的就是从AST获取所有已定义的todo，并通过调用setup中的<code class="fe ly lz ma mb b"><a class="ae ln" href="https://microsoft.github.io/monaco-editor/api/modules/monaco.languages.html#registercompletionitemprovider" rel="noopener ugc nofollow" target="_blank">registerCompletionItemProvider</a></code>在完成提供程序中提供它们。提供者给你代码和光标的当前位置，这样你就可以检查用户正在输入的上下文，如果他们在一个完整的表达式中输入一个TODO，那么你可以建议预定义为DOs。请记住，默认情况下，Monaco-editor支持代码中预定义标记的自动完成，您可能希望禁用该功能，并实现自己的功能，以使其更加智能和上下文相关。</p><p id="e255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目如下:</p><div class="oq or gp gr os ot"><a href="https://github.com/amazzalel-habib/TodoLangEditor/tree/master" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">amazzalel-habib/TodoLangEditor</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这是一个自定义语言的web编辑器。通过创建一个……</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pn l pe pf pg pc ph kp ot"/></div></div></a></div><p id="baac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有任何问题、建议或反馈，请随时联系我。</p><p id="125d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢你的时间。</p></div></div>    
</body>
</html>