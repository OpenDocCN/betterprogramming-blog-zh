<html>
<head>
<title>Making External HTTPS Requests Using AWS Lambda and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda和Node.js发出外部HTTPS请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/aws-tutorial-about-node-js-lambda-external-https-requests-logging-and-analyzing-data-e73137fd534c?source=collection_archive---------2-----------------------#2019-12-16">https://betterprogramming.pub/aws-tutorial-about-node-js-lambda-external-https-requests-logging-and-analyzing-data-e73137fd534c?source=collection_archive---------2-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="354b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记录和分析您的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83f2fd01a2c54ad49fc83fc0830947a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZI81uYafYUz3396nMGlpg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kharaoke?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡拉·伍兹</a>在<a class="ae ky" href="https://unsplash.com/s/photos/external?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8db9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">利用AWS架构</h1><p id="fdf2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在<a class="ae ky" href="https://medium.com/javascript-in-plain-english/create-a-server-less-api-in-10-minutes-4a4cf012eeda" rel="noopener">的上一篇文章</a>中，我们学习了如何创建Node.js Lambda函数，以及如何将其与HTTP API网关连接。我们的Lambda看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c55ef00cae6a30006e1f42b5d451687f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgpeTBuQGgRKeFuDdIuzvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://medium.com/javascript-in-plain-english/create-a-server-less-api-in-10-minutes-4a4cf012eeda?source=friends_link&amp;sk=48b473cd4a1dcf7fe26820bd20b920ea" rel="noopener">之前教程</a>的Lambda</p></figure><p id="1118" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您刚刚加入我们，只需创建一个基本的Lambda并将其连接到一个新的HTTP API网关，或者按照本教程<a class="ae ky" href="https://medium.com/javascript-in-plain-english/create-a-server-less-api-in-10-minutes-4a4cf012eeda?source=friends_link&amp;sk=48b473cd4a1dcf7fe26820bd20b920ea" rel="noopener">进行操作</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8e83" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤1:使用CloudWatch</h1><p id="105e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">您可能已经访问过触发Lambda函数的HTTP端点。但是如果没有，只需点击API端点的链接。这样做之后，会自动为您生成一个日志。AWS的伟大之处在于，许多这些东西都是开箱即用的。要查看此请求的日志，请从AWS dashboard转到CloudWatch服务(您可以从标题中的services按钮搜索CloudWatch)，然后单击左侧窗格中Logs内的Log Groups子部分。一旦向API端点发出请求，您应该会看到lambda函数的名称出现在列表中。点击它，你会被带到一堆日志组。如果你有一个小数字，这意味着你有少量的请求。这就是我的情况。你可以在这里看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3e13f4d19f79d9e931fcdbbefb3740f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLjo5pa4AtEWnze9unFz6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda函数的所有日志组</p></figure><p id="d692" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">要一次搜索所有这些内容，请单击“搜索日志组”按钮。您现在可以看到您的请求日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/23d1697f2034672fb908c9b35f174342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2KGs_4In1ptWabWHSDA1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你的Lambda日志</p></figure><p id="d97c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">一件很棒的事情是，你可以看到你将被收费多少。AWS每月为我们提供100万个免费请求和400，000 GB秒的计算时间，这就是我们使用它的原因。但是如果你确实超过了这个限制，你可以通过查看你的计费持续时间并将其与他们的<a class="ae ky" href="https://aws.amazon.com/lambda/pricing/" rel="noopener ugc nofollow" target="_blank">定价方案</a>进行交叉引用，来确定你将为每个典型请求支付多少钱。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cd5b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤2:自定义日志记录输出</h1><p id="5ac9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">所有这些记录的信息都很棒，但是如果我们可以记录我们自己的信息(例如，以匿名的方式记录我们用户的信息，这样我们就可以利用这种洞察力来改进我们的产品，或者记录请求是否成功)，这不是很酷吗？让我们实现一个基本版本。为此，让我们回到Lambda函数的代码，在服务部分搜索Lambda并选择相关的Lambda。我们可以简单地通过使用Node.js中的<code class="fe nc nd ne nf b">console.log</code>来记录我们需要的任何信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/552d6594df316ad6757f43e584b7a361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7stsvOILf95jg_16gVCWow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有日志输出的Lambda代码</p></figure><p id="ad2e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">一旦您编辑了您的Lambda以包含您需要的日志输出，记得单击Save按钮，这样就可以部署更改了。保存后，让我们通过单击我们的API端点URL发出另一个请求，然后返回到CloudWatch来查看日志现在的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/dcf9ff0fe9b8dafd5f5164bbfca90aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkUy34SZGMHjOBvfQ0qIcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的自定义日志记录输出</p></figure><p id="484a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">显然，这个日志输出不是很有用，但是如果您的Lambda函数做一些稍微复杂一点的事情，比如从DynamoDB检索数据或与另一个服务通信，那么记录该服务或数据查询的输出以及任何异常可能非常有用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6720" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤3:记录HTTP响应</h1><p id="a188" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了记录更复杂的信息，让我们也把Lambda复杂化，这样记录的输出就更有意义。让我们使用Lambda调用外部HTTPS API并检索我们需要的数据。为此，让我们使用一个名为<a class="ae ky" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank"> PokeAPI </a>的免费API，它为我们提供了关于神奇宝贝的信息。在Node.js中进行HTTPS调用非常容易。这可以通过使用<code class="fe nc nd ne nf b">https</code>核心模块来完成:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="d38a" class="nm lh it nf b gy nn no l np nq">const <strong class="nf iu"><em class="nr">https </em></strong>= <strong class="nf iu"><em class="nr">require</em></strong>('https');<br/><br/>let dataString = '';<br/><br/>const req = <strong class="nf iu"><em class="nr">https</em></strong>.get("https://pokeapi.co/api/v2/pokemon/ditto", function(res) {<br/>  res.on('data', chunk =&gt; {<br/>    dataString += chunk;<br/>  });<br/>  res.on('end', () =&gt; {<br/>    <strong class="nf iu"><em class="nr">console</em></strong>.log(dataString);<br/>  });<br/>});<br/><br/>req.on('error', (e) =&gt; {<br/>  <strong class="nf iu"><em class="nr">console</em></strong>.error(e);<br/>});</span></pre><p id="33d7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们在Lambda函数中使用类似的代码。为了成功做到这一点，我们将使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> ES7异步等待函数</a>。在lambda中调用PokeAPI等待其响应后，我们希望将响应返回给用户。我们可以通过编写如下所示的Lambda代码轻松做到这一点:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="5328" class="nm lh it nf b gy nn no l np nq">const https = require('https');</span><span id="98bf" class="nm lh it nf b gy ns no l np nq">exports.handler = async (event) =&gt; {<br/>    let dataString = '';<br/>    <br/>    const response = await new Promise((resolve, reject) =&gt; {<br/>        const req = https.get("<a class="ae ky" href="https://pokeapi.co/api/v2/pokemon/ditto" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/ditto</a>", function(res) {<br/>          res.on('data', chunk =&gt; {<br/>            dataString += chunk;<br/>          });<br/>          res.on('end', () =&gt; {<br/>            resolve({<br/>                statusCode: 200,<br/>                body: JSON.stringify(JSON.parse(dataString), null, 4)<br/>            });<br/>          });<br/>        });<br/>        <br/>        req.on('error', (e) =&gt; {<br/>          reject({<br/>              statusCode: 500,<br/>              body: 'Something went wrong!'<br/>          });<br/>        });<br/>    });<br/>    <br/>    return response;<br/>};</span></pre><p id="01ce" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">注意，我们是从一个字符串解析JSON，然后仅仅出于美观的目的再次进行字符串化(在每个变量之间留出四个空格)。在我们的AWS屏幕中，它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ed9c4e0c5a42a7d82b3570725db4944c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lO69dIoDuw2IR236UGWwZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda函数中的HTTPS调用</p></figure><p id="a232" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">然而，我们目前还不能从用户那里获得输入。让我们在下一步中这样做。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="501d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤4:接受用户输入</h1><p id="8ee6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">您可能已经注意到，处理函数接收一个名为event的参数。让我们记录这个对象，看看里面是否有我们可以使用的东西。在Lambda函数中做任何事情之前，我们可以简单地添加一个<code class="fe nc nd ne nf b">console.log(event);</code>。代码现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/12cb6c084f925ce1bfd093ae7fae7929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L62dVECD6GHSH1LEnBQ4dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在我们的Lambda中记录事件对象</p></figure><p id="7615" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">保存这些更改并向我们的API端点URL发出另一个请求，我们可以看到我们在最新的CloudWatch日志中获得了整个事件对象。该对象内部还有一个<code class="fe nc nd ne nf b">queryStringParameters</code>字段，在本例中为null(显然是因为我们没有在请求中发送任何查询参数)。我看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ff3551dd2795bb0b9ef0fa4d2f687e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YoxNDXiysRKGM_-agZrBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最新的云观察日志</p></figure><p id="5c11" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，让我们通过浏览器对我们的API端点URL进行另一次调用，方法是复制粘贴我们在触发器部分找到的URL:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/0089560bc365bda3daaf82b299bdca95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWA07AcJui8mL6rU7Bie4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API端点URL。</p></figure><p id="e4db" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是，让我们在请求中添加一个查询参数，而不是按enter键。显然，我们可以将这个查询参数命名为任何我们喜欢的名称，但是让我们使用一些有意义的名称。我选择了<code class="fe nc nd ne nf b">name</code>，并给了它一个值<code class="fe nc nd ne nf b">pikachu</code>。于是我在浏览器里的网址是这样的:<a class="ae ky" href="https://evdiwllvsf.execute-api.eu-central-1.amazonaws.com/default/KanyeWestFunction?name=pikachu" rel="noopener ugc nofollow" target="_blank">https://evdiwllvsf . execute-API . eu-central-1 . amazonaws . com/default/KanyeWestFunction？name =皮卡丘</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/13966ecb78e1a6b53bbfd88aea876439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLw28AIFRBF__rXwBv5M9w.png"/></div></div></figure><p id="81fd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们按回车键。显然，在这个阶段，我们仍然得到口袋妖怪<code class="fe nc nd ne nf b">ditto</code>而不是<code class="fe nc nd ne nf b">pikachu</code>的相同响应，因为我们没有在Lambda中编写任何逻辑来根据请求的实体名称更改API hit，但让我们仍然来看看我们最新的CloudWatch日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3355bc2a70af2af7e90e529ee2d85f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYVNb3ue_RXhDYcGj1oOIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有查询参数的CloudWatch日志</p></figure><p id="9c2a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在我们可以看到<code class="fe nc nd ne nf b">queryStringParameters</code>更有意义，我们确实看到了添加到请求中的<code class="fe nc nd ne nf b">name</code>查询参数。既然我们现在可以访问它，我们也可以用它来请求我们喜欢的口袋妖怪使用PokeAPI。让我们将Lambda函数的代码改为:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="abae" class="nm lh it nf b gy nn no l np nq">const https = require('https');</span><span id="198f" class="nm lh it nf b gy ns no l np nq">exports.handler = async (event) =&gt; {<br/>    console.log(event);<br/>    let dataString = '';<br/>    <br/>    const response = await new Promise((resolve, reject) =&gt; {<br/>        const { queryStringParameters } = event;<br/>        if (!queryStringParameters || !queryStringParameters.name) {<br/>            resolve({<br/>                statusCode: 400,<br/>                body: 'Please provide a Pokemon name!'<br/>            })<br/>        }<br/>        const req = https.get(`<a class="ae ky" href="https://pokeapi.co/api/v2/pokemon/${queryStringParameters.name}`" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/${queryStringParameters.name}`</a>, function(res) {<br/>          res.on('data', chunk =&gt; {<br/>            dataString += chunk;<br/>          });<br/>          res.on('end', () =&gt; {<br/>            resolve({<br/>                statusCode: 200,<br/>                body: JSON.stringify(JSON.parse(dataString), null, 4)<br/>            });<br/>          });<br/>        });<br/>        <br/>        req.on('error', (e) =&gt; {<br/>          reject({<br/>              statusCode: 500,<br/>              body: 'Something went wrong!'<br/>          });<br/>        });<br/>    });<br/>    <br/>    return response;<br/>};</span></pre><p id="958f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">让我们保存这些更改，并使用查询字符串参数关键字<code class="fe nc nd ne nf b">name</code>和值<code class="fe nc nd ne nf b">pikachu</code>再次调用我们的API URL。有用！我们这次用经典皮卡丘口袋妖怪的数据得到了成功的回应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/fbde279ffacadcc56a5a8712d3fc9a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8TeJ0jiOm7qK3bb8RnMbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对“皮卡丘”的回应</p></figure><p id="c83d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们删除<code class="fe nc nd ne nf b">name</code>查询参数，就会得到我们定义的响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/5ebc10b14136b891a517db1632e0cb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*587vicVs5VHxGCEPrr0QTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">400错误请求响应</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1d22" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤5:记录有意义的数据</h1><p id="3307" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">因此，在使我们的Lambda函数复杂化之后，我们没有改变任何日志记录。首先，让我们删除关于<code class="fe nc nd ne nf b">event</code>对象的日志记录，然后添加关于我们用户的有意义的日志记录。我通过添加人类可读的日志输出来做到这一点。所以我把Lambda代码改成:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="bcc3" class="nm lh it nf b gy nn no l np nq">const https = require('https');</span><span id="6c68" class="nm lh it nf b gy ns no l np nq">exports.handler = async (event) =&gt; {<br/>    let dataString = '';<br/>    <br/>    const response = await new Promise((resolve, reject) =&gt; {<br/>        const { queryStringParameters } = event;<br/>        if (!queryStringParameters || !queryStringParameters.name) {<br/>            console.log('BadRequest');<br/>            resolve({<br/>                statusCode: 400,<br/>                body: 'Please provide a Pokemon name!'<br/>            })<br/>        }<br/>        const req = https.get(`<a class="ae ky" href="https://pokeapi.co/api/v2/pokemon/${queryStringParameters.name}`" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/${queryStringParameters.name}`</a>, function(res) {<br/>            res.on('data', chunk =&gt; {<br/>                dataString += chunk;<br/>            });<br/>            res.on('end', () =&gt; {<br/>                console.log('OK');<br/>                console.log(JSON.stringify({ name: queryStringParameters.name }));<br/>                resolve({<br/>                    statusCode: 200,<br/>                    body: JSON.stringify(JSON.parse(dataString), null, 4)<br/>            });<br/>          });<br/>        });<br/>        <br/>        req.on('error', (e) =&gt; {<br/>            console.log('ServerError');<br/>          reject({<br/>              statusCode: 500,<br/>              body: 'Something went wrong!'<br/>          });<br/>        });<br/>    });<br/>    <br/>    return response;<br/>};</span></pre><p id="4a3c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在这三种不同的情况下，我们记录有意义的输出:</p><ol class=""><li id="73da" class="ob oc it ma b mb mv me mw mh od ml oe mp of mt og oh oi oj bi translated">如果这个用户提出了一个错误的请求(没有口袋妖怪的名字)</li><li id="410d" class="ob oc it ma b mb ok me ol mh om ml on mp oo mt og oh oi oj bi translated">如果响应成功并且用户请求了哪个口袋妖怪</li><li id="48aa" class="ob oc it ma b mb ok me ol mh om ml on mp oo mt og oh oi oj bi translated">响应不成功</li></ol><p id="f299" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我保存了这段代码，然后向我们的API发出了几个请求，这样CloudWatch中就有了大量的日志信息。我的日志现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/18e58b487f104cb6b15caf461e1ab9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4O77ROdG_fJyo1Sgmhiug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录这3个场景的输出</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="db25" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">步骤6:分析我们的数据</h1><p id="4443" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，为了分析事情，我们可以简单地在日志中搜索。例如，我搜索<code class="fe nc nd ne nf b">BadRequest</code>，发现有一个用户提出了一个糟糕的请求(没有口袋妖怪名称)。嗯？我想知道那是谁😁。在我们的例子中，显然唯一的用户是我们(您！)所以我们在日志中只得到一个条目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/eaf8f85f2668a95a160348324d0674b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yv7T3eyP_hdZiG7eVsnDjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索结果</p></figure><p id="bc4d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是让我们想象一下，我们的应用程序非常成功，有好几个用户。看一堆日志是没用的。因此，我们应该做的是转到页面左侧窗格中日志组子部分下的见解子部分。在此页面上，让我们从顶部的选择日志组搜索输入字段中选择Lambda函数的名称。如果您随后在不更改默认查询的情况下单击Run Query，响应应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/142ae47b8e400df36cffe52df8ea2b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJoKxU06GDEDjwp5rSZdrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询我们的数据</p></figure><p id="ba0e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们可以将查询改为有意义的内容；例如，查看它们有多少OK响应。该查询现在看起来像这样:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="3bf3" class="nm lh it nf b gy nn no l np nq">fields <a class="ae ky" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>, <a class="ae ky" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a><br/>| filter <a class="ae ky" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a> like /OK/<br/>| sort <a class="ae ky" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a> desc<br/>| limit 20</span></pre><p id="22b2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这样的输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/764fd6e2748991c69ef8731f139d0e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjs8cWCmxEd1Y3uFi8KcrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自我们的Lambda的所有“OK”响应</p></figure><p id="bd60" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">请注意，所有OK响应都是最近才有的。这是因为在最后一次代码迭代之前，我们没有在Lambda函数中记录OK。我们再对不同的神奇宝贝做一些API请求，重复几个。然后，让我们给它几分钟来注册。现在，运行相同的查询将返回几个结果。如果我们愿意，甚至可以将限制从20更改为40，或者取消对结果数量的任何限制。我们可以从输入的右上角切换到6h或您想要的任何时间，而不是查询最近1h的数据。现在，由于在我们的Lambda函数代码中，我们还通过执行以下操作将名称记录为JSON stringified对象:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="5cb7" class="nm lh it nf b gy nn no l np nq">console.log(JSON.stringify({ name: queryStringParameters.name }));</span></pre><p id="35fe" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这意味着我们可以查询和显示被请求的神奇宝贝的名称。为此，让我们重写我们的查询:</p><pre class="kj kk kl km gt ni nf nj nk aw nl bi"><span id="ca6c" class="nm lh it nf b gy nn no l np nq">fields <a class="ae ky" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>, name<br/>| filter  ispresent(name)<br/>| sort <a class="ae ky" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a> desc</span></pre><p id="3481" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">结果更有见地:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/1af4157b358c3e00ffcfbe8e8492aa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IwbDzS_MCHb49f_Zk8png.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">神奇宝贝查询显示他们的名字</p></figure><p id="2099" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，我们可以看到被请求的不同神奇宝贝及其名称。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a5ea" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">前进</h1><p id="00c3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们也可以使用AWS的这个Insights工具来为我们创建可视化，但这更复杂，我觉得本教程已经涵盖了足够多的内容。让我们把它留到下一天，我们将从这些数据中创建图表和可视化。</p></div></div>    
</body>
</html>