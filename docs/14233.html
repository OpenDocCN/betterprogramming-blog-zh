<html>
<head>
<title>Demystifying “flushPromises”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘“虚假承诺”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/de-mystifying-flushpromises-b13bc2254f95?source=collection_archive---------0-----------------------#2022-11-20">https://betterprogramming.pub/de-mystifying-flushpromises-b13bc2254f95?source=collection_archive---------0-----------------------#2022-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e1d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解为什么你需要冲水承诺</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eb64a8a61eff7198709d5da982b66663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3oJ_916cQNMzETLC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@shyshkina?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tetiana SHYSHKINA </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的标题是对你经常在LWC考试中看到的流行的<code class="fe ls lt lu lv b">flushPromises</code>方法的赞美，它可以采取以下两种形式之一:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="d451" class="ma mb iq lv b be mc md l me mf">function flushPromises(){<br/>  return Promise.resolve();<br/>}<br/><br/>function flushPromises() {<br/>  return new Promise((resolve) =&gt; {<br/>    setTimeout(resolve, 0);<br/>  });<br/>}</span></pre><p id="045e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经想知道这两种形式之间的区别，或者为什么你有时需要几个<code class="fe ls lt lu lv b">flushPromises</code>或<code class="fe ls lt lu lv b">Promise.resolve</code>调用来通过你的jest测试，我们将不得不进入杂草这里一点。这也是加强您对JavaScript的非阻塞架构的理解的机会，因此它的任何异步魔力都不会困扰您。大部分情况下。所以，系好安全带。</p><p id="a4b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在过去几年中做过前端开发，写过LWC，你可能会遇到JavaScript中的Promises、async/await、setTimeout和fetch APIs。所有这些的共同点是它们都是异步函数调用的形式。</p><p id="b9e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，这些应用程序允许你推迟一个函数的调用，并且不会阻塞主线程，或者说是唯一的线程，因为JavaScript是单线程的。JavaScript运行时处理延迟方法执行的方式是通过事件循环。</p><p id="9c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中的事件循环之所以得名，是因为它是一个在队列中等待新消息的无限循环。当它发现一个新消息时，它将它推送到调用堆栈进行处理。这些可能是来自XHR请求、承诺、<code class="fe ls lt lu lv b">setTimeout</code>回调、事件监听器等等的回调。这里需要注意的是，有多个具有不同优先级的消息队列，事件循环会在这些队列中检查消息，并且在运行时继续处理下一条消息之前，会完整地处理每条消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6c19ac628675785d971a8a9e4a8d8d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*OAZMWHvFL49V82cUl9Dw3A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/event loop</a></p></figure><p id="1a77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">有些人可能想知道:如果JavaScript是单线程的，那么它如何跟踪</em> <code class="fe ls lt lu lv b"><em class="mh">setTimeout</em></code> <em class="mh">调用中的计时器何时到期，或者网络调用何时完成，以便将回调推送到消息队列？</em></p><p id="3f2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的答案是不会。浏览器本身有其他专门用于此目的的非JS线程。浏览器为JavaScript提供与其通信的API，统称为Web APIs。</p><p id="b01a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的讨论，我们将关注事件循环可能处理的两个消息:任务和微任务。微任务是使用<code class="fe ls lt lu lv b">Promise</code>、<code class="fe ls lt lu lv b">Async</code> / <code class="fe ls lt lu lv b">Await</code>、获取API和变异观察器排队的消息。任务是用其他方式调度的回调，特别是使用<code class="fe ls lt lu lv b">setTimeout</code>。</p><p id="21d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的片段:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a331" class="ma mb iq lv b be mc md l me mf">setTimeout(()=&gt;console.log("Timeout callback"),0); // Task<br/>Promise.resolve()<br/> .then(()=&gt;console.log("Promise callback")); // Microtask<br/>console.log("I'm synchronous");<br/><br/>/** Output<br/>I'm synchronous<br/>Promise callback<br/>Timeout callback<br/>**/<br/>/** Snippet 1 **/</span></pre><p id="7293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，首先执行同步代码。然而，尽管<code class="fe ls lt lu lv b">setTimeout</code>回调被首先调度，我们看到<code class="fe ls lt lu lv b">Promise</code>回调被首先执行。这是因为微任务的优先级高于任务。作为一名LWC开发人员，理解并记住这一点非常重要。请允许我解释原因。</p><p id="abee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LWC属性是反应性的。换句话说，当您更改属性值时，如果模板标记中直接或间接(通过getters)引用了该属性值，则LWC运行时会重新呈现该标记，以反映属性的更新值。</p><p id="0396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这完全在开发人员的控制之外，也就是说，没有办法阻止这种情况发生，也没有办法规定您希望模板何时被重新评估。当您在LWC中更改JS函数的reactive属性时，重新计算将被安排为微任务，这意味着只有在函数完成执行后，重新计算才会发生。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="f100" class="ma mb iq lv b be mc md l me mf">&lt;template&gt;<br/> &lt;p&gt;{myVal}&lt;/p&gt;<br/>&lt;/template&gt;<br/><br/>****** js file*****<br/><br/>myVal = 0;<br/>changeVal(){<br/>  this.myVal=1;<br/>  this.myVal=2; //the template will be re-evaluated only after this step which means you will never see the value '1' on the page and the step above is redundant.<br/>}<br/>/** Snippet 2 **/</span></pre><p id="f61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑这个事实的另一个含义。代码如下:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="ebeb" class="ma mb iq lv b be mc md l me mf">&lt;template&gt;<br/> &lt;template if:true={renderButton}&gt;<br/>  &lt;lightning-button label="Click"&gt;&lt;/lightning-button&gt; <br/>&lt;/template&gt;<br/>&lt;/template&gt;<br/><br/>****** jest test *****<br/><br/>it("renders button when prop is set",()=&gt;{<br/>  //initialize and add component to DOM here<br/>  <br/>  element.renderButton=true; //'element' refers to LWC under test<br/>  const btn = element.shadowRoot.querySelector('lightning-button');<br/>  expect(btn).toBeNull();<br/>})<br/>/** Snippet 3 **/</span></pre><p id="1205" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望在设置相关属性后立即呈现按钮，如上面的代码片段所示，那么您就错了。获得新添加按钮的句柄的正确方法是将我们的代码重构为:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a2cd" class="ma mb iq lv b be mc md l me mf">Promise.resolve().then(()=&gt;{<br/>  const btn = element.shadowRoot.querySelector('lightning-button');<br/>  expect(btn).not.toBeNull(); //we've a reference!<br/>});<br/>/** Snippet 4 **/</span></pre><p id="1558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为当我们在一个<code class="fe ls lt lu lv b">Promise.resolve</code>调用后面添加我们的代码片段时，它被安排为一个微任务。该微任务仅在模板重估微任务之后执行，该模板重估微任务已经由LWC运行时调度。所以模板在回调运行时包含了按钮。注意，您可以在更线性的代码风格中使用async/await来代替<code class="fe ls lt lu lv b">Promise</code> s。</p><p id="e0ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一点值得注意的是，只有当模板响应于反应性质的改变而改变时，才需要等待模板重新评估。如果您直接操作DOM，可能会立即“观察”到变化。例如，下面的测试将通过:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="aa0a" class="ma mb iq lv b be mc md l me mf">import LightningButton from "lightning/button";<br/>it("adds button synchronously",()=&gt;{<br/>    // setup "element" LWC and add it to the DOM<br/>    const btn = createElement("lightning-button", { is: LightningButton });<br/>    btn.classList = "jest";<br/>    element.appendChild(btn); //add directly to the DOM<br/>    let theBtn = element.shadowRoot.querySelector("lightning-button.jest");<br/>    expect(theBtn).not.toBeNull(); //no `Promise.resolve` needed!<br/>});<br/>/** Snippet 5 **/</span></pre><p id="5cc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到任务和微任务之间的比较，如上所示(片段1)，微任务比任务具有更高的优先级。让我们用下面的代码来看看这一事实的一些含义:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a8a0" class="ma mb iq lv b be mc md l me mf">/*** component.html ***/<br/><br/>&lt;template if:true={showDiv}&gt;<br/>  &lt;div class="dyna"&gt;&lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>/*** component.js ***/<br/><br/>showDiv=true;<br/>@api<br/>unhide(){<br/>  this.showDiv=true;<br/>}<br/><br/>/** jest test **/<br/><br/>it("renders div when method is called",()=&gt;{<br/>  //create component and add it to DOM<br/>  element.unhide();<br/>  Promise.resolve().then(()=&gt;{<br/>    let div = element.shadowRoot.querySelector("div.dyna");<br/>    expect(div).not.toBeNull();<br/>  })<br/>});<br/><br/>/** Snippet 6 **/</span></pre><p id="18e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如代码片段4所示，在jest测试中添加一个<code class="fe ls lt lu lv b">Promise.resolve</code>调用允许执行渲染微任务，以响应调用<code class="fe ls lt lu lv b">unhide</code>时<code class="fe ls lt lu lv b">showDiv</code>属性的变化。结果，我们看到测试通过了。现在考虑一个微小的变化:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="21db" class="ma mb iq lv b be mc md l me mf">/*** component.html ***/<br/><br/>&lt;template if:true={showDiv}&gt;<br/>  &lt;div class="dyna"&gt;&lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>/*** component.js ***/<br/><br/>showDiv=true;<br/>@api<br/>unhide(){<br/>  // the prop is changed only after the apex call returns<br/>  someApexMethod().then(result=&gt;{ <br/>    this.showDiv=true;<br/>  });<br/>}<br/><br/>/** jest test **/<br/><br/>it("renders div when method is called",()=&gt;{<br/>  //create component and add it to DOM<br/>  element.unhide();<br/>  Promise.resolve().then(()=&gt;{<br/>    let div = element.shadowRoot.querySelector("div.dyna");<br/>    expect(div).not.toBeNull(); //fails!!<br/>  })<br/>});<br/><br/>/** Snippet 7 **/</span></pre><p id="25e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，不是立即更改<code class="fe ls lt lu lv b">showDiv</code>属性，而是首先调用apex方法。方法返回后，我们将属性设置为true以呈现div。那么，为什么测试会失败呢？它失败了，因为现在<code class="fe ls lt lu lv b">unhide</code>方法必须解析apex方法promise，然后在元素出现在模板中之前，响应设置<code class="fe ls lt lu lv b">showDiv</code>的实际呈现微任务。</p><blockquote class="mi mj mk"><p id="f7e8" class="kw kx mh ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">请注意，在测试中，我们通常让apex方法模拟硬编码的结果，因此，它们会立即解析。因此，调用apex方法实际上是一个<code class="fe ls lt lu lv b">Promise.resolve</code>调用。</p></blockquote><p id="d7ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在jest测试中添加一个<code class="fe ls lt lu lv b">Promise.resolve</code>调用时，对它的回调在组件中对<code class="fe ls lt lu lv b">someApexMethod</code>的回调之后执行，但是在微任务重新评估模板以响应<code class="fe ls lt lu lv b">showDiv</code>中的变化之前执行。下面是一个更简单的例子来说明这一点:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="2dbf" class="ma mb iq lv b be mc md l me mf">Promise.resolve().then(()=&gt;console.log(1)).then(()=&gt;console.log(2));<br/>Promise.resolve().then(()=&gt;console.log(3)).then(()=&gt;console.log(4));<br/><br/>/** output **/<br/>1<br/>3<br/>2<br/>4<br/><br/>/** Snippet 8 **/</span></pre><p id="2fea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过测试的一种方法是添加一个微任务来进一步推迟测试断言，如下所示:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="0470" class="ma mb iq lv b be mc md l me mf">it("renders div when method is called",()=&gt;{<br/>  //create component and add it to DOM<br/>  element.unhide();<br/>  Promise.resolve()<br/>   .then(()=&gt;{}) //empty function<br/>   .then(()=&gt;{<br/>     let div = element.shadowRoot.querySelector("div.dyna");<br/>     expect(div).not.toBeNull(); //passes<br/>   })<br/>});<br/><br/>/** Snippet 9 **/</span></pre><p id="6cd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在设置反应性属性之前，组件方法中有多个命令性apex方法调用，该怎么办？您必须继续在测试中添加空的<code class="fe ls lt lu lv b">.then</code>调用，以将您的断言推迟足够长的时间，从而完成模板重新评估。除非您在测试apex方法调用之间的中间状态，否则在我看来，这会使您的测试不必要地冗长。因为测试的目标是确保元素被添加到模板中，而不是关心它需要通过多少次回调才能实现。另一种方法是使用<code class="fe ls lt lu lv b">setTimeout</code>延迟断言，如下面的代码片段所示:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="c687" class="ma mb iq lv b be mc md l me mf">it("renders div when method is called",()=&gt;{<br/>  //create component and add it to DOM<br/>  element.unhide();<br/>  setTimeout(()=&gt;{<br/>     let div = element.shadowRoot.querySelector("div.dyna");<br/>     expect(div).not.toBeNull(); //passes<br/>   },0);<br/>});<br/>/** Snippet 10 **/</span></pre><p id="2c64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管<code class="fe ls lt lu lv b">unhide</code> <em class="mh">、</em>中有多少apex方法，我们只需要一个<code class="fe ls lt lu lv b">setTimeout</code>调用来延迟断言，因为所有可解析的承诺回调(微任务)都是在事件循环选择断言任务之前执行的。请注意，我们甚至不需要给我们的<code class="fe ls lt lu lv b">setTimeout</code>调用添加延迟！</p><p id="018f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我想介绍的最后一件事是事件处理程序。考虑下面的代码片段，其中我们在屏幕上有一个按钮和一条消息。在JS文件中，我们在同一个按钮上注册了两个事件处理函数。看起来是这样的:</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="f9a2" class="ma mb iq lv b be mc md l me mf"><br/><br/>&lt;lightning-button onclick={handleClick} label="Click Me" class="btn"&gt;<br/>&lt;/lightning-button&gt;<br/>&lt;h2&gt;{message}&lt;/h2&gt;<br/><br/><br/>/*** JS ***/<br/><br/> _message = "Hello";                                                                                                                                                                                          │<br/>                                                                                                                                                                                                               │<br/>  @api                                                                                                                                                                                                         │<br/>  get message() {                                                                                                                                                                                              │<br/>    return this._message;                                                                                                                                                                                      │<br/>  }<br/><br/>reset() {                                                                                                                                                                                                    │<br/>    this._message = "Hello";                                                                                                                                                                                   │<br/>  }<br/><br/> _handleClickOne = (event) =&gt; {                                                                                                                                                                               │<br/>    console.log("&gt;&gt;. in click handler one ");                                                                                                                                                                  │<br/>    this.reset();                                                                                                                                                                                              │<br/>    // event &amp;&amp; event.preventDefault() &amp;&amp; event.nativeEvent.stopImmediatePropagation() &amp;&amp; event.stopPropagation();                                                                                             │<br/>    this._message += " One";                                                                                                                                                                                   │<br/>    Promise.resolve().then(() =&gt; (this._message += " Promise"));                                                                                                                                               │<br/>    return false;                                                                                                                                                                                              │<br/>  };                                                                                                                                                                                                           │<br/>                                                                                                                                                                                                               │<br/>  _handleClickTwo = () =&gt; {                                                                                                                                                                                    │<br/>    console.log("&gt;&gt;. in click handler two ");                                                                                                                                                                  │<br/>    this._message += " Two";                                                                                                                                                                                   │<br/>  };<br/><br/>/** We are registering two event handlers on the same button **/<br/><br/>_addEventHandlers() {                                                                                                                                                                                        │<br/>    const btn = this.template.querySelector(".btn");                                                                                                                                                           │<br/>    btn.addEventListener("click", this._handleClickOne);                                                                                                                                                       │<br/>    btn.addEventListener("click", this._handleClickTwo);                                                                                                                                                       │<br/>  }                                                                                                                                                                                                            │<br/>                                                                                                                                                                                                               │<br/>  renderedCallback() {                                                                                                                                                                                         │<br/>    if (this._listenersAdded) return;                                                                                                                                                                          │<br/>    this._listenersAdded = true;                                                                                                                                                                               │<br/>    this._addEventHandlers();                                                                                                                                                                                  │<br/>    console.log("listeners added");                                                                                                                                                                            │<br/>  }<br/><br/>/**** Jest Test ***/<br/><br/>it("it should change the message when button is clicked", async () =&gt; {<br/>    // component setup<br/>    await Promise.resolve(); //wait for template evaluation<br/>    element.shadowRoot.querySelector(".btn").click();<br/>    await Promise.resolve(); //wait for the Promise in the event handler to e resolved<br/>    expect(element.message).toBe("Hello One Two Promise"); //passes<br/>  });<br/><br/>/** Snippet 11 **/</span></pre><p id="100f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果似乎很直观。最初，您单击按钮，事件监听器被一个接一个地调用，最后，<code class="fe ls lt lu lv b">Promise</code>回调被执行。您在屏幕上看到的最后一条消息以及您的玩笑测试是<code class="fe ls lt lu lv b">Hello One Two Promise</code>。现在，让我们稍微修改一下，使用一个标准的HTML按钮来代替<code class="fe ls lt lu lv b">lightning-button.</code>，其他的都保持不变。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="2b92" class="ma mb iq lv b be mc md l me mf">&lt;button class="btn" label="Click Me"&gt;&lt;/button&gt;<br/><br/>/** Snippet 12 **/</span></pre><p id="42f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会发现测试还是通过了。但是当你把这个组件添加到一个页面上并点击按钮时，猜猜当你点击按钮时会发生什么？</p><p id="bbea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你得到的信息是<code class="fe ls lt lu lv b">Hello One Promise Two</code>！你不必相信我的话。你自己试试。</p><p id="7cb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为标准的HTML事件侦听器是作为任务执行的，当从网页触发时，它们按照注册的顺序执行。</p><p id="de1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把这个应用到上面的例子中，<code class="fe ls lt lu lv b">_handleClickOne</code>首先被调用。这个方法中的承诺回调被添加到微任务队列中。添加下一个事件监听器<code class="fe ls lt lu lv b">_handleClickTwo</code>作为在下一个事件循环迭代中执行的任务。然而，如上所述，由于微任务比任务具有更高的优先级，因此在<code class="fe ls lt lu lv b">handleClickTwo</code>之前执行<code class="fe ls lt lu lv b">Promise</code>回调。当事件从JavaScript而不是UI触发时，比如通过调用<code class="fe ls lt lu lv b">button.click()</code>，所有注册的事件监听器被同步执行，而不是作为任务执行。</p><p id="4bee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们看到<code class="fe ls lt lu lv b">_handleClickOne</code>和<code class="fe ls lt lu lv b">_handleClickTwo</code>在<code class="fe ls lt lu lv b">Promise</code>回调作为微任务执行之前同步执行。即使从UI中单击<code class="fe ls lt lu lv b">lightning-button</code>也会导致事件监听器同步执行，这与标准HTML按钮的行为不同。现在，无论这是设计还是一个错误都是一个猜测。无论如何，如果您遇到这种情况，意识到这种异常会很有帮助。</p><p id="6bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经做到了这一步，希望您已经能够收集到一些关于事件循环、任务和微任务的信息，以及它们在LWC开发中的相关性。</p><p id="3310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣深入这个兔子洞，<a class="ae kv" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">这里有YouTube上最受欢迎的视频</a>。这是谷歌人的另一个作品，有一些更好的视觉效果。</p></div></div>    
</body>
</html>