# 3 件事 Go 现在比仿制药更需要

> 原文：<https://betterprogramming.pub/three-things-go-needs-right-now-more-than-generics-a6225d62f76b>

## 我的建议是让 Go 成为更好的语言

![](img/d25c1ba6e7fbd36beed7f969683d8d94.png)

官方 Go 标志

不要误解我——我喜欢泛型，我很高兴看到它们将对 Go 语言及其库产生什么影响。然而，很明显，对于 Go 核心团队来说，就规范达成一致并实现泛型是一项艰巨的任务，其他语言的开发也不可避免地要付出代价。

我每天都在使用 Go，虽然缺乏泛型偶尔会成为一个棘手的问题，但大多数情况下，可以通过滥用`interface{}`或手动生成非泛型代码来解决。另一方面，还有其他我更常感觉到的痛点，也许其他地鼠也是如此…

# 1.枚举

如今，令人惊讶的是，一种静态类型的、现代的、可用于生产的语言却不支持枚举。对于任何不熟悉其他语言的枚举的读者来说，简单地说，它们是一种声明自定义类型的方式，该自定义类型可以采用有限数量的可能值中的一个。例如，您可能希望用可能的值`Red`、`Yellow`或`Blue`来声明一个`PrimaryColour`枚举。

事实上，你可以把围棋中的所有原语类型都看作是伪装的枚举。最明显的是，bool 可以被认为是一个只能为真或假的枚举。

然而，这也适用于其他原始类型。一个字节只能表示 8 位范围内的数字 0–255，int32 可以表示 32 位范围内所有可能的有符号整数，指针可以表示(通常)64 位地址空间中所有可能的内存地址。所以实际上，枚举是一种工具，用来创建你自己的类似原语的类型。

枚举在编程中有很多实际的应用——你有多少次使用一个要求你指定一个选项列表的 API？

例如，最近我使用了一个 API，它需要一个`SortOrder`参数来指定结果应该按升序还是降序排序——这是一个二值枚举的完美用例。

对于 Go 中缺少专用的枚举类型，有两种常见的解决方法。第一种是基于整数定义类型，并使用 iota 创建一些命名的常量来表示枚举值:

然而，这种方法有几个重要的问题。首先，如果你完全熟悉枚举在其他语言中的用法，那么这并不是一个显而易见的声明枚举的方法。

其次，因为类型是基于 int 的，所以在类型级别上没有说伪枚举只能取你想要的枚举值——它可以取整数可以表示的任何可能的值。将任意整数常量转换为枚举类型非常容易——这几乎不是您想要的！

这种可能性意味着每次你想打开你的枚举的可能变体时，你总是不得不考虑一个完全意想不到的值进来的可能性。即使你知道这是完全不可能的，编译器也不知道。

第二种解决方法是完全放弃类型安全，只使用字符串常量来表示各种常量。这是双重的悲哀，因为你不仅有上面提到的同样的问题，而且你还有比较字符串的额外的性能成本，而不是快速的整数比较。

如果 go 有一个`enum`关键字来补充现有的`struct`，不仅声明枚举会更加简单和直观，而且编译器将能够严格执行只允许声明枚举变量，这意味着我们可以从 switch 语句中删除默认的错误处理情况，以获得更简洁的代码。

# 2.通用零

当您是新手时，如何以及何时正确使用 nil 是一件相当混乱和随意的事情。简而言之，nil 是一个可用于指针和某些其他类似指针的对象的值，包括切片、映射和接口类型。对于这些类型中的每一种，它都是零值，并且表示一个未初始化的值，如果您试图以任何方式取消对它的引用，这个值通常会爆炸。

也有一些例外——零切片通常相当于长度为 0 的切片，除非不是这样。您可以在 nil 指针上调用方法，但是根据类型的不同，如果特定的方法不检查被传递 nil 的可能性，这可能会导致 nil 指针异常。一个零映射可以从一个空映射中读取，其行为与空映射相同——但是如果你试图写入它，它会死机。

语言是否应该有空指针是一些争论的原因，但是它们已经深深地嵌入到 Go 的类型系统中，我们现在永远也不会摆脱它们。这样做的一个主要原因是要求所有类型都有一个有效的零值——如果用没有赋值的`var`关键字声明，或者作为在构造时没有指定的结构中的一个字段，变量将取这个值。如果指针的零值自动分配一个对象指向，这将是非常浪费的，因此我们有 nil。

问题是，尽管 Go 中的所有类型都有一个零值，但其中只有一部分可以用 nil 表示。通常，nil 可以赋给指针或类似指针的对象，包括地图、切片和接口。任何整数的零值都是 0，字符串的零值是空字符串，bools 的零值是 false。特别是，对于结构值(不是指针)的零值，没有捷径可走——必须指定结构名，后跟一组空括号。当执行许多样板错误检查时，如果编写一个返回结构类型和错误值的函数，这很快就会变得乏味。

当然，你可以返回一个指向该结构的指针，而不是使用 nil 但是也许调用代码接收一个值而不是一个指针更有意义。也许你想避免堆分配返回一个指针值。

在我看来，有一个简单的解决方案摆在我们面前——让`nil`成为任何类型零值的占位符，包括结构以及整数和字符串等原始类型。这意味着我们不再需要为了简单的错误处理而总是将结构作为指针返回。当然，看到整数用 nil 代替 0 可能有点奇怪，但我认为这是一个很小的代价——此外，它可以被限制为只用于简单的赋值或返回语句，而不是算术表达式的一部分。

# 3.简明错误处理

可能是最有争议的——Go 因其高度冗长的错误处理而闻名，其特点是重复的`if`语句。

与支持异常的语言相比，Go 的详细错误处理更加明确，并且更容易跟踪错误在程序中的传播路径。然而，这是以占用 4 倍多的代码行为代价的——这不是一个很好的信噪比！

我相信有一种替代方法，它将错误的显式传递保持为值而不是异常，但不需要 4 倍多的代码行。从 Rust 中获得灵感，Go 可以引入一个新的`?`操作符，作为样板代码`if err != nil {...}`的快捷方式。

这个`?`操作符的基本思想是自动插入`if err != nil { return nil, err }`样板文件。在`err`为 nil 的情况下，表达式采用第一个返回对象的值，允许我们将结果赋给一个变量。

这可能不像完整地写出`if`语句那么冗长，但是我个人认为，在大多数典型的 Go 程序中，就大幅减少代码行数而言，添加一个`?`操作符仍然是一个很好的权衡。

# 摘要

Go 是一种很棒的语言，但我认为它还有很大的发展空间。这三个建议你怎么看？有更好的主意吗？