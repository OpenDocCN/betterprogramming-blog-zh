<html>
<head>
<title>Build Scalable Event-Driven Applications With Nest.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nest.js构建可伸缩的事件驱动应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-scalable-event-driven-applications-with-nest-js-28676cb093d0?source=collection_archive---------0-----------------------#2022-11-28">https://betterprogramming.pub/build-scalable-event-driven-applications-with-nest-js-28676cb093d0?source=collection_archive---------0-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将探索可能发生的可伸缩性问题的实际例子以及解决这些问题的常用方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81f15dfbd95ff59d6c91febe9a3c203d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ENfamkyhtCGebF7r"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加布里埃尔·海因策在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想谈谈Nest.js框架为开发人员提供的可伸缩事件驱动应用程序的元素。我将展示使用现代框架构建后端Node.js应用程序是多么容易。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="be85" class="lx ly iq lt b be lz ma l mb mc"><strong class="lt ir">Agenda</strong><br/><br/>What is Nest.js?<br/><br/><a class="ae kv" href="#1fc3" rel="noopener ugc nofollow">How Does Nest.js Help Build Highly-Scalable Apps?</a><br/><br/><a class="ae kv" href="#e49d" rel="noopener ugc nofollow">Demo App and Tools</a><br/><br/><a class="ae kv" href="#7525" rel="noopener ugc nofollow">Demo App in Action</a></span></pre><p id="90aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想简要地写一下什么是Nest.js，以及它如何帮助构建可伸缩的应用程序？我为你准备了一个演示。我们将描述整体架构和使用的工具，然后运行并查看我们的演示。</p><h1 id="23b9" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">什么是</strong> Nest.js <strong class="ak">？</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/6874d128892fc467ace4bbd835f7a7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdw5YjRIGsFESBo93PtGBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nest.js —构建后端Node.js应用程序的现代框架。</p></figure><p id="7a14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个构建Node.js应用程序的框架。</p><p id="d7ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的灵感来自Angular，并且非常依赖TypeScript。</p><p id="8ac1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以它提供了某种类型安全的开发体验。transpiling之后还是JavaScript，所以在处理常见的安全风险时要小心。</p><p id="1eb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它已经是一个相当流行的框架，你可能已经听说过了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/53e28700c62f117e5aac06f371c5da91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2tRGA7liVBxLJRVyf8I8g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GitHub从2022年到2011年</p></figure><h2 id="917d" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated">为什么使用另一个框架？</h2><ul class=""><li id="703d" class="ni nj iq ky b kz nk lc nl lf nm lj nn ln no lr np nq nr ns bi translated">依赖注入</li><li id="b564" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">与数据库的抽象集成</li><li id="28a7" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">抽象的常见用例:缓存、配置、API版本和文档、任务调度、队列、日志、cookies、事件和会话、请求验证、HTTP服务器(Express或Fastify)、身份验证。</li><li id="3d2d" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">打字稿(和装饰者)</li><li id="12d0" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">优秀应用程序的其他设计元素:中间件、异常过滤器、防护、管道等等。</li><li id="ab3e" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">还有一些，我稍后会讲到</li></ul><p id="fc33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速回顾一下这个框架为我们提供了什么。</p><p id="bfa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用框架的一个主要优点是有一个依赖注入。它消除了创建和支持类依赖树的开销。</p><p id="9fdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它与大多数数据库有抽象的集成，所以你不必考虑它。一些最受支持的开发和流行的包是mongoose、TypeORM、MikroORM和Prisma。</p><p id="5caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它抽象了web开发的常见用例，如缓存、配置、API版本和文档、队列等。</p><p id="943e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于HTTP服务器，您可以选择Express或Fastify。</p><p id="44c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使用了TypeScript和decorators。它简化了阅读代码，尤其是在较大的项目中，并允许开发团队在推理组件时保持一致。</p><p id="fad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，与任何框架一样，它提供了其他应用程序设计元素，如中间件、异常过滤器、防护、管道等等。</p><p id="4b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们稍后将讨论可伸缩性特有的其他一些特性。</p><h1 id="1fc3" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Nest.js如何帮助构建高可伸缩性的应用？</h1><p id="3a4c" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">让我们首先回顾一下构建高可伸缩性应用程序的主要策略。</p><p id="0a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是选项:</p><ul class=""><li id="2b1c" class="ni nj iq ky b kz la lc ld lf ob lj oc ln od lr np nq nr ns bi translated">整体式(模块化)</li><li id="cea0" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">微服务</li><li id="c4b2" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">事件驱动的</li><li id="40d0" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">混合的</li></ul><blockquote class="oe"><p id="fc41" class="of og iq bd oh oi oj ok ol om on lr dk translated">软件开发都是关于权衡的。</p></blockquote><p id="e94d" class="pw-post-body-paragraph kw kx iq ky b kz oo jr lb lc op ju le lf oq lh li lj or ll lm ln os lp lq lr ij bi translated">我想谈的第一种方法是使用monolith。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/672ff47039285f19845316e232d8d432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRsDEPu4LUS2TFIuFSz0nQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">monolith Nest.js项目架构示例。</p></figure><p id="9892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个组件紧密耦合的单一应用程序。</p><p id="eb3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们一起部署，一起支持，通常，他们离不开彼此。</p><p id="2485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用那种方式编写你的应用程序，最好使用模块化的方法，这是Nest.js非常擅长的。</p><p id="ab2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用模块化方法时，您可以有效地拥有一个代码库，但是您的系统的组件作为某种程度上独立的实体，可以由不同的团队来工作。随着团队和项目的增长，这变得更加困难。这就是为什么我们有其他的架构开发模型。</p><h2 id="4289" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated"><strong class="ak">微服务</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/59c45b9347427b84c025f7061af5f017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c37PJRceIRArQLN9a5BzuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个微服务Nest.js项目架构的例子。</p></figure><p id="b794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微服务是指每个服务都有单独的部署。通常，每个服务只负责一小部分工作，并且会有自己的存储。</p><p id="488a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件驱动的方法类似于微服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/f56f3d09eb5a2eb88b51624c69c0d161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYW57oq4-E99rn6JI-X3PA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事件驱动的Nest.js项目架构示例。</p></figure><p id="df48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，服务之间没有直接的通信。而是每个服务都会发出一个事件，然后就不管了。</p><p id="d9a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该事件可以有侦听器，但不能有侦听器。如果有人消费了事件，它可以再次产生另一个事件，另一个服务可以消费，等等。</p><p id="721d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，有人会为等待的客户端生成一个响应。它可以是WebSocket响应或webhook或其他任何东西。</p><p id="ee2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务将通过HTTP请求或消息传递与其他服务通信。</p><h2 id="e24a" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated"><strong class="ak">混合建筑</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/d98b5e610dff4b2761cacb1c0be1fd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ninrIGorgKZZv6XiHgQc0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">混合Nest.js项目架构的例子。</p></figure><p id="32c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，我们的大型项目是所有设计的混合——一些组件紧密耦合并部署在一起，一些组件单独部署，一些组件通过事件消息传递进行通信。</p><h1 id="98b1" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Nest.js =简单的事件驱动应用程序开发</h1><p id="6343" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">让我们思考一下为什么这个框架简化了事件驱动的开发。</p><ul class=""><li id="23cb" class="ni nj iq ky b kz la lc ld lf ob lj oc ln od lr np nq nr ns bi translated">与Redis/Bull集成进行队列管理(【github.com/OptimalBits/bull】T4)</li><li id="67d2" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">与大多数消息传递代理集成</li><li id="4dc8" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">促进模块化开发</li><li id="8468" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">出色的文档和示例</li><li id="b812" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">单元和集成测试是自举的(DI，Jest)</li></ul><p id="9c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，它允许快速简单地集成流行的Bull队列包。</p><p id="7a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于微服务开发和通信，它集成了最受欢迎的消息代理，如Redis、Kafka、RabbitMQ、MQTT、NATS等。</p><p id="671e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三，它促进了模块化开发，因此在项目生命周期的后期提取单个工作单元自然很容易。</p><p id="b3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的下一点是，它有很好的文档和例子，这总是好的。你可以在几分钟内运行你的第一个分布式应用。</p><p id="326d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想注意的另一件事是，单元和集成测试是为你自举的。它有用于测试的DI和Jest测试框架的所有其他强大特性。</p><h1 id="59d8" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">队列</strong> (npm/bull)</h1><p id="fd21" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">现在，让我们看看如何在NestJS中创建一个简单的队列。</p><h2 id="2463" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated"><strong class="ak">队列:添加连接</strong></h2><p id="97e5" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">首先，使用以下命令安装所需的依赖项:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="4673" class="lx ly iq lt b be lz ma l ow mc">npm install --save @nestjs/bull bull<br/>npm install --save-dev @types/bull</span></pre><p id="133a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后创建一个到Redis的连接。</p><blockquote class="ox oy oz"><p id="91f9" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js用Bull连接Redis的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="75d8" class="lx ly iq lt b be lz ma l ow mc">BullModule.forRootAsync({<br/>  imports: [ConfigModule],<br/>  useFactory: async (configService: ConfigService) =&gt; ({<br/>    redis: {<br/>      host: configService.get('REDIS_HOST') || '127.0.0.1',<br/>      port: +configService.get('REDIS_PORT') || 6379,<br/>      password: configService.get('REDIS_PASSWORD') || undefined,<br/>    },<br/>  }),<br/>  inject: [ConfigService],<br/>}),</span></pre><p id="c844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，注册一个队列。</p><blockquote class="ox oy oz"><p id="e805" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">向Bull注册Nest.js队列的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="5863" class="lx ly iq lt b be lz ma l ow mc">BullModule.registerQueue({<br/>  name: TRADES,<br/>}),</span></pre><h2 id="1e4a" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated">队列:<strong class="ak">事件生成器注入一个队列</strong></h2><blockquote class="ox oy oz"><p id="edcf" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js用Bull发出事件的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="81b2" class="lx ly iq lt b be lz ma l ow mc">export class TradeService {<br/>  constructor(@InjectQueue(TRADES) private queue: Queue) {}<br/><br/>  async add() {<br/>    const uuid = randomUUID();<br/><br/>    await this.queue.add({ uuid });<br/>  }<br/>}</span></pre><p id="a951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在服务构造函数中的其他地方，您键入提示您的队列，它被依赖注入容器注入——您现在拥有对队列的完全访问权，并且可以开始发出事件。</p><h2 id="edbf" class="mw ly iq bd me mx my dn mi mz na dp mm lf nb nc mo lj nd ne mq ln nf ng ms nh bi translated">队列:<strong class="ak">事件消费者处理队列</strong></h2><blockquote class="ox oy oz"><p id="4fd9" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js用Bull消费事件的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="4d36" class="lx ly iq lt b be lz ma l ow mc">@Processor(TRADES)<br/>export class TradeService {<br/>  @Process()<br/>  async process(job: Job&lt;TradeCreatedDto&gt;) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="c1e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在另一个模块的某个地方，你用一个最小的设置来修饰你的处理器类，以使一个队列系统工作。</p><p id="c5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以让生产者和消费者存在于一个应用程序中，也可以分开存在。他们将通过您选择的消息代理进行交流。</p><h1 id="fabb" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">消息传递集成—连接</strong></h1><p id="0f2a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">消息提供者连接从添加客户端模块连接开始。在这个例子中，我们有Redis传输，应该提供Redis特定的连接选项。</p><blockquote class="ox oy oz"><p id="26e0" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js向Redis注册消息客户端模块的示例。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="5d44" class="lx ly iq lt b be lz ma l ow mc">@Module({<br/>  imports: [<br/>    ClientsModule.register([<br/>      {<br/>        name: 'MATH_SERVICE',<br/>        transport: Transport.REDIS,<br/>        options: {<br/>          host: 'localhost',<br/>          port: 6379<br/>        }<br/>      },<br/>    ]),<br/>  ]<br/>  ...<br/>})</span></pre><h1 id="6984" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">消息传递集成—生产者</strong></h1><p id="f48f" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">下一步是将客户机代理接口注入我们的生产者服务。</p><blockquote class="ox oy oz"><p id="d130" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js将消息传递客户端模块注入服务类的示例。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="7ec2" class="lx ly iq lt b be lz ma l ow mc">constructor(<br/>  @Inject('MATH_SERVICE') private client: ClientProxy,<br/>) {}</span></pre><p id="c255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们进一步的选择是<code class="fe pe pf pg lt b">SEND</code>方法或<code class="fe pe pf pg lt b">EMIT</code>。</p><p id="8e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe pe pf pg lt b">SEND</code>通常是一个同步动作，类似于HTTP请求，但是被框架抽象为通过选择的传输来动作。</p><p id="1f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，<code class="fe pe pf pg lt b">accumulate()</code>方法的响应直到消息被监听器应用程序处理后才会被发送到客户端。</p><blockquote class="ox oy oz"><p id="d213" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">一个Nest.js通过消息代理向远程服务发送消息的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="5ce6" class="lx ly iq lt b be lz ma l ow mc">accumulate(): Observable&lt;number&gt; {<br/>  const pattern = { cmd: 'sum' };<br/>  const payload = [1, 2, 3];<br/>  return this.client.send&lt;number&gt;(pattern, payload);<br/>}</span></pre><p id="9e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe pe pf pg lt b">EMIT</code>命令是一个异步的工作流启动，它将充当触发和遗忘或者在某些传输中，这将充当一个持久的队列事件。这将取决于所选择的传输及其配置。</p><blockquote class="ox oy oz"><p id="039f" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js通过消息代理向远程服务发送消息的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="6996" class="lx ly iq lt b be lz ma l ow mc">async publish() {<br/>  this.client.emit&lt;number&gt;('user_created', new UserCreatedEvent());<br/>}</span></pre><p id="b3bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe pe pf pg lt b">SEND</code>和<code class="fe pe pf pg lt b">EMIT</code>模式在消费者端有稍微不同的用例。让我们看看。</p><h1 id="0dc9" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">消息传递集成—消费者</strong></h1><p id="226f" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated"><code class="fe pe pf pg lt b">MessagePattern</code> decorator只用于类似同步的方法(用<code class="fe pe pf pg lt b">SEND</code>命令产生)，并且只能在控制器修饰的类中使用。</p><p id="7e58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们希望通过我们的消息传递协议收到的请求会得到一些响应。</p><blockquote class="ox oy oz"><p id="11bc" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js通过消息代理响应远程服务的例子。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="396d" class="lx ly iq lt b be lz ma l ow mc">@Controller()<br/>export class MathController {<br/>  @MessagePattern({ cmd: 'sum' })<br/>  accumulate(data: number[]): number {<br/>    return (data || []).reduce((a, b) =&gt; a + b);<br/>  }<br/>}</span></pre><p id="ee36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<code class="fe pe pf pg lt b">EventPattern</code> decorator可以在你的应用程序的任何自定义类中使用，它会监听在同一个队列或事件总线上产生的事件，并且它不期望我们的应用程序返回什么。</p><blockquote class="ox oy oz"><p id="a109" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js通过消息传递代理处理来自远程服务的消息的示例。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="56cf" class="lx ly iq lt b be lz ma l ow mc">@EventPattern('user_created')<br/>async handleUserCreated(data: Record&lt;string, unknown&gt;) {<br/>  // business logic<br/>}</span></pre><p id="dddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种设置类似于其他消息传递代理。如果是自定义的，您仍然可以使用阿迪容器并使用Nest.js接口创建自定义事件子系统提供程序。</p><blockquote class="ox oy oz"><p id="7585" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">Nest.js的MQTT和NATS消费者示例</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="057c" class="lx ly iq lt b be lz ma l ow mc">// MQTT<br/>@MessagePattern('notifications')<br/>getNotifications(@Payload() data: number[], @Ctx() context: MqttContext) {<br/>  console.log(`Topic: ${context.getTopic()}`);<br/>}<br/><br/>// NATS<br/>@MessagePattern('notifications')<br/>getNotifications(@Payload() data: number[], @Ctx() context: NatsContext) {<br/>  console.log(`Subject: ${context.getSubject()}`);<br/>}</span></pre><blockquote class="ox oy oz"><p id="2150" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">RabbitMQ和Kafka nest . js的消费者示例。</p></blockquote><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="7004" class="lx ly iq lt b be lz ma l ow mc">// RabbitMQ<br/>@MessagePattern('notifications')<br/>getNotifications(@Payload() data: number[], @Ctx() context: RmqContext) {<br/>  console.log(`Pattern: ${context.getPattern()}`);<br/>}<br/><br/>// Kafka<br/>@MessagePattern('hero.kill.dragon')<br/>killDragon(@Payload() message: KillDragonMessage, @Ctx() context: KafkaContext) {<br/>  console.log(`Topic: ${context.getTopic()}`);<br/>}</span></pre><p id="c15a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是使用Nest.js抽象与最常见的消息传递代理集成的简单程度。</p><h1 id="e49d" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">演示应用和工具</strong></h1><p id="cbed" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">可从以下<a class="ae kv" href="github.com/dkhorev/conf42-event-driven-nestjs-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p><p id="58f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一节中，我将回顾一个真实应用程序的一部分(当然是简化的)。您可以在我的GitHub页面上获得源代码，或者稍后试用。我将展示正确设计的EDA如何面对挑战，以及我们如何使用框架工具快速解决这些挑战。</p><h1 id="fac9" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">演示应用概述</strong></h1><p id="3561" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">让我们先做一个快速的概述。我们预期的工作流程如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/65dbb9e19346f4a9bc1cd5c91c2a497d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XphsQyt_wsZcXVsi4BY14w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nest.js事件驱动的应用程序演示概述。</p></figure><p id="8186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个在API网关中发生的动作，它触及交易服务，交易服务发出一个事件。</p><p id="7944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该事件进入队列或事件总线。然后，我们有四个其他服务监听并处理它。</p><p id="9727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了观察这个应用程序的性能，我使用了一个辅助应用程序，它是我的“通道监视器”这是一种提高可观察性的强大模式，有助于根据渠道指标自动扩大和缩小规模。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/a747708587bc759ce724deae15fb2957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tSNosXFtWnPRmuYNSgZoA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有通道监视器的Nest.js事件驱动应用程序演示概述。</p></figure><p id="d3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一会儿我会告诉你它是如何工作的。</p><h1 id="7525" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">运行中的演示应用——正常条件下</h1><p id="18c6" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">我准备了一个<code class="fe pe pf pg lt b">Makefile</code>，所以你可以跟着来。</p><p id="e139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，运行一个<code class="fe pe pf pg lt b">make start</code>命令，它将启动docker和所有需要的服务。接下来，运行一个<code class="fe pe pf pg lt b">make monitor</code>命令来查看应用程序指标。</p><p id="ef91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">监视器显示了队列名称、等待作业的数量、已处理作业的数量以及在线工作实例的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/fe67739a0163d41f212a5a9a5270f2f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xq1_rQOgn-P3i832msmfmQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行中的演示应用——正常条件下。</p></figure><p id="8dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，在正常情况下，<code class="fe pe pf pg lt b">jobs_waiting</code>计数为零，事件流很慢，我们没有任何堆积的作业。</p><p id="41e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个应用程序在低事件计数的情况下工作良好。但是如果流量突然增加会怎么样呢？</p><h1 id="c072" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">运行中的演示应用程序—流量峰值</h1><p id="52fa" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">您可以通过运行<code class="fe pe pf pg lt b">make start-issue1</code>命令并使用<code class="fe pe pf pg lt b">make monitor</code>命令重启监视器来开始这个演示。我们的事件流增加了三倍。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/dd65fc25f973bb3fdd5b058bfe632ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*5t8uoqLzchMVpJ94QNDVzA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nest.js事件驱动的应用程序演示，流量增加。</p></figure><p id="9183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您最终会在monitor应用程序中注意到<code class="fe pe pf pg lt b">jobs_waiting</code>计数将开始增加，虽然我们仍在用一个工人处理作业，但与增加的流量相比，队列已经变慢了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/e76c8b7e74bde2e842be3c41d88d135e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LKzvs5tXDDjjDZvnSrL0-Q.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行中的演示应用——流量激增。</p></figure><p id="2aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以看到，这抑制了我们的关键任务贸易服务确认。</p><p id="2df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">worker会无优先级地处理所有事件，因此每个新的交易确认必须首先等待一些over事件完成。</p><p id="1bd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以想象这会导致我们的交易处理前端客户端应用程序的响应时间变慢。</p><h1 id="f70c" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">解决方案？</strong></h1><p id="a445" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">让我们探索一下解决这个问题的方法:</p><ul class=""><li id="06f7" class="ni nj iq ky b kz la lc ld lf ob lj oc ln od lr np nq nr ns bi translated">扩展worker实例，以便它能够更快地处理队列</li><li id="9ef2" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">增加工作实例计数</li><li id="85cc" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">应用优化</li><li id="0267" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">分开队列</li><li id="6beb" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">优先处理事件</li></ul><p id="a079" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个也是最明显的是扩展worker实例，这样它会运行得更快。在Node.js世界中，这很少是一个好的解决方案，除非您正在处理视频、音频或加密等高CPU密集型任务。</p><p id="7a69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二是增加工作实例数。这是一个有效的选择，但有时不太划算。</p><p id="aa98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以考虑应用程序优化，包括概要分析、调查数据库查询以及类似的活动。这可能很耗时，且不会产生任何结果或非常有限改进。</p><p id="c736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nest.js可以帮助我们实现最后两个选项。这是为了区分队列和优先处理一些事件。</p><h1 id="3697" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">步骤1-分离队列</h1><p id="5781" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">我将从应用队列分离方法开始。</p><p id="4d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">交易队列将只负责处理交易确认事件。</p><p id="7da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的代码应该是这样的:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="5736" class="lx ly iq lt b be lz ma l ow mc">this.queue.add(JOB_ANALYTICS, { uuid });<br/>this.queue.add(JOB_NOTIFICATION, { uuid });<br/>this.queue.add(JOB_STORE, { uuid });<br/>// this.queue.add(JOB_TRADE_CONFIRM, { uuid });<br/>this.queueTrades.add(JOB_TRADE_CONFIRM, { uuid });</span></pre><p id="e535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是要求我们的<code class="fe pe pf pg lt b">PRODUCER</code>向新队列<code class="fe pe pf pg lt b">TRADES</code>发出一个<code class="fe pe pf pg lt b">TRADE CONFIRM</code>事件。</p><p id="9b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在消费者端，我提取了一个名为<code class="fe pe pf pg lt b">TradesService</code>的新类，并将其作为监听器分配给<code class="fe pe pf pg lt b">TRADES</code>队列。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="4579" class="lx ly iq lt b be lz ma l ow mc">@Processor(QUEUE_TRADES)<br/>export class TradesService {<br/>  protected readonly logger = new Logger(this.constructor.name);<br/><br/>  @Process({ name: '*' })<br/>  async process(job: Job&lt;TradeCreatedDto&gt;) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="3fe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe pe pf pg lt b">QUEUE DEFAULT</code>监听器服务保持不变。我不需要在这里做任何改变。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="eff1" class="lx ly iq lt b be lz ma l ow mc">@Processor(QUEUE_DEFAULT)<br/>export class DefaultService {<br/>  protected readonly logger = new Logger(this.constructor.name);<br/><br/>  @Process({ name: '*' })<br/>  async process(job: Job&lt;TradeCreatedDto&gt;) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="1b9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，无论发生什么，无论我们有什么样的峰值，交易永远不会停止处理(他们会慢下来，但不会等待不重要的事件)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/1a8c89c1df6756916b69b1036af7bb36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10WxVaoezUCuT2DCU14RKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有独立交易队列的Nest.js事件驱动应用程序演示。</p></figure><p id="ca28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe pe pf pg lt b">start-step1</code>命令运行这个示例，并重新启动监视器。</p><p id="b742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到交易队列的<code class="fe pe pf pg lt b">jobs_waiting</code>计数为零，但是默认队列仍然会遇到问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/29f661d19a1e049159e88604eb6c6836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WAXAB51UhSx72sU_wet1Eg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行中的演示应用程序——交易队列是独立且固定的。</p></figure><p id="1647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我将根据我所掌握的信息应用我们的第二步进行扩展，我只为<code class="fe pe pf pg lt b">DEFAULT QUEUE</code>将worker实例计数增加到<code class="fe pe pf pg lt b">3</code>。</p><h1 id="45e7" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">步骤2 —秤工人</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/aaadba184ffa78cfe374cd47e26dae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2GJopwK-Hwp13pdjLOHzQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nest.js事件驱动的应用程序演示，具有单独的交易队列，并将默认队列工作线程增加到3个。</p></figure><p id="2155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过运行<code class="fe pe pf pg lt b">start-step2</code>命令并重启显示器来开始此演示。随着时间的推移，这个应用程序在两个队列上都变为零<code class="fe pe pf pg lt b"> jobs_waiting</code>，干得好！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/13341eb7c547ce4e9db6683e60b7ff3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wrXhcYuP9-Hb_RNifyx_ZQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行中的演示应用——应用稳定。</p></figure><p id="2162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所知，我的例子有点做作，主要是为了演示。你可以很容易地看到我们如何利用<code class="fe pe pf pg lt b">channel monitor patterns</code>通过放大或缩小单独的队列工作器来有计划地对我们的应用程序性能变化做出反应。</p><h1 id="6575" class="md ly iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">解决方案—概述</h1><p id="89f7" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">让我们回顾一下。我在这里应用了列表中的以下解决方案:</p><ul class=""><li id="0f83" class="ni nj iq ky b kz la lc ld lf ob lj oc ln od lr np nq nr ns bi translated">扩展worker实例，以便它能够更快地处理队列</li><li id="2b46" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">增加工作实例计数</li><li id="3724" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">应用优化</li><li id="492e" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">分开排队</li><li id="a63a" class="ni nj iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">优先处理事件</li></ul><p id="afdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建了一个单独的<code class="fe pe pf pg lt b">TRADES</code>队列，该队列还会自动确定这些事件的优先级。</p><p id="1042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我增加了<code class="fe pe pf pg lt b">DEFAULT QUEUE</code>到<code class="fe pe pf pg lt b">3</code>的worker实例数。</p><p id="0505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些主要是由Docker和Nest.js框架为我完成的。</p><p id="9a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步你可以通过使用框架的工具来实现，就是将一些其他的事件优先于其他的事件。例如，与日志记录或内部指标相关的任何事情都可以被延迟，以支持更关键的任务事件，如数据库交互、通知等。</p><p id="cd3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试代码的存储库在这里:<a class="ae kv" href="https://github.com/dkhorev/conf42-event-driven-nestjs-demo" rel="noopener ugc nofollow" target="_blank">github.com/dkhorev/conf42-event-driven-nestjs-demo</a>。</p><p id="7f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于容器和模块化开发，我在链接处使用了<code class="fe pe pf pg lt b">Container Role Pattern</code>描述的<a class="ae kv" href="https://medium.com/@dkhorev/docker-container-roles-pattern-for-nestjs-apps-ca8b07a08a9a" rel="noopener">。</a></p></div><div class="ab cl pn po hu pp" role="separator"><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps"/></div><div class="ij ik il im in"><p id="d07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这有所帮助。祝好运，工程快乐！</p></div><div class="ab cl pn po hu pp" role="separator"><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps pt"/><span class="pq bw bk pr ps"/></div><div class="ij ik il im in"><p id="6936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更有趣的Nest.js读着:</p><div class="pu pv gp gr pw px"><a rel="noopener  ugc nofollow" target="_blank" href="/validating-complex-requests-with-nestjs-a-practical-example-b55c287f7c99"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd ir gy z fp qc fr fs qd fu fw ip bi translated">用Nest.js验证复杂请求</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">实际例子</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">better编程. pub</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql kp px"/></div></div></a></div><div class="pu pv gp gr pw px"><a rel="noopener  ugc nofollow" target="_blank" href="/improve-response-time-10x-by-introducing-an-interceptor-in-nestjs-590695692360"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd ir gy z fp qc fr fs qd fu fw ip bi translated">通过在Nest.js中引入拦截器，将响应时间提高10倍</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">带有基准比较的实际实施</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">better编程. pub</p></div></div><div class="qg l"><div class="qm l qi qj qk qg ql kp px"/></div></div></a></div></div></div>    
</body>
</html>