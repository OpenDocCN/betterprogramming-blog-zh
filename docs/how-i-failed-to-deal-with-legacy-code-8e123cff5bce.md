# 我如何未能处理遗留代码

> 原文：<https://betterprogramming.pub/how-i-failed-to-deal-with-legacy-code-8e123cff5bce>

## 在这个过程中我学到了什么

![](img/7509b0354670b0e48142f9085589972d.png)

照片由 [beasty 拍摄。](https://unsplash.com/@beastydesign?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我清楚地记得我第一次维护遗留代码的经历。我是一名初级开发人员，完全不知道自己在做什么。

该应用本身有点像 Slack，同事们可以创建工作区，自动与客户分享他们的每一次交流。

创始人没有技术背景。他们有一个如何改善团队协作的想法，他们雇佣了一个代理来实现第一个版本。以下特性分别由不同的自由职业者实现。

有些地方在 AngularJS，有些地方在 Django 和 Tornado。这没有任何意义。

对我来说，代码看起来就像[哈尔的移动城堡](https://en.wikipedia.org/wiki/Howl%27s_Moving_Castle_(film)#/media/File:Howls-moving-castleposter.jpg)中生锈的蒸汽机器:勉强保持在一起，慢慢向前移动。

我害怕在代码库中添加任何东西。每次我修复一个错误，另一个就会出现。

我当时应该知道，缺乏结构、代码重复、紧密耦合以及添加新功能的困难是代码糟糕和脆弱的警告信号。

# 重写几乎从来都不是一个好主意

维护别人的代码是不愉快的。我认为最好的办法是做一张白板，从零开始，用我认为干净的架构。

这种重写体验非常紧张和耗时。一方面，我认为我受到了[计划谬误](https://en.wikipedia.org/wiki/Planning_fallacy)的困扰:我对准备好投入生产需要多少时间过于乐观。另一方面，我完全过度设计了一些零件。

此外，由于在重写期间没有发布新功能，我的经理没有看到任何结果。他很沮丧，把这个压力推给了我。

为了尽快投入生产，我走了一些捷径，导致了设计错误。所以我又回到了起点。

当我想到这一点时，我很确定每一个开发过这个令人精神崩溃的遗留应用程序的程序员都有同样的感受。他们每个人都在他们熟悉的框架或语言中开始了新的东西。每一个都带来了更多的复杂性，这就是我们最终陷入这种混乱的原因。

*你的重写不会比现有的代码更好。*

代码在进化。有大量的外部和内部力量会给一个闪亮的新项目带来设计缺陷。新的特性将会出现，需求将会改变，一些部分将会过时，一些 API 端点将会被废弃。

# 如何编写经得起未来考验的代码？

你不知道。[你不会需要它的！](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)

YAGNI 是一个极限编程概念，它说你不应该因为你认为你将来会需要它而现在就构建它。

试图为未来的用例开发一些东西只会增加项目的复杂性。你最好只写你需要的。每一个功能都应该是刻意添加的。

本着同样的精神，您应该不愿意添加依赖项和框架。正如一位老导师曾经告诉我的:

> 每当您添加一个工具或依赖项时，请考虑要消除它需要付出多大的努力。

这个原则可以进一步扩展。当编写一个新的组件时，你应该以这样一种方式来设计它，使得它在将来可以很容易地被移除——万一产品团队有一天决定淘汰那个特性或者改变需求。

# 临时解决方案从来都不仅仅是暂时的

在概念验证(POC)中，开发人员通常利用这个机会享受乐趣并探索新的技术堆栈。问题是，这些临时概念证明是项目的基础。一切都建立在它的基础上，最初选择的框架或语言永远不会改变。

这就是为什么在一个创业公司中，你可能会发现一个项目在 Go 中，另一个在 Python 中，第三个在 NodeJs 中。

即使是变通办法也不是暂时的。我最近在代码库中偶然发现了一个描述临时实现的注释。在 GitHub 中快速查找，我发现这个*临时*代码已经存在好几年了。

小的黑客攻击堆积起来，直到代码成为遗留系统。在[变得真实](https://basecamp.com/gettingreal/10.4-manage-debt)中，Basecamp 团队写道:

> “拼凑一些功能正常但仍有一些问题的糟糕代码，你正在增加债务。拼凑一个足够好但并不真正好的设计，你又做了一次。
> 
> 时不时这样做是可以的。这通常是一种必要的技巧，可以帮助你尽快实现目标。但是你仍然需要认识到它是债务，并在某个时候通过清理多毛的代码或重新设计那个马马虎虎的页面来偿还。"

# 代码会生锈

在著名的博客文章[中，Joel Spolsky 写道:](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)

> “认为新法规优于旧法规的观点显然是荒谬的。旧代码已经被*使用*。它已经过*测试*。*发现了很多*bug，并且已经*修复了*。没什么不好。它不会因为坐在你的硬盘上而感染病毒。恰恰相反，宝贝！软件应该像一辆旧的道奇 Dart 一样，停在车库里就会生锈吗？如果软件不是用全新的材料制作的，会不会像泰迪熊一样有点恶心？”

到目前为止，我同意重写很少是合理的，它可能需要很长时间才能完成，但除此之外，我不同意乔尔。问题是，如果你把一个项目搁置足够长的时间，它就会生锈。

我想到的例子是一个在 Angular1 中实现的 web 应用程序。在发布了一些重要的特性之后，我们在产品管道中没有任何关于这个应用的东西，于是我转而从事一个不同的项目。

与此同时，Angular2 被释放。尽管 Angular1 没有被官方弃用，但我们在那个项目中使用的库现在已经停止维护了。

在这种情况下，一个解决方案是使用[扼杀模式](https://paulhammant.com/2013/07/14/legacy-application-strangulation-case-studies/)并一点一点地替换框架。不利的一面是，重构可能会花费很长时间，两个堆栈会有分歧，并且很难让人们跟上这个项目的进度。

经验教训:框架根据定义是固执己见的。它们强加了架构最佳实践、编码惯例，并且不容易抛弃！

# 优先考虑可读性，而不是灵活性

在一个项目中，我们必须解析一些日志。我们决定依靠 [Fluentd](https://www.fluentd.org/) 并编写了一个插件，使用正则表达式来解析日志流。

使用正则表达式可能会令人沮丧。我一直发现自己在处理一堆只能暂时阅读的东西。第二天，甚至就在我休息一会儿之后，我会先去破译正则表达式。

如果我优先考虑可读性，我可能会对自己承认，尽管这个解决方案看起来可行，但却不可接受。理解代码所花费的时间是巨大的——即使对我这个编写代码的人来说也是如此！毫无疑问，还有更直接的解决方案。

编写干净的代码是关于在六个月内与它交互的难易程度。

# 重构遗留代码的实用建议

遗留代码是生产中使用的未经测试的代码。换句话说，这是每个人都害怕接触的代码部分。

以下是重构遗留代码的一些策略:

## 从编写测试开始

一位老同事曾经告诉我，在为遗留代码编写测试时，迭代处理更容易。

由于紧密耦合，遗留代码通常不容易被模仿和隔离，这使得编写单元测试很困难。从集成测试开始通常更容易。

同样，开始测试外部分支也更容易。假设您有一个更新某些属性的 API 端点。端点首先检查用户是否通过了身份验证，是否具有适当的用户角色，然后继续验证输入和更新。

最简单的测试用例是用户没有经过身份验证。然后是一个测试用例，其中用户通过了身份验证，但是具有错误的用户角色。那么用户被认证的测试用例具有正确的用户角色，但是输入无效，等等。

您可以慢慢地构建代码的内部，直到实现完全覆盖。

## 渐进式重构

就在最近，我将一些功能从前端转移到 API。在这个过程中，我很想修改一些代码。为了不迷路，我的同事给了我最好的建议:在较小的提交中进行增量重构。

重构不应该改变代码的行为。它应该只是改变了设计。如果您想更改其他内容，请稍后在单独的拉请求中进行更改。

增量重构的另一个实用建议是逐渐弃用。

想象一下，你重命名一个函数或者改变它的签名，所有现有的测试开始失败。你可以做的是用旧名字创建一个函数，然后*调用新函数*。这样，测试就不会失败，并且您可以逐步更新它们。

## 去掉洋葱

在元素周期表中，普里莫·莱维讲了一个你[可能很熟悉](http://www.paulgraham.com/arcll1.html)的轶事:

> “他是一名化学家，他对清漆配方中包含生洋葱这一事实非常感兴趣。会是为了什么？没有人知道；这只是食谱的一部分。所以他进行了调查，最终发现他们在几年前就开始扔洋葱来测试清漆的温度:如果温度足够高，洋葱就会被烤焦。

当重构遗留代码时，你无疑会碰到一些洋葱。它们是一些条件和假设，但是没有人记得它们为什么在这里。

您可能很想马上删除它们，但是首先调查并理解最初添加它们的原因和时间是很重要的。幸运的是，有了 GitHub 和其他源代码控制系统，您可以很容易地找到它。

# 进一步阅读

*   [代码气味](https://blog.codinghorror.com/code-smells/)
*   [规划谬误](https://en.wikipedia.org/wiki/Planning_fallacy)
*   [你不会需要它的](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)
*   [管理债务|变得真实](https://basecamp.com/gettingreal/10.4-manage-debt)
*   [永远不要做的事情，第一部分](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/)
*   [遗留应用扼杀:案例研究](https://paulhammant.com/2013/07/14/legacy-application-strangulation-case-studies/)
*   [第 3 周的弧度](http://www.paulgraham.com/arcll1.html)
*   [重写:为什么 Basecamp 3 是一个全新的代码库。](https://signalvnoise.com/posts/3959-rewrite-why-basecamp-3-is-a-brand-new-code)