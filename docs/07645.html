<html>
<head>
<title>Bored of Imperative For Loops? Use Functional Operators Instead.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">厌倦了循环命令？请改用函数运算符。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bored-of-imperative-for-loops-use-functional-operators-instead-8eff6f87d9f2?source=collection_archive---------7-----------------------#2021-02-04">https://betterprogramming.pub/bored-of-imperative-for-loops-use-functional-operators-instead-8eff6f87d9f2?source=collection_archive---------7-----------------------#2021-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用声明性范例来编写更好的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0f17aaa31274a485e2459d77d600656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xt9o0aY8wx0-WuTc"/></div></div></figure><p id="8788" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当人们想到函数式编程时，会想到两件事。第一种通常是纯函数的概念；第二个是不变性。虽然这两个都是正确的，但是用函数式编程来思考的关键是用声明的方式来思考。</p><p id="7d14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于程序的一种声明性的思考方式是在不描述控制流的情况下表达一个计算逻辑。人类通常也是这样说话的。</p><p id="ab6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我举个例子:当你渴了想喝水的时候，你不会告诉别人:“我想装满一杯水，然后扔进嘴里。”你告诉他们:“我要<em class="lq">喝</em>水。”你实际上是在向其他人宣布你的意图是什么，而不是你希望如何达到你的目的。<em class="lq">什么</em>是说明性的。</p><p id="ae75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，当你考虑<em class="lq">如何完成计算逻辑时，必须考虑<em class="lq"/>。您的重点是应用程序的状态——您有一个计算机要执行的命令列表。</em></p><p id="6672" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，我们在看食谱的时候会经常看到这种情况。他们不会告诉你的意图是什么，而是告诉你你想如何实现这个意图。命令式编程关注的是程序应该如何运行。</p><p id="de30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就编写程序而言，有各种各样的方法。编写程序的声明式方式更倾向于递归。相反，编写程序的命令形式通常需要循环。例如，为了得到一个列表的总和，你将有一个<code class="fe lr ls lt lu b">for</code>循环并将数组中的每一项添加到一个变量中。这样做的声明形式将通过循环每个元素的递归方式，并且在每个组件上，我们想要添加彼此。</p><p id="ab79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我们大多数人通常是以命令性方式开始编写代码，但我想展示另一种方式，让您的代码更具声明性，从而使您的代码更具描述性。</p><p id="36f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文不会讨论范式的优缺点，而是让您了解如何进行声明式编程。这是我在进入函数式编程时经常使用的四个函数式操作，你可以在你的工具箱中使用它们来声明性地编写程序。我不会谈论<code class="fe lr ls lt lu b">map</code>和<code class="fe lr ls lt lu b">filter</code>，因为它们已经在其他函数式语言中被广泛使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2442" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">折叠</h1><p id="2c5c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">fold</code>以一种格式获取数据，然后以另一种格式返回给您。任何数据处理器都可以将所有这些程序中的大量操作浓缩到<code class="fe lr ls lt lu b">fold</code>中。例如，反转一个列表:必要的方法是做一个双指针和一个<code class="fe lr ls lt lu b">for a</code>循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7d7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">声明方式将使用<code class="fe lr ls lt lu b">foldLeft</code>，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">fold</code>有两个参数:初始值和一个函数。这个函数还接受两个参数:累积值和列表中的当前项。因此，您可以通过指定您想要将<code class="fe lr ls lt lu b">curr</code>附加到<code class="fe lr ls lt lu b">acc</code>的剩余部分来描述您想要在每个迭代中做什么——这颠倒了现有的列表。</p><p id="72a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想在列表中间停下来。我们怎样才能代表一个<code class="fe lr ls lt lu b">while</code>循环呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b17c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拿了又丢</h1><p id="9845" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">take</code>和<code class="fe lr ls lt lu b">drop</code>操作是您期望它做的。如果有一个元素列表，而你想取前两个，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，如果你想去掉前两个，取其余的，你可以用<code class="fe lr ls lt lu b">drop</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有递归，Scala中的某些算法操作可能很难实现。例如，如果你想根据某个索引将一个列表分成两部分，一种方法是使用递归或者一个<code class="fe lr ls lt lu b">for a</code>循环。像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以通过<code class="fe lr ls lt lu b">take</code>和<code class="fe lr ls lt lu b">drop</code>获取<code class="fe lr ls lt lu b">index</code>值和<code class="fe lr ls lt lu b">drop</code>索引值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">活力</h1><p id="2487" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">zip</code>函数用于将两个连续集合合并成对。当您希望将两个单独的集合组合成一对时，此操作非常有用，尤其是在流环境中，当您希望将两个流结合在一起或使两个流同时运行时。</p><p id="a67d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想做一个无限斐波那契数列的流，你可以用一个<code class="fe lr ls lt lu b">zip</code>函数调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="81bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Fibonacci流压缩两个流——一个包含列表头，另一个不包含列表头。在这种情况下，<code class="fe lr ls lt lu b">fibs</code>将从<code class="fe lr ls lt lu b">[0,1,1,...]</code>开始，<code class="fe lr ls lt lu b">fibs.tail</code>将从<code class="fe lr ls lt lu b">[1,1,2,....]</code>开始。我们将这两个流组合在一起— <code class="fe lr ls lt lu b">[(0,1), (1,1), (1,2), ...]</code> —并将它们加在一起。结果将是一个斐波纳契数列的列表。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="169d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">展开</h1><p id="a3d0" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lr ls lt lu b">unfold</code>是<code class="fe lr ls lt lu b">fold</code>的反义词。它不是递归地将序列压缩为单个值，而是通过采用初始状态并构建以下条件和序列中要生成的下一个值来反转逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d259" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">乍一看，方法签名可能会让你质疑展开怎么可能有用。然而，<code class="fe lr ls lt lu b">unfold</code>是一个非常普通的流构建函数。展开背后的概念是<a class="ae nb" href="https://levelup.gitconnected.com/wtf-is-corecursion-7d3ba8818b48" rel="noopener ugc nofollow" target="_blank">共变</a>，它让你从基础案例开始，慢慢建立下一个价值。我们可以尝试使用<code class="fe lr ls lt lu b">zip</code>示例中的斐波那契数列来构建<code class="fe lr ls lt lu b">unfold</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e460" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的函数接受初始状态，一个<code class="fe lr ls lt lu b">zero</code>和<code class="fe lr ls lt lu b">one</code>的元组，并执行进程来展开序列。在每次迭代中，返回的类型为<code class="fe lr ls lt lu b">Option[(A,S)]</code>的元组意味着:</p><ol class=""><li id="2fa0" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">第一个元素<code class="fe lr ls lt lu b">A</code>是要添加到结果序列中的值——在本例中，它是<code class="fe lr ls lt lu b">zero</code>。</li><li id="a2db" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">第二个元素<code class="fe lr ls lt lu b">S</code>是下一个<em class="lq">状态</em>值——在本例中，<code class="fe lr ls lt lu b">S</code>是另一个元组(<code class="fe lr ls lt lu b">one</code>，<code class="fe lr ls lt lu b">zero+one</code>)</li><li id="12ee" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">返回<code class="fe lr ls lt lu b">Some</code>表示该函数生成了新元素。<code class="fe lr ls lt lu b">None</code>表示序列生成操作结束</li></ol><p id="635e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你能把这些函数操作添加到你的工具带上，这样你就能以一种更加声明性的方式编写程序。</p><p id="d2c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只是触及了可用功能的皮毛。其他积极的行动有助于描述你的计划的意图。</p><p id="a6b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，<code class="fe lr ls lt lu b">FlatMap</code>是映射和展平嵌套序列的组合。<code class="fe lr ls lt lu b">dropWhile</code>和<code class="fe lr ls lt lu b">takeWhile</code>都是<code class="fe lr ls lt lu b">taking</code>和<code class="fe lr ls lt lu b">drop</code>之上的功能操作，包括附加谓词。<code class="fe lr ls lt lu b">zipWithIndex</code>将压缩带有索引的序列作为元组。这些操作更强大，并且以更通用的方式构建。</p><p id="a888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种范式都有优点和缺点，并且各有其用例。使用这些函数操作有助于使程序的意图更加可组合。他们让你陈述你想用你的程序做什么。另一方面，使用命令式方式编写程序有助于使程序更加模块化——它提高了程序的可维护性。</p><p id="bb7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然您已经知道了这种编写程序的函数技术，那么就停止使用常规递归，使用这些声明性函数操作来提高代码的可读性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="43cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">最初发表于</em><a class="ae nb" href="https://edward-huang.com/scala/programming/2021/02/02/stop-using-pattern-matching-to-compose-your-program-use-these-functional-operation-instead/" rel="noopener ugc nofollow" target="_blank"><em class="lq">【https://edward-huang.com】</em></a><em class="lq">。</em></p></div></div>    
</body>
</html>