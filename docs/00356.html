<html>
<head>
<title>Better Swift Codable Models Through Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过合成更好的Swift可编码模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-swift-codable-models-through-composition-a6b109b7e8c7?source=collection_archive---------5-----------------------#2019-05-01">https://betterprogramming.pub/better-swift-codable-models-through-composition-a6b109b7e8c7?source=collection_archive---------5-----------------------#2019-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8e8821dd8dbac830e2cb24998da9fa98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKhyjPvMEmTEAaXLTgL52A.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Iker Urteaga 通过Unsplash拍摄的照片</p></figure><p id="ce3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下，我们想要建立一个应用程序来跟踪书籍。我们正在构建的API为作者和书籍提供了JSON，如下所示:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="e872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Swift的<code class="fe lk ll lm ln b">Codable</code>功能使我们能够快速创建匹配的模型:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="ceee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多亏了<code class="fe lk ll lm ln b">Codable</code>,这就是我们免费获得到类型安全模型的JSON映射所要做的一切！</p><p id="8539" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，随着我们的进展，有几个微妙的问题可能会导致问题。<code class="fe lk ll lm ln b">identifier</code> s被定义为<code class="fe lk ll lm ln b">String</code> s。这并没有<em class="lo">错</em>，但是它可能会导致这样一个场景:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3d23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将会编译，尽管调用点<em class="lo">看起来</em>正确，但它永远不会返回任何东西，因为函数需要的是作者的标识符，而不是他们的名字。让我们看一个类型，我们可以用它来代替<code class="fe lk ll lm ln b">String</code>来提高这里的类型安全性。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="ebf0" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">标识符<t/></h1><p id="cd81" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们不能改变服务器向我们发送<code class="fe lk ll lm ln b">String</code>的事实，但是我们可以使用包装器和幻影类型来改变这些字符串在本地的表示方式。</p><p id="19b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常当我们定义一个类似于<code class="fe lk ll lm ln b">Identifier&lt;T&gt;</code>的泛型类型时，我们也会在类型的其他地方使用那个<code class="fe lk ll lm ln b">T</code>，类似于<code class="fe lk ll lm ln b">let value: T</code>。然而，当<code class="fe lk ll lm ln b">T</code>仅作为声明的一部分出现时，它被称为<em class="lo">幻象类型</em>。</p><p id="2dee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那还有什么意义呢？如果我们不使用类型，为什么要让一些东西通用呢？嗯，我们实际上<em class="lo">在</em>使用类型，只是不是以通常的方式。让我们来看看:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="70a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新我们的模型以使用这种新类型，它们变成:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3b35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的功能现在变成了:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="db9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在已经不可能错误地通过一个<code class="fe lk ll lm ln b">String</code>。我们<em class="lo">必须</em>提供一个<code class="fe lk ll lm ln b">Identifier&lt;Author&gt;</code>来代替；否则，即使它们都在下面，它也不会编译。</p><p id="271e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是幻影类型如此有用的原因。在这种情况下，我们使用通用占位符将类型安全添加到普通的<code class="fe lk ll lm ln b">String</code>中。我们现在不仅可以将<code class="fe lk ll lm ln b">Identifier&lt;T&gt;</code>用于我们的<code class="fe lk ll lm ln b">Book</code>和<code class="fe lk ll lm ln b">Author</code>模型，还可以用于任何其他带有标识符的模型。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="f720" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">可编码支持</h1><p id="9544" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们在<code class="fe lk ll lm ln b">Identifier&lt;T&gt;</code>中引入了一个新问题。默认情况下，<code class="fe lk ll lm ln b">Codable</code>使用与类型相同的结构。这意味着标识符的JSON表示应该是:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9b64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是错误的:我们仍然希望JSON表示是一个<code class="fe lk ll lm ln b">String</code>,这样它就可以与我们的API无缝协作。让我们按如下方式修复<code class="fe lk ll lm ln b">Codable</code>行为:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="b6d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们在模型和JSON之间转换时，它将是一个常规的<code class="fe lk ll lm ln b">String</code>，而不是一个嵌套的对象。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="eb86" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">向API添加新数据</h1><p id="a1a7" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">列出书籍和作者非常有效。现在是时候允许我们的用户提交新的条目了。唯一的问题是我们的API负责确定新数据的标识符，所以我们想发送包含所有内容的JSON，除了对象标识符。</p><p id="6131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种不同的方法可以解决这个问题:</p><ul class=""><li id="c04e" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">我们可以保持一个独立的模型，不包括<code class="fe lk ll lm ln b">Identifier</code>。这将是乏味和脆弱的，但也许我们可以利用一个codegen解决方案来帮助？如果你还没有使用它，这是一个很大的依赖项。</li><li id="e4cd" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">我们可以提供一个伪标识符，并在将它发送给我们的API之前将其从JSON中移除。不过，这不是一个很好的解决方案——在产品代码中使用虚拟值似乎只是在乞求破坏和/或损坏东西。</li></ul><p id="d344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们今天正在创建新的类型，那么让我们来看看另一个可以用来解决这个问题的类型。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="e59b" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">已识别<t/></h1><p id="e74b" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们需要一种方法来定义我们的模型的两个版本:一个在数据向下发送时带有<code class="fe lk ll lm ln b">Identifier</code>,另一个在数据向上发送时没有<code class="fe lk ll lm ln b">Identifier</code>。</p><p id="4fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能使用类型系统来删除属性……但是我们可以用它来为T21添加属性。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="eb36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这个类型，我们可以从我们的模型中删除<code class="fe lk ll lm ln b">identifier</code>属性:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="fc38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以定义我们需要的模型的两个版本。当我们从API接收书籍时，我们可以对每个实例使用<code class="fe lk ll lm ln b">Identified&lt;Book&gt;</code>。当我们想添加一本新书时，我们可以简单地使用<code class="fe lk ll lm ln b">Book</code>。</p><p id="340a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有像<code class="fe lk ll lm ln b">Identified&lt;T&gt;</code>这样的类型给了我们想要的灵活性，而不需要维护并行模型或者在发送数据之前去掉不需要的值。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="4645" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">可编码支持</h1><p id="8135" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">与<code class="fe lk ll lm ln b">Identifier&lt;T&gt;</code>一样，<code class="fe lk ll lm ln b">Identified&lt;T&gt;</code>的默认<code class="fe lk ll lm ln b">Codable</code>行为会导致错误的JSON:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要修复<code class="fe lk ll lm ln b">Codable</code>的行为，以便所有东西在JSON形式下仍然是扁平的:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="0b7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lk ll lm ln b">AnyCodingKey</code>类型用于允许我们动态解码数据的某些部分，而不需要所有新的类型:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="8de1" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="0d6d" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">有很多方法可以给猫换肤，但是希望本文展示了一些有趣的方法，使用包装器类型和一些漂亮的Swift特性来解决一些常见问题。</p><p id="d663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有很多可以改进这些类型的人体工程学的附加功能，例如:</p><ul class=""><li id="a83d" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe lk ll lm ln b">ExpressibleBy*</code>一致性</li><li id="63f5" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe lk ll lm ln b">String</code>以外的支持价值观</li></ul><p id="5d16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我将把这些留给读者作为练习。🤘</p><p id="92ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里获取游乐场就绪代码<a class="ae kf" href="https://gist.github.com/IanKeen/788e2ce55e5c91257bc639efc5dbb1c1" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9b3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有任何反馈，请在这个帖子上留言或回复。</p></div></div>    
</body>
</html>