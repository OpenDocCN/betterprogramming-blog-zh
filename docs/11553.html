<html>
<head>
<title>Exploring JSON, JSON5, and Circular References</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索JSON、JSON5和循环引用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-json-json5-and-circular-references-2b5b0c5de532?source=collection_archive---------2-----------------------#2022-03-30">https://betterprogramming.pub/exploring-json-json5-and-circular-references-2b5b0c5de532?source=collection_archive---------2-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript对象符号(JSON)的深度指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33eaf9c8770e13b0ee4280627d6f7e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XG1eUfAmoS1Z0yBn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@er1end?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erlend Ekseth </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="db93" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">反对字符串问题</h1><p id="d05a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在JavaScript和TypeScript中，对象是属性的集合。例如:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2ed0" class="ms la it mo b gy mt mu l mv mw">const value = {a: 1, b: 2};</span></pre><p id="135e" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">可以记录该值:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="14f4" class="ms la it mo b gy mt mu l mv mw">console.log(value); // <!-- -->{a: 1, b: 2}</span></pre><p id="b98b" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">写封短信怎么样？</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4369" class="ms la it mo b gy mt mu l mv mw">console.log(`My value is ${value}`); // <!-- -->My value is [object Object]</span></pre><p id="a12c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">行动。</p><p id="14f7" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">什么是<code class="fe nc nd ne mo b">[object Object]</code>？它是对象的<code class="fe nc nd ne mo b">toString()</code>值。</p><p id="1232" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">console.log</code>可以通过提供对象作为独立参数来修复消息。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b192" class="ms la it mo b gy mt mu l mv mw">console.log('My value is', value); // <!-- -->My value is {a: 1, b: 2}</span></pre><p id="3130" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然而，还有其他使用<code class="fe nc nd ne mo b">toString()</code>序列化对象的情况。例如，JSX元素:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="10f7" class="ms la it mo b gy mt mu l mv mw">&lt;div&gt;{value}&lt;/div&gt;</span></pre><p id="40ab" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">在许多情况下，<code class="fe nc nd ne mo b">JSON.stringify()</code>是救命恩人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d842" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们将仔细研究JavaScript对象符号(JSON)。</p><h1 id="75f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">JSON是什么？</h1><p id="aecb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JSON(JavaScript对象符号)是一种轻量级的数据交换格式。人类很容易读写，机器也很容易解析生成。它基于JavaScript编程语言标准ECMA-262第三版(1999年12月)的子集。</p><p id="dc5f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">JSON是由道格拉斯·克洛克福特在2001年3月首先规定的。它是序列化对象、数组、数字、字符串、布尔值和<code class="fe nc nd ne mo b">null</code>的语法。它于2013年10月成为ECMA国际标准。</p><p id="d657" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">JSON有两个主要功能:</p><ul class=""><li id="d74c" class="nh ni it lt b lu mx lx my ma nj me nk mi nl mm nm nn no np bi translated">它是在客户端和服务器之间传输的数据格式。</li><li id="f9e7" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">它用于定义配置。</li></ul><p id="eec4" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">JSON语法简单，对数据类型的支持有限，包括<code class="fe nc nd ne mo b">object</code>、<code class="fe nc nd ne mo b">array</code>、<code class="fe nc nd ne mo b">number</code>、<code class="fe nc nd ne mo b">string</code>、<code class="fe nc nd ne mo b">boolean</code>和<code class="fe nc nd ne mo b">null</code>。但是，函数、<code class="fe nc nd ne mo b">NaN</code>、<code class="fe nc nd ne mo b">Infinity</code>、<code class="fe nc nd ne mo b">undefined</code>和<code class="fe nc nd ne mo b">Symbol</code>不是有效的JSON值。JSON没有名称空间、注释或属性支持。它可能不支持复杂的配置。这些限制使JSON变得简单，因此它可以快速传输和解析。</p><p id="b610" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">JSON有两个静态方法，<code class="fe nc nd ne mo b">JSON.parse()</code>和<code class="fe nc nd ne mo b">JSON.stringify()</code>。</p><h2 id="59da" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">JSON.parse()</h2><p id="39d2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nc nd ne mo b">JSON.parse(text)</code>解析一个JSON字符串来构造一个JavaScript值或对象。对于对象，JSON的属性名必须是双引号字符串，并且禁止尾随逗号。对于原始类型，<code class="fe nc nd ne mo b">JSON.parse()</code>返回原始值。对于数字，禁止前导零，小数点后必须至少有一位数字。任何违反JSON语法的行为都会抛出<code class="fe nc nd ne mo b">SyntaxError</code>。</p><p id="c763" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">下面是关于<code class="fe nc nd ne mo b">JSON.parse()</code>如何构造JavaScript值或对象的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1fce" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">JSON.parse(text[, reviver])</code>有一个可选的<code class="fe nc nd ne mo b">reviver</code>，可以改变返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7745" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">reviver</code>(第2-12行)被调用3次。</p><ul class=""><li id="beaf" class="nh ni it lt b lu mx lx my ma nj me nk mi nl mm nm nn no np bi translated">第一次是键<code class="fe nc nd ne mo b">a</code>，在第4行，值(<code class="fe nc nd ne mo b">1</code>)减少到<code class="fe nc nd ne mo b">0</code>。</li><li id="bc71" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">第二次是键，<code class="fe nc nd ne mo b">b</code>，在第8行，值(<code class="fe nc nd ne mo b">2</code>)增加到<code class="fe nc nd ne mo b">3</code>。</li><li id="60af" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">第三次为key，<code class="fe nc nd ne mo b">""</code>，值为当前对象(<code class="fe nc nd ne mo b">{"a":0,"b":3}</code>)。在第11行，返回值被转换成一个字符串，<code class="fe nc nd ne mo b">key is "", and value is {"a":0,"b":3}</code>。</li></ul><p id="65bd" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第15行日志<code class="fe nc nd ne mo b">key is "", and value is {"a":0,"b":3}</code>。</p><h2 id="39bd" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">JSON.stringify()</h2><p id="2fb4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nc nd ne mo b">JSON.stringify(value)</code>返回指定<code class="fe nc nd ne mo b">value</code>对应的JSON字符串。<code class="fe nc nd ne mo b">boolean</code>、<code class="fe nc nd ne mo b">number</code>和<code class="fe nc nd ne mo b">string</code>被转换成相应的原始值。函数、<code class="fe nc nd ne mo b">undefined</code>和<code class="fe nc nd ne mo b">Symbol</code>不是有效的JSON值，在对象中被省略，或者在数组中被改为<code class="fe nc nd ne mo b">null</code>。<code class="fe nc nd ne mo b">NaN</code>、<code class="fe nc nd ne mo b">Infinity</code>、<code class="fe nc nd ne mo b">null</code>改为<code class="fe nc nd ne mo b">null</code>。如果值有一个<code class="fe nc nd ne mo b">toJSON()</code>方法，数据序列化调用这个方法。<code class="fe nc nd ne mo b">Date</code>通过返回字符串<code class="fe nc nd ne mo b">date.toISOString()</code>实现<code class="fe nc nd ne mo b">toJSON()</code>功能。JSON不能序列化<code class="fe nc nd ne mo b">BigInt</code>值或不可枚举的属性。</p><p id="f7de" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">下面是关于<code class="fe nc nd ne mo b">JSON.stringify()</code>如何组成JSON字符串的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="abe6" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">JSON.stringify(value[, replacer])</code>有一个可选的<code class="fe nc nd ne mo b">replacer</code>，可以改变返回值。</p><p id="acab" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们写一个<code class="fe nc nd ne mo b">replacer</code>，类似于<code class="fe nc nd ne mo b">JSON.parse()</code>中的<code class="fe nc nd ne mo b">reviver</code>。猜猜会记录什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d9ca" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第2–12行定义了<code class="fe nc nd ne mo b">replacer</code>，它输出<code class="fe nc nd ne mo b">"key is \"\", and value is {\"a\":1,\"b\":2}"</code>。</p><p id="23e2" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">A <code class="fe nc nd ne mo b">replacer</code>与a <code class="fe nc nd ne mo b">reviver</code>相对。第一次调用有键<code class="fe nc nd ne mo b">""</code>和值<code class="fe nc nd ne mo b">{"a":0,"b":3}</code>。在第11行，它返回一个字符串值，<code class="fe nc nd ne mo b">"key is \"\", and value is {\"a\":1,\"b\":2}"</code>。因为它是一个没有下一次迭代属性的字符串，所以<code class="fe nc nd ne mo b">replacer</code>退出。第15行日志<code class="fe nc nd ne mo b">"key is \"\", and value is {\"a\":1,\"b\":2}"</code>。</p><p id="d13d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">如果我们将第11行改为<code class="fe nc nd ne mo b">return {a: 5};</code>，那么下一次调用将是对属性<code class="fe nc nd ne mo b">a</code>的调用。由于没有其他属性，<code class="fe nc nd ne mo b">replacer</code>退出。第15行日志<code class="fe nc nd ne mo b">{"a":4}</code>。</p><p id="2304" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">如果我们把11号线改成<code class="fe nc nd ne mo b">return {c: 5};</code>呢？然后，下一次调用将在属性上进行，<code class="fe nc nd ne mo b">c</code>。再次循环属性<code class="fe nc nd ne mo b">c</code>，返回<code class="fe nc nd ne mo b">{c: 5}</code>。变成一个无限循环，抛出一个错误:<code class="fe nc nd ne mo b">Uncaught RangeError: Maximum call stack size exceeded</code>。</p><p id="4b4a" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们应该非常小心地写一个<code class="fe nc nd ne mo b">replacer</code>。对空键的第一次调用应该只是返回原始值。下面是典型的<code class="fe nc nd ne mo b">JSON.stringify</code>带<code class="fe nc nd ne mo b">replacer</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3f4d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第13行日志<code class="fe nc nd ne mo b">{"a":0,"b":3}</code>。</p><p id="ea6f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">JSON.stringify(value[, replacer[, space]])</code>有第二个可选参数<code class="fe nc nd ne mo b">space</code>，这是一个<code class="fe nc nd ne mo b">string</code>或<code class="fe nc nd ne mo b">number</code>，它在输出的JSON字符串中插入空格以提高可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0bf9" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">\n</code>是换行符，<code class="fe nc nd ne mo b">\n</code>是制表符。<code class="fe nc nd ne mo b">'{\n "a": 1\n}'</code>指以下结构:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4ab4" class="ms la it mo b gy mt mu l mv mw">{<br/>  "a": 1<br/>}</span></pre></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="4a60" class="kz la it bd lb lc on le lf lg oo li lj jz op ka ll kc oq kd ln kf or kg lp lq bi translated">JSON5是什么？</h1><p id="2fd2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JSON很酷，JSON5更酷！</p><p id="2ed7" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><a class="ae ky" href="https://json5.org/" rel="noopener ugc nofollow" target="_blank">JSON 5数据交换格式</a> (JSON5)是JSON的超集，旨在通过扩展其语法来包括来自<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 5.1 </a>的一些产品，从而减轻JSON的一些限制。</p><h2 id="b0a7" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">目标</h2><ul class=""><li id="066e" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">对象键可以是ECMAScript 5.1标识符名称。</li><li id="dee9" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">对象可以有一个逗号结尾。</li></ul><h2 id="eb6a" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">数组</h2><ul class=""><li id="c07d" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">数组可以有一个逗号结尾。</li></ul><h2 id="5e45" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">用线串</h2><ul class=""><li id="3c8f" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">字符串可以用单引号括起来。</li><li id="e20d" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">通过转义新的行字符，字符串可以跨越多行。</li><li id="b04c" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">字符串可能包含字符转义。</li></ul><h2 id="e48f" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">数字</h2><ul class=""><li id="8b5f" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">数字可以是十六进制的。</li><li id="692b" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">数字可能有一个前导或尾随小数点。</li><li id="48ad" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">数字可以是<code class="fe nc nd ne mo b">Infinity</code>、<code class="fe nc nd ne mo b">-Infinity</code>、<code class="fe nc nd ne mo b">NaN</code>。</li><li id="e0f8" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">数字可以以一个明确的加号开始。</li></ul><h2 id="5821" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">评论</h2><ul class=""><li id="a7cc" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">允许单行和多行注释。</li></ul><h2 id="1b1b" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">空格</h2><ul class=""><li id="7b64" class="nh ni it lt b lu lv lx ly ma os me ot mi ou mm nm nn no np bi translated">允许额外的空白字符。</li></ul><p id="aaee" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">JSON5的静态API<code class="fe nc nd ne mo b">parse</code>和<code class="fe nc nd ne mo b">stringify</code>与JSON的相同。</p><p id="fbd0" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">为了使用JSON5，我们需要安装包<code class="fe nc nd ne mo b"><a class="ae ky" href="https://github.com/json5/json5" rel="noopener ugc nofollow" target="_blank">json5</a></code>，它有5000万的周下载量。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0f2a" class="ms la it mo b gy mt mu l mv mw">npm i json5</span></pre><p id="7a50" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">json5</code>成为<code class="fe nc nd ne mo b">package.json</code>中<code class="fe nc nd ne mo b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>的一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4256" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然后，我们可以从<code class="fe nc nd ne mo b">json5</code>导入<code class="fe nc nd ne mo b">parse</code>和<code class="fe nc nd ne mo b">stringify</code>。我们有些失败的案例是用JSON5的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="5029" class="kz la it bd lb lc on le lf lg oo li lj jz op ka ll kc oq kd ln kf or kg lp lq bi translated">如何转换圆形结构</h1><p id="2cd7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JSON/JSON5比简单的<code class="fe nc nd ne mo b">toString()</code>更强大。<code class="fe nc nd ne mo b">JSON.stringify()</code>解决了<code class="fe nc nd ne mo b">[object Object]</code>的对象序列化问题。原来的问题解决了。</p><p id="6fe3" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然而，我们又遇到了一个新问题。</p><p id="b4f5" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">你遇到过错误:<code class="fe nc nd ne mo b">Uncaught TypeError: Converting circular structure to JSON</code>？</p><p id="372f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">作为一名JavaScript/TypeScript开发人员，您可能已经多次遇到过这个错误。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="365e" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">创建循环引用是糟糕的编码。但是，如果糟糕的JSON结构来自后端或第三方包，我们可能别无选择。</p><p id="dc17" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们如何处理循环引用？</p><p id="675c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">有几种方法可以解决这个问题:</p><ul class=""><li id="52b8" class="nh ni it lt b lu mx lx my ma nj me nk mi nl mm nm nn no np bi translated"><code class="fe nc nd ne mo b">JSON.stringify</code>的<code class="fe nc nd ne mo b">replacer</code></li><li id="d284" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">第三方软件包</li></ul><h2 id="6b7a" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated"><code class="fe nc nd ne mo b">JSON.stringify’s replacer</code></h2><p id="b5c3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">循环引用的话，JSON或者JSON5 <code class="fe nc nd ne mo b">stringify</code>的<code class="fe nc nd ne mo b">replacer</code>可以做拯救者。这里是MDN网站上的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8d3b" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第3–14行定义了一个函数<code class="fe nc nd ne mo b">getCircularReplacer</code>。它返回一个创建<code class="fe nc nd ne mo b">seen</code>闭包的函数，这个闭包是一个在集合中存储弱持有对象的<code class="fe nc nd ne mo b">WeakSet</code>。对于每个键，它验证该值是否已经在<code class="fe nc nd ne mo b">seen</code>中(第7行)。如果是，这是一个循环引用，则忽略键/值对(第8行)。否则，将该值添加到<code class="fe nc nd ne mo b">seen</code>(第10行)并返回(第12行)。</p><p id="31ed" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第15行调用<code class="fe nc nd ne mo b">getCircularReplacer</code>返回<code class="fe nc nd ne mo b">replacer</code>函数，<code class="fe nc nd ne mo b">JSON.stringify()</code>输出<code class="fe nc nd ne mo b">{"a":1,"b":2}</code>，去掉循环属性。</p><h2 id="4211" class="ms la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">第三方软件包</h2><p id="179b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有许多第三方软件包可以解决循环引用问题。<code class="fe nc nd ne mo b"><a class="ae ky" href="https://github.com/moll/json-stringify-safe" rel="noopener ugc nofollow" target="_blank">json-stringify-safe</a></code>是一个受欢迎的，有1700万周下载量。这是一个类似于<code class="fe nc nd ne mo b">JSON.stringify</code>的包，但是不抛出循环引用。可以使用以下命令进行设置:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="579b" class="ms la it mo b gy mt mu l mv mw">npm i json-stringify-safe</span></pre><p id="e9ca" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">json-stringify-safe</code>成为<code class="fe nc nd ne mo b">package.json</code>中<code class="fe nc nd ne mo b">dependencies</code>的一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="45a3" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">这个包有一个方法，<code class="fe nc nd ne mo b">stringify</code>。该方法有四个参数，<code class="fe nc nd ne mo b">stringify(obj, serializer, indent, decycler)</code>。前三个参数与<code class="fe nc nd ne mo b">JSON.stringify</code>相同。默认情况下，<code class="fe nc nd ne mo b">stringify</code>将循环引用显示为一个字符串，<code class="fe nc nd ne mo b">'[Circular]'</code>。<code class="fe nc nd ne mo b">decycler</code>可以自定义显示方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="23a5" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第5行显示了带有循环引用的JSON结构的默认<code class="fe nc nd ne mo b">stringify</code>结果。</p><p id="612c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">第6行定制结果以删除循环引用的属性。</p><p id="5e82" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">下面是<a class="ae ky" href="https://github.com/moll/json-stringify-safe/blob/master/stringify.js" rel="noopener ugc nofollow" target="_blank"/>关于<code class="fe nc nd ne mo b">json-stringify-safe</code>如何定义<code class="fe nc nd ne mo b">stringify</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="7170" class="kz la it bd lb lc on le lf lg oo li lj jz op ka ll kc oq kd ln kf or kg lp lq bi translated">结论</h1><p id="65ea" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JSON是一种轻量级的数据交换格式。它比对象的<code class="fe nc nd ne mo b">toString()</code>更优雅地处理对象序列化。</p><p id="a4d3" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们已经详细研究了JSON和JSON5的工作原理，并提供了多种方法来解决循环引用问题。</p><p id="5064" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>