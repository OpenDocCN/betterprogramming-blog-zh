# 函数式编程:什么是函子？

> 原文：<https://betterprogramming.pub/functional-programming-whats-a-functor-4f5f10a20509>

## 不需要以前的 Haskell 知识

![](img/761b134ce83173c128115f7042da05b0.png)

照片由[克雷格·加纳](https://unsplash.com/@craiggarner?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在我们生产产品的时候，仿函数就已经伴随我们很久了。他们就像空气一样。它们是 JavaScript 的一个非常重要的特性，但是你并不知道它是否存在，或者不容易意识到它有多重要，尽管你知道它的存在。

# 阅读前

如果你已经知道 Haskell 或者其他有类型的编程语言，这篇文章对你来说不会太难。不过不用担心，不用从头学 Haskell。请记住，这篇文章提到的任何类型都是抽象概念。

此外，如果您知道什么是 TypeScript 会更好，因为这个概念在 TypeScript 中广泛使用——尤其是在 monads 家族中。

# 什么是类型？

JavaScript 生来就没有类型。这种语言被称为动态类型语言或动态编程语言，因为变量的类型是在运行时确定的。

```
var name = 'foo';
name = 1;
```

在这个例子中，`name`的类型将是一个数字，而不是一个字符串。

虽然`name`被划入了`foo`，但是`1`后来被划入了`name`。JavaScript 允许开发人员自由地改变变量值，并且它在运行时评估变量的类型。

从 ES6 开始，新的变量关键词`const`出来了。一旦用`const`声明了变量，就不能更改值。然而，当没有`const`时，JavaScript 仍然和以前一样执行。

另外，你还可以用这种方式欺骗 JavaScript。

```
const numbers = [1, 2, 3];
numbers.push('4');
```

即使`numbers`是用`const`声明的，您也可以将一个字符串值推入其中，因为 JavaScript 对`numbers`的限制是存储在`numbers`的内存空间中的内容，它是一个数组，而不是每个索引的值。

换句话说，这意味着 JavaScript 不关心什么值存储在`numbers`中，只要`numbers`是一个数组。

随着时间的推移，一种新的编程语言出现了，TypeScript。TypeScript 允许您使用许多有用的类型来开发和维护应用程序。

JavaScript 和 TypeScript 的一个很大的区别是，TypeScript 从不关心运行时处理。它总是在编译时告诉你一些东西。

所以是的，它实际上没有解决运行时的动态类型问题。然而，现在您可以获得一种更安全的方法来声明和维护变量。

```
let name: string = 'John';name = 1;
~~~~~~~~~
// Cannot assign to 'yourName' because it is a constant.
```

TypeScript 帮助您避免错误的类型转换。这在运行时仍然很好，但在编译时是错误的，编译时是 TypeScript 工作的时期。

好的，现在让我们考虑一下表达函数类型的方法。在 JavaScript 中，任何函数都可以接受任何输入值，并可以返回任何值作为输出。

默认情况下，如果没有返回值，函数将返回`undefined`。然后，我可以把函数的类型写成如下。

```
type Function = (...args: any[]) => any
```

然后，让我们假设有一个函数接受`a`，它是一个`A`类型，返回`b`，它是一个`B`类型。

```
type Function = (a: A) => B
```

在这篇文章中，我将用一种稍微不同的方式来表达。函数`f`代表 it 的类型，它接受`a`类型值并返回`b`类型值。

```
f => (a -> b)
// fat arrow (=>) means (=)
```

# 仿函数——想象比萨饼盒子

让我们试着用一个更现实的例子来接近这个无聊的概念。

一天，在一个饥饿的夜晚，你想吃比萨饼。你开车去了一家披萨店，点了一份意大利香肠披萨。30 分钟后，你就能拿到你点的东西。

哎呀，你意识到你要在上面点额外的配料。你问工人:“对不起，我能在这上面加额外的配料吗？”工作人员说:“对不起，我是收银员，帮不了你。”

这时候，有人从厨房出来，问你:“需要帮忙吗？”你向他们解释了你想要什么。

他们说:“你找对人了。我能为你做那件事，”并且在你的比萨饼上放一些额外的配料，并且再次把它放在比萨饼盒子里。他们给了你带盒子的披萨。

“只要你把装披萨的盒子带来，我可以把披萨换成你想要的任何一种披萨。”

在这个例子中，来自厨房的人所做的是把比萨饼从盒子里拿出来，放上配料，然后再放回盒子里。即使你想再买一个披萨，你只需要告诉他们换盒子里的披萨。他们是一个*函子*。

想象一下，它们是一个接受输入并返回输出的函数——一个比萨饼。

```
KitchenGuy => (pizza A -> pizza B)
```

所以这个人给一个`pizza A`，给你一个`pizza B`。但是，如果要把`pizza B`改成`pizza C`呢？记得他们说什么吗？

“只要你把盒子带来，我就给你换。”

我们可以把`KitchenGuy`的格式写成如下。

```
KitchenGuy w/ Box => (pizza A w/ Box -> pizza B w/ Box);
```

现在来说一个函子。首先，我会记下它的表达。即使你不明白它的意思也没关系，我会一步一步地解释一切，通过与厨房人的故事进行比较。

```
fmap:: (Functor f) => (a -> b) -> (fa -> fb)
```

这种格式看起来很像`KitchenGuy`。一个仿函数`Functor f`以一个函数作为参数，再次返回该函数，但是看看返回值的类型。在每个输入和输出的最左边有一个`f`。

在这种格式中，就像`KitchenGuy`总是返回带有盒子的比萨饼一样，函子也总是返回带有容器类型的新函数`f`。

`KitchenGuy`接受比萨饼作为输入，因子接受函数作为输入。很简单，对吧？然后，你可能想知道最左边的`fmap`是什么。

仿函数从容器(披萨盒)中取出输入，并通过循环将输出放入容器中来处理它。Haskell 中也使用了函子，他们有一定的方法`fmap`，叫做*函子*。

让我们看一个数组的`map`方法的简单例子。

```
const array = [1, 2, 3];
const newArray = array.map(x => x * 2);console.log(array) // [1, 2, 3]
console.log(newArray) // [2, 4, 6]
```

`map`接受一个在数组中循环的函数，并返回一个新数组。现在听起来是不是挺耳熟的？

是的，你是对的。数组是一个函子。为什么？因为你可以不断地链接`map` s。就像`KitchenGuy`可以一遍又一遍地处理披萨盒子里的披萨，只要他们收到盒子里的披萨，一个函子就会返回另一个函子。

# 结论

函子是函数式编程的一个基本概念，有兴趣的应该知道。

许多人认为这很复杂，很难理解，但事实并非如此。它让你困惑的唯一原因是它总是带有类型，这对于像我这样的新手来说就像是一种外星语言。

你应该记住的最重要的一点是，函子只是一个包含一些值的容器，它返回另一个函子。函子在将值从容器中取出后在里面循环，所以无论你想成为什么样的函子，它都应该是可迭代的。

# 此外

我准备了一个函子的简短例子`class`。

这里有一个类`Functor`。它有`map`，它接受一个带值的函数。在这个例子中,`map`所做的是通过将`this.value`传递给它并创建一个新的`Functor`类来执行`fn`。

像这样，你可以继续用这个`Functor`类链接`map` s。

# 资源

*   [动态类型检查和运行时类型信息](https://en.wikipedia.org/wiki/Type_system#DYNAMIC)
*   [打字稿文档](https://www.typescriptlang.org/)