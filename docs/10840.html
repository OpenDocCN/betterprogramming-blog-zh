<html>
<head>
<title>Object-Oriented Programming in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的面向对象编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/object-oriented-programming-in-kotlin-1e8b9a95adbe?source=collection_archive---------8-----------------------#2022-01-30">https://betterprogramming.pub/object-oriented-programming-in-kotlin-1e8b9a95adbe?source=collection_archive---------8-----------------------#2022-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c14" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如代码示例和插图所解释的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42ca0260d54fbd09fd7dd772135a558c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Blq-jxQQXOXkVCUC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@moob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ayla Verschueren </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>是用于Android和后端开发的流行编程语言之一。像<a class="ae kv" href="https://en.wikipedia.org/wiki/Meta_Platforms" rel="noopener ugc nofollow" target="_blank"> Meta </a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Google" rel="noopener ugc nofollow" target="_blank"> Google </a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Apple_Inc." rel="noopener ugc nofollow" target="_blank"> Apple </a>这样的热门科技公司已经将Kotlin纳入了他们的科技堆栈。</p><p id="835b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个博客中，我们将讨论Kotlin的面向对象编程主题，如类、抽象类、接口等。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="ebf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin支持基本类型，如int、long、string等。</p><p id="7461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，类让用户定义他们自己的类型和属性。像其他编程语言一样，Kotlin中的类由函数和属性(变量)组成。让我们创建一个类<em class="lz">狗。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/367f4af1a873d60b1be7786b1255234a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfE8P3Rtz_hsa7rsRixA8A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者插图</p></figure><p id="b162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的UML图描述了一个类<code class="fe mb mc md me b">Dog</code>，它有属性<code class="fe mb mc md me b">name</code>、<code class="fe mb mc md me b">weight</code>、<code class="fe mb mc md me b">height</code>和<code class="fe mb mc md me b">avgLifeExpectancy</code>。</p><p id="f497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还具有定义类<code class="fe mb mc md me b">Dog</code>可以执行的动作的功能，如<code class="fe mb mc md me b">speak</code>、行走和<code class="fe mb mc md me b">eat</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/b4c82d9e54a8a61a45f9b0ed9ad02a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*ZVQFUD0zJ6FP76sgtH6D5Q.png"/></div></figure><p id="56c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是类定义的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序的输出示例:</p><pre class="kg kh ki kj gt mi me mj mk aw ml bi"><span id="27dd" class="mm mn iq me b gy mo mp l mq mr">woof!<br/>nom nom!<br/>I love walking with my hooman. And occasional zoomies!<br/>nora has following properties,<br/>Weight is 10<br/>Height is 22<br/>Average life expectancy is 10</span></pre><p id="6644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，<code class="fe mb mc md me b">myDog</code>是类<code class="fe mb mc md me b">Dog</code>的一个对象。这个对象可以用来访问类中定义的函数和变量。有趣的是，变量是使用关键字<code class="fe mb mc md me b">var</code>和<code class="fe mb mc md me b">val</code>定义的。</p><p id="9c7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用关键字<code class="fe mb mc md me b">var</code>定义的变量是可变的，而用关键字<code class="fe mb mc md me b">val</code>定义的变量是不可变的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="da29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，像其他编程语言一样，类属性可以像<code class="fe mb mc md me b">classObject.property</code>一样被访问。</p><p id="5c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它有一个警告，负值可以赋给像<code class="fe mb mc md me b">weight</code>和<code class="fe mb mc md me b">height</code>这样的属性。为了避免这种情况，我们可以在给类属性赋值之前使用setters来净化输入。</p><p id="2c93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin定义了<code class="fe mb mc md me b">init</code> <em class="lz"> </em>块<em class="lz"> </em>，该块在类初始化时被执行。当我们对类的主要功能有任何先决条件时，这是很有用的。</p><p id="a6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是说明这一点的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="856f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序的输出示例是:</p><pre class="kg kh ki kj gt mi me mj mk aw ml bi"><span id="7751" class="mm mn iq me b gy mo mp l mq mr">This is init block. Notice where it's getting executed!<br/>woof!<br/>nom nom!<br/>I love walking with my hooman. And occasional zoomies!<br/>Nora has following properties,<br/>Weight is 10<br/>Height is 22<br/>Average life expectancy is 10<br/>Weight = 10<br/>Changing weight to 30<br/>New weight is 30<br/>Changing weight to -30<br/>Weight after assigning negative value is 30</span></pre><p id="d88f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，当我们试图这样做时，<em class="lz"> weight </em>属性没有用负值更新。这是因为在setter中检查了<code class="fe mb mc md me b">weight</code>属性。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7bb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我们能适应科特林的课程。让我们扩大范围来理解继承。为此，我们将设置<code class="fe mb mc md me b">Animal</code>、<code class="fe mb mc md me b">Cat</code>和<code class="fe mb mc md me b">Dog</code>三个等级。<code class="fe mb mc md me b">Animal</code>类是一个抽象类，将被类<code class="fe mb mc md me b">Cat</code>和<code class="fe mb mc md me b">Dog</code>继承。遵循这个UML图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/341d37b0d5d315cc1dbd6d9483626415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhEQ_nTwBoy43uI8GZf3dQ.png"/></div></div></figure><p id="b0ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是它的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="848c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例代码输出:</p><pre class="kg kh ki kj gt mi me mj mk aw ml bi"><span id="662f" class="mm mn iq me b gy mo mp l mq mr">woof!<br/>nom nom!<br/>I love walking with my hooman. And occasional zoomies!<br/>meow!<br/>nom nom!<br/>Hooman, you better not leash me!</span></pre><p id="14a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码示例中，类<code class="fe mb mc md me b">Animal</code>是抽象类。函数<code class="fe mb mc md me b">speak</code>和<code class="fe mb mc md me b">walk</code>被类<code class="fe mb mc md me b">Dog</code>和类<code class="fe mb mc md me b">Cat</code>覆盖。这是通过使用关键字<code class="fe mb mc md me b">override</code>来完成的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/b2fc93b17dfaf26f74255c52f4ab0360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwqxWUZ8mD8nt7tnrGKxig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="704a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象类使代码更具可扩展性，但它有一个限制，即子类只能有一个父类。接口可以用来支持多重继承，这意味着一个类可以实现多个接口。下面是一个示例界面<em class="lz"> : </em>的UML图</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/ae4b8ea39a3f0cf681426230f4031cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnDFX8HvoC47cGHwnkHOwQ.png"/></div></div></figure><p id="5c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如UML图所描述的，类<code class="fe mb mc md me b">Dog</code>实现了接口<code class="fe mb mc md me b">Animal</code>和<code class="fe mb mc md me b">LivingThings</code>。下面是它的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="a15d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">样本输出:</p><pre class="kg kh ki kj gt mi me mj mk aw ml bi"><span id="0ecd" class="mm mn iq me b gy mo mp l mq mr">woof!<br/>nom nom!<br/>I love walking with my hooman. And occasional zoomies!<br/>I might be an Airbender! May be. Just May be.<br/>Growing with the time.</span></pre><p id="0021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的代码中我们可以看到，变量<code class="fe mb mc md me b">alive</code>和函数<code class="fe mb mc md me b">speak</code>、<code class="fe mb mc md me b">walk</code>和<code class="fe mb mc md me b">breath</code>是在类<code class="fe mb mc md me b">Dog</code>中使用关键字<code class="fe mb mc md me b">override</code>实现的。</p><p id="db4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口和抽象类听起来非常相似，但略有不同。</p><p id="d90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口提供了类的蓝图，换句话说，它定义了一个关于它将交付的功能和实现它的类负责交付这些承诺的契约。</p><p id="c146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，抽象类是由子类扩展的不完整的实现。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你和我一起学习Kotlin面向对象编程有一段美好的时光。感谢您的阅读。</p></div></div>    
</body>
</html>