<html>
<head>
<title>Mathematical Set Operations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的数学集合运算</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mathematical-set-operations-in-python-e065aac07413?source=collection_archive---------4-----------------------#2020-08-27">https://betterprogramming.pub/mathematical-set-operations-in-python-e065aac07413?source=collection_archive---------4-----------------------#2020-08-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d0f0" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Python数学集合运算完全指南</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ac9069cca94f4c825d9b72e39a68569b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GurbVIu4XYjADZn7ZH1z8w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">所有图片均由作者提供</p></figure><h1 id="6c53" class="kz la iu bd lb lc ld le lf lg lh li lj ka lk kb ll kd lm ke ln kg lo kh lp lq bi translated">Python中的数学集合运算</h1><blockquote class="lr ls lt"><p id="ed70" class="lu lv lw lx b ly lz jv ma mb mc jy md me mf mg mh mi mj mk ml mm mn mo mp mq in bi translated">Python的<code class="fe mr ms mt mu b">set</code>是Python中的无序集合。它可用于计算标准数学运算，如交集、并集、差集和对称差集。<code class="fe mr ms mt mu b">Other</code>集合——如列表、元组和字典——不支持集合操作。<code class="fe mr ms mt mu b">Dict</code>视图对象类似集合，允许集合操作。- <a class="ae mv" href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="noopener ugc nofollow" target="_blank"> python文档</a></p></blockquote><p id="900e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">参考我关于Python集合的<a class="ae mv" href="https://medium.com/analytics-vidhya/python-sets-8e38a8bfb98c" rel="noopener">故事。</a></p><p id="02a5" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">本文将详细探讨set对象支持的数学运算。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="4166" class="kz la iu bd lb lc ng le lf lg nh li lj ka ni kb ll kd nj ke ln kg nk kh lp lq bi translated"><strong class="ak">我们来看看Set对象</strong>支持的数学运算</h1><ul class=""><li id="cfcd" class="nl nm iu lx b ly nn mb no mw np mx nq my nr mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">union()</code></li><li id="d464" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">update()</code></li><li id="2928" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">intersection()</code></li><li id="f7bc" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">intersection_update()</code></li><li id="77cb" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">difference()</code></li><li id="fad5" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">difference_update()</code></li><li id="1b48" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">symmetric_difference()</code></li><li id="4e12" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">symmetric_difference_update()</code></li><li id="e166" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">isdisjoint()</code></li><li id="270c" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">issubset()</code></li><li id="bb29" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">issuperset()</code></li></ul><p id="46ca" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">集合操作有两种方式。通过使用方法或使用运算符。</p><h2 id="95ec" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated"><strong class="ak"> 'union()' </strong></h2><p id="5f36" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">用集合和<code class="fe mr ms mt mu b">other</code>中的元素返回一个新的集合<strong class="lx iv"> </strong>。由<code class="fe mr ms mt mu b">union()</code>或使用<code class="fe mr ms mt mu b">|</code>操作器来执行</p><p id="9977" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="9805" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">union</strong>(<em class="lw">*others</em>)</code></p><p id="3f01" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set | other | ...</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8c95c6fedb1a1aacc6ff8381994788ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSK8pNJJD1djWe6FwpNjAw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">union()'</p></figure><p id="f7f3" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:求两个集合的并集— </strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">和</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code></p><p id="112e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将返回一个包含集合<code class="fe mr ms mt mu b">A</code>和集合<code class="fe mr ms mt mu b">B</code>中元素的新集合。但不会重复元素。集合中的所有元素都是唯一的。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="3e50" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8}<br/>print (A.union(B))#Output:{1, 2, 3, 4, 5, 6, 8}<br/>print (A|B)#Output:{1, 2, 3, 4, 5, 6, 8}</span></pre><p id="6baf" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2:求两个以上集合的并集</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="311d" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8,10}<br/>C={1,3,5,7,9}<br/>print (A|B|C)#Output:{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}<br/>print (A.union(B,C))#Output:{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</span></pre><p id="f8cc" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">union()</code>方法和<code class="fe mr ms mt mu b">|</code>操作器的区别:</p><ul class=""><li id="b611" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated">它将接受任何iterable作为参数</li><li id="28c8" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated">运算符:它只接受一个集合作为参数。否则，它会引发一个<code class="fe mr ms mt mu b">TypeError</code>。</li></ul><p id="6b83" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">union()</strong></code> <strong class="lx iv">方法</strong>中的一个自变量</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="dbb4" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>#iterable is given as list<br/>print (A.union([2,4,6]))#Output:{1, 2, 3, 4, 5, 6}<br/><br/>#iterable is given as tuple<br/>print (A.union((2,4,6)))#Output:{1, 2, 3, 4, 5, 6}<br/><br/>#iterable is given as range object<br/>print (A.union(range(5,10)))#Output:{1, 2, 3, 4, 5, 6, 7, 8, 9}<br/><br/>#iterable is given as a dictionary<br/>print (A.union({<strong class="mu iv">'a'</strong>:6,<strong class="mu iv">'b'</strong>:7}))#Output:{1, 2, 3, 4, 5, 'b', 'a'}</span></pre><p id="f189" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">|</strong></code> <strong class="lx iv">运算符</strong>的自变量</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="2676" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B=[1,2,3]<br/>print (A|B)<br/><em class="lw">#Output:TypeError: unsupported operand type(s) for |: 'set' and 'list'</em></span></pre><h2 id="92ff" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">更新()'</h2><p id="6a08" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">它更新集合，添加来自<code class="fe mr ms mt mu b">other</code>的元素。但不会重复元素。集合中的所有元素都是唯一的。通过使用<code class="fe mr ms mt mu b">update() </code>或使用<code class="fe mr ms mt mu b">|=</code>操作符来执行。返回类型为<code class="fe mr ms mt mu b">None</code>。它会修改原始设置本身。</p><p id="cb9a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="789e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">update</strong>(<em class="lw">*others</em>)</code></p><p id="92a0" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set |= other | ...</strong></code></p><p id="f03e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:在两个集合— </strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">和</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>之间调用 <code class="fe mr ms mt mu b"><strong class="lx iv">update()</strong></code> <strong class="lx iv"/></p><p id="be8c" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将通过添加两个集合中的元素来更新集合<code class="fe mr ms mt mu b">A</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="7cfc" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#update()<br/></em>A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.update(B)) <em class="lw">#Output: None<br/></em>print (A) <em class="lw">#Output: {1, 2, 3, 4, 5, 6, 7, 8}</em></span><span id="b452" class="ob la iu mu b gz pb ov l ow ox">A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>A|=B<br/>print (A) <em class="lw">#Output: {1, 2, 3, 4, 5, 6, 7, 8}</em></span></pre><p id="6c79" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2:在两台以上</strong>之间调用 <code class="fe mr ms mt mu b"><strong class="lx iv">update()</strong></code> <strong class="lx iv"/></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="4bc9" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#update()<br/></em>A={1,2,3}<br/>B={3,4,5}<br/>C={5,6,7}<br/>print (A.update(B,C)) <em class="lw">#Output: None<br/></em>print (A) <em class="lw">#Output: {1, 2, 3, 4, 5, 6, 7}<br/><br/></em>A={1,2,3}<br/>B={3,4,5}<br/>C={5,6,7}<br/>A|=B|C<br/>print (A) <em class="lw">#Output: {1, 2, 3, 4, 5, 6, 7}</em></span></pre><p id="7323" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">update()</code>方法和<code class="fe mr ms mt mu b">|=</code>操作符的区别:</p><ul class=""><li id="87a9" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">update()</code>:它将接受任何iterable作为参数</li><li id="b2c3" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated">运算符:它只接受集合作为参数。否则，它会养一只<code class="fe mr ms mt mu b">TypeError</code>。</li></ul><p id="994e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:在</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">update()</strong></code> <strong class="lx iv">方法</strong>中给出 <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为自变量</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="a0e6" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3}<br/><em class="lw">#iterable is given as list<br/></em>print (A.update([2,3,4]))<em class="lw">#Output:None<br/></em>print (A)<em class="lw">#Output:{1,2,3,4}<br/><br/>#iterable is given as tuple<br/></em>A={1,2,3}<br/>A.update((2,3,4))<br/>print (A)<em class="lw">#Output:{1,2,3,4}<br/><br/>#iterable is given as range object<br/></em>A={1,2,3}<br/>A.update(range(2,5))<br/>print (A)<em class="lw">#Output:{1,2,3,4}<br/><br/>#iterable is given as a dictionary<br/></em>A={1,2,3}<br/>A.update({2:<strong class="mu iv">'a'</strong>,3:<strong class="mu iv">'b'</strong>})<br/>print (A) <em class="lw">#Output:{1, 2, 3}</em></span></pre><p id="9b1a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">|=</strong></code> <strong class="lx iv">运算符</strong>的自变量</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="32ce" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#iterable is given as tuple<br/></em>A={1,2,3}<br/>B=(3,4)<br/>A|=B<br/><em class="lw">#Output:TypeError: unsupported operand type(s) for |=: 'set' and 'tuple'</em></span></pre><h2 id="5625" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">交集()'</h2><p id="f29b" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">返回一个包含集合和<code class="fe mr ms mt mu b">other</code>共有元素的新集合。它由<code class="fe mr ms mt mu b">intersection()</code>或使用<code class="fe mr ms mt mu b">&amp;</code>操作器执行。</p><p id="5816" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="b9a0" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">intersection</strong>(<em class="lw">*others</em>)</code></p><p id="e57d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &amp; other &amp; ...</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/61ffc39c89a4daffe8ee2cba573f68d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhul57HPXrnZH29IB3bA2A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">交集()'</p></figure><p id="6234" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:求两个集合的交集— </strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">和</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code></p><p id="0ed5" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将从集合<code class="fe mr ms mt mu b">A</code>和集合<code class="fe mr ms mt mu b">B</code>中返回一个包含公共元素的新集合。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="01fb" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8}<br/><em class="lw">#intersection is performed by intersection() method or &amp; operator<br/></em>print (A.intersection(B))<em class="lw">#Output:{2,4}<br/></em>print (A&amp;B)<em class="lw">#Output:{2,4}</em></span></pre><p id="b8fc" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2:求两个以上集合的交集</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="2f06" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8,10}<br/>C={2,4}<br/>print (A&amp;B&amp;C)<em class="lw">#Output:{2,4}<br/></em>print (A.intersection(B,C))<em class="lw">#Output:{2,4}</em></span></pre><p id="212f" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">intersection()</code>方法和<code class="fe mr ms mt mu b">&amp;</code>操作符的区别:</p><ul class=""><li id="4f93" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">intersection()</code>:它将接受任何iterable作为参数</li><li id="f9a9" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated">运算符:它只接受一个集合作为参数。否则，它会引发一个<code class="fe mr ms mt mu b">TypeError</code>。</li></ul><p id="7694" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:在</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">intersection()</strong></code> <strong class="lx iv">方法</strong>中给出 <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为参数</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="6d06" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/><em class="lw">#iterable is given as list<br/></em>print (A.intersection([1,4,6]))<em class="lw">#Output:{1,4}<br/><br/>#iterable is given as tuple<br/></em>print (A.intersection((2,4,6)))<em class="lw">#Output:{2,4}<br/><br/>#iterable is given as range object<br/></em>print (A.intersection(range(5,10)))<em class="lw">#Output:{5}<br/><br/>#iterable is given as a dictionary<br/></em>print (A.intersection({1:<strong class="mu iv">'a'</strong>,<strong class="mu iv">'b'</strong>:7}))<em class="lw">#Output:{1}</em></span></pre><p id="4f37" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">&amp;</strong></code> <strong class="lx iv">运算符</strong>的自变量</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="affa" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B=[1,2,3]<br/>print (A&amp;B)<br/><em class="lw">#Output:TypeError: unsupported operand type(s) for &amp;: 'set' and 'list'</em></span></pre><h2 id="c2c8" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">'交叉点_更新()'</h2><p id="8b3a" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">它更新集合，只保留在集合和<code class="fe mr ms mt mu b">other</code>中找到的元素。通过使用<code class="fe mr ms mt mu b"> intersection_update()</code>或使用<code class="fe mr ms mt mu b">&amp;=</code>操作器来执行。返回类型为<code class="fe mr ms mt mu b">None</code>。它会修改原始设置本身。</p><p id="01b9" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="048e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">intersection_update</strong>(<em class="lw">*others</em>)</code></p><p id="d514" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &amp;= other &amp; …</strong></code></p><p id="739a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:找出两个集合——</strong><code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code><strong class="lx iv"/><code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>之间的 <code class="fe mr ms mt mu b"><strong class="lx iv">intersection_update()</strong></code> <strong class="lx iv"/></p><p id="3f81" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将通过只保留在两个集合中找到的元素来更新集合<code class="fe mr ms mt mu b">A</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="c195" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#intersection_update()<br/></em>A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.intersection_update(B)) <em class="lw">#Output: None<br/></em>print (A) <em class="lw">#Output: {4,5}</em></span><span id="d3bd" class="ob la iu mu b gz pb ov l ow ox">A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>A&amp;=B<br/>print (A) <strong class="mu iv"><em class="lw">#Output: {4,5}</em></strong></span></pre><h2 id="41f2" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">差异()'</h2><p id="767a" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">返回一个新的集合，该集合中的元素不在<code class="fe mr ms mt mu b">other</code>中。由<code class="fe mr ms mt mu b">difference()</code>或使用<code class="fe mr ms mt mu b">-</code>操作器执行。</p><p id="0d18" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="99ee" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">difference</strong>(<em class="lw">*others</em>)</code></p><p id="0e66" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set - other - ...</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/0ea5daa3c4bad6a71ce1da4d9945d15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OL3Wn4A5K6Lt7TBclaB-Og.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">差异()'</p></figure><p id="2c3d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:求两组的区别— </strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">和</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code></p><p id="63eb" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将返回一个包含集合<code class="fe mr ms mt mu b">A</code>中不在集合b中的元素的新集合。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="7fbb" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8}<br/><em class="lw"><br/></em>print (A.difference(B))<em class="lw">#Output:{1,3,5}<br/></em>print (A-B)<em class="lw">#Output:{1,3,5}</em></span></pre><p id="b93a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2:求两组以上的差</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="310d" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6,8,10}<br/>C={2,3}<br/>print (A-B-C)<em class="lw">#Output:{1,5}<br/></em>print (A.difference(B,C))<em class="lw">#Output:{1,5}</em></span></pre><p id="e7cd" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">difference()</code>方法和<code class="fe mr ms mt mu b">-</code>操作符的区别:</p><ul class=""><li id="a122" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">difference()</code>:它将接受任何iterable作为参数</li><li id="4531" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated">运算符:它只接受一个集合作为参数。否则，它会抛出一个<code class="fe mr ms mt mu b">TypeError</code>。</li></ul><p id="90f4" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">difference()</strong></code> <strong class="lx iv">方法</strong>中的参数</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="da78" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/><em class="lw">#iterable is given as list<br/></em>print (A.difference([1,2,3]))<em class="lw">#Output:{4,5}<br/><br/>#iterable is given as tuple<br/></em>print (A.difference((1,2,3)))<em class="lw">#Output:{4,5}<br/><br/>#iterable is given as range object<br/></em>print (A.difference(range(1,4)))<em class="lw">#Output:{4,5}<br/><br/>#iterable is given as a dictionary<br/></em>print (A.difference({1:<strong class="mu iv">'a'</strong>,2:<strong class="mu iv">'b'</strong>,3:<strong class="mu iv">'c'</strong>}))<em class="lw">#Output:{4,5}</em></span></pre><p id="e53a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给出</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">-</strong></code> <strong class="lx iv">运算符</strong>的参数</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="3f6b" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B=[1,2,3]<br/>print (A-B)<br/><em class="lw">#Output:TypeError: unsupported operand type(s) for -: 'set' and 'list'</em></span></pre><h2 id="fb11" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">'差异_更新()'</h2><p id="8fe1" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">从集合中删除同时存在于<code class="fe mr ms mt mu b">other</code>集合中的元素。使用<code class="fe mr ms mt mu b">-= </code>操作器或<code class="fe mr ms mt mu b">difference_update() </code>方法进行。返回类型为<code class="fe mr ms mt mu b">None</code>。它会修改原始设置本身。</p><p id="4e81" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="191f" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">difference_update</strong>(<em class="lw">*others</em>)</code></p><p id="aa1d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set -= other | ...</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pc"><img src="../Images/e0306db6a8ea912289f416149e7da9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*KxiR54_nu6OybYaOC14O-w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">'差异_更新()'</p></figure><p id="b8ec" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:找出两个集合——</strong><code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code><strong class="lx iv"/><code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>之间的 <code class="fe mr ms mt mu b"><strong class="lx iv">difference_update()</strong></code> <strong class="lx iv"/></p><p id="8754" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将通过删除集合<code class="fe mr ms mt mu b">B</code>中的元素来更新集合<code class="fe mr ms mt mu b">A</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="ae37" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={2,4,6}<br/><em class="lw">#Return type is None.<br/></em>print (A.difference_update(B))<em class="lw">#Output:None<br/>#It will update the original set<br/></em>print (A) <em class="lw">#Output: {1,3,5}<br/><br/># difference_update by using -= operator<br/></em>A-=(B)<br/>print (A) <em class="lw">#Output: {1,3,5}</em></span></pre><p id="b12b" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2:找出两个以上集合</strong>之间的 <code class="fe mr ms mt mu b"><strong class="lx iv">difference_update</strong></code> <strong class="lx iv"/></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="c07d" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#difference_update() will modify the original set.<br/></em>A={1,2,3}<br/>B={1}<br/>C={2}<br/><em class="lw">#Return type is None.<br/></em>print (A.difference_update(B,C))<em class="lw">#Output:None<br/>#It will update the original set<br/></em>print (A) <em class="lw">#Output: {3}<br/><br/># difference_update by using -= operator<br/></em>A={1,2,3}<br/>B={1}<br/>C={2}<br/>A-=B|C<br/>print (A) <em class="lw">#Output: {3}</em></span></pre><p id="2720" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">difference_update()</code>方法和<br/> <code class="fe mr ms mt mu b"> -=</code>操作符的区别:</p><ul class=""><li id="3ce5" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated">它将接受任何iterable作为参数</li><li id="a8ba" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated"><code class="fe mr ms mt mu b">-= operator</code>:它只接受一个集合作为参数。否则，它会引发一个<code class="fe mr ms mt mu b">TypeError</code>。</li></ul><p id="6513" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:在</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">difference_update()</strong></code> <strong class="lx iv">方法</strong>中给出 <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为自变量</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="6c48" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#iterable is given as list<br/></em>A={1,2,3}<br/>B=[1]<br/>print (A.difference_update(B))<em class="lw">#Output:None<br/></em>print (A)<em class="lw">#Output:{2,3}</em></span></pre><p id="1bb7" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">-=</strong></code> <strong class="lx iv">运算符</strong>的自变量</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="b918" class="ob la iu mu b gz ou ov l ow ox"><em class="lw"><br/></em>A={1,2,3}<br/>B=[1]<br/>A-=B<br/>print (A) <br/><em class="lw">#Output: TypeError: unsupported operand type(s) for -=: 'set' and 'list'</em></span></pre><h2 id="0007" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">symmetric_difference()'</h2><p id="8c9d" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">返回包含集合或<code class="fe mr ms mt mu b">other</code>中元素的新集合，但不包含两者。由<code class="fe mr ms mt mu b">symmetric_difference()</code>或使用<code class="fe mr ms mt mu b">^</code>操作器来执行。</p><p id="a327" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="2f5a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference</strong>(<em class="lw">other</em>)</code></p><p id="b17e" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set ^ other</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/faa30c558706fe6e22bd1c00d531d473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpzlHCXFjshFsc2A4iv2Yg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对称_差异()</p></figure><p id="a52c" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:找出两个集合之间的</strong><code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference</strong></code><strong class="lx iv">——</strong><code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code><strong class="lx iv">和</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code></p><p id="d245" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将返回一个新的集合，包含来自集合<code class="fe mr ms mt mu b">A</code>和集合<code class="fe mr ms mt mu b">B</code>的元素，但不包含在两个集合中都找到的元素。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="faa1" class="ob la iu mu b gz ou ov l ow ox">A={1,2}<br/>B={2,3}<br/><em class="lw"><br/></em>print (A.symmetric_difference(B))<em class="lw">#Output:{1,3}<br/></em>print (A^B)<em class="lw">#Output:{1,3}</em></span></pre><p id="da0a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例2: </strong> <code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference</strong></code> <strong class="lx iv">只在两组</strong>之间进行</p><p id="18ec" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">多台电视机不支持<code class="fe mr ms mt mu b">symmetric_difference() method</code>。如果给定了两个以上的集合，就会产生一个<code class="fe mr ms mt mu b">TypeError</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="4e05" class="ob la iu mu b gz ou ov l ow ox">A={1,2}<br/>B={2,3,5}<br/>C={3,4}<br/><em class="lw"><br/></em>print (A.symmetric_difference(B,C))<em class="lw">#Output:TypeError: symmetric_difference() takes exactly one argument (2 given)</em></span></pre><p id="56c5" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">但是我们可以用<code class="fe mr ms mt mu b">^</code>找到多组的<code class="fe mr ms mt mu b">symmetric_difference</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="896c" class="ob la iu mu b gz ou ov l ow ox">A={1,2}<br/>B={2,3,5}<br/>C={3,4}<br/><br/>print (A^B^C)<em class="lw">#Output:{1,4,5}</em></span></pre><p id="33f5" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">symmetric_difference</code>方法和<code class="fe mr ms mt mu b">&amp;</code>操作符的区别:</p><ul class=""><li id="f903" class="nl nm iu lx b ly lz mb mc mw oy mx oz my pa mq ns nt nu nv bi translated">它将接受任何iterable作为参数。此方法不允许多个集合。</li><li id="6cba" class="nl nm iu lx b ly nw mb nx mw ny mx nz my oa mq ns nt nu nv bi translated">运算符:它只接受集合作为参数。否则，它会抛出一个<code class="fe mr ms mt mu b">TypeError</code>。通过使用<code class="fe mr ms mt mu b">^</code>运算符，可以找到多个集合之间的<code class="fe mr ms mt mu b">symmetric_difference</code>。</li></ul><p id="141c" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例3:在</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference</strong></code> <strong class="lx iv">方法</strong>中给出 <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为参数</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="0013" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#iterable is given as list<br/></em>A={1,2,3}<br/>B=[1]<br/>print (A.symmetric_difference(B))<em class="lw">#Output:{2,3}<br/><br/>#iterable is given as tuple<br/></em>A={1,2,3}<br/>B=(1,)<br/>print (A.symmetric_difference(B))<em class="lw">#Output:{2,3}<br/><br/>#iterable is given as range object<br/></em>A={1,2,3}<br/>B=range(2)<br/>print (A.symmetric_difference(B))<em class="lw">#Output:{2,3}</em></span></pre><p id="a0bb" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例4:给</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">iterable</strong></code> <strong class="lx iv">作为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">^</strong></code> <strong class="lx iv">运算符</strong>的参数</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="f8ac" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3}<br/>B=[1]<br/>A^B<br/>print (A) <em class="lw">#Output: TypeError: unsupported operand type(s) for ^: 'set' and 'list'</em></span></pre><h2 id="6dbd" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">symmetric_difference_update()'</h2><p id="5937" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">更新集合，只保留在任一集合中找到的元素，而不同时保留两个集合中的元素。通过使用<code class="fe mr ms mt mu b">symmetric_difference_update()</code>或使用<code class="fe mr ms mt mu b">^=</code>操作器来执行。返回类型为<code class="fe mr ms mt mu b">None</code>。它会修改原始设置本身。</p><p id="7703" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="8563" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference_update</strong>(<em class="lw">other</em>)</code></p><p id="0fdd" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set ^= other</strong></code></p><p id="9779" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例1:找出A和B两个集合</strong>之间的 <code class="fe mr ms mt mu b"><strong class="lx iv">symmetric_difference_update()</strong></code> <strong class="lx iv"/></p><p id="c558" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">它将更新集合<code class="fe mr ms mt mu b">A</code>,只保留在任一集合中找到的元素，而不是在两个集合中都找到的元素。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="db4e" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#symmetric_difference_update()<br/></em>A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.symmetric_difference_update(B)) <em class="lw">#Output: None<br/></em>print (A) <em class="lw">#Output: {1, 2, 3, 6, 7, 8}<br/><br/></em>A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>A^=B<br/>print (A) <em class="lw">#Output: {1, 2, 3, 6, 7, 8}</em></span></pre></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h2 id="f398" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated">isdisjoint()'</h2><p id="d014" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">如果集合中没有与<code class="fe mr ms mt mu b">other</code>相同的元素，则返回<code class="fe mr ms mt mu b">True</code>。集合是不相交的当且仅当它们的交集是空集。</p><p id="91b7" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="ee49" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">isdisjoint</strong>(<em class="lw">other</em>)</code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pd"><img src="../Images/76f5b43c5c8d4b392665cbb60ae9b16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*degruTkg4dlURyHXEHVamw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">isdisjoint()</p></figure><p id="1fd8" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例子</strong></p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="037f" class="ob la iu mu b gz ou ov l ow ox"><em class="lw">#Set A and Set B containing common elements<br/></em>A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.isdisjoint(B))<em class="lw">#Output:False<br/><br/>#Set A and Set B not containing common elements<br/></em>A={1,2}<br/>B={3,4}<br/>print (A.isdisjoint(B))<em class="lw">#Output:True</em></span></pre><h2 id="de79" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated"><strong class="ak"> 'issubset()' </strong></h2><p id="ad16" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">测试集合中的每个元素是否都在<code class="fe mr ms mt mu b">other</code>中。</p><p id="a718" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法:</strong></p><p id="914a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">issubset</strong>(<em class="lw">other</em>)</code></p><p id="a5d3" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &lt;= other</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pe"><img src="../Images/9d12c491e0748f622bdd8a450d3ffba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*fwdfgiyyhY5m7s2SU-IGqA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">issubset()</p></figure><p id="35a6" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例:检查集合</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">是否是</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>的子集</p><p id="9d3d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">可通过<code class="fe mr ms mt mu b">issubset()</code>方法或使用<code class="fe mr ms mt mu b">≤</code>操作符完成。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="12bc" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.issubset(B)) <em class="lw">#Output: False<br/></em>print (A&lt;=B)<em class="lw">#Output: False<br/><br/></em>A={1,2,3}<br/>B={1,2,3,4,5}<br/>print (A.issubset(B)) <em class="lw">#Output: True<br/></em>print (A&lt;=B)<em class="lw">#Output: False</em></span></pre><p id="5844" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">真子集</strong></p><p id="c272" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">测试集合是否是<code class="fe mr ms mt mu b">other</code>——即<code class="fe mr ms mt mu b">set &lt;= other and set != other</code>的真子集。</p><p id="c59d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="581d" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &lt; other</strong></code></p><p id="4334" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例:检查集合</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">是否是</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>的真子集</p><p id="411b" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">如果两组相等，这意味着<code class="fe mr ms mt mu b"> A.issubsetset(B) </code>返回<code class="fe mr ms mt mu b">True</code>。但是真子集<code class="fe mr ms mt mu b">A&lt;B</code>将返回<code class="fe mr ms mt mu b">False</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="dd01" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A&lt;B)<em class="lw">#Output: False<br/><br/></em>A={1,2,3,4,5}<br/>B={1,2,3,4,5}<br/>print (A&lt;B)<em class="lw">#Output: False<br/><br/></em>A={1,2,3}<br/>B={1,2,3,4,5}<br/>print (A&lt;B)<em class="lw">#Output: True</em></span></pre><h2 id="7500" class="ob la iu bd lb oc od dn lf oe of dp lj mw og oh ll mx oi oj ln my ok ol lp om bi translated"><strong class="ak"> 'issuperset()' </strong></h2><p id="7f11" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">测试<code class="fe mr ms mt mu b">other</code>中的每个元素是否都在集合中。</p><p id="7461" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="1c46" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">issuperset</strong>(<em class="lw">other</em>)</code></p><p id="77e0" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &gt;= other</strong></code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pe"><img src="../Images/0d6a6e50196ac55d421cb1e0b8a80bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*aMmJJsnq4CpmNX1w5KQRqA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">issuperset()</p></figure><p id="b652" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例:检查集合</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">是否是</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code>的超集</p><p id="987a" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">可通过<code class="fe mr ms mt mu b">issuperset()</code>方法或使用<code class="fe mr ms mt mu b">≥</code>操作器完成。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="c768" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={4,5,6,7,8}<br/>print (A.issuperset(B)) <em class="lw">#Output: False<br/></em>print (A&gt;=B)<em class="lw">#Output:True<br/><br/></em>A={1,2,3,4,5}<br/>B={1,2,3}<br/>print (A.issuperset(B)) <em class="lw">#Output: True<br/></em>print (A&gt;=B)<em class="lw">#Output:True</em></span></pre><p id="6519" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">适当超集</strong></p><p id="eafe" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">测试该集合是否是<code class="fe mr ms mt mu b">other</code>——即<code class="fe mr ms mt mu b">set &gt;= other and set != other</code>——的适当超集。</p><p id="3302" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">语法</strong></p><p id="17f9" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b"><strong class="lx iv">set &gt; other</strong></code></p><p id="e719" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><strong class="lx iv">例:检查集合</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">A</strong></code> <strong class="lx iv">是否为</strong> <code class="fe mr ms mt mu b"><strong class="lx iv">B</strong></code> <strong class="lx iv">的真超集。</strong></p><p id="b501" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">如果两组相等，则意味着<code class="fe mr ms mt mu b">A.issuperset(B)</code>返回<code class="fe mr ms mt mu b">True</code>。但是适当的超集<code class="fe mr ms mt mu b">A&gt;B</code>将返回<strong class="lx iv"> </strong> <code class="fe mr ms mt mu b">False</code>。</p><pre class="kk kl km kn gu oq mu or os aw ot bi"><span id="26b9" class="ob la iu mu b gz ou ov l ow ox">A={1,2,3,4,5}<br/>B={4,5}<br/>print (A&gt;B)<em class="lw">#Output: True<br/><br/></em>A={1,2,3,4,5}<br/>B={1,2,3,4,5}<br/>print (A&gt;B)<em class="lw">#Output: False<br/><br/></em>A={1,2,3}<br/>B={1,2,3,4,5}<br/>print (A&gt;B)<em class="lw">#Output: True</em></span></pre></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="53e2" class="kz la iu bd lb lc ng le lf lg nh li lj ka ni kb ll kd nj ke ln kg nk kh lp lq bi translated">注意</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pf"><img src="../Images/c18345c29883afbdc3f9932746ce9f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUJgpzkA17laIxIJWRGT4Q.png"/></div></div></figure><p id="ae14" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated"><code class="fe mr ms mt mu b">frozenset</code>不支持所有的更新方式。<code class="fe mr ms mt mu b">frozenset</code>类型是不可变的，而<a class="ae mv" href="https://docs.python.org/3.8/glossary.html#term-hashable" rel="noopener ugc nofollow" target="_blank">是可散列的</a>——它的内容在创建后不能更改。因为所有的更新方法都修改原始集合，所以<code class="fe mr ms mt mu b">frozenset</code>不支持。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="a8c8" class="kz la iu bd lb lc ng le lf lg nh li lj ka ni kb ll kd nj ke ln kg nk kh lp lq bi translated">结论</h1><p id="d38c" class="pw-post-body-paragraph lu lv iu lx b ly nn jv ma mb no jy md mw on mg mh mx oo mk ml my op mo mp mq in bi translated">数学集合运算可以通过两种方式执行:使用运算符或使用方法。</p><p id="47f3" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">不同的是如果我们使用方法，他们会接受<strong class="lx iv"> </strong> <code class="fe mr ms mt mu b">iterable</code>作为参数。但是对于运算符，应该只设置参数。如果没有，它会引发一个<code class="fe mr ms mt mu b">TypeError</code>。所有的更新方法都会更新原来的集合，在<code class="fe mr ms mt mu b">frozenset</code>中不支持。除了update方法之外，所有其他方法都返回一个新的集合。</p></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><h1 id="bb6a" class="kz la iu bd lb lc ng le lf lg nh li lj ka ni kb ll kd nj ke ln kg nk kh lp lq bi translated">资源</h1><ul class=""><li id="ab46" class="nl nm iu lx b ly nn mb no mw np mx nq my nr mq ns nt nu nv bi translated"><a class="ae mv" href="https://docs.python.org/3.8/library/stdtypes.html#set-types-set-frozenset" rel="noopener ugc nofollow" target="_blank"> Python docs:“设置类型— </a> <code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3.8/library/stdtypes.html#set-types-set-frozenset" rel="noopener ugc nofollow" target="_blank">set</a></code> <a class="ae mv" href="https://docs.python.org/3.8/library/stdtypes.html#set-types-set-frozenset" rel="noopener ugc nofollow" target="_blank">、</a> <code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3.8/library/stdtypes.html#set-types-set-frozenset" rel="noopener ugc nofollow" target="_blank">frozenset</a></code>”</li></ul></div><div class="ab cl mz na hy nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="in io ip iq ir"><p id="961c" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">请关注此空间，了解更多关于Python和数据科学的文章。如果你喜欢看我的更多教程，就关注我的 <a class="ae mv" href="https://medium.com/@IndhumathyChelliah" rel="noopener"> <strong class="lx iv"> <em class="lw">中</em></strong></a><a class="ae mv" href="https://www.linkedin.com/in/indhumathy-chelliah/" rel="noopener ugc nofollow" target="_blank"><strong class="lx iv"><em class="lw">LinkedIn</em></strong></a><strong class="lx iv"><em class="lw"/></strong><a class="ae mv" href="https://twitter.com/IndhuChelliah" rel="noopener ugc nofollow" target="_blank"><strong class="lx iv"><em class="lw">Twitter</em></strong></a><strong class="lx iv"><em class="lw">。</em> </strong></p><p id="8416" class="pw-post-body-paragraph lu lv iu lx b ly lz jv ma mb mc jy md mw mf mg mh mx mj mk ml my mn mo mp mq in bi translated">感谢阅读！</p></div></div>    
</body>
</html>