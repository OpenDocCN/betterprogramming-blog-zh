<html>
<head>
<title>Asynchronous Calls in Swift 5.5 — Tasks and Task Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.5中的异步调用—任务和任务组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-asynchronous-tasks-and-task-groups-in-swift-5-5-8dd7bc639c8c?source=collection_archive---------6-----------------------#2022-01-11">https://betterprogramming.pub/exploring-asynchronous-tasks-and-task-groups-in-swift-5-5-8dd7bc639c8c?source=collection_archive---------6-----------------------#2022-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">顺序地、并行地创建任务，使用Swift并发处理结果、返回的类型和主要参与者</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2aca3b193dddb223f9c5c43688832237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAJMIM36YItutPL5uy68mA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="7029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上个月，我发表了几篇论文，主题是今年苹果WWDC 2021大会的一个主要议题——并发。苹果发表了至少七篇关于这个主题的演讲。</p><ul class=""><li id="7910" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank">满足异步等待</a></li><li id="3591" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10095/" rel="noopener ugc nofollow" target="_blank">对URLSession使用Async-Await</a></li><li id="cf67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10134/" rel="noopener ugc nofollow" target="_blank">探索Swift中的结构化并发</a></li><li id="609e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10133/" rel="noopener ugc nofollow" target="_blank">用Swift Actors保护可变状态</a></li><li id="5620" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10058/" rel="noopener ugc nofollow" target="_blank">满足异步序列</a></li><li id="0ec9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10254/" rel="noopener ugc nofollow" target="_blank">幕后的快速并发</a></li><li id="db0b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10019/" rel="noopener ugc nofollow" target="_blank">在SwiftUI中发现并发</a></li><li id="c48b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10017/" rel="noopener ugc nofollow" target="_blank">将核心数据并发引入Swift和SwiftUI </a></li></ul><p id="c263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三个多小时的视频——我自己看完了所有的视频，并对这个主题做了一些实际研究，我最初发表了几篇关于演员、<code class="fe mj mk ml mm b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-asyncsequence-in-swift-5-5-ed2f7d218337">asyncSequences</a></code>和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/urlsession-combine-and-asyncawait-96981923a7ec"> URL处理</a>——把最广泛的主题留到最后——任务的文章。我将在这里介绍。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0b0c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">任务</h1><p id="46e3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在开始之前，我需要定义任务这个术语的含义。任务不是将在特定CPU内核上运行的线程、队列或作业，它只是一段具有特定优先级的代码，是Swift 5.5中四个可能的优先级之一。</p><h1 id="d527" class="mu mv it bd mw mx nr mz na nb ns nd ne jz nt ka ng kc nu kd ni kf nv kg nk nl bi translated">概观</h1><p id="d7de" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我想通过一个简单的SwiftUI界面来说明新的编码范式——维恩图中的三个圆圈。</p><p id="8179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码将在运行时以指定的延迟填充每个形状。为了与使用<code class="fe mj mk ml mm b">async/await</code>指令的新规则保持一致，我不会使用任何其他并发/线程语言特性(苹果告诉我们这样做不好)。</p><p id="c60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的Venn的每个循环中，我打印代码运行的延迟。</p><p id="957a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我启动的每个任务都会运行的代码。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="a3af" class="oa mv it mm b gy ob oc l od oe">func changer(newColor:Color, delay:Int) async throws -&gt; Color {<br/>  debugPrint("delay \(newColor) \(delay)")<br/>  textDelay[newColor] = delay<br/>  try await Task.sleep(seconds: delay)<br/>  return newColor<br/>}</span></pre><p id="a846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在其中运行了一个扩展，您也可以在这里看到:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="152c" class="oa mv it mm b gy ob oc l od oe">extension Task where Success == Never, Failure == Never {<br/>  static func sleep(seconds: Int) async throws {<br/>  let duration = UInt64(seconds * 1000_000_000)<br/>  try await sleep(nanoseconds: duration)<br/>  }<br/>}</span></pre><p id="973a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该扩展用于延迟方法的返回。感谢<a class="ae ky" href="https://www.hackingwithswift.com/store" rel="noopener ugc nofollow" target="_blank">黑客用Swift </a>在哪里找到的。</p><h1 id="5513" class="mu mv it bd mw mx nr mz na nb ns nd ne jz nt ka ng kc nu kd ni kf nv kg nk nl bi translated">按顺序运行任务</h1><p id="388b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">维恩牌上的数字是所用的时间。最初，我按顺序运行改变颜色的方法，如你所见，首先是绿色，然后是蓝色，最后是红色——间隔为两秒钟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a9e573b1a54584e4e410b74ac5283343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VorW_1ReDhHPA5GVzt9BcQ.gif"/></div></div></figure><p id="733e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这背后的代码很简单。看起来是这样的:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="8ea1" class="oa mv it mm b gy ob oc l od oe">func serialTasks() async throws {<br/>  try await colour[0] = changer(newColor:.green, delay: 2)<br/>  try await colour[1] = changer(newColor:.blue, delay: 2)<br/>  try await colour[2] = changer(newColor:.red, delay: 2)<br/>}</span></pre><p id="d5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">try</code>是必需的，因为changer函数中的sleep函数会抛出。<code class="fe mj mk ml mm b">await</code>关键字告诉系统这个函数可能需要时间——它应该在运行下一个函数之前等待。</p><p id="044c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">serialTasks</code>方法本身在主SwiftUI代码的单个<code class="fe mj mk ml mm b">.task</code>标记部分中运行。</p><p id="5d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在SwiftUI界面中运行的代码使用了一个<code class="fe mj mk ml mm b">.task</code>标签。：</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="c156" class="oa mv it mm b gy ob oc l od oe">.task {<br/>  do {<br/>    try await serialTasks()<br/>  } catch {<br/>    print(error.localizedDescription)<br/>  }<br/>}</span></pre><p id="963f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意这段代码，因为它将在主线程上运行，同时从主线程继承优先级。</p><p id="8a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在同一个构造中运行这里展示的所有任务，只是简单地更改了被调用函数的名称。理论上，iOS 15可以决定在多个线程下的多个内核上运行这个程序——作为一名程序员，你再也不用担心这个细节了。</p><p id="c6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:如果我需要/想要在SwiftUI接口内专门运行一个不在主线程上运行的任务和/或从其父线程继承优先级，你需要使用<code class="fe mj mk ml mm b">Task.detached(priority: .choices)</code>；用一个可能的选择来代替选择。</p><h1 id="ce46" class="mu mv it bd mw mx nr mz na nb ns nd ne jz nt ka ng kc nu kd ni kf nv kg nk nl bi translated">并行运行任务</h1><p id="9526" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当然，并发意味着同时进行，这在M1芯片上意味着多达32个内核，理论上，你应该能够让事情运转起来。</p><p id="42c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我将展示并行运行相同方法的五个版本的代码。</p><p id="ef7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有五个版本，因为并发编码不适合胆小的人，而且有多种方法可以做到这一点。</p><h2 id="56e8" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">1.在单个任务下运行Swift代码</h2><p id="538b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">bon——这是第一个，然后——有一个小的变化——这次改变颜色的时间后面的数字是随机的，尽管我在单个<code class="fe mj mk ml mm b">.task</code>标签下运行这个。但这只是我眼中的部分并行解决方案。</p><p id="6103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我并行运行所有的颜色变化——我按顺序等待它们完成— <code class="fe mj mk ml mm b">green</code>、<code class="fe mj mk ml mm b">blue</code>，然后是<code class="fe mj mk ml mm b">red</code>。尽管红色在绿色和蓝色之前很久就跑完了，但我们先看到绿色，然后是蓝色和红色同时出现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4e16aca12d80d601e35f80a8d2c7faa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EfKJKf836AcAxUaWlHsRzw.gif"/></div></div></figure><p id="1e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案背后的代码稍微复杂一点，尽管仍然非常简单:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="9dcf" class="oa mv it mm b gy ob oc l od oe">func parrallelTasksI() async throws {<br/>  async let colour1 = changer(newColor:.green, delay: Int.random(in: 0...7))<br/>  async let colour2 = changer(newColor:.blue, delay: Int.random(in: 0...7))<br/>  async let colour3 = changer(newColor:.red, delay: Int.random(in: 0...7))<br/>  try await colour[0] = colour1<br/>  try await colour[1] = colour2<br/>  try await colour[2] = colour3<br/>}</span></pre><p id="e023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">let告诉系统这段代码可以独立运行，并且它对所有的转换器方法都是这样。</p><h2 id="44c1" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">2.在Swift中并行运行多个任务</h2><p id="af70" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了解决这个问题，我需要告诉系统，我想用第二个解决方案独立地运行这些方法中的每一个，如下所示。</p><p id="909c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间决定了圆圈再次填充的顺序。<br/>整个事情是并行运行的。我又跑了三次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4c03c2f5d6e17366146bea6154031786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nM5HX5bXTCuUqWt5qzdk0g.gif"/></div></div></figure><p id="e552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个动画GIF背后的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="23d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我再次使用了<code class="fe mj mk ml mm b">async</code>和wait语言——但关键的是，这一次，我把它们放在了一起。我这样做是为了让他们都在自己的环境中运行，一旦完成，就返回来填充他们正在工作的圈子。</p><p id="5bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完了，但是，不，我们还没完。第二种解决方案没有错。如果它能解决你的问题，你就有了答案——但事实是，你很可能需要更多。</p><p id="f6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的主要问题是，您几乎无法控制已经启动的任务，除非您关闭创建它们的视图，否则它们将被终止(在OS术语中是干净的)。</p><h2 id="e56e" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">3.取消任务</h2><p id="2ad9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果在这一点上，你的头开始旋转，因为下一次迭代感觉有点像向前两步和向后一步，你会被原谅。</p><p id="0add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了控制这些任务，我需要将它们分配给一个变量——为此，我需要离开我用来启动它们的作业——这意味着我必须再启动三个任务来解决我在第一个解决方案中遇到的问题。</p><p id="dbb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出与已经显示的结果相同，所以我只给出代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在其中创建了六个任务——为了演示这个过程，中途取消了其中一个。</p><p id="0637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请注意，cancel进程除了标记一个作业已被取消之外，没有什么作用。如果作业已经开始，则不会停止。</p><h2 id="0153" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">4.从任务中获得结果</h2><p id="a026" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">放松，我们快完成了。同样，动画GIF看起来和已经发布的一样，所以我跳转到代码。在这个版本中，我设法再次分解任务，同时让代码就位，以便在为时已晚之前进行潜在的取消检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="649e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想说这是最终版本——但不是——我们可以做得更好一点。</p><h2 id="917c" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">5.使用分离的任务和主要参与者</h2><p id="6a4b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">bon——最后，我们到了——嗯，老实说，第二个解决方案不错，但前提是你能跳过任务的取消或放弃。和最后两个一样，我们直接进入正题。</p><p id="c4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里使用了几个其他的特性——我运行的<code class="fe mj mk ml mm b">Task</code>是作为一个分离的颜色发出的——所以用我设置的优先级，而不是继承的优先级，我在<code class="fe mj mk ml mm b">mainActor</code>(主线程，与SwiftUI相同)下运行<code class="fe mj mk ml mm b">setColour</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我有三个任务，它们都独立运行。当一个任务完成时，我首先确认它没有同时被取消，然后检查返回的结果类型。</p><p id="77ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在一个单独的过程中这样做。假设它没有被取消，并且没有其他错误，它应该设置颜色。警告取消的任务仍可能返回成功的结果。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="90ff" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">分组任务</h1><p id="f501" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">好的——如果你读了前面的部分，你会很习惯任务的分解——我确信这在你的脑海里留下了一个挥之不去的想法。</p><p id="a390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在M1 max芯片中一点一点地将它分成32个内核，那么你可以更快地完成工作，这是一个很好的想法，但是，正如俗话所说，“上升的东西，必须下降”，“分裂的东西，最终必须回到一起”。</p><p id="94bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提出适合解决方案的问题当然很好(教程似乎就是这样)，但是现实世界呢？</p><p id="e952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你确实有可以并行运行的代码——但是代码需要协调它运行的方法，如果你把它们分开并并行执行，这些过程需要协调它们的返回。</p><h2 id="90de" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">特遣部队</h2><p id="850b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">所以协调任务最简单的方法是使用顺序任务；所以你把你的任务按顺序排列，或者用顺序代码混合搭配并行的任务。<br/>但是这种方法不是可有可无的。</p><p id="d2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的解决方案是使用小组任务。</p><p id="c06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的Swift 5.5 API中的组任务是需要同时完成的并行和/或顺序任务的集合，也称为相互等待。我直接提到的唯一主要限制是它们都必须返回相同的类型——尽管我将在后面讨论一个变通方法。</p><p id="87e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个动画GIF开始，它展示了我们第一次尝试的结果，以及我上一篇论文所基于的文氏图。</p><p id="402d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我运行这个应用程序两次，以确保你能理解你在看什么。这些数字是每个进程所花费的随机时间，尽管这有一点争议，因为它们是分组的，它们花费的时间与最慢的进程一样长。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/3e2624c51ebefdcd6bfcbdee0f718b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JY77et32FmLc_kvIFhQ3Tg.gif"/></div></div></figure><p id="bc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画GIF背后的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="cfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所示的代码中，我定义了一个任务组，并向其中添加了三个任务。</p><p id="5176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一个都将返回一种新的颜色。在代码本身中，我在第7行注释掉了一个取消分组结果的选项。</p><p id="4a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任务的情况一样，这仅设置了一个标志；如果任务已经开始，它不会停止运行。</p><p id="3959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当最慢的完成时，整个组返回<code class="fe mj mk ml mm b">newColours</code>数组或者抛出一个错误消息。</p><p id="bddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法本身在如下所示的<code class="fe mj mk ml mm b">.task</code>选项卡中运行:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="df11" class="oa mv it mm b gy ob oc l od oe">.task {<br/>  do {<br/>    try colour = await newGroup()<br/>  } catch {<br/>    print(error.localizedDescription)<br/>  }<br/>}</span></pre><h2 id="b8e6" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">高级任务组</h2><p id="6c85" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这个看起来像这样——这可能看起来有点奇怪——但请和我呆在一起，因为这里发生了很多事情。</p><p id="bd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我创建了一个任务组，然后向其中添加了三个任务，确认它们没有在我之前被取消。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bce38317f515dbdd52fb4551f5a96456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kUFsscMOU7dxjrOwU-JpHA.gif"/></div></div></figure><ul class=""><li id="4bb8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">但是直接在添加第一个任务之后，我设置了一个提取来提前获得它的副本。你看，它开始执行，因为它独立于组任务设置标签。</li><li id="ea99" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我还在设置好下一个任务后提取它的结果，这一次，在小组到达之前，预先复制出结果类型并设置颜色，因此提前完成[蓝色圆圈，数字2]。</li><li id="5749" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我简单地让<code class="fe mj mk ml mm b">task3</code>执行，该组在填充颜色(红色+绿色+蓝色)之前等待所有三种颜色。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="5c0c" class="oa mv it bd mw og oh dn na oi oj dp ne li ok ol ng lm om on ni lq oo op nk oq bi translated">处理任务组中的返回类型</h2><p id="8bde" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在，说了这么多，让我们重温一下相同类型的返回限制并修复它。但首先，这是文氏图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/6886e43f3c123b426e97cc31563808e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lM5X4DHGg0B46e357N7-Ug.gif"/></div></div></figure><p id="fef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其背后的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从一个包含我想要返回的所有数据的自定义结构开始。现在，与前一个案例一样，发生了很多事情:</p><ul class=""><li id="f79f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我添加了三个任务，它们使用一个定制的结构，通过一个方法<code class="fe mj mk ml mm b">changerV</code>分配颜色和标签。</li><li id="a3de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该标签用作任务完成时设置的延迟，但圆圈仍然是黑色的。</li><li id="304f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">直到最后一项任务完成，圆圈才会被填满。但是我将标签设置为单个过程完成。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="4220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些让我想到了Swift 5.5下的<code class="fe mj mk ml mm b">Tasks</code>这篇文章的结尾。这是一次试图理解正在发生的事情的迷人旅程，也是一次很好的学习练习。</p><p id="1af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你能像我写这本书时一样喜欢读它，并从中有所收获。</p><p id="dd51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问Bitbucket <a class="ae ky" href="https://bitbucket.org/wizard1066/concurrentcode/commits/8384f85a2ffa0ec56422d4a906c015ec7340012f" rel="noopener ugc nofollow" target="_blank">这里</a>完整的源代码。感谢阅读。</p></div></div>    
</body>
</html>