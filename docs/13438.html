<html>
<head>
<title>Exploring SwiftUI Coordinators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索SwiftUI协调员</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-coordinators-a27c2c9d701f?source=collection_archive---------2-----------------------#2022-08-26">https://betterprogramming.pub/swiftui-coordinators-a27c2c9d701f?source=collection_archive---------2-----------------------#2022-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4baa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">回收以前为命令性代码库设计的著名模式，并重用它来处理一些声明性UI。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fbc93f8a9011fc0a64617ae0df9a795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vCsKxxGS9BWNa32z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@swansway?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯旺西汽车集团</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="116e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经熟悉了最初为UIKit框架设计的协调器设计模式。基本上，它包括将导航责任委托给另一个层，称为<code class="fe ls lt lu lv b">Coordinator</code>。</p><p id="981a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类包含对场景的<code class="fe ls lt lu lv b">viewController</code>或<code class="fe ls lt lu lv b">navigationController</code>的引用，它允许<code class="fe ls lt lu lv b">pushViewController</code>和<code class="fe ls lt lu lv b">present</code>操作，以便拥有多种导航方法并在上下文之间传递适当的数据。</p><p id="f062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望用SwiftUI做同样的事情，但问题是在这个框架中，关于UI的一切都是声明性的，我们处理值类型(结构)。所以我们不能有一个引用，我们可以直接要求改变上下文，导航是通过建立<code class="fe ls lt lu lv b">NavigationViews</code>和<code class="fe ls lt lu lv b">NavigationLinks</code>以声明的方式完成的，只要我们操纵它的状态数据，这些数据通过输入传递给这些组件，就会触发一些改变。首先，让我们深入SwiftUI导航原语:</p><h1 id="fb7d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">导航指令</h1><p id="c598" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">像UIKit一样，在SwiftUI中，你可以通过两种方式改变上下文:按下或者模式化。在UIKit中，你可以在你的<code class="fe ls lt lu lv b">navigationController</code>中使用<code class="fe ls lt lu lv b">pushViewController</code>来放置一个新的ViewController到你的堆栈中，或者如果你想要一个模态ViewController，可以使用<code class="fe ls lt lu lv b">present</code>。在SwiftUI中有同样的两种方法，但是机制非常不同，我们现在将看到</p><h2 id="737d" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">1.导航链接</h2><p id="4280" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在SwiftUI中，当我们希望一个堆栈保存多个顺序呈现的视图时，您需要使用<code class="fe ls lt lu lv b">NavigationView</code>来保存所有内容。就像以前的<code class="fe ls lt lu lv b">UINavigationController</code>，但是现在以声明的方式实例化了。在这个容器中，你可以声明<code class="fe ls lt lu lv b">NavigationLinks</code>来建立你可以从当前上下文中选择的路径。</p><p id="b18f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想让一个<code class="fe ls lt lu lv b">NavigationLink</code>工作，它应该被放在一个<code class="fe ls lt lu lv b">NavigationView</code>里面。忘记这一点就像试图访问一个没有任何导航功能的<code class="fe ls lt lu lv b">viewController</code>的<code class="fe ls lt lu lv b">navigationController</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/15215680907acbf19215264d8577a6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WxOTKeErlHvVkBQVJmboA.png"/></div></div></figure><p id="a76c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，一旦导航链接的输入绑定布尔值为真，或者如果某个标签被赋予了某个对应于自定义视图的值，导航链接就会强制改变上下文。</p><p id="d265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于本文的目的是在声明性框架中展示一个协调器层，所以我不会涉及它的细节，所以我们将继续。</p><h2 id="1c76" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">2.表</h2><p id="f736" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这是一个SwiftUI修改器，一旦绑定布尔输入为真或者某个输入<code class="fe ls lt lu lv b">Identifiable</code>被改变，它会强制一个新的屏幕以模态方式呈现在你当前的屏幕上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/c4e0609b8df7b40aaa4e833dbb74ce67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5nYxhuD5agGP5pB2GfjdQ.jpeg"/></div></div></figure><h1 id="0d58" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">解释我们的建筑</h1><p id="c067" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当我们在SwiftUI中导航到一个新场景时，我们只需通过<code class="fe ls lt lu lv b">NavigationLink</code>或<code class="fe ls lt lu lv b">sheet</code>修饰符来声明可能的路线，这与UIKit不同，在ui kit中，我们习惯于强制“命令”我们的<code class="fe ls lt lu lv b">navigationController</code>将一个新屏幕推入堆栈。由于我们没有对我们的<code class="fe ls lt lu lv b">NavigationView</code>的引用，我们需要一些绑定变量来控制何时是改变屏幕的正确时间。也就是说，我们需要将协调器分成两个子层:</p><ol class=""><li id="1079" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">CoordinatorView:插入<code class="fe ls lt lu lv b">NavigationView</code>并通过<code class="fe ls lt lu lv b">NavigationLinks</code>和<code class="fe ls lt lu lv b">sheet</code>修饰符建立可能的路线。此外，我们需要插入我们的内容视图，在这个CoordinatorView中我们场景的中心组件。</li><li id="4734" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">CoordinatorViewModel:我们放置逻辑数据的层，这些数据将触发我们的上下文变化。当我们和MVVM一起工作时，不要被场景视图模型弄糊涂了，它处理主要的场景逻辑，这个处理导航逻辑。</li></ol><p id="4be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的场景可能看起来像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/3cba4f89c46d3c0c0904f5721d1c35c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZrWMiCcOyYhO2QPcDnkfQ.png"/></div></div></figure><p id="ef62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，我们的<code class="fe ls lt lu lv b">CoordinatorView</code>有一些<code class="fe ls lt lu lv b">NavigationView</code>和协调指令，它们由我们的<code class="fe ls lt lu lv b">CoordinatorViewModel</code>中的一些绑定逻辑控制。<code class="fe ls lt lu lv b">CoordinatorView</code>将我们的<code class="fe ls lt lu lv b">View</code>呈现在里面，它也由自己的<code class="fe ls lt lu lv b">ViewModel</code>控制，并向它发送一些用户事件，这可能会触发<code class="fe ls lt lu lv b">CoordinatorViewModel</code>的上下文变化，它执行一些导航逻辑，强制在<code class="fe ls lt lu lv b">CoordinatorView</code>中导航。很简单，对吧？说到这里，让我们在Xcode上创建一个新项目。</p><h1 id="7b58" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">CoordinatorSample示例项目</h1><p id="8d3e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">打开Xcode并创建一个新的SwiftUI项目。你可以用CoordinatorSample这样的名字来命名它。这是我们将要创建的文件夹结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/2f548ca75f4ff1c59be72f5faef640fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xy12Sa5JIgAUksVjR6UtsA.png"/></div></div></figure><p id="1507" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先创建一些我们需要的通用模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="09ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在某个地方创建这个协议。基本上，这将是一个负责定义单一导航路线的<code class="fe ls lt lu lv b">enum</code>。我们将在第一场戏中验证这一点。</p><p id="e5a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的SwiftUI场景，并将其命名为<code class="fe ls lt lu lv b">Scene1CoordinatorView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个公正的视图，它建立了一个<code class="fe ls lt lu lv b">NavigationView</code>，它将我们的输入<code class="fe ls lt lu lv b">content</code>(主场景本身)包装在一起，并通过所有可能的导航情况(NavigationItem)进行循环，以便将自己的<code class="fe ls lt lu lv b">nextView</code>附加到<code class="fe ls lt lu lv b">NavigationLink</code>目的地。这样，我们就为给予者提供了一条通向每个视图的路径<code class="fe ls lt lu lv b">NavigationItem</code>。因为我们的<code class="fe ls lt lu lv b">NavigationItem</code>是<code class="fe ls lt lu lv b">Identifiable</code>和<code class="fe ls lt lu lv b">Hashable</code>，我们被允许用这个类型来标记我们的链接。</p><p id="d705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修复我们的<code class="fe ls lt lu lv b">CoordinatorView</code>引用了<code class="fe ls lt lu lv b">Scene1CoordinatorViewModelProtocol</code>实例。我们现在就要谈论它。</p><h1 id="9b78" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">协调器视图模型</h1><p id="4575" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在我们的场景1文件夹中创建一个新类，并将其命名为<code class="fe ls lt lu lv b">Scene1CoordinatorViewModel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cb78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这么多内容你可能会感到困惑，那我来解释一下每一部分:</p><ol class=""><li id="8aff" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">我们有两个<code class="fe ls lt lu lv b">NavigationItem</code>具体类型，它们都是枚举:<code class="fe ls lt lu lv b">Scene1NavigationItem</code>应该附加到一个<code class="fe ls lt lu lv b">NavigationLink</code>和<code class="fe ls lt lu lv b">Scene1SheetItem</code>上，在那里定义一个<code class="fe ls lt lu lv b">sheet</code>要呈现的视图。每个枚举案例对应于一个可能由我们的场景路由的新上下文。对于每种情况，<code class="fe ls lt lu lv b">nextView</code>方法返回一个新场景。在这种情况下，<code class="fe ls lt lu lv b">Scene2Factory</code>实例化一个新的上下文，场景2的协调器视图。</li></ol><p id="bb0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.我们有两个协议:<code class="fe ls lt lu lv b">Scene1CoordinatorViewModelProtocol</code>和<code class="fe ls lt lu lv b">Scene1CoordinatorProtocol</code>，前者是我们的协调视图可以看到的接口，后者是我们的视图模型可以看到的接口。<code class="fe ls lt lu lv b">navigateTo</code>方法接收一个<code class="fe ls lt lu lv b">Scene1NavigationItem</code>，<code class="fe ls lt lu lv b">present</code>接收一个<code class="fe ls lt lu lv b">Scene1SheetItem</code>。在我们的具体类中，它们每个都有一个属性，所以当分配了相应的项时，它会更新我们的协调器视图，如果分配了新的<code class="fe ls lt lu lv b">Scene1NavigationItem</code>，则导航由<code class="fe ls lt lu lv b">NavigationLink</code>触发；如果分配了<code class="fe ls lt lu lv b">Scene1SheetItem</code>，则导航由<code class="fe ls lt lu lv b">sheet</code>触发。</p><p id="e010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为一个<code class="fe ls lt lu lv b">Scene1NavigationItem</code>的散列也是由它的关联值计算的，所以我们应该在每次新值出现时将每个新的事例保存到一个数组中，所以我们订阅了我们的<code class="fe ls lt lu lv b">navigationItem</code> publisher并将这个条目添加到我们的数组中。为了节省内存，每次实例化场景时，我们都会重置这些值。</p><h1 id="1d6c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">视角</h1><p id="a34f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">现在让我们创建我们的视图。它只由一个<code class="fe ls lt lu lv b">TextField</code>组成，将一些值传递给下一个场景。我们将绑定值保存在视图模型中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/3c9fe65b3a8cb0d34d4175e4f047c406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3LXG2Qhtw5URHOE-KdDzA.png"/></div></div></figure><p id="fb3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，第一个按钮通过<code class="fe ls lt lu lv b">NavigationLink</code>导航到场景2(查看我们的协调视图)，第二个按钮通过<code class="fe ls lt lu lv b">sheet</code>导航到场景3。好了，让我们来谈谈我们的视图模型</p><h1 id="ee25" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">逻辑视图模型</h1><p id="8f16" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这是我们的标准视图模型，我通过逻辑视图模型调用它，以区别于<code class="fe ls lt lu lv b">CoordinatorViewModel</code>。它的主要任务是保存可能改变<code class="fe ls lt lu lv b">View</code>的值，并回答用户交互以及触发<code class="fe ls lt lu lv b">CoordinatorViewModel</code>的上下文变化。看一看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="abd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<code class="fe ls lt lu lv b">SceneViewModel</code>实现了一个协议，该协议包含一个绑定到我们的<code class="fe ls lt lu lv b">View</code>中的<code class="fe ls lt lu lv b">TextField</code>的文本<code class="fe ls lt lu lv b">String</code>和由我们的用户交互触发的方法。每个人创建一个新的<code class="fe ls lt lu lv b">NavigationItem</code>案例，并将其发送到<code class="fe ls lt lu lv b">CoordinatorViewModel</code>进行处理。</p><p id="b845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的工作方式与我们已经习惯的前一种方式完全一样。</p><h1 id="ca88" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">工厂</h1><p id="571d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们采用工厂设计模式来构建我们所有的场景，通过绑定每一层来保证架构的完整性。只需在我们的<code class="fe ls lt lu lv b">Scene1</code>文件夹中创建这个枚举:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="ef14" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创造我们接下来的两个场景</h1><p id="0332" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">由于我们只是从场景1导航到场景2和场景3，我们的目标不是为其他场景重建场景结构，因此，只需为它们创建一个新的<code class="fe ls lt lu lv b">View</code>，它将只呈现从原始场景传递过来的<code class="fe ls lt lu lv b">Text</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/4cdf23f142125a415e0c07075317bcaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOZI20EV3Sf23cVAuhCyPg.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/8b43bebc53f176aec91ba2aa325af824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHyTDEVobeWC4DP60tOfvw.png"/></div></div></figure><p id="6559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图模型只能保存从场景1:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="70b1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="6f87" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们刚刚创建了一个新项目，它包含一个带有<code class="fe ls lt lu lv b">TextField</code>的初始场景，该场景的值通过<strong class="ky ir">协调器</strong>视图模型传递给场景2和场景3，该模型控制在<strong class="ky ir">协调器</strong>视图中触发上下文变化的时间。我们要检查的最后一行代码是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以运行项目并检查导航魔术:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/c1fa5889511c8d2bc71368a4226d8987.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*BVa-2N1d4MVAMYTC40h4aQ.gif"/></div></figure><p id="8070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有分享这个项目的所有文件，因为我的目标是解释如何将导航逻辑分成场景1中的两个特殊层(协调器)并向前发送它们。</p><p id="cad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Github上这个示例项目的链接:</p><div class="ob oc gp gr od oe"><a href="https://github.com/pnalvarez/SwiftUI-Coordinator" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">GitHub-pnalvarez/swift ui-Coordinator:这个库说明了Coordinator的正确用法…</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><p id="a6fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们解释了如何回收以前为命令性代码库设计的著名模式，并重用它来处理一些声明性UI。</p><p id="4f94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将我们的主场景包装在一个<code class="fe ls lt lu lv b">NavigationView</code>中，还有一些链接和表单修改器，只有在我们的Coordinator视图模型中实现了一些逻辑时才会启用。</p><p id="d37b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这个新的MVVM C建筑适合你未来的项目，你喜欢；)</p></div></div>    
</body>
</html>