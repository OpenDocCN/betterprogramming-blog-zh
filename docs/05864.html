<html>
<head>
<title>How TypeScript’s Strict Mode Actually Fixes TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript的严格模式如何实际修复TypeScript</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-typescripts-strict-mode-actually-fixes-typescript-736ba8108c85?source=collection_archive---------8-----------------------#2020-08-12">https://betterprogramming.pub/how-typescripts-strict-mode-actually-fixes-typescript-736ba8108c85?source=collection_archive---------8-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dfc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">默认情况下没有理由不打开它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18e4cd6df97f95f7ab0966f55a06fd9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jaDrjfASkNVYnkfU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@clemono2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clem Onojeghuo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="0741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式实际上是其他六个标志的组合(从TypeScript 3.8开始):</p><ul class=""><li id="2905" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">noImplicitAny</code></li><li id="3a6a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">strictNullChecks</code>(从2.0开始)</li><li id="ba22" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">noImplicitThis</code>(从2.0开始)</li><li id="d1dd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">strictFunctionTypes</code>(从2.6开始)</li><li id="a05b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">strictPropertyInitialization</code>(从2.7开始)</li><li id="e074" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">strictBindCallApply</code>(从3.2开始)</li></ul><p id="eeb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个选项都可以单独启用或禁用。其中一些使TypeScript的类型检查更好，一些有助于使您的代码可读性更好，更不容易出错。</p><p id="e326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在您的<code class="fe me mf mg mh b">tsconfig.json</code>中启用严格模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以在<code class="fe me mf mg mh b">compileOptions</code>中禁用任何您不喜欢的严格系列选项(例如<code class="fe me mf mg mh b">"noImplicitAny": false</code>)。</p><p id="1324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为最重要的旗帜是<code class="fe me mf mg mh b">noImplicitAny</code>和<code class="fe me mf mg mh b">strictNullChecks</code>。这两点将真正提高代码的类型检查和可读性。</p><p id="0053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看每面旗。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9732" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">无ImplicitAny</h1><p id="ad10" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">没有打开<code class="fe me mf mg mh b">noImplicitAny</code>，你只是<em class="nt">主要是</em>使用类型脚本，因为现在你甚至没有注意到你的部分代码是类型<code class="fe me mf mg mh b">any</code>的。</p><p id="5ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为type <code class="fe me mf mg mh b">any</code>基本上禁用了类型检查，所以除非别无选择，否则真的不应该有。问题是在你的代码中很容易错误地使用<code class="fe me mf mg mh b">any</code>，所以通过使用<code class="fe me mf mg mh b">noImplicitAny</code>，你现在只有在你明确使用<code class="fe me mf mg mh b">any</code>的地方才会有它。</p><p id="600e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看错误地禁用类型检查是多么容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们定义了一个函数(<code class="fe me mf mg mh b">fn</code>)，它只返回它得到的结果。我们很容易忽略的是，这个函数的返回类型其实是<code class="fe me mf mg mh b">any</code>。你可以看到和<code class="fe me mf mg mh b">num</code>一样的<code class="fe me mf mg mh b">copyOfNum</code>，现在是<code class="fe me mf mg mh b">any</code>类型，我们可以用它做各种错误的事情。</p><p id="32cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打开<code class="fe me mf mg mh b">noImplicitAny</code>，我们将不能像<code class="fe me mf mg mh b">fn</code>那样定义一个隐式返回<code class="fe me mf mg mh b">any</code>的函数，而必须正确地定义它，导致<code class="fe me mf mg mh b">copyOfNum</code>不会丢失它的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ff2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种我们在没有注意到的情况下将<code class="fe me mf mg mh b">any</code>放入代码的常见方式是在导入外部模块时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="928b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们只是想使用lodash添加1 + 1，但是得到了类型为<code class="fe me mf mg mh b">any</code>的结果，因为我们没有安装lodash的类型。这可以通过安装<code class="fe me mf mg mh b">@types/lodash</code>来解决。如果我们使用没有可用类型的外部模块，我们可以使用<code class="fe me mf mg mh b">declare module ‘lodash’ { /* types goes here */}</code>自己编写它们。</p><p id="3a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们同意这个模块是类型<code class="fe me mf mg mh b">any</code>或者现在没有能力修复它，我们可以通过声明这个模块没有类型来通知编译器:</p><pre class="kj kk kl km gt nu mh nv nw aw nx bi"><span id="923e" class="ny mx it mh b gy nz oa l ob oc">declare module ‘lodash’;</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="fff6" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">strictNullChecks</h1><p id="baf7" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">最常见的JS运行时错误可能是<code class="fe me mf mg mh b">Uncaught TypeError: Cannot read property ‘foo’ of undefined. </code>这是在试图访问一个属性或调用一个<code class="fe me mf mg mh b">undefined</code>对象上的方法时引起的。</p><p id="cf0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，TypeScript可以提供帮助。</p><p id="04f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe me mf mg mh b">null</code>和<code class="fe me mf mg mh b">undefined</code>可赋给所有其他类型，而您的代码实际上有许多类型永远不可能是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>，这使得它们的类型在默认情况下是错误的。</p><p id="5bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用<code class="fe me mf mg mh b">strictNullChecks</code>后，只有明确标记为<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>的类型。这意味着你不能初始化一个没有值的变量。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="be4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你从这些额外的工作中得到了什么？现在您的类型更加具体了，TypeScript将能够分析您的代码流并找到潜在的错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时你不得不退出这个功能。也许某些外在类型是错误的，但是你没有办法修复或者你想逐步引入这个标志。您可以随时使用<code class="fe me mf mg mh b">!</code>符号禁用<code class="fe me mf mg mh b">strictNullChecks</code>。<br/>任何带有<code class="fe me mf mg mh b">!</code>符号的属性访问在该检查中将被忽略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="90d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有启用了<code class="fe me mf mg mh b">strictNullChecks</code>，你才能启用下一面旗帜。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8e68" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak">严格属性初始化</strong></h1><p id="60a5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">使用<code class="fe me mf mg mh b">strictPropertyInitialization</code>，TypeScript将抛出一个错误，除非所有的类属性都在构造函数中或由属性初始化器初始化。这有助于防止无意中访问代码中的<code class="fe me mf mg mh b">undefined</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时你不能在类创建时初始化。例如，您可能使用外部服务来获取数据。在这些情况下，您可以使用<code class="fe me mf mg mh b">!</code>符号忽略<code class="fe me mf mg mh b">strictPropertyInitialization</code>，就像您使用<code class="fe me mf mg mh b">strictNullChecks</code>符号一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ef23" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">strictFunctionTypes</h1><p id="4c92" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在TypeScript中，<a class="ae ky" href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant" rel="noopener ugc nofollow" target="_blank">参数类型是双变量的</a>(既有协变的也有逆变的)，这是不合理的(虽然你现在可以在<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html" rel="noopener ugc nofollow" target="_blank"> TypeScript 2.6 </a>中用<code class="fe me mf mg mh b">--strictFunctionTypes</code>或<code class="fe me mf mg mh b">--strict</code>修复这一点)。</p><p id="751b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的例子来理解它的意思:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们用另一个函数调用<code class="fe me mf mg mh b">forEach</code>，这个函数得到一个<code class="fe me mf mg mh b">HTMLElement</code>，即使<code class="fe me mf mg mh b">querySelectorAll</code>返回一个<code class="fe me mf mg mh b">Element</code>的列表(这个列表是<code class="fe me mf mg mh b">HTMLElement</code>扩展的)。您可以看到我们访问了元素的<code class="fe me mf mg mh b">offsetHeight</code>，这是一个不存在于<code class="fe me mf mg mh b">Element</code>而只存在于<code class="fe me mf mg mh b">HTMLElement</code>的属性。</p><p id="bbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有<code class="fe me mf mg mh b">strictFunctionTypes</code>，这段代码可以编译，但是它的类型是错误的，会导致潜在的错误。如果我们打开<code class="fe me mf mg mh b">strictFunctionTypes</code>，我们将得到一个错误:</p><pre class="kj kk kl km gt nu mh nv nw aw nx bi"><span id="e5b2" class="ny mx it mh b gy nz oa l ob oc">Type ‘Element’ is missing the following properties from type ‘HTMLElement’ …</span></pre><p id="d5a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上意味着我们不能决定<code class="fe me mf mg mh b">element</code>是<code class="fe me mf mg mh b">HTMLElement</code>而不是<code class="fe me mf mg mh b">Element</code>,因为那样我们就可以使用只有<code class="fe me mf mg mh b">HTMLElement</code>在我们函数内部才有的属性，这是错误的。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ea16" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">strictBindCallApply</h1><p id="af7d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">使用<code class="fe me mf mg mh b">strictBindCallApply</code>标志，<code class="fe me mf mg mh b">bind</code>、<code class="fe me mf mg mh b">call</code>和<code class="fe me mf mg mh b">apply</code>方法是强类型的。如果没有这个标志，您可能会错误地使用这三个函数，其参数与使用它们的函数不匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="887b" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">不影响这个</h1><p id="5aec" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这与<code class="fe me mf mg mh b">noImplicitAny</code>的作用相同，但对于<code class="fe me mf mg mh b">this</code>类型。如果你有一个使用了<code class="fe me mf mg mh b">this</code>的函数，但是编译器无法从代码中推断出<code class="fe me mf mg mh b">this</code>的类型是什么，那么你就会出错。这有助于在编译时而不是运行时捕获bug。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们得到一个运行时错误:</p><pre class="kj kk kl km gt nu mh nv nw aw nx bi"><span id="45be" class="ny mx it mh b gy nz oa l ob oc">Uncaught TypeError: Cannot read property ‘x’ of undefined.</span></pre><p id="40fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个错误，因为我们用错误的<code class="fe me mf mg mh b">this</code>参数调用了<code class="fe me mf mg mh b">isEqual</code>(当我们将函数赋给第11行的另一个变量时，我们丢失了<code class="fe me mf mg mh b">this</code>绑定)。</p><p id="90b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打开了<code class="fe me mf mg mh b">noImplicitThis</code>标志，而不是运行时错误，我们将在第6行得到一个编译时错误:<code class="fe me mf mg mh b">‘this’ implicitly has type ‘any’</code>。我们可以通过显式编写<code class="fe me mf mg mh b">this</code>类型来修复这个错误，这将迫使我们修复这个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="4f11" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="9e01" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我希望您现在理解了严格模式，并且您应该在您的代码中使用它，因为好处大于代价——至少对于不需要迁移的新项目来说是这样。</p><p id="3066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于现有项目，考虑一次添加一个严格标志，使迁移更加渐进。</p></div></div>    
</body>
</html>