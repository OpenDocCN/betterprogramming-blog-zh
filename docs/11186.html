<html>
<head>
<title>The Open-Closed Principle Explained in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解释开闭原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-open-closed-principle-explained-in-python-f5517488f990?source=collection_archive---------8-----------------------#2022-02-24">https://betterprogramming.pub/the-open-closed-principle-explained-in-python-f5517488f990?source=collection_archive---------8-----------------------#2022-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">固体原理2/5</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e0f38869004ad0a0eac8bfed34a6af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DYifhcq4MdzPvCAP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@d_mccullough?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">丹尼尔·麦卡洛</a> / <a class="ae ky" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="0fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则系列文章的第二部分。你可以在这里找到第一个帖子<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-explained-in-python-622e2d996d86"/>。</p><p id="6e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件的本质是不断变化的。软件从来都不是“完整的”。几乎总是有一些东西需要修复或改进。这是因为软件是为满足业务需求而构建的，而业务需求从来不会停滞不前。它只是一个封闭的企业，有停滞或不存在的需求。</p><p id="2073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以问题自然出现了，我们如何构建适应变化并且仍然健壮的软件？</p><p id="f9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开闭原理是回答这个问题的一种方式。</p><p id="6f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开闭原则在某些方面与第一篇文章中解释的单一责任原则非常相似。<br/>本质上，这一原则规定了以下内容:</p><blockquote class="lv lw lx"><p id="e2d2" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">软件组件(类和功能)应<strong class="lb iu">打开</strong>进行扩展，而<strong class="lb iu">关闭</strong>进行修改。</p></blockquote><p id="757d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法很简单。您的代码中特定类的业务逻辑不应更改。相反，如果必须实现一个额外的特性，代码应该被扩展而不是被修改。随着业务需求的增长和变化，这使得调试更容易，代码也更容易维护。想象一下，每次由于新的业务需求而改变代码时，都必须重写单元测试！</p><p id="5ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们看一个例子来说明这一点，并把它带回家。</p><h1 id="3c88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">密码</h1><p id="8a51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们有下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用了与第一篇文章相同的主题，即汽车经销商。</p><p id="e9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新车在购买前需要进行实例化。可以使用<code class="fe nb nc nd ne b">buy</code>功能购买汽车，也可以使用<code class="fe nb nc nd ne b">buy_with_discount</code>功能以20%的折扣购买。</p><p id="9bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供给<code class="fe nb nc nd ne b">buy_with_discount</code>函数的<code class="fe nb nc nd ne b">cash</code>需要正好是汽车价格的80%才能被购买。</p><p id="ece9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以运行代码，看到宝马以80000英镑的价格购买，享受20%的折扣。</p><p id="fcc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们假设汽车经销商希望为经销商的忠实会员、VIP人士或亲密的朋友和亲戚提供一些折扣。或者，我们可以假设经销商希望开展夏季销售活动，并提供20%以上的折扣。</p><p id="1077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的,<em class="ly">业务需求</em>已经改变，需要对代码进行<em class="ly">变更。</em></p><p id="4856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了适应这个请求，我们可以简单地为<code class="fe nb nc nd ne b">buy_with_discount</code>函数编写另一个if语句。类似于表示30%的折扣:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="1237" class="nj md it ne b gy nk nl l nm nn">if int(0.7*self.price) == int(cash):<br/>        print("Buying {} with 30%% discount".format(self.name))</span></pre><p id="1a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是根据开闭原则，这是一个错误的方法。因为<code class="fe nb nc nd ne b">Car</code>类的业务逻辑不应该改变。相反，它应该被延长。在OOP(面向对象编程)中扩展功能的一种常见方式是使用多态性，也称为继承。</p><p id="c73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用Python中的继承来正确解决这个问题。</p><p id="1b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做的第一件事是通过创建一个<code class="fe nb nc nd ne b">Discount</code>类将折扣业务逻辑与常规购买逻辑分开。然后我们定义<code class="fe nb nc nd ne b">buy_with_discount</code>函数，它简单地打印汽车已经被购买。</p><p id="da92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是有趣的地方。</p><p id="60d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要实现八折逻辑。但是记住，根据原则，我们不允许修改<code class="fe nb nc nd ne b">Discount</code>类。我们唯一能做的就是延长它。我们如何扩展它？通过创建一个新类并让这个新类继承<code class="fe nb nc nd ne b">Discount</code>类。</p><p id="e2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个新的类<code class="fe nb nc nd ne b">Discount20</code>，并通过将<code class="fe nb nc nd ne b">Discount</code>作为类定义中的一个参数来传递，使它继承自<code class="fe nb nc nd ne b">Discount</code>类。<code class="fe nb nc nd ne b">__init__</code>函数调用父类的<code class="fe nb nc nd ne b">Discount</code> ) <code class="fe nb nc nd ne b">__init__</code>方法，如<code class="fe nb nc nd ne b">super()</code>命令所示。我们将<code class="fe nb nc nd ne b">Discount</code>类的实例中的<code class="fe nb nc nd ne b">self.discount</code>初始化为<code class="fe nb nc nd ne b">20</code>。接下来，我们定义一个<code class="fe nb nc nd ne b">buy_with_discount</code>函数，它使用我们之前在不正确的代码中使用的if条件来检查所提供的钱是否是原始值的80%。如果是，我们通过调用父类的<code class="fe nb nc nd ne b">buy_with_discount</code>函数发出一个购买订单。你看到我们是如何扩展原始的<code class="fe nb nc nd ne b">Discount</code>类和其中的业务逻辑的吗？</p><p id="975f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷的是，假设我们想提供30%的折扣。我们如何实现这一点？</p><p id="b356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单地创建了一个名为<code class="fe nb nc nd ne b">Discount30</code>的新类，并重复代码，仅将值从<code class="fe nb nc nd ne b">20</code>更改为<code class="fe nb nc nd ne b">30</code>，将<code class="fe nb nc nd ne b">0.8</code>更改为<code class="fe nb nc nd ne b">0.7</code>。多棒啊</p><p id="5747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经做到了这一步，花点时间为自己的出色表现而感到自豪吧！</p><p id="7d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在初始化时在<code class="fe nb nc nd ne b">if __name__</code>条件下调用这两个函数。</p><p id="4d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以运行代码了，您将看到购买了两辆汽车。一个七折，一个八折！</p><h1 id="81f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包裹</h1><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个帖子到此为止。希望你学到了一些有用的东西，可以应用到你的软件项目中。简而言之，我们研究了开闭原则，以及它如何有助于使代码更易于维护和测试。我们还看到了它如何提高代码的可读性和质量。</p><p id="184d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，这个原则可能看起来没什么大不了的，因为我们在这篇文章中有一个小的测试例子。但是在拥有中型到大型代码库的组织中，尤其是在测试是开发过程的一部分的情况下，开闭原则真的是一个游戏改变者！</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="4cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">原载于</em><a class="ae ky" href="https://haseebkamal.com/the-open-closed-principle-explained-with-a-python-example/" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://haseebkamal.com</em></a></p></div></div>    
</body>
</html>