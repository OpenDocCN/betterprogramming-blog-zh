<html>
<head>
<title>A Guide to Concurrency in iOS and Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS和Swift并发性指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/concurrency-in-ios-and-swift-guide-50443ce5b0f5?source=collection_archive---------0-----------------------#2022-01-12">https://betterprogramming.pub/concurrency-in-ios-and-swift-guide-50443ce5b0f5?source=collection_archive---------0-----------------------#2022-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c954" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DispatchQueue、Operation和OperationQueues以及Swift并发性的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1026f8444609c25e2942f961bbb59fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TeR1sGcqxPJX498i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jonathan Chng 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的应用程序会因为用户界面时不时被冻结而遭受损失吗？你的应用程序会因为没有响应而被系统杀死吗？</p><p id="8418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现上述情况的应用程序可能是由于您的应用程序在负责响应用户界面交互的同一线程中执行繁重和/或长时间的任务。</p><p id="a549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍如何解决这些问题。这个帖子不是教程。我已经涵盖了这里的大部分内容，我会在单独的帖子中引用教程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你的应用为什么会死机？</h1><p id="94dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设你正在从一个网络服务器获取图像，这可能需要几秒钟的时间。当你的应用程序的进程等待接收图像时，它不会响应用户的交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/fccb993f0686d9248b125b4374e5df5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tXs_6a5BLGR6STMh4tgMQ.jpeg"/></div></div></figure><p id="aebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在他们的点击被处理之前，用户可能会感觉应用程序“没有反应”几秒钟。</p><h1 id="ce6b" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">什么是进程和线程？</h1><p id="e7bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设用户在主屏幕上。用户点击你的应用。这会告诉iOS启动您的应用程序。在这种情况下，iOS将为你的应用程序创建一个新的<strong class="lb iu">进程</strong>，并用它创建一个<strong class="lb iu">线程</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/215264bec004763dd4da0be2fed6492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP0CsIPuODfEfrW5qUjDOA.jpeg"/></div></div></figure><p id="c0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流程是程序的一个实例——在本例中是您的应用程序。在iOS中，你只能运行一个应用实例。</p><p id="4315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他操作系统可能允许运行一个应用程序的多个实例。对于每个进程或实例，操作系统将把你的程序从磁盘加载到内存中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/377726cc5ee6431d857b3d03a6ecb3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*k5KY5X5jXtC57VCiyXM6Aw.jpeg"/></div></figure><p id="fca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS中的每个app进程都是用一个线程启动的。这就是所谓的主线程或UI线程。其他线程可以由您的应用程序或程序创建。线程共享相同的内存空间。</p><p id="2efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线程是一系列指令。你的程序向线程发送指令。这些被排队并执行先来先服务，或者更普遍地被称为先进先出(FIFO)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何解决冻结app问题？</h1><p id="8a3e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">冻结应用程序问题的解决方案是将繁重或长时间运行的任务卸载到新线程中。通过将任务卸载到一个新线程中，释放了UI线程，以继续响应用户与UI的交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/0c9e70650eaf8104c4d69abe0a561fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxCt_n9EwlWOgnukLsnYqQ.jpeg"/></div></div></figure><p id="2bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">委派任务并继续执行自己的任务，直到委派的任务返回结果，这种行为称为异步执行任务。在任务执行之前，我们不会等待阻塞。等待任务被执行，然后再继续我们自己的任务，这就是所谓的同步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/9cf4e65621f0861caa7536232238b549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lw6y6xBUr5ELxat9kBWXeQ.jpeg"/></div></div></figure><p id="05c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如何才能在Swift和iOS中的其他线程上执行代码呢？以下是iOS和Swift的原生可能性:</p><ol class=""><li id="7563" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">中央车站调度</li><li id="2b46" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">操作和操作队列</li><li id="a55e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">快速并发</li></ol><p id="b898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GCD在iOS中已经存在很久了。操作和操作队列建立在GCD之上，并简化了它的一些缺点，我们将在这一节中看到。</p><p id="1e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift并发是最近推出的，它简化了并发任务的执行。你不需要知道GCD和，Operation和OperationQueues。但是，只有iOS 13或更高版本才支持Swift并发。还需要Xcode 13.2或更高版本。</p><p id="9c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这篇文章的目的是了解不同的选项并进行比较。</p><h1 id="87b3" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">如何使用大中央调度</h1><p id="b52c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<a class="ae ky" href="https://developer.apple.com/documentation/DISPATCH" rel="noopener ugc nofollow" target="_blank">大中央调度</a>的主要方式是通过其API接口<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank"> DispatchQueue </a>。一个<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">调度队列</a>不是一个线程。它只是一个队列。任务被添加到队列中。然后<a class="ae ky" href="https://developer.apple.com/documentation/DISPATCH" rel="noopener ugc nofollow" target="_blank"> GCD </a>将选择最老的任务，并首先执行它。</p><p id="3517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上是先来先服务的原则；技术上称为先进先出或FIFO。线程在可用时由系统关联到队列。</p><p id="91cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的队列:</p><ol class=""><li id="3b41" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">串行队列</li><li id="324e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">并发队列</li></ol><p id="9bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于在主/UI线程上执行所有任务的用户界面交互，还有一个默认的调度队列。这个线程被称为<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main" rel="noopener ugc nofollow" target="_blank">主队列</a> ( <code class="fe nw nx ny nz b">DispatchQueue.main</code>)，它在应用程序启动时提供。主队列类型是串行。</p><h2 id="b815" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">串行队列</h2><p id="f50a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">串行队列是一个接一个地执行任务的队列，并且只有在前一个任务已经完成时才执行。</p><p id="a411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建串行队列，请执行以下操作:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="e69f" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">let</strong> queue = DispatchQueue(label: "my_serial_queue")</span></pre><p id="ff04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，当您创建队列时，它被配置为串行执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a19acded2051be26e8a5e39ec8b006a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRaN9aY6JUmBOrpgZ88Y-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前一任务完成时执行的任务</p></figure><h2 id="4f75" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">并发队列</h2><p id="1dfb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">并发队列一个接一个地执行任务，而不等待前一个任务完成。这并不意味着所有任务都将一次性执行。任务的执行将基于系统资源或线程池中的可用线程。</p><p id="3d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建并发队列，请执行以下操作:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="f69d" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">let</strong> queue = DispatchQueue(label: "my_concurrent_queue", attributes: .concurrent)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/6406a9fb08f94b838557ad712156994b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oua05wZ7WOkOZWciJbR3Eg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多个任务正在同时执行</p></figure><h2 id="7ceb" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">如何在<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">调度队列</a>上执行任务</h2><p id="b805" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了推动任务在<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">分派队列</a>上执行，我们需要在闭包中包含要执行的代码。</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="4615" class="oa md it nz b gy oq or l os ot">let taskToPerform = {<br/>    // do something<br/>}</span></pre><p id="9e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">DispatchQueues</a></code>允许我们执行任务<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016103-async" rel="noopener ugc nofollow" target="_blank">异步</a>和<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1452870-sync" rel="noopener ugc nofollow" target="_blank">同步</a>。</p><p id="022b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述,<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016103-async" rel="noopener ugc nofollow" target="_blank"> async </a>或asynchronous会把要执行的任务放入队列，并继续执行下一段代码。</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="4393" class="oa md it nz b gy oq or l os ot">let taskToPerform = {<br/>    print("2. This will print second")<br/>    // do something<br/>}</span><span id="3381" class="oa md it nz b gy ow or l os ot">queue.<strong class="nz iu">async</strong>(execute: taskToPerform)</span><span id="e9b2" class="oa md it nz b gy ow or l os ot">print("1. This will print first")</span></pre><p id="c1e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，<code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1452870-sync" rel="noopener ugc nofollow" target="_blank">sync</a></code>或synchronous会将任务放入<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">队列</a>中，等待任务执行完毕后再继续执行下一行代码。</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="c702" class="oa md it nz b gy oq or l os ot">let taskToPerform = {<br/>    print("1. This will print first")<br/>    // do something<br/>}</span><span id="461d" class="oa md it nz b gy ow or l os ot">queue.<strong class="nz iu">sync</strong>(execute: taskToPerform)</span><span id="da38" class="oa md it nz b gy ow or l os ot">print("2. This will print second")</span></pre><h2 id="8e3e" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">如何用在非主队列中执行的任务的结果更新UI</h2><p id="40ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有UI更新都必须在主队列上执行。那么，如何从在另一个队列中工作的任务执行UI更新呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/f8c026d531f96770695af50ee74fdb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHvzpQVYxPZZBoM-Kn5JEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在UI线程上执行任务？</p></figure><p id="28b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在非主队列中，您可以使用<code class="fe nw nx ny nz b">DispatchQueue.main</code>调用主队列:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="dc80" class="oa md it nz b gy oq or l os ot">let taskToPerform = {<br/>    // do something<br/>    <strong class="nz iu">DispatchQueue.main.async {</strong><br/>        <strong class="nz iu">// update UI</strong><br/>    <strong class="nz iu">}</strong><br/>}</span><span id="df6c" class="oa md it nz b gy ow or l os ot">mySerialQueue.async(execute: taskToPerform)</span></pre><p id="d180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自后台(非主)队列的任何UI更新都可能失败，并导致意外行为。Xcode包含并启用了一个“主线程检查器”，它将检查来自后台线程的UI更新，并在调试时抛出异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/716b4291ecb559b1fc3ea25aa4ef94b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17pTg2J_aXEoFTEsmP5Yow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行时API检查“主线程检查器”选项已启用</p></figure><h2 id="8483" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">如何按顺序执行多个异步任务</h2><p id="e2f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们需要按顺序执行异步任务呢？假设我们要准备一份沙拉，需要按以下顺序执行:</p><ol class=""><li id="dca2" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">加入生菜</li><li id="ef65" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">加入西红柿</li><li id="ff58" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">加入红洋葱</li><li id="89c3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">加入甜玉米</li><li id="ff3c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">加入金枪鱼和葵花籽油</li></ol><p id="a918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于DispatchQueue，它看起来会像下面这样:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="906b" class="oa md it nz b gy oq or l os ot">queue.async {<br/>    // prepare lettuce<br/>    queue.async {<br/>        // prepare tomatoes<br/>        queue.async {<br/>            // prepare red onion<br/>            queue.async {<br/>                // prepare sweetcorn<br/>                queue.async {<br/>                    // prepare tuna<br/>                    // completed salad!<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="2e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上<code class="fe nw nx ny nz b">tomatoes</code>准备工作<em class="oz">依赖于<code class="fe nw nx ny nz b">lettuce</code>的完成</em>。红洋葱依赖于番茄等的制作。</p><p id="d32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们向沙拉中添加更多的配料，我们的代码会变得非常嵌套。这个问题也被称为“<a class="ae ky" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>”。代码很难遵循，因此也很难改变。</p><h2 id="7155" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">使用DispatchGroup并发执行任务并完成任务</h2><p id="5549" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想同时执行多个任务呢？如果我们想根据上一节准备沙拉，而不考虑准备的顺序，该怎么办？</p><p id="7c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在并发队列中异步准备所有配料:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="966e" class="oa md it nz b gy oq or l os ot">concurrentQueue.async { /* prepare lettuce */ }<br/>concurrentQueue.async { /* prepare tomatoes */ }<br/>concurrentQueue.async { /* prepare red onion */ }<br/>concurrentQueue.async { /* prepare sweetcorn */ }<br/>concurrentQueue.async { /* prepare tuna */ }</span></pre><p id="21b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当所有的配料都准备好了，可以端上沙拉的时候，我们怎么才能得到通知呢？通过使用<code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>。</p><p id="98b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>是<code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/DISPATCH" rel="noopener ugc nofollow" target="_blank">Dispatch</a></code>框架中的一个工具，它允许我们在所有指定的任务都执行完毕时得到通知。以下是如何使用<code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>的示例:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="a0d9" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">let</strong> dispatchGroup = DispatchGroup()</span><span id="2aa7" class="oa md it nz b gy ow or l os ot">dispatchGroup.enter()<br/>concurrentQueue.async {<br/>    /* prepare lettuce */<br/>    dispatchGroup.leave()<br/>}</span><span id="df67" class="oa md it nz b gy ow or l os ot">dispatchGroup.enter()<br/>concurrentQueue.async {<br/>    /* prepare tomatoes */<br/>    dispatchGroup.leave()<br/>}</span><span id="5c58" class="oa md it nz b gy ow or l os ot">... // enter and leave for each ingredient</span><span id="7660" class="oa md it nz b gy ow or l os ot">dispatchGroup.notify(queue: .main, execute: { /* serve salad bowl */ })</span></pre><p id="5c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的博客中了解更多关于<code class="fe nw nx ny nz b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>的信息:</p><div class="pa pb gp gr pc pd"><a href="https://anuragajwani.medium.com/how-to-perform-parallel-asynchronous-operations-with-dispatchgroup-3c112deda62c" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">如何使用DispatchGroup执行并行异步操作</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">了解如何将多个并行URL请求作为一个操作来触发</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">anuragajwani.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div><h1 id="c2b3" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">如何使用操作和操作队列</h1><p id="498c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operation" rel="noopener ugc nofollow" target="_blank">操作</a>仅仅是一个要执行的任务。<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank">操作队列</a>类似于<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">分派队列</a>。</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="2bc2" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">let</strong> taskToPerform = BlockOperation {<br/>    // do something<br/>}<br/><strong class="nz iu">let</strong> operationQueue = OperationQueue()<br/>operationQueue.addOperation(taskToPerform)</span></pre><p id="1291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么为什么拥有并使用<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank"> OperationQueue的</a>？他们有几个优势。但是，对于本文的范围，值得强调的是，它们允许管理要执行的任务之间的依赖关系:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="330b" class="oa md it nz b gy oq or l os ot">let prepareLettuceTask = BlockOperation {<br/>    // prepare lettuce<br/>}<br/>let prepareTomatoesTask = BlockOperation {<br/>    // prepare tomatoes<br/>}</span><span id="f0ed" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">prepareTomatoesTask.addDependency(prepareLettuceTask)</strong></span><span id="7f80" class="oa md it nz b gy ow or l os ot">let operationQueue = OperationQueue()<br/>let operationsToPerform = [prepareLettuceTask, prepareTomatoesTask]<br/>operationQueue.addOperations(operationsToPerform, waitUntilFinished: false)</span></pre><p id="1a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以同时执行以下操作:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="e145" class="oa md it nz b gy oq or l os ot">let prepareLettuceTask = BlockOperation {<br/>    // prepare lettuce<br/>}<br/>let prepareTomatoesTask = BlockOperation {<br/>    // prepare tomatoes<br/>}</span><span id="4a8f" class="oa md it nz b gy ow or l os ot">let operationQueue = OperationQueue()<br/><strong class="nz iu">operationQueue.maxConcurrentOperationCount = 2<br/></strong>let operationsToPerform = [prepareLettuceTask, prepareTomatoesTask]<br/>operationQueue.addOperations(operationsToPerform, waitUntilFinished: false)</span></pre><p id="0a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意上面我们已经指定了并发操作的最大数量。如果未指定，它将使用默认值，该值将根据系统的可用资源而变化。另外，请注意，除了没有声明依赖关系之外，代码与前面的示例非常相似。</p><p id="b699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，编写和管理更复杂的操作也更容易。假设您想同时准备生菜和西红柿。但是，只有在这两个操作完成后，您才需要准备红洋葱:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="9793" class="oa md it nz b gy oq or l os ot">let prepareLettuceTask = BlockOperation {<br/>    // prepare lettuce<br/>}<br/>let prepareTomatoesTask = BlockOperation {<br/>    // prepare tomatoes<br/>}<br/>let prepareRedOnionTask = BlockOperation {<br/>    // prepare red onions<br/>}</span><span id="44a9" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">prepareRedOnionTask.addDependency(prepareLettuceTask)<br/>prepareRedOnionTask.addDependency(prepareTomatoesTask)</strong></span><span id="11ab" class="oa md it nz b gy ow or l os ot">let operationQueue = OperationQueue()<br/>operationQueue.maxConcurrentOperationCount = 2<br/>let operationsToPerform = [prepareLettuceTask, prepareTomatoesTask, prepareRedOnionTask]<br/>operationQueue.addOperations(operationsToPerform, waitUntilFinished: false)</span></pre><p id="08f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的场景中，队列将并行或同时执行生菜和西红柿准备。一旦这两个操作完成，队列将执行红洋葱准备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/31e21f1317875c0cfbc7ac6759eb555d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76Ig3qKqnXv2L44ypbNYvg.jpeg"/></div></div></figure><h1 id="a7ad" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">如何使用Swift并发</h1><p id="cab9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swift并发功能最近已经发布。这些功能从Swift 5.5开始提供，从iOS 13也可以使用。</p><p id="223b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift并发特性旨在修复当前使用<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank"> DispatchQueue的</a>和<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operation" rel="noopener ugc nofollow" target="_blank">操作</a>和<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank">操作Queue的</a>进行并发的多种问题。我们将通过例子揭示其中的一些。</p><p id="6d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到制作沙拉的例子。假设我们有一个带有make函数的<code class="fe nw nx ny nz b">SaladMaker</code>类:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="eeb4" class="oa md it nz b gy oq or l os ot">class SaladMaker {<br/>    func make(onCompletion completionHandler: () -&gt; Void) {<br/>        ...<br/>    }<br/>}</span></pre><p id="957d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要按顺序做沙拉。下面是一个使用<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank"> DispatchQueue的</a>的例子:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="6f01" class="oa md it nz b gy oq or l os ot">class SaladMaker {<br/>    func make(onCompletion completionHandler: () -&gt; Void) {<br/>        queue.async {<br/>            // prepare lettuce<br/>            queue.async {<br/>                // prepare tomatoes<br/>                queue.async {<br/>                    // prepare red onion<br/>                    queue.async {<br/>                        // prepare sweetcorn<br/>                        queue.async {<br/>                            // prepare tuna<br/>                            <strong class="nz iu">completionHandler()</strong><br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="629b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个主要问题值得强调:</p><ol class=""><li id="1b39" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">末日金字塔(嵌套闭包)</li><li id="4904" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">你很容易忘记调用<code class="fe nw nx ny nz b">completionHandler</code>而没有注意到</li></ol><p id="8f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Swift并发，上面的代码将如下所示:</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="c49a" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">struct</strong> Salad {<br/>    <strong class="nz iu">func</strong> addIngredient(_ ingredient: Ingredient) {<br/>        ...<br/>    }<br/>}</span><span id="ba83" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">class</strong> SaladMaker {<br/>    <strong class="nz iu">func</strong> make() <strong class="nz iu">async</strong> -&gt; Salad {<br/>        <strong class="nz iu">let</strong> salad = Salad()<br/>        <strong class="nz iu">let</strong> lettuce = <strong class="nz iu">await</strong> <strong class="nz iu">self</strong>.prepareLettuce()<br/>        salad.addIngredient(lettuce)<br/>        <strong class="nz iu">let</strong> tomatoes = <strong class="nz iu">await</strong> <strong class="nz iu">self</strong>.prepareTomatoes()<br/>        salad.addIngredient(tomatoes)<br/>        <strong class="nz iu">let</strong> redOnion = <strong class="nz iu">await</strong> <strong class="nz iu">self</strong>.prepareRedOnion()<br/>        salad.addIngredient(redOnion)<br/>        <strong class="nz iu">let</strong> sweetcorn = <strong class="nz iu">await</strong> <strong class="nz iu">self</strong>.prepareSweetcorn()<br/>        salad.addIngredient(sweetcorn)<br/>        <strong class="nz iu">let</strong> tuna = <strong class="nz iu">await</strong> <strong class="nz iu">self</strong>.prepareTuna()<br/>        salad.addIngredient(tuna)<br/>        <strong class="nz iu">return</strong> salad<br/>    }</span><span id="4e10" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">    private</strong> <strong class="nz iu">func</strong> prepareLettuce() <strong class="nz iu">async</strong> -&gt; Ingredient {<br/>        ...<br/>    }</span><span id="77a3" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">    private</strong> <strong class="nz iu">func</strong> prepareTomatoes() <strong class="nz iu">async</strong> -&gt; Ingredient {<br/>        ...<br/>    }</span><span id="895c" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">    private</strong> <strong class="nz iu">func</strong> prepareRedOnion() <strong class="nz iu">async</strong> -&gt; Ingredient {<br/>        ...<br/>    }</span><span id="fdcc" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">    private</strong> <strong class="nz iu">func</strong> prepareSweetcorn() <strong class="nz iu">async</strong> -&gt; Ingredient {<br/>        ...<br/>    }</span><span id="1c88" class="oa md it nz b gy ow or l os ot"><strong class="nz iu">    private</strong> <strong class="nz iu">func</strong> prepareTuna() <strong class="nz iu">async</strong> -&gt; Ingredient {<br/>        ...<br/>    }<br/>}</span></pre><p id="dd48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码看起来更接近我们的同步代码。可读性得到了提高。此外，Swift编译器能够检查返回值。</p><p id="7ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift并发不仅使异步代码的编码和调试变得更加容易，而且它也是从平台中抽象出来的。<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">调度队列的</a>和<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operation" rel="noopener ugc nofollow" target="_blank">操作</a>和<a class="ae ky" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank">操作队列的</a>依赖于平台。因此，借助<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank"> Swift Concurrency </a>，将您的Swift代码从一个平台移植到另一个平台(即Linux)变得可能且更容易。</p><p id="7b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要通过教程了解更多关于Swift Concurrency的信息，您可以阅读我的博文:</p><div class="pa pb gp gr pc pd"><a href="https://anuragajwani.medium.com/introduction-to-concurrency-swift-with-async-and-await-1d3b03226585" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">带异步和等待的并发Swift简介</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">了解如何使用Swift并发功能</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">anuragajwani.medium.com</p></div></div><div class="pm l"><div class="pt l po pp pq pm pr ks pd"/></div></div></a></div><h1 id="ab3f" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">最后的想法</h1><p id="6159" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">iOS和Swift中的并发性已经很多年没有出现大的变化了。</p><p id="9b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我欢迎Swift 5.5中新增的<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank"> Swift并发</a>功能。快速并发无疑是必由之路。</p><p id="d3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，仅在iOS 13或更新版本上提供支持的警告使得这些功能对于我正在维护和工作的当前产品尚不可用。</p><p id="785a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我期待着有一天我可以在我从事的项目中实现这些功能！</p><pre class="kj kk kl km gt om nz on oo aw op bi"><span id="9ea2" class="oa md it nz b gy oq or l os ot"><strong class="nz iu">Want to Connect With the Author?</strong></span><span id="357a" class="oa md it nz b gy ow or l os ot">For more on iOS development follow me on <a class="ae ky" href="https://twitter.com/anuragajwani?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">Twitter</a></span></pre></div></div>    
</body>
</html>