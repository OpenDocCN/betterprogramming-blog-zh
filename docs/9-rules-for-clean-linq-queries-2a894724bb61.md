# 清洁 LINQ 查询的 9 条规则

> 原文：<https://betterprogramming.pub/9-rules-for-clean-linq-queries-2a894724bb61>

## 让你的 LINQ 查询像一本好书一样可读

![](img/c70f23d70a16ecbc4e9e8348285409ed.png)

照片由[亚伦·伯顿](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在我最近的一篇关于如何编写可读代码的文章中，我提到在大多数情况下，好的 LINQ 查询比任何类型的循环都更可读，也是一个好的替代。对于初学者来说，LINQ 可能需要几天时间来学习，但我发现，在第一次学习 LINQ 查询六年后，我仍然在改进我如何编写它们。

在本文中，我将向您介绍一些在编写 LINQ 查询时要遵守的规则。这些规则将使你的查询像一本书一样可读。

# 1.在每个语句后中断

打破你的代码可以改变你的代码的外观，从一堆垃圾变成一个美丽的艺术品。我发现，垂直阅读代码比水平阅读更快。因此，我至少中断了所有代码行，这将超出半个屏幕。对于 LINQ 查询，我甚至在每个点之前断开它们。这使得它们的可读性更好，逻辑也更清晰，如下所示:

打破 LINQ 的质疑

# 2.缩进每个嵌套层

中断代码后，有时需要调整代码行的缩进级别，因为您的 IDE 可能不会为您这样做。我发现将每个嵌套层多缩进一级是可行的，如下所示:

缩进嵌套层

`ReceivedMessage`的构造函数是一个新的逻辑层，它获得了一个新的缩进级别，你也可以随意地打断和缩进你的参数。

不要忘记断开您的右括号，并将它们移动到与左括号相同的缩进级别。这样，您可以很快地看到，一个语句在哪里结束，一个新的(具有相同的缩进级别)在哪里开始。

# 3.提取更大的方法

有时，在您的`Select` / `SelectMany`子句中可能有复杂的转换规则。你可能想把整个代码都写在 Lambda 函数中。然而，下一个开发者很可能不明白，那里发生了什么。所以为什么不把这部分代码提取到一个单独的方法中呢。您甚至可以省去大括号和 lambda 函数样板代码，因为您可以像这样编写简短的 lambda:

提取方法

# 4.提取复杂的 Where 子句

与第三个类似的情况发生在`Where`从句中。如果你评估一个布尔值，一切都是好的。但是，如果有两个或两个以上，你的意图就会淡化。下一个开发者将很难理解，你想在这里过滤什么。要解决这个问题，只需将 lambda 提取到一个本地函数中，并给它一个好名字，如下所示:

提取谓词

# 5.制作自己的扩展方法

LINQ 已经提供了非常有用的扩展方法。然而，仍然可能有一些函数非常有用，并且还没有包含在默认库中。例如，我在微软将扩展方法`DistinctBy()`包含进来之前就创建了它。NET 6。

我在 LINQ 特别怀念的是对任务和异步代码的更好处理。为了让生活变得简单一点，我实现了以下扩展方法:

LINQ 的异步扩展方法

它们使异步 LINQ 方式更容易处理，正如您在这里看到的:

异步扩展的应用

# 6.Lambda 变量使用单个字符

几乎在每一个干净代码指南中，你都会读到你应该提供命名良好的变量和方法。但是，在这种情况下，我敢反驳。LINQ 查询在水平方向上通常比您通常的代码长一点。当你现在试图给每个 lambda 变量起一个好名字时，你的代码行肯定会变得更长，你可能会重复使用你的变量，你可能会发现你的代码更难破解。

我发现这是可行的，只使用类的第一个字母，你想传递给函数。无论如何，源可枚举变量的意图应该是清楚的。这就是为什么你应该特别注意这个可枚举的名字。看看这个例子:

使用单字符命名

变量的类型和意图从它的源可枚举中变得清晰，我们节省了一些字符，我们甚至可以直接看到哪个变量用于 lambda 函数。

# 7.总是期望 IEnumerable 作为参数

你的项目中的每一个期望某种`IEnumerable`的方法应该总是声明它期望这样。当你真的不需要时，不要期待一个`Array`或`List`或其他什么(尽管你仍然可以把它传递给方法)。我在我的项目中发现的唯一例外是`HashSets`和`Dictionaries`。此外，当您明确想要一个已经枚举的`IEnumerable`时，您可以根据自己的喜好期待一个特定的类型。

你应该建立一个规则，永远不要把`null`当作`IEnumerable`来传递。用`Enumerable.Empty<T>()`就可以空着`IEnumerable`过去了。这样，您将大大减少 NullReferenceExceptions，并且您的代码不会中断。通常你甚至不需要担心空的可枚举数，因为你的 LINQ 查询也可以使用空的。

# 8.总是转换不可变的

对于干净编码来说，不变性是一个极其重要的概念。这基本上意味着你不能通过设计来改变任何对象的状态。有时候当然可以，但是一定不能！特别是在你的`Select()`查询中，你必须注意不要改变你的源的任何状态。通过这种方式，您可以确保多次枚举查询，而不会改变结果。看看下面的例子:

非不可变转换示例

如果您第一次枚举它，流将被读取，然后被释放，从而改变源的状态！如果你试着再列举一次，你会得到一个`ObjectDisposedException()`，它不是太明显，你做错了。

# (9.)注重执行力——业绩

最后但同样重要的是，您应该记住 LINQ 查询是如何执行的。我承认，这一点为了性能可能会降低可读性，这也是我把它放在括号里的原因。

很容易发生这样的情况，你迭代整个`IEnumerables`的次数比你真正需要的要多一些。许多 Leetcode 练习的特点是优化迭代，从而降低时间和空间的复杂性。如果您想优化查询，一个很好的问题是:

我可以在这里使用哈希表或字典吗？

通常，您可以通过使用其中一个来降低时间复杂度，因为它们具有`O(1)`时间复杂度。

另外，一个大大提高 LINQ 查询性能的好方法是使用`.AsParallel()`。这将您的 LINQ 查询引入到一个 [PLINQ](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq) 查询中，其中所有的事情都在您的 CPU 上并行运行。在这里，您应该特别注意不变性，不要依赖于其他变化的状态，因为并行化只能有效地用于独立查询。

只有当您有非常长时间运行的查询时，您才应该使用 PLINQ，因为它甚至会降低某些本来会更快的查询的速度。

感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。

如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在 C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。

祝你有美好的一天！

![](img/429378e6a7aee01df92851fb0e90e385.png)

如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助 Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:

[*现在加入中等*](https://medium.com/@tobias.streng/membership)

通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。