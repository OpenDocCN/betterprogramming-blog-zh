<html>
<head>
<title>4 Ways to Use Dynamic Remotes in Module Federation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在模块联合中使用动态远程的4种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-ways-to-use-dynamic-remotes-in-module-federation-985e9fb69817?source=collection_archive---------10-----------------------#2022-07-11">https://betterprogramming.pub/4-ways-to-use-dynamic-remotes-in-module-federation-985e9fb69817?source=collection_archive---------10-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何动态配置联邦远程模块的URL。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/986d15d61a4be6074ada3bb32e29785a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CojpBHvb1AcQvSad"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mourimoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mourizal Zativa </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何将相同的微前端应用程序部署到测试、试运行和生产环境中？您的应用程序如何同时支持本地、云和混合部署？如何扩展同时在架构的不同部分工作的多个团队？动态引入新的远程应用程序？</p><p id="e4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是动态定义的远程应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么使用动态遥控器？</h1><p id="102d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在之前的<a class="ae ky" href="https://medium.com/better-programming/how-to-use-webpack-module-federation-in-react-70455086b2b0" rel="noopener">文章</a>中，我们讨论了在主机远程配置中使用Webpack模块联合来配置一个简单的React应用程序。当我们为远程应用程序定义URL时，我们使用本地主机URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="17ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上对于本地开发来说非常有效，但是如果我们部署和托管应用程序，这就行不通了。当然，我们可以用产品URL替换字符串——但是本地开发会发生什么呢？我们是否一直手动来回切换，希望没有人合并到错误的URL中？</p><p id="0a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有多个不同URL和环境的部署阶段，这种模式也不起作用。如果我们不能在部署管道中的隔离环境中测试远程应用，当开发人员引入突破性变化时，我们会陷入混乱和沮丧。每个人都会对开发流程失去信心。</p><p id="854e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代替<code class="fe nb nc nd ne b">localhost</code>,我们希望根据环境动态定义URL来指向正确的主机。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bb4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Webpack模块联盟中的动态远程</h1><p id="9ae7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">幸运的是，Webpack模块联盟支持为我们的远程应用程序动态定义URL。我们将考虑四种可用的解决方案:</p><ol class=""><li id="662e" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">环境变量</li><li id="245f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">网络包<code class="fe nb nc nd ne b"><a class="ae ky" href="https://www.npmjs.com/package/external-remotes-plugin" rel="noopener ugc nofollow" target="_blank">external-remotes-plugin</a></code></li><li id="8d11" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">基于承诺的动态遥控器:<a class="ae ky" href="https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="93c2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">动态远程容器:<a class="ae ky" href="https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers" rel="noopener ugc nofollow" target="_blank">文档</a></li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5fae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.环境变量</h1><p id="0ad5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最直接的选择是在构建时使用环境变量。您可以在本地或部署管道中用环境变量替换Webpack配置中的<code class="fe nb nc nd ne b">localhost</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在构建时将每个远程应用程序的URL定义为本地或托管生产部署。这种方法的优点是简单，但有一个问题。我们需要为每个环境构建一个新版本来更新URL。对于我们的企业用例以及多种部署模型，这是行不通的。</p><p id="b540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您可以在运行时更改远程URL会怎么样？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="52c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.Webpack外部远程插件</h1><p id="a4b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在幕后，模块联合允许我们动态加载远程容器。我们一会儿会谈到这一点。但是首先，有一个方便的Webpack插件是由模块联盟的创造者之一Zack Jackson开发的，叫做T1。它允许我们在运行时使用模板来解析URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="20ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在从远程应用程序加载任何代码之前，您需要做的就是在应用程序中定义<code class="fe nb nc nd ne b">window.appAUrl</code>和<code class="fe nb nc nd ne b">window.appBUrl</code>。</p><p id="674b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以灵活地定义你的网址。例如，您可以为每个环境维护一个主机URL到远程URL的映射，使用服务器端呈现来允许后端定义URL，创建一个定制的配置管理服务，以及许多其他方法。</p><p id="768f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法是完全动态的，可以解决我们的用例，但是这种方法仍然有一点限制。我们无法完全控制装载生命周期。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0ff8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.基于承诺的动态遥控器</h1><p id="e61c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">模块联合允许我们将远程URL定义为承诺，而不是URL字符串。你可以使用任何承诺，只要它符合模块联盟定义的<code class="fe nb nc nd ne b">get/init</code>接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="eac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个承诺中，我们创建了一个新的脚本标记，并将其注入DOM以获取远程javascript文件。<code class="fe nb nc nd ne b">window.appAUrl</code>包含远程应用程序的URL。</p><p id="b3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Webpack远程配置仍然必须是字符串格式，所以我将promise与配置分开定义，并在稍后将其字符串化，以提高可读性。不幸的是，这种方法不是最容易调试或维护的，因为它是配置文件中的字符串化代码。</p><p id="4ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，所有的方法都有另一个限制。我们仅限于加载<code class="fe nb nc nd ne b">RemoteA</code>和<code class="fe nb nc nd ne b">RemoteB</code>应用，这可能是一个安全优势。但是如果一个开发者正在开发一个我们还不知道存在的新的远程应用呢？如果合作伙伴或客户希望将他们的远程模块注入到我们应用的部署中，该怎么办？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d7d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.动态远程容器</h1><p id="f4da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">模块联合允许我们以编程方式加载远程应用程序，而无需在我们的Webpack配置中定义任何URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是怎么做呢？</p><p id="a32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面的方法类似，在您尝试加载任何远程应用程序之前，您首先需要使用动态脚本标签获取远程模块。然后，您可以手动初始化远程容器。</p><p id="655d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<a class="ae ky" href="https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers" rel="noopener ugc nofollow" target="_blank"> Webpack文档:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">container</code>指的是我们在主机应用的Webpack配置中的<code class="fe nb nc nd ne b">"remotes"</code>字段中配置的远程应用。</p><p id="50cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">module</code>是指我们在远程应用的Webpack配置的<code class="fe nb nc nd ne b">"exposes"</code>字段中定义的项目之一。</p><p id="339b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用注入脚本标签的方法，您可以获取远程容器并将其存储在<code class="fe nb nc nd ne b">window.someContainer</code>中，只要代码解析为我们之前使用的相同的<code class="fe nb nc nd ne b">get/init</code>模式。</p><p id="76e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您想要使用我们的远程应用程序公开的模块之一时，您需要做的就是像上面的例子那样调用:<code class="fe nb nc nd ne b">container.get(moduleName)</code>。</p><p id="46d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想像我们在基本的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-webpack-module-federation-in-react-70455086b2b0"> React主机-远程应用</a>中所做的那样加载React远程应用，这看起来像什么？</p><p id="25de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我的另一篇文章中的例子:</p><div class="nt nu gp gr nv nw"><a href="https://medium.com/@oskari.rautiainen/rendering-dynamic-remote-containers-in-a-react-micro-frontend-1dd97019824f" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">在React微前端中呈现动态远程容器</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">我们如何在一个React微前端应用程序中安全、方便地使用Webpack模块联盟的动态远程容器…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5df4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="5d18" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用动态加载的遥控器，您已经学习了四种不同的机制来分解您的微前端部署。当您部署我们的微前端时，您可以从您定义的任何URL获取您的远程应用程序。您可以将它部署到多个测试环境、内部或云中。开发人员可以选择是使用其他远程应用程序的生产版本，还是动态引入新版本。</p><p id="bdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会选择哪种方法？</p></div></div>    
</body>
</html>