<html>
<head>
<title>Simulate Recursion Using Java Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java流模拟递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simulate-recursion-using-java-streams-9219c834957e?source=collection_archive---------7-----------------------#2021-01-18">https://betterprogramming.pub/simulate-recursion-using-java-streams-9219c834957e?source=collection_archive---------7-----------------------#2021-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逼近平方根的Bakhshali方法的函数实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e75b851d7e28f0eff47159ec3ecf8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqJhpPcIFo3LJ7KHQ0aIHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">巴赫沙里手稿。国家地理，公共领域，通过维基共享</p></figure><p id="a6cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一篇文章<a class="ae lu" href="https://levelup.gitconnected.com/rethinking-structured-programming-7c0ae2f73b90" rel="noopener ugc nofollow" target="_blank">重新思考结构化编程</a>中，我谈到了在Java中使用流和反应式函数编程作为结构化编程中的控制结构。我描述了一个我认为目前无法用流或通量的特征解决的问题:如果一个函数的输出是同一个函数迭代的输入。这描述了一种特殊类型的递归——尾递归——它可以变成一个循环。但是在我所有的例子中，一个阶段的输出总是下一个阶段的输入。一个阶段绝不会仅仅通过将其输出传递回其输入来进行迭代。</p><p id="8c64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原来有一个Java <code class="fe lv lw lx ly b">Stream</code>类的方法，<code class="fe lv lw lx ly b">iterate</code>，它就是这样做的。在我的上一篇文章中，我使用了<a class="ae lu" href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method" rel="noopener ugc nofollow" target="_blank">巴比伦</a>方法来计算近似平方根，作为这类问题的一个例子。所以，我决定试试能否用<code class="fe lv lw lx ly b">iterate</code>函数实现它。</p><p id="fb71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">iterate</code>函数是<code class="fe lv lw lx ly b">Stream</code>类的静态方法。它返回一个由种子值和一个<code class="fe lv lw lx ly b">Unary</code>函数计算得到的无限流，这个函数接受一个值并返回一个相同类型的值。在我们的例子中，类型将是一个<code class="fe lv lw lx ly b">double</code>。</p><p id="042a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过使用<code class="fe lv lw lx ly b">Random.doubles(int size)</code>方法生成一个随机的<code class="fe lv lw lx ly b">Stream</code>双精度浮点数。我将创建一个包含15个doubles的流来测试它。我可以使用流的<code class="fe lv lw lx ly b">forEach</code>方法，因为这将是一个终端任务，即只计算值并打印出来。因此，代码以下面的代码开始和结束:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3e84" class="md me it ly b gy mf mg l mh mi">public class Recurse {<br/>    public static void main(String [] args) {<br/>        Random random = new Random();<br/>        random.doubles(15)<br/>           .forEach(s -&gt; {<br/>...<br/>            });<br/>    }<br/>}</span></pre><p id="78ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将调用<code class="fe lv lw lx ly b">lambda</code>方法15次，随机双精度15次。我们将用它来测试我们的新方法。</p><p id="6631" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会用巴比伦的方法。我将使用古印度数学手稿<a class="ae lu" href="https://en.wikipedia.org/wiki/Bakhshali_manuscript" rel="noopener ugc nofollow" target="_blank"> Bakhshali手稿</a>中描述的<a class="ae lu" href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Bakhshali_method" rel="noopener ugc nofollow" target="_blank"> Bakhshali方法</a>。它浓缩了巴比伦方法的两次迭代，并将四次分解。基本公式是，如果<code class="fe lv lw lx ly b">S</code>是你想要求平方根的数字，<code class="fe lv lw lx ly b">x</code>是一个种子近似值，<code class="fe lv lw lx ly b">intermediate a</code>是<code class="fe lv lw lx ly b">S minus x squared divided by 2x</code>。<code class="fe lv lw lx ly b">Intermediate b</code>是<code class="fe lv lw lx ly b">x plus a</code>。最后，新的近似值是<code class="fe lv lw lx ly b">b minus a squared divided by 2b</code>。不要让我解释，我只是个程序员。</p><p id="1ebd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，这个函数的<code class="fe lv lw lx ly b">Unary</code>应该是:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1ad8" class="md me it ly b gy mf mg l mh mi">double a = (s-(x*x))/(2*x);<br/>double b = x + a;<br/>return b - (a*a)/(2*b);</span></pre><p id="1ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用了很多括号，因为我从来不记得运算符优先级。</p><p id="9fe7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以把它放入迭代函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d5d0" class="md me it ly b gy mf mg l mh mi">Stream.iterate(0.1, x -&gt; {<br/>                    double a = (s-(x*x))/(2*x);<br/>                    double b = x + a;<br/>                    return b - (a*a)/(2*b);<br/>                })</span></pre><p id="22c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">种子值是任意的；您可以使用任何东西，但是您越接近实际值，您需要的迭代次数就越少。我们所有的值都是介于0.0和1.0之间的双精度值。</p><p id="069e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像现在这样，不会有任何好处，因为它会创造一个永无止境的双价值流。我准备用<code class="fe lv lw lx ly b">dropWhile</code>的方法，当近似平方根的平方非常接近原始数的时候，结束它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="87b0" class="md me it ly b gy mf mg l mh mi">dropWhile(x -&gt; Math.abs((x*x)-s) &gt; 0.00000001)</span></pre><p id="da11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还将对迭代次数进行硬性限制，以防不收敛。把所有这些放在一起，你得到这个:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="11c9" class="md me it ly b gy mf mg l mh mi">double r = Stream.iterate(0.1, x -&gt; {<br/>  double a = (s-(x*x))/(2*x);<br/>  double b = x + a;<br/>  return b - (a*a)/(2*b);<br/>})<br/>.limit(1000) // force a limit<br/>.dropWhile(x -&gt; Math.abs((x*x)-s) &gt; 0.00000001)<br/>.findFirst() // returns Optional&lt;Double&gt;<br/>.orElse(Double.NaN);<br/>System.out.println("calculated square root of "<br/>   + s<br/>   + " = " <br/>   + r);<br/>System.out.println("math lib square root of "<br/>   + s<br/>   + " = " <br/>   + Math.sqrt(s));</span></pre><p id="8d5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将上面的内容放入产生15个doubles的<code class="fe lv lw lx ly b">forEach</code>并运行它，您可以看到输出并确认我们的计算值等于由<code class="fe lv lw lx ly b">Math.sqrt</code>返回的值。</p><p id="7c48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是使用函数式编程抽象出控制结构的另一个例子。像<code class="fe lv lw lx ly b">iterate</code>这样的方法是一元的:它们旨在充当函数的流机制，并且可以链接在一起以产生期望的结果。如果你知道你的一元函数，你将能够最大限度地使用像<code class="fe lv lw lx ly b">Stream</code>和<code class="fe lv lw lx ly b">Flux</code>这样的类型。</p></div></div>    
</body>
</html>