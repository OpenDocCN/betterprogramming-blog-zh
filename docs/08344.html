<html>
<head>
<title>Applying the Liskov Substitution Principle in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">里斯科夫替代原理在React中的应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/applying-the-liskov-substitution-principle-in-react-3a0614a42a08?source=collection_archive---------4-----------------------#2021-04-20">https://betterprogramming.pub/applying-the-liskov-substitution-principle-in-react-3a0614a42a08?source=collection_archive---------4-----------------------#2021-04-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="cc98" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">看看实际应用中的可靠原则</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4d0c10d463b7922966f0ffaee68ce0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrqL7YcbIJCjWKBWOPnN0g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/photo/white-wooden-table-with-chairs-in-a-room-4064835/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>拍摄。</p></figure><p id="2f8c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SOLID是一组原则，用于指导创建一个干净的、可维护的、更少错误的应用程序。</p><p id="c404" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，我们将深入探讨固体的第三个原理:利斯科夫替代原理。我们将试图理解这个原则如何帮助我们创建一个更好、更干净的React应用程序。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5fc6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">本系列的其他文章</h1><ol class=""><li id="7b8c" class="mv mw iu lc b ld mx lg my lj mz ln na lr nb lv nc nd ne nf bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-solid-principles-to-clean-your-code-in-react-cdfd5e0a9cea">单一责任原则</a></li><li id="5e6b" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40">开启关闭原理</a></li><li id="b669" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d">界面分离原理</a></li><li id="6658" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/apply-the-dependency-inversion-principle-in-react-c20a0afc3d64">依存倒置原则</a></li></ol></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="24ef" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">什么是利斯科夫替代原理？</h1><p id="9315" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">简单来说，这个原则就是:</p><blockquote class="no"><p id="c139" class="np nq iu bd nr ns nt nu nv nw nx lv dk translated">"子类应该可以替代它们的超类."</p></blockquote><p id="c32a" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">这意味着一个特定类的子类应该能够在不破坏任何功能的情况下替换超类。</p><h2 id="766f" class="od me iu bd mf oe of dn mj og oh dp mn lj oi oj mp ln ok ol mr lr om on mt oo bi translated">例子</h2><p id="f5ad" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">如果<code class="fe op oq or os b">PlasticDuck</code>是<code class="fe op oq or os b">Duck</code>的子类，那么我们应该能够用<code class="fe op oq or os b">PlasticDuck</code>替换<code class="fe op oq or os b">Duck</code>的实例，而不会有任何意外。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/b9b0d0e09065b929ecb03deb2bc8303f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRfUFxV7oKEEJAI9X9BdEA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来源:马克西姆·伊万诺夫</p></figure><p id="6cf5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着<code class="fe op oq or os b">PlasticDuck</code>应该满足<code class="fe op oq or os b">Duck</code>班设定的所有期望。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6cae" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">这在React中是什么意思？</h1><p id="e65f" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">React不是一个面向对象的框架，因为它基本上是JavaScript。在React的上下文中，该原则背后的主要思想是:</p><blockquote class="no"><p id="12d1" class="np nq iu bd nr ns nt nu nv nw nx lv dk translated">"组件应该遵守某种契约."</p></blockquote><p id="61bc" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">其核心是，这意味着组件之间应该有某种契约。因此，无论何时一个组件使用另一个组件，它都不应该破坏它的功能(或者制造任何意外)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="426b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">让我们更深入地探讨一下</h1><p id="1cea" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">我们来看一个<code class="fe op oq or os b">ModalHolder</code>组件。该组件将<code class="fe op oq or os b">contentToShow</code>作为道具，显示在一个模态中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">ModalHolder.jsx</p></figure><p id="a594" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里的问题是什么？</p><p id="52e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯，现在的问题是对于可以传递给<code class="fe op oq or os b">ModalHolder</code>组件的内容没有限制。任何东西都可以通过变量<code class="fe op oq or os b">contentToShow</code>传递给它。</p><p id="6d81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，让我们检查一下我们的代码是否正常工作，一切是否如预期的那样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">App.jsx</p></figure><p id="aad5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，如果您打开模式，它将正常工作，并向您显示模式:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/6a7215fda8f8f01202d8f34d46d02f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej45FJzyv9mtFXh3QtAeGA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">显示模态</p></figure><p id="9c72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们利用前面描述的缺陷，看看它如何破坏我们的应用程序。</p><p id="b9b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们试着将一个对象传递到<code class="fe op oq or os b">ModalHolder</code>中，看看会发生什么:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">App.jsx</p></figure><p id="6188" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这段代码非常好，不会出现编译错误。现在让我们打开应用程序，看看单击按钮会发生什么:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/f52f29d076155d7e922b1c16a9da2b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67ENRHAiKBwYpndTSVFT-w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">错误</p></figure><p id="b61b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，即使我们的代码没有错误，我们的应用程序也会崩溃。这里出了什么问题？</p><p id="0d08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的<code class="fe op oq or os b">Modal</code>组件允许包含另一个React组件。但是由于没有合同，其他组件不会被绑定。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="948e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">有什么解决办法？</h1><p id="b840" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">现在我们将看到在我们的应用程序中使用TypeScript的重要性以及它为什么重要。让我们将<code class="fe op oq or os b">ModalHolder</code>组件重构为TypeScript，看看会发生什么:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">ModalHolder.tsx</p></figure><p id="b771" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以现在我们已经重构了我们的组件，只有当它得到一个<code class="fe op oq or os b">JSX.Element</code>时才接受属性<code class="fe op oq or os b">contentToShow</code>。</p><p id="f3ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果有人想要传递任何不是有效组件的内容来呈现，我们会得到一个错误:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/ebf7010be9e585e687e1b101b3301332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4d0iPlF-h1CFJkWHSkiIg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">ModalHolder的有效用法</p></figure><p id="7dc0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">瞧啊。现在，所有其他想要插入到<code class="fe op oq or os b">ModalHolder</code>组件中的组件都需要遵循一个契约，这样它们就不会产生任何意外的行为。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c627" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我们做到了吗？</h1><p id="2cb8" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">我们以这样一种方式设计了我们的<code class="fe op oq or os b">ModalHolder</code>组件，使用这个组件的子组件不能创建任何意外的行为，因为它们必须遵守父组件设置的规则。</p><p id="f531" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这正是<strong class="lc iv">利斯科夫替代原理</strong>的全部内容。</p><p id="dfc9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以是的，我们做到了！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="793e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你喜欢这篇文章，就像我喜欢写它一样。</p><p id="487c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面留下你的想法。祝你今天愉快，:D</p><p id="ac17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">有话要说？通过</strong><a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a>联系我</p><div class="oz pa gq gs pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd iv gz z fq ph fs ft pi fv fx it bi translated">如何在反应堆中应用界面分离原理</h2><div class="pj l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">行动中的坚实原则</h3></div><div class="pk l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">better编程. pub</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kt pc"/></div></div></a></div></div></div>    
</body>
</html>