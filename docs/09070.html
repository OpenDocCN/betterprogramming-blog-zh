<html>
<head>
<title>Exploring Kotlin Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索科特林函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-kotlin-functions-af8a345ba85e?source=collection_archive---------3-----------------------#2021-07-13">https://betterprogramming.pub/exploring-kotlin-functions-af8a345ba85e?source=collection_archive---------3-----------------------#2021-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c52b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">中缀、内联等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed0cd521f6c56fa5bd65a259774dac3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SNQ6EPf5tiipDMzP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克·赖歇尔在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><h1 id="c847" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="0163" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">随着Kotlin在Android开发中的引入，我们最终都会得到那些包含我们在Android应用程序开发中使用的各种函数的Util文件。</p><p id="370f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Util files并不是一个新的产品，但是Kotlin的功能性使它比以前更加精致和优化。我们都知道Kotlin是一种面向对象的函数式编程语言。</p><p id="92d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据我的经验，我已经使用Kotlin的面向对象功能来创建基类和实现复杂的架构。但说到功能性能力，Kotlin要方便得多。它减少了样板代码，提高了代码的可读性和重用性。</p><p id="b53b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，我决定写一篇文章来记录我使用的所有函数类型。我们开始吧！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="edc0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">扩展功能</h1><p id="7662" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过扩展函数，Kotlin提供了用新功能扩展类的能力，而不必继承类或使用设计模式。作为一名迁移到Kotlin的Java开发人员，这个特性似乎好得难以置信——但它是真实的。</p><p id="6447" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我迄今为止使用的所有扩展函数中，我喜欢显示、移除和隐藏函数，如下所示:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3aae" class="nj la it nf b gy nk nl l nm nn">fun View.remove() {<br/>    if (visibility != View.GONE) visibility = View.GONE<br/>}<br/><br/>fun View.show() {<br/>    if (visibility != View.VISIBLE) visibility = View.VISIBLE<br/>}<br/><br/>fun View.hide() {<br/>    if (visibility != View.INVISIBLE) visibility = View.INVISIBLE<br/>}</span></pre><p id="af04" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">扩展函数不仅提高了代码的可重用性，还使Kotlin更加易读和简洁。强烈推荐你阅读这两篇文章，了解Android开发中更有用的扩展函数:</p><ul class=""><li id="9c55" class="no np it lt b lu mn lx mo ma nq me nr mi ns mm nt nu nv nw bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/5-kotlin-extensions-to-make-your-android-code-more-expressive-4c9243cb9466"> 5个Kotlin扩展，让您的Android代码更具表现力</a></li><li id="e095" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated">来自KTX库的5个强大的Kotlin扩展</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="d55b" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">在一条直线上的</h1><p id="dd80" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Kotlin中，扩展函数、lambads等作为对象存储。所以它们消耗内存，虚拟调用会引入运行时开销。我们有时可以通过内联函数代码来消除内存开销。</p><p id="d0b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">内联函数是用关键字<code class="fe oc od oe nf b">inline</code>声明的。内联函数的使用增强了Kotlin的性能。<em class="of">内联函数告诉编译器将参数和函数复制到调用点。</em></p><p id="7b0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">很少有人认为在上面使用的扩展函数上使用inline是有意义的，这样它们就可以被移动到调用站点而不是存储为对象。看一看:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e889" class="nj la it nf b gy nk nl l nm nn">inline fun View.remove() {<br/>    if (<em class="of">visibility </em>!= View.<em class="of">GONE</em>) <em class="of">visibility </em>= View.<em class="of">GONE<br/></em>}<br/><br/>inline fun View.show() {<br/>    if (<em class="of">visibility </em>!= View.<em class="of">VISIBLE</em>) <em class="of">visibility </em>= View.<em class="of">VISIBLE<br/></em>}<br/><br/>inline fun View.hide() {<br/>    if (<em class="of">visibility </em>!= View.<em class="of">INVISIBLE</em>) <em class="of">visibility </em>= View.<em class="of">INVISIBLE<br/></em>}</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="c1df" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">跨线</h1><p id="04c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe oc od oe nf b">Crossinline</code>允许你标记一个lambda，禁止它使用非本地返回。实际上，<code class="fe oc od oe nf b">inline</code> lambdas将<code class="fe oc od oe nf b">return</code>解释为非本地返回，而<code class="fe oc od oe nf b">return</code>在非内联的lambdas上是不允许的。看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="80d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是上述程序的输出:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6827" class="nj la it nf b gy nk nl l nm nn">Hello, Main!! <br/>Hello</span></pre><p id="4d85" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不打印<code class="fe oc od oe nf b">main finished</code>的原因是inline lambdas将<code class="fe oc od oe nf b">return</code>解释为非本地返回。现在当你改成crossinline的时候，就不允许在里面返回了，这就允许编译器执行最后一条语句。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="b2d2" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">中缀</h1><p id="4621" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe oc od oe nf b">infix</code>符号允许我们快速调用单参数函数。为了创建一个<code class="fe oc od oe nf b">infix</code>函数，需要两个参数。第一个参数是目标对象，第二个参数是传递给函数的实际参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="68a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建<code class="fe oc od oe nf b">infix</code>函数就像创建<code class="fe oc od oe nf b">inline</code>函数一样。语法上唯一的区别是我们使用了<code class="fe oc od oe nf b">infix</code>关键字而不是<code class="fe oc od oe nf b">inline</code>。现在，让我们看看如何调用<code class="fe oc od oe nf b">infix</code>函数。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="35e1" class="nj la it nf b gy nk nl l nm nn">val fruit = Fruit()                       <br/>fruit type "apple"</span></pre><p id="4a30" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在中缀函数的帮助下，我们可以使代码更加易读和简洁。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="73f5" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">高阶的</h1><p id="53f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可作为参数传递或可从函数返回的函数称为<em class="of">高阶函数。</em>换句话说，高阶函数就是以函数为参数或者返回函数的函数。</p><p id="bc41" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不管您在哪个平台上开发，这些类型的函数都非常方便。作为一名Android开发人员，我发现高阶函数可以非常方便地代替点击监听器并将函数作为参数传递。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="7671" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">嵌套函数</h1><p id="f60d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以在另一个函数中编写一个函数，类似于Python中的嵌套函数。嵌套函数的作用域是外部函数，只有外部函数可以包含嵌套函数。内部函数不受函数外部发生的任何事情的影响:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f85d" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">具有默认值和命名参数的函数</h1><p id="1f2f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Kotlin有许多有用和被低估的功能，我敢肯定这是其中之一。</p><p id="5a56" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们要写一个计算两个值之和的函数。这里棘手的部分是用户可以传递两个值或其中任何一个值，或者什么都不传递。我确信Java可以处理它，但不像Kotlin那样优雅和简单。看一看:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="374b" class="nj la it nf b gy nk nl l nm nn">fun add(a : Int = 0, b : Int = 0) =  a + b</span></pre><p id="fd65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这不是很棒吗——一个参数有默认值的函数！您可以根据自己的需要只传递<code class="fe oc od oe nf b">a</code> <strong class="lt iu"> </strong>或<code class="fe oc od oe nf b">b</code> <strong class="lt iu"> </strong>值。要传递特定的参数，我们可以使用Kotlin中的命名参数特性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="31fe" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">λ表达式</h1><p id="5a00" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Lambda是函数的最简单形式，只有一行表达式(大多数情况下)。在Kotlin中，lambda函数用花括号<code class="fe oc od oe nf b">{}</code>括起来。Lambda函数不像普通函数那样有<code class="fe oc od oe nf b">fun</code>关键字或任何访问修饰符(public、private和protected)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kotlin中的简单lambda函数</p></figure><p id="c5e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Kotlin中的lambda函数没有返回类型，但我们可以传递参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="3ebf" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">通用函数</h1><p id="aba6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">泛型是Kotlin中最强大的特性之一。我们可以创建一个泛型类、函数或属性，并用不同的数据类型访问它们，同时确保编译时的类型安全。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="bcbf" class="nj la it nf b gy nk nl l nm nn">fun &lt;T&gt; genericFunc(objects: T) {<br/>    // Do whatever<br/>}</span></pre><p id="179e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我最常用的一个通用函数包括从包中检索数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c46a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这看起来很简单，但它减少了开发人员的大量工作，提高了代码的可读性和简洁性，所有这些都是通过几个函数实现的。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="51fb" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">奖金</h1><p id="f876" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你对科特林感兴趣，我强烈推荐你阅读以下文章:</p><ul class=""><li id="8009" class="no np it lt b lu mn lx mo ma nq me nr mi ns mm nt nu nv nw bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“使用Kotlin进行高级编程</a>”</li><li id="2815" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated"><a class="ae ky" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">“使用Kotlin进行高级编程—第3部分</a>”</li><li id="068c" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated"><a class="ae ky" href="https://medium.com/@sgkantamani/sealed-classes-in-kotlin-e48e072daca8" rel="noopener">科特林</a>中的密封类<strong class="lt iu"/></li></ul><p id="351d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我最近看到了一篇由<a class="ae ky" href="https://medium.com/u/d255c4fc9d76?source=post_page-----4c9f44d04e68--------------------------------" rel="noopener"> Satya Pavan Kantamani </a>发表的关于Android中的ExoPlayer的优秀文章，强烈推荐:</p><div class="oi oj gp gr ok ol"><a href="https://levelup.gitconnected.com/customize-exoplayer-overlay-look-like-youtube-player-14fdd6d4583d" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">自定义ExoPlayer覆盖看起来像Youtube播放器</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">为ExoPlayer创建自定义UI元素</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="a8c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>