# JavaScript 中的动态模块导入:方法和原因

> 原文：<https://betterprogramming.pub/dynamic-module-imports-in-javascript-the-how-and-why-9a47114119c>

## 不要在第一次加载时加载那些不必要的大文件

![](img/ea47ddba6883a63479dff5ad5ce5a80f.png)

照片由[温斯顿陈](https://unsplash.com/@winstonchen?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

如果你想让你的代码更快更有性能，动态模块导入扮演了一个非常重要的角色。大多数时候，你不需要一次加载所有那些又重又大的文件。如果我们能在需要的时候导入这些文件，那将会非常有帮助。

动态模块导入在这里可以成为救世主。在本文中，我们将讨论什么是动态模块导入，以及它们非常有用的一些用例。

首先，让我们看一下这两个文件。

我们可以看到，我们有这两个简单的 js 文件:`user.js` **、**和`script.js`。

`user.js`有一个名为`User`的类，它接受两个属性:`first`名和`last`名，还有一个简单的`printUser`函数，它将简单地在控制台中打印全名。

`script.js` 有一个标准的`import`语句，从`user.js`导入`User`和`printUser`。之后我们创建了一个新用户，名字`first`为`Gourav`，名字`last`为`Kajal`，然后我们调用`printuser`函数在控制台打印用户名。非常简单。

这就是我们大多数时候在代码中使用 import 语句的方式。现在，这段代码目前的工作方式是，我们的浏览器将首先下载`script.js`，然后在页面加载后立即下载`user.js` 。即使你使用的是像 Webpack 这样的捆绑器，这两个文件也会合并在一起，新文件会在页面加载时下载。无论发生什么，所有的`user.js` 代码和所有的`script.js`代码都会在页面加载后立即下载。

现在，使用动态模块导入，我们可以做的是稍后下载应用程序的一些代码，或者根本不下载代码。

现在，让我们看看如何将其转换为动态模块导入。这其实很简单。

这里，我们没有使用`import`语句，而是使用了`import()`函数，它接受一个参数，即文件路径，并返回一个`promise`。所以我们使用了`then`并析构了从`user.js`返回的任何东西，然后简单地将我们的代码移到那个块中。现在，`user.js`将在我们调用该函数时被加载，而不是初始加载。

为了测试这一点，我将导入函数放在一个超时内，以便在页面加载后，它将等待五秒钟，然后将加载`user.js`。即使您有捆绑器，`user.js`也不会与`script.js`结合，在初始页面加载时，只会加载`script.js`，五秒钟后会加载`user.js`。

这是动态模块导入的基本思想和理解。使用它，你的 web 应用程序将加载得更快，因为它不必下载所有不必要的代码。

现在，让我们看看动态模块导入有用的一些用例。

# 示例 1:代码分割

作为一名开发人员，我们试图将我们的代码分成尽可能多的包，这样我们就可以下载最少的代码。如果你需要额外的代码，你可以随时下载。这就是我们要通过动态模块导入实现的目标。

为了完全理解它，让我们看一下我们的`script.js`文件:

同样，这是一个超级简单的文件。正如我们所见，我们从`admin.js`导入了一个名为`setupAdminUser()`的函数。现在，如果用户是管理员，我们将调用这个函数。这是正常导入的样子。

这种方法的问题是，不管用户实际上是什么类型，`admin.js`总是会被下载。但是只有当它是管理员用户时才会被执行。因此，可能对于大多数用户来说，我们只是不必要地下载这个文件，它可能包含大量的代码。这实际上是一个可以使用动态模块导入的理想地方。

现在，请看下面的代码:

这里，不是总是下载`admin.js`，而是仅当用户是管理员时才下载。还有 wallah，我们可能节省了很多带宽，我们的应用程序下载速度会更快。

# 示例 2:减少内存使用

加快页面加载时间是动态模块导入的一个明显的用例，但另一个用例是当您有一堆不同的文件，而您只需要其中的一个，所以您只需要下载一个。没有动态导入，就要全部下载。语言翻译文件很适合它。

举个例子，假设我们有一个支持三种语言的多语言 web 应用程序:英语、法语和西班牙语。我们简单地使用导入语句来获取翻译，并有条件地使用它们，如下面的代码所示:

正如您所看到的，即使我们一次有条件地使用一个翻译，我们仍然将它们全部导入，这就是为什么所有三个翻译文件都将被下载，而不管用户当前的语言环境。

现在，想象一下这些翻译文件非常大，你有二十个。它们都将被下载，这将导致我们的 web 应用程序的性能更差。

我们可以使用动态导入，只下载当前需要的文件，而不是一次性下载所有文件。我们可以这样做:

现在，这个看起来比上一个好多了。而且实际上比前一个好用多了。这里我们只是根据用户的语言环境动态地导入翻译文件，甚至动态地创建翻译文件名。然后，一切看起来都与我们在前面的例子中已经看到的东西相似。

我们甚至使用`catch`处理了默认导入，所以如果没有找到语言环境，英语翻译将默认导入。

这种方式允许我们只下载一个文件，节省了内存空间，也节省了下载速度。超级有用。

# 示例 3:提高代码性能

我们要讨论的最后一个例子与前一个非常相似，但重点会有所不同。最后一个例子是关于节省时间和内存，因为我们只下载一个文件，而不是下载数百个大文件。这个用例完全是为了节省时间和内存，但前提是我们需要它。

现在，为了完全理解这个例子，让我们假设我们有一个类似这样的文件:

如我们所见，我们有一个形状数组，我们构建了一个复杂的渲染引擎，其中可能有数百个我们想要渲染的不同形状。通常，我们需要做的是为每个形状导入所有的渲染引擎，然后我们需要检查它是哪个形状，然后将其渲染出来。我们使用`switch`语句来实现这个目的。很简单，对吧？

这种方法的问题也是下载不必要的文件。

通过动态导入，我们可以确保只导入那些我们需要的文件。所以，假设你只想渲染一个**三角形**。在这种情况下，我们不必导入**矩形**文件。因此，我们可以更改代码来动态处理导入，如下所示:

这种方法的好处是，如果我们从`shapes`数组中移除**三角形**，那么**三角形. js** 将不会被导入。这节省了时间、内存和空间。

此外，有一点非常好，那就是我们实际上也可以使用`async-await` 来代替承诺。所以如果你对`async-await`更熟悉，你可以这样做:

这就是这篇文章的内容。我希望你今天学到了新东西。想看更多这样的文章，敬请期待！

感谢阅读！