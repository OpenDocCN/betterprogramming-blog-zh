<html>
<head>
<title>How to Build Lightning Fast APIs With AWS Step Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用AWS Step函数构建闪电般快速的API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-lightning-fast-apis-with-aws-step-functions-d1725624aaaa?source=collection_archive---------2-----------------------#2022-03-31">https://betterprogramming.pub/how-to-build-lightning-fast-apis-with-aws-step-functions-d1725624aaaa?source=collection_archive---------2-----------------------#2022-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a17b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Step函数正迅速成为在AWS中构建工作流的事实标准。探索用REST APIs配置它们的技巧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5adfefd29617335ee3a73b4f7bedfa54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJdyaznOHYeJMs9l1PMlWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比尔·杰伦在<a class="ae ky" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前我刚开始使用无服务器时，阶跃函数有点神秘。</p><p id="5e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道它们是为编排工作流而设计的，但我不知道它们的范围。他们应该跨越微服务吗？他们是否应该局限于单个微服务？它们应该被限制在有限的上下文中的服务吗？</p><p id="14e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作流中的跨帐户Lambda调用怎么办？在这种情况下，Step函数会发挥作用。</p><p id="efc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时，步进函数的唯一选项是异步的。<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-express-synchronous.html" rel="noopener ugc nofollow" target="_blank">快递工作流程</a>还没出来。有很多功能，但它被我的经验不足和缺乏明确的服务方向所掩盖。</p><p id="7ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种情况已经改变了。</p><p id="a736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信阶跃函数团队不睡觉。他们每周都推出高质量、高价值的功能，加上AWS开发者社区<a class="ae ky" href="https://dev.to/search?q=step%20functions" rel="noopener ugc nofollow" target="_blank">一直在写关于它们的文章</a>。这是一个很好的时间去了解未来的发展方向。</p><p id="343c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我写了关于使用异步工作流进行处理的“存储优先”开发的文章。但这并不总是可行的。</p><p id="f08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多需要同步响应的用例。如果您想在这些场景中使用步骤功能，您将不得不使用<a class="ae ky" href="https://aws.amazon.com/blogs/compute/new-synchronous-express-workflows-for-aws-step-functions/" rel="noopener ugc nofollow" target="_blank">同步快速工作流</a>。因此，今天我们将介绍如何在REST API中创建一个端点，该API使用express工作流作为其后端。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="560e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么在Lambda上使用阶跃函数？</h1><p id="e5cd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这将永远是开发者之间的激烈争论。在一个lambda函数中管理和维护所有代码有利于组织和代码密度。但是对于阶跃函数，从技术上讲，你是在编写<em class="lv">配置</em>，而不是<em class="lv">代码</em>。</p><p id="7cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/continuousdelivery/simplicity-and-reliability-bc8c4e916f8e" rel="noopener">代码是负债</a>。通过在Lambda函数中切换到配置状态机而不是手写代码，您将责任推给了云供应商，让您可以专注于…构建更多的阶跃函数！</p><p id="2af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们今天的用例是使用阶跃函数比使用Lambda更好的一个很好的例子。我们将构建一个API，允许用户为我们构建的微服务注册API密钥。</p><p id="ac73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://twitter.com/andmoredev" rel="noopener ugc nofollow" target="_blank"> Andres Moreno </a>在<a class="ae ky" href="https://www.andmore.dev/blog/portman-with-api-key/" rel="noopener ugc nofollow" target="_blank">他的文章</a>中对此做了最好的描述:</p><blockquote class="na"><p id="d6ac" class="nb nc it bd nd ne nf ng nh ni nj lu dk translated"><em class="nk">“当创建一个API时，你需要有安全性，以避免不良使用和意外使用带来的成本”——Andres Moreno</em></p></blockquote><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">Auth在任何项目中都是绝对必要的。甚至一个<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-reasons-you-should-never-use-proof-of-concepts-in-production-ca54432e52b9">概念验证(POC) </a>也需要受到某种安全层的保护。因此，我们将创建一个简单的API，它位于我们的服务旁边，允许用户创建和注册API密钥。</p><p id="4b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册API密钥包括几个步骤:</p><p id="dfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们快乐的道路上有四个不同的步骤。更不用说我们需要构建的任何验证和检查状态了。</p><p id="d80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图使用Lambda来创建我们的API键，它将调用四个不同的AWS命令。对于单个功能标记，这开始超过<em class="lv">的阈值太多。Lambda函数应该用尽可能少的业务逻辑做一件事情。</em></p><p id="5310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，迁移到托管状态机为我们提供了更容易的可读性和更好的工作流长期管理。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="39a1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建状态机</h1><p id="cd4d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当构建状态机时，我喜欢从AWS控制台开始，并使用<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/workflow-studio.html" rel="noopener ugc nofollow" target="_blank"> Workflow Studio </a>来构建它。</p><p id="2c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以将AWS SDK集成直接拖放到状态机中，并将一个调用的输出传递到另一个调用的输入中。</p><p id="fe3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最初的开发阶段，我将状态机构建为标准的工作流，这样我就可以图形化地看到我的开发测试的执行情况，并轻松地跟踪问题。Express工作流仅限于显示日志结果，这使得在初始开发阶段进行故障排除更加困难。</p><p id="9894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了构建我们的快乐路径，我们可以将四个API调用添加到工作流中，并进行一些初始验证:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/52d2bb4e51970d37d747b69bed69db51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*udmovISV_tFTAAJo.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nk">添加API密匙的快乐之路。来源:作者</em></p></figure><p id="3c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到为什么我们已经选择了状态机。刚刚开始我们的工作流，我们已经对AWS SDK进行了五次调用。此外，使用阶跃函数，我们还可以并行运行一些调用<em class="lv"/>，这样我们就可以减少执行时间。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b107" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">补偿行动</h1><p id="25bb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在处理安全问题时，你要再三检查你没有留下任何暴露的东西。你最不希望看到的就是你的系统出现安全漏洞，因为当出现问题时，你忘了收拾残局。</p><p id="5cbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果SDK调用由于某种原因在我们的状态机中失败，我们希望确保删除任何已创建的资源。API密匙和使用计划是进入你的API的大门，所以如果我们不小心留下了它们，我们就在系统中留下了一个未被跟踪的入口。</p><p id="a821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当工作流失败时，采取补偿措施。它们是设计用来清理失败前生成的资源的路径。这有助于防止安全漏洞和孤立数据。</p><p id="691c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的工作流程中，我们希望确保删除任何使用计划、API密钥以及API密钥和使用计划之间的链接(如果它们已创建)。加上我们的补偿动作，工作流的形状如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f6b949aa92a16608464bfe156ed11251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K_5JQXOwCYvq3CsF.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nk">完成向您的API添加API密钥的工作流程。来源:作者</em></p></figure><p id="15ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此工作流有条件地清理它创建的任何资源。同样，我们尽可能利用并行处理来确保最快的运行时间。这是一个同步调用，所以我们必须确保快速返回响应。</p><p id="4c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这个状态机中没有Lambdas。随着去年<a class="ae ky" href="https://aws.amazon.com/about-aws/whats-new/2021/09/aws-step-functions-200-aws-sdk-integration/" rel="noopener ugc nofollow" target="_blank">的大发布</a>，Step函数可以直接与AWS SDK集成，因为没有Lambda冷启动，所以大大加快了状态机的速度。</p><p id="a23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要完整查看状态机，您可以<a class="ae ky" href="https://github.com/allenheltondev/serverless-api-key-registration" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上查看。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2f65" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">将API网关连接到步骤函数</h1><p id="907f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我第一次使用阶跃函数时，我会让API Gateway触发一个Lambda函数，该函数会触发阶跃函数。但是那种胶水真的没有必要。您可以轻松地让API Gateway连接到一个同步步骤函数，并将响应返回给您的用户。</p><p id="e7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我非常支持使用<a class="ae ky" href="https://openapis.org" rel="noopener ugc nofollow" target="_blank">开放API规范(OAS) </a>来定义你的<a class="ae ky" href="https://www.readysetcloud.io/blog/allen.helton/the-importance-of-proper-serverless-api-design" rel="noopener ugc nofollow" target="_blank">无服务器API</a>。在我们的例子中，我们将使用<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html" rel="noopener ugc nofollow" target="_blank"> VTL </a>通过我们的OAS将API网关连接到Step函数。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="f52b" class="nx me it nt b gy ny nz l oa ob">x-amazon-apigateway-integration: <br/>  credentials: <br/>    Fn::Sub: ${AddApiKeyRole.Arn} <br/>  uri: <br/>    Fn::Sub:   arn:${AWS::Partition}:apigateway:${AWS::Region}:states:action/StartSyncExecution <br/>  httpMethod: POST <br/>  type: aws <br/>  requestTemplates: <br/>    application/json: <br/>      Fn::Sub: <br/>        - |- <br/>          #set($context.responseOverride.header.Access-Control-Allow-Origin = '*') <br/>          #set($body = "{""detail"" : $input.json('$')}") <br/>          { <br/>            "input": "$util.escapeJavaScript($body)", <br/>            "stateMachineArn": "${StateMachine}" <br/>          } <br/>        - { StateMachine: { "Ref": "AddApiKeyStateMachine" }}</span></pre><p id="e873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS <code class="fe oc od oe nt b">x-amazon-apigateway-integration</code> <a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank">开放API扩展</a>允许我们定义来自API请求的输入，并将其转换为状态机所需的形状。</p><p id="000c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种配置，我们创建的状态机将运行并返回一个响应。因此，我们必须将各种响应映射到有效的http响应。为此，我们可以在<code class="fe oc od oe nt b">x-amazon-apigateway-integration</code>扩展上添加一个<em class="lv">响应</em>部分。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="af40" class="nx me it nt b gy ny nz l oa ob">responses: <br/>  200: <br/>    statusCode: 201 <br/>    responseTemplates: <br/>      application/json: | <br/>        #set($context.responseOverride.header.Access-Control-Allow-Origin = '*') <br/>        #set($inputRoot = $input.path('$')) <br/>        #set($output = $util.parseJson($input.path('$.output'))) <br/>        { <br/>          #if("$output.apiKey" != "") <br/>            "apiKey": "$output.apiKey" <br/>          #end <br/>          #if("$inputRoot.error" == "NameExists") <br/>            #set($context.responseOverride.status = 400) <br/>            "message": "$inputRoot.cause" <br/>          #end <br/>          #if("$inputRoot.error" == "UnhandledError") <br/>            #set($context.responseOverride.status = 500)<br/>            "message": "$inputRoot.cause" <br/>          #end <br/>        }</span></pre><p id="6612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe nt b">responses</code>部分下的<em class="lv"> 200 </em>定义了当积分(在本例中为阶跃函数)返回200时该做什么，这意味着它被成功执行。在200以下是我们对如何将响应从成功的执行中转化出来的定义。</p><p id="2c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个映射将从我们的状态机中获取三个可能的结果，并将它们映射到适当的http响应。</p><ul class=""><li id="4a34" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><strong class="lb iu">成功</strong> —如果状态机运行并在响应中返回一个<code class="fe oc od oe nt b">apiKey</code>属性，我们返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201" rel="noopener ugc nofollow" target="_blank"> 201状态代码</a>和生成的API键的值。</li><li id="c4ed" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><strong class="lb iu">名称存在</strong> —如果有人已经注册了一个API密钥，并使用了调用者输入的相同名称，我们将返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400" rel="noopener ugc nofollow" target="_blank"> 400状态代码</a>，表明调用者需要进行更改。</li><li id="0fec" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><strong class="lb iu">未处理的错误</strong> —如果在我们的工作流处理过程中出现了我们没有预料到的问题，我们会返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500" rel="noopener ugc nofollow" target="_blank"> 500状态代码</a>，表明服务器端出现了问题，调用者可以等待或重试。</li></ul><p id="7957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在检查的<code class="fe oc od oe nt b">NameExists</code>和<code class="fe oc od oe nt b">UnhandledError</code>错误被专门添加到我们的状态机中作为故障状态。您可以添加任何类型的失败状态，并显式地检查它们以向调用者返回不同的响应。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8e6a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">进行速度测试</h1><p id="ae76" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">既然状态机已经完成，OAS映射也已经创建，我们可以在部署的API上运行一个测试，看看它到底有多快。</p><p id="673d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用<a class="ae ky" href="https://www.postman.com" rel="noopener ugc nofollow" target="_blank"> Postman </a>来运行一个测试，这样我们就可以看到响应时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/d2bf42eb5f6a3dd98c1367e637181a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AbqIQr9SPnTClUkz.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nk">通过Step函数生成API密钥的速度测试。来源:作者</em></p></figure><p id="9c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1004 ms不是最快的端点，但考虑到它正在做的一切，它已经相当快了。这篇文章展示了如何进行完全同步的操作。</p><p id="5965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的上一篇文章讨论了使用存储优先方法的完全异步端点。有一个例子可以说明，利用端点的同步和异步处理可以获得完美的平衡。</p><p id="2460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以对这个端点进行修改，以生成API键并同步验证注册名称，然后启动异步步骤函数来创建使用计划并将键链接到计划。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="99e9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="b586" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">和所有事情一样，你创建的软件也有权衡。您可以完全同步，并以较慢的响应时间向用户返回完整的验证，或者您可以返回部分响应，并让用户检查异步作业的结果。</p><p id="2fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平衡就是一切。找出对你和你的消费者来说最好的解决方案。异步正在获得越来越多的关注，你可以做像<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-aws-websockets-8b336a92c379">实现WebSockets </a>这样的事情来增强用户体验。另外，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/and-the-2022-word-of-the-year-for-programmers-is-3605dc1bd698">是2022年</a>软件工程的词。</p><p id="62a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是也有必须同步的关键端点。比如生成一个API密匙。</p><blockquote class="na"><p id="b830" class="nb nc it bd nd ne nf ng nh ni nj lu dk translated">安全永远值得等待。</p></blockquote><p id="638b" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">随着AWS Step Functions服务的不断改进，延迟将继续减少，功能集将继续增加。现在是熟悉这项服务工作原理的时候了。在不太遥远的将来，我们都将构建状态机作为日常工作的一部分。</p><p id="7206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>