<html>
<head>
<title>SwiftUI: Create a Tinder-Style Swipeable Card View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:创建Tinder风格的可滑动卡片视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-create-a-tinder-style-swipeable-card-view-283e257cb102?source=collection_archive---------0-----------------------#2020-01-11">https://betterprogramming.pub/swiftui-create-a-tinder-style-swipeable-card-view-283e257cb102?source=collection_archive---------0-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f9e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI中的卡片和刷卡手势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eafa401994d751e4b268d1c266802905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXY7FEBYgSh_nfTx3oA0rQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:李国豪·巴尔斯</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="00f8" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">以下是我们将在本教程中构建的内容</h1><p id="e998" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如你所见，任何时候都只显示四张牌。当一个被移除时，另一个被添加到堆栈的底部。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/56b8ef61dc4e00531cbc69ee3652b696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*CKmN7LXNjXKTXhjTouqPow.gif"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="df7f" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">入门指南</h1><p id="0dc4" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在Xcode中创建新的SwiftUI项目。确定您运行的是macOS Catalina，并且安装了Xcode 11。(这允许您使用SwiftUI。)</p><p id="a3b0" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">打开Xcode →文件→新建→项目</p><p id="4b21" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我把我的叫做可刷卡，但是你想怎么叫都行。</p><p id="c428" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">确保将用户界面设置为SwiftUI。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/e7c1af1c82bd1c7deeff776292caffe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdJrEQ99zqRSu_w2djlWEQ.png"/></div></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="bc08" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">履行</h1><p id="5ea9" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们开始我们的布局。</p><p id="e7a0" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我接着去了pexels.com，搜索了人物，为这个教程抓取了大约十张人物照片。</p><p id="d89e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们将在顶部创建我们的日期视图。</p><p id="103e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">打开<code class="fe nb nc nd ne b">ContentView.swift</code>，在主<code class="fe nb nc nd ne b">ContentView</code>结构之外添加以下代码作为新结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ol class=""><li id="f7ad" class="nh ni it lz b ma mu md mv mg nj mk nk mo nl ms nm nn no np bi translated">创建一个类似容器的视图来包装我们的整个布局。我们添加了填充，这样我们的视图就不会接触到手机的侧面。</li><li id="ce08" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated"><code class="fe nb nc nd ne b">DateView</code>组件只是一个简单的布局，用<code class="fe nb nc nd ne b">Text()</code>来显示我们的假日期。我们使用一个对齐的<code class="fe nb nc nd ne b">VStack</code>和一个<code class="fe nb nc nd ne b">Spacer() </code>来让我们的文本位于视图的最左边。</li></ol><p id="9d6e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">接下来，我们将创建可重用卡片视图的布局。这张卡最终会被多次创建，并显示虚假数据。</p><p id="28e8" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">布局存在一个图像，一些假数据，和一个信息按钮。该卡将有圆角和阴影。</p><p id="3728" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">创建一个新的Swift文件，并将其命名为<code class="fe nb nc nd ne b">CardView.swift</code>。</p><p id="bdc9" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">打开新创建的<code class="fe nb nc nd ne b">CardView.swift</code>文件，添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5d7f" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这里没有什么是开创性的UI，但让我们来分解一下。</p><ol class=""><li id="009e" class="nh ni it lz b ma mu md mv mg nj mk nk mo nl ms nm nn no np bi translated">使用几何阅读器在父视图的框架内调整内容的大小。变量<code class="fe nb nc nd ne b">geometry</code>将允许我们访问父对象的宽度和高度。我们将用它来填充可用区域。这将允许我们根据从<code class="fe nb nc nd ne b">geometry</code>接收的数据来调整我们的内容。</li><li id="e8de" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">创建我们的<code class="fe nb nc nd ne b">VStack</code>我们的形象，然后是内容。这将把图像放在顶部，我们的内容在下面。</li><li id="70d7" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">将我们的图片调整为父图片的宽度和75%的高度。这将使我们所有的图像大小相同，并为下面的<code class="fe nb nc nd ne b">HStack</code>创造足够的空间。</li><li id="41e8" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">创建我们的<code class="fe nb nc nd ne b">PreviewProvider</code>，这允许我们在屏幕右侧的画布中查看我们的<code class="fe nb nc nd ne b">CardView</code>。我们给视图一个400像素的明确高度，并使用系统默认的填充。这意味着我们的<code class="fe nb nc nd ne b">geometry</code>变量将接收这个帧，高度将是400像素，宽度将是我们设备的宽度减去系统填充(可能是16像素？).</li></ol><p id="680c" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们新创建的<code class="fe nb nc nd ne b">CardView</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2580360f0d65f312cc7903b646c0539b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*ex2XCuopFJ579GwhPkDfXQ.png"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="e31e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">如何让它平移和旋转</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1e5684ecbc31eed24f53da30cd79a2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*gD9iEygokJpiMKnYm4E3-A.png"/></div></figure><p id="89a4" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们可以使用拖动手势来获得拖动的宽度。在上图中，如果用户从这两点拖动，我们的平移将是200像素。</p><p id="6ccb" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">使用这个不断变化的值，我们可以根据用户拖动手指的程度，将视图偏移我们想要的x或y值。</p><p id="132a" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">然后，我们可以使用设备或父视图的值和宽度来确定用户拖动屏幕的百分比。</p><p id="833d" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">使用该百分比，我们可以说，在0%时，我们不旋转图像，但在100%时，我们将其旋转25度。</p><p id="d67f" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">写一些伪代码获取我们的旋转度数:<br/> <code class="fe nb nc nd ne b">let rotationDeg = dragPercentage * 25</code>。</p><p id="45e0" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这会给我们0到25之间的值。</p><p id="9199" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">谢天谢地，SwiftUI通过手势为我们做了很多繁重的工作。我们只需要保存一个<code class="fe nb nc nd ne b">@State</code>值来更新我们的翻译。使用该值，我们可以进行必要的计算。</p><p id="9e0d" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">仍然在我们的<code class="fe nb nc nd ne b">CardView.swift</code>中，将下面的变量和视图修饰符添加到我们现有的最外层<code class="fe nb nc nd ne b">VStack { }</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ol class=""><li id="dc3b" class="nh ni it lz b ma mu md mv mg nj mk nk mo nl ms nm nn no np bi translated">创建一个私有状态变量来保存我们的翻译值。</li><li id="8bef" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">基于我们的平移的宽度/高度中的任何值来更新视图的偏移。这将把视图准确地移动到我们拖动它的地方。</li><li id="62f1" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">添加手势修改器并指定<code class="fe nb nc nd ne b">DragGesture()</code>类。这个类允许我们获得<code class="fe nb nc nd ne b">.onChange</code>处理程序中的拖动值。</li><li id="14bf" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">将我们的<code class="fe nb nc nd ne b">translation</code>变量更新为我们拖动的新值，并在<code class="fe nb nc nd ne b">.onEnded</code>中将我们的平移重置回0。如果我们不把它设置回0，视图将保持在我们上次离开的地方。</li></ol><p id="a598" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">您可能已经注意到，我们的视图可以在x或y方向拖动。但是，我们需要将其限制在x方向(水平拖动)。</p><p id="4700" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">将<br/> <code class="fe nb nc nd ne b">.offset(x: self.translation.width, y: self.translation.height)</code> <br/>改为<br/> <code class="fe nb nc nd ne b">.offset(x: self.translation.width, y: 0)</code>。</p><p id="5243" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">注意:这里我们不想根据我们的拖拽来更新我们的y值，只更新x值。</p><h2 id="4ecd" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">旋转</h2><p id="80dc" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">简单，让我们使用几何阅读器的宽度来检索父视图的宽度，并使用它作为我们的最大拖动距离。</p><p id="3bc7" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们所要做的就是在<code class="fe nb nc nd ne b">.offset()</code>之后和<code class="fe nb nc nd ne b">.gesture()</code>之前添加这一行代码视图修饰符:</p><p id="744d" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated"><code class="fe nb nc nd ne b">.rotationEffect(.degrees(Double(self.translation.width / geometry.size.width) * 25), anchor: .bottom)</code></p><p id="d637" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这将添加一个0到25度之间的旋转效果(或者-25度，取决于我们在x轴上移动手指的方向)，锚定在我们视图的底部。</p><p id="cb1e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">如果我们没有设置底部锚点，我们的视图将围绕它的默认视图<code class="fe nb nc nd ne b">.center</code>旋转。(这也很好，但我认为<code class="fe nb nc nd ne b">.bottom </code>看起来更好)。</p><p id="b6b1" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这就是我们现在的观点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0f4b131fb3b7f2e50308c3192de8a12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*RpwAZvkMY5h3B343rOHnCw.gif"/></div></figure><p id="3a91" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">不过，你现在可能会问，当翻译结束时，我们如何将它动画回原位。</p><p id="51ca" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">轻松点。</p><p id="1659" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">在<code class="fe nb nc nd ne b">.offset()</code>修改器的正上方添加<code class="fe nb nc nd ne b">.animation(.interactiveSpring())</code>作为视图修改器。这将交互式地产生一个漂亮的弹簧般的动画。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7a2a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">如何创建堆叠卡片</h1><p id="dfcb" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">为了实现堆叠的卡片外观，创建一个由四张卡片组成的<code class="fe nb nc nd ne b">ZStack</code>。这四张牌将作为前四名。如果一个被删除，一个被添加到堆栈的底部，以此类推，动画帧的每一个变化，所以最新的一个变得更大，当它在顶部时。</p><p id="ffa1" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">为了将最大的卡片放在顶部，我们需要使用每张卡片的索引，并基于该索引使其稍微变小。该指数将通过乘以一个固定值来决定每张卡的宽度。</p><h2 id="8387" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">那是什么意思？</h2><p id="92c8" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">假设我们最上面的卡片的索引是0，下一张是1，然后是2，以此类推。我们可以将其乘以10px，然后从宽度中减去该值，从而将每张卡片的大小减少10px。我们可以对y偏移做同样的事情，这样第三张卡片看起来比第一张卡片更靠下。</p><p id="3ce1" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们现在移除最上面的卡片(索引为0)，新的最上面的卡片现在是索引1。现在，我们遇到了一个问题，因为我们的第一个视图会由于上述算法的性质而稍微偏移。如果我们最上面的牌变成了索引9，情况会更糟，因为我们已经移除了另外9张牌。</p><p id="95ef" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">一种解决方案是当另一张卡被移除时，通过减一来更新每张卡的索引。所以当最上面的卡片被移除时，我们将下一张卡片更新为新的索引0。这样做的一个缺点是，当我们修改对象时，我们需要遍历整个列表并更新每个条目的索引——我们可能并不总是被允许这样做。</p><p id="06ce" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">另一个稍微复杂一点的解决方案是反转索引并从数组长度中减去它们，然后在算法中使用它来找到新的宽度和y偏移量。</p><p id="8fa3" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">让我们深入探讨一下，因为这是我们将要使用的解决方案。(它的可扩展性稍强，您不必遍历整个列表来更新每个对象上的变量)。</p><p id="0f22" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">假设我们有10张卡片，索引0-9。如果我们反转数组，我们的索引现在是9 → 0。</p><p id="c150" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们顶卡的当前指数是9。数组的最大索引是9。我们可以做:<br/> <code class="fe nb nc nd ne b">let offset = (arraySize — 1 — currentIndex) * 10</code></p><p id="c2e1" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">对于我们的顶卡，这将等同于<code class="fe nb nc nd ne b">10–1–9 * 10 = 0</code>。</p><p id="c0c9" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">然而，对于我们的第二张卡，它等同于<code class="fe nb nc nd ne b">10–1–8 * 10 = 10</code>。</p><p id="5541" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">第三张牌<code class="fe nb nc nd ne b">10–1–7 * 10 = 20</code>。</p><p id="5cdd" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这种模式适用于所有未来的卡片。</p><p id="cad7" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这将减少宽度并偏移y轴。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="b5d2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">来实施吧！</h1><p id="6da9" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">打开<code class="fe nb nc nd ne b">ContentView.swift</code>，添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ol class=""><li id="263f" class="nh ni it lz b ma mu md mv mg nj mk nk mo nl ms nm nn no np bi translated">使用我们的<code class="fe nb nc nd ne b">User</code>结构，构造一个包含十个伪用户的数组。<code class="fe nb nc nd ne b">id</code>字段是我们用来驱动<code class="fe nb nc nd ne b">CardView</code>偏移的。</li><li id="5728" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">创建一个助手函数来返回我们的新宽度。这依赖于用户的ID字段来计算我们的偏移量。</li><li id="4f38" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">为我们的卡偏移创建另一个助手，同样使用ID字段和每张卡10px。</li><li id="3471" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">添加一个<code class="fe nb nc nd ne b">GeometryReader</code>来获得我们的<code class="fe nb nc nd ne b">VStack</code>的实际大小(因为在本例中这是我们的父视图)。</li><li id="f98e" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">添加一个<code class="fe nb nc nd ne b">VStack</code>，这样我们的<code class="fe nb nc nd ne b">DateView</code>和<code class="fe nb nc nd ne b">ZStack</code>卡可以很好地配合，并且<code class="fe nb nc nd ne b">DateView</code>卡在<code class="fe nb nc nd ne b">CardView</code>卡的上方。</li><li id="aabf" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">加一个<code class="fe nb nc nd ne b">ZStack</code>。因为我们将循环和创建我们所有的卡片，我们希望它们一个在另一个之上。然而，它的工作方式是阵列中的最后一张牌在顶部，带有<code class="fe nb nc nd ne b">id: 9</code>。</li><li id="6817" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">为了迭代我们的用户，在<code class="fe nb nc nd ne b">ForEach</code>中创建的每个视图都需要一个<code class="fe nb nc nd ne b">ID</code>。我们可以为我们的用户继承<code class="fe nb nc nd ne b">Hashable</code>协议，这允许我们在这里使用<code class="fe nb nc nd ne b">\.self</code>(这只是我们数组中的每个用户)。<code class="fe nb nc nd ne b">Hashable</code>确保每个物体都是独一无二的。或者，您可以不使用<code class="fe nb nc nd ne b">Hashable</code>协议，而只编写<code class="fe nb nc nd ne b">\.self.id</code>，它对应于每个用户的ID，这个ID对于<code class="fe nb nc nd ne b">User</code>对象的每个实例都是唯一的。</li><li id="30fe" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">将我们的帧和偏移量更新为从步骤2的帮助函数返回的内容。第三。</li></ol><p id="9dcd" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们的更新视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/725c1eaec644655469d95a16a1328f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_h-9vWYTHeNIGYLlqW2a3g.png"/></div></div></figure><p id="f611" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">你可能注意到了，我们所有的牌都被展示出来了。</p><p id="9852" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">如果我们想限制只显示前四张的牌呢？</p><p id="fbb3" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">如果我们回头看看我们是如何实现我们的卡的，我们知道每张卡都有一个<code class="fe nb nc nd ne b">id</code>。如果ID在四的范围内，我们只能呈现前四张卡片。</p><p id="720e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">例如，如果我们的顶部ID是9，那么我们希望显示ID为6、7、8、9的卡片。</p><p id="9611" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">为了实现这一点，当我们在那个<code class="fe nb nc nd ne b">ForEach</code>中创建我们的卡视图时，我们可以编写一个<code class="fe nb nc nd ne b">if-statement</code>，它查看卡的ID并确定它是否在该范围内。</p><p id="2817" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">将这个计算出的变量添加到顶部，在<code class="fe nb nc nd ne b">var body: some View { }</code>之上</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="cf49" class="nx lg it ne b gy op oq l or os"> // Compute what the max ID in the given users array is. <br/> private var maxID: Int {<br/>     return self.users.map { $0.id }.max() ?? 0<br/> }</span></pre><p id="ddff" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们创建了一个计算变量，无论何时使用，它都会重新计算<code class="fe nb nc nd ne b">maxID</code>是什么。当我们开始从牌堆中取出牌时，这将很有用。</p><p id="caf4" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">接下来，在这个if语句中包装<code class="fe nb nc nd ne b">CardView().frame(:width).offset(x:y:)</code>。</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="c0e0" class="nx lg it ne b gy op oq l or os">/// Using the pattern-match operator <!-- -->~=, we can determine if our <br/>/// user.id falls within the range of 6...9</span><span id="e7d0" class="nx lg it ne b gy ot oq l or os">if (self.maxID - 3)...self.maxID ~= user.id {<br/>    // Normal Card View being rendered here.                                    <br/>}</span></pre><p id="a5d5" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">或者，您也可以:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="8001" class="nx lg it ne b gy op oq l or os">if user.id &gt; self.maxID - 4 { ... }</span></pre><p id="1a25" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在我们在任何给定的时间都只展示四张牌。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="1613" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">移除卡</h1><p id="0cf3" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">要移除一张卡，我们将使用一个给定的阈值(比如50%刷卡)，这将触发我们的父视图从用户的数组中移除该卡，同时还将其隐藏在<code class="fe nb nc nd ne b">View</code>中。</p><p id="4ca6" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这样做将在我们的<code class="fe nb nc nd ne b">View</code>层级中触发一次重新渲染，我们应该还有四张牌在堆叠中，但它们将是接下来的四张。</p><p id="69e1" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">打开<code class="fe nb nc nd ne b">CardView.swift</code>并添加以下新代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ol class=""><li id="cdc5" class="nh ni it lz b ma mu md mv mg nj mk nk mo nl ms nm nn no np bi translated">创建两个变量，一个用于<code class="fe nb nc nd ne b">User</code>函数，一个用于<code class="fe nb nc nd ne b">onRemove</code>函数，当用户刷卡超过某个阈值时，将调用这两个变量。</li><li id="925a" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">将我们的阈值百分比指定为视图宽度的0.5%或50%。</li><li id="0d2b" class="nh ni it lz b ma nq md nr mg ns mk nt mo nu ms nm nn no np bi translated">创建我们的自定义<code class="fe nb nc nd ne b">init</code>，它接受我们的用户和<code class="fe nb nc nd ne b">onRemove</code>函数。请注意，我们将通过以下方式传回移除的用户:</li></ol><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="a5f3" class="nx lg it ne b gy op oq l or os"> @escaping (_ user: User) -&gt; Void</span></pre><p id="ddfd" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">4.创建一个助手函数，它将获取我们的几何图形和当前滑动值，并传回百分比。</p><p id="bd97" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">5.用<code class="fe nb nc nd ne b">self.user.{value}</code>更新用户特定数据的所有实例。现在所有的卡都不一样了。</p><p id="bca8" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">6.在我们的手势识别器的<code class="fe nb nc nd ne b">.onEnded</code>中，我们确定我们的<code class="fe nb nc nd ne b">gesturePercentage</code>是大于还是<code class="fe nb nc nd ne b">threshold</code>。如果是，我们调用我们的<code class="fe nb nc nd ne b">onRemove</code>，传回我们的<code class="fe nb nc nd ne b">user</code>。</p><p id="ceaa" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">7.确保更新<code class="fe nb nc nd ne b">PreviewProvider</code>以包含一个<code class="fe nb nc nd ne b">temp</code>用户，这样我们的视图将再次呈现在画布中。</p><p id="17fb" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在打开<code class="fe nb nc nd ne b">ContentView.swift</code>，更新我们的<code class="fe nb nc nd ne b">view</code>，我们正在构建我们的<code class="fe nb nc nd ne b">User</code>视图:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="a17f" class="nx lg it ne b gy op oq l or os">CardView(user: user, onRemove: { removedUser in<br/>   // Remove that user from our array<br/>   self.users.removeAll { $0.id == removedUser.id }<br/>  })<br/>  .animation(.spring()) // Animate our changes to our frame<br/>  .frame(width: self.getCardWidth(geometry, id: user.id), <br/>         height: 400)<br/>  .offset(x: 0, y: self.getCardOffset(geometry, id: user.id))</span></pre><p id="1019" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在我们删除与我们删除的用户ID相匹配的<code class="fe nb nc nd ne b">user</code>。</p><p id="b5b8" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们还加上了<code class="fe nb nc nd ne b">.animation(.spring())</code>。这现在使我们的框架中的变化有了动画效果，所以看起来我们新的顶卡会弹出来，同时也使被添加到底部的卡有了动画效果。</p><p id="742f" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在我们的视图应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d4b414e6ef97967401fb96681ba9c4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*rWlOwYLW9zGRiDPC9T0l_Q.gif"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="756c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">就是这样！</h1><p id="2392" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我们完成了Tinder风格布局的滑动和堆叠视图。</p><p id="378e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我要求你自己加上喜欢和不喜欢的。</p><p id="fc34" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">完整的源代码可以在这里找到，包括挑战:<a class="ae na" href="https://github.com/bbaars/SwiftUI-Tinder-SwipeableCards" rel="noopener ugc nofollow" target="_blank">https://github.com/bbaars/SwiftUI-Tinder-SwipeableCards</a></p></div></div>    
</body>
</html>