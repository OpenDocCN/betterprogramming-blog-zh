<html>
<head>
<title>Draw Custom Views in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中绘制自定义视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/draw-custom-views-in-android-a321fa157d60?source=collection_archive---------2-----------------------#2019-11-07">https://betterprogramming.pub/draw-custom-views-in-android-a321fa157d60?source=collection_archive---------2-----------------------#2019-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">获得对视图的控制，同时优化性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a34d11cddf40f615fd05a4296b52a0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4BNFX5vFF1QciG2G915cg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="7f6e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="4683" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为开发人员，我们每天都在使用XML设计不同种类的UI，但是学习定制视图是一件非常容易的事情。利用定制视图的好处，避免样板代码的重复。</p><p id="f36b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Android提供了一组很好的预建小部件或布局来构建UI，但这些东西无法满足我们在应用程序中的每一个要求。这就是自定义视图发挥作用的地方。我们需要创建一个视图的子类。创建自己的视图子类可以让您精确控制屏幕元素的外观和功能。</p><p id="dc8c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在开始定制视图之前，最好了解一下<strong class="lt iu"> </strong> <a class="ae ky" href="https://medium.com/@pavan.careers5208/the-life-cycle-of-a-view-in-android-6a2c4665b95e" rel="noopener">视图生命周期</a>。</p><h2 id="79b8" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">为什么要自定义视图？</h2><p id="b467" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于大多数自定义视图比常规视图更耗时，因此只有在没有其他更简单的方法来实现某个功能，或者您有以下任何问题可以通过使用自定义视图来消除时，才应该使用自定义视图:</p><ol class=""><li id="7cb5" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">性能:如果您的布局中有许多视图，并且您希望通过绘制一个单独的自定义视图来优化它们，使其更明亮</li><li id="a1a8" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">难以操作和支持的复杂视图层次结构</li><li id="5d9b" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">需要手动绘制的完整自定义视图</li></ol></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="7a0e" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">基本概述</h1><p id="8e35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要开始创建定制视图组件，我们需要遵循下面的基本步骤:</p><ol class=""><li id="1f51" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">创建一个类并扩展基本视图类或子类。</li><li id="441d" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">提供构造函数来使用XML中的属性。</li><li id="64fd" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">重写超类中的一些方法。如onDraw()、onMeasure()等方法。</li><li id="beeb" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">一旦完成，您的新扩展类就可以用来代替它所基于的视图。</li></ol></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="5e2d" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">例子</h1><p id="6e8b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我的一个项目中，我需要创建一个循环的TextView来显示通知的数量。这里我们需要创建一个TextView的子类。</p><p id="3add" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">步骤1:创建一个名为CircularTextView的类。</p><p id="a8b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二步:扩展<strong class="lt iu"> </strong> TextView小工具类。现在，IDE在TextView上弹出一个错误，说这个类型有一个构造函数，必须在这里初始化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1df8775b565153975d748b5aaff79f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgMgjWOtj7TJUO9DtjVSuQ.png"/></div></div></figure><p id="daef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">步骤3:向类中添加构造函数。</p><p id="972b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这可以通过两种方式实现</p><p id="765d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一种方法是向类中添加构造函数，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/64aecbc8070050d28a20ddd59dc9d125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs5IhBFvj-4hgmAWOz8z6Q.png"/></div></div></figure><p id="aa0b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一种方法是将@JvmOverloads添加到构造函数调用中，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5f11aa367eb3e860d81b409f35e3f0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0o2JUfOzKj555MeWDVa27g.png"/></div></div></figure><p id="18da" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，我们会对为什么一个视图有不同类型的构造函数感到困惑。</p><h2 id="a1b3" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">视图(上下文上下文)</h2><p id="33e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从代码动态创建视图时使用的简单构造函数。这里的参数context是视图运行的上下文，通过它可以访问当前的主题、资源等。</p><h2 id="c9f5" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">视图(上下文Context，@Nullable AttributeSet attrs)</h2><p id="5760" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从XML展开视图时调用的构造函数。当从XML文件构造视图时调用这个函数，提供XML文件中指定的属性。这个版本使用默认样式0，所以只应用上下文主题和给定属性集中的属性值。</p><p id="a881" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">步骤4:绘制自定义视图最重要的一步是覆盖onDraw()和其中的逻辑实现。</p><p id="0bc9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">OnDraw(画布:画布？)有一个参数Canvas，视图组件可以通过它来绘制自己。要在画布上绘图，需要创建一个Paint对象。</p><p id="49c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">主要绘图分为两个区域</p><ul class=""><li id="bd9e" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm oh nk nl nm bi translated">画什么，由画布处理</li><li id="259c" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm oh nk nl nm bi translated">怎么画，由颜料处理。</li></ul><p id="6887" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Canvas提供了绘制线条的方法，而Paint提供了定义线条颜色的方法。在我们的例子中，CircularTextView Canvas提供了一个在Paint对象填充颜色时绘制圆形的方法。简单地说，Canvas定义了可以在屏幕上绘制的形状，而Paint定义了颜色、样式、字体等属性。你画的每一个形状。</p><p id="dc61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们开始编码吧。我们创建一个Paint对象并为其分配一些属性，然后使用该Paint对象在画布上绘制形状。onDraw()将简单地如下所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9645f1b6aeef1f8d2394ab934e2a9ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZQ0TjQs9enMi467W3mvWQ.png"/></div></div></figure><p id="afc7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">IDE显示一条警告，以避免在绘制/布局操作期间进行对象分配。因为在渲染视图时会多次调用onDraw()方法，每次都会创建不必要的对象。所以为了避免这种不必要的对象创建，我们需要将这部分从onDraw()中移出，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/66a364dfd0a2dc3f79f096db74874d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtrP0oIZ2fgOF25UQvNKvg.png"/></div></div></figure><p id="3168" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在执行绘图时，请始终记住重用对象，而不是创建新对象。不要依赖您的IDE来突出潜在的问题，而是自己去做，因为如果您在从onDraw()调用的方法中创建对象，IDE就看不到它。</p><p id="18a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第5步:现在我们完成了绘图，让我们用XML膨胀这个视图类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/8c18b22daa995439cafc82262da26f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Enp3XFwJD7rjRKsRnbu_2A.png"/></div></div></figure><p id="4bde" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将这个XML布局添加到您的活动中，并运行应用程序。以下是输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2d48c7a8fe6ffe5af6f1fe4a26d938f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSu6_NN_x3gb5yap7hfs7Q.jpeg"/></div></div></figure><p id="6d65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太棒了，对吧？现在让我们将这个circlePaint颜色动态属性从activity连同一些stroke一起分配。为此，我们需要在CircularTextView类中创建一些setter方法，以便我们可以调用这些方法并动态设置属性。</p><p id="6c8c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，让我们配置一种油漆颜色。为此，我们创建一个setter方法如下。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="c7a2" class="ms la it on b gy or os l ot ou">fun setSolidColor(color: String) {<br/>    solidColor = Color.parseColor(color)<br/>    circlePaint?.<em class="ov">color </em>= solidColor<br/>}</span></pre><p id="58b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，从Activity中，我们可以通过调用这个方法来动态设置颜色。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="7cbb" class="ms la it on b gy or os l ot ou">circularTextView.setSolidColor("#FF0000")</span></pre><p id="a109" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">很酷，对吧？现在让我们添加一些中风的圆圈。对于笔画，需要两个输入:笔画宽度和笔画颜色。对于笔画颜色，我们需要创建一个绘画对象，就像我们对上面的圆形所做的一样。对于笔画宽度，我们创建一个变量并为其设置该值，然后在onDraw()中使用该值。完整的代码将简单如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="e3a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并从activity中动态设置属性来定制它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/d67d211191b8e17e3f0f395cd9739d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FUdPU1u40-BJqTLzAKmGw.png"/></div></div></figure><p id="5421" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们运行设置不同颜色的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/daed3dd84d233e1e01e6b24d4edd8617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTUoP8ed8nrkhK1BaU0GSg.jpeg"/></div></div></figure><p id="7a3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们已经了解了如何从活动中动态设置属性，但是还有一个问题是如何从XML中设置属性。让我们继续进一步探讨。</p><p id="f251" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我们首先在values文件夹中创建一个名为attrs.xml的新文件。在下面的例子中，我们有一个名为CircularTextView <em class="ov"> </em>的视图，其属性名为ct_circle_fill_color，接受颜色输入。同样，我们也可以添加其他属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/60129882bb676d8b1e34b82b23bf8498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3nXgfyvVJx6zytmdKPd0g.png"/></div></div></figure><p id="bbc0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其次，我们需要在自定义视图类中读取这些属性。从init块中，我们读取如下所示的属性集</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ce35" class="ms la it on b gy or os l ot ou">val typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.<em class="ov">CircularTextView</em>)<br/>circlePaint?.<em class="ov">color </em>= typedArray.getColor(R.styleable.<em class="ov">CircularTextView_ct_circle_fill_color</em>,Color.<em class="ov">BLUE</em>)<br/>typedArray.recycle()</span></pre><p id="6766" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，只需转到XML，将属性值设置为您想要的颜色，然后运行应用程序。您将看到所需的输出。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1d53" class="ms la it on b gy or os l ot ou">app:ct_circle_fill_color="@color/green"</span></pre><p id="78cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我的例子中，输出是。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/a486a63206f1ba00db40201fac385af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCfA0ntCf9tlfUemYPsqMQ.jpeg"/></div></div></figure><p id="4ca8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意:不要在绘图时硬编码你的视图大小，因为其他开发人员可能有相同的视图，但大小不同。所以根据它的大小来画你的视图。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="30bf" class="kz la it bd lb lc nz le lf lg oa li lj jz ob ka ll kc oc kd ln kf od kg lp lq bi translated">查看更新</h1><p id="fe70" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果有属性更改或者您想要更新自定义视图，我们现在就完成了视图的设置。主要有两种方法</p><h2 id="97a3" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">无效()</h2><p id="be4b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">invalidate()是一种方法，它坚持对我们希望显示变化的特定视图进行强制重绘。简单地说，当视图的外观发生变化时，需要调用invalidate()。</p><h2 id="57d2" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">请求布局()</h2><p id="68b2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某一点上，视图中有一个状态变化，那么requestLayout()就是给视图系统的信号，它需要重新计算视图的度量和布局阶段(度量→布局→绘制)。简单地说，我们可以说当视图边界发生变化时，需要调用requestLayout()。</p><p id="d828" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，我想您已经对如何创建自定义视图有了基本的了解。您需要知道上面提到的所有方法来创建最佳性能的定制视图。</p><p id="8e63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>