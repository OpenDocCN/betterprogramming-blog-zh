<html>
<head>
<title>Build a Search Engine for Medium Stories Using Streamlit and Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Streamlit和Elasticsearch为中型故事建立搜索引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-search-engine-for-medium-stories-using-streamlit-and-elasticsearch-b6e717819448?source=collection_archive---------1-----------------------#2021-09-23">https://betterprogramming.pub/build-a-search-engine-for-medium-stories-using-streamlit-and-elasticsearch-b6e717819448?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a14c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在你自己的应用程序中搜索媒体报道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a0a2139098ffc9ef53dd3e143c8e70e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D9fJZa6bqyxg7Bfb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@firmbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Firmbee.com</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你读了一个中等的故事，发现它对你很有趣或有用，你会把它保存到你的中等列表中吗？我会的。我有数百个故事被分类并保存在我的列表中。但是当我需要回顾一些我知道我以前见过的东西时，我不会经常回头去看它们。原因之一是因为滚动和浏览一长串故事需要时间。</p><p id="ff74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我宁愿在浏览器中打开一个新标签，在谷歌搜索中输入关键词。虽然我们也可以在媒体搜索中做同样的事情，但如果你以前尝试过，你就会知道为什么我不这样做。在这篇文章中，我将与你分享我是如何做到的，以及我学到了什么。坐下来喝杯咖啡，聊聊这个长故事。</p><p id="b58d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该代码可在<a class="ae kv" href="https://github.com/chiachong/medium-search-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。首先，构建搜索引擎的主要工具有:</p><ul class=""><li id="f688" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">python 3——构建并连接UI (Streamlit)和搜索引擎。</li><li id="82ed" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">elastic search——一个基于Lucence的全文搜索引擎。</li><li id="7cee" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">docker——帮助我们轻松打包和部署应用程序的虚拟化工具。</li></ul><h1 id="6672" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">细流</h1><p id="2121" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们从Streamlit开始。运行<code class="fe nd ne nf ng b">pip3 install streamlit</code>安装Python包，然后在文件夹<code class="fe nd ne nf ng b">srcs/streamlit_app</code>中创建一个py文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b56e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在终端运行<code class="fe nd ne nf ng b">streamlit run srcs/streamlit_app/app.py</code>启动streamlit app。您将看到主页面上有一个文本栏，用于输入搜索词。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/34eeb4cb7bc5523983718ae1ff123b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEixfqi5kc0YsW35rfFAqQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><h1 id="1d5d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">连接弹性搜索</h1><p id="1f67" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们需要通过在终端中运行<code class="fe nd ne nf ng b">pip3 install elasticsearch</code>来安装Python Elasticsearch。之后，在一个新的py文件中创建一些辅助函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nd ne nf ng b">check_and_create_index()</code>函数中，我们定义每个故事有五个属性——作者姓名、故事长度、标题、标签和故事内容。而在<code class="fe nd ne nf ng b">index_search()</code>函数中，我们定义了Elasticsearch查询来进行索引搜索，查询API的细节可以在<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="12e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们在搜索查询中添加了一个聚合术语<code class="fe nd ne nf ng b">tags</code>来对结果中的每个标签进行分组和计数，并将其降序排序为<code class="fe nd ne nf ng b">sorted_tags</code>。这些标签将显示在结果的顶部，可用于过滤搜索结果。</p><p id="cbd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下代码将两个助手函数添加到<code class="fe nd ne nf ng b">app.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bdb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以输入关键字和搜索，但它会失败，因为Elasticsearch还没有开始，我们稍后会这样做，因为在Docker的帮助下非常简单。</p><h1 id="d996" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">显示搜索结果</h1><p id="064e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设我们已经启动并运行了Elasticsearch，下一个任务是显示搜索结果。让我们在同一个文件夹中创建另一个py文件<code class="fe nd ne nf ng b">templates.py</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ac5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的函数用于生成一些HTML和CSS脚本来显示在UI中。<code class="fe nd ne nf ng b">load_css()</code>函数用于设计用作过滤器的故事标签的样式。</p><p id="b9e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<code class="fe nd ne nf ng b">tag_boxes()</code>呈现的story标签可以通过URL参数<code class="fe nd ne nf ng b">search</code>和<code class="fe nd ne nf ng b">tags</code>点击，这对于保持应用程序的状态很重要，我们将在后面讨论。<code class="fe nd ne nf ng b">search_result()</code>函数是显示故事的URL、作者姓名、故事长度和简短突出显示的文本片段的主要组件。</p><p id="5c46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以用以下代码显示搜索结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">st.write()</code>是呈现HTML和定制用户界面的神奇命令。</p><h1 id="70d8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">过滤</h1><p id="5fb4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在这个阶段，我们可以搜索并显示搜索结果(假设Elasticsearch已经启动并运行)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/8c67883078ac36638c87e0d8ffece33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNa_ZkOTOF-NXMAn-1q0hQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="272b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">搜索结果顶部的灰色矩形框是结果中最受欢迎的标签，我们可以单击其中的任何一个来过滤搜索结果。由于它们是包含URL参数<code class="fe nd ne nf ng b">search</code>和<code class="fe nd ne nf ng b">tags</code>的超链接，单击它们中的任何一个都会刷新应用程序状态，但是我们可以使用<code class="fe nd ne nf ng b">st.experimental_get_query_params()</code>捕获URL参数并将这些值设置为新的应用程序状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="628d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之前写过一篇关于Streamlit会话状态的<a class="ae kv" href="https://towardsdatascience.com/advanced-streamlit-session-state-and-callbacks-for-data-labelling-tool-1e4d9ad32a3f" rel="noopener" target="_blank">文章</a>。请随意查看更多细节。</p><h1 id="4a45" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">页码</h1><p id="ab56" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们完成UI需要做的最后一件事是结果分页。与故事标签一样，我们也将分页按钮呈现为超链接，带有URL参数<code class="fe nd ne nf ng b">search</code>、<code class="fe nd ne nf ng b">tags</code>和一个新参数<code class="fe nd ne nf ng b">page</code>。在<code class="fe nd ne nf ng b">templates.py</code>中增加以下功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要捕获新的URL参数并设置会话状态。以下代码将帮助我们做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2040" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有完整的UI来进行搜索、过滤和分页。下一步是使用Docker将我们的Streamlit应用程序容器化。</p><h1 id="3538" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">码头工人</h1><p id="72f0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">老实说，这是我构建的第一个容器图像。我从Prakhar Srivastav的一个很棒的<a class="ae kv" href="https://docker-curriculum.com/?fbclid=IwAR1uDIaodWqSCt90J0DHONTkmfhXonWUK7j-M0ZKDFTsKpeiOvIqznt7sas" rel="noopener ugc nofollow" target="_blank">教程</a>中学到了很多。如果你是Docker新手，我强烈建议你阅读教程。</p><p id="584b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们唯一需要将应用程序容器化的是一个名为<code class="fe nd ne nf ng b">Dockerfile</code>的文件(当然我们还需要在机器上安装Docker)。Dockerfile是一个文本文件，包含自动创建图像过程的命令列表。以下是创建Streamlit应用程序映像的Dockerfile文件示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="52fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们告诉Docker客户端从Python 3.7开始，然后将本地目录中的<code class="fe nd ne nf ng b">requirements.txt</code>复制到映像中，并安装所有的依赖项。之后复制所有源代码，启动端口<code class="fe nd ne nf ng b">8501</code>上运行的Streamlit app。最后，我们只需要一个终端命令来构建映像:</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="e37f" class="np mh iq ng b gy nq nr l ns nt">docker build -t medium-search-app .</span></pre><p id="2817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦构建了映像，我们可以使用终端命令启动映像:</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="0936" class="np mh iq ng b gy nq nr l ns nt">docker run -p 8501:8501 medium-search-app</span></pre><p id="3e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">搜索应用程序现在已经启动并在<code class="fe nd ne nf ng b">localhost:8501</code>上运行。</p><p id="08ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，我们是不是忘了什么？Elasticsearch！是时候启动“引擎”了。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="6af5" class="np mh iq ng b gy nq nr l ns nt"><em class="nu">docker run -p 9200:9200 -p 9300:9300 \<br/>    -e "discovery.type=single-node" \<br/>    elasticsearch:7.11.2</em></span></pre><p id="d42a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果Elasticsearch图像不存在，将自动提取该图像。我们可以通过运行以下命令来检查Elasticsearch的状况:</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="eeb5" class="np mh iq ng b gy nq nr l ns nt">curl 0.0.0.0:9200</span><span id="d927" class="np mh iq ng b gy nv nr l ns nt"># {<br/>#  "name" : "32746bf3501e",<br/>#  "cluster_name" : "docker-cluster",<br/>#  "cluster_uuid" : "DGEsSP6pTPqV4o4eKgxVgw",<br/>#  "version" : {<br/>#    "number" : "7.11.2",<br/>#    "build_flavor" : "default",<br/>#    "build_type" : "docker",<br/>#    "build_hash" : "3e5a16cfec50876d20ea77b075070932c6464c7d",<br/>#    "build_date" : "2021-03-06T05:54:38.141101Z",<br/>#    "build_snapshot" : false,<br/>#    "lucene_version" : "8.7.0",<br/>#    "minimum_wire_compatibility_version" : "6.8.0",<br/>#    "minimum_index_compatibility_version" : "6.0.0-beta1"<br/>#  },<br/>#  "tagline" : "You Know, for Search"<br/># }</span></pre><p id="1ef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">搜索应用现在应该可以连接到Elasticsearch了。借助Docker设置Elasticsearch很简单。</p><h1 id="e1f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Docker撰写</h1><p id="8e59" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">上一节展示了运行单个容器的简单性，但是我们必须用两个命令运行两个容器，如果我们有更多的容器呢？有没有更简单的方法来管理多容器？其中一种方法是编写bash脚本，但是还有一种更优雅的方法——docker compose。</p><p id="ee93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要做的第一件事是安装docker-compose包<code class="fe nd ne nf ng b">pip3 install docker-compose</code>，然后准备一个配置文件<code class="fe nd ne nf ng b">docker-compose.yml</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="71d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用docker-compose的一个好处是它会自动创建一个docker网络。docker网络的用法在我上面提到的<a class="ae kv" href="https://docker-curriculum.com/?fbclid=IwAR1uDIaodWqSCt90J0DHONTkmfhXonWUK7j-M0ZKDFTsKpeiOvIqznt7sas#docker-network" rel="noopener ugc nofollow" target="_blank">教程</a>中有解释。现在，我们可以将搜索应用程序<code class="fe nd ne nf ng b">app.py</code>中定义的Elasticsearch托管域从<code class="fe nd ne nf ng b">DOMAIN='0.0.0.0'</code>更改为<code class="fe nd ne nf ng b">DOMAIN='es'</code>，这是Elasticsearch图像的容器名称。Docker会自动解析域<code class="fe nd ne nf ng b">'es'</code>，所以搜索app图片会通过docker网络直接连接到Elasticsearch图片。</p><p id="dce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe nd ne nf ng b">docker-compose.yml</code>中的<code class="fe nd ne nf ng b">volumes</code>参数对我们也很重要，因为我们不希望我们的应用程序在关机或重启时丢失数据。我们需要在Elasticsearch图像中指定挂载点来持久化数据。</p><p id="8960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，通过运行终端命令启动搜索应用程序:</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="a0e3" class="np mh iq ng b gy nq nr l ns nt">docker-compose up</span></pre><h1 id="de09" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">包裹</h1><p id="463c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这篇文章是关于如何使用Streamlit和Elasticsearch创建一个搜索应用程序，以及如何使用Docker容器化应用程序。</p><p id="a9ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源代码可在<a class="ae kv" href="https://github.com/chiachong/medium-search-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。请随意尝试。感谢您的阅读，我希望您喜欢这本书，并学到一些新东西。我很想听听你的反馈。</p><h1 id="2b63" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="dce3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://docker-curriculum.com/?fbclid=IwAR1uDIaodWqSCt90J0DHONTkmfhXonWUK7j-M0ZKDFTsKpeiOvIqznt7sas" rel="noopener ugc nofollow" target="_blank"> Docker博客</a></p></div></div>    
</body>
</html>