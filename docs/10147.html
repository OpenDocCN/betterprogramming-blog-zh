<html>
<head>
<title>Best Practices for Angular 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度13的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-for-angular-13-fa7fdd42ba80?source=collection_archive---------2-----------------------#2021-12-06">https://betterprogramming.pub/best-practices-for-angular-13-fa7fdd42ba80?source=collection_archive---------2-----------------------#2021-12-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6dd3" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解构建高质量和可伸缩角度应用的最佳实践</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6c42014c4caef90b50f76e2576280e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-o5jrlD8QJ3a4xQ8"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@lmtrochezz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lina Trochez </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f82b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">过去几年，我一直致力于多个大角度应用。在实现过程中，开发团队多次重构应用程序，以改进结构并降低复杂性。</p><p id="34b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文将向您展示我们在此期间学到的最佳实践。这些最佳实践将防止在构建更重要、更复杂的应用程序时遇到清晰性、可伸缩性和性能问题。</p><p id="2100" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将从演示如何组织你的Angular项目和文件夹开始。接下来，我们将研究Angular组件、服务和性能最佳实践。接下来，我们将看看如何处理状态管理。我们将在文章的最后看看基本的编码最佳实践。</p><p id="4383" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文结束时，您将了解所有基本的最佳实践，帮助您构建高质量和可伸缩的Angular应用程序。我们使用Angular 13，但是这些实践大部分也适用于以前的版本。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1c46" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">应用程序结构和组织</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4f04bf18cbf6ade82a4739ce03841e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5G881BTa2TYH_GFM"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">结构由<a class="ae kz" href="https://unsplash.com/@chortsang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chor曾</a>上<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">下</a></p></figure><p id="91ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有许多方法来组织你的角度应用。不可能创建一个适合所有用例的结构。应用程序的组织取决于项目的需求。话虽如此，我认为一些指导方针可以有所帮助。</p><p id="26cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://angular.io/guide/styleguide" rel="noopener ugc nofollow" target="_blank">角形风格指南</a>使用LIFT首字母缩写作为指南。它代表:</p><ul class=""><li id="87e1" class="mv mw iu lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">定位—你必须能够快速找到文件</li><li id="2b64" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc iv">I</strong>identify——给文件命名，以便您立即知道它包含什么</li><li id="7f9b" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc iv"> F </strong> lat —尽可能长时间保持扁平的文件夹结构。</li><li id="8e63" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">试着保持简洁——不要重复，但要避免过于简洁，以至于牺牲了可读性。</li></ul><p id="09a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是我在中到大角度应用中使用的格式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">角度应用程序的文件夹结构</p></figure><h2 id="0bc4" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">核心文件夹和模块</h2><p id="eb56" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">核心文件夹和模块包含共享的单例服务和应用程序级组件。顶级应用程序模块使用这些应用程序级组件，例如导航组件。创建一个核心文件夹和模块可以防止你的主应用程序文件夹变得过于混乱。</p><h2 id="9980" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">共享文件夹和模块</h2><p id="f608" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">共享模块包含由功能模块中的组件使用和引用的组件、管道和指令。</p><h2 id="3732" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">特征文件夹和模块</h2><p id="7b55" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">我喜欢创建一个主特性文件夹，在这个文件夹下，我为应用程序中的每个特性创建单独的文件夹和模块，比如身份验证。当您使用CLI创建新的Angular应用程序时，它将只包含一个模块。当您的应用程序增长时，将它组织成不同的功能模块会有所帮助。将您的特性放在单独的模块中允许Angular延迟加载它们，从而提高性能。</p><h2 id="6823" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">风格和资产</h2><p id="d067" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">styles文件夹包含应用程序的所有全局样式表。“资源”文件夹包含所有图像、矢量和其他类型的应用程序资源。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7eab" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">角度服务最佳实践</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/e920aa3a73457a07ac09c89ac6731383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bfp_pFDfTZ_n0aBB"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@introspectivedsgn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克·麦克林</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发球</p></figure><h2 id="f35a" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">将组件从数据检索中分离出来</h2><p id="a56a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">角度服务通常是一个只有一个目的的类。它做特定的事情，而且做得很好。服务的目标是保护您的组件免受直接的数据检索。划分这些职责将使检索逻辑可重用，并且更容易测试。另一个结果是你的组件类将是精简和高效的。</p><p id="1293" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，避免从组件中直接检索数据或调用API的诱惑。请改用服务。</p><h2 id="1ead" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">将可注入装饰器添加到所有服务中</h2><p id="62ac" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">当一个服务需要另一个服务时，您可以通过服务的构造函数注入它。然后，您必须将<code class="fe od oe of og b">@Injectable</code>装饰器添加到类中。您可以将<code class="fe od oe of og b">@Injectable</code>添加到您的所有服务中，即使他们目前不需要其他服务。我发现直接添加比在添加服务依赖项时添加更容易。我经常忘记它。</p><h2 id="2e25" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">理解Angular如何注入服务</h2><p id="4be0" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">角度注入器实例化依赖关系，并将它们注入到组件或服务中。因此，有必要了解这种喷油器是如何工作的。</p><p id="16b9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当Angular开始时，它会创建一个集中的注射器。这个注入器收集所有已定义的依赖项，并维护应用程序可以在容器中重用的所有已创建的实例。您告诉Angular，它可以使用DI系统中的服务，方法是用@ Injectable修饰它，并在模块的Providers部分列出该服务。</p><p id="3bd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，Angular将服务的同一个实例注入到组件中。延迟加载的功能模块有一个例外。这些模块获得一个服务的新实例。当您使用延迟加载并在服务中使用状态时，请记住这一点。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6436" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">性能最佳实践</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/81a003cd9995cb335917af7ec7b7c654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uipusKPF2IsG10Zs"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">安迪·比尔斯的表演</p></figure><h2 id="a3d2" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">惰性装载</h2><p id="821b" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">惰性加载是一种在需要时加载角度模块的技术。例如，当用户选择应用程序的特定部分时，我们加载一个特性模块。Angular编译引擎在编译期间为每个功能模块创建单独的包。这意味着主包的大小减小了，所以应用程序加载得更快了。</p><h2 id="2033" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">监控捆绑包大小</h2><p id="06ae" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">我们已经看到，减少应用程序的包大小会导致应用程序加载更快。因此，持续监控您的包的大小至关重要。</p><p id="36ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/danvk/source-map-explorer" rel="noopener ugc nofollow" target="_blank"> Source-map-explorer </a>是一个有助于可视化你的包中所有代码来源的工具。你用<code class="fe od oe of og b">npm install -g source-map-explorer</code>安装源地图浏览器。使用<code class="fe od oe of og b">ng build --configuration production --source-map=true</code>生成带有源地图的产品构建之后。然后，您可以使用source-map-explorer可视化生成的js文件。下面是一个例子。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/80f677390427fa471bee00dd0172f278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*924gujqLh7Dr9OKjrqQdNw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Source-map-explorer生成一个可视化的包，图片由作者提供。</p></figure><h2 id="e930" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">提前编译和CLI</h2><p id="7660" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">编译Angular应用程序有两种方法。实时(JIT)在运行时在浏览器中编译应用程序。或者您可以使用提前编译(AOT)，它在构建时编译您的应用程序。自Angular 9以来，AOT一直是默认设置。</p><p id="8e8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过<code class="fe od oe of og b">angular.json</code>配置文件中的<code class="fe od oe of og b">aot</code>属性选择编译器的类型。</p><p id="2fd4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最好总是使用AOT编译，因为它在部署之前只编译一次应用程序，这样可以节省时间。</p><h2 id="1fc8" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">变化检测策略</h2><p id="f0a3" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">角度重新渲染视图，以在零部件中的数据发生变化时显示更新的数据。角度确保组件和视图中的数据始终同步。</p><p id="b497" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">变化检测器处理这种同步。每个组件都有一个变化检测器。当组件的数据发生变化时，变化检测器将更新的数据投射到视图中。</p><p id="6648" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有两种变化检测策略:<code class="fe od oe of og b">Default</code>策略和<code class="fe od oe of og b">OnPush</code>策略。使用<code class="fe od oe of og b">Default</code>策略，变更检测通过检查所有组件的模板表达式的值是否已经变更来工作。</p><p id="0518" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二种策略<code class="fe od oe of og b">OnPush</code>，通过引用比较输入。使用<code class="fe od oe of og b">OnPush</code>策略将提高您的角度应用程序的性能。</p><p id="7112" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你使用<code class="fe od oe of og b">OnPush</code>方法，你必须确保你所有的对象都是不可变的。如果您不这样做，并继续使用可变对象，您的应用程序的复杂性就会增加。然后，它可能会引入难以复制的错误。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在组件上启用OnPush更改检测策略</p></figure><p id="f436" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你切换到<code class="fe od oe of og b">OnPush</code>，确保你的对象变成不可变的。变成不可变的一个好选择是使用<a class="ae kz" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank">不可变. js </a>库。这个库为构建应用程序提供了不可变的原语，比如不可变的对象和列表。</p><h2 id="d671" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">纯净和不纯净管道性能</h2><p id="bcc1" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果您使用自定义管道，那么需要考虑一些性能因素。默认情况下，自定义管道是纯管道，这意味着只有当管道所应用到的对象的引用发生变化时，它们才会被重新计算。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">纯净和不纯净管道性能</p></figure><p id="5ade" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解决这个问题的一个快速方法是通过将第3行的管道装饰器的pure属性设置为false，将管道更改为不纯。这将随着数据的每次变化触发管道。</p><p id="2284" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，最好不要这样做！不纯净的管道会牺牲性能。解决这个问题的一个更好的方法是使用不变性，通过构建一个新的引用来改变对象的引用。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3740" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">角度分量</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/c650059b598ae8997edf4e4204a27afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ASxHAddmAlJXPXBx"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">组件由<a class="ae kz" href="https://unsplash.com/@dreamevile?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉斐尔Koh </a>放在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><h2 id="8288" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">分离组件、CSS和模板文件</h2><p id="892c" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">组件由模板、样式和组件类型脚本代码组成。您可以将模板和样式集成到组件typescript文件中。最佳实践是，当您的HTML超过四行时，您应该将HTML模板分成一个单独的文件。</p><h2 id="834c" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">前缀组件选择器</h2><p id="78e0" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">给组件选择器加上前缀是一个最佳实践。如果将组件存储在功能模块中，请根据该功能模块设置组件前缀。如果一个公共组件驻留在一个共享模块中，使用应用程序名称作为选择器前缀。确保前缀长度在2到4个字符之间。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">为组件选择器添加前缀</p></figure><h2 id="ee24" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">修饰输入和输出属性</h2><p id="8c55" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">有两种方法可以创建组件的输入和输出属性。推荐的方式是用<code class="fe od oe of og b">@Input</code>装饰你的公共财产。第二种不推荐的方法是使用元数据。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用装饰器来指示组件的输入属性</p></figure><h2 id="1283" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">将复杂的逻辑委托给服务</h2><p id="c256" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">努力保持组件内部的逻辑尽可能简单。保持简单意味着更复杂的逻辑应该转移到一个单独的类，一个服务中。</p><h2 id="8b39" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">组件成员序列</h2><p id="4b7e" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">您应该始终对组件的元素进行排序。我使用下面的顺序。</p><ul class=""><li id="21f9" class="mv mw iu lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">公共财产</li><li id="d93a" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">私有财产</li><li id="b9f8" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">构造器</li><li id="a5e2" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">公共方法</li><li id="546f" class="mv mw iu lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">私有方法</li></ul><h2 id="8243" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">实现生命周期挂钩接口</h2><p id="60a5" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">当Angular创建和销毁组件时，可以将多个生命周期事件附加到组件。您应该使用接口，而不是直接实现方法。通过用<code class="fe od oe of og b">implements [Interface]</code>实现接口，你可以确保你正确地实现了事件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">实现生命周期挂钩接口</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="718a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">角度状态管理</h1><p id="7637" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">当您的Angular应用程序变大时，它将需要状态管理。您可以使用几种模式和库来实现状态管理。更直接的方法之一是使用组件的@Input和@Output绑定。您还可以使用角度服务和简单变量来存储临时数据。</p><p id="046e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦您的应用程序增长，您将需要一些不同的东西。我们知道我们的应用程序将增长到企业应用程序的规模，所以我们从NGXS开始。</p><p id="a9f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NGXS是Angular的状态管理模式+库。这个著名的Redux模式和库使它流行起来。NGXS的工作原理与它集中应用程序的状态和逻辑是一样的。所以在你的应用程序中有一个包含所有状态的中心位置。</p><p id="98f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，我开发了一个角度应用程序，用于在飞机上放映电影。应用程序通过服务检索所有电影，并将其存储在应用程序启动时的状态中。每个需要播放电影的组件都通过中央状态选择它们。</p><p id="84ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NGXS的另一个优点是使用选择器从存储中获取数据，作为改变存储的可观察值和动作。现在几乎需要一篇完整的文章来详细介绍NGXS的使用，所以我把它留到另一篇文章中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="440e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">角度编码最佳实践</h1><h2 id="6137" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">不变</h2><p id="add2" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">用JavaScript或TypeScript编码有几个最佳实践。我们之前提到的第一个最佳实践是不变性。不变性是对所有JavaScript代码的一般建议。不变性指的是编程时不改变现有的对象，而是根据需要的改变创建新的对象。一个有帮助的JavaScript库是<a class="ae kz" href="https://immutable-js.com/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nj nk l"/></div></figure><p id="f15e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面例子的第3行，我们使用Map from immutable将键b设置为值50。结果是一个包含map1的所有值的新映射，键b的值更改为50</p><h2 id="d8ad" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">严格模式</h2><p id="161d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">Angular Strict模式是指Angular在编译你的app时执行的TypeScript验证。严格模式提高了可维护性，并帮助您提前发现错误。严格模式也允许使用<code class="fe od oe of og b">ng update</code>自动升级角度。</p><p id="7e12" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用CLI创建新的新角度项目时，默认情况下会打开严格模式。</p><h2 id="f666" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">小文件和函数</h2><p id="733d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">对于用任何语言编写的应用程序来说，保持代码文件和函数小是一个通用的最佳实践。这也适用于角度应用。保持你的函数小使得它们更容易测试、重用、阅读和维护。</p><p id="a0f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于文件或函数没有严格的限制，但是Angular风格指南建议将函数限制在75行以上。</p><h2 id="763d" class="nl me iu bd mf nm nn dn mj no np dp mn lj nq nr mp ln ns nt mr lr nu nv mt nw bi translated">单一责任原则</h2><p id="3f4b" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果不提及单一责任原则(SRP ),你就无法创建最佳编程实践。鲍伯·马丁，又名鲍勃大叔，说一个单独的类或模块应该只有一个单独的责任。</p><p id="315e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我构建一个新的Angular应用程序时，我将这个应用程序分解成单独的组件。对于每个组件，我描述了它的职责以及输入和输出。我总是这样开始描述:“这个组件负责……”—如果我需要进一步分解组件，描述责任信号所需的文本量。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c022" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="a2d7" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">本文描述了几个最佳实践，帮助您构建高质量和可伸缩的Angular应用程序。我们从Angular项目的组织开始。然后我们看了组件、服务和性能。我们通过查看一般的编码实践结束了本文。</p><p id="a898" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两次，我参考了棱角分明的风格指南。风格指南是关于语法、惯例和应用程序结构的固执己见的指南。请务必阅读该指南。</p><p id="dabb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这些最佳实践能在构建Angular应用程序时对您有所帮助。</p></div></div>    
</body>
</html>