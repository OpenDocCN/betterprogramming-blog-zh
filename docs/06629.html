<html>
<head>
<title>How to Implement Linear Regression in Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Scikit-learn中实现线性回归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-linear-regression-in-scikit-learn-e459f6f6a3eb?source=collection_archive---------3-----------------------#2020-10-20">https://betterprogramming.pub/how-to-implement-linear-regression-in-scikit-learn-e459f6f6a3eb?source=collection_archive---------3-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f8a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即开始使用Scikit-了解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48dc2d940c5c1723e5910b7e1da8dfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4FLS-efcRBXH0CPX1K4rg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="a866" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">机器学习正迅速成为就业市场上最受欢迎的技能。具体来说，雇主正在寻找在最流行的ML Python库<a class="ae lr" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>方面有经验的候选人。Scikit-learn是Python的一个库，为机器学习开发者提供了许多无监督和有监督的学习算法。</p><p id="ca61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将探索这个令人敬畏的库，并向您展示如何实现它的核心功能。最后，我们将结合我们所学的知识来实现您自己的线性回归算法。</p><p id="1355" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我们今天要讲的内容:</p><ul class=""><li id="4582" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><a class="ae lr" href="#e323" rel="noopener ugc nofollow">什么是Scikit-Learn？</a></li><li id="a787" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#e7bf" rel="noopener ugc nofollow">sci kit入门-学习</a></li><li id="5550" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#e6e7`" rel="noopener ugc nofollow">数据集和导入. sklearn </a></li><li id="1336" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#19e2" rel="noopener ugc nofollow">生成合成回归数据</a></li><li id="623f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#eafb" rel="noopener ugc nofollow">用Matplotlib绘制数据</a></li><li id="e740" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#5998" rel="noopener ugc nofollow">数据预处理</a></li><li id="b1a9" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#2a0f" rel="noopener ugc nofollow"> Scikit-learn线性回归:实现算法</a></li><li id="676b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="#7259" rel="noopener ugc nofollow">包装和后续步骤</a></li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e323" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">什么是Scikit-Learn？</h1><p id="3293" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">Scikit-learn(简称sklearn)是一个免费开源的Python机器学习库。它旨在与SciPy和NumPy库合作，并简化Python中的数据科学技术，内置对流行的分类、回归和聚类机器学习算法的支持。</p><p id="fea1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Sklearn是许多ML工具无缝协作的统一点。它还为数据科学家提供了导入、预处理、绘制和预测数据的一站式工具包。</p><p id="2b91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个项目是由David Cournapeau在2007年Google代码之夏期间发起的，这个库在过去的十年中在受欢迎程度和功能上都有所增长。Scikit-learn现在是Github上最受欢迎的机器学习库。</p><p id="70d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Scikit-learn提供工具用于:</p><ul class=""><li id="840a" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><strong class="kx ir">回归</strong>，包括线性回归和逻辑回归</li><li id="3dc4" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">分类</strong>，包括K-最近邻</li><li id="9a5a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">型号选择</strong></li><li id="bfac" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">聚类</strong>，包括K-Means和K-Means++</li><li id="898a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">预处理</strong>，包括最小-最大归一化</li></ul><h2 id="6cd4" class="nk mo iq bd mp nl nm dn mt nn no dp mx le np nq mz li nr ns nb lm nt nu nd nv bi translated">scikit-Learn的优势</h2><p id="4173" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">开发者和机器学习工程师使用Sklearn是因为:</p><ul class=""><li id="0cce" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">很好学，也很好用。</li><li id="622a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">它是免费和开源的。</li><li id="7735" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">在机器学习，甚至深度学习的各个方面和算法上都有帮助。</li><li id="3b18" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">它的功能非常强大。</li><li id="a1c6" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">详细的文档和活跃的社区。</li><li id="c505" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">这是使用最广泛的机器学习工具包。</li></ul><h2 id="0075" class="nk mo iq bd mp nl nm dn mt nn no dp mx le np nq mz li nr ns nb lm nt nu nd nv bi translated">与scikit-learn一起使用的库</h2><p id="0300" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">Scikit-learn是一个扩展现有SciPy堆栈(有时称为NumPy堆栈)功能的工具包。下面，我们概述Scikit-learn如何使用SciPy堆栈中的每个库进行数据分析。</p><ul class=""><li id="4a44" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><strong class="kx ir"> NumPy </strong>:高级线性代数和NumPy数组运算。</li><li id="325c" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> SciPy </strong>:包含优化、线性代数和其他基本数据科学功能的模块。</li><li id="fce6" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> Matplotlib </strong>:二维或三维可视化和数据绘图。</li><li id="f68b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> IPython </strong>:增加控制台交互性。</li><li id="4dd2" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">符号计算和计算机代数。</li><li id="cfc0" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> Pandas </strong>:数据操作和分析，主要通过数据框和表格。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e7bf" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">Scikit入门-学习</h1><p id="11d4" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">今天，我将向您展示如何用scikit learn实现您自己的线性回归算法。在我们开始之前，您需要一些基础知识:</p><ul class=""><li id="a95f" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">ML和数据科学的目的。</li><li id="cc61" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">机器学习算法彼此有何不同。</li><li id="0c77" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">线性代数，它与ML的关系。</li></ul><h2 id="c7d8" class="nk mo iq bd mp nl nm dn mt nn no dp mx le np nq mz li nr ns nb lm nt nu nd nv bi translated">导入sci kit-学习</h2><p id="c46e" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">首先，您需要安装scikit-learn。我们将为此使用pip，但是如果您愿意，您也可以使用conda。</p><p id="a492" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让scikit-learn正确工作，您需要一个64位版本的Python 3，以及NumPy和SciPy库。对于可视化数据绘图，您还需要matplotlib。</p><p id="5e83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要安装Scikit-learn，请在Python 3中输入以下代码行:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="d2c9" class="nk mo iq nx b gy ob oc l od oe">pip install -U scikit-learn</span></pre><p id="c843" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，要验证安装，请输入:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="a220" class="nk mo iq nx b gy ob oc l od oe">python -m pip show scikit-learn # displays which version and where sklearn is installed<br/>python -m pip freeze # displays all packages installed in virtualenv<br/>python -c "import sklearn; sklearn.show_versions()"</span></pre><p id="f76e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="of"> Linux用户</em> </strong> <em class="of">:在上面几行</em><code class="fe og oh oi nx b"><em class="of">pip</em></code><em class="of"/><code class="fe og oh oi nx b"><em class="of">python</em></code><em class="of">后面加上</em><code class="fe og oh oi nx b"><em class="of">3</em></code><em class="of"/><code class="fe og oh oi nx b"><em class="of">pip3</em></code><em class="of"/><code class="fe og oh oi nx b"><em class="of">python3</em></code><em class="of">。</em></p><p id="1773" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，要安装NumPy、SciPy和matplotlib，请输入:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="6883" class="nk mo iq nx b gy ob oc l od oe">pip install -U numpy<br/>pip install -U scipy<br/>pip install -U matplotlib</span></pre><p id="8e3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们之前所做的那样，我们将使用以下信息来确认每个组件的安装:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7297" class="nk mo iq nx b gy ob oc l od oe">python -m pip show numpy<br/>python -m pip show scipy<br/>python -m pip show matplotlib</span></pre><p id="2548" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您已经准备好开始使用Scikit-learn了！让我们通过导入数据集来开始我们的教程。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e6e7" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">数据集和导入. sklearn</h1><p id="1552" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">所有机器学习项目的起点都是导入数据集。Scikit-learn包括三个有用的选项来获取数据进行练习。</p><p id="0700" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，该库包含著名的数据集，如<code class="fe og oh oi nx b">iris</code>分类数据集或<code class="fe og oh oi nx b">Boston housing price</code>回归数据集，如果你想在经典集上练习的话。你也可以使用scikit-learn的预定义函数直接从互联网上下载真实世界的数据集，比如<code class="fe og oh oi nx b">20 newsgroups</code>。最后，您可以使用Scikit-learn的数据生成器简单地生成一个随机数据集来匹配某个模式。</p><p id="3cc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些选项中的每一个都要求您导入<code class="fe og oh oi nx b">datasets</code>模块:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="a5a5" class="nk mo iq nx b gy ob oc l od oe">import sklearn.datasets as datasets</span></pre><p id="5135" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将导入<code class="fe og oh oi nx b">iris</code>分类集，看看它是如何存储在sklearn中的。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="955f" class="nk mo iq nx b gy ob oc l od oe">iris = datasets.load_iris()</span></pre><p id="ab51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe og oh oi nx b">iris</code>数据集作为一个类似字典的对象导入，其中包含所有必需的数据和元数据。数据存储在<code class="fe og oh oi nx b">n_samples</code> * <code class="fe og oh oi nx b">n_features</code>的2D数组<code class="fe og oh oi nx b">data</code>域中。</p><p id="9a83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用<code class="fe og oh oi nx b">DESCR</code>、<code class="fe og oh oi nx b">shape</code>和<code class="fe og oh oi nx b">_names</code>函数来获得数据及其格式的描述。如果我们打印这些函数的结果，我们将发现使用<code class="fe og oh oi nx b">iris</code>集合所需的所有信息。</p><p id="3add" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="of">目标与特点</em> </strong> <em class="of"> : </em></p><p id="bf6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="of">所有的ML算法都试图增加自己对某个变量的理解，称为</em> <strong class="kx ir"> <em class="of">目标变量</em> </strong> <em class="of">。然后，算法试图揭示目标变量和其他传递的</em> <strong class="kx ir"> <em class="of">特征变量</em> </strong> <em class="of">之间的看不见的关系。</em></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="cae1" class="nk mo iq nx b gy ob oc l od oe">import sklearn.datasets as datasets</span><span id="2a12" class="nk mo iq nx b gy oj oc l od oe">iris = datasets.load_iris()</span><span id="489c" class="nk mo iq nx b gy oj oc l od oe">print("iris dataset is {}".format(iris.DESCR))</span><span id="c8f6" class="nk mo iq nx b gy oj oc l od oe">print("iris data size is {}".format(iris.data.shape))</span><span id="459d" class="nk mo iq nx b gy oj oc l od oe">print("iris target size is {}".format(iris.target.shape))</span><span id="6c8a" class="nk mo iq nx b gy oj oc l od oe">print("iris data has {} features, the feature names are {}".format(</span><span id="9b9d" class="nk mo iq nx b gy oj oc l od oe">iris.data.shape[1], iris.feature_names))</span><span id="5c51" class="nk mo iq nx b gy oj oc l od oe">print("iris data has {} samples, the target label names {}".format(</span><span id="1b59" class="nk mo iq nx b gy oj oc l od oe">iris.data.shape[1], iris.target_names))</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="19e2" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">生成综合回归数据</h1><p id="97ca" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">如果不想使用任何内置数据集，可以生成自己的数据来匹配所选的分布。下面，我们将看到如何使用<code class="fe og oh oi nx b">matplotlib</code>生成回归数据并绘制它。</p><p id="fb26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，使用以下命令导入<code class="fe og oh oi nx b">matplotlib</code>:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="0038" class="nk mo iq nx b gy ob oc l od oe">import matplotlib.pyplot as plt</span></pre><p id="3e44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们将生成一个包含一个要素和一个信息要素的简单回归数据集。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="be83" class="nk mo iq nx b gy ob oc l od oe">X, y = datasets.make_regression(n_features=1, n_informative=1)</span></pre><p id="455e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这会生成我们的数据集，并将其保存到2D数据集对象<code class="fe og oh oi nx b">x, y</code>。改变<code class="fe og oh oi nx b">make_regression</code>功能的参数将改变生成数据的特征。这里，我们将<code class="fe og oh oi nx b">features</code>和<code class="fe og oh oi nx b">informative</code>参数从默认的<code class="fe og oh oi nx b">10</code>改为<code class="fe og oh oi nx b">1</code>。其他流行的参数包括控制样本数量的<code class="fe og oh oi nx b">samples</code>和控制跟踪多少目标变量的<code class="fe og oh oi nx b">targets</code>。</p><p id="63ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="of">信息性与非信息性特征:</em> </strong></p><p id="d622" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="of">一个</em> <strong class="kx ir"> <em class="of">信息特征</em> </strong> <em class="of">是为ML算法提供有用的、可应用的信息的特征。这些是用于在回归分析算法中形成趋势的数据点。不提供信息的特征被认为是无用的。</em></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="eafb" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使用Matplotlib绘制数据</h1><p id="1b48" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">我们现在将通过输入以下内容来绘制此图:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="26a9" class="nk mo iq nx b gy ob oc l od oe">fig, axe = plt.subplots(dpi = 300)<br/>axe.scatter(X, y, marker='o')<br/>axe.set_title("Data generated from make_regression")<br/>fig.savefig("output/img.png")<br/>plt.close(fig)</span></pre><ul class=""><li id="0af6" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><strong class="kx ir">第1行</strong>将绘图元组变量解包为单独的变量<code class="fe og oh oi nx b">fig</code>和<code class="fe og oh oi nx b">axe</code>。这允许我们保存图形并操作这些单独的属性。</li><li id="8da6" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">第2行</strong>使用我们生成的数据集对象<code class="fe og oh oi nx b">x,y</code>生成散点图。<code class="fe og oh oi nx b">marker</code>参数决定了将使用什么样的视觉来标记每个数据点，在本例中是一个点(<code class="fe og oh oi nx b">o</code>)。</li><li id="aabb" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">第三行设定了我们生成的情节的标题。</li><li id="efd1" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">第4和第5行</strong>然后将图形保存到一个<code class="fe og oh oi nx b">.png</code>图像文件并关闭当前图形。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/7c2785a4d79c947d7385bca19210fa7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEaEt5NlLbq6CCdUjCzfIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的回归图</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="5998" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">数据预处理</h1><p id="58dd" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">大多数ML工程师都认为数据预处理是项目过程中最重要的步骤之一。</p><p id="f015" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没有完美的数据集。可能存在无关的数据点、报告错误和任何数量的干扰算法预测的问题。为了防止这种情况，工作数据科学家在数据进入ML算法之前花了很多时间对其进行清理、标准化和缩放。</p><p id="7986" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个阶段，您将使用的最常见的函数类型是标准化函数，即<code class="fe og oh oi nx b">MinMax</code>和<code class="fe og oh oi nx b">Standard</code>函数。这是因为数据中的要素的范围会有所不同。然而，几乎所有的最大似然算法都使用欧氏距离来度量两个数据点之间的距离。缩放标准化功能允许算法通过缩放集合中的所有点以适合相同的范围来适当地测量距离。</p><p id="b3bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两者都要求您首先导入<code class="fe og oh oi nx b">sklearn.preprocessing</code>和<code class="fe og oh oi nx b">numpy</code>:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="e5ad" class="nk mo iq nx b gy ob oc l od oe">import sklearn.preprocessing as preprocessing<br/>import numpy as np</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9b7f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">最小最大值</h1><p id="6d9a" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><code class="fe og oh oi nx b">MinMax</code>将每个图形的范围缩小到0到1之间。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="386c" class="nk mo iq nx b gy ob oc l od oe">​​<br/>import sklearn.preprocessing as preprocessing<br/> <br/>minmax = preprocessing.MinMaxScaler()<br/># X is a matrix with float type<br/>minmax.fit(X)<br/>X_minmax = minmax.transform(X)</span></pre><ul class=""><li id="6f76" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><strong class="kx ir">第3行</strong>创建一个<code class="fe og oh oi nx b">MinMaxScaler</code>名为<code class="fe og oh oi nx b">minmax</code>。</li><li id="46b8" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">第5行</strong>将原始缩放矩阵与缩放器相匹配。</li><li id="553c" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">第6行</strong>转换原始矩阵以匹配拟合矩阵<code class="fe og oh oi nx b">X</code>。</li></ul><p id="60a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们<code class="fe og oh oi nx b">MinMaxScalar</code>的一个实例:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="3249" class="nk mo iq nx b gy ob oc l od oe">import sklearn.preprocessing as preprocessing</span><span id="7003" class="nk mo iq nx b gy oj oc l od oe">import numpy as np</span><span id="f663" class="nk mo iq nx b gy oj oc l od oe">X = np.random.randint(2, 10, size=(4, 2))</span><span id="f508" class="nk mo iq nx b gy oj oc l od oe">X2 = np.random.randint(100, 10000, size=(4, 2))</span><span id="5579" class="nk mo iq nx b gy oj oc l od oe">X = np.concatenate((X, X2), axis=1)</span><span id="3b83" class="nk mo iq nx b gy oj oc l od oe">print("The original matrix")</span><span id="61ff" class="nk mo iq nx b gy oj oc l od oe">print(X)</span><span id="8267" class="nk mo iq nx b gy oj oc l od oe">#### min-max scaler</span><span id="85ac" class="nk mo iq nx b gy oj oc l od oe">minmax = preprocessing.MinMaxScaler()</span><span id="a33c" class="nk mo iq nx b gy oj oc l od oe">minmax.fit(X)</span><span id="f3e8" class="nk mo iq nx b gy oj oc l od oe">X_minmax = minmax.transform(X)</span><span id="1a9e" class="nk mo iq nx b gy oj oc l od oe">print("The transform data using min-max scaler")</span><span id="fdef" class="nk mo iq nx b gy oj oc l od oe">print(X_minmax)</span></pre><p id="6b47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们使用Numpy <code class="fe og oh oi nx b">randint</code>创建一个大小为四行两列的矩阵，其数量从2到10不等。</p><p id="c71d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们创建另一个同样大小的矩阵，其数量从100到1000不等。这两个指标被连接成一个。</p><p id="12fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从第8行的输出中，您可以看到不同列的数字范围有很大的不同。</p><p id="998e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们应用最小-最大缩放器来缩小和标准化特征之间的范围。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e28a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">标准</h1><p id="2100" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">如果您的数据遵循标准偏差，您可以使用<code class="fe og oh oi nx b">StandardScaler</code>来代替。该定标器将传递的数据集与标准偏差一起拟合为标准标度:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="919d" class="nk mo iq nx b gy ob oc l od oe">import sklearn.preprocessing as preprocessing<br/> <br/>std = preprocessing.StandardScaler()<br/># X is a matrix<br/>std.fit(X)<br/>X_std = std.transform(X)</span></pre><p id="bace" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，我们首先在第三行创建缩放器，在第五行拟合当前矩阵，最后在第六行转换原始矩阵。</p><p id="a811" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看这如何扩展我们上面的例子:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="dd84" class="nk mo iq nx b gy ob oc l od oe">import sklearn.preprocessing as preprocessing</span><span id="f4ce" class="nk mo iq nx b gy oj oc l od oe">import numpy as np</span><span id="a13c" class="nk mo iq nx b gy oj oc l od oe">X = np.random.randint(2, 10, size=(4, 2))</span><span id="a735" class="nk mo iq nx b gy oj oc l od oe">X2 = np.random.randint(100, 10000, size=(4, 2))</span><span id="0f7f" class="nk mo iq nx b gy oj oc l od oe">X = np.concatenate((X, X2), axis=1)</span><span id="6458" class="nk mo iq nx b gy oj oc l od oe">print("The original matrix")</span><span id="a193" class="nk mo iq nx b gy oj oc l od oe">print(X)<br/></span><span id="0f64" class="nk mo iq nx b gy oj oc l od oe">std = preprocessing.StandardScaler()</span><span id="ec1a" class="nk mo iq nx b gy oj oc l od oe">std.fit(X)</span><span id="63ce" class="nk mo iq nx b gy oj oc l od oe">X_std = std.transform(X)</span><span id="84e1" class="nk mo iq nx b gy oj oc l od oe">print("The transform data using Standard scaler")</span><span id="6c9d" class="nk mo iq nx b gy oj oc l od oe">print(X_std)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/0cdb36b5c2a6fa5eb66216f8a0327b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMApVs4KWZw1NIEruvcXAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">缩放方法比较</p></figure><h1 id="2a0f" class="mn mo iq bd mp mq om ms mt mu on mw mx jw oo jx mz jz op ka nb kc oq kd nd ne bi translated">Scikit-learn线性回归:实现算法</h1><p id="a59c" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">现在，我们将使用<em class="of">波士顿房价</em>样本数据实现线性回归机器学习算法。与所有ML算法一样，我们将从导入数据集开始，然后使用历史数据训练我们的算法。</p><p id="2d31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">线性回归是真实企业经常使用的预测模型。线性回归试图预测标量响应和相关解释变量之间的关系，以产出具有现实意义的价值，如产品销售或住房价格。当您拥有以前的一致数据的日志，并且希望预测如果模式继续下去接下来会发生什么时，最好使用此模型。</p><p id="2bd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从数学的角度来看，线性回归就是对数据进行拟合，使每个数据点与预测值之间的残差之和最小。换句话说，我们正在最小化数据和估计模型之间的差异。</p><p id="9b61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如下图，红线是我们求解的模型，蓝点是原始数据，点与红线的距离是残差。我们的目标是最小化残差的和。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/a6aafc3cca8d51b7a27af9fa250f21cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfkRfAkzWzf8FoKMSrCw-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">残差、数据与预测的和</p></figure><h1 id="67ff" class="mn mo iq bd mp mq om ms mt mu on mw mx jw oo jx mz jz op ka nb kc oq kd nd ne bi translated">如何实现线性回归</h1><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="005d" class="nk mo iq nx b gy ob oc l od oe">import sklearn.datasets as datasets</span><span id="e821" class="nk mo iq nx b gy oj oc l od oe">from sklearn.model_selection import train_test_split</span><span id="a5f2" class="nk mo iq nx b gy oj oc l od oe">from sklearn.linear_model import LinearRegression</span><span id="9a90" class="nk mo iq nx b gy oj oc l od oe">import sklearn.metrics as metrics</span><span id="c33d" class="nk mo iq nx b gy oj oc l od oe">house = datasets.load_boston()</span><span id="0d44" class="nk mo iq nx b gy oj oc l od oe">print("The data shape of house is {}".format(house.data.shape))</span><span id="8f04" class="nk mo iq nx b gy oj oc l od oe">print("The number of feature in this data set is {}".format(</span><span id="6024" class="nk mo iq nx b gy oj oc l od oe">house.data.shape[1]))</span><span id="ba3c" class="nk mo iq nx b gy oj oc l od oe">train_x, test_x, train_y, test_y = train_test_split(house.data,</span><span id="e580" class="nk mo iq nx b gy oj oc l od oe">                                                    house.target,</span><span id="20a8" class="nk mo iq nx b gy oj oc l od oe">                                                    test_size=0.2,</span><span id="2bbc" class="nk mo iq nx b gy oj oc l od oe">                                                    random_state=42)</span><span id="3148" class="nk mo iq nx b gy oj oc l od oe">print("The first five samples {}".format(train_x[:5]))</span><span id="63a7" class="nk mo iq nx b gy oj oc l od oe">print("The first five targets {}".format(train_y[:5]))</span><span id="342c" class="nk mo iq nx b gy oj oc l od oe">print("The number of samples in train set is {}".format(train_x.shape[0]))</span><span id="0c38" class="nk mo iq nx b gy oj oc l od oe">print("The number of samples in test set is {}".format(test_x.shape[0]))</span><span id="2d7b" class="nk mo iq nx b gy oj oc l od oe">lr = LinearRegression()</span><span id="cab2" class="nk mo iq nx b gy oj oc l od oe">lr.fit(train_x, train_y)<br/></span><span id="4874" class="nk mo iq nx b gy oj oc l od oe">pred_y = lr.predict(test_x)</span><span id="8946" class="nk mo iq nx b gy oj oc l od oe">print("The first five prediction {}".format(pred_y[:5]))</span><span id="2e94" class="nk mo iq nx b gy oj oc l od oe">print("The real first five labels {}".format(test_y[:5]))<br/></span><span id="9b23" class="nk mo iq nx b gy oj oc l od oe">mse = metrics.mean_squared_error(test_y, pred_y)</span><span id="a83a" class="nk mo iq nx b gy oj oc l od oe">print("Mean Squared Error {}".format(mse))</span></pre><ul class=""><li id="825e" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">在<strong class="kx ir">第6行</strong>，我们通过调用<code class="fe og oh oi nx b">load_boston</code>加载数据集。</li><li id="a13d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">在<strong class="kx ir">第12行</strong>，我们将数据集分成两部分:训练集(80%)和测试集(20%)。</li><li id="4923" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">在<strong class="kx ir">第23行</strong>，创建一个线性回归模型，并对其进行训练(在sklearn中，训练等于拟合)。</li><li id="c0d3" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">在<strong class="kx ir">第29行</strong>，我们调用<code class="fe og oh oi nx b">mean_squared_error</code>来评估该模型的性能。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7259" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">总结和后续步骤</h1><p id="597e" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">您刚刚迈出了掌握Scikit-Learn的第一步。今天，我们讨论了Sklearn的用途，如何导入或生成样本数据，如何缩放我们的数据，以及如何实现流行的线性回归算法。</p><p id="ead9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着您继续您的Scikit-learn之旅，下面是接下来要学习的一些算法和主题:</p><ul class=""><li id="784e" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">支持向量机</li><li id="4a0e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">随机森林</li><li id="0efe" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">朴素贝叶斯模型</li><li id="c56d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">无监督学习</li><li id="d126" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">深度学习</li><li id="6e2a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">逻辑回归</li></ul><p id="75a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="of">快乐学习！</em></p></div></div>    
</body>
</html>