<html>
<head>
<title>How To Use the HTML Canvas Element to Make Awesome Stuff (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用HTML Canvas元素制作令人惊叹的东西(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-the-html-canvas-element-to-make-awesome-stuff-part-ii-2baa658320ff?source=collection_archive---------14-----------------------#2019-12-03">https://betterprogramming.pub/how-to-use-the-html-canvas-element-to-make-awesome-stuff-part-ii-2baa658320ff?source=collection_archive---------14-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用for循环和动画绘制形状</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0a4910984cd4b16864cb94ad8d4e455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_j2yMh4v_S4gWd4aNFwug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@szilviabasso?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西尔维亚·巴索</a>在<a class="ae ky" href="https://unsplash.com/s/photos/canvas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="310e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第二部分。使用for循环和动画绘制形状</h1><p id="19df" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在这篇博客的第一部分中，我展示了如何使用<code class="fe mu mv mw mx b">canvas</code>元素在浏览器中创建形状。</p><p id="106a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们首先制作可以在DOM上看到的正方形和长方形，并编辑它们的属性，比如大小和颜色。现在，我将向你展示如何制作这些形状的动画。</p><p id="c5f0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">首先，让我们看一下到目前为止我们拥有的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bcff73c7bd0f05ce791cb0b810f53b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*y88v7CxynZ16ftHk"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的Index.html档案</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3dec0a2b04e557a1690ced93866bdb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75XJIHrG8YO0DhKbIL-YEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的形状</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1f0b24b3719f92c122de735428d8c9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*huQHbmvjWSLqc7WfWZWi2g.png"/></div></figure><p id="d19b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">要添加圆圈，我们将使用<code class="fe mu mv mw mx b">.arc()</code>方法。方法<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc" rel="noopener ugc nofollow" target="_blank">的文档可以在MDN </a>上找到。<strong class="ma iu"/><code class="fe mu mv mw mx b">.arc()</code>方法有五个必需的参数和一个可选的第六个参数:</p><ul class=""><li id="722c" class="ng nh it ma b mb my me mz mh ni ml nj mp nk mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">x</code>:圆弧中心的水平坐标。</li><li id="7c94" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">y</code>:圆弧中心的纵坐标。</li><li id="ab1d" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">radius</code>:圆弧的半径。必须是正面的。</li><li id="a7e5" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">startAngle</code>:圆弧开始的角度，以弧度为单位，从正x轴开始测量。</li><li id="c6a6" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">endAngle</code>:圆弧结束的角度，以弧度表示，从正x轴开始测量。</li><li id="0386" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">anticlockwise</code>:可选<strong class="ma iu"> </strong> <code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener ugc nofollow" target="_blank">Boolean</a></code>。如果<code class="fe mu mv mw mx b">true</code>，在开始和结束角度之间逆时针绘制圆弧。默认为<code class="fe mu mv mw mx b">false</code>(顺时针)。</li></ul><p id="725c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>参数类似于<code class="fe mu mv mw mx b">.fillRect()</code>方法的参数，这是我们在第一部分中创建矩形和正方形所需要的。</p><p id="e886" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">X</code>和<code class="fe mu mv mw mx b">y</code>对应于浏览器窗口中圆的坐标位置。<code class="fe mu mv mw mx b">startAngle</code>我将从0°开始，因为我们希望我们的圆从0°角度开始，<code class="fe mu mv mw mx b">endAngle</code>将是等于2π弧度或360°的<code class="fe mu mv mw mx b">2 * Math.PI</code>。</p><p id="13bb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我鼓励你试验一下<code class="fe mu mv mw mx b">endAngle</code>和<code class="fe mu mv mw mx b">startAngle</code>，看看你改变值<em class="nu">会得到什么。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7cede10320aad150d0b2d86de5672c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*Iy6RKZwIILNnzhjBp37sKA.png"/></div></figure><p id="b430" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当您将此方法添加到代码中时，您将不会在浏览器中看到任何内容。这将类似于我们在第一部分中最初制作画布时看不到画布的情况。</p><p id="17db" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">要看到这个圆，我们必须给它添加一个填充或描边属性，在这个例子中，我将使用<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fill" rel="noopener ugc nofollow" target="_blank">.fill()</a></code>。这将使我们的圈子可见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1626e3570e7cddf5aecb75ca6f544965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ca0v2ePqDgoZzAyMtHB8fg.png"/></div></figure><p id="3c42" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，如果我想改变我的圆圈的颜色呢？</p><p id="d305" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们将使用<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle" rel="noopener ugc nofollow" target="_blank">.fillStyle</a></code>属性。这可用于任何形状，因为它将改变该形状的笔画颜色、渐变或图案。在我们的圆的例子中，我想把它变成红色。</p><p id="2808" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">注意:您制作的形状将采用它前面的<code class="fe mu mv mw mx b">.fillStyle</code>属性。所以我每个<code class="fe mu mv mw mx b">.fill()</code>方法前都有。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d8f43c5d1f2ca1efa5d7e20756348662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6CMurIGLmZRfa0JtnBlLQ.png"/></div></div></figure><p id="0613" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">还记得我提到过使用<code class="fe mu mv mw mx b">for-loop</code>来创建圆吗？</p><p id="c19d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果您不熟悉如何使用<code class="fe mu mv mw mx b">for-loop</code>，请查阅<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for_statement" rel="noopener ugc nofollow" target="_blank">文档</a>。<em class="nu"> </em>我们将使用一个<code class="fe mu mv mw mx b">for-loop</code>来添加圆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a6de045831cf3440729896010867793a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDNAm3JSLE6_0UnIkZN5OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">把10改成你想要的任何正整数，看看会发生什么。</p></figure><p id="d254" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在花括号内，(或者，正如我的导师所说的，“卷毛男孩”)，我们将放入前一个图像的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/46aab5c2360ad83eeb868e5593ccaf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mI-Y6ozP7LE3APtn11Kf8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为什么什么都没发生？？</p></figure><p id="f781" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们的循环正在工作，但是我们不会在循环的每次迭代中改变<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>参数。这个圆正在绕着自己转十圈。</p><p id="6fd7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了改变这一点，我们可以对我们的<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>值使用<code class="fe mu mv mw mx b">Math.random()</code>方法。并且，为了确保这些圆仍然是圆，我将引入<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath" rel="noopener ugc nofollow" target="_blank">.beginPath()</a></code>，它将确保在循环的每次迭代中，一个新的圆以它自己的路径被创建。</p><p id="061a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果你不确定这到底是什么意思，试着在不添加<code class="fe mu mv mw mx b">.beginPath()</code>的情况下运行这个循环，看看你会得到什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/12d743061fa5ea58d26ddba8ad7c94f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*jv4e65qh_YMbK3DOlKenAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我添加了一个颜色数组来随机化圆圈的颜色，并在填充样式中使用它</p></figure><p id="8ed6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我会把这个做成一个函数叫做<code class="fe mu mv mw mx b">colorizedCircles</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3cea2bda26d1b1681ba85c0aebdd769d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpxMotDP8_eyKkh_VzYiSw.png"/></div></div></figure><p id="82ba" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在你知道了如何实现一个基本的<code class="fe mu mv mw mx b">for-loop</code>来一次制作多个形状，让我们开始制作动画的有趣部分吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a34f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为您的形状制作动画</h1><p id="30f8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好了，我们终于开始用JavaScript制作动画的有趣部分了。</p><p id="4ef0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们将使用<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">.requestAnimationFrame()</a></code>方法。这告诉浏览器你希望动画出现，浏览器的工作就是在制作另一个动画之前调用一个函数来更新动画。</p><p id="7c9e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">.requestAnimationFrame()</code>接受一个参数，这是一个回调(根据MDN):</p><blockquote class="oc od oe"><p id="ed4d" class="ly lz nu ma b mb my ju md me mz jx mg of na mj mk og nb mn mo oh nc mr ms mt im bi translated">"<code class="fe mu mv mw mx b">callback</code>:该为下一次重画更新动画时调用的函数。回调函数通过一个参数传递，一个类似于<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="noopener ugc nofollow" target="_blank">performance.now()</a></code>返回的<code class="fe mu mv mw mx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="noopener ugc nofollow" target="_blank">DOMHighResTimeStamp</a></code>，指示<code class="fe mu mv mw mx b">requestAnimationFrame()</code>开始执行回调函数的时间点。</p></blockquote><p id="d3bf" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">其工作原理是刷新页面，每次刷新时，形状移动<code class="fe mu mv mw mx b">x</code>、<code class="fe mu mv mw mx b">y</code>值。我们首先要开始增加我们的圆的<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>值，并观察它的移动。</p><p id="74a6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我将创建一个名为<code class="fe mu mv mw mx b">animateShape</code>的函数。我将在函数外部设置一个变量<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>，只要函数运行，我将让<code class="fe mu mv mw mx b">x</code>递增0.5，让<code class="fe mu mv mw mx b">y</code>递增1。</p><p id="2392" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">试着改变这些值。你可能会注意到它会影响圆圈移动的速度。</p><p id="8321" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我将创建另一个名为<code class="fe mu mv mw mx b">drawCircle</code>的函数，它负责创建我们的圈子。然后，我将在我的<code class="fe mu mv mw mx b">animateShape</code>函数中调用<code class="fe mu mv mw mx b">drawCircle</code>，这样它将为我们刚刚创建的圆制作动画。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4fdc21ade1e4f66d33c64a11b8ccffe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*rOUB_VRNaTk8FLeyruQF_w.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oj"><img src="../Images/bae6a2f47b9f418154e6277766417185.png" data-original-src="https://miro.medium.com/v2/1*Mx2KXKuvcLhCQ8NvsmV_4g.gif"/></div></figure><p id="f930" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这真的很酷，但我们的形状正在变成一个移动的斑点，这实际上不是我们此刻想要的。</p><p id="d27e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">相反，我们需要画布在呈现新形状之前清空页面。这类似于当我们最初用我们的随机循环制作我们的圆时，为什么我们需要使用<code class="fe mu mv mw mx b">.beginPath()</code>方法。</p><p id="2c72" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了解决这个问题，我们需要使用<code class="fe mu mv mw mx b">.<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect" rel="noopener ugc nofollow" target="_blank">clearRect()</a></code>方法。这将在每个新页面刷新之前清空我们的画布，然后在上面绘图。</p><p id="80ac" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">.clearRect()</code>采用四个参数:</p><ul class=""><li id="4251" class="ng nh it ma b mb my me mz mh ni ml nj mp nk mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">x</code>:矩形起点的x轴坐标。</li><li id="fef6" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">y</code>:矩形起点的y轴坐标。</li><li id="db67" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">width</code>:矩形的宽度。正值在右边，负值在左边。</li><li id="fd5b" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt nl nm nn no bi translated"><code class="fe mu mv mw mx b">height</code>:矩形的高度。正值向下，负值向上。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5ee1e2650023f89692c1d036e0798d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*5W5_tEU3QQHcBqPltnWlWw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在前面的clearRect()中添加。beginPath()</p></figure><p id="3a63" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了得到一个新的圆形渲染，我们应该使<code class="fe mu mv mw mx b">.clearRect()</code>中的<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>值保持为0，并使另外两个参数等于画布的宽度和高度。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5cf6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">边注</h1><p id="8e26" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">将动作分解成更小的功能的好处在于，您可以在不同的地方调用它们并重用它们。(对于调试较大的代码来说，这也很好。)</p><p id="9882" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在代码中，我有我们之前注释掉的<code class="fe mu mv mw mx b">colorizedCircles</code>函数。尝试取消注释<code class="fe mu mv mw mx b">colorizedCircles</code>函数，注释掉<code class="fe mu mv mw mx b">drawCircle</code>函数，看看会发生什么。</p><p id="b442" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><strong class="ma iu">警告</strong>:如果你对闪光动作敏感，不要这样做:例如，如果你有癫痫症。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/bd75e7ef9eda2c58428c5b0bca2f5bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b6JWareo6POQKVLEWO-Myg.gif"/></div></div></figure><p id="b00a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">这是加上<code class="fe mu mv mw mx b">.clearRect()</code>的结果。然而，球离开了屏幕。</p><p id="4965" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了解决这个问题，我们需要在函数中添加一个条件，将我们的形状限制在窗口内。当实现这个条件时，有几件事情需要考虑:</p><ol class=""><li id="d721" class="ng nh it ma b mb my me mz mh ni ml nj mp nk mt om nm nn no bi translated">随着我们的形状增加它的<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>值，如上面的代码所示，随着<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>值变大，它继续朝那个方向前进。</li><li id="615b" class="ng nh it ma b mb np me nq mh nr ml ns mp nt mt om nm nn no bi translated">我们的形状应该在什么点上决定停下来，向相反的方向前进？</li></ol><p id="6a04" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的第一点中，我提到过<code class="fe mu mv mw mx b">x</code>和<code class="fe mu mv mw mx b">y</code>的值在增加，并且形状在那个方向上继续。我们该如何阻止？</p><p id="9ae1" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">一种方法是将我们正在增加的<code class="fe mu mv mw mx b">x</code>或<code class="fe mu mv mw mx b">y</code>值变成一个负数。让我们创建另一个名为<code class="fe mu mv mw mx b">y1</code>的变量，它等于3。</p><p id="993a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">然后，代替我们的<code class="fe mu mv mw mx b">y</code>变量增加<code class="fe mu mv mw mx b">+= 1</code>，我们将让它增加我们设置为<code class="fe mu mv mw mx b">y1</code>的值。这样，我们可以很容易地改变我们的条件的<code class="fe mu mv mw mx b">y1 </code>值。</p><p id="78eb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在上面的第二点中，我提到了考虑圆的半径。确保，如果你想让圆在圆的边缘从屏幕上弹开，你在条件中输入<code class="fe mu mv mw mx b">y + center</code>，并在<code class="fe mu mv mw mx b">.arc()</code>函数的半径参数中输入我们的<code class="fe mu mv mw mx b">center </code>变量。</p><p id="5c13" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，在我们的<code class="fe mu mv mw mx b">if statement</code>中，如果<code class="fe mu mv mw mx b">y + center</code>大于窗口的高度，那么反转形状的方向。由于<code class="fe mu mv mw mx b">y1</code>等于3，所以现在会变成-3。</p><p id="29e3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们添加圆心/半径的原因是，圆不会从圆心处的窗口反弹，而是从圆的边缘反弹。</p><p id="9888" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们还在条件的右边添加了一个<code class="fe mu mv mw mx b"><a class="ae ky" href="https://www.w3schools.com/js/js_comparisons.asp" rel="noopener ugc nofollow" target="_blank">||</a></code>。这就要说到<code class="fe mu mv mw mx b">y — center &lt; 0</code>。这将检查<code class="fe mu mv mw mx b">y - center</code>是否小于0。如果是这样，将-3转回正3，然后向另一个方向走。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/893a7b78e80dd69ab10f04b1484ca776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*xs83YTASN3qBLTWwupvCHw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a45253bd9def04f7217ac01e322c05fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/1*7sEXzZezqNqy5cQIyxo_wQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">挑战:根据上面的代码示例，如果它横向反弹，如何让它停留在窗口内？</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="10dd" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="d200" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">希望本教程能够给你一个创建和动画基本形状的概述。我希望这给了你工具去尝试其他形状以及如何制作动画。</p><p id="e0c7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">查看MDN文档:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations" rel="noopener ugc nofollow" target="_blank">画布动画简介</a>。</p><p id="303d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">另外，另一个很棒的资源是一个名为<a class="ae ky" href="https://threejs.org/" rel="noopener ugc nofollow" target="_blank"> Three.js </a>的JS库。这可以帮助您制作3D形状。</p></div></div>    
</body>
</html>