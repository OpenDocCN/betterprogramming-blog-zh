<html>
<head>
<title>How To Present a Bottom Sheet View Controller in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中呈现底部表单视图控制器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-present-a-bottom-sheet-view-controller-in-ios-a5a3e2047af9?source=collection_archive---------0-----------------------#2021-06-07">https://betterprogramming.pub/how-to-present-a-bottom-sheet-view-controller-in-ios-a5a3e2047af9?source=collection_archive---------0-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2a33" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不需要库的简单易行的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e790a3a94893bdf9d4eb79b188ed4481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSv96RYS7-38LBw8xT2hxw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用底部表单视图的应用程序。图片由作者提供。</p></figure><p id="6c21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">底部表单模态视图控制器是一个具有很好的UI/UX设计的特性。当我们想用最少的内容呈现一个快速预览时，这是非常有用的。事实上，在大多数iOS实现中，它有一个平移手势功能(可拖动)，只需通过将视图拖动到顶部或底部来关闭控制器或扩展内容。也可以通过点击变暗的背景来快速关闭模式视图控制器。</p><p id="7229" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该功能目前已在脸书、Slack、Instagram等众多知名app中实现。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="adae" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们将建造什么？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cdb4655f8e245487ff4e3cb22b6af39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TrYRf940KOrtiQCjHqCJeQ.gif"/></div></figure><p id="14b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将创建一个简单的应用程序(如上所示),它带有一个模态视图控制器，具有以下功能:</p><ul class=""><li id="9877" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated">可以有模式地呈现，内容大小约占屏幕大小的一半或更少(可定制)。</li><li id="a7aa" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">能够向下拖动以关闭视图控制器(使用平移手势识别器)。</li><li id="fc74" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">能够向上拖动以展开视图控制器。</li><li id="565e" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">能够通过点击暗背景来关闭视图控制器。</li></ul><p id="270d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我假设每个阅读这篇文章的人都已经熟悉了<a class="ae nf" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" rel="noopener ugc nofollow" target="_blank">自动布局</a>和修改约束。此外，我们将以编程方式构建它，包括创建视图和设置布局约束。</p><p id="a118" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，您可以使用Storyboard、Xib或其他自动布局库。但是在整个教程中，请务必关注哪些约束将会发生变化并影响布局。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="fd0e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">1.创建新的UIKit项目</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/6fb9e3aed89ffb9a105238d90b13887b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgKj9CVm1TnW6noKlGzeTQ.png"/></div></div></figure><p id="0722" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用UIKit和故事板创建一个新项目。然而，我们不打算更新<code class="fe nh ni nj nk b">Main.storyboard</code>文件，因为我们将在一个Swift文件中以编程方式创建整个文件。</p><h2 id="144d" class="nl lz iq bd ma nm nn dn me no np dp mi le nq nr mk li ns nt mm lm nu nv mo nw bi translated">移除故事板(可选)</h2><p id="91b0" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">您可以通过以下额外步骤完全删除故事板:</p><p id="7286" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.首先，从<code class="fe nh ni nj nk b">Project &gt; General &gt; Main Interface</code>中删除“Main”。</p><p id="3e9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.打开<code class="fe nh ni nj nk b">Info.plist</code>文件作为“源代码”,删除这两行:</p><pre class="kg kh ki kj gt oc nk od oe aw of bi"><span id="f925" class="nl lz iq nk b gy og oh l oi oj">&lt;key&gt;UISceneStoryboardFile&lt;/key&gt;<br/>&lt;string&gt;Main&lt;/string&gt;</span></pre><p id="a4b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.然后，从项目中删除<code class="fe nh ni nj nk b">Main.storyboard</code>文件。</p><p id="01e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.将下面的代码添加到<code class="fe nh ni nj nk b">SceneDelegate.swift</code>中，从指定的视图控制器中设置我们的根窗口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="75ea" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">2.向ViewController添加视图</h1><p id="4147" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在这个项目中，我们将致力于两个主要的视图控制器:</p><ol class=""><li id="1dcd" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq om mx my mz bi translated"><code class="fe nh ni nj nk b">ViewController</code>已经作为主页面存在于<code class="fe nh ni nj nk b">ViewController.swift</code>中。</li><li id="f85e" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated"><code class="fe nh ni nj nk b">CustomModalViewController</code>是一个可展示的视图控制器，我们将在下一步创建它。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/0d9f37764a9bd996938de6e03b532375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lchk3N3UI84dDBcqMkXfxA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ViewController页面的屏幕截图</p></figure><p id="de7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，打开<code class="fe nh ni nj nk b">ViewController.swift</code>，我们将添加一些文本和一个按钮，它们被包裹在<code class="fe nh ni nj nk b">UIStackView</code>中。这个按钮将触发一个函数来呈现我们的自定义模态视图控制器。</p><p id="6964" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用下面的代码更新您的<code class="fe nh ni nj nk b">ViewController.swift</code>文件并运行项目(command + R)。你应该能够看到如上图所示的相同结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="31c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是对视图控制器中添加的每个要点的解释:</p><ol class=""><li id="8bae" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq om mx my mz bi translated">将所有需要的UI组件，包括<code class="fe nh ni nj nk b">UILabel</code>、<code class="fe nh ni nj nk b">UITextView</code>和<code class="fe nh ni nj nk b">UIButton</code>，添加到一个带有<a class="ae nf" href="https://theswiftdev.com/lazy-initialization-in-swift/" rel="noopener ugc nofollow" target="_blank">懒人闭包</a>的<code class="fe nh ni nj nk b">UIStackView</code>中，并定义样式。我们不设置框架或大小，因为它将在接下来的步骤中的约束设置中处理。我还在<code class="fe nh ni nj nk b">containerStackView</code>里面加了一个<code class="fe nh ni nj nk b">spacer</code>把<code class="fe nh ni nj nk b">registerButton</code>推到屏幕底部。</li><li id="a550" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">我们常用<code class="fe nh ni nj nk b">viewDidLoad()</code>来调用所有的设置方法。</li><li id="a2d3" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">将一个动作方法绑定到<code class="fe nh ni nj nk b">registerButton</code>。</li><li id="98ba" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated"><code class="fe nh ni nj nk b">setupConstraints()</code>方法是我们添加必要的子视图并设置约束的地方。我认为约束非常简单，尽管它们是以编程方式编写的。</li><li id="8641" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">包装<code class="fe nh ni nj nk b">activate()</code>函数中需要的所有约束，以立即更新每个视图的布局。</li><li id="0559" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">将<code class="fe nh ni nj nk b">containerStackView</code>边缘(顶部、底部、前缘和后缘)设置为24px间距的超级视图。</li><li id="29f8" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">将按钮高度设置为50px。</li><li id="8588" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">准备一个当我们点击<code class="fe nh ni nj nk b">registerButton</code>时将被调用的<code class="fe nh ni nj nk b">presentModalController()</code>方法。</li></ol><p id="4443" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很好，现在我们完成了第一页。让我们继续创建我们的第二个视图控制器。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="fc87" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">3.创建CustomModalViewController</h1><p id="bc16" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">创建一个名为<code class="fe nh ni nj nk b">CustomModalViewController</code>的新控制器(您可以使用任何合适的名称)。然后添加一个名为<code class="fe nh ni nj nk b">containerView</code>的<code class="fe nh ni nj nk b">UIView</code>作为主视图来保存UI组件的子视图。下图显示了我们将在这一步中构建的第二个视图控制器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/b546d5ad5009a50c42246739349efb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*980n9aDawxLJEJB356qyfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CustomModalViewController页面的屏幕截图</p></figure><p id="b72f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在初始阶段，我们将创建一个没有动画的空视图<code class="fe nh ni nj nk b">CustomModalViewController</code>。下面是更新视图控制器的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ol class=""><li id="344d" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq om mx my mz bi translated">创建一个<code class="fe nh ni nj nk b">containerView</code>作为以后保存内容的主要位置。</li><li id="8502" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">创建一个简单的<code class="fe nh ni nj nk b">dimmedView</code>作为背光。</li><li id="a7b1" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">创建可根据动画和<code class="fe nh ni nj nk b">containerView</code>高度进行更改的动态约束。</li><li id="de96" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">增加<code class="fe nh ni nj nk b">dimmedView</code>和<code class="fe nh ni nj nk b">containerView</code>为主子视图。</li><li id="3cc1" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">设置静态(不可改变的)约束。</li><li id="0b4c" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">将容器高度设置为默认值(300像素)。</li><li id="3d36" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq om mx my mz bi translated">将<code class="fe nh ni nj nk b">containerView</code>的底部锚定设置为<code class="fe nh ni nj nk b">0</code>，这样从底部边缘到300px高度都可以看到视图。</li></ol><p id="d2f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，更新<code class="fe nh ni nj nk b">ViewController.swift</code>中的<code class="fe nh ni nj nk b">presentModalController()</code>方法，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="555a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们没有将<code class="fe nh ni nj nk b">present()</code>用于上面代码中显示的动画。因此，我们应该将<code class="fe nh ni nj nk b">animated</code>的值设置为<code class="fe nh ni nj nk b">false</code>。相反，我们将添加我们的自定义动画来制作暗淡背景和容器移动的动画。</p><p id="a92a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果您运行项目并单击“开始”按钮，它将显示我们的新视图控制器，但没有任何动画。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="d546" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">4.用动画显示容器视图</h1><p id="1e11" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">添加一个名为<code class="fe nh ni nj nk b">animatePresentContainer()</code>的新方法，它将从底部到默认高度呈现<code class="fe nh ni nj nk b">containerView</code>。在<code class="fe nh ni nj nk b">setupConstraints()</code>中，确保将初始底部常数更改为<code class="fe nh ni nj nk b">defaultHeight</code> (300px)，这样<code class="fe nh ni nj nk b">containerView</code>最初会隐藏在底部边缘下方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/1e649bc81521eccb28c697ddcaa040c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xk51pbMeIssGVpwMn_C5Qg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">底部锚值更改以上下移动容器视图</p></figure><p id="dc7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">务必记住，如果底部锚点等于<code class="fe nh ni nj nk b">0</code>，则<code class="fe nh ni nj nk b">containerView</code>将可见。如果底锚大于<code class="fe nh ni nj nk b">0</code>，会根据偏移值稍微隐藏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="aa7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个新方法需要从<code class="fe nh ni nj nk b">viewDidAppear()</code>调用。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7eee" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">5.添加暗视图动画</h1><p id="c3a8" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">添加一个名为<code class="fe nh ni nj nk b">animateShowDimmedView()</code>的新方法。然后通过更新alpha值制作一个简单的渐变动画，如下面的代码所示。这个方法也会在<code class="fe nh ni nj nk b">viewDidAppear()</code>中用<code class="fe nh ni nj nk b">animatePresentContainer()</code>调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="4b49" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">6.添加自定义消除动画</h1><p id="7f98" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">在这一步，我们将模仿视图控制器解散动画。首先，添加一个名为<code class="fe nh ni nj nk b">animateDismissView()</code>的新方法。它用于隐藏变暗的视图并将<code class="fe nh ni nj nk b">containerView</code>移动到底部边缘下方。在动画结束时(在完成闭包中)，它会调用原生视图控制器的<code class="fe nh ni nj nk b">dismiss()</code>方法，没有任何动画。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bbb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦完成这一步，当“开始”按钮被按下时，我们的应用程序应该能够平稳地呈现底部的<code class="fe nh ni nj nk b">containerView</code>以及一个淡入淡出的动画。此外，您应该能够通过点击暗视图来关闭视图控制器。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b277" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">7.设置平移手势以检测拖动运动</h1><p id="0947" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">这部分很重要，因为我们想在<code class="fe nh ni nj nk b">containerView</code>上平移时捕捉偏移值的距离。</p><p id="19cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.添加一个名为<code class="fe nh ni nj nk b">setupPanGesture()</code>的新方法，在主视图上设置手势，并将其绑定到handler方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="5960" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.创建一个名为<code class="fe nh ni nj nk b">handlePanGesture()</code>的处理程序方法。为了更好地理解，让我们做一个简单的打印输出来捕捉拖动距离和方向:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b3e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.现在，调用<code class="fe nh ni nj nk b">viewDidLoad()</code>中的<code class="fe nh ni nj nk b">setupPanGesture()</code>。</p><p id="ae7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行项目并尝试平移<code class="fe nh ni nj nk b">containerView</code>。当检查底部输出日志时，它应该会打印出类似如下所示的结果:</p><pre class="kg kh ki kj gt oc nk od oe aw of bi"><span id="f83a" class="nl lz iq nk b gy og oh l oi oj">Pan gesture y offset: -20.666671752929688<br/>Dragging direction: going up</span><span id="ad87" class="nl lz iq nk b gy oq oh l oi oj">Pan gesture y offset: -14.333343505859375<br/>Dragging direction: going up</span><span id="5a46" class="nl lz iq nk b gy oq oh l oi oj">Pan gesture y offset: -3.6666717529296875<br/>Dragging direction: going up</span><span id="02b4" class="nl lz iq nk b gy oq oh l oi oj">Pan gesture y offset: 9.0<br/>Dragging direction: going down</span><span id="fbcb" class="nl lz iq nk b gy oq oh l oi oj">Pan gesture y offset: 14.333328247070312<br/>Dragging direction: going down</span><span id="fb30" class="nl lz iq nk b gy oq oh l oi oj">Pan gesture y offset: 22.666656494140625<br/>Dragging direction: going down</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5492" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">8.更新手势处理程序</h1><p id="a404" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">根据上一步的结果，我们知道如果拖动方向向上，那么<em class="or"> Y </em>偏移总是负的，反之亦然。因此，为了用新的高度更新<code class="fe nh ni nj nk b">containerView</code>，我们应该实现这个公式:</p><pre class="kg kh ki kj gt oc nk od oe aw of bi"><span id="6108" class="nl lz iq nk b gy og oh l oi oj">newHeight = containerHeight + (-translation.y)</span></pre><p id="14ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，当我们拖动到底部时，容器高度会变小。当我们拖动到顶部时，高度会增加。完美！</p><h2 id="215d" class="nl lz iq bd ma nm nn dn me no np dp mi le nq nr mk li ns nt mm lm nu nv mo nw bi translated">扩展和消除条件</h2><p id="8bfa" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">请记住，我们已经确定了我们的条件的价值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/652d8155a0ff6cf405339c3f9de2659b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xy44SZ8cWfCRiZHNXJZ8zg.png"/></div></div></figure><ul class=""><li id="709f" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated">默认高度:容器的固定默认大小</li><li id="a0b1" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">最大高度:容器可以呈现或被拖动的最大值。每当<code class="fe nh ni nj nk b">containerView</code>从默认高度(300px)拖动到顶部时，无论用户是否放开，<code class="fe nh ni nj nk b">containerView</code>都会一直增长到顶部(不能超过最大高度)。</li><li id="b4d0" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">最小高度:如果容器达到最小值或低于最小值，视图将自动关闭。这类似于“向下滑动以消除”操作。</li></ul><p id="697c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为固定值添加一些<code class="fe nh ni nj nk b">let</code>常量，并添加一个<code class="fe nh ni nj nk b">var</code>来保存对容器高度的更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ceb2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，根据手势状态更新<code class="fe nh ni nj nk b">handlePanGesture()</code>并添加一个新的<code class="fe nh ni nj nk b">animateContainerHeight()</code>方法，用动画更新新的容器高度。容器的高度根据名为<code class="fe nh ni nj nk b">containerViewHeightConstraint</code>的动态约束变量进行更新。有关详细解释，请参见代码中的注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="227f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">9.向容器视图添加内容</h1><p id="305b" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">如果您想在<code class="fe nh ni nj nk b">containerView</code>扩展或收缩时看到内容的变化，这一步是可选的。</p><p id="000e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将添加两个标签和一个堆栈视图，然后将堆栈视图的约束设置到超级视图的边缘(<code class="fe nh ni nj nk b">containerView</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="fd1b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">项目已完成</h1><p id="648e" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">恭喜你！现在，我们已经完成了所有的步骤，项目已经准备好运行了。我们已经编写了非常简单的代码，定制的模态视图控制器工作得很好。</p><p id="2728" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的源代码可以从我的GitHub <a class="ae nf" href="https://github.com/xmhafiz/CustomModalVC" rel="noopener ugc nofollow" target="_blank">库</a>下载。尝试将它实现到您的项目中，并通过创建一个可在其他视图控制器中重用的包装类来改进代码。</p><p id="5b1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9728" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">WWDC21更新</h1><p id="8596" class="pw-post-body-paragraph kv kw iq kx b ky nx jr la lb ny ju ld le nz lg lh li oa lk ll lm ob lo lp lq ij bi translated">根据<a class="ae nf" href="https://developer.apple.com/videos/play/wwdc2021/10063/" rel="noopener ugc nofollow" target="_blank"> WWDC21 </a>中的最新会话，苹果发布了UIKit的更新，拥有一个可定制和可调整大小的底部表单，名为<a class="ae nf" href="https://developer.apple.com/documentation/uikit/uisheetpresentationcontroller?changes=_2_1&amp;language=objc" rel="noopener ugc nofollow" target="_blank">uisheetepresentationcontroller</a>，可在iOS15+上使用。这个更新绝对是每个开发者期待已久的特性。</p><h1 id="dc8e" class="ly lz iq bd ma mb ot md me mf ou mh mi jw ov jx mk jz ow ka mm kc ox kd mo mp bi translated">参考</h1><ul class=""><li id="3084" class="mr ms iq kx b ky nx lb ny le oy li oz lm pa lq mw mx my mz bi translated"><a class="ae nf" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/library/archive/documentation/user experience/Conceptual/AutolayoutPG/index . html</a></li><li id="f2d7" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/library/archive/documentation/user experience/Conceptual/AutolayoutPG/programmaticallycreationconstraints . html</a></li><li id="3102" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://fluffy.es/facebook-draggable-bottom-card-modal-1/" rel="noopener ugc nofollow" target="_blank">https://fluffy.es/facebook-draggable-bottom-card-modal-1/</a></li><li id="5f0a" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://github.com/xmhafiz/CustomModalVC" rel="noopener ugc nofollow" target="_blank">https://github.com/xmhafiz/CustomModalVC</a></li><li id="33d0" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://developer.apple.com/videos/play/wwdc2021/10063/" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/videos/play/wwdc2021/10063/</a></li><li id="06ea" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/customize_and_resize_sheets_in_uikit?language=objc" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/ui kit/uiview controller/customize _ and _ resize _ sheets _ in _ ui kit？language=objc </a></li><li id="f402" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><a class="ae nf" href="https://developer.apple.com/documentation/uikit/uisheetpresentationcontroller?changes=_2_1&amp;language=objc" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/ui kit/uisheetpresentationcontroller？changes = _ 2 _ 1&amp;language = objc</a></li></ul></div></div>    
</body>
</html>