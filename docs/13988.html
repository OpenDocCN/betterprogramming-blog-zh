<html>
<head>
<title>Building a Website Using Rust, GraphQL, React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust、GraphQL、React建立网站</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-website-using-rust-graphql-react-72f2783f2a30?source=collection_archive---------1-----------------------#2022-10-23">https://betterprogramming.pub/building-a-website-using-rust-graphql-react-72f2783f2a30?source=collection_archive---------1-----------------------#2022-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="05b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您更快创建的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf19b4890964b2a74a27baf95529f258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mv8lB66qz23Eq1Js"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在之前的一篇文章中，我解释了如何使用React、gRPC-web和Rust创建我的个人网站。在本文中，我将修改代码以使用GraphQL接口。</p><p id="2940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于服务器，我使用<a class="ae kv" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket </a> web框架和<a class="ae kv" href="https://github.com/graphql-rust/juniper" rel="noopener ugc nofollow" target="_blank"> Juniper </a>库来服务<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。</p><p id="1e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于客户端，我使用<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kv" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>，并通过<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>为其提供服务。</p><h1 id="c005" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算机网络服务器</h1><p id="7dc4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于服务器，我们需要以下板条箱:</p><ul class=""><li id="3366" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">rocket="0.5.0-rc.2”</code></li><li id="8a1f" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">juniper={version="0.15.10",features=["uuid","chrono"]}</code></li><li id="36d3" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">juniper_rocket="0.8.2”</code>帮助整合杜松和火箭</li><li id="96d9" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">chrono={version="0.4.22",features=["serde"]}</code>用于创建时间戳并将其序列化到json</li><li id="1d88" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">uuid={version="0.8.2",features=["v4","serde"]}</code>用于创建UUIDs并将它们序列化为json</li></ul><p id="5ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们不会实现数据库，而是使用一个<a class="ae kv" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" rel="noopener ugc nofollow" target="_blank">散列表</a>来存储我们的数据。让我们首先声明所需板条箱的用途，并为<code class="fe my mz na nb b">Database</code>添加一个结构。我们的页面<code class="fe my mz na nb b">Object</code>将被称为<code class="fe my mz na nb b">Page</code>，我们将使用一个名为<code class="fe my mz na nb b">“home”</code>的字符串键来存储它。我们还需要让我们的领域访问我们的数据库。为此，我们需要为我们的<code class="fe my mz na nb b">Database</code>实现<code class="fe my mz na nb b">Context</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="aa7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些，我们将首先实现我们的模式并用内容初始化我们的数据库。接下来是内容，就像gRPC-web应用程序中的<a class="ae kv" href="https://editorjs.io/" rel="noopener ugc nofollow" target="_blank"> Editor.js </a>模式。</p><h2 id="bab0" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">(计划或理论的)纲要</h2><p id="4a2f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Juniper有定义GraphQL <a class="ae kv" href="https://docs.rs/juniper/0.15.10/juniper/attr.graphql_object.html" rel="noopener ugc nofollow" target="_blank">对象</a>和<a class="ae kv" href="https://docs.rs/juniper/0.15.10/juniper/attr.graphql_interface.html" rel="noopener ugc nofollow" target="_blank">接口</a>的宏。我们将使用它们。Juniper允许我们使用一个<a class="ae kv" href="https://graphql-rust.github.io/juniper/master/types/objects/defining_objects.html" rel="noopener ugc nofollow" target="_blank">结构</a>或者一个实现作为GraphQL对象。使用实现允许我们手动定义我们的解析器。例如，我们可以解析计算字段。这同样适用于GraphQL接口。</p><p id="6c43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先尝试一个简单的结构作为页面的GraphQL对象。对于我们的块，我们将使用一个向量，并将我们的块称为<code class="fe my mz na nb b">BlockValue</code>。一旦我们实现了我们的<code class="fe my mz na nb b">Block</code>接口，这一点就会变得很清楚，因为每一个<code class="fe my mz na nb b">Block </code>类型都需要成为一个<code class="fe my mz na nb b">Block</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="643b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要一个实现，因为我们想更容易地创建一个新的<code class="fe my mz na nb b">Page</code>。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8cfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，每个块类型都是一个<code class="fe my mz na nb b">Block</code>。因此我们将实现一个名为<code class="fe my mz na nb b">Block</code>的接口。这个<code class="fe my mz na nb b">Block</code>应该有两个标准字段<code class="fe my mz na nb b">id</code>和<code class="fe my mz na nb b">type</code>。由于<code class="fe my mz na nb b">type</code>是一个保留名称，我们需要对其进行重命名，并对其进行注释。因为我们为这个接口实现了三个对象，所以我们还需要给它们命名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="30cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe my mz na nb b">to_vec()</code>需要特征<code class="fe my mz na nb b">Clone</code>，我们必须为<code class="fe my mz na nb b">Interface</code>枚举实现它，枚举是由宏graphql_interface生成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以实现三种不同的<code class="fe my mz na nb b">Block</code>类型。我将只显示列表类型，因为其他两个几乎相同。<code class="fe my mz na nb b">block_type</code>将使用函数导出，不会存储在我们的数据库中。我们还将在我们的<code class="fe my mz na nb b">ListBlock</code>中添加一个<code class="fe my mz na nb b">new</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0b54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将实现接口和GraphQL对象。当我们使用我们的实现作为我们的对象时，我们将需要复制一些代码。如果你知道更好的解决方法，请告诉我。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="582d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">ListData</code>将有一个被约束为两个选项的样式字段。我们可以通过使用enum和<a class="ae kv" href="https://graphql-rust.github.io/juniper/master/types/enums.html" rel="noopener ugc nofollow" target="_blank"> GraphQLEnum </a>派生宏来实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a2a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以为我们的<code class="fe my mz na nb b">Page</code>实现<code class="fe my mz na nb b">Query</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="affd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也适用于<code class="fe my mz na nb b">ParagraphBlock</code>和<code class="fe my mz na nb b">HeaderBlock</code>。</p><h2 id="a345" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">数据库ˌ资料库</h2><p id="5aa4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe my mz na nb b">Database</code>需要两个功能:</p><ul class=""><li id="a31e" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个初始化数据库的新函数</li><li id="2489" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">get_page</code>函数获取逐页名称</li></ul><p id="f113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有页面，函数<code class="fe my mz na nb b">get_page</code>返回页面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="54ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于新函数，我们将初始化一个可变的<code class="fe my mz na nb b">HashMap</code>，然后插入我们的<code class="fe my mz na nb b">Pages</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="be7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们实现数据库和模式所需的全部内容。</p><h1 id="c2ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用</h1><p id="2739" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于与rocket的集成，我们坚持使用官方的<a class="ae kv" href="https://github.com/graphql-rust/juniper/blob/master/juniper_rocket/examples/rocket_server.rs" rel="noopener ugc nofollow" target="_blank">示例</a>。</p><p id="467a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这不包括CORS标题，我们将需要做出一些改变。有板条箱<a class="ae kv" href="https://docs.rs/rocket_cors/latest/rocket_cors/" rel="noopener ugc nofollow" target="_blank"> rocket_cors </a>来做这件事，但是它目前还不稳定，所以我们手动做。</p><p id="f537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要更多的导入，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法是创建一个<code class="fe my mz na nb b">Fairing</code>，它将把<code class="fe my mz na nb b">CORS</code>头添加到每个响应中。此外，我们将需要添加一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" rel="noopener ugc nofollow" target="_blank"> HTTP </a> <code class="fe my mz na nb b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" rel="noopener ugc nofollow" target="_blank">OPTIONS</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" rel="noopener ugc nofollow" target="_blank">方法</a>处理程序，这是<code class="fe my mz na nb b">CORS</code>所必需的。选项处理程序没有任何逻辑，因为唯一需要的是响应中的<code class="fe my mz na nb b">CORS</code>头。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们只需要添加新的路线，并将我们的<code class="fe my mz na nb b">CORS</code> <code class="fe my mz na nb b">Fairing</code>连接到我们的火箭&lt;构件&gt;上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ff2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方示例还包括一条GraphiQL路线。因此，通过启动我们的应用程序，我们已经可以尝试我们的服务器。让我们启动服务器，前往<code class="fe my mz na nb b"><a class="ae kv" href="http://127.0.0.1:8000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/</a></code>。</p><pre class="kg kh ki kj gt nv nb nw nx aw ny bi"><span id="e05b" class="nj lt iq nb b gy nz oa l ob oc">cargo run</span></pre><p id="fee9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样查询我们的服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="75f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">客户</h1><p id="25a3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">客户端与<a class="ae kv" href="https://medium.com/@christopher-scholz/building-a-website-using-rust-grpc-web-react-7412f1596a17" rel="noopener"> gRPC-web示例</a>中的相同，所以我只解释如何实现Apollo客户端。</p><p id="74de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要添加</p><ul class=""><li id="b5d2" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">@apollo/client@~3.7.0</code></li><li id="ee03" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">graphql@~16.6.0</code></li></ul><p id="b1e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">敬我们的包裹。</p><p id="6b4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe my mz na nb b">index.js</code>文件中，我们将实例化apollo客户机，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并添加<code class="fe my mz na nb b">ApolloProvider</code>组件作为<code class="fe my mz na nb b">React</code>组件的子组件。<code class="fe my mz na nb b">root.render</code>功能的其余部分保持不变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b603" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件将查询服务器并将数据存储在一个数据变量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">return函数将以与gRPC-web示例中相同的方式呈现块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是全部。我们现在可以运行我们的客户机和服务器，并浏览到<code class="fe my mz na nb b"><a class="ae kv" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a></code>。</p><pre class="kg kh ki kj gt nv nb nw nx aw ny bi"><span id="b801" class="nj lt iq nb b gy nz oa l ob oc">docker-compose up --build</span></pre><h1 id="864f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="7117" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Juniper有很好的文档记录。如果你不喜欢Rocket，其他很多集成都可以。此外，阿波罗客户端是非常完善的。你可能有的每一个问题都会在栈溢出时得到回答。</p><p id="0e5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢一切都很容易设置，以及它的工作原理。由于Juniper使用的是<a class="ae kv" href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" rel="noopener ugc nofollow" target="_blank">代码优先的方法</a>，我们将不得不编写相当多的代码。如果您喜欢使用<a class="ae kv" href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" rel="noopener ugc nofollow" target="_blank">模式优先的方法</a>,那么有一个<a class="ae kv" href="https://github.com/davidpdrsn/juniper-from-schema" rel="noopener ugc nofollow" target="_blank"> juniper-from-schema </a>的箱子可以做到这一点。</p><p id="cb8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的完整代码可以在<a class="ae kv" href="https://github.com/christopherscholz/rust_graphql_website" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>