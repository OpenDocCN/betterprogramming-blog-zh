<html>
<head>
<title>Python Wallpaper Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python壁纸引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-art-of-web-scraping-2-0-63fc2b49c7b6?source=collection_archive---------11-----------------------#2021-04-27">https://betterprogramming.pub/the-art-of-web-scraping-2-0-63fc2b49c7b6?source=collection_archive---------11-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b133" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python带来全新的日常外观</h2></div><p id="0a6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个项目中，你将学习一些新的网络抓取技巧，使用Python制作一个应用程序，自动找到桌面壁纸并将其应用到你的PC上。</p><p id="98ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们需要什么？</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c187" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">图像的来源</h1><p id="80cb" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">对于我们的图像来源，我们需要一个网站，有一个合适的分辨率和高质量的图像集合。它不应该使用JavaScript来加载图像，因为那样我们将无法使用<a class="ae mf" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup 4 </a>(用于高效网页抓取的Python库)，我们将不得不求助于一个实际上是自动化浏览器的库(例如<a class="ae mf" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>或<a class="ae mf" href="https://mechanicalsoup.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Mechanical Soup </a>)。它们有它们的用途，但是对于我们想要做的事情来说，它们往往是缓慢而低效的。</p><p id="326d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在的问题是，几乎所有的壁纸网站，如<a class="ae mf" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>和<a class="ae mf" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>都用JS加载图片，所以我们需要采取不同的方法。</p><p id="537e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Reddit是出了名的非常好刮，我看了一下，发现了几个图片和壁纸都很酷的subreddits。我找到的最好的一个是<a class="ae mf" href="https://www.reddit.com/r/wallpaper/" rel="noopener ugc nofollow" target="_blank"> r/wallpaper </a>，内容丰富。所以这将是我们的来源。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="12da" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">下载这些图片的方法</h1><p id="1fa9" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">用Reddit以编程方式获取帖子很容易。其实你根本不需要网页抓取库。</p><p id="afd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个subreddit URL的末尾，您可以键入<code class="fe mg mh mi mj b">/new.json</code>、<code class="fe mg mh mi mj b">/hot.json</code>或<code class="fe mg mh mi mj b">/top.json</code>来获得一个<a class="ae mf" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON文件</a>，其中包含该类别中所有最近帖子的所有数据。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5efe" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated"><span class="l mk ml mm bm mn mo mp mq mr di">M</span>JSON上的矿石</h1><p id="33b5" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">JSON代表JavaScript对象符号，它基本上是一种将字典保存到文件或从文件中加载字典的方法。很多API用它来返回数据，而且可以用Python来解析。</p><p id="d9e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试加载这个网址:<a class="ae mf" href="https://www.reddit.com/r/wallpaper/hot.json" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/wallpaper/hot.json</a>。</p><p id="b66a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，它的结构是:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="9c45" class="na lj iq mj b gy nb nc l nd ne">{“kind”: “X”, “data”: {“modhash”: “X”, “dist”: X, “children”: [{},{},{}]</span></pre><p id="8493" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们感兴趣的是最后一部分:<code class="fe mg mh mi mj b">"children"</code>。</p><p id="1945" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是一个字典数组，每个字典包含一篇文章的数据(标题、作者、内容等)。).</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="943c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着用Python来解析这个。</p><p id="89ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，导入内置的请求库，以便我们可以从URL获取JSON文件:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="276d" class="na lj iq mj b gy nb nc l nd ne">import requests</span></pre><p id="1f74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在使用从特定资源请求数据的<a class="ae mf" href="https://www.w3schools.com/tags/ref_httpmethods.asp" rel="noopener ugc nofollow" target="_blank"> HTTP GET </a>方法来获取JSON数据:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="d367" class="na lj iq mj b gy nb nc l nd ne">textData = requests.get("<a class="ae mf" href="https://www.reddit.com/r/wallpaper/hot.json" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/wallpaper/hot.json</a>").content</span></pre><p id="3dbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试打印请求的响应。在我的例子中，我被返回了<code class="fe mg mh mi mj b">{"message": "Too Many Requests", "error": 429}</code>。</p><p id="7a66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我没有发出太多请求，但服务器知道这不是来自浏览器或真正的Reddit应用程序的真正请求。</p><p id="66ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们需要在消息头中提供一个<a class="ae mf" href="https://en.wikipedia.org/wiki/User_agent" rel="noopener ugc nofollow" target="_blank">用户代理</a>。<a class="ae mf" href="https://www.whatismybrowser.com/guides/the-latest-user-agent/windows" rel="noopener ugc nofollow" target="_blank">该站点</a>显示了最新的用户代理，因此我将把它包含在我的请求头中:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="232b" class="na lj iq mj b gy nb nc l nd ne">myHeaders={"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36"}</span><span id="11a9" class="na lj iq mj b gy nf nc l nd ne">textData = requests.get("<a class="ae mf" href="https://www.reddit.com/r/wallpaper/hot.json" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/wallpaper/hot.json</a>",headers=myHeaders).content</span></pre><p id="ae63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次打印字符串后，我得到了我们想要的大型JSON文件。</p><p id="a3ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了文本形式的JSON数据，我们需要解析它，所以导入内置的JSON库:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="c7b1" class="na lj iq mj b gy nb nc l nd ne">import json</span></pre><p id="b284" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将文本数据转换成字典，我们将使用<code class="fe mg mh mi mj b">loads</code>方法。你可以在W3Schools 上阅读更多关于各种JSON方法<a class="ae mf" href="https://www.w3schools.com/python/python_json.asp" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="7d1c" class="na lj iq mj b gy nb nc l nd ne">jsonData = json.loads(textData)</span></pre><p id="d905" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按照我前面指出的结构，我们可以通过访问新构建的字典中不同索引处的条目来找到子节点(帖子)。我们会这样访问孩子:<code class="fe mg mh mi mj b">jsonData -&gt; "data" -&gt; "children"</code>。</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="af1f" class="na lj iq mj b gy nb nc l nd ne">posts = jsonData["data"]["children"]</span></pre><p id="a7fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你现在可以得到任何帖子的图片网址。让我们试试第一篇文章:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="b6c0" class="na lj iq mj b gy nb nc l nd ne">posts[0]["data"]["url"]</span></pre><p id="26e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给了我以下网址:<a class="ae mf" href="https://i.redd.it/24vbhq06y6v61.jpg" rel="noopener ugc nofollow" target="_blank">https://i.redd.it/24vbhq06y6v61.jpg</a>，这是一个全分辨率图像。我们需要想办法把这个存到磁盘上。</p><p id="57e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对图像的URL执行另一个HTTP GET请求，这将为我们提供图像的内容，并以字节模式将字节写入文件:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="56ad" class="na lj iq mj b gy nb nc l nd ne">imageContents = requests.get(posts[0]["data"]["url"],headers=myHeaders).content</span><span id="e195" class="na lj iq mj b gy nf nc l nd ne">with open("wallpaper.jpg","wb") as imageFile:<br/>     imageFile.write(imageContents)</span></pre><p id="30bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将成功地将其保存到磁盘。酷毙了。但是我们希望它是随机的，所以让我们将<code class="fe mg mh mi mj b">0</code>索引改为一个在<code class="fe mg mh mi mj b">0</code>和文章列表长度之间的随机数:</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="338d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在把它设为你的壁纸。</p><p id="2330" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<a class="ae mf" href="https://stackoverflow.com/questions/1977694/how-can-i-change-my-desktop-background-with-python" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出线程</a>，在Windows上，可以使用<code class="fe mg mh mi mj b">ctypes</code>模块。对我来说，这段代码有效:</p><pre class="ms mt mu mv gt mw mj mx my aw mz bi"><span id="f1eb" class="na lj iq mj b gy nb nc l nd ne">import ctypes</span><span id="261c" class="na lj iq mj b gy nf nc l nd ne">SPI_SETDESKWALLPAPER = 20</span><span id="42f8" class="na lj iq mj b gy nf nc l nd ne">ctypes.windll.user32.SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, "%USERPROFILE%/wallpaper.jpg" , 3)</span></pre><p id="26ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这对您不起作用，或者您使用的是Linux/Unix，那么看看这个线程，尝试一些不同的东西。</p><p id="bf4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将所有代码编译在一起，并在固定的时间间隔后重复:</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4a9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可能希望它在启动时运行。如果是这样，你也会希望它没有窗户，所以让我们来看看。</p><ul class=""><li id="1e9f" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">将Python文件另存为<code class="fe mg mh mi mj b">.pyw</code>而不是<code class="fe mg mh mi mj b">.py</code>。这意味着文件不创建窗口。</li></ul><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b44cdf73e270a14b61db70f68b5df518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*lrClYJj9YYSjnXLiMLBIgA.png"/></div></figure><ul class=""><li id="e807" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">右键单击<code class="fe mg mh mi mj b">.pyw</code>文件，然后单击“创建快捷方式”</li></ul><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3a56513eb3b51bf12d7318599962c1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*kEUNu-4tC8YvCZdtFzQAyQ.png"/></div></figure><ul class=""><li id="547f" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated">按Windows键+ R并键入<code class="fe mg mh mi mj b">shell:startup</code>。</li><li id="d438" class="nj nk iq kh b ki nw kl nx ko ny ks nz kw oa la no np nq nr bi translated">将新的快捷方式拖到新的浏览器窗口中。</li></ul><p id="9fca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你就完了。该脚本将在您每次启动电脑时运行，并每30分钟随机更换一次壁纸。</p></div></div>    
</body>
</html>