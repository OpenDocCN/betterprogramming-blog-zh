<html>
<head>
<title>Playing With Pipelines (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用管道(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/more-playing-with-pipelines-24a97f136722?source=collection_archive---------11-----------------------#2020-03-20">https://betterprogramming.pub/more-playing-with-pipelines-24a97f136722?source=collection_archive---------11-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2787" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建和部署现有项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e499eb22c018465c343d8b6c46e78f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SM7kvAkbjkgH8tB6CIFM2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=569145" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="432f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://medium.com/better-programming/playing-with-pipelines-b5cf357ddd06" rel="noopener">上一篇文章</a>中，我使用<a class="ae ky" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>创建了一个构建和部署单个(伪)微服务的管道。但是一个微服务不是一个系统。微服务的全部意义在于，您可以根据需要单独扩展和缩小系统的各个部分。其他好处包括隔离、使用不同表达式语言的能力，以及更好地控制系统中的数据流。我要用一个我创建的更复杂的系统，制作一系列管道。</p><p id="8512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文假设您已经阅读了我的前两篇文章，<a class="ae ky" href="https://medium.com/better-programming/playing-with-vms-and-kubernetes-26ef93019c22" rel="noopener">使用VMs和Kubernetes </a>和<a class="ae ky" href="https://medium.com/@rlkamradt/playing-with-pipelines-b5cf357ddd06" rel="noopener">使用管道</a>。您需要对Linux和命令行有一个基本的了解，以及对使用容器的基本了解，再加上我前两篇文章中收集的所有知识。</p><p id="32fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的大部分文章都是关于玩耍的，我坚信玩耍是最好的学习方式。就在昨天，一位寻求软件帮助的同事最终表示，她将继续使用这个系统，直到她弄明白为止。有时候玩游戏在特定的时间点并不有趣，比如当你试图找出如何在末日地牢中杀死老板时，但它几乎总是令人满意的。我应该指出我为我的最后一点拍摄的截图，看看圈起来的数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/ac21b478a0f070ea4ae879e71d4516f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jofRvpFTdwG1gfKQBa3XDw.png"/></div></div></figure><p id="c165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我运行这个管道52次，才最终解决了所有的错误！说到一个难对付的老板！</p><p id="c52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是哲学已经足够了。我要接一个演示几个微服务的项目，建立一些管道。这个项目叫做<a class="ae ky" href="https://github.com/rkamradt/MondoReacto" rel="noopener ugc nofollow" target="_blank"> MondoReacto </a>，它是用Java编写的。它已经有了一个<code class="fe lw lx ly lz b">Jenkinsfile</code>和<code class="fe lw lx ly lz b">build-pod.yaml</code>，但是我将忽略它们，并可能在以后删除它们以避免混淆。正如我在之前的构建中所做的那样，我将创建一个新的MondoReactoBuilder存储库来保存所有的构建代码。我几乎不会改变MondoReacto项目本身，而是专注于在新项目中建立管道。</p><p id="4ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MondoReacto的一个优点是它使用了谷歌的<a class="ae ky" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> Jib项目</a>。这是专门针对用<a class="ae ky" href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html" rel="noopener ugc nofollow" target="_blank"> Maven </a>构建的Java <a class="ae ky" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>项目的，只需要插件包含在<code class="fe lw lx ly lz b">pom</code>文件中。它不需要一个<code class="fe lw lx ly lz b">Dockerfile</code>或Docker守护进程，所以没有Docker-in-Docker的问题，而且它只需要很少的配置。不利的一面是，它内置于Maven构建中，因此您无法将微服务的构建与管道构建分开。但是我们可以很容易地绕过它。</p><p id="f916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先做一个简单的管道。这将只是提取源回购并运行构建。这里是<code class="fe lw lx ly lz b">Jenkinsfile</code>:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="12aa" class="me mf it lz b gy mg mh l mi mj">pipeline {<br/>    agent any<br/>    stages {<br/>        stage('Build Stage') {<br/>            agent {<br/>              kubernetes {<br/>              label 'maven'<br/>              idleMinutes 10<br/>              yamlFile 'pods/maven-pod.yaml'<br/>              defaultContainer 'maven'<br/>              }<br/>            }<br/>            steps {<br/>              git '<a class="ae ky" href="https://github.com/rkamradt/MondoReacto.git'" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/MondoReacto.git'</a><br/>              container('maven') {<br/>                sh 'mvn -B clean install'<br/>              }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="0624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建一个装载了Maven的Kubernetes pod，检查代码，然后运行Maven构建。我们还没有创建图像。这将是下一步。下面是<code class="fe lw lx ly lz b">pods/maven-pod.yaml</code>的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="09a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建Jenkins作业。这是一个非常简单的管道:您只需要指定存储库URL、凭证和Jenkins文件的位置。使用声明性管道的最大好处是，如果您不小心删除了管道(因为构建和删除链接就在旁边)，很容易重新创建。这是目前为止的管道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/54794dcb81859fe69cf59dbb9df976d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyKVRsrVhL5p3uph8zxy2A.png"/></div></div></figure><p id="6698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个问题:第一次构建需要两分钟，但是第二次构建只需要26秒。这是因为第一个构建必须从Maven Central获取世界，但是第二个构建可以使用仍然包含在pod中的本地缓存。由于pod会在闲置十分钟后消失，这将是一个持续的问题。</p><p id="2419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种可能的解决方案是将一个持久卷附加到pod并将本地缓存定向到那里，或者添加一个本地工件服务器，至少可以减轻Maven Central的负担。在本文中，我不会讨论这些策略，但是如果您打算将这些设置用于演示软件之外的其他用途，那么应该讨论一下。</p><p id="1a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到的另一件事是第一步大约是45秒，这太长了。看来默认的詹金斯从吊舱不会闲置很久。通过将空闲时间设置为60分钟，我可以将这个速度提高到大约1秒。单击管理Jenkins链接，然后配置系统。向下滚动到“云”部分，单击“窗格模板”按钮，然后单击“窗格详细信息”按钮。找到“空闲时保留代理的时间(分钟)”并将其设置为某个合理的值。那么你的第一阶段应该会减少很多。</p><p id="7457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是将所有图像部署到本地存储库。目前，Maven构建部署到Docker Hub，因此这将意味着更改MondoReacto项目。因为我希望MondoReacto项目可以在这个新管道之外构建，所以我将参数化容器repo并将其默认为Docker Hub。我还将允许不安全的注册，因为Kubernetes容器注册本质上是不安全的。下面是新的<code class="fe lw lx ly lz b">Jib</code>插件配置:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="38b2" class="me mf it lz b gy mg mh l mi mj">&lt;plugin&gt;<br/>  &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;<br/>  &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;1.6.1&lt;/version&gt;<br/>  &lt;configuration&gt;<br/>  &lt;to&gt;<br/>    &lt;image&gt;${container-repo}/incoming-persist:${project.version}&lt;/image&gt;<br/>  &lt;/to&gt;    <br/>  &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt;  &lt;/configuration&gt;<br/>&lt;/plugin&gt;</span></pre><p id="7182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的插件是如何在没有<code class="fe lw lx ly lz b">Dockerfile</code>的情况下创建图像的？它创建了三层:一层用于jar依赖项，一层用于本地类文件，一层用于资源。然后它找到你的Spring主文件并执行它。通过对您的Spring应用程序进行大量假设，不需要任何配置。它确实使用了谷歌无发行版的基本映像，但是你可以改变它。</p><p id="fc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，通过添加更多的配置，您可以改变很多东西，但是这种做法违背了约定优于配置的目的。我主要使用它，因为我想在Kubernetes中进行构建，而不是在Docker中与Docker纠缠。一个小小的不便是，它只部署到外部容器存储库。如果您正在使用Docker或Docker Compose，您需要在使用它之前将其拉出。</p><p id="04c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用它来构建图像，我们必须进入应用程序模块并运行<code class="fe lw lx ly lz b">mvn jib:build -Dcontainer-repo=registry.container-registry:5000</code>。这将为我们在MondoReacto的三个微服务构建映像。(我们也将为测试创建图像，但这还不在项目中。)</p><p id="960c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有外部化的Maven依赖缓存，所以构建映像必须和构建一起完成。下面是新的<code class="fe lw lx ly lz b">Jenkinsfile</code>部分:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="4300" class="me mf it lz b gy mg mh l mi mj">container('maven') {<br/>  sh """<br/>    mvn -B clean install<br/>    cd incoming-persist<br/>    mvn -B jib:build -Dcontainer-repo=registry.container-registry:5000<br/>    cd ../incoming-read-service<br/>    mvn -B jib:build -Dcontainer-repo=registry.container-registry:5000<br/>    cd incoming-service<br/>    mvn -B jib:build -Dcontainer-repo=registry.container-registry:5000<br/>  """<br/>}</span></pre><p id="f6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它，看看它是否工作。在修复了十几个愚蠢的错误后，成功了！</p><p id="78ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们部署和每个微服务。因为所有的部署都非常相似，所以我将使用一个管道来部署每个部署并对其进行参数化。我可以使用我上一篇文章中的<code class="fe lw lx ly lz b">Jenkinsfile</code>并修改它以使用参数。我还将删除测试阶段，因为我们还没有准备好作为映像运行测试。然后我可以在Jenkins中创建一个运行参数化管道的新作业，并对其进行测试。部署<code class="fe lw lx ly lz b">yaml</code>文件看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意带有IP地址的<code class="fe lw lx ly lz b">loadBalancerIP</code>。这是我最初设置Metallb(我在上一篇文章中安装的负载平衡器)时从IP地址范围中设置的。我设置它是因为我的入口是通过外部nginx的，我想保持外部IP稳定，这样我就不必在每次重新部署时重新配置nginx。</p><p id="229c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了三个<code class="fe lw lx ly lz b">yaml</code>文件:<code class="fe lw lx ly lz b">incoming-service.yaml</code>、<code class="fe lw lx ly lz b">incoming-persist.yaml</code>和<code class="fe lw lx ly lz b">incoming-read-service.yaml</code>——根据需要替换名称。另外，<code class="fe lw lx ly lz b">incoming-persist.yaml</code>不需要服务部分，只需要部署部分，因为它从消息队列中读取。对于完整的<code class="fe lw lx ly lz b">Jenkinsfile</code>，我将添加一个到repo的链接，以便您可以看到它，但是它看起来很像我在上一篇文章中创建的<code class="fe lw lx ly lz b">Jenkinsfile</code>，没有构建或测试部分。</p><p id="ba1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用一个名为<code class="fe lw lx ly lz b">DEPLOYMENTNAME</code>的选择参数来参数化新的Jenkins作业，有三个选择:<code class="fe lw lx ly lz b">incoming-service</code>、<code class="fe lw lx ly lz b">incoming-persis</code> t和<code class="fe lw lx ly lz b">incoming-read-service</code>。然后在<code class="fe lw lx ly lz b">Jenkinsfile</code>中，我用<code class="fe lw lx ly lz b">${parameters.DEPLOYMENTNAME}.yaml</code>替换了所有的部署<code class="fe lw lx ly lz b">yaml</code>文件，这样一个管道就可以在所有的环境(开发、测试、生产)中构建所有的服务。这是我对詹金斯工作的唯一修改；其他的都是从构建作业中复制的，到<code class="fe lw lx ly lz b">Jenkinsfile</code>的路径被改为<code class="fe lw lx ly lz b">pipelines/deploy/Jenkinsfile</code>。</p><p id="e267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在纠正了一些拼写错误后，我能够运行并部署所有的服务了。查看<code class="fe lw lx ly lz b">kubectl get services --all-namespaces</code>的输出，我可以看到它们都在运行。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="8088" class="me mf it lz b gy mg mh l mi mj">NAMESPACE            NAME                    TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)                  AGE<br/>container-registry   registry                NodePort       10.152.183.65    &lt;none&gt;            5000:32000/TCP           3h9m<br/>default              jenkins                 LoadBalancer   10.152.183.138   192.168.122.240   8080:30816/TCP           9d<br/>default              jenkins-agent           ClusterIP      10.152.183.166   &lt;none&gt;            50000/TCP                9d<br/>default              kubernetes              ClusterIP      10.152.183.1     &lt;none&gt;            443/TCP                  9d<br/>kube-system          kube-dns                ClusterIP      10.152.183.10    &lt;none&gt;            53/UDP,53/TCP,9153/TCP   9d<br/>kube-system          kubelet                 ClusterIP      None             &lt;none&gt;            10250/TCP                40h<br/>mondoreacto-dev      incoming-read-service   LoadBalancer   10.152.183.230   192.168.122.244   80:31517/TCP             15m<br/>mondoreacto-dev      incoming-service        LoadBalancer   10.152.183.19    192.168.122.241   80:31560/TCP             67m<br/>mondoreacto-prod     incoming-read-service   LoadBalancer   10.152.183.120   192.168.122.246   80:31432/TCP             15m<br/>mondoreacto-prod     incoming-service        LoadBalancer   10.152.183.116   192.168.122.243   80:31086/TCP             67m<br/>mondoreacto-test     incoming-read-service   LoadBalancer   10.152.183.108   192.168.122.245   80:31285/TCP             15m<br/>mondoreacto-test     incoming-service        LoadBalancer   10.152.183.124   192.168.122.242   80:31581/TCP             67m</span></pre><p id="3b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lw lx ly lz b">incoming-persist</code>没有服务，因为它没有服务定义。</p><p id="bdf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看看豆荚，我们可以看到他们都在运行。然而，如果我们查看日志，我们可以看到他们失败得很惨。</p><p id="d96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务有一些要求，Kafka和MongoDB。我们应该将它们安装到不同的名称空间中，看看这样是否会让这些服务更好用。</p><p id="ebb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们用helm文件安装Jenkins一样，我们也可以用Helm文件安装MongoDB和Kafka。要安装MongoDB，请运行以下命令:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="bfe5" class="me mf it lz b gy mg mh l mi mj">helm install mongodb stable/mongodb -n mondoreacto-dev<br/>helm install mongodb stable/mongodb -n mondoreacto-test<br/>helm install mongodb stable/mongodb -n mondoreacto-prod</span></pre><p id="c900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kafka来自不同的Helm库，所以我们必须先添加它，但除此之外，都是一样的。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="63f0" class="me mf it lz b gy mg mh l mi mj">helm repo add incubator <a class="ae ky" href="http://storage.googleapis.com/kubernetes-charts-incubator" rel="noopener ugc nofollow" target="_blank">http://storage.googleapis.com/kubernetes-charts-incubator</a><br/>helm install kafka incubator/kafka -n mondoreacto-dev<br/>helm install kafka incubator/kafka -n mondoreacto-test<br/>helm install kafka incubator/kafka -n mondoreacto-prod</span></pre><p id="7a34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了访问这些新服务，我们可以将它们放在不同的<code class="fe lw lx ly lz b">yaml</code>文件中。这里是<code class="fe lw lx ly lz b">incoming-persist.yaml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的<code class="fe lw lx ly lz b">env</code>部分将被添加到<code class="fe lw lx ly lz b">incoming-service.yaml</code>和<code class="fe lw lx ly lz b">incoming-read-service.yaml</code>中。由于我们构建应用程序的方式，<code class="fe lw lx ly lz b">incoming-persist</code>服务需要访问MongoDB，即使它不使用它。Spring在类路径中寻找感兴趣的组件，并试图启动它们，即使我们从来不使用它们。我们需要重新构建我们的应用程序，从类路径中排除MongoDB组件，或者在类扫描中加入排除项。目前，我们不会担心这个问题。</p><p id="ef6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lw lx ly lz b">kubectl get services -n mondoreacto-dev</code>找到<code class="fe lw lx ly lz b">incoming-read-service</code>的外部IP地址，看看能不能用<code class="fe lw lx ly lz b">http://&lt;ipaddress&gt;/incoming</code>把它卷起来，应该会返回一个空列表(因为我们还没有给<code class="fe lw lx ly lz b">incoming-service</code>发送任何东西)。但是，它会返回一条错误消息，这是我们应该预料到的:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b690" class="me mf it lz b gy mg mh l mi mj">curl <a class="ae ky" href="http://192.168.122.242/incoming" rel="noopener ugc nofollow" target="_blank">http://192.168.122.242/incoming</a><br/>{<br/>  "timestamp":"2020-03-17T20:32:36.273+0000",<br/>  "path":"/incoming",<br/>  "status":500,<br/>  "error":"Internal Server Error",<br/>  "message":"Query failed with error code 13 and error message 'command find requires authentication' on server mongodb:27017; nested exception is com.mongodb.MongoQueryException: Query failed with error code 13 and error message 'command find requires authentication' on server mongodb:27017",<br/>  "requestId":"9807dc29"<br/>}</span></pre><p id="dbe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要提供凭证来访问MongoDB。但至少我们知道可以和MongoDB对话。</p><p id="03c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您为MongoDB安装Helm chart时，它应该已经打印出了一些关于如何使用它的说明。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="e203" class="me mf it lz b gy mg mh l mi mj">NAME: mongodb<br/>LAST DEPLOYED: Tue Mar 17 00:46:25 2020<br/>NAMESPACE: mondoreacto-prod<br/>STATUS: deployed<br/>REVISION: 1<br/>TEST SUITE: None<br/>NOTES:<br/>** Please be patient while the chart is being deployed **</span><span id="e93f" class="me mf it lz b gy mn mh l mi mj">MongoDB can be accessed via port 27017 on the following DNS name from within your cluster:</span><span id="0202" class="me mf it lz b gy mn mh l mi mj">mongodb.mondoreacto-prod.svc.cluster.local</span><span id="24a1" class="me mf it lz b gy mn mh l mi mj">To get the root password run:</span><span id="aeab" class="me mf it lz b gy mn mh l mi mj">export MONGODB_ROOT_PASSWORD=$(kubectl get secret --namespace mondoreacto-prod mongodb -o jsonpath="{.data.mongodb-root-password}" | base64 --decode)</span><span id="9a36" class="me mf it lz b gy mn mh l mi mj">To connect to your database run the following command:</span><span id="c251" class="me mf it lz b gy mn mh l mi mj">kubectl run --namespace mondoreacto-prod mongodb-client --rm --tty -i --restart='Never' --image docker.io/bitnami/mongodb:4.2.3-debian-10-r31 --command -- mongo admin --host mongodb --authenticationDatabase admin -u root -p $MONGODB_ROOT_PASSWORD</span><span id="baa1" class="me mf it lz b gy mn mh l mi mj">To connect to your database from outside the cluster execute the following commands:</span><span id="f735" class="me mf it lz b gy mn mh l mi mj">kubectl port-forward --namespace mondoreacto-prod svc/mongodb 27017:27017 &amp;<br/>    mongo --host 127.0.0.1 --authenticationDatabase admin -p $MONGODB_ROOT_PASSWORD</span></pre><p id="3469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是描述如何设置<code class="fe lw lx ly lz b">MONGODB_ROOT_PASSWORD</code>环境变量的那一行。您可以看到，它已经将其密码嵌入到Kubernetes的一个秘密中，因此我们只需将该秘密传递给我们的服务。</p><p id="2b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在中运行MongoDB和Kafka时，需要添加一些属性来配置如何访问它们。在MondoReacto项目中，一切都在运行，每个人都信任每个人。所以现在我们必须为MondoReacto项目中的服务对<code class="fe lw lx ly lz b">application.properties</code>进行更改。即使不是所有的服务都使用MongoDB和Kafka，我们也可以对每个人使用相同的属性文件。这是我想到的:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="4fea" class="me mf it lz b gy mg mh l mi mj">spring.data.mongodb.host=mongodb<br/>spring.data.mongodb.password=${MONGODB_ROOT_PASSWORD}<br/>spring.data.mongodb.authentication-database=admin<br/>spring.data.mongodb.username=root<br/>spring.data.mongodb.database=incoming<br/>spring.data.mongodb.port=27017<br/>kafka.bootstrap.address=kafka:9092</span></pre><p id="4e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要确保这些设置在<code class="fe lw lx ly lz b">yaml</code>文件中。这里是<code class="fe lw lx ly lz b">incoming-read-service.yaml</code>环境部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="12d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">desc目录中的所有<code class="fe lw lx ly lz b">yaml</code>文件应该有相似的环境设置。</p><p id="f2dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些事情。我们设置<code class="fe lw lx ly lz b">SPRING_DATA_MONGODB_HOST</code>，并将其设置为Kubernetes提供的主机DNS名称。由于MongoDB、Kafka和我们的微服务之间的名称空间是相同的，所以只需要服务名。这也意味着对于<code class="fe lw lx ly lz b">-dev</code>、<code class="fe lw lx ly lz b">-test</code>和<code class="fe lw lx ly lz b">-prod</code>名称空间，每个人只与运行在同一个名称空间中的服务对话。</p><p id="c7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spring会自动将<code class="fe lw lx ly lz b">SPRING_DATA_MONGODB_HOST</code>映射到<code class="fe lw lx ly lz b">application.properties</code>文件中的<code class="fe lw lx ly lz b">spring.data.mongodb.host</code>属性。我总是尝试用大写/下划线表示环境变量，用小写/点表示属性。</p><p id="8cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后要注意的是<code class="fe lw lx ly lz b">MONGODB_ROOT_PASSWORD</code>是从存储在Kubernetes中的秘密值中收集的。您的密码再也不应该存储在四处传递的文件中，最终不可避免地会出现在您的Git存储库中。</p><p id="1ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该从Jenkins重新运行构建作业，然后从Jenkins运行各种部署作业(每个服务一个)。这样做之后，我们就可以设置nginx反向代理了。这个设置的反向代理与我们到目前为止设置的略有不同。这是因为我们希望<code class="fe lw lx ly lz b">POST</code>和<code class="fe lw lx ly lz b">GET</code>访问看起来来自同一个服务器，即使它们由不同的微服务处理。因此，使用一点路径技巧，我们可以像这样完成:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="6d30" class="me mf it lz b gy mg mh l mi mj">server {<br/>  listen 80;<br/>  listen [::]:80;</span><span id="14bb" class="me mf it lz b gy mn mh l mi mj">#Server DNS name<br/>  server_name incoming;<br/>  ignore_invalid_headers off; #pass through headers from Jenkins which are considered invalid by Nginx server.</span><span id="8a55" class="me mf it lz b gy mn mh l mi mj">location /read/incoming {<br/>      # use the name from the upstream section (no ip:port necessary)<br/>      proxy_pass <a class="ae ky" href="http://192.168.122.245:80/incoming" rel="noopener ugc nofollow" target="_blank">http://192.168.122.245:80/incoming</a>;<br/>      sendfile off;<br/>      proxy_redirect     default;<br/>      proxy_http_version 1.1;</span><span id="a264" class="me mf it lz b gy mn mh l mi mj">proxy_set_header   Host              $host;<br/>      proxy_set_header   X-Real-IP         $remote_addr;<br/>      proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;<br/>      proxy_set_header   X-Forwarded-Proto $scheme;<br/>      proxy_max_temp_file_size 0;</span><span id="c62f" class="me mf it lz b gy mn mh l mi mj">#this is the maximum upload size<br/>      client_max_body_size       10m;<br/>      client_body_buffer_size    128k;</span><span id="b4d6" class="me mf it lz b gy mn mh l mi mj">proxy_connect_timeout      90;<br/>      proxy_send_timeout         90;<br/>      proxy_read_timeout         90;<br/>      proxy_buffering            off;<br/>      proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins &gt; 2.54<br/>      proxy_set_header Connection ""; # Clear for keepalive<br/>   }<br/>   location /post/incoming {<br/>      # use the name from the upstream section (no ip:port necessary)<br/>      proxy_pass <a class="ae ky" href="http://192.168.122.241:80/incoming" rel="noopener ugc nofollow" target="_blank">http://192.168.122.241:80/incoming</a>;<br/>      sendfile off;<br/>      proxy_redirect     default;<br/>      proxy_http_version 1.1;</span><span id="0318" class="me mf it lz b gy mn mh l mi mj">proxy_set_header   Host              $host;<br/>      proxy_set_header   X-Real-IP         $remote_addr;<br/>      proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;<br/>      proxy_set_header   X-Forwarded-Proto $scheme;<br/>      proxy_max_temp_file_size 0;</span><span id="94ca" class="me mf it lz b gy mn mh l mi mj">#this is the maximum upload size<br/>      client_max_body_size       10m;<br/>      client_body_buffer_size    128k;</span><span id="28bb" class="me mf it lz b gy mn mh l mi mj">proxy_connect_timeout      90;<br/>      proxy_send_timeout         90;<br/>      proxy_read_timeout         90;<br/>      proxy_buffering            off;<br/>      proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins &gt; 2.54<br/>      proxy_set_header Connection ""; # Clear for keepalive<br/>   }<br/>      <br/>}</span></pre><p id="62f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我留下了一些对于像Jenkins这样的老式MVC客户机-服务器系统来说最必要的东西。我确信有一个nginx天才可以用三行代码做到这一点。但是这个管用，我就不去管了。</p><p id="8782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以一旦这些都准备好了，我就让邮递员出来试一试，非常失望地发现什么都没用。似乎MondoReacto项目处于建设中，所以我不得不进去做一些调试和检测工作。但是一旦解决了这个问题，我就有了两个端点:对<a class="ae ky" href="http://incoming/post/incoming" rel="noopener ugc nofollow" target="_blank">http://incoming/POST/incoming</a>的POST将在数据库中存储一些JSON，对<a class="ae ky" href="http://incoming/read/incoming" rel="noopener ugc nofollow" target="_blank">http://incoming/read/incoming</a>的GET将返回所有数据，或者对<a class="ae ky" href="http://incoming/read/incoming/{key}" rel="noopener ugc nofollow" target="_blank">http://incoming/read/incoming/{ key }</a>的GET将返回一个条目。</p><p id="abe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们离这个系统还远着呢。构建应该启动部署。部署应该运行测试。我们也许应该有某种日志嗅探器，这样我们就不会沦落到<code class="fe lw lx ly lz b">kubectl logs</code>。图像标签之间可能应该有一些协调，以便当图像从开发到测试再到生产时，它们被必要地标记。但这篇文章我看完了。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="a143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，我们已经取得了一个现有的项目，并创建了一个构建/部署管道，对代码进行了最小的更改。</p><p id="9dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建脚本的代码可以在这里找到:<a class="ae ky" href="https://github.com/rkamradt/MondoReactoBuild/releases/tag/v1.0" rel="noopener ugc nofollow" target="_blank">https://github . com/rkamradt/mondoreactbuild/releases/tag/v 1.0</a></p><p id="f3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际运行的MondoReacto项目可以在这里找到:<a class="ae ky" href="https://github.com/rkamradt/MondoReacto/releases/tag/v1.0" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/MondoReacto/releases/tag/v1.0</a></p><p id="da29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信我很快就会再次写作，只要我能找到我下一步想改进的领域。</p></div></div>    
</body>
</html>