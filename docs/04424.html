<html>
<head>
<title>Use id() to Understand 6 Key Concepts in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用id()理解Python中的6个关键概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-id-to-understand-6-key-concepts-in-python-73e0bbd461ec?source=collection_archive---------3-----------------------#2020-04-13">https://betterprogramming.pub/use-id-to-understand-6-key-concepts-in-python-73e0bbd461ec?source=collection_archive---------3-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ec5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发现引擎盖下的机械</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cf33792472ba7f264f05528337b2abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q4vhULW81mN53uH3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tma?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">天一马</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="0045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有超过70个内置函数<a class="ae ky" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank">可供任何Python解释器在启动时使用。每个Python学习者都不应该对一些常见的不熟悉。例如，我们可以使用<code class="fe lv lw lx ly b">len()</code>来获取一个对象的长度，比如一个列表或字典中的条目数。再比如，我们可以使用<code class="fe lv lw lx ly b">print()</code>打印出感兴趣的对象，用于学习和调试。</a></p><p id="7b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，几乎所有的Python程序员都应该在教程中看到过使用内置的<code class="fe lv lw lx ly b">id()</code>函数来演示特定的Python概念。然而，据我所知，这些信息是分散的。在本文中，我将提供一个使用<code class="fe lv lw lx ly b">id()</code>函数理解六个关键Python概念的系统回顾。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1a94" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.在Python中，一切都是对象</h1><p id="ed34" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">作为一种流行的面向对象编程语言，Python在其实现中处处使用对象。例如，整数、浮点数、字符串、列表和字典等内置数据类型都是对象。此外，函数、类、甚至模块也被用作对象。</p><p id="ddaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，<code class="fe lv lw lx ly b">id()</code>函数接受一个对象并返回该对象的标识，即以整数表示的内存地址。因此，我们可以使用这个函数来证明Python中的一切都是对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python对象和id()函数。</p></figure><p id="189d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，您可以看到<code class="fe lv lw lx ly b">objects</code>列表中的每一项都可以在<code class="fe lv lw lx ly b">id()</code>函数中使用，它揭示了每个对象的内存地址。</p><p id="f7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的操作，我认为非常有趣，作为一个函数本身，<code class="fe lv lw lx ly b">id()</code>函数也应该有它的内存地址。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="f361" class="nj mh it ly b gy nk nl l nm nn">&gt;&gt;&gt; print(f'{type(id)} with id: {id(id)}')<br/>&lt;class 'builtin_function_or_method'&gt; with id: 4480774224</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0acf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.变量赋值和别名</h1><p id="7731" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们在Python中创建变量时，我们通常使用以下语法:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="2116" class="nj mh it ly b gy nk nl l nm nn">var_name = the_object</span></pre><p id="7903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程基本上将在内存中创建的对象绑定到特定的变量名。如果我们给一个变量赋值另一个变量，比如<code class="fe lv lw lx ly b">var_name1 = var_name</code>，会发生什么？</p><p id="178b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。在下面的代码片段中，我们首先创建了一个名为<code class="fe lv lw lx ly b">hello</code>的变量，并为其分配了一个字符串值。接下来，我们通过给前面的变量<code class="fe lv lw lx ly b">hello</code>赋值来创建另一个变量<code class="fe lv lw lx ly b">world</code>。当我们打印出它们的内存地址时，我们发现<code class="fe lv lw lx ly b">hello</code>和<code class="fe lv lw lx ly b">world</code>有相同的内存地址，这表明它们是内存中的同一个对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变量赋值和别名。</p></figure><p id="4875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，变量<code class="fe lv lw lx ly b">world</code>通常被称为变量<code class="fe lv lw lx ly b">hello</code>的别名，并且通过分配现有变量来创建新变量的过程可以被称为别名。在其他编程语言中，别名非常类似于内存中底层对象的指针或引用。</p><p id="8479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们可以进一步看到，当我们为字典创建别名并修改别名的数据时，修改也适用于原始变量，因为在幕后，我们修改了内存中的同一个字典对象。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8e44" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.比较运算符:== vs. is</h1><p id="3559" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在各种场景中，我们需要比较两个对象作为决策点，以便在满足或不满足特定条件时应用不同的功能。在等式比较方面，我们可以使用两个比较运算符:<code class="fe lv lw lx ly b">==</code>和<code class="fe lv lw lx ly b">is</code>。一些新的Python学习者可能会错误地认为它们是一样的，但是还是有细微差别的。</p><p id="459d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。我们创建了相同项目的两个列表。当我们使用<code class="fe lv lw lx ly b">==</code>操作符比较两个列表时，比较结果是<code class="fe lv lw lx ly b">True</code>。当我们使用<code class="fe lv lw lx ly b">is</code>操作符比较两个列表时，比较结果是<code class="fe lv lw lx ly b">False</code>。为什么它们会产生不同的结果？是因为<code class="fe lv lw lx ly b">==</code>运算符比较的是值，而<code class="fe lv lw lx ly b">is</code>运算符比较的是身份(即内存地址)。</p><p id="e06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所期望的，引用内存中相同对象的变量，它们不仅有相同的值，而且有相同的标识。这导致<code class="fe lv lw lx ly b">==</code>和<code class="fe lv lw lx ly b">is</code>操作员的评估结果相同，如下面涉及<code class="fe lv lw lx ly b">str0</code>和<code class="fe lv lw lx ly b">str1</code>的示例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较运算符。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5c39" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.整数缓存</h1><p id="a9fa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们在编程中经常使用的一组数据是整数。在Python中，解释器通常会缓存-5到256范围内的小整数。这意味着当Python解释器启动时，这些整数将被创建，并在内存中供以后使用。以下代码片段展示了这一特性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">整数缓存。</p></figure><p id="9317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我创建了两个字典，<code class="fe lv lw lx ly b">id_counters</code>跟踪每个整数的唯一标识的数量，<code class="fe lv lw lx ly b">id_records</code>跟踪该整数的最新标识。对于-10到265范围内的整数，如果新整数的标识不同于现有的标识，则相应的计数器加1。这个过程我重复了1000次。</p><p id="a5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行代码使用列表理解技术向您展示了具有多个单位的整数。显然，经过1000次之后，从-5到256的整数每一个都只有一个单位，正如上一段所讨论的。要了解更多关于Python的列表理解，可以参考我以前的一篇文章:</p><div class="no np gp gr nq nr"><a href="https://medium.com/better-programming/9-things-to-know-to-master-list-comprehensions-in-python-8bc0411ec2ed" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">掌握Python中列表理解的9件事</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">本教程将帮助你学习Python中列表理解的最常见用法</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3556" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.浅拷贝和深拷贝</h1><p id="d51f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，我们需要制作现有对象的副本，这样我们可以在不改变另一个副本的情况下改变一个副本。内置的<code class="fe lv lw lx ly b">copy</code>模块为此提供了两种方法:<code class="fe lv lw lx ly b">copy()</code>和<code class="fe lv lw lx ly b">deepcopy()</code>，分别制作浅层副本和深层副本。如果你不知道它们是什么，让我们利用<code class="fe lv lw lx ly b">id()</code>函数来理解这两个概念。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">浅拷贝和深拷贝。</p></figure><p id="3d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建了一个名为<code class="fe lv lw lx ly b">original</code>的列表变量，它由一个嵌套列表和两个整数组成。然后我们分别使用<code class="fe lv lw lx ly b">copy()</code>和<code class="fe lv lw lx ly b">deepcopy()</code>方法制作了两个副本(<code class="fe lv lw lx ly b">copy0</code>和<code class="fe lv lw lx ly b">copy1</code>)。正如我们所料，<code class="fe lv lw lx ly b">original</code>、<code class="fe lv lw lx ly b">copy0</code>和<code class="fe lv lw lx ly b">copy1</code>具有相同的值(即<code class="fe lv lw lx ly b">[[0, 1], 2, 3]</code>)。然而，它们有不同的身份，因为与别名不同，<code class="fe lv lw lx ly b">copy()</code>和<code class="fe lv lw lx ly b">deepcopy()</code>方法都在内存中创建新的对象，因此新的副本有不同的身份。</p><p id="7081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浅拷贝和深拷贝之间最本质的区别是，深拷贝将为原始复合对象递归地创建拷贝，而浅拷贝将维护对现有对象的引用(如果适用)。在上面的例子中，变量<code class="fe lv lw lx ly b">original</code>实际上是一个复合对象(即一个列表嵌套在另一个列表中)。</p><p id="cd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，使用<code class="fe lv lw lx ly b">copy()</code>方法，变量<code class="fe lv lw lx ly b">copy0</code>的第一个元素与<code class="fe lv lw lx ly b">original</code>的第一个元素具有相同的身份(即相同的对象)。相比之下，<code class="fe lv lw lx ly b">deepcopy()</code>方法会在内存中复制嵌套列表，这样<code class="fe lv lw lx ly b">copy1</code>中的第一个元素就与<code class="fe lv lw lx ly b">original</code>中的不同</p><p id="2643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是深度复制中的“递归”是什么意思呢？这意味着如果有多层嵌套(例如，一个列表嵌套在一个列表中，而这个列表又嵌套在另一个列表中)，<code class="fe lv lw lx ly b">deepcopy()</code>方法将为每一层创建新的对象。有关此功能，请参见以下示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">deepcopy()中的递归。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5b90" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.数据可变性</h1><p id="a2cb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Python编程中的一个高级主题与数据可变性有关。一般来说，不可变数据是那些在创建后其值不能被改变的对象，比如整数、字符串和元组。相比之下，可变数据指的是那些在创建后其值可以改变的对象，比如列表、字典和集合。</p><p id="5781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一个关键点是，我们所说的“改变值”是指内存中的底层对象是否可以改变。关于数据可变性的详细讨论可以在我以前的文章中找到:</p><div class="no np gp gr nq nr"><a href="https://medium.com/swlh/6-things-to-understand-python-data-mutability-b52f5c5db191" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">理解Python数据可变性的6件事</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">不可变与可变</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div><p id="b1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文讨论id <code class="fe lv lw lx ly b">()</code>函数的目的，让我们考虑下面的例子。对于不可变的数据类型(代码片段中的整数变量<code class="fe lv lw lx ly b">thousand</code>，当我们试图改变它的值时，一个新的整数在内存中被创建，正如变量<code class="fe lv lw lx ly b">thousand</code>的新标识所反映的那样。换句话说，原始的底层整数对象不能被改变。改变整数的尝试导致在内存中创建了一个新的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据可变性和id()。</p></figure><p id="3649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这让您感到困惑，让我们看看可变数据类型发生了什么——在我们的例子中，是变量<code class="fe lv lw lx ly b">numbers</code>。如上面的代码所示，当我们试图改变<code class="fe lv lw lx ly b">numbers</code>的值时，变量<code class="fe lv lw lx ly b">numbers</code>得到了更新，更新后的列表仍然具有相同的标识，这证实了<code class="fe lv lw lx ly b">list</code>类型的对象的可变性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4c83" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">外卖食品</h1><p id="46ef" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我们利用内置的<code class="fe lv lw lx ly b">id()</code>函数来理解Python中的六个关键概念。以下是这些概念的简要回顾:</p><ul class=""><li id="2040" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">Python中的一切都是对象。</li><li id="a7ae" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">我们通过赋值来创建变量，别名指向内存中相同的对象。</li><li id="374c" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">比较运算符<code class="fe lv lw lx ly b">==</code>比较值，而比较运算符<code class="fe lv lw lx ly b">is</code>比较恒等式。</li><li id="6868" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">Python解释器在启动时创建从-5到256的整数对象。</li><li id="f7be" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">浅拷贝和深拷贝都具有与其原始对象相同的值，但是浅拷贝仅拷贝原始对象的嵌套对象的引用。</li><li id="0214" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">可变对象的值可以在内存中更改，而不可变对象不支持值更改。</li></ul></div></div>    
</body>
</html>