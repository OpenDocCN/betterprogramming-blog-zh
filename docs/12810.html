<html>
<head>
<title>Path to a Perfect Go Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通往完美Go Dockerfile文件的路径</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/path-to-a-perfect-go-dockerfile-f7fe54b5c78c?source=collection_archive---------4-----------------------#2022-07-04">https://betterprogramming.pub/path-to-a-perfect-go-dockerfile-f7fe54b5c78c?source=collection_archive---------4-----------------------#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="15ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个小而安全的Go docker形象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6126559164fd7d2ad50207f873630013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aDt6npi-Kb56Xm02"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贾斯汀·考夫曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成在云环境中部署代码，最后一步是配置和部署pod的容器映像。目的地就在眼前，但是仍然有一个问题需要考虑:不是每个映像都适合部署，但是需要满足两个标准。</p><ul class=""><li id="1586" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">足够小</strong>。图像大小在一定程度上决定了我们的云开销，当一个pod是几MB甚至几十MB的时候是无法注意到的。然而，当它扩展到数千或数万个pod时，额外的内存成本将飙升至数百万，最终导致额外的实例成本(以GKE E2为例，最高为128GB)。所以，越小越好。</li><li id="c22a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">安全</strong>。为了将损害映像安全性的可能性降至最低，我们在构建映像时应该注意，例如<strong class="lb iu">不要直接复制<code class="fe mj mk ml mm b">Dockerfile</code>中的</strong>密钥，尤其是如果服务部署在公共云上。</li></ul><p id="2ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开门见山。先从建立Go镜像(Go 1.18)开始，然后一步一步优化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/7da59d0e55866e8df4e2cae911bcfd90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8-WtHvAVNEufFro"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自unsplash，<a class="ae ky" href="https://unsplash.com/photos/Rv-O5fmUKbU" rel="noopener ugc nofollow" target="_blank"> @anniespratt </a></p></figure><h1 id="1d24" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">构建Go图像</h1><p id="0dca" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在我之前的文章中，我用Go构建了一个<a class="ae ky" href="https://github.com/slaise/localcache" rel="noopener ugc nofollow" target="_blank">缓存包</a>，只能作为第三方被其他Go代码引用。为了使它成为一个独立的缓存服务，你只需要</p><ul class=""><li id="3bf1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建<code class="fe mj mk ml mm b">Put/Get</code>接口。这一点并不是我们要展开的地方，不过有兴趣的可以抢一下<a class="ae ky" href="https://gist.github.com/slaise/c515bbc3d47dc48aaec1f593615c29a8" rel="noopener ugc nofollow" target="_blank">代码</a>。​</li><li id="5f7b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建一个<code class="fe mj mk ml mm b">Dockerfile</code>并将其部署到云中，这是我们今天的主要关注点。</li></ul><p id="3b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在写一个<code class="fe mj mk ml mm b">Dockerfile</code>之前，我们应该始终明白它是什么:</p><p id="376a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nl">容器的一组命令，可以独立构建和运行代码</em> </strong>。</p><p id="f388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一部<code class="fe mj mk ml mm b">Dockerfile</code>由什么组成？答案就在运行Go程序所需的两个步骤中。</p><ul class=""><li id="25e6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">编译，运行<code class="fe mj mk ml mm b">go build main.go</code>。</li><li id="ff80" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行，运行<code class="fe mj mk ml mm b">go run main.go</code>。</li></ul><p id="3bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两步都需要一些先决条件，比如Go包和当前目录下的所有文件，像<code class="fe mj mk ml mm b">go.mod</code>，都需要编译代码；web程序要求暴露端口8000。我们应该在Dockerfile文件中包含的内容似乎更清楚，如下6行。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="53e5" class="nq mp it mm b gy nr ns l nt nu"><em class="nl"># Base image, golang 1.18<br/></em>FROM golang:1.18.3<em class="nl"><br/></em>WORKDIR /workspace<br/><em class="nl"># Copy all files into the image<br/></em>COPY . .<br/><em class="nl"># Run go mod<br/></em>RUN go mod download<br/><em class="nl"># Expose ports<br/></em>EXPOSE 8000<br/><em class="nl"># Run Go program, just like locally<br/></em>ENTRYPOINT ["go","run","main.go"]</span></pre><p id="9f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，运行<code class="fe mj mk ml mm b">docker build . -t localcache_srv</code>来查看图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ce9a6d892f10545c21b6166f5e9e5008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dfyGtoYzibkoLUzQ"/></div></div></figure><p id="2336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀，图像大小几乎达到1GB！一定是哪里出了问题。</p><p id="7cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看图像中有什么，并找出原因。运行<code class="fe mj mk ml mm b">docker image history localcache_srv</code>，查看建筑历史。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/16787b793ffaeda6405e36f8389485b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SEI_oBgk3gNeJElk"/></div></div></figure><p id="7b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到，复制的Dockfile相关内容和本地文件仅占7M左右，而大部分内容来自基础镜像<code class="fe mj mk ml mm b">golang:1.18.3</code>，是Go官方为了编译Go代码而在<a class="ae ky" href="https://hub.docker.com/_/golang" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>中发布的，包括一个完整的<code class="fe mj mk ml mm b">gcc</code>、<code class="fe mj mk ml mm b">g++</code>、<code class="fe mj mk ml mm b">make</code>等工具的Go安装包。</p><p id="e202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们放弃这个版本的Golang基础图像，还有其他选择吗？是的，当然。</p><ul class=""><li id="f6c2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用较小的Go基础图像。</li></ul><p id="4f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://hub.docker.com/_/golang" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>中搜索，找到Golang <a class="ae ky" href="https://github.com/docker-library/golang/blob/a212f660f30646927c1a10ecdc7b579df2d28155/1.18/alpine3.16/Dockerfile" rel="noopener ugc nofollow" target="_blank"> alpine </a>版本，其图像总是被简化，尺寸可以用<code class="fe mj mk ml mm b">docker pull golang:alpine</code>查看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/afd22d9bbd69fbc49a59bb5fe69a259e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WO8-7Y7xFqB3MHMU"/></div></div></figure><p id="2d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用它替换先前的<code class="fe mj mk ml mm b">golang:1.18.3</code>并重新运行<code class="fe mj mk ml mm b">docker build</code>，我们得到一个小得多的图像。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="c096" class="nq mp it mm b gy nr ns l nt nu">localcache-go-alpine   latest    17e5c879ba48   3 seconds ago  335MB</span></pre><p id="fc12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样我们可以把图像缩小到330 MB。</p><ul class=""><li id="f686" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不再有Go基础图像。</li></ul><p id="cb3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了本地编译的<code class="fe mj mk ml mm b">main</code>文件，我们就可以直接把文件复制到镜像中来运行容器中的代码。参见下面的<code class="fe mj mk ml mm b">Dockerfile</code>。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="807e" class="nq mp it mm b gy nr ns l nt nu">FROM debian:latest<br/>WORKDIR /workspace<br/>COPY main /workspace<br/>EXPOSE 8000<br/>ENTRYPOINT ["./main"]</span></pre><p id="2826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像大小进一步缩小到130MB。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/8d3500cbd21fc8e00285b9ffefe51540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSGm-49BL3jb3O0f"/></div></div></figure><p id="42c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，上述两种方法都可以缩小图像的大小，但都不是有效的和可持续的，每次打包前都需要手动编译。</p><p id="5b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以寻求其他优化吗？是的，我们继续吧。</p><h1 id="6c36" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">优化Go图像</h1><h2 id="0f71" class="nq mp it bd mq nz oa dn mu ob oc dp my li od oe na lm of og nc lq oh oi ne oj bi translated">多阶段</h2><p id="a2cf" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如上所述，Dockerfile应该包含编译和运行两个步骤，只有运行步骤需要部署到容器中。这里可以应用Docker的多阶段构建，将Dockerfile分成两个阶段，<code class="fe mj mk ml mm b">compile</code>和<code class="fe mj mk ml mm b">run</code>，后者实际上启动容器。</p><blockquote class="ok ol om"><p id="bc65" class="kz la nl lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">对于那些努力优化docker文件同时保持它们易于阅读和维护的人来说，多级构建非常有用。</p><p id="83e9" class="kz la nl lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">—来自<a class="ae ky" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/stage-build/</a></p></blockquote><p id="7bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是为Go构建Docker映像的推荐方式。更多信息见本官方<a class="ae ky" href="https://docs.docker.com/language/golang/build-images/#multi-stage-builds" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><p id="251e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将Dockerfile文件转换成多阶段文件，我们需要</p><ul class=""><li id="8a9f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在构建阶段使用<code class="fe mj mk ml mm b">golang:alpine</code>作为基础图像。</li><li id="2c29" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">只复制编译阶段需要的文件，忽略<code class="fe mj mk ml mm b">main</code>文件。在某些情况下，当编译后的文件达到数百MB时，这是一个很好的做法。</li><li id="f26c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<code class="fe mj mk ml mm b">debian</code>作为跑步者阶段的基础图像。</li></ul><p id="6a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的Dockerfile文件是</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="50bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复<code class="fe mj mk ml mm b">docker build</code>，我们可以看到新的图像只有131 MB，在<code class="fe mj mk ml mm b">builder</code>阶段的图像被忽略。目标达成！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e4b31056503faf34130252c2b10f2c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kewXJ1fLAsXK4ItO"/></div></div></figure><p id="d09d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，<code class="fe mj mk ml mm b">Dockerfile</code>优化已经初步完成，生成了一个尺寸比原始版本减小到1/8的版本，并被认为可以投入生产。</p><p id="e398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要就此打住，尽量把图像做得更小。</p><h2 id="5a60" class="nq mp it bd mq nz oa dn mu ob oc dp my li od oe na lm of og nc lq oh oi ne oj bi translated">去做旗子</h2><p id="b983" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在构建阶段，我们使用<code class="fe mj mk ml mm b">GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build main.go</code>命令，使用<code class="fe mj mk ml mm b">CGO_ENABLED</code> <a class="ae ky" href="https://pkg.go.dev/cmd/cgo#:~:text=The%20cgo%20tool%20is%20enabled,to%200%20to%20disable%20it." rel="noopener ugc nofollow" target="_blank">环境变量</a>来避免构建可能的C文件，因为库的这一部分可能在<code class="fe mj mk ml mm b">golang:alpine</code>中缺失。但是如果使用了CGO特征，那么就需要其他标志。</p><p id="b12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以添加<code class="fe mj mk ml mm b">-w -s</code>构建标志来删除二进制文件中的调试信息。</p><p id="6bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">docker build . -t localcache:v2</code>再次，我们可以发现新图像又缩小了2MB。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/fe75a47ef83c02b1c7ace70b61037206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OETNL6Ta0T1O3leE"/></div></div></figure><p id="29a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过检查<code class="fe mj mk ml mm b">image history</code>，我们可以确认减少是由于编译的文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9f6f3de27f8dd1a699edc995371b2d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QX5qzRFH0wYWrgoT"/></div></div></figure><h2 id="f0dd" class="nq mp it bd mq nz oa dn mu ob oc dp my li od oe na lm of og nc lq oh oi ne oj bi translated">Debian或Alpine或Scratch</h2><p id="8ab3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们使用<code class="fe mj mk ml mm b">debian</code>作为runner阶段的基础映像，但不使用它的一些内置工具，如bash。作为一个纯粹的围棋图像，我们可以用<a class="ae ky" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank">阿尔卑斯</a> (5.53MB)替换，将图像大小缩小到<strong class="lb iu"> 10.1 MB </strong>。</p><p id="a1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更夸张的是，如果我们使用<a class="ae ky" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank"> scratch </a> base image，一个明确为空的图像，特别是用于“从零开始”构建图像，来替换alpine，图像大小将降至4.5 MB。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f6fc16c723ff2655f33f7ff280037a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pu0mAgBHxckpsrC8"/></div></div></figure><p id="734a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个图像非常适合这个缓存服务，既简单又高效！我们可以做个测试来验证。</p><ul class=""><li id="bd25" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在8000开始一个容器。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/461e0af63e24e3da141a49c3ab5e07c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YCIiD-71K9XpwijY"/></div></div></figure><ul class=""><li id="2a83" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用curl访问<code class="fe mj mk ml mm b">put</code>和<code class="fe mj mk ml mm b">get</code>API，放入<code class="fe mj mk ml mm b">slaise: 123</code>，获取<code class="fe mj mk ml mm b">123</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/156768b4ebcc3971002eecb6477c2ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2jvzXvTGsoEBKxBF"/></div></div></figure><p id="467e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从972MB -&gt; 4.57MB，完美吧？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/526425d5c1e3654813bcf080f771c7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ZQYhKloqKIdfIFV"/></div></div></figure><p id="85e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在上面的例子中使用了<code class="fe mj mk ml mm b">scratch</code>，但情况并不总是如此，这只是由需要的图像内容决定的。</p><p id="ec0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您使用<code class="fe mj mk ml mm b">scratch</code>，并且需要任何额外的库或工具，比如CA和时区，那么您必须手动安装它们。这听起来非常复杂并且容易出错，这也解释了为什么<code class="fe mj mk ml mm b">debian</code>在许多公司被设定为标准配置。</p><p id="e689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在Go中使用<code class="fe mj mk ml mm b">scratch</code>，这是一种静态编译的语言。那么Rust和C呢，不是完全静态编译的？而在Java和Python中呢？我们根据语言做出选择。以下是最常用的基本图像，您可以从中选择最合适的图像。</p><ul class=""><li id="dc9d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">scratch</code>，一个完全空洞的基地形象。</li><li id="c4f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">distroless/static-debian</a></code>，搭建于scratch之上，大小约2MB，包括<code class="fe mj mk ml mm b">CA</code>、<code class="fe mj mk ml mm b">root user</code>等。它只有<code class="fe mj mk ml mm b">alpine</code>的一半大小，并且被许多人用作Go基础图像。</li><li id="d4d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://wiki.alpinelinux.org/wiki/Release_Notes_for_Alpine_3.16.0" rel="noopener ugc nofollow" target="_blank">alpine</a></code>，通用基础镜像，支持多种场景。尽管为用户提供了更少的工具选择，但足以支持常规用例，并且被认为比<code class="fe mj mk ml mm b">debian</code>更安全。</li><li id="0545" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">debian</code>，包含大部分工具，如<code class="fe mj mk ml mm b">ssh</code>、<code class="fe mj mk ml mm b">curl</code>等。</li></ul><h1 id="e977" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">其他提示</h1><p id="b39b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">还有一些关于缩小体型的小技巧。</p><ul class=""><li id="06b2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">尽量减少层数。</li></ul><p id="b801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe mj mk ml mm b">COPY </code>和<code class="fe mj mk ml mm b">ADD</code>这样的命令会在复制之前的图像之前建立一个新的图层，导致图像尺寸不断膨胀。解决方案是合并命令行，比如将我们示例中的4行<code class="fe mj mk ml mm b">COPY</code>命令合并成一行。</p><p id="62b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">COPY go.mod go.sum localcache/ main.go /workspace</code></p><p id="9626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有很多bash命令，用<code class="fe mj mk ml mm b">pipe</code>将它们组合起来。</p><ul class=""><li id="015d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用<code class="fe mj mk ml mm b">COPY</code>代替<code class="fe mj mk ml mm b">ADD</code>。</li></ul><p id="8e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">COPY </code>可以通过Docker的缓存加快构建过程。当然，<code class="fe mj mk ml mm b">ADD</code>有一些额外的功能，查看<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多。</p><h1 id="d059" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">安全性</h1><p id="f3f2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我不是安全解决方案方面的专家，不同的部署环境中的安全策略也不同。但是下面的7个技巧适用于所有的图片。</p><ul class=""><li id="0b7c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">与<code class="fe mj mk ml mm b">noroot</code>用户一起运行。我们可以手动添加一个用户<code class="fe mj mk ml mm b">useradd</code>，或者使用<code class="fe mj mk ml mm b">gcr.io/distroless/static:nonroot</code>基础映像自动包含一个<code class="fe mj mk ml mm b">noroot</code>用户。</li><li id="8261" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">公开大于1024的端口。一般来说，小于1024的端口只能由root用户操作。</li><li id="cab5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">检查您的Docker文件，参考Docker官员提供的<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices" rel="noopener ugc nofollow" target="_blank">最佳实践</a>。</li><li id="c1d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择最小的基本图像。一般认为图像越小越安全，因为内容越少，漏洞越少。</li><li id="de51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用Dockerhub最新的基础镜像，不要用第三方的，不要用Github上不可信的。</li><li id="db47" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不要放任何明文密钥，比如<code class="fe mj mk ml mm b">GITHUB_KEY</code>、<code class="fe mj mk ml mm b">GKE ServiceAccountKey</code>等。，在Dockerfile文件中。选择另一种认证方法，如<code class="fe mj mk ml mm b">workloadidentity</code>。</li><li id="d7d0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用第三方工具扫描你的docker文件，比如snyk 。但这是CI/CD中的公司级实现。</li></ul><h1 id="2262" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结束了</h1><p id="4361" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">过大的图像有时会触发集群中的自动缩放，并影响用户。因此，我们必须具备Dockerfile知识来构建一个合理大小的图像或对其进行优化以避免自动缩放。希望这篇文章能有所帮助。</p><p id="5e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><h1 id="03e9" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">参考</h1><p id="d2ca" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/language/golang/build-images/#multi-stage-builds" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/language/golang/build-images/#多阶段构建</a></p><p id="63a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/stage-build/</a></p><p id="14f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices</a></p></div></div>    
</body>
</html>