<html>
<head>
<title>Absence of Null in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实性中零的缺失</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/absence-of-null-in-solidity-bc80ce5e5b09?source=collection_archive---------6-----------------------#2022-08-31">https://betterprogramming.pub/absence-of-null-in-solidity-bc80ce5e5b09?source=collection_archive---------6-----------------------#2022-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d5bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可靠性编程语言不具有可空性特征</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18b0acef849d8237107c83e117bf0c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-dR2Y0s0hQO9YqAugSwMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·史密斯在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="039f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Solidity编程语言最奇怪的地方之一是没有null。对于以可空性为核心构建块之一的Swift来说，这感觉很陌生。一开始我不明白没有这么有用的功能怎么编码。这篇文章详细阐述了在构建智能合同时，如何在Solidity中找到一种解决方法。</p><h1 id="f7f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">未定义的概念</h1><p id="d835" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">undefined</code>、<code class="fe ms mt mu mv b">null</code>、<code class="fe ms mt mu mv b">nil</code>、<code class="fe ms mt mu mv b">None</code>等概念。存在于JavaScript、Java、Python、Swift等语言中，但不存在于Solidity中。</p><p id="bfb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在坚固性上，我们可以称之为零值或缺省值概念。这是因为每个值一旦被创建，就会在内存中获得一个位置，并且应该包含一些内容。</p><h1 id="a13e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">默认值</h1><p id="48bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要讨论默认值，我们应该将实度类型分为两类:</p><ul class=""><li id="0d4d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">动态调整大小的类型，如<code class="fe ms mt mu mv b">string</code>、<code class="fe ms mt mu mv b">bytes</code>和数组；</li><li id="b6ae" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">非动态大小的类型，如<code class="fe ms mt mu mv b">int</code>、<code class="fe ms mt mu mv b">bool</code>和<code class="fe ms mt mu mv b">address</code>。</li></ul><h1 id="b6ca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">非动态调整大小的类型</h1><p id="b907" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于非动态调整大小的类型，这个游戏非常简单。以下是这些的默认值:</p><ul class=""><li id="573d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">int</code>或<code class="fe ms mt mu mv b">uint256</code>默认值为零<code class="fe ms mt mu mv b">0</code>；</li><li id="75fd" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">对于<code class="fe ms mt mu mv b">bool</code>是<code class="fe ms mt mu mv b">false</code>；</li><li id="59b8" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">address</code>类型默认值为零地址<code class="fe ms mt mu mv b">0x0000000000000000000000000000000000000000</code>。</li></ul><p id="f2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想创建一个<code class="fe ms mt mu mv b">struct</code>，缺省值是它所有成员的缺省值的元组。</p><p id="463e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ms mt mu mv b">enum</code>默认值是第一种情况。这可能是一个非常陌生的方法，但那是因为所有幕后的<code class="fe ms mt mu mv b">enum</code>案例都是一个<code class="fe ms mt mu mv b">uint8</code>整数数组。</p><h1 id="979d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动态大小的类型</h1><p id="6203" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于动态调整大小的类型，情况就不同了:</p><ul class=""><li id="b821" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">string</code>的默认值为空<code class="fe ms mt mu mv b">string</code>；</li><li id="eea3" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">数组的默认值是一个空数组；</li><li id="1034" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">bytes</code>默认值为空或无字节。</li></ul><h1 id="236b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跟着代码走</h1><p id="2da6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了说明代码中的默认值，让我们创建一个带有<code class="fe ms mt mu mv b">enum</code> <code class="fe ms mt mu mv b">EmployeeType</code>的雇员<code class="fe ms mt mu mv b">struct</code>。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="f9c9" class="no lw it mv b gy np nq l nr ns">enum EmployeeType {<br/>  Employee,<br/>  Contractor,<br/>  PartTime<br/>}</span><span id="0ad5" class="no lw it mv b gy nt nq l nr ns">struct Person {<br/>  EmployeeType employeeType;<br/>  bool deleted;<br/>  string name;<br/>  uint256 yearOfBirth;<br/>  address walletAddress;<br/>  uint256[] doorAccess;<br/>}</span></pre><p id="fd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以初始化一个<code class="fe ms mt mu mv b">Employee</code>的新实例<code class="fe ms mt mu mv b">struct</code>。记住，我们不需要提供任何成员值，而是在内存中分配它们。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="ee6a" class="no lw it mv b gy np nq l nr ns">Person person;</span></pre><p id="adcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打印出<code class="fe ms mt mu mv b">person</code>的值，我们将得到每个<code class="fe ms mt mu mv b">Person</code> <code class="fe ms mt mu mv b">struct</code>成员的一组默认值。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="d456" class="no lw it mv b gy np nq l nr ns">tuple(uint8,bool,string,uint256,address,uint256[]): 0,false,,0,0x0000000000000000000000000000000000000000,</span></pre><h1 id="be12" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">检查可空性</h1><p id="640e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们知道了默认值，我们可以检查某个东西是否为“null ”,或者准确地说，它是否有默认值。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="b20e" class="no lw it mv b gy np nq l nr ns">function check() external view {<br/>  console.log(person.deleted == false);<br/>  console.log(bytes(person.name).length == 0);<br/>  console.log(person.yearOfBirth == 0);<br/>  console.log(person.walletAddress == address(0));<br/>  console.log(person.employeeType == EmployeeType.Employee);<br/>  console.log(person.doorAccess.length == 0);<br/>}</span></pre><p id="a999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们执行了这个函数，所有的检查都会得到<code class="fe ms mt mu mv b">true</code>。这就是我们如何理解没有定义的价值。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="7c3e" class="no lw it mv b gy np nq l nr ns">Deleted true<br/> Name true<br/> Year of birth true<br/> Wallet address true<br/> Employee type true<br/> Door access true</span></pre><p id="4900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，我们将其转换为<code class="fe ms mt mu mv b">bytes</code>的‘字符串’类型，并检查其长度。还有另一种方法可以实现这一点，但我们将在以后的帖子中讨论。</p><h1 id="6159" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="87d9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Solidity编程语言没有可空性特性，这在Swift和JavaScript等许多语言中都很常见。相反，类型有默认值，比如零<code class="fe ms mt mu mv b">0</code>代表<code class="fe ms mt mu mv b">uint</code>。知道缺省值是至关重要的，因为一旦我们想要检查某个东西是否被定义了，它就会派上用场。</p><h1 id="42cf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">链接</h1><ul class=""><li id="ffb6" class="mw mx it lb b lc mn lf mo li nu lm nv lq nw lu nb nc nd ne bi translated"><a class="ae ky" href="https://gist.github.com/fassko/86af7e7598ae950ad5ed2fdba7b66309" rel="noopener ugc nofollow" target="_blank">样本代码</a></li><li id="77d5" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.16/types.html" rel="noopener ugc nofollow" target="_blank">正式文件—类型</a></li><li id="30bc" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.16/control-structures.html#default-value" rel="noopener ugc nofollow" target="_blank">范围界定和声明</a></li><li id="5697" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://ethereum.stackexchange.com/questions/93109/how-to-set-a-require-for-a-string-to-not-be-null" rel="noopener ugc nofollow" target="_blank"> StackOverflow讨论</a></li></ul></div></div>    
</body>
</html>