<html>
<head>
<title>Creating a Singleton in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中创建单例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-singleton-in-typescript-dc320904e058?source=collection_archive---------3-----------------------#2022-08-09">https://betterprogramming.pub/creating-a-singleton-in-typescript-dc320904e058?source=collection_archive---------3-----------------------#2022-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e3e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">众所周知的模式的无类对象方法——从JavaScript到TypeScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cdae724f08b3c5ef7f2686a308fcb2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbD9qQduSd_byEYSP43VLA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">舒巴姆·达奇</a>在<a class="ae kv" href="https://unsplash.com/s/photos/one?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="4107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常使用ES6类声明将设计模式翻译成JavaScript，这可能有几个原因:</p><ol class=""><li id="c409" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">设计模式的流行<a class="ae kv" href="https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=the%20singleton%20pattern%20is%20a%20software%20design%20pattern%20that%20restricts%20the%20instantiation%20of%20a%20class%20to%20one%20%22single%22%20instance." rel="noopener ugc nofollow" target="_blank">定义</a>使用<em class="mb">类</em>关键字</li><li id="be45" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Java激增，将现有的模式转移到JavaScript类是微不足道的(设计模式在1994年出现，几年后在Java中迅速流行起来)</li></ol><p id="8806" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是多范例的，也可以在同一个代码库中支持类和非类对象(一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#defining_classes" rel="noopener ugc nofollow" target="_blank">类</a>声明是JavaScript中的一个语法糖)。</p><p id="36a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有一个普遍的共识，由于各种原因，无类方法更好。此外，如果您正在使用React，并且从v16.8开始已经迁移到Hooks⁴，那么您可能已经停止使用类或者至少不再添加新的类。</p><h1 id="7f72" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">什么是独生子女</h1><p id="09a2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">简单地说，Singleton是一个只能有一个实例的对象。</p><p id="3351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当需要跨多个模块共享单一版本的数据和/或功能时，这很有用。也许您想声明一次授权凭证，或者用修饰方法创建一个Axios实例。在创建日志实例时，它也非常受欢迎。</p><p id="a712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在使用React，你也可以简单地通过使用<a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> useContext钩子</em> </a>来创建一个Singleton。然而，知道如何从第一原理构造单态仍然是有教育意义和有趣的。</p><h1 id="f281" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">幼稚的实现</h1><p id="b0d4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">那么，我们如何创造一个呢？</p><p id="82c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">界面很简单。我们只需要一个返回一个对象实例的<code class="fe ne nf ng nh b">getInstance()</code>函数。对该函数的重复调用(包括跨模块调用)也必须返回相同的实例。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="1383" class="nm mi iq nh b gy nn no l np nq">const singleton = () =&gt; ({ name: "I am not yet a singleton 😿" })</span><span id="d076" class="nm mi iq nh b gy nr no l np nq"><br/>/** Should return _the_ instance of a singleton, not new ones 😕 */</span><span id="dc9c" class="nm mi iq nh b gy nr no l np nq">const getInstance = () =&gt; singleton();</span></pre><p id="26de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们仍然需要能够得到单例。只有一个版本。因此，这不符合实施要求:</p><ul class=""><li id="2fcc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ns ly lz ma bi translated">只能有一个实例(<code class="fe ne nf ng nh b">getInstance()</code>每次都会创建一个新的实例)</li><li id="537f" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">全局访问器(只能在脚本中访问)</li><li id="d4c6" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">惰性初始化是好的(在调用<code class="fe ne nf ng nh b">getInstance()</code>时创建)</li></ul><p id="e52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，没关系。上面的例子只是一个开始的试验方法。</p><h1 id="69a3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">一个改进的JavaScript实现</h1><h2 id="49fa" class="nm mi iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">对象闭包</h2><p id="3cff" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">此时，我们可以使用一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>来存储singleton的实例。JavaScript闭包的所有定义似乎都集中在函数的词法范围上，但它也适用于对象！在我们的例子中，singleton可以存储在外部函数中，并对返回的内部对象可用。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JavaScript中的对象闭包示例</p></figure><p id="7d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在一个脚本中创建一个私有但可访问的值，我强调以上方法是一个解决方案，但是对于我们的目的来说，仍然有改进的空间。</p><h2 id="e758" class="nm mi iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">模块范围</h2><p id="e18b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">ES6中的模块是作为脚本文件引入的，只在严格模式下运行，防止函数和变量出现在全局范围内。</p><p id="a95b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，模块是单态的；无论导入的频率有多高，它们都只执行一次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个简单的例子，这是可行的。一旦模块被导入，立即调用的函数表达式(IIFE)将运行并创建一个实例。如果我们通过<code class="fe ne nf ng nh b">getInstance()</code>访问它，我们将总是得到相同的单例对象。</p><p id="39a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，您可能已经注意到了一个问题:</p><ul class=""><li id="70f8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ns ly lz ma bi translated">只能有一个实例(模块生命已经为我们做到了这一点)</li><li id="8932" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">全局访问器(可通过导出的getInstance()访问—只需要导入到任何需要访问单例的模块中)</li><li id="6c0f" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">惰性初始化不好(模块一导入就被创建)</li></ul><p id="2110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以利用模块作用域来“隐藏”我们的单例实例并控制对它的访问，我们可以丢弃不再需要的生命:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，这解决了我们的懒惰初始化问题，我们现在有一些有用的东西。</p><ul class=""><li id="ed69" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ns ly lz ma bi translated">只能有一个实例</li><li id="61fd" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">全局存取器</li><li id="1121" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr ns ly lz ma bi translated">惰性初始化(在第一次引用时创建)</li></ul><p id="996e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的一个潜在问题是返回的singleton可以被客户端修改，所以我们可以通过冻结singleton对象来解决这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="91db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们想更进一步呢？</p><p id="74a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还没有为TypeScript实现引入类型，所以让我们开始吧。此外，如果我们想有选择地用一个值初始化单例怎么办？</p><h1 id="e8c9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">TypSscript实现</h1><p id="2c8a" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">第一步是为Singleton的值创建某种类型，并使它可以从外部访问(因为依赖函数可能希望传递它并将其包含在它们的类型中)</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="d079" class="nm mi iq nh b gy nn no l np nq">/**<br/> * Type of whatever we want to store in the singleton<br/> * In this case, it is an object with a name attribute<br/> */</span><span id="7131" class="nm mi iq nh b gy nr no l np nq">export type SingletonValue = {name: string};</span></pre><p id="5a52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我所使用的实际类型是任意的，但是除非我们想要一个单例构建器，否则它将特定于单例的使用，但这是另一个讨论的内容。</p><p id="a3e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单例本身可以是泛型的，因此，如果需要的话，可以将它提取到一个单独的库中。现在，为了简单起见，我将把它放在同一个模块中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用的泛型</p></figure><p id="1fe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持TypeScript的习惯用法，我们为其包含的值定义了一个<t>泛型。</t></p><p id="446d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经从实现中移除了<code class="fe ne nf ng nh b">Object.freeze()</code>,以说明编译时类型脚本将如何帮助保护实现。如果您在自己的代码库中使用它，这应该没问题，但是当实现第三方库时，您可能希望冻结它以防万一。</p><p id="94d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在模块中为我们的singleton包含一个私有“实例”(回想一下，模块总是在严格模式下运行，所以任何值都是不可访问的，除非我们显式导出它们)</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="15b1" class="nm mi iq nh b gy nn no l np nq">/**<br/> * The only instance of our Singleton<br/> */<br/>let instance: ReturnType&lt;typeof makeSingleton&lt;SingletonValue&gt;&gt;;</span></pre><p id="8f78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使用了一个叫做<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype" rel="noopener ugc nofollow" target="_blank">返回类型</a>的“实用类型”,并指定它将存储的单例值的类型(即，当使用值<code class="fe ne nf ng nh b">SingletonValue</code>时，<code class="fe ne nf ng nh b">makeSingleton</code>函数的返回类型)</p><p id="f1b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是处理可选的初始化，并指定我们正在创建的Singleton的类型。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="fa81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，现在有一个小问题，即每次我们随后调用<code class="fe ne nf ng nh b">getInstance()</code>时，初始值都可能被传递。这不是所有的问题，因为它只是被忽略，但它可能会导致误解。</p><p id="5d4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好的方法是，如果已经创建了Singleton，就抛出一个异常。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如果在创建后尝试初始化，则引发异常</p></figure><p id="a467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们现在已经达成了满足我们要求的最终版本。它看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">单例的最终实现</p></figure><h1 id="7677" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">单例的用法</h1><p id="05fe" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">从任何模块中，我们都可以简单地获得<code class="fe ne nf ng nh b">getInstance</code>函数:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="0a85" class="nm mi iq nh b gy nn no l np nq">import getInstance from "./Singleton";</span><span id="99b6" class="nm mi iq nh b gy nr no l np nq">const singleton = getInstance();</span><span id="de5b" class="nm mi iq nh b gy nr no l np nq">singleton.setValue({ name: "what is in a name" });</span><span id="4994" class="nm mi iq nh b gy nr no l np nq">const theNameObj = singleton.getValue();</span></pre><p id="9574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取对单例的多个引用将导致相同的底层对象。代码如下:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="ae0b" class="nm mi iq nh b gy nn no l np nq">const singletonRef1 = getInstance();<br/>const singletonRef2 = getInstance();</span><span id="6d73" class="nm mi iq nh b gy nr no l np nq">console.log(singletonRef1 === singletonRef2);  <em class="mb">// true</em></span></pre><p id="1032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，扩展Singleton是不可能的，因为TypeScript会停止。代码如下:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="3dc0" class="nm mi iq nh b gy nn no l np nq">singleton.myExtraFunc = () =&gt; { /** some logic */ }</span><span id="ef68" class="nm mi iq nh b gy nr no l np nq"><em class="mb">Property 'myExtraFunc' does not exist on type '{ getValue: () =&gt; Singleton | undefined; setValue: (value: Singleton) =&gt; Singleton; }'.ts(2339)</em></span></pre><h1 id="3ba3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">包裹</h1><p id="939f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">希望你能看到这篇文章不仅仅是关于在TypeScript中实现单例，还涵盖了许多有趣的主题(闭包、模块、生命、泛型等等)。)</p><p id="f76d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你觉得这有趣吗？</p><p id="2262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后的实现你怎么看？你会做些什么来改善它？</p><p id="6a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请在下面的评论中告诉我你的反馈！</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h1 id="a4dc" class="mh mi iq bd mj mk on mm mn mo oo mq mr jw op jx mt jz oq ka mv kc or kd mx my bi translated"><em class="os">资源</em></h1><p id="83a3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">[1]:维基百科。<em class="mb">单例模式</em>。https://en.wikipedia.org/wiki/Singleton_pattern<a class="ae kv" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank"/></p><p id="3777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]:维基百科。<em class="mb">设计图案</em>。<a class="ae kv" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Design_Patterns</a></p><p id="7ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]:道格拉斯·克洛克福特。<em class="mb">JavaScript中的经典继承</em>。<a class="ae kv" href="https://www.crockford.com/javascript/inheritance.html" rel="noopener ugc nofollow" target="_blank">https://www.crockford.com/javascript/inheritance.html</a></p><p id="35bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]:反应堆。<em class="mb">挂钩常见问题解答</em>。<a class="ae kv" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-faq.html</a></p></div></div>    
</body>
</html>