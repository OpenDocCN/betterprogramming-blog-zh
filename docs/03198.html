<html>
<head>
<title>Avoiding Shared Mutable State in JavaScript by Shallow Copying Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过浅层复制数据避免JavaScript中的共享可变状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avoiding-shared-mutable-state-in-javascript-by-shallow-copying-data-ad6051f0eaa2?source=collection_archive---------23-----------------------#2020-01-27">https://betterprogramming.pub/avoiding-shared-mutable-state-in-javascript-by-shallow-copying-data-ad6051f0eaa2?source=collection_archive---------23-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e0d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何做一个浅显的文案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ebb4414291110ae3d9eaa17fab3ba9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkGb4CIs4efYcDUwJ-5L-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freestocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae ky" href="https://unsplash.com/s/photos/copy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，像任何其他编程语言一样，事物都存储在变量中，这些变量可以随时更改。</p><p id="acf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是一个问题，因为我们可能会意外地更改共享的内容。让许多代码共享同一个可变状态是很难追踪的。这使得调试和阅读代码变得困难。</p><p id="e7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在不同的函数中更改同一个数组，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ebd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lx ly lz ma b">arr</code>的值根据最后调用的是<code class="fe lx ly lz ma b">foo</code>还是<code class="fe lx ly lz ma b">bar</code>而变化。如果<code class="fe lx ly lz ma b">foo</code>被调用，那么<code class="fe lx ly lz ma b">arr</code>就是<code class="fe lx ly lz ma b">[1, 2, 3]</code>。另一方面，如果调用了<code class="fe lx ly lz ma b">bar</code>，那么<code class="fe lx ly lz ma b">arr</code>就是<code class="fe lx ly lz ma b">[4, 5, 6]</code>。</p><p id="0918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为代码越复杂，函数调用就越多。如果许多函数都这样做，那么跟踪值就很困难，调试也很混乱。</p><p id="2ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，很难理解调用带有这些副作用的函数时逻辑是如何流动的。</p><p id="be52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以避免这种情况。有一个<code class="fe lx ly lz ma b">const</code>关键字来防止重新分配。此外，我们可以复制对象以防止原始对象被修改。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d771" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">对常量使用const</h1><p id="3c9a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果我们想在代码的不同部分之间共享常量，那么我们可以使用<code class="fe lx ly lz ma b">const</code>关键字来声明常量。这可以防止它们被修改。</p><p id="005a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么无论何时调用<code class="fe lx ly lz ma b">foo</code>或<code class="fe lx ly lz ma b">bar</code>，我们都会得到一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/fdbdf0e0199d9fc4bd4795d6b7171262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*poQjJD4FgfHjrulW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@thepoodlegang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">狮子狗帮</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="dfeb" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">浅层复制数据</h1><p id="7577" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当我们在函数中操作数据时，我们还可以通过复制原始数据来防止原始数据被更改。</p><p id="186b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制数据有两种方法。一种是进行浅层复制，我们复制一个对象或数组的顶级条目。如果我们有嵌套的数组或对象，那么我们必须做一个深度拷贝，拷贝对象或数组的所有级别。</p><p id="b792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解如何浅层复制数据。</p><p id="c4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要进行浅层复制，我们可以使用spread运算符。它对对象和数组都有效。例如，我们可以为对象编写以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为数组编写以下代码:</p><pre class="kj kk kl km gt ng ma nh ni aw nj bi"><span id="e283" class="nk mj it ma b gy nl nm l nn no">let arr = [1, 2, 3];<br/>let arrCopy = [...arr];</span></pre><p id="34af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用spread运算符时有一些限制。首先，原型不是复制的，所以如果我们有从原型继承的东西，如下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="783a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到第一个<code class="fe lx ly lz ma b">console.log</code>输出与第二个完全不同。<code class="fe lx ly lz ma b">obj</code>的原型是我们明确设定的<code class="fe lx ly lz ma b">{foo: 1}</code>。但是，<code class="fe lx ly lz ma b">objCopy</code>的原型是<code class="fe lx ly lz ma b">Object.prototype</code>，完全不一样。</p><p id="2f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像正则表达式这样的特殊对象也有不被复制的特殊内部槽。此外，我们可以从上面的日志输出中看到，继承的值没有使用spread操作符进行复制。</p><p id="7ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，只复制可枚举的属性。这意味着，例如，如果我们使用spread运算符将一个数组复制到一个对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第二个<code class="fe lx ly lz ma b">console.log</code>的输出中缺少了<code class="fe lx ly lz ma b">length</code>属性。</p><p id="9dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，getters、setters和属性描述符也不会被复制。例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看到<code class="fe lx ly lz ma b">obj</code>和<code class="fe lx ly lz ma b">objCopy</code>的属性描述符是不同的。</p><p id="03a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以绕过这些问题。我们可以将原始对象的原型复制到新对象中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到在上面的<code class="fe lx ly lz ma b">console.log</code>语句中<code class="fe lx ly lz ma b">obj</code>和<code class="fe lx ly lz ma b">objCopy</code>有相同的原型。</p><p id="0825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过编写以下代码，我们可以复制该值以及其他属性描述符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="63fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性描述符对象包括一个属性的值，所以我们可以用<code class="fe lx ly lz ma b">defineProperties</code>方法定义所有属性，并通过调用<code class="fe lx ly lz ma b">getOwnPropertyDescriptors</code>传入属性描述符，通过传入<code class="fe lx ly lz ma b">obj</code>来获得<code class="fe lx ly lz ma b">obj</code>的属性描述符。</p><p id="ef35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到属性<code class="fe lx ly lz ma b">b</code>在<code class="fe lx ly lz ma b">obj</code>和<code class="fe lx ly lz ma b">objCopy</code>的属性描述符中都将<code class="fe lx ly lz ma b">writable</code>设置为<code class="fe lx ly lz ma b">false</code>。</p><p id="9719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">防止共享可变状态是JavaScript中的一个问题。我们希望避免这种情况，以防止共享数据发生变异，这使得跟踪代码和调试变得困难。</p><p id="3d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用JavaScript精确复制对象是很棘手的。spread运算符不会彻底复制对象。属性描述符、getters和设置以及prototype不会被复制。</p><p id="31aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数问题可以通过手动复制它们来解决，就像我们对对象的原型和属性描述符所做的那样。</p><p id="2c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于常量，我们使用<code class="fe lx ly lz ma b">const</code>来防止意外的重新分配。</p></div></div>    
</body>
</html>