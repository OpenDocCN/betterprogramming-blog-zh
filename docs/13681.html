<html>
<head>
<title>The Testing Guide For Combine Framework in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift联合框架测试指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-combine-testing-guide-198a25af0445?source=collection_archive---------4-----------------------#2022-09-16">https://betterprogramming.pub/swift-combine-testing-guide-198a25af0445?source=collection_archive---------4-----------------------#2022-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e486" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在处理声明性API时执行单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bdd54f9c92b0b35fc9e7db792b553dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M56jIPw6H9sP_fTP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@parachutel_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">盛L </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="db71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们已经讨论的，组合实体(发布者、订阅者和订阅者)<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/combine-publishers-subscriptions-and-subscribers-implementations-under-the-hood-fe308fb9f7f6">如何在幕后相互关联</a>以及数据流如何通过<a class="ae kv" href="https://medium.com/better-programming/swift-combine-operators-the-core-ones-and-when-apply-82d6dd310aa5" rel="noopener">操作符</a>形成，是时候理解执行单元测试的最佳方式了，以便保护我们逻辑的完整性。首先，我们来谈谈模仿:</p><h1 id="e7ab" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">出版商嘲讽</h1><p id="ebba" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">发布者</strong>只是产生一些输出值的实体，或者可能是由<code class="fe mp mq mr ms b">Subscribers</code>处理的失败案例。我们可能有实际上来自上游的发布者，我们甚至不知道数据是如何创建的，甚至不知道它通过哪个操作者来获得我们的结果。思考软件架构——让我们以MVVM场景为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/c084e2ba7a6626f020a8417fe2599afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auZJ_EZqClHlzXz1ro5ljA.png"/></div></div></figure><p id="940a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个场景中发生的是，我们的<code class="fe mp mq mr ms b">ViewModel</code>通过我们的<code class="fe mp mq mr ms b">Service</code>层触发一个API请求，作为回报，<code class="fe mp mq mr ms b">ViewModel</code>获得一个<code class="fe mp mq mr ms b">Publisher</code>，它发出我们想要的值类型(输出)或自定义错误(失败)。然后，我们的<code class="fe mp mq mr ms b">ViewModel</code>创建一个订阅者来处理即将到来的输出值，并对其执行一些操作(可能分配给一个UI属性？).</p><p id="4c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们实际上不知道我们的<code class="fe mp mq mr ms b">Service</code>正在返回哪个发布者，因为<code class="fe mp mq mr ms b">ViewModel</code>实际上正在接收一个<code class="fe mp mq mr ms b">AnyPublisher</code>，它包装了另一个具有相同输出和故障类型的发布者。它可以是一个<code class="fe mp mq mr ms b">URLSession</code>发布者，一个<code class="fe mp mq mr ms b">Just</code>发布者，也可能是一个<code class="fe mp mq mr ms b">Future</code>发布者，但这并不重要，因为我们只对输出感兴趣，而不是发布者的实现。<code class="fe mp mq mr ms b">AnyPublisher</code>类型只是由一个抽象组成。</p><p id="346b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于此，由于我们不希望我们的服务逻辑干扰我们的测试，我们需要一种模拟我们的服务的方法。看看我们的服务类别，看看我们需要做什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7a1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有另一个<code class="fe mp mq mr ms b">API</code>层，它通过一个包含所有必需数据的具体端点对象来执行本地API调用。它可能会执行一个<code class="fe mp mq mr ms b">URLSession</code>调用，我们的<code class="fe mp mq mr ms b">Service</code>层负责将结果处理放到主线程中，然后它将发布者转换成一个<code class="fe mp mq mr ms b">AnyPublisher</code>包装器，以便封装我们的实现。</p><p id="c652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为如果我们要测试我们的视图模型，我们需要模拟这个类，所以让我们创建一个新的模拟类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="149f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，我们重新实现了我们的上游发布者，只是返回了我们的<code class="fe mp mq mr ms b">PokemonDetailsModel</code>的存根实例，并设置了适当的错误类型，然后删除了<code class="fe mp mq mr ms b">AnyPublisher</code>，因为我们需要包装器类型。所以我们创建了我们的嘲讽类。查看我们的存根代表什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以采用一个<code class="fe mp mq mr ms b">Future</code>发布器，因为我们只想让一个发布器发出一个没有任何逻辑的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="a276" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现我们的视图模型</h1><p id="9bc2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们展示一下我们的<code class="fe mp mq mr ms b">ViewModel</code>是如何实现的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="70ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，它由一个用于口袋妖怪细节的<code class="fe mp mq mr ms b">ViewModel</code>组成。它有一些属性可以作为文本放入SwiftUI视图和一个将从<code class="fe mp mq mr ms b">Service</code>调用输出填充的模型。</p><p id="7cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修复我们正在建立一些异步流，并通过将其字段转换为适合接口变量的格式，如<code class="fe mp mq mr ms b">image</code>、<code class="fe mp mq mr ms b">baseExperience</code>和<code class="fe mp mq mr ms b">height</code>，为我们的<code class="fe mp mq mr ms b">Published</code>模型放置多个订户。我们想要测试的输出条件是这些变量的值。</p><p id="7252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了前置和后置条件:我们想从我们的<code class="fe mp mq mr ms b">DetailsViewModelClass</code>中测试<code class="fe mp mq mr ms b">onAppear</code>方法，并且<code class="fe mp mq mr ms b">Service</code>将返回一个发布者，该发布者将发出一个特定的值，该值将由视图模型处理并通过操作符和订阅者转换成我们的接口变量<code class="fe mp mq mr ms b">name</code>、<code class="fe mp mq mr ms b">weight</code>、<code class="fe mp mq mr ms b">height</code>、<code class="fe mp mq mr ms b">baseExperience</code>、<code class="fe mp mq mr ms b">types</code>和<code class="fe mp mq mr ms b">image</code>。说到这里，让我们创建我们的测试类。</p><h1 id="84c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">判例案件</h1><p id="ffd0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们被用来测试UIKit项目中的<code class="fe mp mq mr ms b">ViewModel</code>、<code class="fe mp mq mr ms b">Interactor</code>或<code class="fe mp mq mr ms b">Presenter</code>时，我们不仅瞄准了模仿的概念，还瞄准了间谍的概念，以便获得测试用例输出并检查它们。这很重要，因为我们不能直接访问<code class="fe mp mq mr ms b">ViewModel</code>中的UI属性，它们是通过委托和闭包传递给ViewController的。既然我们依赖于作为<code class="fe mp mq mr ms b">ObservedObject</code>和<code class="fe mp mq mr ms b">StateObject</code>的<code class="fe mp mq mr ms b">ObservableObject</code>类型(在这篇<a class="ae kv" href="https://pedroalvarez-29395.medium.com/swiftui-meet-the-most-important-property-wrappers-for-a-views-data-refresh-d5c6b7d2f87c" rel="noopener">文章</a>中检查它们之间的区别)，一旦属性值在我们的<code class="fe mp mq mr ms b">ViewModel</code>层中改变，我们的场景就会被渲染，所以我们只需要访问我们的<code class="fe mp mq mr ms b">ViewModel</code> UI属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/2b6ecc116a9c0f62e54a82b9f2048cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VDysjI5Yao7V4hFUADxHQ.png"/></div></div></figure><p id="91e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，就像在以前的测试类中一样，我们将一个模拟的<code class="fe mp mq mr ms b">Service</code>实例注入到可测试的<code class="fe mp mq mr ms b">ViewModel</code>中，然后他们通过我们的测试类应用用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="965c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在我们的视图模型中触发我们的任何用例，这将从我们的<code class="fe mp mq mr ms b">ServiceMock</code>中获得我们需要的确切回报，然后我们将我们的<code class="fe mp mq mr ms b">ViewModel</code>属性与预期结果进行比较。</p><h1 id="b205" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试错误案例</h1><p id="5e56" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当单元测试时，我们感兴趣的是测试所有可能的场景，包括失败。为此，我们的模拟应该知道我们期望哪个输出。同样，我们可以模仿我们期望的数据模型，我们也应该模仿原始的错误代码。检查我的解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fbf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与任何其他模拟测试一样，我们可以通过一个枚举类型来模拟每个用例需要的场景，相应的方法将返回适当的数据。</p><h1 id="3318" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a5aa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我们研究了在处理像Combine这样的声明式API时如何执行单元测试。</p><p id="49c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们总是在处理<code class="fe mp mq mr ms b">Publishers</code>，由于<code class="fe mp mq mr ms b">AnyPublisher</code>包装器，我们不知道它的数据源。因为我们只对输出值感兴趣，所以在模仿时，我们可能会返回一个仅发出简单原始数据的<code class="fe mp mq mr ms b">Publisher</code>，比如<code class="fe mp mq mr ms b">Just</code>，如果处理集合则返回数组发布者，如果我们想要失败场景，则返回<code class="fe mp mq mr ms b">Future</code>或<code class="fe mp mq mr ms b">Fail</code>。这样，我们可以接收任何我们想要的数据，并定制我们的测试。</p><p id="8935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>