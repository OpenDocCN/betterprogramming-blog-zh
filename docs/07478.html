<html>
<head>
<title>Mastering ES6 Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握ES6代理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-es6-proxies-ced4253bc661?source=collection_archive---------7-----------------------#2021-01-19">https://betterprogramming.pub/mastering-es6-proxies-ced4253bc661?source=collection_archive---------7-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="944d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在现实世界中使用代理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9f06122cd99c5c3b402117b8a46d2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BRMAdVxByVVi4wpN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sejadisruptivo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> DISRUPTIVO </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="7529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript 6版本过了很久才发布。它直到2015年才发布，而ECMAScript 5是在1997年发布的。网络泡沫、EMACScript 4失败的尝试以及其他因素是这一最新版本背后的原因。</p><p id="c6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，ES6功能丰富。功能如此丰富，以至于许多功能都被忽略了。ES6类的sugar语法特性让一切黯然失色。这使得令人敬畏的代理功能有点被忽视。</p><p id="d1ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近js 的<a class="ae ky" href="https://stateofjs.com" rel="noopener ugc nofollow" target="_blank">状态发布了。据它说，代理人仍然是广泛未知的。今年对它的认识只增加了4%:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/0cb38509de86caebcd026af1cebf9876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRQjHsk2XZkJN1xGIcUepQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自js状态的统计数据，在此处找到<a class="ae ky" href="https://2020.stateofjs.com/en-US/features/language/#proxies" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="0910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这促使我写这篇文章，试图提高对这一特性的认识。让我们看看明年我们能否一起提高这个百分比！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6af6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是代理？</h1><blockquote class="mv mw mx"><p id="7297" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it"/><code class="fe nc nd ne nf b"><em class="it">Proxy</em></code><em class="it">对象使您能够为另一个对象创建一个代理，它可以截取并重新定义该对象的基本操作。</em></p><p id="c668" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">— MDN网络文档</p></blockquote><p id="2882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来是不是很酷？代理是可以放在其他对象前面并重新定义其基础的对象。您可以记录对对象的访问、创建缓存、控制对方法的访问、为变量提供方法访问器——这种可能性是无穷无尽的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0a78" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">代理诉讼</h1><p id="3c73" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们看看代理是如何创建的:</p><blockquote class="mv mw mx"><p id="184c" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it">用两个参数创建一个</em><code class="fe nc nd ne nf b"><em class="it">Proxy</em></code><em class="it">:</em></p><p id="fddf" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it"> — </em> <code class="fe nc nd ne nf b"><em class="it">target</em></code> <em class="it">:您要代理的原始对象</em></p><p id="5e5d" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it"> — </em> <code class="fe nc nd ne nf b"><em class="it">handler</em></code> <em class="it">:定义哪些操作会被拦截，以及如何重新定义被拦截的操作的对象。</em></p><p id="a897" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">— MDN网络文档</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/38b07b0214ff5c3db1173172a0d94391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4ifVQ_N__VrxG-pldvLNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者代理模式</p></figure><p id="b60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建第一个代理:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="dea1" class="nq me it nf b gy nr ns l nt nu">const book = {};</span><span id="37f2" class="nq me it nf b gy nv ns l nt nu">const bookHandler = {};</span><span id="f65d" class="nq me it nf b gy nv ns l nt nu">const bookProxy = new Proxy(book, bookHandler);</span></pre><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的<code class="fe nc nd ne nf b">handler</code>为空时，就好像我们直接调用了对象:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="6a26" class="nq me it nf b gy nr ns l nt nu">bookProxy.name; // undefined</span></pre><p id="22a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序可以定义一组陷阱。这些陷阱是我们放置代码来重新定义对象基础的地方。以下是完整列表:</p><ul class=""><li id="960e" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/apply" rel="noopener ugc nofollow" target="_blank">handler.apply()</a></code></li><li id="1a53" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/construct" rel="noopener ugc nofollow" target="_blank">handler.construct()</a></code></li><li id="02ec" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/defineProperty" rel="noopener ugc nofollow" target="_blank">handler.defineProperty()</a></code></li><li id="2259" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty" rel="noopener ugc nofollow" target="_blank">handler.deleteProperty()</a></code></li><li id="bf5c" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get" rel="noopener ugc nofollow" target="_blank">handler.get()</a></code></li><li id="bd71" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor" rel="noopener ugc nofollow" target="_blank">handler.getOwnPropertyDescriptor()</a></code></li><li id="f5e1" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getPrototypeOf" rel="noopener ugc nofollow" target="_blank">handler.getPrototypeOf()</a></code></li><li id="2455" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has" rel="noopener ugc nofollow" target="_blank">handler.has()</a></code></li><li id="77a8" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/isExtensible" rel="noopener ugc nofollow" target="_blank">handler.isExtensible()</a></code></li><li id="fa14" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys" rel="noopener ugc nofollow" target="_blank">handler.ownKeys()</a></code></li><li id="2c24" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/preventExtensions" rel="noopener ugc nofollow" target="_blank">handler.preventExtensions()</a></code></li><li id="8723" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set" rel="noopener ugc nofollow" target="_blank">handler.set()</a></code></li><li id="1982" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/setPrototypeOf" rel="noopener ugc nofollow" target="_blank">handler.setPrototypeOf()</a></code></li></ul><p id="a93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了时间和简单起见，本文中我们将只关注<code class="fe nc nd ne nf b">get</code>和<code class="fe nc nd ne nf b">set</code>陷阱。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ea03" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">代理获取陷阱</h1><p id="3453" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们先来看看<code class="fe nc nd ne nf b">get</code>陷阱界面:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="0f4f" class="nq me it nf b gy nr ns l nt nu">get: function(target, prop, receiver)</span></pre><p id="9ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们拦截任何对象访问器并总是返回默认字符串<code class="fe nc nd ne nf b">'unknown'</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单不是吗？使用<code class="fe nc nd ne nf b">get</code>处理程序，我们可以劫持对象的任何访问器。但是我们要小心——我们当前对象的访问器将总是解析为<code class="fe nc nd ne nf b">'unknown'</code>:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="6bef" class="nq me it nf b gy nr ns l nt nu">bookProxy.title // unknown<br/>bookProxy.pages // unknown</span><span id="a403" class="nq me it nf b gy nv ns l nt nu">bookProxy.read() // return unknown and then error is book.read is not a function</span></pre><p id="349e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看<code class="fe nc nd ne nf b">get</code>处理程序的参数:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="6c52" class="nq me it nf b gy nr ns l nt nu">const handler = {<br/>  get: function(target, property, receiver) {}<br/>};</span></pre><ul class=""><li id="950f" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">target</code>:要代理的原始对象。</li><li id="c13e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">property</code>:被访问属性的名称或符号。</li><li id="9c21" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">receiver</code> : proxy或继承de proxy的对象。</li></ul><p id="ba59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe nc nd ne nf b">target</code>或<code class="fe nc nd ne nf b">receiver</code>的任何修改将在代理对象中可见。</p><p id="0907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现一个基本的属性记录器。每当访问一个属性时，我们将打印一条消息<code class="fe nc nd ne nf b">"you have access the ${prop} property"</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重构上面的代码来使用<code class="fe nc nd ne nf b">Reflect</code>而不是手动访问属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="19c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们做一些更复杂的事情。让我们计算一个属性被调用的次数。</p><p id="d6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，这样做是很直观的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">注意:</em> <code class="fe nc nd ne nf b"><em class="my">counter</em></code> <em class="my">需要在</em> <code class="fe nc nd ne nf b"><em class="my">target</em></code> <em class="my">对象中。试图从</em> <code class="fe nc nd ne nf b"><em class="my">get</em></code> <em class="my">陷阱中的</em> <code class="fe nc nd ne nf b"><em class="my">receiver</em></code> <em class="my">访问任何属性都会导致无限循环。我们可以绕过这个无限循环，但是对于我们的例子来说不值得。</em></p><p id="7996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个问题:使用这种方法，<code class="fe nc nd ne nf b">count</code>将成为对象的一部分。如果要解耦，最好用闭包。让我们看看使用闭包后我们的代码会是什么样子。但是首先，让我们回顾一下JavaScript中的闭包概念是什么。</p><blockquote class="mv mw mx"><p id="50fe" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">闭包是捆绑在一起(封闭)的函数与对其周围状态(词法环境)的引用的组合。…在JavaScript中，闭包是在每次创建函数时创建的。</p><p id="d8f2" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">— MDN</p></blockquote><p id="46e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="e02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nc nd ne nf b">counter</code>不再可以从我们的处理程序外部访问，它被解耦了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="29ee" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">代理设置陷阱</h1><p id="0633" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们已经看到了<code class="fe nc nd ne nf b">get</code>陷阱。同样，逻辑也适用于<code class="fe nc nd ne nf b">set</code>号。我们先来看看<code class="fe nc nd ne nf b">set</code>陷阱界面。</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="9fbe" class="nq me it nf b gy nr ns l nt nu">set: function(target, property, value)</span></pre><p id="30ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个代理，它只接受<code class="fe nc nd ne nf b">string</code>类型的变量作为输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">注意:这是一个简单的例子。要在生产中使用，你应该注意像</em> <code class="fe nc nd ne nf b"><em class="my">defineProperty</em></code> <em class="my">这样的东西。它应该结合在一起，因为这是一种创造新道具的方式。</em></p><p id="adc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在我们之前的代理中是有效的:</p><pre class="kj kk kl km gt nm nf nn no aw np bi"><span id="d5f7" class="nq me it nf b gy nr ns l nt nu">Object.defineProperty(dictionaryProxy, "strawberry", {<br/>  get: function () {<br/>    return 10;<br/>  }<br/>});</span><span id="1954" class="nq me it nf b gy nv ns l nt nu">dictionaryProxy.strawberry // result will be 10</span></pre><p id="b03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做很容易解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，也可以在<code class="fe nc nd ne nf b">defineProperty</code>陷阱中做一些新奇的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ba6e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">代理组成</h1><p id="a065" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦你开始创建你的代理对象，你就可以尽情地玩，并把它们组合起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以做的是创建你的最佳实践代理，然后在你需要的时候组合它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8e7c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">真实世界的例子</h1><p id="1c46" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">代理被用在许多场景中。代理最常见的用途是用于单元测试。它们被用来在嘲弄的对象周围表演所有的魔术。</p><p id="fe03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个非常简单的模仿函数实用程序。我们将模仿jest <a class="ae ky" href="https://jestjs.io/docs/en/mock-functions" rel="noopener ugc nofollow" target="_blank"> API </a>。</p><p id="354b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将实现三种方法:</p><ul class=""><li id="5697" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">mockReset</code>:将模拟设置重置为初始设置。</li><li id="beba" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">hasBeenCalled</code>:如果函数被调用，返回true，否则返回false。</li><li id="e975" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">mockReturnValue</code>:设置函数的返回值。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那里发生了什么事？</p><p id="6229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心概念是我们在对一个函数做<code class="fe nc nd ne nf b">Proxy</code>。但这怎么可能呢？</p><blockquote class="mv mw mx"><p id="dbd1" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it">中的</em><strong class="lb iu"><em class="it">JavaScript</em></strong><em class="it">，</em> <strong class="lb iu"> <em class="it">函数</em> </strong> <em class="it">是一级</em> <strong class="lb iu"> <em class="it">对象</em> </strong> <em class="it">，因为它们可以像任何其他</em> <strong class="lb iu"> <em class="it">对象</em> </strong> <em class="it">一样拥有属性和方法。与其他</em> <strong class="lb iu"> <em class="it">对象</em> </strong> <em class="it">区别在于</em> <strong class="lb iu"> <em class="it">函数</em> </strong> <em class="it">可以被调用。简而言之，它们就是</em> <strong class="lb iu"> <em class="it">功能对象。</em> </strong></p><p id="3887" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><strong class="lb iu"> — MDN </strong></p></blockquote><p id="ca02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于函数本质上是对象，我们可以自由地将它们放在代理后面。剩下要做的就是定义一个API和一个作用域函数状态:<code class="fe nc nd ne nf b">currentState</code>。对于这组特定的API指令，我们只需要<code class="fe nc nd ne nf b">get</code>陷阱。陷阱将运行定义在<code class="fe nc nd ne nf b">methods</code>对象上的API指令。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9b8b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">收尾</strong></h1><p id="a030" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们一起深入研究了代理功能。ES6的这个功能乍一看很吓人。一旦你掌握了窍门，使用起来就很有趣。我们已经掌握了核心概念。然而，我们只是触及了表面。有很有意思的陷阱，像<code class="fe nc nd ne nf b">apply</code>，好玩又厉害。</p><p id="52fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理人不仅仅是嘲笑！它们是实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank"> <em class="my">写时复制</em> </a>机制的完美工具。</p><p id="2649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多的ES6代理将很快出现在你面前！</p><p id="3ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还想吃吗？查看我关于Typescript映射类型的文章</p><div class="om on gp gr oo op"><a href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握TypeScript的映射类型</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">了解如何像专家一样处理Typescript映射类型</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>