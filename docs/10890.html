<html>
<head>
<title>5 Ways to Lazy Load React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延迟加载React组件的5种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-ways-to-lazy-load-react-components-4ffebf1c2088?source=collection_archive---------1-----------------------#2022-02-02">https://betterprogramming.pub/5-ways-to-lazy-load-react-components-4ffebf1c2088?source=collection_archive---------1-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="55e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化您的React前端以获得更好的用户体验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d85bae96ab7a69c42ff94d68f3dcf8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sS8kvIjcGoXhZmaF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凯特·斯通·马西森在<a class="ae kv" href="https://unsplash.com/s/photos/lazy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，当我看Figma和XD设计时，它们看起来比它的宽度长，哦，我的意思是它们大多是肖像。</p><p id="2a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是没关系，我们都不期望整个设计同时出现在屏幕上，我们理解，一部分设计会出现在屏幕上，一部分设计会在用户滚动时出现。</p><p id="78f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。所以我们戴上护目镜，开始一个像素一个像素地实现设计。问题是:如果我们从根本上意识到设计不会同时出现在屏幕上，那我们为什么还要麻烦浏览器一次呈现出来呢？难道我们不能找到一种好的方法来告诉浏览器只呈现即将到来的组件吗？</p><p id="7ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当页面被加载时，页脚怎么敢和页眉竞争资源呢？如果你看看你的网站统计数据，或者使用热图，无论如何，页脚的点击率都没有那么高。</p><p id="e49e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的目标是优先考虑在特定时间对UX至关重要的组件和元素。谢天谢地，React提供了一些很棒的API和指针来帮助我们进行优化。</p><h1 id="35ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先说图像。</h1><p id="e7e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">图像是资源密集型的，通常情况下，它们会占用一个页面的很大一部分资源。问题是，实际上并不需要所有的图像。以幻灯片为例，最重要的图像是当前可用的图像。</p><p id="a3e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，当从服务器请求资源时，为什么所有的图像应该被给予相同的优先级呢？</p><p id="de6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑另一种情况，即图像在视口中不可用，同样，这些图像不应该像视口中的图像一样被赋予同样多的优先级。</p><p id="d8cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果我们后退一步，你可能会意识到，有时，即使是视图端口中的图像也不应该被阻止，也不应该阻止网站加载其他内容，如CSS和一些核心JavaScript。</p><p id="4e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的做法是推迟所有图像，只要页面没有图像也可以，我说，让我们推迟图像的加载，直到加载了其他组件。然后，您可以在后台加载图像，或者在图像进入视口时加载图像。</p><p id="719c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们可以做到这一点的几种方法。</p><h1 id="8699" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.本机支持加载='lazy '</h1><blockquote class="mp mq mr"><p id="42a0" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">来自MDN文档</p><p id="e569" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">惰性加载是一种将资源识别为非阻塞(非关键)的策略，只在需要时加载这些资源。这是缩短关键呈现路径长度的一种方式，也就是说减少了页面加载时间。</p><p id="9bb5" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">通常情况下，网页包含许多图像，这些图像会影响数据的使用和页面加载的速度。这些图像中的大多数是离屏的(非关键的)，需要用户交互(一个例子是滚动)才能查看它们。</p></blockquote><p id="b1db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们所要做的就是将<code class="fe mw mx my mz b">loading=“lazy”</code>添加到图像中</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="3001" class="ne lt iq mz b gy nf ng l nh ni"><br/>&lt;img src=”image.jpg” alt=”…” loading=”lazy”&gt;</span></pre><p id="aac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常有效，它会在图像进入视图时加载并渲染图像，而不会将其视为关键资源。不幸的是，它并不被所有的浏览器支持，因此，建议添加<a class="ae kv" href="https://github.com/mfranzke/loading-attribute-polyfill" rel="noopener ugc nofollow" target="_blank">聚投</a>。</p><h1 id="a667" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.交叉点观察器API</h1><p id="257d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一种方法是使用交叉点观察器API。</p><p id="ace6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mozilla web文档将交叉点观察器API描述为:</p><blockquote class="mp mq mr"><p id="b52a" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">交叉点观察器API提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>的交叉点变化的方法。</p><p id="6099" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">交叉点观察器API让代码注册一个回调函数，每当它们希望监视的元素进入或退出另一个元素(或<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>)时，或者当两个元素相交的量改变了请求的量时，就会执行该回调函数。通过这种方式，站点不再需要在主线程上做任何事情来监视这种元素的交集，浏览器可以自由地优化交集的管理。</p></blockquote><p id="ffe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先将一个空的<code class="fe mw mx my mz b">src</code>附加到我们的图像上，当它在视图中时，我们将附加我们的<code class="fe mw mx my mz b">src</code>，然后浏览器将获取<code class="fe mw mx my mz b">src</code>，这将是一个双赢的局面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="8faa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.使用库</h1><p id="f00d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JavaScript生态系统中，还有其他库可以在这方面提供帮助，其中一些库专门用于react。我将在此列出它们，但不会详细说明如何使用它们，因为它们都与我们在此讨论的内容有相似的概念。</p><ul class=""><li id="6fca" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.npmjs.com/package/react-lazy-load-image-component" rel="noopener ugc nofollow" target="_blank">反应迟缓加载图像</a></li><li id="ac69" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.npmjs.com/package/lozad" rel="noopener ugc nofollow" target="_blank">洛扎德</a></li><li id="9400" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.npmjs.com/package/yall-js" rel="noopener ugc nofollow" target="_blank"> Yall-js </a></li><li id="ac8e" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.npmjs.com/package/lazysizes" rel="noopener ugc nofollow" target="_blank">懒人尺码</a></li></ul><p id="d2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，非基于react的可能会直接改变DOM，所以您可能想要避免它们。</p><p id="bfc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，您可以创建一个图像组件，并使用<code class="fe mw mx my mz b">React.lazy()</code>和<code class="fe mw mx my mz b">React.suspense()</code>延迟加载它。接下来我们来看看这两个。</p><h1 id="713d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.延迟加载组件</h1><p id="8e74" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，随着延迟加载图像的概念的提出，我们可以将它扩展到其他组件，同样，当元素还没有出现在视图中时，为什么要做一些计算和动画。您应该再次推迟加载非关键组件。您可以通过内置的<code class="fe mw mx my mz b">React.Lazy</code>、<code class="fe mw mx my mz b">React.Suspense</code>和动态导入来实现这一点。</p><p id="a4b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是react的方法，可以轻松地对你的代码进行代码拆分。根据文件显示</p><blockquote class="mp mq mr"><p id="6c4c" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">对你的应用进行代码拆分可以帮助你“延迟加载”用户当前需要的东西，这可以极大地提高你的应用的性能。虽然你没有减少应用程序中的总代码量，但你避免了加载用户可能永远不需要的代码，并减少了初始加载期间所需的代码量。</p></blockquote><p id="9ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一个关于页面，我们可能想在实际的关于内容下面显示一些文章和时事通讯。</p><p id="4fc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“关于”页面对于一些图片来说可能很大，但是正如我们从上面了解到的，e成功地延迟了图片，但是我们仍然对页面的大小不太感冒。</p><p id="aee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以决定拆分时事通讯和“关于”页面上的文章，以减少初始加载的大小。让我们看看如何在这里实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这里发生了什么。</p><p id="0d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">import(“./NewPost”) </code> —这告诉捆绑器我们想在这里进行代码拆分，而不是添加到捆绑包中。</p><p id="39ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">const Posts = React.lazy(() =&gt; import(“./Posts”)); </code> —这创建了一个可用的组件，我们可以将它添加到我们的Jsx中，就像它是一个组件一样。但是为了添加它，我们将把它包装在<code class="fe mw mx my mz b">Suspense</code>组件中，这样我们可以指定一个回退，只要我们的组件还没有完成获取，就应该呈现这个回退。你可以在这里展示你的超棒的装载机。就这样，我们就可以走了。</p><h1 id="1574" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.虚拟化巨大的桌子</h1><p id="04e9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们都明白向用户显示一个巨大的列表是一种糟糕的用户体验，所以我们同意对它们进行分页或无限加载。</p><p id="2491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分页很棒，因为这意味着我们将只从服务器加载相当数量的数据，以便在特定时间向用户显示。但是无论我们做什么，有时甚至分页的列表在屏幕上也放不下。这是我认为虚拟化列表的亮点。</p><p id="b49e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最早是从Android上发现虚拟列表这个概念的。在移动设备上，我们没有太多的资源，所以无论如何我们都不能使用内存,<code class="fe mw mx my mz b">RecyclerView</code>只有几个容器可以呈现数据。当视图进入屏幕时，它使用一个现有的容器来呈现元素，当它被滚出屏幕时，容器被回收，数据被分离，以便再次重用。</p><p id="0105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果列表一次只能显示9件事情，无论你给它多少元素来显示在屏幕上，它将只使用9个容器，并通过它进行循环。在r <code class="fe mw mx my mz b">eact-window</code>的帮助下，我们可以在React中使用类似的概念。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bcec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我在这里解释几个道具:</p><ul class=""><li id="d601" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><code class="fe mw mx my mz b">itemKey</code>是一个函数，它获取你的项目被渲染所需要的键。如果没有通过，它将使用索引。</li><li id="14f0" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><code class="fe mw mx my mz b">height</code>和<code class="fe mw mx my mz b">width</code>是容器(桌子)的尺寸。</li><li id="5a82" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><code class="fe mw mx my mz b">ItemSize</code>是要渲染的项目的垂直高度和水平宽度</li></ul><p id="dc1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以点击查看react窗口文档<a class="ae kv" href="https://react-window.vercel.app/#/examples/list/fixed-size" rel="noopener ugc nofollow" target="_blank">。还有其他方法可以实现这一点，但是我发现react-window库从一开始就有点简单明了。你可以通过</a><a class="ae kv" href="https://developers.google.com/web/updates/2016/07/infinite-scroller" rel="noopener ugc nofollow" target="_blank">谷歌</a>查看这个帖子，或者查看<code class="fe mw mx my mz b">@moshe_31114</code>是如何构建<a class="ae kv" href="https://medium.com/@moshe_31114/building-our-recycle-list-solution-in-react-17a21a9605a0" rel="noopener"> his </a>的。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="468e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道如何在react中防止多重渲染，请点击这里查看我的文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/avoid-unnecessary-renders-in-react-14e9dfeaf090"/>。这是我关于优化React前端的系列文章的一部分。</p><p id="b154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>