<html>
<head>
<title>The 3 Types of Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入的三种类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-3-types-of-dependency-injection-141b40d2cebc?source=collection_archive---------0-----------------------#2019-12-15">https://betterprogramming.pub/the-3-types-of-dependency-injection-141b40d2cebc?source=collection_archive---------0-----------------------#2019-12-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a3c8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><strong class="ak">如何以及何时使用构造函数注入、方法注入和属性注入</strong></h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/082257dd805d71d8a17250eb2dba3d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AqArIFq1wpmAPxZE"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="ab15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本系列的第一篇文章中，我描述了什么是依赖注入。在我的第二篇文章中，我描述了使用依赖注入的五个原则。</p><p id="eb5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将讨论三种类型的依赖注入——构造函数注入、方法注入和属性注入<strong class="lc iv"/>——包括它们是什么、它们如何工作以及何时使用它们。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fcd4" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">构造函数注入</h1><p id="05b1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">构造函数注入是使用构造函数传入类的依赖关系的过程。依赖项被声明为构造函数的参数。因此，如果不传入构造函数所需类型的变量，就无法创建类的新实例。</p><p id="6232" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一点很关键——当你将一个依赖项声明为构造函数的参数时，你是在说，“对不起，伙计们，但是如果你想创建这个类，你必须传入这个参数。”因此，一个类能够指定它所需要的依赖项，并保证它将得到它们。没有它们就不能创建类。如果您有此代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="3549" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你不能创建一个<code class="fe nc nd ne nf b">PayrollSystem</code>而不给它传递一个<code class="fe nc nd ne nf b">BankingService.</code>的实例(嗯，很遗憾，你可以传递<code class="fe nc nd ne nf b">null</code>，但是我们一会儿会处理这个问题。)<code class="fe nc nd ne nf b">PayrollSystem </code>非常明确地声明它需要一个<code class="fe nc nd ne nf b">BankingService</code>，并且该类的用户必须提供一个。</p><h2 id="5197" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">绝不接受空值</h2><p id="2bde" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">正如我提到的，很不幸，上面的类可以并且将会把<code class="fe nc nd ne nf b">null</code>作为一个参数。我说<em class="ns">采用</em>是因为虽然该类的用户可以传入<code class="fe nc nd ne nf b">null</code>，但该类本身并不需要接受<code class="fe nc nd ne nf b">null</code>。</p><p id="ed45" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事实上，我认为所有方法都应该在任何时候明确拒绝将<code class="fe nc nd ne nf b">null</code>作为任何引用参数的值，包括构造函数和正则方法。在任何时候，如果方法没有引发异常，参数都不应该是<code class="fe nc nd ne nf b">null</code>。如果您将<code class="fe nc nd ne nf b">null</code>传递给上面的<code class="fe nc nd ne nf b">PayrollSystem</code>，并且该类试图使用它，将会发生错误。错误是不好的。它们应该——在这种情况下，可以——避免。</p><p id="0612" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码看起来应该是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="c7d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这段代码绝不允许内部字段为<code class="fe nc nd ne nf b">null</code>。如果有人胆敢传入<code class="fe nc nd ne nf b">null</code>作为构造函数的参数值，它将引发一个异常。这是应该的。你可以接受<code class="fe nc nd ne nf b">null</code>，但是你必须在你的代码中到处检查它，谁想要这样呢？用<a class="ae kz" href="https://en.wikipedia.org/wiki/Barney_Fife" rel="noopener ugc nofollow" target="_blank">巴尼法夫</a>的不朽名言来说，你应该通过在入口点拒绝接受<code class="fe nc nd ne nf b">null</code>来把它的使用扼杀在萌芽状态。</p><p id="2e6d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">检查<code class="fe nc nd ne nf b">null</code>是样板代码。防止<code class="fe nc nd ne nf b">null</code>被作为参数传递被称为<a class="ae kz" href="https://en.wikipedia.org/wiki/Guard_%28computer_science%29" rel="noopener ugc nofollow" target="_blank"> <em class="ns">保护模式</em> </a>，你可以编写代码来防止<code class="fe nc nd ne nf b">null</code>被传递给你的方法。下面是一个guard函数的基本实现:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="a8b3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">保护模式实际上被定义为在程序继续执行之前必须计算为<code class="fe nc nd ne nf b">true</code>的任何布尔表达式。它通常用于确保在方法继续之前满足某些前提条件，从而确保后面的代码可以正确执行。检查引用是否不是<code class="fe nc nd ne nf b">null</code>可能是保护模式最常见的用途，但不是唯一的用途。</p><p id="519f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在目前的情况下，我们使用保护模式来防止参数成为<code class="fe nc nd ne nf b">null</code>，因此我们可以使用保护模式来简化我们的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><h2 id="7235" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">何时使用构造函数注入</h2><p id="4086" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当您的类需要依赖项才能正常工作时，您应该使用构造函数注入。如果你的类没有依赖就不能工作，那么通过构造函数注入它。如果你的类需要三个依赖项，那么在构造函数中要求所有三个。</p><p id="04c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，当相关依赖项的生存期比单个方法长时，应该使用构造函数注入。传递到构造函数中的依赖项应该在一般情况下对类有用，它的使用跨越了类中的多个方法。如果一个依赖项只在一个地方使用，那么方法注入(下面介绍)可能是一个更好的选择。</p><p id="561f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构造函数注入应该是你进行依赖注入的主要方式。很简单:一个类需要一些东西，因此在它被构造之前就要求得到它。通过使用保护模式，您可以放心地使用该类，因为您知道存储该依赖关系的字段变量将是一个有效的实例。另外，做起来真的很简单明了。</p><p id="3a0b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构造函数注入应该是清晰、解耦代码的首选技术。但它不应该是工具箱中的唯一工具。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9b8e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">资产注入</h1><p id="91ae" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">好的，当我们想要声明所需的依赖项时，我们使用构造函数注入。但是当不需要依赖项时该怎么办呢？有时候一个类有一个依赖项，这个依赖项并不是严格要求的，但是确实被这个类使用了。例如，一个文档类可能安装了语法检查器，也可能没有安装。如果有，太好了；班级可以使用它。如果没有，很好——该类可以包含一个默认实现作为占位符。</p><p id="8c72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里的解决方案是属性注入。向类中添加一个属性，该属性可以设置为相关类的有效实例。因为依赖项是一个属性，所以您可以根据需要设置它。如果不希望或不需要依赖项，可以保留该属性不变。您的代码应该像存在依赖关系一样运行，因此您应该提供一个什么都不做的默认实现，这样无论有没有真正的依赖关系，代码都可以运行。(记住，我们从来不希望任何东西是<code class="fe nc nd ne nf b">null</code>，所以默认实现应该是有效的)。因此，如果类的用户想要提供一个有效的实现，他们可以这样做，但是如果不是这样，有一个有效的缺省值允许包含类仍然工作。</p><h2 id="6d79" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">何时使用属性注入</h2><p id="cf0f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当依赖项是可选的和/或当类实例化后依赖项可以更改时，请使用属性注入。当您希望包含类的用户能够提供他们自己的相关接口实现时，请使用它。只有在可以提供相关接口的默认实现时，才应该使用属性注入。属性注入有时被称为<em class="ns"> setter注入</em>。</p><p id="07c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">任何默认实现都可能是非功能性实现。但不一定非要这样。如果您想提供一个有效的默认实现，那很好。但是，请注意，通过使用属性注入并在包含对象的构造函数中创建该类，您将自己耦合到了该实现。</p><h2 id="058a" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">属性注入示例</h2><p id="2d13" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">一个例子，当然，将显示事情是如何做的。让我们来看看实现我上面描述的功能的代码——一个具有可选语法检查器的文档类。</p><p id="775e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们将从一个接口开始:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="bd2a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们将实现它两次:一次作为什么都不做的默认设置，另一次作为真正的语法检查器。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="6735" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这两个实现都只是记录到<code class="fe nc nd ne nf b">console</code>，甚至是非op实现。我只是想确保一切正常。同样，<code class="fe nc nd ne nf b">defaultGrammarChecker</code>是一个不可操作的默认实现，它将使我们不必一直检查<code class="fe nc nd ne nf b">null</code>。</p><p id="1aac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们需要一个有属性的类来进行语法检查。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="aca3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是关于此代码的一些注意事项:</p><ul class=""><li id="34e9" class="nt nu iu lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">它的构造函数将文档文本作为参数。然后它被公开为一个读/写属性，所以如果你想的话，你可以访问和修改它。</li><li id="6b98" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">构造函数还创建默认语法检查器的实例。再次注意，这创建了一个硬编码的依赖——属性注入的危险之一。但是这种依赖是一种什么都不做的默认设置，它阻止我们不断地检查<code class="fe nc nd ne nf b">null</code>。</li><li id="4c13" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">属性的设置器包含一个保护调用，确保内部值<code class="fe nc nd ne nf b">_grammarChecker</code>永远不会是<code class="fe nc nd ne nf b">null</code>。</li><li id="4d4c" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">还有一点需要注意的是，<code class="fe nc nd ne nf b">grammarChecker</code>属性是只写属性。也就是说，您只能设置该值，而不能从外部实际读取它。当写入的值仅在内部使用，并且永远不会被类外部的代码调用时，您可以创建只写属性。</li></ul><p id="d2f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是一些练习所有内容并展示属性注入的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="d8cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是关于上述代码的注意事项:</p><ul class=""><li id="e9d7" class="nt nu iu lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">它创建一个文档，将一些文本作为构造函数参数。</li><li id="2e6f" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">它调用<code class="fe nc nd ne nf b">CheckGrammar</code>，但是默认的语法检查器什么都不做，所以它在控制台中这么说。</li><li id="d7b1" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">但是接下来我们使用属性注入来注入一个真正的语法检查器，当我们调用<code class="fe nc nd ne nf b">CheckGrammar</code>时，语法得到真正的检查。</li></ul><p id="9b0b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，属性注入允许您提供可选的依赖项。如果需要，它还允许您更改依赖关系。例如，您的文档类可能接受来自不同语言的文本，因此需要随着文档语言的改变而改变语法检查器。资产注入将考虑到这一点。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="b789" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">方法注入</h1><p id="dfeb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你的类所需要的依赖关系在大多数时候是不同的，那该怎么办呢？如果依赖项是一个接口，并且您有几个可能想要传递到类中的实现，该怎么办？您可以使用属性注入，但是在调用利用频繁变化的依赖关系的方法之前，您将一直设置属性，从而建立时间耦合的可能性。</p><p id="6100" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">(<em class="ns">时间耦合</em>是指执行的顺序必须以特定的方式发生，事情才能正常工作。)</p><p id="5e5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你有一个不经常改变的依赖项时，通常使用构造函数和属性注入，所以当你的依赖项可能是许多实现中的一个时，它们不适合使用。</p><p id="1f36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是方法注入的用武之地。</p><p id="b87c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">方法注入允许您在使用时注入一个依赖项，这样您就可以传递您想要的任何实现，而不必担心存储它以备后用。当你传递其他需要特殊处理的信息时，经常会用到它。例如:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="b318" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里我们有一个配方的概念，根据配方的不同，可能需要不同的准备者。只有调用实体知道给定配方的正确编制者类型。例如，一个食谱可能需要一个快餐厨师，而另一个食谱可能需要一个面包师或厨师。当编写代码时，我们不知道需要哪种类型的<code class="fe nc nd ne nf b">IFoodPreparer</code>,因此我们不能真正地在构造函数中传递依赖关系，并坚持使用那个实现。</p><p id="6f8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每次需要新的或不同的<code class="fe nc nd ne nf b">IFoodPreparer</code>时设置属性也很笨拙。以这种方式设置属性会导致时间耦合，并且会遇到线程安全问题，因为这需要在线程环境中锁定代码。</p><p id="3288" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最好的解决方案是在使用时将<code class="fe nc nd ne nf b">IFoodPreparer</code>传递到方法中。<br/> <br/>方法注入应该在依赖关系会随着每次使用而改变的时候使用，或者至少在你不能确定在使用的时候会需要哪个依赖关系的时候使用。</p><p id="052b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个使用方法注入的例子，当每次使用依赖项都需要改变时。想象一下这样一种情况，一个汽车喷漆机器人每刷完一辆车就需要一个新的喷枪尖。您可能会这样开始，使用构造函数注入:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="8c32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这里，当我们油漆汽车时，我们必须得到一个新的油漆枪尖端。但是怎么做呢？当我们给汽车上漆的时候，tip已经没有用了，但是它是一个接口，我们没有办法手动释放它，即使我们做到了，下一次我们需要给汽车上漆的时候我们会怎么做呢？我们不知道给定的汽车需要什么样的小费，如果我们已经适当地分离了我们的关注，我们甚至不知道如何创建一个新的小费。怎么办？好吧，用方法注入代替:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="na nb l"/></div></figure><p id="e465" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当使用方法注入实现一个方法时，你<strong class="lc iv">必须</strong>包含一个保护子句。依赖项将会立即被使用，当然，如果您试图在它是<code class="fe nc nd ne nf b">null</code>的时候使用它，您将会立即得到一个错误。这显然应该避免。</p><p id="5946" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，当我们将依赖项直接传递给方法时，当我们完成绘制并且喷枪尖被销毁时，接口就超出了范围。此外，下一次汽车需要喷漆时，消费者将输入一个新的小费，该小费将在使用后释放。法注射抢救！</p><h2 id="7a45" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">何时使用方法注入</h2><p id="f0ee" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">因此，方法注入在两种情况下是有用的:当依赖项的实现会变化时，以及当依赖项在每次使用后需要更新时。在这两种情况下，由调用者决定将什么实现传递给方法。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="de21" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="a634" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为了编写干净、松散耦合、易于维护的代码，依赖注入是一种强大、有用且关键的技术。有三种方法可以进行依赖注入，每种都有自己的用例。学会什么时候使用这三种技术，你就能写出优秀的、可测试的、可爱的代码。</p></div></div>    
</body>
</html>