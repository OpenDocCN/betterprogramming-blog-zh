<html>
<head>
<title>Virtualized Rendering From Scratch in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中从头开始的虚拟化渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/virtualized-rendering-from-scratch-in-react-34c2ad482b16?source=collection_archive---------8-----------------------#2021-02-24">https://betterprogramming.pub/virtualized-rendering-from-scratch-in-react-34c2ad482b16?source=collection_archive---------8-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6169" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们了解虚拟化是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87c29d9bd7df1028ab168a26ebd9d61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBbeXLQHagk5drRDgzZrqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天将创造什么！作者照片。</p></figure><p id="d80d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多年前，我是一个开发团队的成员，该团队正在创建一个必须呈现大量数据的Flash应用程序。我们努力将它呈现为一个列表。滚动列表很慢，但我想出了一个解决办法。</p><p id="adb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我将解释我当时在<a class="ae lu" href="https://en.wikipedia.org/wiki/ActionScript#ActionScript_3.0" rel="noopener ugc nofollow" target="_blank">动作脚本3.0 </a>中创作的东西。不用说，我们将使用JavaScript来代替。我们将创建一个非常高级的演示，我将指导您完成所有步骤，以便您对这个高性能解决方案背后的逻辑有一个坚实的理解。渲染几百万个项目(！)没问题。我们最后会谈到这一点。</p><p id="b305" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我知道存在第三方解决方案，如流行的<a class="ae lu" href="https://www.npmjs.com/package/react-virtualized" rel="noopener ugc nofollow" target="_blank">反应虚拟化</a>。但是在我看来，学习如何自己创建虚拟化是一个有用的练习。你不仅可以定制最终组件的每一个方面，还可以理解它的所有小部分，这将有助于你成为最好的开发人员。</p><p id="d676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们写代码之前，先说几句关于虚拟化的话。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e1a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">虚拟化</h1><p id="006f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">虚拟化意味着“创造物理上不存在的东西。”就呈现web应用程序而言，您可以说这意味着“在内存中创建您的web应用程序，但不实际在DOM中呈现它。”例如，在内存中，我们定义我们的web应用程序由一个<code class="fe mz na nb nc b">div</code>元素组成，但是我们实际上并不在浏览器的DOM中呈现这个<code class="fe mz na nb nc b">div</code>元素。</p><p id="c080" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请看下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9df4e9c86c40371768a23f333a730d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*H5rArtR3WFli5UmPD8voxA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非虚拟化与虚拟化渲染。</p></figure><p id="9acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">黑色边框表示视口。可以说是我们的班长。</p><p id="65b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在左侧，有一个40行的列表(绿色元素)正在被渲染。我们在屏幕上看到了其中的10行，但是剩下的30行也被渲染了。更准确地说，我们指示我们的浏览器渲染它们(浏览器是否实际渲染它们是另一回事)。我们已经将它们添加到DOM中。除非我们向下滚动，否则我们看不到这些行。</p><p id="7a82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在右侧，我们可以看到虚拟化在发挥作用。我们只指示我们的浏览器呈现当前应该在视口中可见的行——加上之前和之后的一些行，我们称之为<em class="ne">缓冲行</em>。有时这种技术被称为<em class="ne">过扫描，</em>虽然我不认为使用这个术语是完全准确的。它指的是从20世纪30年代到21世纪初在某些电视机上使用的一种旧技术。但确实有一些相似之处。</p><p id="de0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以想象，使用左侧的技术呈现数千行(如果不是数百万行的话)是有问题的。如果我们指示我们的浏览器呈现成千上万的行，它将会很困难。</p><p id="3909" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从头开始创建一个使用虚拟化渲染许多行的视口，这样我们就可以了解发生了什么。</p><p id="56cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，所有的代码都可以在GitLab 上我的知识库中找到。</p><p id="e4da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候写一些代码了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0ab1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">列表组件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/be336712ff10a2e89319bce44a0b7978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/1*81AmZXGr4t0iR0eWuNRqSw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画:虚拟化在行动。</p></figure><p id="3b4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将像这样初始化我们的(虚拟)数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两件事值得一提:我们定义了我们的<code class="fe mz na nb nc b">rowHeight</code> (40个像素)，对于每一行，我们计算它的<code class="fe mz na nb nc b">top</code>位置(index *一行的高度)。这是解决方案的关键部分。将以相对于其父级(视口)的绝对位置来渲染行。因为我们正在创建一个垂直列表，所以我们只需要计算行的垂直位置。</p><p id="687a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">注意:大多数虚拟化库使用绝对定位。React-virtualized的</em> <a class="ae lu" href="https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md" rel="noopener ugc nofollow" target="_blank"> <em class="ne">列表组件</em> </a> <em class="ne">要求你定义一个</em> <code class="fe mz na nb nc b"><em class="ne">rowHeight</em></code> <em class="ne">属性，该属性应该是一个数字或者一个函数，返回给定索引的行高，增加了对动态行高的支持。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关变量</h1><p id="6e01" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在我们实现实际的逻辑之前，您应该知道相关的变量。您现在应该明白，在渲染我们的行之前，我们必须进行一些计算。这些计算需要几个变量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d00b24239402f7806a36cc0093b22cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJ69Fu4Gp4bw6yFv3UxurQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">即将进行的计算的相关变量。</p></figure><p id="ed7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一的动态值(在我们的例子中)是<code class="fe mz na nb nc b">scrollTop</code>的值。当用户滚动视窗时，我们必须重新计算和渲染。我们很快会研究这个问题，但是首先，我们会做一个初始渲染。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5932" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始渲染</h1><p id="047e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">首先，我们将只渲染当前在视口中可见的行。他们是哪几个？</p><p id="9f91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户没有向下滚动，我们将呈现索引为<code class="fe mz na nb nc b">0</code>到<code class="fe mz na nb nc b">9</code>的行。我们如何计算这个？</p><p id="be7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以像这样计算第一个可见行(在我们的视窗顶部)的索引:</p><pre class="kj kk kl km gt nj nc nk nl aw nm bi"><span id="384c" class="nn md it nc b gy no np l nq nr">// indexStart<br/>Math.floor(scrollTop / rowHeight);</span></pre><p id="4a36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户没有向下滚动，结果是<code class="fe mz na nb nc b">0</code>(零)。这是有意义的，因为在这种情况下，第一行也将是第一个<em class="ne">可见的</em>行。如果我们的用户向下滚动，比如说40个像素，结果将是<code class="fe mz na nb nc b">1</code>(一)。这也是符合逻辑的，因为第一行(索引为<code class="fe mz na nb nc b">0</code>)会从屏幕上消失。注意我们如何在一个<code class="fe mz na nb nc b">Math.floor</code>调用中包装我们的计算。这确保了部分可见的行也将被返回。</p><p id="bb4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以类似的方式，我们也可以计算应该呈现的最后一行的索引:</p><pre class="kj kk kl km gt nj nc nk nl aw nm bi"><span id="da3b" class="nn md it nc b gy no np l nq nr">// indexEnd<br/>Math.ceil((scrollTop + viewportHeight) / rowHeight - 1);</span></pre><p id="49e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，现在有一点点不同。我们使用<code class="fe mz na nb nc b">Math.ceil</code>代替，由于我们的零索引列表，我们必须在表达式中减去<code class="fe mz na nb nc b">1</code>(一)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b050" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缓冲行(过扫描)</h1><p id="4d47" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">上面的计算将返回一系列行(<code class="fe mz na nb nc b">indexStart</code>到<code class="fe mz na nb nc b">indexEnd</code>)，这些行代表应该在视口中可见的行。但是正如我们在动画中看到的，如果我们缓冲一些行，这实际上是非常好的。这样，当我们的用户开始滚动时，我们已经为此做好了准备，我们已经为他们准备好了一些行。你可以将它与YouTube为你缓冲的一些帧进行比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/96a709291571b93c68f80f67f5740de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*ZM4bwpl0ES9Lc1zXVrFTNQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">YouTube播放曲目。</p></figure><p id="56fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图中播放轨道的浅灰色部分(红色部分之后)代表缓冲帧。每当用户向前跳过几秒或几分钟，视频就已经为此“准备好”了，用户就有了流畅的体验。</p><p id="32e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过从我们的<code class="fe mz na nb nc b">indexStart</code>中减去一定的数量，并向<code class="fe mz na nb nc b">indexEnd</code>中添加一个数量来轻松实现类似的事情。因为我们没有索引小于零的行，也没有索引大于总行数的行(减去<code class="fe mz na nb nc b">1</code>,因为我们有一个零索引列表)，所以我们也必须考虑这一点。<code class="fe mz na nb nc b">Math.min</code>和<code class="fe mz na nb nc b">Math.max</code>可以帮助我们。确定索引的最终代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e56a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该缓冲多少行？这取决于几个可变因素。你的视窗高度是多少？你的用户实际滚动的速度有多快？渲染一行有多重？这是一个调整你的解决方案并找到平衡的问题。我们很快就会看到，这将对我们的虚拟化列表的几个方面产生影响。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b155" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">呈现可见行和缓冲行</h1><p id="13f0" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在我们实际上可以做一些渲染:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="35f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里提几点意见。首先，我们确保我们的视窗(第一个<code class="fe mz na nb nc b">div</code>元素)与我们在计算中使用的高度相同。</p><p id="30fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，我们硬编码第二个<code class="fe mz na nb nc b">div</code>元素的高度(该元素充当所有行的包装器)。理论上，这是因为我们从不一次渲染所有的行。它充当我们所有行的占位符。它的高度通过简单的乘法来确定:</p><pre class="kj kk kl km gt nj nc nk nl aw nm bi"><span id="ff00" class="nn md it nc b gy no np l nq nr">amountRows * rowHeight</span></pre><p id="79c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须为所有的行保留空间，即使我们从不一次渲染它们。这样，视窗的滚动条也有正确的大小。</p><p id="9f65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不总是能实现。当你滚动一个没完没了的列表时，比如像脸书这样的网站，你会注意到向下滚动时滚动条会“跳动”。这是因为列表不知道内容的总高度有多大(因为越来越多的数据被动态加载)。</p><p id="9c1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，我们知道总高度。因此，我们设置它，我们将有一个漂亮的和正确大小的滚动条。</p><p id="191d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在第11-13行，我们对行项目(来自数据数组)进行切片并呈现它们。记住，我们还设置了CSS属性<code class="fe mz na nb nc b">top</code>的值，它确保行在正确的垂直(绝对)位置呈现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b6ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">监听滚动事件</h1><p id="a673" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后但同样重要的是，我们必须确保每当用户滚动时<code class="fe mz na nb nc b">scrollTop</code>的值都会更新。这听起来相当简单，在某种程度上，的确如此。但是我们必须小心:如果用户快速滚动，滚动事件可能每秒被触发几十(如果不是几百)次。如此频繁地更新DOM会影响性能，并可能导致主JavaScript被阻塞(例如，浏览器暂时变得无响应)。</p><p id="264b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们可以很容易地阻止它。</p><p id="1341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的视口有一个名为<code class="fe mz na nb nc b">update</code>的滚动监听器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="197e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更新函数只不过是确保我们的<code class="fe mz na nb nc b">scrollTop</code>变量在<code class="fe mz na nb nc b">List</code>组件的状态中被更新的函数。但是如前所述，我们必须确保它不会被调用得太频繁。我们必须使用一种叫做节流的技术:</p><blockquote class="nt"><p id="3c13" class="nu nv it bd nw nx ny nz oa ob oc lt dk translated">负责调节应用程序处理速率的过程，可以是静态的，也可以是动态的— <a class="ae lu" href="https://en.wikipedia.org/wiki/Throttling_process_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="444c" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">我们自己实现很容易，但是我们也可以从实用程序库中获得一个函数，比如<a class="ae lu" href="https://lodash.com/docs/4.17.15#throttle" rel="noopener ugc nofollow" target="_blank"> Lodash </a>。添加特定功能后:</p><pre class="kj kk kl km gt nj nc nk nl aw nm bi"><span id="f554" class="nn md it nc b gy no np l nq nr">$ yarn add lodash.throttle</span></pre><p id="0a39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用它来包装我们的更新函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9ae3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这确保了每隔50毫秒更新函数不会被调用超过一次。如您所见，这个值(<code class="fe mz na nb nc b">50</code>)是一个参数，因此您可以尝试不同的值，看看哪个值最适合您的解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0be6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="f679" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用虚拟化是非常强大的。它允许您向用户呈现大量数据，而不会遇到性能问题。正如我前几天写的，我们每天都要面对越来越多的数据:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/how-to-handle-large-amounts-of-data-in-react-based-applications-8d97dd80a9f1" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何在基于React的应用程序中处理大量数据</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">全球数据的指数级增长影响着整个世界，包括前端开发</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="5f04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自己实现这样的技术(不使用第三方解决方案)是非常有教育意义的，可以帮助您创建定制的解决方案和性能调优，否则这是不可能的。</p><p id="8a85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>