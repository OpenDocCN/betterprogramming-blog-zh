<html>
<head>
<title>How to Scroll a List to the Bottom in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中将列表滚动到底部</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-scrolling-a-list-to-the-bottom-68337e4d8db0?source=collection_archive---------15-----------------------#2020-03-30">https://betterprogramming.pub/swiftui-scrolling-a-list-to-the-bottom-68337e4d8db0?source=collection_archive---------15-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">跳到列表中的不同点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f2e25ca72025963f0670e6733ba8ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yQ0m3Gy6vaw5OTYyImtjg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Glenn Carstens-Peters 在<a class="ae kv" href="https://unsplash.com/s/photos/list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b3ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用SwiftUI列表是使用所有自动机制来插入、删除或移动行的一种便捷方式。</p><p id="3d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您添加了一个新条目，则没有正式的方法可以滚动到添加了新条目的列表底部。所以，我试图找到一个解决办法。您会发现一些关于堆栈溢出的问题，但没有真正好的解决方案(我不想用包装的UITableView替换列表)。</p><p id="af1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个偶然的机会，我发现了一个名为<a class="ae kv" href="https://github.com/timbersoftware/SwiftUI-Introspect.git" rel="noopener ugc nofollow" target="_blank"> Introspect </a>的库，它提供了对SwiftUI元素背后的大部分UIKit内容的访问。</p><p id="25de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在的想法是访问列表后面的UITableView，然后只使用一个名为<code class="fe ls lt lu lv b">scrollToBottom</code>的自定义函数。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="93ec" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">通往幸福之路</h1><ul class=""><li id="6682" class="mv mw iq ky b kz mx lc my lf mz lj na ln nb lr nc nd ne nf bi translated">将自省添加到项目的包列表中。</li><li id="51eb" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">将自省导入到您的自定义内容视图中。</li><li id="4fd3" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">将此添加到您的<code class="fe ls lt lu lv b">Add</code>按钮的动作中:</li></ul><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="4e3e" class="np me iq lv b gy nq nr l ns nt">self.tableView?.scrollToBottom(animated: true, yOffset: self.$yOffset)</span></pre><ul class=""><li id="3216" class="mv mw iq ky b kz la lc ld lf nu lj nv ln nw lr nc nd ne nf bi translated">为了让编译器接受这一点，我们需要一个状态变量:</li></ul><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="8653" class="np me iq lv b gy nq nr l ns nt">@State var yOffset: CGFloat = 0</span></pre><ul class=""><li id="76b0" class="mv mw iq ky b kz la lc ld lf nu lj nv ln nw lr nc nd ne nf bi translated">还有一个:</li></ul><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="7f51" class="np me iq lv b gy nq nr l ns nt">@State var tableView: UITableView?</span></pre><ul class=""><li id="fe23" class="mv mw iq ky b kz la lc ld lf nu lj nv ln nw lr nc nd ne nf bi translated">将此修饰符添加到列表中:</li></ul><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="916c" class="np me iq lv b gy nq nr l ns nt">.introspectTableView(customize: { tableView in<br/>if self.tableView == nil { self.tableView = tableView }<br/>else { self.tableView?.setContentOffset(CGPoint(x: 0, y: self.yOffset + 60), animated: true) } })</span></pre><ul class=""><li id="5702" class="mv mw iq ky b kz la lc ld lf nu lj nv ln nw lr nc nd ne nf bi translated">添加此扩展名:</li></ul><pre class="kg kh ki kj gt nl lv nm nn aw no bi"><span id="70f9" class="np me iq lv b gy nq nr l ns nt">extension UITableView {<br/>func scrollToBottom(animated: Bool, yOffset: Binding&lt;CGFloat&gt;) {<br/>let y = contentSize.height — frame.size.height<br/>if y &lt; 0 { return }<br/>yOffset.wrappedValue = y<br/>}}</span></pre><h2 id="8680" class="np me iq bd mf nx ny dn mj nz oa dp mn lf ob oc mp lj od oe mr ln of og mt oh bi translated">一些笔记</h2><ul class=""><li id="4e57" class="mv mw iq ky b kz mx lc my lf mz lj na ln nb lr nc nd ne nf bi translated">第三个项目符号中的添加触发滚动到当前的<code class="fe ls lt lu lv b">yOffset</code>。</li><li id="66d8" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">第五个项目符号中的变量需要使<code class="fe ls lt lu lv b">tableView</code>在整个<code class="fe ls lt lu lv b">CustomView</code>中可用，因为它似乎在其生命周期中保持不变。</li><li id="1c13" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">第六个项目符号中的修饰语是魔法酱。通过自省，我们可以访问列表背后的ui table视图。我们使用<code class="fe ls lt lu lv b">yOffset</code>来调整内容偏移。无论出于什么原因，都有必要在偏移量(这里是60)上增加一些偏移量，因为——至少在我的环境中——最后一行是不可见或完全可见的。</li><li id="0b27" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">在第七个项目符号中，设置了新的<code class="fe ls lt lu lv b">yOffset</code>。因为有了<code class="fe ls lt lu lv b">@State</code>属性包装器，视图会根据新的偏移量进行更新。</li></ul><p id="ff50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，一切都非常顺利(不完美，但以一种可接受的方式)。当然，并不是一切:如果您删除一行，定位就会不稳定(例如，到<code class="fe ls lt lu lv b">yOffset</code>中的最后一个保存位置)。</p><p id="cf44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在该怎么办？</p><ul class=""><li id="e6f2" class="mv mw iq ky b kz la lc ld lf nu lj nv ln nw lr nc nd ne nf bi translated">让我们将<code class="fe ls lt lu lv b">yOffset</code>声明改为<code class="fe ls lt lu lv b">CGFLoat?</code>(可选)。</li><li id="4ed2" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">在列表的<code class="fe ls lt lu lv b">.onDelete(perform:)</code>事件中，移除操作后增加一个<code class="fe ls lt lu lv b">self.yOffset = nil</code>。</li><li id="ab81" class="mv mw iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">在<code class="fe ls lt lu lv b">.introspectTableView</code>视图修改器中，在<code class="fe ls lt lu lv b">setContentOffset</code>的调用前添加一个<code class="fe ls lt lu lv b">guard let yOffset = self.yOffset else { return }</code>。</li></ul><p id="ab08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，事情进展顺利。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c9f2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="aaea" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf oi lh li lj oj ll lm ln ok lp lq lr ij bi translated">我在GitHub 上添加了一个<a class="ae kv" href="https://gist.github.com/innoreq/ad20d8d2a65865ffbf3d0ade89ceda5a" rel="noopener ugc nofollow" target="_blank">要点，你可以查看视图的完整代码。它引用了一些没有提供的模型相关的协议。您可以用您的代码替换与模型相关的调用。</a></p><p id="ed19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>