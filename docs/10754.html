<html>
<head>
<title>Managing Concurrency With Swift Task Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Swift任务组管理并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-concurrency-with-swift-task-groups-703ef993eb16?source=collection_archive---------19-----------------------#2022-01-25">https://betterprogramming.pub/managing-concurrency-with-swift-task-groups-703ef993eb16?source=collection_archive---------19-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fcb1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">管理多线程iOS应用的机制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf9e28769f8c595401b9d8b10d42fe59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8TzfGPMm9otapctM8nzxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:undraw.co</p></figure><p id="564d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上周我<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/handling-core-image-filter-processing-with-concurrency-in-swift-a016396c3a07">发表了一篇文章</a>关于在现实世界中使用并发。这是我想在本文中继续讨论的一个主题，希望了解您在开发需要管理多个Swift任务组的应用程序时的选择。</p><h1 id="4c30" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">案情摘要</h1><p id="335c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我的客户希望使用图像实现一些基本的运动检测。他们想在安全环境下从静态摄像机拍摄的两张照片中寻找变化。</p><p id="19eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理论上，如果我们使用前面开发的代码，我们可以比较这些图像，并返回它们有多大不同的百分比。假设基线是一个静态图像，任何重大变化都可能被解释为运动，所以入侵者。</p><p id="f221" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等——事情比这复杂得多。考虑一下，静态图像可以是内部位置，也可以是外部位置。假设是在室外随着天的变化，光线的变化，你会得到不同的结果。</p><p id="5c1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着季节的变化，光线也在变化，不同的结果。有些场景会比其他场景更有效。一扇黑色的门，装在黑色的框架里，被一个穿黑色衣服的入侵者偶然发现——这是最糟糕的情况。最后，整个过程需要很快——每个周期不到一秒。理想情况下，处理多个图像对需要一秒钟。</p><h1 id="92d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">密码</h1><p id="3d51" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">好，这就是我要开始的。我得到了两段代码，一段将我的图像转换成一些我可以处理的数据，另一段处理这些数据。看起来像这样的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8058" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里使用了一个<code class="fe mu mv mw mx b">Actor</code>,因为在我之前的文章中，我运行了多个任务来处理同一个图像——我在这里不会这样做，以保持事情的重点，但你可以稍后尝试进行修改。我用这些在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/handling-core-image-filter-processing-with-concurrency-in-swift-a016396c3a07">这篇论文</a>——最好的时间是1.98秒。等等，那只是一张照片，现在我有两张了。这太慢了。</p><p id="badf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要使用更少的数据来得出答案，所以我引入了图像过滤器，这是一个低级别的API，可以快速对我的图像进行像素化，用它来预处理图像，并大大减少我需要采样的像素数量。然后，我用一个步幅跳过呈现的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="cabe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">巴别塔中的任务组</h1><p id="d9b8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">bon——我想，我已经有了三种主要成分——我现在需要做的就是想出如何混合它们。我整理的初稿是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a4fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一次尝试还可以，尽管我确信我可以做得更好——主要是，我不太喜欢巴别塔的结构。我不喜欢它，因为它看起来不可扩展。从时间上看，大约需要0.82秒。</p><p id="c103" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法<code class="fe mu mv mw mx b">phase1</code>调用例程过滤数据，阶段2将图像转换为数据&amp;阶段3进行分析。这些方法将调用已经列出的<code class="fe mu mv mw mx b">t4</code>、<code class="fe mu mv mw mx b">t6</code>和<code class="fe mu mv mw mx b">t8</code>例程。结构<code class="fe mu mv mw mx b">phase1</code>、<code class="fe mu mv mw mx b">phase2</code>和<code class="fe mu mv mw mx b">phase3</code>几乎完全相同。</p><p id="5118" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe mu mv mw mx b">phase1</code>。它们都是指任务组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="68a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">具有单一订阅的任务组</h1><p id="202c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我想到，也许我可以使用基于订阅的解决方案来获得更好的结构，所以我尝试了一下。如果你忽略了这样一个事实，它读起来会更好，那就是开始的时候有点扭扭捏捏。</p><p id="f2de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从时间上来说，它花了0.79秒，这很好，因为它表明构建代码并没有对速度产生太大的影响，但却使它更具可读性/可伸缩性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="19ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">具有多个订阅的任务组</h1><p id="7589" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在第一稿中，我建立了一个订阅，并根据我收到的数据决定下一步发送到哪里。但是我有点担心这种安排，同样是可伸缩性。</p><p id="bb34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我设置了多个订阅，每个任务组一个。本次修订使用了两组<code class="fe mu mv mw mx b">subject1</code>和<code class="fe mu mv mw mx b">subject2</code>。时间方面，我仍然是0.88秒。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="a2aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">任务、任务组和多个订阅</h1><p id="d48d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，虽然这有点悬而未决，但在这种情况下，我不需要等待<code class="fe mu mv mw mx b">image1</code>和<code class="fe mu mv mw mx b">image2</code>完成两幅图像的像素化过滤器，就可以建立数据集。</p><p id="4268" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我可以独立完成。同时，我也可以独立运行像素化图像的分析。理论上，我也不需要一起做分析系综，尽管我需要在最后将两个数字放在一起——所以这里有一个草稿，最初只使用任务，最后一步有一组用于分析。</p><p id="8382" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与此同时，我们的计时越来越好，0.56秒，尽管我必须承认我修改了do filter方法，将<code class="fe mu mv mw mx b">CIContext</code>的创建移到了函数之外，我认为这是一个非常慢的过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="ed16" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用通知的任务和任务组</h1><p id="7876" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当然，有一种机制比订阅历史更悠久，也更久经考验。</p><p id="7305" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是使用通知构建的最后一个订阅解决方案—它花费了0.90秒，这是可以的。我没有试图加快它，阅读警告。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d733" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">一个警告</strong>:通知似乎有一个与队列相关的元素——又名<code class="fe mu mv mw mx b">DispatchQueues</code>——如果你打算使用async/await模式，你被告知要像plage一样避免它。所以我不确定这个解决方案最终是否有意义，只有当你讨厌联合订阅时才小心使用。</p><h2 id="72b2" class="my lw it bd lx mz na dn mb nb nc dp mf lh nd ne mh ll nf ng mj lp nh ni ml nj bi translated">使用属性观察器</h2><p id="c06c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在我尝试用这些来实现一些东西。你知道，<code class="fe mu mv mw mx b">willSet</code> / <code class="fe mu mv mw mx b">didSet</code>人群。但是我没有成功，所以很明显，没有代码可以发布。</p><h1 id="41fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的话</h1><p id="0406" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Bon，使用订阅的最终草案最有意义，它是最快的，最灵活的，并且最好地利用了任务/任务组的混合。</p><p id="99f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些使我想到了本文的结尾。我希望你喜欢读它，就像我喜欢写它一样。</p></div></div>    
</body>
</html>