<html>
<head>
<title>Learn How To Compile a C++ Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习如何编译C++程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-how-to-compile-a-c-program-382c4c690bdc?source=collection_archive---------0-----------------------#2019-08-21">https://betterprogramming.pub/learn-how-to-compile-a-c-program-382c4c690bdc?source=collection_archive---------0-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索我在使用C++时遇到的问题的一系列文章</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aca2cc10757fea4b633001b4debef649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wq_QD2L__Lj0Oyp5EBIBeg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次学习C++时，除了学习指针和内存管理之外，我发现最困难的事情之一是如何使用第三方库成功地编译代码。</p><p id="e536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名游戏开发人员，你的游戏在很多方面都依赖于库，比如渲染和物理，而成功编译一个包含这些库的空项目可能会非常棘手。</p><p id="b833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很纠结，因为我根本不明白C++程序是如何在互联网上构建和分发的。我不明白我的源代码是如何变成可执行文件或库的，也不明白如何编译与平台无关的代码。</p><p id="908c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我根本不知道如何将一个库合并到我的代码中，否则我会在试图解决编译时出现的错误时碰壁。事实上，这不应该是构建游戏的困难部分。</p><p id="7955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这种知识不是可以教授的。重点主要是解决问题和C++语法，然而，如果你想用C++进行任何严肃的游戏编程，而不是从头开始编写任何东西，这些知识是必需的。</p><p id="3853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我想写一系列文章来探讨我已经讨论过的许多问题。第一篇文章将着眼于学习如何编译C++程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c263" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">三步过程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/41de7c54928daf8c6201939d30d0fa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fX-4KC5uRDBkiJIX.png"/></div></div></figure><p id="dc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译C++程序包括获取我们编写的源代码(。cpp，。c，。h，。hpp文件)并将它们转换成可在指定平台上运行的可执行文件或库。</p><p id="af94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一过程可分为三个关键阶段:</p><ol class=""><li id="a379" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">预处理</li><li id="a37e" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">汇编</li><li id="8480" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">连接</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">预处理</h1><p id="48ae" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">C++有预处理器指令，这些指令在代码中由前缀<code class="fe no np nq nr b">#</code>标识，它定义了源代码在编译前要执行的行为。</p><p id="3c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里阅读更多关于预处理器指令<a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=vs-2019" rel="noopener ugc nofollow" target="_blank">的信息。使用预处理器编译C++程序的第一阶段包括执行这些行为。</a></p><p id="dfb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预处理器做什么的确切性质取决于预处理器指令。</p><p id="4660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们经常将代码分割成单独的文件，以便于组织和阅读。为了将一个文件中的代码与另一个文件中的代码链接起来，我们使用了<code class="fe no np nq nr b">#include</code>指令。</p><p id="0cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当编译我们的C++程序时，预处理器获取这个<code class="fe no np nq nr b">#include</code>并将头文件中定义的代码复制粘贴到包含它的文件中。这节省了我们的时间，并避免了由于我们必须在文件之间手动复制代码而出现错误的可能性。</p><p id="d0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">include指令只是预定义指令的一个例子，更多例子请参见这篇<a class="ae ky" href="http://www.cplusplus.com/doc/tutorial/preprocessor/#conditional_inclusions" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="5866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到预处理器阶段结束时，代码中的所有预处理器指令都已经由编译器预处理器处理过，输出的代码现在可以编译了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="299e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">收集</h1><p id="7b54" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">编译是这个过程的下一步，它涉及到将我们编写的源代码转换成计算机可以理解的机器代码。</p><p id="46f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C++编译本身是一个两步的过程。首先，编译器获取源代码，并将其转换成<em class="ns">汇编语言</em>。汇编语言是一种低级编程语言，更类似于CPU的机器指令。</p><p id="403f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，现在被转换成汇编语言的源代码使用一个<em class="ns">汇编器</em>再次被转换成实际的机器代码。结果输出是一组以中间文件格式存储的文件，称为<em class="ns">对象文件</em>。</p><p id="b060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:机器码由二进制指令组成，之所以被称为机器语言，是因为它是CPU实际理解的代码。</p><p id="a41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标文件的扩展名为<code class="fe no np nq nr b">.obj</code>或<code class="fe no np nq nr b">.o</code>，它是为每个源代码文件创建的。目标文件包含该文件的所有机器指令。它被称为中间文件，因为直到最后阶段，链接，我们可以使用的实际可执行文件或库才被创建。</p><p id="a843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编译阶段，我们会被警告代码中任何导致代码无法编译的错误。发生的任何错误都是由于编译器不理解我们编写的代码。</p><p id="d06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码不能被C++识别，所以我们基本上在语法上搞砸了。常见的编译例子有缺少分号、拼写错误的C++关键字，或者在方法末尾添加了过多的花括号。</p><p id="6926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果发现错误，编译将完全停止。直到所有的错误都被修复，你才能编译你的C++代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b288" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接</h1><p id="8c9d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">该过程的最后一个阶段是<em class="ns">链接，</em>它涉及到从前面的步骤中获取我们的输出，并将其链接在一起以产生实际的可执行文件或库。</p><p id="bead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一阶段的第一步是将所有的目标文件编译成可执行文件或库。一旦成功实现了这一点，下一步就是将这个可执行文件与我们希望在程序中使用的任何外部库链接起来。</p><p id="715d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:一个库只是共享一个共同目的的函数、类和对象的可重用集合，例如，一个数学库。</p><p id="f515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，链接器需要解析任何依赖关系。这是任何与链接相关的错误都会发生的地方。</p><p id="f4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常见错误包括找不到指定的库，或者试图链接两个文件，例如，两个文件可能有一个共享相同名称的类。</p><p id="7161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设在这个阶段没有错误发生，编译器会给我们一个可执行文件或库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="52ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">建筑物</h1><p id="b834" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我认为值得一提的一件额外的事情是，在像<a class="ae ky" href="https://visualstudio.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio </a>这样的IDE中，所描述的编译步骤被分组到一个叫做<em class="ns"> build </em>的过程中。<strong class="lb iu"> </strong>创建程序时一个典型的工作流程是构建然后调试。</p><p id="cba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正在发生的是，构建通过编译和链接代码产生可执行文件，或者一个错误列表，这取决于自上次构建以来我们是否做了很好的编码工作。当我们点击<em class="ns">开始调试</em>时，Visual Studio将运行产生的可执行文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a78f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编译一个简单的C++程序</h1><p id="b79c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在我们知道了编译C++程序的基本步骤，我想我们可以通过看一个简单的例子来帮助巩固我们刚刚学到的东西，从而结束这篇文章。</p><p id="5551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我计划使用<a class="ae ky" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=vs-2019" rel="noopener ugc nofollow" target="_blank"> MSCV </a>工具集，并且我正在从开发者命令提示符下编译。</p><p id="73ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个关于如何从命令行设置和使用MSCV工具集的教程，所以如果你想这样做，你可以在这里找到更多信息。</p><p id="72ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将遵循的步骤:</p><p id="7002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.为我们的C++程序创建一个文件夹。</p><p id="95d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.导航到该文件夹。</p><p id="b0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.从文本编辑器创建我们的C++程序(我使用了Visual Studio代码)。</p><p id="3109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.将我们的源代码编译成目标文件。</p><p id="b4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.链接我们的目标文件以生成一个可执行文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8356" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建一个存储我们的C++程序的地方</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/65e5b094c68b0184889a9c826ad3d64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_Ox_s5LLOAx1Omsdu573w.png"/></div></div></figure><p id="1e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这一步中所做的就是使用Windows命令<code class="fe no np nq nr b">md</code>在指定的路径下创建一个目录，名称为<code class="fe no np nq nr b">HelloWorld</code>。我们可以直接从文件浏览器中创建文件夹，但是这样做更酷。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b586" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">导航到该文件夹</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/12d72e19b6d18b9112ed3708077d3f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-ncu9TNnTaEI6-Jj8J7kg.png"/></div></div></figure><p id="9f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一步中，我们所做的就是使用命令<code class="fe no np nq nr b">cd</code>导航到我们的文件夹，然后是我们想要导航到的路径。在我们的例子中，我们在最后一步中创建的文件夹。</p><p id="2697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这样做是为了让我们的生活更轻松。</p><p id="345f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有导航到我们想要编译的每个文件的文件夹，我们必须指定完整的路径名，但是如果我们已经在文件夹中，那么我们只需要给出文件名。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e4c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建C++代码</h1><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="77e8" class="ny md it nr b gy nz oa l ob oc">class HelloWorld</span><span id="f975" class="ny md it nr b gy od oa l ob oc">{</span><span id="138f" class="ny md it nr b gy od oa l ob oc">public:</span><span id="83c6" class="ny md it nr b gy od oa l ob oc">void PrintHelloWorld();</span><span id="68a8" class="ny md it nr b gy od oa l ob oc">};</span><span id="6448" class="ny md it nr b gy od oa l ob oc">#include "HelloWorld.h"<br/>#include &lt;iostream&gt;</span><span id="3bd5" class="ny md it nr b gy od oa l ob oc">using namespace std;</span><span id="d279" class="ny md it nr b gy od oa l ob oc">void HelloWorld::PrintHelloWorld()</span><span id="dd77" class="ny md it nr b gy od oa l ob oc">{</span><span id="ddfe" class="ny md it nr b gy od oa l ob oc">std::cout &lt;&lt; "Hello World";</span><span id="b967" class="ny md it nr b gy od oa l ob oc">}</span><span id="3b6e" class="ny md it nr b gy od oa l ob oc">#include "HelloWorld.h"</span><span id="0056" class="ny md it nr b gy od oa l ob oc">int main()</span><span id="3f51" class="ny md it nr b gy od oa l ob oc">{</span><span id="5c05" class="ny md it nr b gy od oa l ob oc">HelloWorld hello;</span><span id="12ac" class="ny md it nr b gy od oa l ob oc">hello.PrintHelloWorld();</span><span id="c1d0" class="ny md it nr b gy od oa l ob oc">return 0;</span><span id="c6bf" class="ny md it nr b gy od oa l ob oc">}</span></pre><p id="0019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是一个非常简单的程序，包含三个文件，<code class="fe no np nq nr b">main.cpp</code>、<code class="fe no np nq nr b">HelloWorld.h</code>和<code class="fe no np nq nr b">HelloWorld.cpp</code>。</p><p id="86ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe no np nq nr b">HelloWorld</code>头文件定义了一个函数<code class="fe no np nq nr b">PrintHelloWorld()</code>，该函数的实现在<code class="fe no np nq nr b">HelloWorld.cpp</code>中定义，而<code class="fe no np nq nr b">HelloWorld</code>对象的实际创建及其函数的调用是从<code class="fe no np nq nr b">main.cpp</code>中完成的。</p><p id="51ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这些文件保存在我们之前创建的文件夹中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a4aa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编译程序</h1><p id="800c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">要编译和链接我们的程序，我们只需使用<code class="fe no np nq nr b">cl</code>命令，后面跟着我们想要编译的所有<code class="fe no np nq nr b">.cpp</code>文件。如果我们想在没有链接的情况下编译，我们使用命令<code class="fe no np nq nr b">cl /c</code>。</p><p id="38ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们没有将<code class="fe no np nq nr b">.h</code>文件包含在编译中，因为由于<code class="fe no np nq nr b">#include</code>前处理器指令，该文件的内容被前处理器自动包含在<code class="fe no np nq nr b">main.cpp</code>和<code class="fe no np nq nr b">HelloWorld.cpp</code>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/acf68e64d409ab8fe43b0e4a87ef6c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1JGbdgoqe2cdThCx"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f8061ce84206077f71710cf4d18570de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IQzHXcobZJGH89Zb.png"/></div></div></figure><p id="6349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了我们两个<code class="fe no np nq nr b">.cpp</code>源文件的目标文件。另外，请注意，我们没有可执行文件，因为我们还没有运行链接器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="20f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接</h1><p id="10b7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这最后一步中，我们需要链接我们的目标文件来生成最终的可执行文件。</p><p id="6121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用<code class="fe no np nq nr b">LINK</code>命令，然后创建目标文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/39566597fc6dc69066fcb72bc0e221fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*saLO3B-tUsk_dVUR"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/e7192043c643659f3ca3f62ad852856f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TTRAf1ZgYd6zwcQN.png"/></div></div></figure><p id="9a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要做的就是双击<code class="fe no np nq nr b">helloworld.exe</code>来运行我们的程序。</p><p id="ebd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，鉴于我们的程序只在main函数返回之前打印到控制台，您可能看不到控制台出现，或者可能只是非常短暂地出现。</p><p id="cf9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保控制台保持打开的一个常见解决方案是在程序结束时使用<code class="fe no np nq nr b">cin</code>请求用户输入。</p><p id="2336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的例子，但我希望它能解释C++程序是如何编译的。</p><p id="cc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多东西我们没有看，比如如何链接外部库，如何跨多个平台编译我们的代码，如何更好地处理编译大型C++程序。</p><p id="afa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种比在命令行中输入每个文件更好的编译和链接程序的方法，不，不只是在我们的IDE中点击<em class="ns">构建</em>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="21a9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">编译C++程序有三个步骤:预处理、编译和链接。</p><p id="574d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预处理器处理诸如<code class="fe no np nq nr b">#include</code>的预处理器指令，编译将源代码文件转换成机器代码，存储在目标文件中，并链接目标文件和外部库以产生可执行文件或库文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="85d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="b36b" class="mv mw it lb b lc nj lf nk li oh lm oi lq oj lu ok nb nc nd bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/C%2B%2B" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/C%2B%2B</a></li><li id="09be" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu ok nb nc nd bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/6264249/how-the-compilation-linking-process-work</a></li><li id="5a36" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu ok nb nc nd bi translated"><a class="ae ky" href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html" rel="noopener ugc nofollow" target="_blank">http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html</a></li><li id="24da" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu ok nb nc nd bi translated"><a class="ae ky" href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/" rel="noopener ugc nofollow" target="_blank">https://www . learn CPP . com/CPP-tutorial/introduction-to-the-compiler-linker-and-libraries/</a></li></ul></div></div>    
</body>
</html>