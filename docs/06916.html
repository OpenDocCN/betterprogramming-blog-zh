<html>
<head>
<title>Understanding Kubernetes Multi-Container Pod Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes多容器Pod模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-kubernetes-multi-container-pod-patterns-577f74690aee?source=collection_archive---------2-----------------------#2020-11-17">https://betterprogramming.pub/understanding-kubernetes-multi-container-pod-patterns-577f74690aee?source=collection_archive---------2-----------------------#2020-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cbd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Sidecar、Ambassador和Adapter模式指南，并附有实践示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db03f209790d0c7faafb7a23799354b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2SBVoKvXqNIpZPQk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tevintrinh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tevin Trinh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="62f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes豆荚是Kubernetes的基本组成部分。由一个或多个容器组成，它是您可以将Kubernetes架构分解成的最小实体。</p><p id="337a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次接触Kubernetes时，我经常想知道他们为什么要这样设计。我的意思是为什么容器没有成为基本的构建模块。嗯，在真实环境中做一些事情，现在更有意义了。</p><p id="5ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，pod可以包含多个容器，这有一些很好的原因——主要是，pod中的容器在多节点集群中的同一个节点上被调度。这使得它们之间的通信更快、更安全，并且它们可以彼此共享卷安装和文件系统。</p><p id="168c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于我们构建可以实现的模式来解决一些特定的问题。有三种被广泛认可的多容器pod模式:</p><ul class=""><li id="ff45" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">边车</li><li id="d978" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">大使</li><li id="75cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">适配器</li></ul><p id="527e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一些实际操作的例子来看一下每一项。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="09c1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">先决条件</h1><p id="6ad4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">出于动手练习的目的，您需要一个正在运行的Kubernetes集群，并且您需要克隆<a class="ae ky" href="https://github.com/bharatmicrosystems/multi-container-patterns" rel="noopener ugc nofollow" target="_blank">这个repo </a>，并将cd放入其中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="28ef" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">边车</h1><p id="e191" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">边车的名字来源于摩托车边车。虽然你的摩托车没有边车也可以工作得很好，但是有一个边车可以通过给它一个额外的座位来增强或扩展你的自行车的功能。类似地，在Kubernetes中，sidecar模式用于增强或扩展容器的现有功能。</p><p id="a5d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的集装箱在没有边车的情况下工作得非常好，但是有了边车，它可以执行一些额外的功能。一些很好的例子是使用sidecar进行监控和日志记录，并为这些目的添加代理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/282f28d1119c33ca694989525fc22864.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*oeSs9sh6YF1MS23yOu_SEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">边车</p></figure><p id="0d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于演示，让我们看一个sidecar模式，其中一个应用程序在一个特定的文件路径生成日志，sidecar将记录推送到<code class="fe no np nq nr b">nginx</code> HTML目录供用户查看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="63e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你看看货单，你会看到我们有两个集装箱:<code class="fe no np nq nr b">app-container</code>和<code class="fe no np nq nr b">log-exporter-sidecar</code>。<code class="fe no np nq nr b">app-container</code>不断地将日志流式传输到<code class="fe no np nq nr b">/var/log/app.log</code>，sidecar容器将日志装载到<code class="fe no np nq nr b">nginx</code> HTML目录。这使得任何人都可以使用网络浏览器查看日志。</p><p id="3cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您应用清单并在端口80上运行端口转发时，您应该能够使用浏览器访问日志。对于这个演示，我们将使用<code class="fe no np nq nr b">curl</code>来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/738e85fa92893a025c27765e99325faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-nSPFt-V2E3YuittXc8Ayg.gif"/></div></div></figure><p id="c678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，可以通过<code class="fe no np nq nr b">curl</code>查看日志，尽管这是一种非常基本的做事方式，但它解释了这个概念。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9ffd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">大使</h1><p id="75d0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">大使模式的名字来源于大使，他是一个特使，是一个国家选择来代表他们的国家并与世界其他地区联系的人。类似地，在Kubernetes的观点中，大使模式实现了外部世界的代理。让我给你举个例子——如果你构建一个需要连接数据库服务器的应用程序，服务器配置等会随着环境的变化而变化。</p><p id="c775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，处理这些问题的官方建议是使用配置映射，但是如果您的遗留代码已经在使用另一种连接数据库的方式呢？可能是一个属性文件，或者更糟，一组硬编码的值。如果您想与localhost通信，并且可以将其余的工作交给管理员，那该怎么办呢？对于这种情况，您可以使用大使模式。</p><p id="6589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以做的是创建另一个容器，它可以充当数据库的TCP代理，您可以通过localhost连接到该代理。然后，sysadmin可以使用代理容器的配置映射和秘密来注入正确的连接和身份验证信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/825ff3072496883f489d00baea40d6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*KezIya2fucCvNSx99CI23A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大使</p></figure><p id="b446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于演示，我们将使用一个简单的NGINX配置，作为example.com的TCP代理。这应该也适用于数据库和其他后端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细看YAML的舱单，你会发现有三个集装箱。app-container-poller不断调用<code class="fe no np nq nr b"><a class="ae ky" href="http://localhost:81" rel="noopener ugc nofollow" target="_blank">http://localhost:81</a></code>并将内容发送给<code class="fe no np nq nr b">/usr/share/nginx/html/index.html</code>。</p><p id="fc48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">app-container-server运行<code class="fe no np nq nr b">nginx</code>并监听端口80来处理外部请求。这两个容器共用一个<code class="fe no np nq nr b">mountPath</code>。这类似于边车方法。</p><p id="ffc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个在pod中运行的<code class="fe no np nq nr b">ambassador-container</code>监听<code class="fe no np nq nr b">localhost:81</code>并代理到<code class="fe no np nq nr b">example.com</code>的连接，所以当我们在端口80上卷曲<code class="fe no np nq nr b">app-container-server</code>端点时，我们从<code class="fe no np nq nr b">example.com</code>得到一个响应。</p><p id="0ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/d79f7cb95dacf86cfbb69c85308ee859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jFZzlimV9rLPLeSqRSh77g.gif"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4518" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">适配器</h1><p id="fe87" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">适配器是可以用多个容器实现的另一种模式。适配器模式有助于标准化本质上不同的东西。例如，您在不同的容器中运行多个应用程序，但是每个应用程序都有不同的输出日志文件的方式。</p><p id="bde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您有了一个集中的日志记录系统，只接受特定格式的日志。在这种情况下你能做什么？你可以改变每个应用程序的源代码来输出一个标准的日志格式，或者在把日志发送到你的中央服务器之前使用一个适配器来标准化日志。这就是适配器模式的由来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/45a9cfcc6d91503647212eb02a6b24da.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*eQ2gXcum3e7ADOdBrjKS5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">适配器</p></figure><p id="afd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的动手练习，让我们考虑一个以特定格式输出日志的应用程序，我们希望将其转换为标准格式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在清单中，我们有一个<code class="fe no np nq nr b">app-container</code>将一串日期输出到一个日志文件中。<code class="fe no np nq nr b">log-adapter</code>容器在前面加了一个<code class="fe no np nq nr b">Date</code>前缀。是的，这是一个非常基本的例子，但足以了解适配器是如何工作的。</p><p id="e983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们应用清单，自己看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/57106d6cbd7f9ccc9e863a7ae04bac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Nz7yYoIbVqECQ4ystCEP7w.gif"/></div></div></figure><p id="e841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们为<code class="fe no np nq nr b">log-adapter</code>创建日志文件<code class="fe no np nq nr b">/var/log/out.log</code>时，我们会看到一个<code class="fe no np nq nr b">Date</code>前缀出现在原来的日志<code class="fe no np nq nr b">/var/log/app.log</code>中。然后，您可以使用sidecar将这些日志导出到您的监控和警报引擎。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7776" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="b1f5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">多容器豆荚在Kubernetes有很好的存在理由。上面的模式只是最广泛使用的模式之一——还有其他您可能想要使用它们的场景。Pod中的容器使用相同的IPC名称空间和网络，因此您可能需要根据它们的效用紧密耦合两个容器。</p><p id="5f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>