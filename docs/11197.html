<html>
<head>
<title>From Python to Rust: Some Key Differences and Takeaways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Python到Rust:一些关键差异和要点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-python-to-rust-some-key-differences-and-takeaways-151da8293b9a?source=collection_archive---------0-----------------------#2022-02-25">https://betterprogramming.pub/from-python-to-rust-some-key-differences-and-takeaways-151da8293b9a?source=collection_archive---------0-----------------------#2022-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f15d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并排的代码片段</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ad920e537fca8db3360bc2cce9b4ea0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aklv9U9MPkx5ylQv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄的照片</p></figure><p id="bb35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将近10年来，Python一直是我的第一门编程语言。在花了3年时间使用C++之后，我喜欢上了Python的简单——不需要担心分配内存、空指针或引用:梦想成真了！</p><p id="de0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在过去的几个月里，我花了相当多的时间使用Rust，原因如下所述，我将在这个故事的结尾分享一些我喜欢的Rust的特性，这些特性不是Python语言的一部分。</p><p id="4294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls"> NB。这不是又一个关于哪种语言更好的故事。我只是分享我在学习和使用Rust几周后的想法，我来自一个主要是Pythonic的环境。</em></strong></p><h1 id="b528" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">动机</h1><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我使用Python编写脚本，用模板渲染建立网站(嗨，Django！)和训练机器学习模型，同时在庞大的代码库中保持语言的一致性，相当方便。所以当从头开始一个新项目时，使用Python是很自然的。</p><p id="c379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么我现在在考虑另一种语言呢？我确实喜欢一直学习新的东西，但这不是唯一的原因。</p><blockquote class="mq"><p id="2013" class="mr ms iq bd mt mu mv mw mx my mz lr dk translated"><strong class="ak">一般来说，在某些时候，质疑你的过程和选择总是一件好事。总是使用相同的语言或工具，只是因为你习惯了，并不总是最好的决策过程。</strong></p></blockquote><p id="d369" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">因此，关注其他人正在使用的工具是一种很好的做法，了解他们是如何工作的，这样你就可以快速确定他们什么时候适合你。最近人们谈论了很多关于铁锈的话题。根据最近的堆栈溢出开发者调查(2021年)，它甚至是最受欢迎的语言:</p><blockquote class="nf ng nh"><p id="5b57" class="kw kx ls ky b kz la jr lb lc ld ju le ni lg lh li nj lk ll lm nk lo lp lq lr ij bi translated">最喜欢、最害怕和最想要的<a class="ae kv" href="https://insights.stackoverflow.com/survey/2021/#technology-most-loved-dreaded-and-wanted" rel="noopener ugc nofollow" target="_blank">https://insights . Stack Overflow . com/survey/2021/# technology-最喜欢、最害怕和最想要的</a> <br/> - Stack Overflow 2021年开发者调查</p></blockquote><p id="1d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我参与了一个项目，其中Python的使用开始受到质疑，主要有两个原因。第一个是表演。因为我们构建的应用程序在幕后做了很多事情。第二个原因是代码混淆。</p><p id="b166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我对开源充满热情，它也不能总是被应用，尤其是在没有清晰的商业模式的情况下。由于这两点，Rust似乎是一个很好的调查对象，这也是我开始阅读<a class="ae kv" href="https://doc.rust-lang.org/stable/book/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这本书的原因。</em> </a>事实证明，与Python相比，我发现了用完全不同的范式学习语言的其他优势！</p><h1 id="054b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如何从Python过渡到Rust</h1><p id="2843" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这两种语言根本不同。虽然Python允许您编写代码而不必担心程序内存分配，但由于垃圾收集器程序与您的代码并行运行，Rust通过其他机制实现了内存安全，即它的“所有权规则”。理解它们并不是这个故事的目标，但是你可以在下面找到访问和“移动”一个变量的不同方法的例子(例如，从一个函数到另一个函数)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/1840a6e9224426c62ceebd578e1cb3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tM3kNr_w5V7NQeT-Zkhzgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow" rel="noopener ugc nofollow" target="_blank">https://rufflewind.com/2017-02-15/rust-move-copy-borrow</a></p></figure><p id="55d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对我来说，理解所有权和生存期并不是从Python迁移到Rust时最困难的——可能是因为我已经有了一些C/C++的背景知识，并且引用的概念对我来说并不陌生。最困难的是无法在Rust中使用面向对象编程和继承(注意:这不完全正确，你可以用Rust模仿一些行为，但这绝对不是Rust开发人员的思维方式)。它迫使我以完全不同的方式思考代码。更熟悉使用接口的语言(如Java)的人可能会觉得更容易。</p><p id="14e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，我将讨论Rust的几个方面，在我看来，它们可以真正帮助开发人员编写更好的代码。这里的“更好”意味着更容易阅读、维护和使用。</p><h1 id="d2e6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">从Python开发人员的角度看Rust</h1><h2 id="34bb" class="nm lu iq bd lv nn no dn lz np nq dp md lf nr ns mf lj nt nu mh ln nv nw mj nx bi translated">默认隐私和不变性</h2><p id="7a50" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Python中，一切(变量、类、类的方法和属性……)都是公共的，可以从包中的任何地方访问。我们依靠约定来模拟隐私(比如在变量名前加下划线；如果您在变量作用域之外使用该变量，IDE将会发出警告，但是您的代码将会运行。相反，在Rust中，默认情况下所有东西都是私有的，你必须用前缀<code class="fe ny nz oa ob b">pub</code>显式声明公共对象，并将它们导出到父模块。这看起来像是一个细节，但它迫使我更好地考虑应用程序的公共API，哪些是我希望我公司的其他开发人员在他们自己的模块中访问的元素，哪些是我希望向外部开发人员公开的元素，哪些是我认为不应在非常有限的范围之外使用的元素？</p><h2 id="f03c" class="nm lu iq bd lv nn no dn lz np nq dp md lf nr ns mf lj nt nu mh ln nv nw mj nx bi translated">所有权</h2><p id="0744" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">作为一名普通的Python开发人员，所有权可能是你从未听说过的东西，但它非常强大。这个概念让我爱上了Rust，下面是一个令人兴奋的例子。考虑一个数据库事务，从中可以执行查询，然后提交或回滚，最后关闭事务。</p><p id="5916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的列表显示了如何实现一个<code class="fe ny nz oa ob b">Transaction </code>对象(实际的方法实现与当前主题无关，所以我省略了它们)。我们可以在一个<code class="fe ny nz oa ob b">do_stuff</code>函数中使用这个对象，如你所见，如果你不注意的话，Python会让你关闭事务两次:一次是在<code class="fe ny nz oa ob b">do_stuff </code>函数中，另一次是在<code class="fe ny nz oa ob b">main</code>函数中的<code class="fe ny nz oa ob b">do_stuff</code>完成之后。这将不可避免地导致运行时错误(我们可以讨论在<code class="fe ny nz oa ob b">do_stuff </code>函数中关闭事务是糟糕的设计，但是同样，这里的要点是Python允许您这样做，没有人可以说他从未犯过这种错误)。</p><p id="5b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个文件展示了用Rust编写的几乎相同的代码，利用了Rust所有权系统。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">所有权示例Python和Rust中的相同代码</p></figure><p id="71f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这都是关于方法签名中的<code class="fe ny nz oa ob b"><strong class="ky ir">&amp;</strong>self</code>对<code class="fe ny nz oa ob b">self</code>！<code class="fe ny nz oa ob b">execute_query</code>方法将对<code class="fe ny nz oa ob b">self</code>的引用作为第一个参数，这意味着调用该方法的对象在该方法完成后仍然存在(该对象只是被“借用”)。另一方面，<code class="fe ny nz oa ob b">close</code>方法将对象本身作为第一个参数(它是“steeled”)，这意味着它在函数之后将不再存在。换句话说，在第<code class="fe ny nz oa ob b">do_stuff(tx)</code>行之后，变量<code class="fe ny nz oa ob b">tx</code>不能再被使用，Rust <strong class="ky ir">编译器</strong>不会让你再次使用它，如果你试图使用它，它会发出一个错误。这样的行为比不上无法达到的生产，即使你<em class="ls">忘记</em>去测试你的代码。</p><h2 id="1f38" class="nm lu iq bd lv nn no dn lz np nq dp md lf nr ns mf lj nt nu mh ln nv nw mj nx bi translated">添加具有特征的功能</h2><p id="5a69" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我相信你可以通过几个例子理解所有权的概念和规则。正如我上面所说的，对我来说最困难的部分是没有面向对象编程！我习惯并且喜欢继承的想法，允许封装共享的行为。这在Rust中是不可能的，或者至少Rust不是用这种目标设计制造的。相反，您应该定义一个结构(包含属性、数据)和特征(包含函数定义)。然后，您可以为给定的结构实现一个trait来描述给定的结构在某些操作下将如何表现。</p><p id="ac0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特征类似于接口。Python中最接近的是mixins，您可以使用它向您的对象添加一些可能的操作。然而，它们是Rust的真正核心，因此提供了更强大的功能。</p><p id="a87b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的例子，我们为可缓存的对象创建一个mixin (Python版本)和一个trait (Rust版本):它们需要公开两个方法，<code class="fe ny nz oa ob b">get_key</code>和<code class="fe ny nz oa ob b">serialize</code>。生成的代码显示在下面代码片段中的前两个文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Trait示例Python和Rust中的相同代码</p></figure><p id="1b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个实现非常相似，我们在这里还没有看到真正的好处，除了，同样，虽然Python会让你“忘记”实现一些方法，但是如果你忘记了trait中任何一个必需的方法，Rust编译就会停止，并显示有意义的错误消息。</p><p id="3e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于Rust中的特征还有很多要说的，我会让你通读下面的例子，它模仿了一种“继承”，但是我会让你去发现更多。作为练习，您可以尝试并思考如何用Python实现一个等效的行为。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rust Trait继承和完全限定的消歧语法(请参见<a class="ae kv" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/book/ch19-03-advanced-traits . html # full-Qualified-Syntax-for-diffusion-calling-methods-with-the-same-name</a>)</p></figure><h2 id="b545" class="nm lu iq bd lv nn no dn lz np nq dp md lf nr ns mf lj nt nu mh ln nv nw mj nx bi translated">带约束和动态调度的泛型</h2><p id="2702" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我今天要讲的第三点也是最后一点是泛型。由于Rust是一种强类型语言，因此很难涵盖所有情况。在前面的<code class="fe ny nz oa ob b">Cachable</code>特征的例子中，我们已经不得不处理两次几乎相同的代码，唯一的区别是:<code class="fe ny nz oa ob b">serialize</code>方法返回值的类型。我们可以使用泛型重写它，按照惯例命名为<code class="fe ny nz oa ob b">T</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非专利产品的生锈特性</p></figure><p id="2516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust的一个很好的特性是它能够根据变量的预期类型找到合适的方法来调用。声明<code class="fe ny nz oa ob b">serialized_data_str</code>必须是类型<code class="fe ny nz oa ob b">String</code>足以让它发现它必须使用<code class="fe ny nz oa ob b">Cachable&lt;String&gt;</code>的<code class="fe ny nz oa ob b">serialize</code>方法，而不是来自<code class="fe ny nz oa ob b">Cachable&lt;HashMap&lt;String, String&gt;&gt;</code>的方法。很整洁，不是吗？</p><p id="31ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更进一步(然后我停下来，我保证！).前面的代码片段将让我们为任何类型的泛型<code class="fe ny nz oa ob b">T</code>实现<code class="fe ny nz oa ob b">Cache</code>特征。在某些情况下，我们希望<code class="fe ny nz oa ob b">T</code>满足一些约束，比如拥有一些方法，或者，用术语来说，实现一些其他特征。例如，我们将为我们的<code class="fe ny nz oa ob b">Cachable</code>特征添加一个方法<code class="fe ny nz oa ob b">serialize_and_print</code>，它将打印<code class="fe ny nz oa ob b">serialize</code>方法的结果。在Rust中，为了被打印，一个类型必须实现标准库中的一些特征，比如<code class="fe ny nz oa ob b">Display</code>或<code class="fe ny nz oa ob b">Debug</code>。为了简单起见，我们将要求类型<code class="fe ny nz oa ob b">T</code>实现这里的<code class="fe ny nz oa ob b">Debug</code>特征，语法为:<code class="fe ny nz oa ob b">T: Debug</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用约束来信任泛型(这里，T必须从标准库中实现‘Debug’特征)</p></figure><p id="2a42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用<code class="fe ny nz oa ob b">Display</code>替换<code class="fe ny nz oa ob b">Debug</code>，Rust编译器会出错，因为<code class="fe ny nz oa ob b">HashMap</code>没有实现<code class="fe ny nz oa ob b">Display</code>特征。Python不提供这种类型的保护。在一个mixin中，你可以使用一个没有在这个mixin中实现的方法，但是你可以<em class="ls">假设</em>这个方法会在其他地方实现。Rust在编译时检查<em class="ls">是否被</em>实现。</p><p id="8148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事我已经讲得比预期的多了，所以我就讲到这里。</p><h1 id="85a8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">外卖食品</h1><p id="a043" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我已经用铁锈做了几个月的实验。我认为它提供了Python无法达到的安全和信任度。这无疑拓宽了我在代码组织方面思路，超越了OOP。</p><p id="b6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还没有感到足够的舒适来开始移动我正在使用的整个代码库。我觉得我仍然缺少一些使用Rust的“惯用”方法，有时仍然试图让我的代码过于“面向对象”。但是Rust也可以很好地与Python集成，我目前的阅读内容都是关于如何利用Rust的速度来处理关键组件，同时保持Python对API/SDK的优势……(参见“进一步阅读”部分)。</p><p id="18d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是除了明确使用Rust之外，探索Rust社区如何构建他们的代码，以及Rust的一些功能，如本故事中展示的那些，给了我全新的见解，我已经可以感受到对我的Python代码的影响。我会在后续的故事中说明这一点，敬请关注！</p><h1 id="5c2f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">进一步阅读</h1><p id="6d4f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以下是我在Rust学习过程中使用的资源:</p><ul class=""><li id="a2b1" class="oe of iq ky b kz la lc ld lf og lj oh ln oi lr oj ok ol om bi translated">关于Rust的一切:<a class="ae kv" href="https://doc.rust-lang.org/stable/book/" rel="noopener ugc nofollow" target="_blank"><em class="ls">Rust编程语言</em> </a> (Rust官方文档)</li><li id="1588" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated">拉胡尔·夏尔马、维萨·凯赫拉维塔和克劳斯·马青格(Packt出版社)的《Rust编程参考指南》  <em class="ls"> </em>【从零开始】学习Rust</li><li id="316b" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated">在Python中使用Rust:<a class="ae kv" href="https://www.amazon.com/Speed-Your-Python-Rust-performance/dp/180181144X/" rel="noopener ugc nofollow" target="_blank"><em class="ls">用Rust </em> </a>加速您的Python</li></ul></div></div>    
</body>
</html>