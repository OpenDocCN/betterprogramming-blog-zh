<html>
<head>
<title>Adding Core Data in a Swift Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift包中添加核心数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/core-data-in-a-swift-package-86bf759c3b6?source=collection_archive---------6-----------------------#2022-01-03">https://betterprogramming.pub/core-data-in-a-swift-package-86bf759c3b6?source=collection_archive---------6-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c789" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们为Swift产品包添加一个核心数据管理器和模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0102c5e562a2aa9bf314e05bcd0f98fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvJnQ-z43okGgQZxjDR9sA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="70ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当创建一个应用程序时，它的架构应该是模块化的，以便可以清楚地识别和管理依赖关系，并且尽可能简单。</p><p id="100b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift包是一种分离关注点的便捷方式，例如，通过将持久存储提取到包中。然而，当谈到核心数据存储时，这并不像看起来那么简单。</p><p id="f5de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文描述了一种方法，可以避免类似“没有找到模型”这样的错误。</p><h1 id="1bf9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本要求</h1><p id="309d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">应该有一个包含核心数据管理器和核心数据模型的“持久性”包。</p><p id="bc00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他软件包应该能够使用该软件包，以便访问管理对象以及管理器本身。</p><p id="efc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，应可以设置不同的经理:</p><ul class=""><li id="e407" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">临时存储的管理器，用于测试或其他目的。</li><li id="ab2a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">本地商店的经理(如果没有活跃的iCloud)。</li><li id="110c" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">云商店的经理，如果iCloud可用的话。</li></ul><p id="6d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，不应该有单例实现。</p><h1 id="1b38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实施</h1><p id="3b2b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Xcode中创建新的包“Persistence”后，我们需要一个包配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们添加一个协议，管理器变量可以符合该协议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该配置有助于我们提供基本设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="de5e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">子类化容器</h1><p id="d4bd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实际上，我们现在只需要使用一个<code class="fe nf ng nh ni b">NSPersistentContainer</code>来设置商店。然而，根据Apple的说法，这个类应该被子类化，以便更容易地控制商店应该存储在哪里。</p><p id="e363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们创建了两个子类(本地或临时存储，以及云存储)。在这些子类中，我们覆盖了<code class="fe nf ng nh ni b">defaultDirectoryURL</code>方法，以便将商店放在适当的位置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="da8a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">符合协议</h1><p id="35f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们创建我们定义的协议的第一个实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="69ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们为一个给定的配置设置了一个临时存储，它提供了模型的名称。有一个重要的部分隐藏在<code class="fe nf ng nh ni b">?TemporaryPersistenceManager.model(for:)</code>函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="10ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两件事是相关的:</p><ul class=""><li id="4791" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">首先，必须从包中检索URL，因此必须使用<code class="fe nf ng nh ni b">Bundle.module.url(forResource:withExtension:)</code>。</li><li id="6f94" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">第二，虽然通常使用扩展名<code class="fe nf ng nh ni b">momd</code>，但这里有必要只使用<code class="fe nf ng nh ni b">mom</code>。否则，将无法正确找到模型。</li></ul><p id="503d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你现在可能想以类似的方式实现一个<code class="fe nf ng nh ni b">LocalPersistenceManager</code>和一个<code class="fe nf ng nh ni b">CloudPersistenceManager</code>，我不会在这里指出这一点。</p><h1 id="1d05" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用我们的经理</h1><p id="cd32" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，将包添加到我们的应用程序后，我们可以使用那里的管理器。在我们的例子中，我们使用<a class="ae kv" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">解析器</a>来注册使用管理器的<code class="fe nf ng nh ni b">MetaDataService&lt;&gt; </code>服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bdc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些<code class="fe nf ng nh ni b">MetaDataService&lt;&gt;</code>服务被定义在一个包<code class="fe nf ng nh ni b">Meta</code>中。该包只是引用了<code class="fe nf ng nh ni b">Persistence</code>包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="4004" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="7681" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我与运行时(不是构建时)出现的错误做了很多斗争，因为没有找到模型。这里给出的解决方案现在可以正常构建和运行了。</p><p id="f19b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，还有一件事:尽管Xcode控制台在第一次设置存储时显示一个错误(类似于“无法创建文件”)，但是存储设置正确。如果你知道为什么，请留下评论。</p><p id="21fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读本文，希望它能在类似情况下为您节省一些故障排除时间。</p></div></div>    
</body>
</html>