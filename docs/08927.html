<html>
<head>
<title>Integrating Amazon Cognito With Ethereum Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Amazon Cognito与以太坊区块链集成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/integrating-amazon-cognito-with-ethereum-blockchain-7e87f1425422?source=collection_archive---------0-----------------------#2021-06-27">https://betterprogramming.pub/integrating-amazon-cognito-with-ethereum-blockchain-7e87f1425422?source=collection_archive---------0-----------------------#2021-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="834c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Amazon Cognito和MetaMask构建自定义身份验证流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f3768783c946ed933c198ad1b10d396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsvcUqQ7d-1_h8dsLT_6pg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="http://twitter.com/helloimnik" rel="noopener ugc nofollow" target="_blank"> @helloimnik </a>在<a class="ae ky" href="https://unsplash.com/photos/qXakibuQiPU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="17ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您构建区块链DApp时，您可以使用带有自定义逻辑的AWS服务，例如使用AWS CloudWatch监控您的合同事件日志并对其进行故障排除。使用<a class="ae ky" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> Amazon Cognito </a>，您可以向您的应用程序提供临时的、有限权限的凭证来访问AWS资源。</p><p id="a9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍一个使用Amazon Cognito增强的流和<a class="ae ky" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a>扩展和Web3的加密安全认证流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决方案概述</h1><p id="d980" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到本文结束时，我们将拥有一个网站，允许用户使用MetaMask登录，并通过IAM授权访问我们的Amazon API Gateway APIs。</p><p id="3aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将要构建的演示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/08461eb43425a01d75c76bdf69c866a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tcnKAZ4sNiw2Qte0scQkIw.gif"/></div></figure><h2 id="3e34" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">授权流程包括以下步骤</h2><ol class=""><li id="09a5" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">用户使用元掩码登录。</li><li id="5144" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">从DynamoDB获取nonce。如果nonce不存在，则生成一个。</li><li id="9453" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">用当前帐户的私钥对邮件进行脱链签名。</li><li id="5da9" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">用Web3验证签名。</li><li id="36ca" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">获取开发人员认证的身份。</li><li id="b896" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">获取返回的开发人员验证的身份ID的凭据。</li><li id="26bd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">使用签名版本4对AWS请求进行签名。</li><li id="47b9" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">使用IAM授权控制对AWS API网关API的访问。</li></ol><p id="7ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图说明了身份验证流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/519d882afe72803c0f0f43d5d06ca3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H32Kc-IgOk4zLBMwKSk7uQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾毅的序列图。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a57c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><ul class=""><li id="a838" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu ob ns nt nu bi translated">设置一个AWS帐户。</li><li id="e707" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">设置一个<a class="ae ky" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank">元掩码</a>钱包。</li><li id="f6b7" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">安装金属掩模<a class="ae ky" href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en" rel="noopener ugc nofollow" target="_blank">镀铬延伸件</a>。</li><li id="8135" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">安装或更新<a class="ae ky" href="https://www.serverless.com/framework/docs/providers/aws/guide/installation/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>。</li></ul><p id="8d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80fb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应前端DApp</h1><p id="f581" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我为这篇文章创建了一个反应前端DApp。这个项目可以在我的<a class="ae ky" href="https://github.com/yai333/AWSandBlochainAuthFlow" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中看到。</p><p id="e8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户单击登录页面上的登录按钮时，他们需要连接到他们的元掩码钱包，并获取当前元掩码帐户的公共地址。元掩码连接函数如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了公共地址，我们将使用它通过公共地址获得随机数。如果在DynamoDB中没有发现nonce，我们将调用<code class="fe oe of og oh b">signup</code> API来创建加密的强伪随机数据作为nonce，并将其保存到DynamoDB表中。</p><p id="8037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用<code class="fe oe of og oh b"><a class="ae ky" href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth-personal.html" rel="noopener ugc nofollow" target="_blank">web3.eth.personal.sign</a></code>用nonce对字符串消息进行签名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行此代码片段将提示一个签名请求弹出窗口，用于对MetaMask中的消息进行签名。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8acf41b82ddfabd1b5e5556baf2ebbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Buv9IJVD-WDz9DQbrT0ODg.png"/></div></div></figure><p id="84f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击弹出窗口中的“签名”按钮时，<code class="fe oe of og oh b"><a class="ae ky" href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth-personal.html" rel="noopener ugc nofollow" target="_blank">web3.eth.personal.sign</a></code>的回调函数会返回一个签名。</p><p id="bd52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此后，前端进行身份验证API调用，传递签名和公共地址。如果令牌和签名在后端过程中被验证，前端将被给予AWS STS凭证(<code class="fe oe of og oh b">accessKeyId</code>、<code class="fe oe of og oh b">secretAccessKey</code>、<code class="fe oe of og oh b">sessionToken</code>)。</p><p id="b331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">身份验证过程完成后，我们可以使用AWS STS凭证通过<code class="fe oe of og oh b">Signature Version 4</code>对我们的请求进行签名，然后连接到使用AWS IAM权限保护的API网关端点。</p><p id="22c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">login</code>页面的示例代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经创建了我们的前端DApp，让我们继续后端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f833" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在无服务器应用程序中处理认证和授权</h1><p id="6431" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为提示，我假设您已经安装了无服务器框架，并且熟悉它。如果你不是，看看<a class="ae ky" href="https://www.serverless.com/framework/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">无服务器框架开源入门&amp; AWS </a>指南。</p><h2 id="4bf5" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">创建随机数和获取随机数</h2><p id="b60c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从DynamoDB获取nonce。如果nonce不存在，则生成一个。</p><p id="d63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要在DynamoDB中存储nonce和用户的公共地址。我们将创建一个<code class="fe oe of og oh b">user</code>表，其中每个条目都由<code class="fe oe of og oh b">address</code>唯一标识。</p><p id="63a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们导航到您的无服务器应用程序文件夹中的<code class="fe oe of og oh b">serverless.yml</code>文件。首先，将下列行添加到<code class="fe oe of og oh b">Resources</code>部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义了<code class="fe oe of og oh b">user</code>表，让我们构建一个API Gateway REST API，使用Lambda函数通过用户的公共地址来<code class="fe oe of og oh b">get/set</code> nonce。</p><p id="d41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下配置添加到<code class="fe oe of og oh b">functions</code>部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c23b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<code class="fe oe of og oh b">functions</code>部分的代码片段定义了两个API端点，<code class="fe oe of og oh b">getNonce</code>和<code class="fe oe of og oh b">signup</code>(创建nonce)。前端可以通过两个API网关HTTPS端点向Lambda函数发送请求。</p><p id="c4fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建相关的Lambda函数:<code class="fe oe of og oh b">getNonce</code>和<code class="fe oe of og oh b">signup</code>。</p><p id="f120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">getNonce</code> Lambda将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且<code class="fe oe of og oh b">signup</code> Lambda函数将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创建一个IAM策略，允许<code class="fe oe of og oh b">Get/Put/update</code>访问<code class="fe oe of og oh b">user</code> DynamoDB表。在<code class="fe oe of og oh b">serverless.yml</code>的<code class="fe oe of og oh b">provider</code>部分添加以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="259c" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">构建认证流程</h2><p id="c32b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们需要创建一个与开发人员提供者<code class="fe oe of og oh b">my.ether.login</code>相关联的Cognito身份池。</p><blockquote class="oj ok ol"><p id="edc1" class="kz la om lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">“使用开发人员身份认证，您可以通过自己现有的身份认证流程注册和认证用户，同时仍然使用Amazon Cognito来同步用户数据和访问AWS资源。”— <a class="ae ky" href="https://docs.aws.amazon.com/cognito/latest/developerguide/developer-authenticated-identities.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a></p></blockquote><p id="dbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建资源:<code class="fe oe of og oh b">CognitoIdentityPool</code>、<code class="fe oe of og oh b">CognitoAuthorizedRole</code>、<code class="fe oe of og oh b">unAuthorizedRole</code>、<code class="fe oe of og oh b">CognitoIdentityPoolRolesMapping</code>。将以下几行复制到<code class="fe oe of og oh b">Resources</code>，使该部分如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，是时候构建我们的无服务器认证流程了。该流程包括以下步骤:</p><ol class=""><li id="911d" class="nm nn it lb b lc ld lf lg li oq lm or lq os lu nr ns nt nu bi translated">用Web3验证签名。</li><li id="3d69" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">获取开发人员认证的身份。</li><li id="774a" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">获取返回的开发人员验证的身份ID的凭据。</li></ol><h2 id="016f" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">签名验证</strong></h2><p id="8d59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当用户通过发送POST请求登录到站点时，第一步是验证用户是否正确地签署了nonce。我们可以使用<code class="fe oe of og oh b">web3.personal.ecRecover</code>函数来验证已签名的消息。<code class="fe oe of og oh b">ecRecover</code>输出用于签署同一消息的<code class="fe oe of og oh b">signing_address</code>。如果<code class="fe oe of og oh b">signing_address</code>与我们来自请求体的地址匹配，那么发出请求的用户成功地证明了他们对公共地址的所有权:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="7772" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">开发者认证的身份</strong></h2><p id="2787" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦验证了签名，我们将在Lambda函数中实现我们自己的身份提供者，身份提供者函数应该返回一个包含属性<code class="fe oe of og oh b">identityId</code>和<code class="fe oe of og oh b">token</code>的响应对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="edc0" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><strong class="ak">获取已验证身份ID的凭证</strong></h2><p id="1371" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们建立了身份ID和令牌之后，我们可以调用<code class="fe oe of og oh b">getCredentialsForIdentity</code>来返回所提供的身份ID的STS凭证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止用户每次都用同一个签名登录，我们将改变<code class="fe oe of og oh b">login</code> Lambda函数底部的nonce ( <code class="fe oe of og oh b">updateNonce</code>)。授权流的完整示例代码如下所示。</p><p id="0315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">serverless.yml</code>的<code class="fe oe of og oh b">functions</code>段中的<code class="fe oe of og oh b">login</code> API端点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">login</code>λ函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="06fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！我们刚刚完成了区块链认证流程的构建。</p><p id="e6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以用<code class="fe oe of og oh b">AWS_IAM Authorizers</code>创建<code class="fe oe of og oh b">/hello</code> HTTP端点。成功登录后，用户可以提交IAM用户的访问密钥进行身份验证，以调用我们的Lambda函数。</p><p id="fe6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下几行复制到<code class="fe oe of og oh b">serverless.yml</code>的<code class="fe oe of og oh b">functions</code>部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe oe of og oh b">hello</code>λ函数看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="85d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用React前端的<code class="fe oe of og oh b"><a class="ae ky" href="https://github.com/mhart/aws4fetch" rel="noopener ugc nofollow" target="_blank">aws4fetch</a></code>用签名版本4和<code class="fe oe of og oh b">fetch()</code>对<code class="fe oe of og oh b">hello</code>请求进行签名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署无服务器应用，<code class="fe oe of og oh b">npm start</code>React应用，使用MetaMask登录。我们应该在仪表板页面上看到“您的IAM角色已授权”消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/0744a407e06b720392c7222e9d89fb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPqJaeaCMV6ScaosNigMlA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7296" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文介绍了一种使用MetaMask和Cognito的身份池开发人员提供者对用户进行身份验证的方法。我向您展示了如何使用<code class="fe oe of og oh b">AWS_IAM</code>授权器调用AWS API网关端点。我希望这篇文章对你有用。</p><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://github.com/yai333/AWSandBlochainAuthFlow" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的项目。</p></div></div>    
</body>
</html>