<html>
<head>
<title>How and Where to Handle Exceptions While Maintaining a Great API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及在哪里处理异常，同时维护一个优秀的API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-and-where-to-handle-exceptions-while-maintaining-a-great-api-e3df6c084746?source=collection_archive---------5-----------------------#2022-08-29">https://betterprogramming.pub/how-and-where-to-handle-exceptions-while-maintaining-a-great-api-e3df6c084746?source=collection_archive---------5-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1cbb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么我更喜欢通过结果模式的无异常方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f153fddb08a96bed3609f8d2fb62a781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rZ5AVuaAD3btjHmdTTk8w.jpeg"/></div></div></figure><p id="cdef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">异常处理并不容易。可以在错误的地方做，可以用错误的方式做，甚至可以完全忘记。</p><p id="ecd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个问题上，我们能做的最好的帮助我们的开发者伙伴的事情就是尽可能的设计我们的API。</p><p id="8a5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过结果模式的无异常方法是朝着这个方向迈出的一步。</p><p id="e9c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将指导您解决我在生产行业工作中多次遇到的一个典型的软件问题。我将提供一些简单的例子，分享我的想法，并解释为什么我更喜欢这个用例中的无异常方法。</p><p id="46f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我经常不得不在工作中处理实际的硬件。</p><ul class=""><li id="cb41" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">打开/关闭阀门</li><li id="0be1" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">开关继电器</li><li id="2165" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">从温度传感器检索值</li><li id="e0fe" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">移动致动器</li><li id="36d2" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi">…</li></ul><h1 id="a977" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">制造商的DLL</h1><p id="6b89" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">所有这些昂贵的硬件都从制造商那里以DLL的形式附带了一个软件。</p><p id="ddf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们想测量环境压力，买了一些昂贵的压力传感器。制造商为我们提供的驱动程序具有以下特点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="78af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于大多数制造商的dll来说，API不是很方便。为了实际调查当前的环境压力，我们必须</p><ol class=""><li id="640c" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm na lt lu lv bi translated">呼叫<code class="fe nb nc nd ne b">Init()</code></li><li id="1fb8" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm na lt lu lv bi translated">呼叫<code class="fe nb nc nd ne b">StartMeasurement()</code></li><li id="9158" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm na lt lu lv bi translated">打电话给<code class="fe nb nc nd ne b">StopMeasurement()</code></li><li id="04f4" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm na lt lu lv bi translated">呼叫<code class="fe nb nc nd ne b">GetPressure()</code></li></ol><h2 id="1c1f" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">不要重复自己！</h2><p id="00f7" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">因为我们不希望在我们的解决方案中重复调用，所以我们将引入一个新的类，它包装了制造商的驱动程序，为我们提供了一个方便的服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="717b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们通过连续多次轮询压力来测试我们的服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3ee2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然:只要我们运行应用程序，我们就会得到一个未处理的异常:</p><blockquote class="nr ns nt"><p id="af22" class="kr ks nu kt b ku kv jr kw kx ky ju kz nv lb lc ld nw lf lg lh nx lj lk ll lm ij bi translated">未处理的异常—系统。异常:“传感器连接中断。”</p></blockquote><h2 id="91d4" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">我们做错了什么？</h2><p id="c1cf" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我们只是从另一个应用层调用了一个方法，没有任何异常处理。</p><p id="f42b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">驱动程序类是我们不知道的第三方代码。然而，我们在没有任何安全网的情况下越过了边界。我们只是假设该方法将按预期工作。</p><blockquote class="ny"><p id="bde4" class="nz oa iq bd ob oc od oe of og oh lm dk translated">总是处理应用程序边界上的异常！</p></blockquote><p id="695f" class="pw-post-body-paragraph kr ks iq kt b ku oi jr kw kx oj ju kz la ok lc ld le ol lg lh li om lk ll lm ij bi translated">这包括:</p><ul class=""><li id="2dc5" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">硬件调用与通信协议无关</li><li id="3f23" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">网络请求或任何依赖于互联网的东西</li><li id="e4a9" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">外部代码，未知的、未记录的或未测试的。</li></ul><h2 id="f894" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">经典解决方案</h2><p id="ed21" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">既然我们已经发现了这个问题，那么让我们来实现它的经典解决方案:在我们的服务中实现一个try-catch权利:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这是可行的。所有的例外都会被我们的<code class="fe nb nc nd ne b">catch</code>吞噬。如果出错，我们只需返回一个<code class="fe nb nc nd ne b">double.NaN</code>。我们现在无一例外！</p><p id="d3da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是也有一些瑕疵。让我们从用户的角度来看我们服务的API。对于API，我只是指我们的方法<code class="fe nb nc nd ne b">GetPressure()</code>；它的名称、返回类型和输入参数。因为用户只能看到这些。</p><ul class=""><li id="1770" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">用户没有办法知道该方法是否抛出异常。他没有办法决定是否必须在不查看的情况下将该方法调用放入<code class="fe nb nc nd ne b">try/catch</code>中。太糟糕了。</li><li id="d521" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">用户无法知道该方法是否成功。即使方法运行时没有异常，他也必须检查是否得到了有效的数字或<code class="fe nb nc nd ne b">double.NaN</code>。那也很糟糕。</li></ul><h2 id="7995" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">尝试模式</h2><p id="b0a7" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">让我们进一步调整我们的服务，看看我们是否能消除这些缺陷:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3059" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的方法现在通过一个out变量返回压力。现在该方法的返回值是一个指示该方法成功或失败的<code class="fe nb nc nd ne b">bool</code>。我们还将我们方法的名称从<code class="fe nb nc nd ne b">GetPressure</code>调整为<code class="fe nb nc nd ne b">TryGetPressure</code>。</p><p id="ef92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚刚实现了Try模式。</p><h2 id="76d7" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">那样我们赢得了什么？</h2><p id="5006" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">以<code class="fe nb nc nd ne b">Try</code>开头的方法名是无异常的！这是Try模式中最重要的部分。</p><p id="e519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅仅通过读取方法的名称，我们服务的用户就已经知道他在调用它时不需要处理任何异常。这听起来微不足道，但却是API设计的重要组成部分:</p><blockquote class="ny"><p id="3a6c" class="nz oa iq bd ob oc od oe of og oh lm dk translated">如果你让用户知道期待什么，他会以正确的方式去做。</p></blockquote><p id="0a67" class="pw-post-body-paragraph kr ks iq kt b ku oi jr kw kx oj ju kz la ok lc ld le ol lg lh li om lk ll lm ij bi translated">另一个缺陷也被消除了:用户可以简单地检查返回的<code class="fe nb nc nd ne b">bool</code>标志，看看方法调用是否成功。当方法已经返回<code class="fe nb nc nd ne b">false</code>时，他根本不需要查看压力值。</p><p id="668f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是在我看来有一些新的缺陷:</p><ul class=""><li id="897c" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">我不喜欢out变量的语法。许多干净的代码先知会立即签署。这只是令人困惑——每个人都期望方法的输出在它的名字的左边，而突然在输入之间有了输入？仅仅因为我们能，并不意味着我们应该。不要用你的语言提供的所有语法来混淆你的代码。保持简单！</li><li id="76ee" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">我们只有一个二进制的结果。但是大多数时候，我们希望为我们方法的用户提供更多的信息。考虑我们的方法可能失败的所有原因:服务无法连接到传感器？服务已连接到传感器，但连接丢失？传感器返回一个值，但这个值不可信。用户可能想用不同的方式来处理这些情况。在某些情况下，他可能会安排重试，在其他情况下，他可能只是显示一个描述性的错误消息。</li></ul><h2 id="5d14" class="nf mc iq bd md ng nh dn mh ni nj dp ml la nk nl mn le nm nn mp li no np mr nq bi translated">结果模式</h2><p id="6b01" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">为了解决这些缺陷，让我们进一步调整我们的服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9e91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个版本中，我们不返回一个<code class="fe nb nc nd ne b">bool</code>，而是返回一个<code class="fe nb nc nd ne b">Result&lt;double&gt;</code>类型的完整的<code class="fe nb nc nd ne b">object</code>。</p><p id="8c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在深入研究类型<code class="fe nb nc nd ne b">Result</code>之前，先看看我们服务的新用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="55bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您回顾一下API及其用法，您会注意到:</p><p id="5cc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你得到的不是一个<code class="fe nb nc nd ne b">double</code>，而是一个<code class="fe nb nc nd ne b">Result&lt;double&gt;</code>。你不得不考虑如果手术失败了你会怎么做。只要使用<code class="fe nb nc nd ne b">Result&lt;double&gt;</code>你就知道可能会有问题。如果我只是在方法中抛出一个异常，你不会注意到吧？这就是结果模式的最大好处。</p><blockquote class="ny"><p id="aaf1" class="nz oa iq bd ob oc od oe of og oh lm dk translated">一个好的API迫使用户正确使用它！这使得几乎不可能忘记错误处理。</p></blockquote><h2 id="fa64" class="nf mc iq bd md ng on dn mh ni oo dp ml la op nl mn le oq nn mp li or np mr nq bi translated">结果对象</h2><p id="cdb9" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">结果对象只包含您感兴趣的实际值以及您需要的任何附加信息——错误原因、成功原因、类似<code class="fe nb nc nd ne b">IsFailed</code>的帮助方法——要有创意！</p><p id="9715" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种模式并不新鲜；很经典。结果模式有许多可用的库，因此您甚至不必实现自己的<code class="fe nb nc nd ne b">Result</code>类！</p><p id="5fd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的。NET示例使用了伟大的项目<a class="ae os" href="https://github.com/altmann/FluentResults" rel="noopener ugc nofollow" target="_blank"> FluentResults </a>。</p><h1 id="bf3f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="c686" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">为了消化，我将重复我的介绍:</p><p id="abb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">异常处理并不容易。可以在错误的地方做，可以用错误的方式做，甚至可以完全忘记。</p><p id="be56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个问题上，我们能做的最好的帮助我们的开发者伙伴的事情就是尽可能的设计我们的API。</p><p id="7ef9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过结果模式的无异常方法是朝着这个方向迈出的一步。</p><p id="6787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>