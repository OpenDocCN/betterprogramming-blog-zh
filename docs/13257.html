<html>
<head>
<title>Kotlin Retry To Make Your Code More Resilient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林尝试让你的代码更有弹性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-retry-to-make-your-code-more-resilient-5b8cc4fac4e4?source=collection_archive---------2-----------------------#2022-08-11">https://betterprogramming.pub/kotlin-retry-to-make-your-code-more-resilient-5b8cc4fac4e4?source=collection_archive---------2-----------------------#2022-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb53" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kotlin包装函数重试代码的任何部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/542abfce35b8b8ef9df452caf53c3fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVDuJx9u_soOW-MKvwHZgg.png"/></div></div></figure><p id="e9bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我的“Kotlin cookbook”函数之一，当我需要对代码的任何部分进行简单的重试时，它会有所变化。在标准的Kotlin内联函数中，我没有发现任何类似的东西，所以我试图发明自己的函数。</p><h1 id="7f6f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">最简单的实现</h1><p id="4be9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">众所周知，当使用远程资源时，“重试模式”被认为是最佳实践，并且是<a class="ae mn" href="https://blog.codecentric.de/en/2019/06/resilience-design-patterns-retry-fallback-timeout-circuit-breaker/" rel="noopener ugc nofollow" target="_blank">弹性设计</a>所必须的。因此，当我需要一个简单而优雅的重试时，我将这个内联函数引入我的源代码:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2023" class="mt lr it mp b gy mu mv l mw mx">inline fun &lt;T&gt; executeWithSocketTimeoutRetry(call: () -&gt; T) =<br/>    try {<br/>        call()<br/>    } catch (e: ProcessingException) {<br/>        call()<br/>    }</span></pre><blockquote class="my mz na"><p id="c1eb" class="ku kv nb kw b kx ky ju kz la lb jx lc nc le lf lg nd li lj lk ne lm ln lo lp im bi translated">请记住，在大多数WebClient实现中，您无法直接捕获" Java . net . sockettimeoutexception:Read timed "<em class="it"/><em class="it">，</em>，这样做是一个常见的错误</p></blockquote><p id="9c3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，您需要捕捉一个特定的<a class="ae mn" href="https://stackoverflow.com/questions/37244264/java-jersey-retry-request-on-sockettimeoutexception" rel="noopener ugc nofollow" target="_blank">包装器</a>异常。当然，您可以捕捉一般的异常，但不建议这样做。</p><h2 id="658a" class="mt lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">使用</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="9b72" class="mt lr it mp b gy mu mv l mw mx">val result = <em class="nb">executeWithSocketTimeoutRetry </em>{<strong class="mp iu"><br/>    </strong>//do request and return a result<br/>}</span></pre><p id="2842" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是如何在由<a class="ae mn" href="https://github.com/eclipse-ee4j/jersey" rel="noopener ugc nofollow" target="_blank"> Jersey REST框架</a>抛出的SocketTimeoutException(Read timed out)上用retry包装一部分代码，并从中获得一个结果。</p><h1 id="21ef" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">改进实施</h1><p id="6466" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我想你已经明白了，为了让事情更明显，下面是上面“重试”功能的另一个更有用的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a6e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我声明了一种我想要捕捉的异常。这使得这个函数更具可重用性。由于语言的限制，我不能直接捕捉参数化的异常。一种解决方法是捕获所有异常，然后用条件表达式检查它们。</p><h2 id="e381" class="mt lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">使用</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8606" class="mt lr it mp b gy mu mv l mw mx"><em class="nb">executeWithRetry</em>&lt;IllegalArgumentException&gt; {<strong class="mp iu"><br/>    </strong>//some important code here<br/>}</span></pre><p id="61c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个变体中，我正在重试代码的一部分，并且不期望任何输出。</p><h1 id="0149" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">高级实施</h1><p id="0add" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">但是如果您需要从包装的代码中返回一些值呢？这也是可能的，但是将异常类型移到参数列表会更容易，因为Kotlin不能自动推断多个泛型类型。既然我们现在已经有了参数，让我们带来一个更方便的参数—重试次数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="c1a7" class="mt lr it bd ls nf ng dn lw nh ni dp ma ld nj nk mc lh nl nm me ll nn no mg np bi translated">使用</h2><p id="875f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这就是我们如何在Kotlin中简单地重试代码的任何部分。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="20e2" class="mt lr it mp b gy mu mv l mw mx">val result = executeWithRetry{<br/>   // code that returns value<br/>}</span></pre><p id="3f2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者更具体地说，仅在<code class="fe ns nt nu mp b">IllegalArgumentException</code>重试。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c82e" class="mt lr it mp b gy mu mv l mw mx">val result = executeWithRetry({ it is IllegalArgumentException }) {<br/>   // code that returns value<br/>}</span></pre><p id="51ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用谓词在灵活性方面给了我们很多优势。例如，我们可以在解开原始异常时捕捉一些异常类型。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ab04" class="mt lr it mp b gy mu mv l mw mx">val result = <em class="nb">executeWithRetry</em>({ it is IllegalArgumentException || it.cause is IOException}) {<br/>    // code that returns value<br/>}</span></pre><p id="fbb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们甚至可以在每次重试后做额外的动作，比如用<code class="fe ns nt nu mp b">also</code>关键字记录重试次数。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="baf3" class="mt lr it mp b gy mu mv l mw mx">val result = <em class="nb">executeWithRetry</em>({ e -&gt;<br/>    (e is IOException).<em class="nb">also </em>{ if (it) <em class="nb">println</em>("Retrying after $e") }<br/>}) {<br/>    // code that returns value<br/>}</span></pre><p id="5355" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者甚至重试不止一次，重试之间有延迟。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="269d" class="mt lr it mp b gy mu mv l mw mx">val result = <em class="nb">executeWithRetry</em>({ e -&gt;<br/>    (e is IOException).<em class="nb">also </em>{ if (it) Thread.sleep(100) }<br/>}, retries = 2) {<br/>    // code that returns value<br/>}</span></pre><h1 id="c4a0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">额外的Java实现</h1><p id="7217" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果您对Java实现感兴趣，我可以满足您。在Kotlin之前，我使用了与Java 8相同的思想，用额外的逻辑包装代码的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b7a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了方便起见，我将所有的<code class="fe ns nt nu mp b">Exceptions</code>用<code class="fe ns nt nu mp b">RuntimeExceptions</code>包装起来。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6f38" class="mt lr it mp b gy mu mv l mw mx">var restult = executeWithRetry(IllegalArgumentException.class, () -&gt; {<br/>    //code that returns result<br/>});</span></pre><h1 id="00f1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="1829" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这就是你如何在没有任何额外的库或代码依赖的情况下重试你的部分代码。您还可以将这种包装器思想用于其他功能，如日志记录、前/后逻辑等。一些标准的Kotlin内联函数使用相同的方法，例如<code class="fe ns nt nu mp b"><a class="ae mn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/measure-time.html" rel="noopener ugc nofollow" target="_blank">measureTime</a></code>、<strong class="kw iu">、</strong>。</p><p id="81ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，这是最简单的重试实现。一旦我需要更复杂的东西，我就用<a class="ae mn" href="https://github.com/resilience4j/resilience4j" rel="noopener ugc nofollow" target="_blank"> Resilience4j </a>库，因为它给了我其他现成的特性，比如用<code class="fe ns nt nu mp b">ExponentialBackoff</code>和<code class="fe ns nt nu mp b">CircuitBreaker</code>重试。</p></div></div>    
</body>
</html>