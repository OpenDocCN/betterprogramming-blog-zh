<html>
<head>
<title>Using Disjoint-Set (Union-Find) to Build a Maze Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用不相交集(Union-Find)构建迷宫生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-disjoint-set-union-find-to-build-a-maze-generator-7462ea3b8632?source=collection_archive---------15-----------------------#2020-01-21">https://betterprogramming.pub/using-disjoint-set-union-find-to-build-a-maze-generator-7462ea3b8632?source=collection_archive---------15-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1776" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给我留下深刻印象的数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ad3312eed16094add6aa04d2a955ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6xLaj7gfym9z9K21xHJ0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥马尔·索蒂洛·佛朗哥在<a class="ae ky" href="https://unsplash.com/s/photos/maze?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多年前开始学数据结构的时候，<code class="fe lv lw lx ly b">disjoint-set</code>是给我印象比较深的一个，它是那么的素雅，有用。</p><p id="3b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将学习<code class="fe lv lw lx ly b">disjoint-set</code>是如何工作的，然后我们用它实现一个迷宫生成器。我希望这能帮助初学者找到数据结构的乐趣。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="613e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不相交集(联合查找)数据结构</h1><p id="894f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Disjoint-set</code>是一种数据结构，它跟踪一组被分割成许多不相交(非重叠)子集的元素。根据定义，两个不相交的集合是其交集是空集的集合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1f1eb3d35646de356ab3b987863ee131.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*a77STcGXS0l-SdH3"/></div></figure><p id="1f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中:e1、e2在<code class="fe lv lw lx ly b">Set1</code>，e3、e4、e5在<code class="fe lv lw lx ly b">Set2</code>。</p><p id="b79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不交化集合有两种运算，<code class="fe lv lw lx ly b">union</code>和<code class="fe lv lw lx ly b">find</code>，这就是不交化集合也可以用名称<code class="fe lv lw lx ly b">union-find</code>来调用的原因:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="1224" class="ni mh it ly b gy nj nk l nl nm">make_set()    =&gt; create a disjoin-set<br/>union(e1, e2) =&gt; link 'e1' and 'e2' to the same subset<br/>find(e)       =&gt; return the subset's root for 'e'</span></pre><p id="0173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们联合两个不同集合中的任意两个元素，那么它们将被合并成一个更大的集合。</p><p id="e464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果e2和e3联合，这也意味着e1和e5在同一个集合中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/69097353c126aea85ed401bd342c321a.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/0*NqRuu9XBpFFBN8wF"/></div></figure><p id="d75e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用<code class="fe lv lw lx ly b">find</code>的结果，我们可以测试两个元素是否属于同一个集合。如果<code class="fe lv lw lx ly b">find(e1)</code>等于<code class="fe lv lw lx ly b">find(e2)</code>，这意味着e1和e2在同一个集合中。</p><p id="c1f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">disjoin-set</code>的一个有用的属性，特别是对于图算法，我们需要测试两个节点之间是否有连通性。</p><p id="a506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上面的规范和描述，您如何自己实现这个数据结构呢？你可以花几分钟自己尝试一下，这是学习数据结构和算法的好方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9ecf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用数组的简单实现</h1><p id="6ec9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们需要找出在编程语言中使用哪种基本数据结构来存储数据。如果我们可以存储一个元素的父元素，我们就可以构造一个树状结构来保持元素之间的关系。</p><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，如果我们完成了<code class="fe lv lw lx ly b">union(e1, e2)</code>、<code class="fe lv lw lx ly b">union(e2, e3)</code>、<code class="fe lv lw lx ly b">union(e3, e4)</code>的操作，构造的树会是这样的(假设我们总是将第一个参数设置为父参数):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/200a87611e226d16d6cdbdc4aedb1bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/0*CqS2xxRg7wP52AeL"/></div></figure><p id="9e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">find(e)</code>将以递归的方式实现，尝试自下而上的查找父节点，根据树。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b1e2" class="ni mh it ly b gy nj nk l nl nm">#define MAX_SIZE 60<br/>int parent[MAX_SIZE];  // the parent root for each node<br/><br/>void make_set() {<br/>  for(int i=0; i &lt; MAX_SIZE; ++i )<br/>    parent[i] = i;<br/>}<br/><br/>int find(int x) {<br/>  // recursive find and path compression<br/>  if(x != parent[x])<br/>    return find(parent[x]);<br/>  return parent[x];<br/>}<br/><br/>void union_set(int e1, int e2) {<br/>  if( x == y ) return;<br/>  parent[e2] = e1; // e1 is always the parent<br/>}</span></pre><p id="3666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们已经用数组完成了第一版<code class="fe lv lw lx ly b">union-find</code>！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="16d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.路径压缩优化</h1><p id="dd95" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们运行更多的测试用例来验证我们实现的正确性，如果我们运行<code class="fe lv lw lx ly b">union(e1, e2)</code>、<code class="fe lv lw lx ly b">union(e3, e4)</code>、<code class="fe lv lw lx ly b">union(e2, e4)</code>操作会发生什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4bd94c7ec8b164bc81af7286105819c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*Rs63Uvawo_p3mZnh"/></div></figure><p id="2ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等！这不是我们所期望的！根据上面的定义，我们期望e1，e2，e3，e4在同一个集合中。似乎我们在<code class="fe lv lw lx ly b">union_set</code>的功能上有一个bug。</p><p id="6967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊！我们要做的是联合两个集合，而不仅仅是两个元素的父关系。当我们<code class="fe lv lw lx ly b">union(e2, e4)</code>的时候，需要找到e2和e4的根，用一个<code class="fe lv lw lx ly b">union(e1, e3)</code>的运算来完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4e8d703d48354e800afb6880faea33fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/0*FaNThPMFBkd00Soq"/></div></figure><p id="b80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们修复第一个版本中的错误:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="7a5e" class="ni mh it ly b gy nj nk l nl nm">void union_set(int e1, int e2) {<br/>  int root1 = find(e1);<br/>  int root2 = find(e2);<br/>  if( root1 == root2 ) return;<br/>  parent[root2] = root1; // e1's root is always the parent<br/>}</span></pre><p id="d9e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单实现的时间复杂度是O(N)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3dc3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.按秩联合优化</h1><p id="a654" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们试着让它快点。在<code class="fe lv lw lx ly b">find</code>的朴素递归函数中，如果我们在每次递归迭代中缓存结果，时间性能会好很多。这就是<a class="ae ky" href="https://coderscat.com/caching-from-top-to-bottom" rel="noopener ugc nofollow" target="_blank"> <em class="nr">缓存中解释的缓存技术:自下而上</em> </a>。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="110d" class="ni mh it ly b gy nj nk l nl nm">int find(int x) {<br/>  // recursive find with path compression<br/>  if(x != parent[x])<br/>    parent[x] = find(parent[x]);<br/>  return parent[x];<br/>}</span></pre><p id="2e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe lv lw lx ly b">find</code>的函数调用之后，我们可以使树变得更平(深度更短，这加快了对这些元素的未来操作):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7d835025bbe04c6de9e4f0d6b3c9e0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/0*_xEy-Hj44uSQohne"/></div></figure><p id="746a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的第一个版本<code class="fe lv lw lx ly b">union_set</code>中，我们总是将e1的根设置为e2的父级，多次union操作后会发生什么？</p><p id="cb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树的深度会不断增加。我们能为此做一些优化吗？一项名为“按级别联合”的策略将有助于解决这一问题。</p><p id="8219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用另一个数组来记录秩(元素子树的深度)，那么我们总是试图将深度较大的元素设置为父元素。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c33a" class="ni mh it ly b gy nj nk l nl nm">int rank[MAX_SIZE];    // the depath rank, initialized with 0 in make_set<br/><br/>void union_set(int e1, int e2) {<br/>  int x = find_set(e1);<br/>  int y = find_set(e2);<br/>  if( x == y ) return;<br/><br/>  // optimization with rank<br/>  if(rank[x] &gt; rank[y])<br/>    parent[y] = x;<br/>  else {<br/>    parent[x] = y;<br/>    if(rank[x] == rank[y]) ++rank[y];<br/>  }<br/>}</span></pre><p id="7f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举个例子来理解这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4921eeae542aa72b1c0e762c5b1f7705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/0*fcVxVU1O7h5dUAbe"/></div></figure><p id="28d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用按秩并集的操作，当两个根的深度不相等时，我们可以保持树的深度，这样它就不会生长了！</p><p id="b429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种策略叫做<code class="fe lv lw lx ly b">union by size</code>，总是将元素较少的树附加到元素较多的树根上。</p><p id="e749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优化版本的时间分析涉及许多数学技巧。</p><p id="394c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单得出结论，路径压缩并按秩联合，摊销时间复杂度仅为O(α(n))，其中α(n)为<a class="ae ky" href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse" rel="noopener ugc nofollow" target="_blank">逆阿克曼函数</a>，对于任何实际输入大小<em class="nr"> n </em>，α(n)小于五。</p><p id="69e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真的是很好的时间表现！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7a97" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">随机迷宫生成</h1><p id="3ac6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">用新学到的数据结构完成一个小项目会对你的学习有很大帮助。</p><p id="335b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我看罗伯特·塞奇威克 的<a class="ae ky" href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X" rel="noopener ugc nofollow" target="_blank"> <em class="nr">算法的时候，有一个用<code class="fe lv lw lx ly b">disjoin-set</code>生成随机迷宫的练习。</em></a></p><p id="07ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很棒的算法，简化后的代码如下所示:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2a7d" class="ni mh it ly b gy nj nk l nl nm">void rand_maze {<br/>  // begin with a rectangular maze of all closed cells<br/>  // numrows = number of rows of cells;<br/>  // numcols = number of columns of cells;<br/>  start = cell at (0,0);<br/>  goal  = cell at (numrows-1, numcols-1);<br/>  numcells = numrows * numcols;<br/>  Partition p(numcells); // p represents the maze components<br/><br/>  // goal is not reachable from start<br/>  while (!p.Find(start, goal)) {<br/>    edge = randomly select a wall;<br/>    x = edge.x;<br/>    y = edge.y;<br/>    if(!p.Find(x,y)) {<br/>      remove edge;<br/>      // x and y now in same component<br/>      p.Union(x,y);<br/>    }<br/>  }<br/>}</span></pre><p id="8343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lv lw lx ly b">disjoin-set</code>来测试<code class="fe lv lw lx ly b">start</code>和<code class="fe lv lw lx ly b">goal</code>是否连接，在地图中随机移除一条边，直到它们连接。</p><p id="ab89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的迷宫如下所示，左上角有一个起始单元格，右下角有一个目标单元格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3c579c090057d96ecdd4d2303e0657f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/0*cqRmbQIkweqnKbs-"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0047" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><ul class=""><li id="85f6" class="nv nw it lb b lc my lf mz li nx lm ny lq nz lu oa ob oc od bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="noopener ugc nofollow" target="_blank">维基百科不相交集数据结构</a></li><li id="56a5" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X" rel="noopener ugc nofollow" target="_blank">罗伯特·塞奇威克的算法</a></li></ul></div></div>    
</body>
</html>