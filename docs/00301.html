<html>
<head>
<title>How To Properly Use the React useRef Hook in Concurrent Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在并发模式下正确使用React useRef钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-properly-use-the-react-useref-hook-in-concurrent-mode-38c54543857b?source=collection_archive---------0-----------------------#2019-03-07">https://betterprogramming.pub/how-to-properly-use-the-react-useref-hook-in-concurrent-mode-38c54543857b?source=collection_archive---------0-----------------------#2019-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d7dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并发模式要求更严格的组件编写方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79a53d1bad55a648c35ddacd077b82cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFsnw6E0OH5lguQAguApMQ.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d3d2" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">介绍</h1><p id="b62a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">根据<a class="ae mp" href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html" rel="noopener ugc nofollow" target="_blank"> React 16.x路线图</a>，我们很快就可以期待并发模式了。</p><h2 id="371a" class="mq lc it bd ld mr ms dn lh mt mu dp ll mc mv mw ln mg mx my lp mk mz na lr nb bi translated">React 16.x (~Q2 2019):并发模式的那个</h2><p id="9f2a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">并发模式允许<a class="ae mp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>应用在不阻塞主线程的情况下渲染组件树，从而提高响应速度。</p><p id="ac3f" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">它是可选的，并允许React中断长时间运行的呈现(例如，呈现新的提要故事)来处理高优先级事件(例如，文本输入或悬停)。</p><p id="660a" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">并发模式还通过跳过快速连接上不必要的加载状态来改善用户的悬念体验。</p><p id="cff7" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">虽然它是一个选择加入的特性，但是您可以很容易地启用它，如果您的组件没有正确实现，它将无法正常工作。</p><p id="fbd8" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">简而言之，你不能在你的渲染函数中制造副作用。这一直都是正确的，但是直到我们有了并发模式，它才成为一个真正的问题。</p><p id="a938" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">在并发模式下，可以多次调用渲染函数，而无需实际提交(例如，将更改应用到DOM)。</p><p id="c7e1" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">幸运的是，严格模式故意调用两次呈现函数，您可以在开发模式中看到错误的行为。更多信息请参考<a class="ae mp" href="https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="14ed" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">这篇短文关注的是React的钩子之一<code class="fe nh ni nj nk b">useRef</code>。<code class="fe nh ni nj nk b">useRef</code>钩子非常强大，经常会被误用。一般来说，开发人员应该避免使用<code class="fe nh ni nj nk b">useRef</code>，如果他们可以使用<code class="fe nh ni nj nk b">useState</code>来代替的话。</p><p id="64cc" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">本文展示了错误使用<code class="fe nh ni nj nk b">useRef</code>的示例代码以及如何修复它。</p><p id="6e88" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">这个例子是一个简单的计数器，只是为了说明这个问题。不是产品代码，实际上可以用<code class="fe nh ni nj nk b">useState</code>实现同样的例子。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="2151" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">错误代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="042b" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">它在传统的React中按预期工作，其中呈现阶段和提交阶段是一对一的。</p><p id="4b0b" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">但是，如果它多次调用render函数而没有提交，计数会意外增加。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a37f" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">好代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5d92" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">这段代码使用了<code class="fe nh ni nj nk b">useEffect</code>，它的第一个参数函数只在提交阶段被调用。</p><p id="2bcc" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated"><code class="fe nh ni nj nk b">currentCount</code>是渲染函数范围内的局部变量，它只会在提交阶段改变ref <code class="fe nh ni nj nk b">count</code>。ref本质上是函数范围之外的一个全局变量，因此修改它是一个副作用。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="72a1" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">演示</h1><p id="8651" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">为了运行上面的两个代码示例，下面是应用程序组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e798" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">我们其实不需要<code class="fe nh ni nj nk b">ConcurrentMode</code>，只要<code class="fe nh ni nj nk b">StrictMode</code>就够了。</p><p id="a686" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">请查看下面的“codesandbox”以了解实际行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn nm l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="31b9" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">最终注释</h1><p id="e566" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我想用<code class="fe nh ni nj nk b">useRef</code>的原因是为Redux开发一个绑定库。它需要订阅全局存储，并在状态更新时更新组件。</p><p id="8e70" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">ref用于跟踪上一次呈现的状态。要了解更多信息，请查看GitHub资源库。</p><div class="no np gp gr nq nr"><a href="https://github.com/dai-shi/react-hooks-easy-redux" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">戴式/反应式挂钩-简易-还原</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用Hooks API为Redux提供简单的React绑定。为dai-shi/react-hooks-easy-redux开发作出贡献</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>