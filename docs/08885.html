<html>
<head>
<title>11 Advanced Vue Coding Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">11个高级Vue编码技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-vue-tricks-6e315347c378?source=collection_archive---------0-----------------------#2021-06-23">https://betterprogramming.pub/advanced-vue-tricks-6e315347c378?source=collection_archive---------0-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dbb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我在Vue工作5年后的策划列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c3b100d17baa2f290ac464d1429d4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGZG_7BPv7o_Mck6iaDoAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="http://titusdecali.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">提图斯</strong> </a>拍摄</p></figure><p id="244c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">今天，我为大家带来了一个精选的知识集合，帮助大家更快地构建Vue应用，同时使它们更具性能，更易于大规模管理。</p><h2 id="e8fb" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">这些高级小技巧从何而来？</strong></h2><ul class=""><li id="fa15" class="mp mq it lc b ld mr lg ms lj mt ln mu lr mv lv mw mx my mz bi translated">五年的Vue。</li><li id="097d" class="mp mq it lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">在Vue 2和Vue 3中构建了20多个大型客户项目。</li><li id="4eb7" class="mp mq it lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">来自有影响力的Vue开发者的精选简讯提示。</li></ul><p id="75cd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然高级Vue开发人员会发现这些概念非常有用，但我已经详细描述了如何实现它们，因此没有一个初学者会被落下！ </p><p id="17ef" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你需要任何进一步的解释，请留下评论，我很乐意帮忙。有自己的高级战术？也可以随意分享这些！</p><p id="4790" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好了，让我们开始吧。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b61f" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">动态SVG组件</h1><p id="3b5a" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">如果你像我一样，喜欢手工制作你的应用程序——选择独特的SVG图标来适应你的风格指南，并将它们与自定义动画和风格配对。</p><p id="5d62" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这样做的问题是，要改变SVG图像的颜色，您需要访问模板中内嵌的SVG代码。根据SVG的大小，即使只有一两个矢量图像，也会使模板代码迅速膨胀。</p><p id="ec1b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我已经测试了各种方法和包来访问<code class="fe ob oc od oe b">fill</code>属性，而不会破坏我的模板，结果是添加<code class="fe ob oc od oe b">hover</code>或<code class="fe ob oc od oe b">active</code> CSS状态的最好方法是在SVG中更改一个或多个<code class="fe ob oc od oe b">fill</code>属性，这实际上是最明显的方法——只是让它成为一个组件！</p><p id="ad5b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，当我们需要这种功能时，而不是使用这个:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="c7a4" class="lw lx it oe b gy oj ok l ol om">&lt;img src="@/assets/images/myImg.svg" /&gt;</span></pre><p id="bb38" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">相反，我们将在VSCode中打开我们的<code class="fe ob oc od oe b">.svg</code>图像，然后复制我们图像的<code class="fe ob oc od oe b">&lt;svg~</code>代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a2e15b1bcd047697759ca2a6b70476d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NctBZ6Y9FBCD8X9g_iD40w@2x.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复制Svg代码(使用<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=SimonSiefke.svg-preview" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz"> Svg预览</strong> </a>预览您的SVG图像)</p></figure><p id="1ddd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="nf">边注:</em> </strong> <em class="nf">为了确保你看到的是正确的图像的代码，我建议安装一个名为</em><strong class="lc iu"><em class="nf"/></strong><a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=SimonSiefke.svg-preview" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu"><em class="nf">Svg预览</em></strong></a><strong class="lc iu"><em class="nf"/></strong><em class="nf">的VSCode扩展(如上图)。这将打开图像的侧面板预览，如果您更改SVG代码，它也会更新。</em></p><p id="cb00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们将这个代码粘贴到一个新的<code class="fe ob oc od oe b">component</code>模板中。我建议把你所有的SVG图标组件放到一个新的文件夹中，并相应地命名它们<code class="fe ob oc od oe b">(components/SVG/<strong class="lc iu">IconMoon.vue</strong>)</code>以保持事物的有序。</p><p id="ede3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦我们把它作为一个组件，我们就可以通过使用<code class="fe ob oc od oe b">&lt;IconMoon /&gt;</code>把它放到我们应用程序的任何其他组件或页面中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/4b82875eee00cebe00f18753b0378d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*p5-3PRwKUJ6rDp4HRiH_DQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在浏览器中测试动态SVG组件</p></figure><p id="425a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在上面的例子中，当我将鼠标悬停在SVG上时，我只是在我想改变的部分上设置了一个类(这里称为<code class="fe ob oc od oe b">.inner</code>)，但是我也可以直接访问所有SVG的属性，所以在保持其他组件没有SVG代码膨胀的情况下，你可以用这个方法做很多事情。</p><p id="1036" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您想要一些如上所述的扩展功能，您只需要创建一个定制的SVG组件。否则，你可以像平常一样简单地使用它们，就在图像的<code class="fe ob oc od oe b">src</code>之内。</p><p id="0277" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了动态图标样式和动画，您还可以通过道具来改变SVG的大小和其他方面(就像任何其他组件一样)。<a class="ae ky" href="https://vuejs.org/v2/cookbook/editable-svg-icons.html" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">Vue docs</strong></a><strong class="lc iu"/>提供了一个很好的例子，如果你还不熟悉，可以用图标来完成。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="cf19" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">使用<code class="fe ob oc od oe b">Vue-Router</code>数据实现更智能的导航链接</h1><p id="67f6" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">您可能没有意识到，但是<code class="fe ob oc od oe b">Vue-Router</code>可以像任何其他数据存储一样使用。您可以访问应用程序的所有可用路径，添加元数据以使逻辑更智能，甚至自动填充导航条、页面面包屑等内容！</p><p id="a05f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，乍看起来这并不明显，也不能像我们通常访问路线那样直接访问。</p><p id="8a3a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是我们将添加到模板中的基本代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从vue-router访问所有数据和元数据</p></figure><p id="b4e7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了这个<code class="fe ob oc od oe b">v-for</code>，您可以直接在模板中访问路由器树的所有<code class="fe ob oc od oe b">children</code>路由和单个路由元数据。</p><p id="baff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我最近在一个项目中使用它来生成一个动态边栏导航组件。我在<code class="fe ob oc od oe b">router</code>中设置了一个<code class="fe ob oc od oe b">showInSidebar</code>元数据属性，我想隐藏在工具条中。我也能够自动生成所有的边栏链接，而不用对每一个进行编码。</p><p id="95cd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我是这样设置我的<code class="fe ob oc od oe b">router</code>路线的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0a91dc2fb5d81987475ce8ab730596db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgRrQ6Drwmgx4pLceDaVDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为面包屑设置子路由和元数据(可以是任何值)</p></figure><p id="839f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">客户端还有一个额外的需求，他们不仅需要从路由器生成侧边栏路由，还需要从API数据生成侧边栏路由。上面的方法也以一种干净和可管理的方式解决了这个任务。我能够控制如何从路由器直接显示本地路由，以及是否使用API提供的路由。我还用它制作了自动面包屑来显示用户的路线历史。</p><p id="0f2f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这下面(这里没有显示),我还有一个单独的部分，允许侧边栏切换到使用从API发送的一组路由。为了触发它，我简单地使用了一个<code class="fe ob oc od oe b">v-if</code>，如果它们存在，它就使用它们，否则它将返回使用来自<code class="fe ob oc od oe b">vue-router</code>的路由。</p><p id="a3b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我的<code class="fe ob oc od oe b">SideNavbar</code>组件模板中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/7f28e3986d5eab9d08251307940032ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLZLafcRwSpRC6v0YGMHDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用法示例</p></figure><p id="6a7e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可能已经注意到了<code class="fe ob oc od oe b">exact-active-class</code>代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/a92ab057752af5101ffe5db55e3bd945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOS7PlyoTs63qSg1eqqhRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动突出显示链接的精确活动类</p></figure><p id="7556" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这样，如果路由器链接的目的地与当前路由匹配，Vue会自动设置一个活动类。</p><p id="693c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是一个很好的技巧，它绕过了我们用来实现这一点的典型逻辑，并将其简化为<code class="fe ob oc od oe b">exact-active-class=”className”.</code></p><p id="d712" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我经常把它用于导航条链接——它既减小了模板的大小，又使东西更整洁。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="9e59" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">从子组件访问父数据( )</h1><p id="f02f" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">有时我们想从父节点访问数据，但不想经历传递属性的麻烦。如果您只需要从<code class="fe ob oc od oe b">$parent</code>的数据对象中获取一个快速值，您可以简单地通过引用<code class="fe ob oc od oe b">$parent</code>来完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">访问子代中的父代数据</p></figure><p id="df58" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你想要更多在组件间传递数据的好方法，<br/> Erik Hanchett有一个<a class="ae ky" href="https://www.youtube.com/watch?v=rKWSj3zfBAs&amp;t=46s&amp;ab_channel=ProgramWithErik" rel="noopener ugc nofollow" target="_blank">很棒的视频</a>和一些其他选项。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="18f3" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">用<code class="fe ob oc od oe b">.includes( )</code>简化你的<code class="fe ob oc od oe b">:class</code>和<code class="fe ob oc od oe b">v-if</code>逻辑</h1><p id="bbb2" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">有了v指令的强大功能，我们很容易忘记我们仍然可以在模板中使用纯JavaScript的高级功能。</p><p id="ceb7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，假设您想要设置一个<code class="fe ob oc od oe b">class</code>，但是仅当用户在三条特定路线中的任何一条上时。当您第一次编写这个逻辑时，它可能看起来像这样:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="3047" class="lw lx it oe b gy oj ok l ol om">:class="<br/>  $route.name === 'Home'<br/>  || $route.name === 'Gallery' <br/>  || $route.name === 'Profile' <br/>  ? 'classOnlyOnThesePages' <br/>  : ''<br/>"</span></pre><p id="bbe1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，你可以学着像这样把它缩短一点:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="f644" class="lw lx it oe b gy oj ok l ol om">:class="{ <br/>  'classOnlyOnThesePages' : <br/>  $route.name === 'Home'<br/>  || $route.name === 'Gallery' <br/>  || $route.name === 'Profile'<br/>}"</span></pre><p id="fb8c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但最好的写法肯定是这样的:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="880f" class="lw lx it oe b gy oj ok l ol om">:class="{ <br/>  'classOnlyOnThesePages' : <br/>  ['Home', 'Gallery', 'Profile'].includes($route.name)<br/>}"</span></pre><p id="297f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你不喜欢这些东西毁了你的模板，有这样一种方法:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="95d6" class="lw lx it oe b gy oj ok l ol om">// &lt;template&gt;<br/>&lt;div :class="classByRoute"&gt;<br/>  Changes based on route<br/>&lt;/div&gt;<br/>...</span><span id="7a8f" class="lw lx it oe b gy ot ok l ol om">// &lt;script&gt;<br/>computed: { <br/>  classByRoute() {<br/>    return 'classOnlyOnThesePages' : <br/>      ['Home', 'Gallery', 'Profile'].includes($route.name)<br/>  }  <br/>}<br/>...</span><span id="67ca" class="lw lx it oe b gy ot ok l ol om">// &lt;style&gt;<br/>.classOnlyOnThesePages {<br/>  background: red;<br/>}<br/>...</span></pre><p id="d4f2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这不仅可读性更好，而且以后扩展起来也容易得多。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="314b" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">当路线改变时滚动到顶部</h1><p id="0064" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">当您更改路线时，Vue会保持您在页面上的当前位置。这有时很有用，但大多数时候只是一个麻烦。如果你向下滚动一个很长的列表，然后转到另一个页面，你的滚动条将会在新页面的底部，而不是你期望的顶部。</p><p id="ee5b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">解决这个问题很简单。只需在您的<code class="fe ob oc od oe b">app.js</code>文件中添加一个<code class="fe ob oc od oe b">watch:</code>，它会在每次路线更改后触发滚动到顶部:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每次更改路线时滚动到顶部</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c6b2" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">对干燥机代码使用全局实用方法</h1><p id="0d1c" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">几乎每个Vue项目都有在应用程序的多个地方重用的逻辑。为了让我们的代码保持干燥(不要重复)和易于管理，我们应该创建一个单独的<code class="fe ob oc od oe b">utils.js</code>文件来保存这个重用的逻辑，并且可以从任何地方访问。</p><p id="cca2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="nf">注意:</em> </strong> <em class="nf">您可能认为Vuex很适合这类事情，但是除非您想将您的实用程序方法产生的值存储在state中，否则它真的不适合这个场景。如果你只是想从一个全局函数返回一个值，那么一个单独的</em><strong class="lc iu"><em class="nf">utils . js</em></strong><em class="nf">文件就是与Vue.prototype配对的键(如下所示)。但是，如果您仍然想在您的实用程序中访问您的Vuex状态，您可以这样做:<br/> </em> <code class="fe ob oc od oe b">import store from '../store'</code> <em class="nf">，然后做类似<br/> </em> <code class="fe ob oc od oe b">store.getters</code> <em class="nf">或</em> <code class="fe ob oc od oe b">store.state</code> <em class="nf">的事情来访问您的Vuex状态的属性。</em></p><p id="1fc9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好的——首先我们要设置我们的<code class="fe ob oc od oe b">utils.js</code>文件，并添加一个全局方法，将文本复制到用户的剪贴板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全局Vue实用程序功能</p></figure><p id="89fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们已经有了我们的实用方法，我们只需要让它在整个应用程序中可访问。我们可以将它们导入到一个组件中，并以这种方式使用它们，但是我发现让它们在全球范围内可用会产生更干净、更可读的代码，同时使东西更容易访问。</p><p id="d9ae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了使这些函数全局可用，我们将编辑我们的<code class="fe ob oc od oe b">main.js</code>文件。Vue 2和Vue 3之间的设置略有不同，因此相应地选择您的口味。</p><h2 id="8f53" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">在Vue2中</h2><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="93f5" class="lw lx it oe b gy oj ok l ol om"><strong class="oe iu">//<em class="nf"> Utils</em></strong><em class="nf"><br/>import</em> Utils <em class="nf">from</em> './utils/utils.js'</span><span id="657e" class="lw lx it oe b gy ot ok l ol om"><br/><strong class="oe iu">//<em class="nf"> Init Global Utils</em></strong><em class="nf"><br/></em>Vue<em class="nf">.</em>prototype<em class="nf">.</em>$utils = Utils</span></pre><h2 id="9cdf" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">在Vue3中</h2><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="e468" class="lw lx it oe b gy oj ok l ol om"><strong class="oe iu">//<em class="nf"> Utils</em></strong><em class="nf"><br/>import</em> Utils <em class="nf">from</em> './utils/utils.js'   <em class="nf">//</em> <em class="nf">&lt;-- import file</em><br/></span><span id="b394" class="lw lx it oe b gy ot ok l ol om">const<em class="nf"> app </em>=<em class="nf"> createApp</em>(App)</span><span id="1548" class="lw lx it oe b gy ot ok l ol om"><strong class="oe iu"> //<em class="nf"> Init Global Utils</em></strong><em class="nf"><br/> </em>app.config.globalProperties.$utils = Utils   <em class="nf">// &lt;-- set globally</em></span><span id="7ef3" class="lw lx it oe b gy ot ok l ol om"><em class="nf">app.mount</em>('#app')</span></pre><p id="e813" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们可以在任何地方访问我们的实用程序方法，只需使用以下代码:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="5eb6" class="lw lx it oe b gy oj ok l ol om"><strong class="oe iu"><em class="nf">// In template</em></strong><br/>$utils.copyToClipboard(text)</span><span id="1ce4" class="lw lx it oe b gy ot ok l ol om"><strong class="oe iu"><em class="nf">// In methods</em></strong><br/>this.$utils.copyToClipboard(text)</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4e7f" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">检测用户是在台式机上还是在移动设备上</h1><p id="0e48" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">检测用户在哪个平台上的方法经常变化。在评估了你可以做到这一点的许多方法之后，我决定用一个做得很好并且会<em class="nf">(希望是</em>)的包🤞<em class="nf"> ) </em>这些因素变化时保持更新。</p><ul class=""><li id="06f1" class="mp mq it lc b ld le lg lh lj ou ln ov lr ow lv mw mx my mz bi translated">用<strong class="lc iu"> </strong> <code class="fe ob oc od oe b">npm i vue-mobile-detection --save</code>安装<a class="ae ky" href="https://www.npmjs.com/package/vue-mobile-detection" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">vue-mobile-detection</strong></a><strong class="lc iu"/></li><li id="1995" class="mp mq it lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated">在您的<code class="fe ob oc od oe b">App.vue</code>文件中，添加一个<code class="fe ob oc od oe b">mounted()</code>挂钩，将用户平台存储在您的Vuex商店中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装App.vue时保存用户的平台</p></figure><p id="a1aa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你正在使用Vuex，你现在可以为上面的<code class="fe ob oc od oe b">$store.commit</code>创建一个变体，将值设置为<code class="fe ob oc od oe b">state</code>，然后使用一个getter在你的应用程序中的任何地方访问<code class="fe ob oc od oe b">platform</code>值。我最近在区块链的一个项目中使用了这种方法，在这个项目中，了解用户的平台以触发正确的区块链钱包(浏览器扩展钱包，或移动应用钱包)是至关重要的，它非常有效。</p><p id="78b2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="nf">注意:</em> </strong> <em class="nf">如果你没有使用Vuex，你可以用</em> <code class="fe ob oc od oe b"><em class="nf">localStorage.setItem</em></code> <em class="nf">把这个值保存在用户的localStorage中，然后用</em> <code class="fe ob oc od oe b"><em class="nf">localStorage.getItem</em></code>在你的应用中的任何地方使用它</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="7232" class="lw lx it oe b gy oj ok l ol om"><strong class="oe iu">// in App.vue inside of your <em class="nf">mounted()</em> hook:</strong><br/>const currentPlatform = this.$isMobile() ? ‘mobile’ : ‘desktop’</span><span id="096d" class="lw lx it oe b gy ot ok l ol om"><em class="nf">localStorage.setItem</em>('platform', currentPlatform)</span><span id="3001" class="lw lx it oe b gy ot ok l ol om"><strong class="oe iu"><br/>// Use it anywhere</strong><br/><em class="nf">localStorage.getItem</em>(‘platform’)</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="31a2" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">当用户按ENTER时聚焦于下一个表单输入</h1><p id="f4de" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">表单是一个巨大的皮塔饼。现有的一些软件包(我最喜欢的是<code class="fe ob oc od oe b"><a class="ae ky" href="https://vueformulate.com/" rel="noopener ugc nofollow" target="_blank">vue-formulate</a></code>)大大减少了这种情况，但是不管你使用的是什么软件包，或者你是否从头开始编写表单，这都是你的用户会喜欢的概念。</p><p id="b4b9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果用户在关注此输入时按enter，它会将光标焦点设置到以下输入框:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="917e" class="lw lx it oe b gy oj ok l ol om">&lt;input <br/> type="text"<br/> <strong class="oe iu">@keyup.enter="$event.target.nextElementSibling.focus()"</strong><br/>/&gt;</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><blockquote class="ox"><p id="9970" class="oy oz it bd pa pb pc pd pe pf pg lv dk translated">这是我从迈克尔·泰森的Vue tips时事通讯中学到的一些技巧——我强烈推荐你订阅！</p></blockquote><h1 id="f10f" class="nn lx it bd ly no ph nq mb nr pi nt me jz pj ka mh kc pk kd mk kf pl kg mn nx bi translated">动态刷新(重新加载)特定组件</h1><p id="6013" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">在很多极端情况下，组件需要在不影响其所在页面的情况下重新加载。有时您需要强制它用新属性刷新，或者因为当新属性传递给它时，您正在使用的包没有按预期更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以编程方式重新加载单个组件</p></figure><p id="bce6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当然，如果您想重新加载整个页面，也很容易:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="ad4c" class="lw lx it oe b gy oj ok l ol om"><strong class="oe iu"><em class="nf">// Using traditional JS </em></strong><em class="nf">(If you don't have access to $router)<br/>window.location.reload</em>()<br/></span><span id="3e78" class="lw lx it oe b gy ot ok l ol om"><strong class="oe iu">// Using vue-router</strong><br/>this.$router.go(0)</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d021" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">从父组件调用子组件的方法</h1><p id="2abe" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">通常，父组件通过<code class="fe ob oc od oe b">props</code>事件将数据发送给子组件，子组件通过<code class="fe ob oc od oe b">$emit</code>事件将数据发送给父组件。但是有时我们可能希望从只存在于子组件中的父组件中触发方法。听起来很复杂？这不是和Vue <code class="fe ob oc od oe b">refs</code>提供了完美的解决方案吗！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b4ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里有一个更清楚的例子，以防上面说的太简短:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/b8533888c90b6b72c1b2ac118d69d920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ourRvbyhOELvu9c-alK3zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用<strong class="bd kz"> ref </strong>设置子组件</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/af44c7092adf0876255d41554b6f1580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aF7ZZvOllUuo7IcL2SgMMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<strong class="bd kz"> this访问子方法。$refs </strong></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/242ef4163740877c1d0a037205c0d28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMgFzcWPIU5VOZMYeIq9eA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅存在于子组件上的方法</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b9b0" class="nn lx it bd ly no np nq mb nr ns nt me jz nu ka mh kc nv kd mk kf nw kg mn nx bi translated">验证组件属性</h1><p id="22c7" class="pw-post-body-paragraph la lb it lc b ld mr ju lf lg ms jx li lj ny ll lm ln nz lp lq lr oa lt lu lv im bi translated">验证你的道具有两个作用。它会告诉你，如果你传递了一个不正确的道具给一个组件，它会让你很容易看到这个组件被设计成接受什么选项。您可以附加任何您想要的逻辑来创建自定义属性验证器，但是下面的情况可能是您使用最多的(验证字符串选项):</p><p id="7437" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下面的例子中，我创建了一个自定义的<code class="fe ob oc od oe b">Button</code>组件，我在我的应用程序中使用它。注意，我有<code class="fe ob oc od oe b">variant</code>和<code class="fe ob oc od oe b">type</code>道具。</p><p id="7b81" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">注意:</strong> <em class="nf">对于自定义按钮组件，请务必不要使用</em> <code class="fe ob oc od oe b"><em class="nf">type</em></code> <em class="nf">作为道具，因为</em> <code class="fe ob oc od oe b"><em class="nf">variant</em></code> <em class="nf">已经是HTML按钮上的一个东西，应该是一个单独的道具来处理表单</em><code class="fe ob oc od oe b"><em class="nf">submit</em></code><strong class="lc iu"><em class="nf"/></strong><em class="nf">和</em> <code class="fe ob oc od oe b"><em class="nf">reset</em></code> <em class="nf">之类的东西。</em></p><p id="3f66" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于这些道具中的每一个，我声明我只想接受几个不同的选项。如果我传递了错误的东西，这将帮助我调试我的代码。它还将帮助其他人查看我的代码，以了解该组件可以接受哪些选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="29f8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我希望你喜欢这些提示，并发现它们很有用。如果你有自己的高级技巧，请在评论中分享，或者询问关于使用上述概念的任何其他问题。我很乐意帮助你。</p><p id="4d81" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">哦，如果你想把你的Vue应用本地化成多种语言，我有一个简化的工作流程，可以在一个小时内完成——不，我说真的！</p><p id="9c0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请点击这里查看:</p><div class="pn po gp gr pp pq"><a rel="noopener  ugc nofollow" target="_blank" href="/vue-i18n-ultimate-guide-fb3d9db48c94"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">仅用1小时翻译任何Vue.js应用程序</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">本地化任何规模应用程序的终极自动化工作流程</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">更好的编程</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ks pq"/></div></div></a></div></div></div>    
</body>
</html>