<html>
<head>
<title>How To Write Flexible JavaScript Code With Pure Functional Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用纯函数包装器编写灵活的JavaScript代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-flexible-javascript-code-with-pure-functional-wrappers-ad1cb39b2630?source=collection_archive---------4-----------------------#2021-09-09">https://betterprogramming.pub/how-to-write-flexible-javascript-code-with-pure-functional-wrappers-ad1cb39b2630?source=collection_archive---------4-----------------------#2021-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">和测试，而不改变现有的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e335250813efb90ae29a635ec63325f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCMyTb0pxMj4OWsmkw3aZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">食物矢量由<a class="ae ky" href="https://www.freepik.com/free-vector/kawaii-fast-food-cute-burrito-sauces-illustration_5769151.htm#page=1&amp;query=Burrito&amp;position=20" rel="noopener ugc nofollow" target="_blank"> gstudioimagen </a>创建，<a class="ae ky" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">作者</a>编辑</p></figure><p id="1151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用高阶函数(HOF ),可以编写更具声明性、灵活性和紧凑性的代码。</p><p id="4905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发的一个规则是<em class="lv">不要碰任何工作上的东西</em>。如果您要增强现有的功能，您应该设计一个包装类。但是要注意，创建这样的类会带来新的问题，比如不灵活、副作用，甚至是约束。</p><p id="a2d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该考虑编写适当的函数包装函数，以获得干净的包装函数，从而获得更高的代码灵活性和更好的测试能力。</p><h1 id="952c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一些包装用例</h1><p id="d522" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">包装一个函数意味着保持原来的函数不变。已经给定的代码可能会影响其他对象，如果您更改它，可能会引起连锁反应。—你也可以说包装器是装饰器。</p><p id="594b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些使用案例:</p><ol class=""><li id="79c8" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">向函数添加日志记录</li><li id="a88a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">从函数中获取计时信息</li><li id="d19b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">使用缓存(<em class="lv">内存化</em>)来提高函数的性能</li></ol></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="6612" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">经典实现—记录器</h1><p id="93a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可能已经多次遇到过这种用例，是的，除了日志记录，您可以只使用断点。但是这是关于更深层次的理解，所以你可以采用这种技术。</p><p id="2b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不使用包装器，就必须修改函数的代码——入口和出口，以产生一些日志输出。</p><p id="5585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是您的原始代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更进一步，没有包装意味着您必须添加一个<code class="fe nv nw nx ny b">auxiliaryVar</code>来存储您想要记录和返回的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果函数有几个<code class="fe nv nw nx ny b">return</code>语句，考虑一下开销。如果您只是在运行中计算返回表达式，您将需要一个辅助变量来捕获该值。</p><p id="e4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，必须有一种更好的方法，也是一种不容易发生事故且不违反以下规则的技术:</p><p id="33a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有用…不要碰它。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="4d8d" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">功能实现—记录器</h1><p id="bf1c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，你有一个函数，它实现了某种功能，你想知道它的I/O——输入的参数和输出的参数。</p><p id="8c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写一个具有单个参数的高阶函数(原始函数)，并返回一个新函数，该函数将依次执行以下操作:</p><ol class=""><li id="b64c" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">记录收到的参数</li><li id="3bd5" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">调用原始函数，捕捉其返回值</li><li id="e7e3" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">记录该值</li><li id="ca52" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">把它还给呼叫者</li></ol><p id="95fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现此过程，您将得出以下可能的代码作为解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx ny b">loggingWrap()</code>返回的函数具有以下特点:</p><ol class=""><li id="0cef" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe nv nw nx ny b">console.log()</code>显示原始函数的名称及其参数。</li><li id="cc37" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">调用原始函数(<code class="fe nv nw nx ny b">fn()</code>)，并存储返回值。</li><li id="1f21" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">第二行<code class="fe nv nw nx ny b">console.log()</code>显示了函数名及其返回值。</li><li id="7bfc" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">返回<code class="fe nv nw nx ny b">fn()</code>计算的值。</li></ol><blockquote class="nz oa ob"><p id="255e" class="kz la lv lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">提示:对于节点应用程序，您可能会选择更好的日志记录方式。大概用的是<a class="ae ky" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> Winston </a>(通用日志器)<a class="ae ky" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank"> Morgan </a>(适合http-logging)，或者<a class="ae ky" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank"> Bunyan </a>(专门用于JSON日志记录)。我的重点在于向你展示如何包装原始函数。使用这些库所需的改动很小，您将在本文末尾看到这一点。</p></blockquote><p id="0574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所示的方法适用于您的大多数函数。一个你可能已经想到的问题:</p><p id="b790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抛出异常的函数会给这种光明的包装技术带来黑暗吗？</p><h1 id="4dcb" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">例外注定</h1><p id="d0a9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了检查这种情况，我们应该稍微增强一下您的日志功能。当您的原始函数抛出异常时，<code class="fe nv nw nx ny b">try/catch</code>块是一个更好的想法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您的包装函数是否抛出错误，这一更改都会产生一个适当的日志记录语句。每次你都会收到一条消息，告诉你一切顺利或不顺利。除此之外，还会再次抛出错误进行处理。</p><p id="8edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:为了获得更好的日志输出，您可以添加日期和时间。增强列出参数的方式，等等。</p><p id="ba49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，这个实现仍然不是完美的。它有一个重要的缺陷。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="83a8" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">创建一个纯包装</h1><p id="76a1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">提到纯功能意味着没有副作用。<code class="fe nv nw nx ny b">Console.log()</code>就是这样的副作用。</p><p id="629f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样使用固定语句会使您失去灵活性——您无法选择另一种形式的日志记录——并使测试变得更加复杂。</p><p id="d90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你打算怎么测试它？刺探<code class="fe nv nw nx ny b">console.log()</code>方法？</p><p id="5362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也不是很干净。了解特定函数的内部行为对于测试它是必不可少的。事实并非如此。你想设计你的测试。你想要的是黑盒测试。</p><p id="1308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查以下测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该测试将向您展示<code class="fe nv nw nx ny b">loggingWrap()</code>确实如预期的那样运行。第一个验证日志记录是否被正确调用。第二个测试检查错误抛出，以验证产生了正确的输出。因此，这是对一段工作代码的有效解决方案。</p><p id="e721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管它没有解决灵活性的缺乏，但是您应该将日志记录函数作为参数传递给包装函数。如果你有或者希望的话，导致随需应变的变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="26e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不传递任何东西，默认的包装器将产生与版本<code class="fe nv nw nx ny b">loggingWrapCatcher</code>相同的结果。但是您现在能够提供不同的日志记录系统。简单地将它存储到一个变量中，并将其传递给包装函数。</p><p id="96f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样写函数，我们可以利用存根。测试的代码几乎和以前一样，但是因为您可以使用一个存根(stub)，没有提供功能或副作用，所以总体来说更安全。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，最初调用的真正函数<code class="fe nv nw nx ny b">console.log()</code>不会造成任何伤害，但情况并不总是如此，所以建议使用存根。</p><p id="469f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新测试的工作方式和以前的一样，但是使用并检查<code class="fe nv nw nx ny b">stubby.logger</code>而不是处理原来的<code class="fe nv nw nx ny b">console.log</code>调用。这为您带来了更多的灵活性，因为您不再需要监视特定的硬编码函数——一种通用的方法。</p><p id="bc3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它避免了所有因副作用而可能出现的问题，因此更加清洁和安全。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="cdaf" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">结论</h1><p id="3842" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我想说的是，当你使用功能技术时，永远记住，如果你正在使你自己的工作复杂化，那么你一定是做错了。</p><p id="0473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe nv nw nx ny b">loggingWrap()</code>是不纯的，这应该让你警惕了。</p><p id="9201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会认为代码的简单性不足以决定它是否值得修复。您甚至可以不经过测试就完成，并且您不需要能够改变日志产生的方式。但迟早你会对那种决定后悔的。</p><p id="c61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该总是尝试使用更清洁的解决方案。</p><p id="544f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这种方式通过添加一个包装类为您带来了高度的灵活性，并且您可以使用任何您想要的记录器——记录器代表了您想要的任何更改。</p><p id="6321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您现在已经完成了对任何期望的实现的测试。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="4896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取26份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！ </p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> Arnold Code Academy 26 Web开发人员备忘单</a></p></figure><h1 id="1304" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><ul class=""><li id="6157" class="mt mu it lb b lc mo lf mp li og lm oh lq oi lu oj mz na nb bi translated"><a class="ae ky" href="https://www.codecademy.com/learn/game-dev-learn-javascript-higher-order-functions-and-iterators/modules/game-dev-learn-javascript-iterators/cheatsheet" rel="noopener ugc nofollow" target="_blank">学习JavaScript:高阶函数和迭代器</a></li><li id="a493" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oj mz na nb bi translated"><a class="ae ky" href="https://www.toptal.com/software/declarative-programming" rel="noopener ugc nofollow" target="_blank">声明式编程:它是真的吗？</a></li><li id="2f22" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oj mz na nb bi translated"><a class="ae ky" href="https://dev.to/deogadkarravina/javascript-predicate-and-uses-8pl" rel="noopener ugc nofollow" target="_blank"> Javascript:谓词</a></li><li id="c095" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oj mz na nb bi translated"><a class="ae ky" href="https://amzn.to/3ziF8cL" rel="noopener ugc nofollow" target="_blank">掌握JavaScript函数式编程</a></li></ul></div></div>    
</body>
</html>