<html>
<head>
<title>Remove Duplicates From an Array: Get Unique Values in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数组中删除重复项:在Swift中获取唯一值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/remove-duplicates-from-an-array-get-unique-values-in-swift-7a477ef89260?source=collection_archive---------11-----------------------#2020-01-28">https://betterprogramming.pub/remove-duplicates-from-an-array-get-unique-values-in-swift-7a477ef89260?source=collection_archive---------11-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">选择最适合您需求的性能选项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/008ef39542fddffcafe66fb5502d82ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJkUqmKF2Bg1MvHq9MYVKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图:<a class="ae ky" href="https://www.seobility.net/en/wiki/Duplicate_Content" rel="noopener ugc nofollow" target="_blank">重复内容</a> —作者:Seobility —许可:<a class="ae ky" href="https://www.seobility.net/en/wiki/Creative_Commons_License_BY-SA_4.0" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0 </a></p></figure><p id="170a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除重复项以从数组中获取唯一值是一项常见的任务。像Ruby这样的语言有内置的方法，比如<code class="fe lv lw lx ly b">uniq</code>，但是在Swift中，我们必须自己创建这样的方法。标准库没有提供一个简单的方法来做到这一点。</p><p id="56f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以达到同样的结果，每种方法都有各自的优缺点。让我们回顾一下，看看哪些方法最适合您的用例。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="04b0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">默认情况下，使用集合移除重复项</h1><p id="ab37" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始深入研究从数组中删除重复项的扩展之前，最好先了解一下Swift中的<code class="fe lv lw lx ly b">set</code>。默认情况下，一个<code class="fe lv lw lx ly b">set</code>只包含唯一的值，可以实现你想要的结果。</p><p id="9c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现以下情况，请选择<code class="fe lv lw lx ly b">set</code>:</p><ul class=""><li id="250f" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">顺序并不重要</li><li id="090f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">默认情况下，您喜欢拥有独特的元素</li></ul><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="9dad" class="nv mh it ly b gy nw nx l ny nz">let array: [Int] = [1, 1, 1, 2, 2, 2, 3, 3, 3]<br/>let set: Set&lt;Int&gt; = [1, 1, 1, 2, 2, 2, 3, 3, 3]<br/><br/>print(array) // prints: [1, 1, 1, 2, 2, 2, 3, 3, 3]<br/>print(set)   // prints: [2, 3, 1]</span></pre><p id="fbdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决定是使用<code class="fe lv lw lx ly b">set</code>还是数组更像是一个代码设计决策。s还具有更高性能的优势，这使它们成为解决唯一性问题的良好候选。你可以在我的<a class="ae ky" href="https://www.avanderlee.com/swift/array-vs-set-differences-explained/" rel="noopener ugc nofollow" target="_blank">博客</a>中读到更多关于<code class="fe lv lw lx ly b">set</code>和<code class="fe lv lw lx ly b">array</code>的区别。</p><p id="fbf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要太多细节上的区别，知道一个<code class="fe lv lw lx ly b">set</code>没有维持顺序是很好的。如果保持秩序对你来说很重要，你可能不想用<code class="fe lv lw lx ly b">set</code>。你可以使用<code class="fe lv lw lx ly b">NSOrderedSet</code>，但是这个类没有给你类型完成，你必须使用<code class="fe lv lw lx ly b">Any</code>实例。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e31e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用扩展名从数组中移除重复元素</h1><p id="3c1f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当元素的顺序很重要时，我们可以继续使用数组，并通过使用自定义扩展来获得唯一的值。</p><p id="3403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现以下情况，请选择<code class="fe lv lw lx ly b">array</code>:</p><ul class=""><li id="7100" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">秩序很重要</li><li id="c384" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">你不能轻易切换到<code class="fe lv lw lx ly b">set</code></li></ul><p id="acfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须创建一个扩展来过滤掉重复的元素。在创建扩展时，记住性能是很重要的，因为我们很容易以二次时间复杂度<code class="fe lv lw lx ly b">o(N²)</code>结束。简而言之，这意味着你拥有的元素越多，性能下降的就越多。</p><p id="c753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面这段代码依赖于<code class="fe lv lw lx ly b">Hashable</code>协议来匹配元素，并且具有线性时间复杂度<code class="fe lv lw lx ly b">o(N)</code>。这意味着3个元素需要3次迭代，10个元素需要10次迭代，依此类推。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="58b0" class="nv mh it ly b gy nw nx l ny nz">extension Sequence where Iterator.Element: Hashable {<br/>    func unique() -&gt; [Iterator.Element] {<br/>        var seen: Set&lt;Iterator.Element&gt; = []<br/>        return filter { seen.insert($0).inserted }<br/>    }<br/>}<br/><br/>print(array.unique()) // prints: [1, 2, 3]</span></pre><p id="0df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们来分解一下这个<code class="fe lv lw lx ly b">unique()</code>方法:</p><ul class=""><li id="7131" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">我们创建一个<code class="fe lv lw lx ly b">set</code>来跟踪看到的物体</li><li id="ddec" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">过滤器用于迭代所有对象</li><li id="4d77" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">insert(_:)</code>方法返回一个包含插入布尔值的元组，如果对象被插入，则该元组被设置为<code class="fe lv lw lx ly b">true</code>,否则被设置为<code class="fe lv lw lx ly b">false</code></li><li id="1f26" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">插入的布尔值用来过滤掉数组中的重复项</li></ul><p id="92ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果是一个具有相同顺序但没有重复元素的数组。唯一的缺点是您的元素需要符合<code class="fe lv lw lx ly b">Hashable</code>协议，但这应该不是什么大问题。事实上，标准库中的许多类型已经符合该协议，如字符串、整数和布尔值。</p><p id="4e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Hashable</code>协议用于确定一个元素是否等于一个现有的对象，因此需要获得唯一的值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b2ce" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e337" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你想获得一个系列的独特元素时，你可以选择一个<code class="fe lv lw lx ly b">set</code>或者一个<code class="fe lv lw lx ly b">array</code>的扩展。</p><ul class=""><li id="1407" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">如果顺序不重要，请选择<code class="fe lv lw lx ly b">set</code></li><li id="7a54" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">保持顺序，并在数组上提取具有扩展名的唯一元素</li></ul></div></div>    
</body>
</html>