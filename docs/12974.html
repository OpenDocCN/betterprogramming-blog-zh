<html>
<head>
<title>Creating an NFT Marketplace With Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个稳健的NFT市场</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-an-nft-marketplace-solidity-2323abca6346?source=collection_archive---------4-----------------------#2022-07-16">https://betterprogramming.pub/creating-an-nft-marketplace-solidity-2323abca6346?source=collection_archive---------4-----------------------#2022-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d8a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">只用了200行代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/400eb959a38471f6943cc0421c06c91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbbcIMaBLeTEgl6rOs5etA.png"/></div></div></figure><blockquote class="kr ks kt"><p id="b0b9" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Web 3.0 </strong>有潜力永远改变我们所知的互联网<em class="iq">。<br/> —阿德里安(精通JavaScript】</em></p></blockquote><p id="b2c3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这篇博客中，我将解释可靠性以及如何用200行代码创建一个NFT市场。</p><p id="31a2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">然而，这是一份聪明的合同。<strong class="kx ir"/>智能合约可以定义为一个实体，它可以发送和接收货币(<em class="kw"> crypto </em>)，而不仅仅是网络上的用户。这是一段管理你的钱以及你如何引导它执行特定功能的代码——因此，是区块链上的程序！</p><p id="ba1d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这些程序一旦部署就不能修改，并且是最终版本。我们不要深入讨论智能合约的许多有益方面，因为有许多方面，而且时间是相对的。</p><h1 id="aebd" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">从应用程序的演示开始—</h1><ol class=""><li id="9f7d" class="mm mn iq kx b ky mo lb mp lr mq ls mr lt ms lq mt mu mv mw bi translated">连接我们的<code class="fe mx my mz na b">metamask</code> <strong class="kx ir"> </strong>钱包(<em class="kw">即使你没有metamask帐户或对此一无所知，你也可以继续阅读此博客:| </em>，<em class="kw">只要假设它是一个在线钱包</em></li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e31b13055529938f04f107aa8deaef15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*qqnkGk-_PKGNF2w8BTtcow.png"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">与metamask钱包连接</p></figure><p id="641f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">2.创建一个NFT</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/1bd008b0378627d2267c727653983174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ibI-2qAX9pkYdAqLHOnDg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">创建一个NFT页面(缩放50%，以适应此处)</p></figure><p id="a3d3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">上传您的图像并填写详细信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b776309b55413143b5d901e5f3b43936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_FXto_ps3Qi4PkT8m2U5A.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">metamask确认将NFT上市。</p></figure><p id="f4bc" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">你将向市场的所有者发送0.00025以太作为刊登费。上图是对交易的批准，<em class="kw">把它想象成输入您的PIN码或在线交易的OTP。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/5e63c630ab6edc3898ac0f1a1a00056b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axoB9Mbzkx6Edhrz5oLmMg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">你的图像现在在市场上，瞧！</p></figure><p id="9f33" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">3.我们买下你列出的那辆NFT吧。现在，我们将改变我们的metamask帐户，因为让我们现实一点，我们不能购买自己的NFT。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d0c4bdde1a249e8c07195b33d914a4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*dulXHXf41tUs7K4Vykzl9A.png"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">切换元掩码上的帐户。</p></figure><p id="9f14" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">4.买下NFT。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/f08138955aee666a1e73245ac458ce36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJdD3cd6429G4R_VNPcAbA.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">NFT详情页面。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/236c3ef17936efd650fab609020c9102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-8aY8J1tWYb6dUUeZNILg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">结账确认</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/dc6cc29312ef1b4e4aa1d9fafb7281b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tVxvpzhk3eAK-CVaaXzrg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">购买NFT的确认。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/abf6ce5641686e83022ce5a896b67976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlh5qlQwbAxqJJo6YW5C3A.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">现在，您可以在NFT详细信息页面查看您是否已经购买了NFT。</p></figure><p id="73a2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">既然演示已经结束，我们可以从solidity代码开始了。</p><h1 id="a8f2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">坚固性代码</strong></h1><p id="57b6" class="pw-post-body-paragraph ku kv iq kx b ky mo jr la lb mp ju ld lr no lg lh ls np lk ll lt nq lo lp lq ij bi translated">对于初学者来说，如果你懂JavaScript，那么你会很容易理解solidity的代码。以太坊的智能合约是用solidity编程的，solidity是一种面向对象的高级语言。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/fc0f61bf3f891860c5ac7500b2c8f34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVIZlWG8tc14Kxat3QoiFg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">开始代码。</p></figure><p id="3ecb" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">让我们一行一行地检查这段代码:</p><p id="4f43" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">第2行——在写合同之前，必须提到可靠性版本。这里我们将使用版本0.8.4。</p><p id="77a9" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">第4、5、6行——就像任何其他语言一样，这里我们导入了其他契约，我们用它们来构建我们的代码，把它们想象成库。<br/> <code class="fe mx my mz na b">Counters.sol</code>:保持一个——(将进一步讨论)的计数器。<br/> <code class="fe mx my mz na b">ERC721.sol</code>:非功能性翻译相关合同的写作标准。<br/> <code class="fe mx my mz na b">ERC721URIStorage.sol</code>:为了继承<code class="fe mx my mz na b">_tokenURI</code>，应该解析成一个JSON文档</p><p id="8c22" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="kw">第8行</em> </strong> —定义继承<code class="fe mx my mz na b">ERC721URIStorage</code>(另一个合同)的合同<code class="fe mx my mz na b">NFTMarketplace</code> <strong class="kx ir"> </strong>，我们不继承ERC721.sol，因为<code class="fe mx my mz na b">ERC721URIStorage</code>已经继承了。这些合同是由。</p><p id="e631" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">using Counters for Counters.Counter;</code></p><p id="694d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">初始化我们继承的计数器。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="1adb" class="nx lv iq na b gy ny nz l oa ob">Counters.Counter private _tokenIds; <br/>Counters.Counter private _itemsSold;</span></pre><p id="5984" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这里，契约记录了两个变量tokenIds和itemsSold。每当我们调用<code class="fe mx my mz na b">_tokenIds.increment();</code>时，<code class="fe mx my mz na b">_tokenIds</code>的值将从1 → 2递增，对于<code class="fe mx my mz na b">_itemsSold</code>也是如此。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="d3f8" class="nx lv iq na b gy ny nz l oa ob">uint256 listingPrice = 0.00025 ether;</span></pre><p id="15d2" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">指定上市价格，每当有人想创建自己的NFT，并在市场上列出，他们支付上市费即。0.00025 ETH。这里的<code class="fe mx my mz na b">uint256 </code>是一种数据类型。u →无符号，int →基数为256的整数。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="c200" class="nx lv iq na b gy ny nz l oa ob">address payable owner;</span></pre><p id="7cf0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">称为所有者的地址类型变量(只接受地址)。这里定义为<code class="fe mx my mz na b">payable</code>，表示该地址可以参与交易。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="bf3b" class="nx lv iq na b gy ny nz l oa ob">constructor() ERC721(“Metaverse Tokens”, “METT”) {<br/>   owner = payable(<em class="kw">msg.sender</em>);<br/>}</span></pre><p id="cddc" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">每当调用我们的契约时，都会调用一个构造函数。在我们的例子中，我们需要调用两个构造函数——我们的契约和ERC721.sol契约，因为我们从它继承了<strong class="kx ir"> </strong>。</p><p id="42f7" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这个构造函数中，我们告诉契约，所有者是调用契约的人，但是在区块链中，我们通过地址来传递，从而得到发送者的地址，<code class="fe mx my mz na b">msg.sender </code>是一个内置参数，接受调用/调用契约的帐户的地址。</p><p id="cd20" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">长话短说，我们通过定义owner变量来通知契约我们(<code class="fe mx my mz na b"><em class="kw">msg.sender</em></code>)是所有者！当我们部署我们的契约时，它接收我们的地址，所以只有我们拥有所有权。咳……</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/57e1437b2764f904ad98b4bc5cd920d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcJSiI1UAAFOF3JonhopVg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">在调用ERC721的构造函数时，我们需要调用它，因为它想被ie调用。它需要的参数。</p></figure><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="ed8c" class="nx lv iq na b gy ny nz l oa ob">struct MarketItem {<br/>   uint256 tokenId;<br/>   address payable seller;<br/>   address payable owner;<br/>   uint256 price;<br/>   bool sold;<br/>}</span></pre><p id="d0b5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">创建结构市场项以存储各种类型的数据。</p><ul class=""><li id="b27e" class="mm mn iq kx b ky kz lb lc lr od ls oe lt of lq og mu mv mw bi translated"><code class="fe mx my mz na b">tokenID</code> <strong class="kx ir"> </strong> →参与销售的代币Id</li><li id="fed5" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">seller </code> →存储卖家地址</li><li id="a132" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">owner </code> →存储所有者的地址(如果创建了一个NFT，最初它属于市场，即合同地址)</li><li id="6d65" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">price </code>→NFT的价格</li><li id="16b2" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">sold </code> →布尔值(真/假)表示NFT是否售出。</li></ul><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="b8f9" class="nx lv iq na b gy ny nz l oa ob">mapping(uint256 =&gt; MarketItem) private idToMarketItem;</span></pre><p id="d9a9" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">mapping</code> <strong class="kx ir"> </strong> —实性的另一种数据类型。它存储一个键(一种数据类型)及其对应的值(也是一种数据类型)，因此是键-值对。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="75ce" class="nx lv iq na b gy ny nz l oa ob">mapping ( &lt;data-type&gt; =&gt; &lt;data-type/structure&gt;/ ) visibility name;</span></pre><p id="9b4e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这种情况下，我们将一个<code class="fe mx my mz na b">uint256 </code>数据类型映射到这里的<code class="fe mx my mz na b">struct MarketItem.</code>，可见性是私有的，这意味着它只能从契约内部调用，而不能从外部调用。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="2d7d" class="nx lv iq na b gy ny nz l oa ob">function updateListingPrice(uint _listingPrice) public payable {<br/>     require(owner == <em class="kw">msg.sender</em>);<br/>     listingPrice = _listingPrice;<br/>}</span><span id="83cd" class="nx lv iq na b gy om nz l oa ob">function getListingPrice() public view returns (uint256) {<br/>     return listingPrice;<br/>}</span></pre><p id="c59d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">好吧，让我们加快速度。</p><ul class=""><li id="cf28" class="mm mn iq kx b ky kz lb lc lr od ls oe lt of lq og mu mv mw bi translated"><code class="fe mx my mz na b">updateListingPrice()</code> <strong class="kx ir"> </strong> —接受一个uint → <code class="fe mx my mz na b">_listingPrice</code>作为参数，并更新当前的列表价格。<br/> <code class="fe mx my mz na b">getListingPrice()</code> <strong class="kx ir"> </strong> —返回合约当前挂牌价的返回函数。</li></ul><p id="af2c" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这里，require是一个在其下的代码运行之前运行的条件。所以理论上，如果除了所有者之外的其他人调用上述函数，它就不会运行。</p><p id="a866" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">正在绕道…</p><p id="e54a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">你一定想知道什么是私有的，公共的，等等。是。</p><ul class=""><li id="f393" class="mm mn iq kx b ky kz lb lc lr od ls oe lt of lq og mu mv mw bi translated">public、private、internal、external →这些只是给予每个函数/变量的可见性类型，告诉契约谁可以调用这些函数/变量以及从哪里调用。</li><li id="b8e7" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">public</code> →谁都可以叫。</li><li id="5b04" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">private</code> →只能在合同内调用，不能由合同外的任何人调用。</li><li id="6ed1" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">external</code> →可以由继承具有外部可见性的函数的契约调用。</li><li id="c201" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b">internal (default )</code>→只能在声明它们的合同中访问，也可以从派生合同中访问。</li></ul><p id="b27d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">继续讨论合同…</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="0aca" class="nx lv iq na b gy ny nz l oa ob">function createToken(string memory tokenURI, uint256 price) public                                                                                                                                       payable returns (uint) {</span><span id="4936" class="nx lv iq na b gy om nz l oa ob">   _tokenIds.<strong class="na ir">increment</strong>();<br/>   uint256 newTokenId = _tokenIds.<strong class="na ir">current</strong>();<br/>   <strong class="na ir">_mint</strong>(<em class="kw">msg.sender</em>, newTokenId);<br/>   <strong class="na ir">_setTokenURI</strong>(newTokenId, tokenURI);<br/>   <strong class="na ir">createMarketItem</strong>(newTokenId, price);<br/>   return newTokenId;</span><span id="b736" class="nx lv iq na b gy om nz l oa ob">}</span></pre><p id="b35f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">如何在JavaScript中调用该函数:</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="a06f" class="nx lv iq na b gy ny nz l oa ob"><strong class="na ir">createToken</strong>(url, price, { value: listingPrice.toString() })</span></pre><ul class=""><li id="5ea6" class="mm mn iq kx b ky kz lb lc lr od ls oe lt of lq og mu mv mw bi translated"><code class="fe mx my mz na b">_tokenIds.increment()</code> —将合同中<code class="fe mx my mz na b">_tokenIds</code>的值增加1。</li><li id="01ec" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b"><strong class="kx ir">uint256 newTokenId = _tokenIds.current()</strong></code> —将合同中<code class="fe mx my mz na b">_tokenIds</code>的当前值存储到变量<code class="fe mx my mz na b">newTokenId</code>中。</li><li id="1455" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><code class="fe mx my mz na b"><strong class="kx ir">_mint(msg.sender, newTokenId)</strong></code> <strong class="kx ir"> — </strong>这个<code class="fe mx my mz na b">_mint()</code>函数继承自ERC721.sol契约。这是用来铸造一个新的合同和区块链令牌。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/fc66a93632aa40d154f3f4aebe8980db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RctjFs6C5YvRXucDcm9vw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">ERC721.sol中的_mint函数</p></figure><p id="1105" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b"><strong class="kx ir">_setTokenURI</strong>(newTokenId, tokenURI)</code> —这个<code class="fe mx my mz na b">_setTokenURI()</code>函数也继承自ERC721URIStorage.sol契约。这用于设置令牌URI，并检查令牌是否已经存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/7545181bd9b0fdd8d410d004de3ad85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4p7SDT7Qk_thPkTl1211Lw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">ERC721URIStorage.sol合同中的_setTokenURI函数</p></figure><p id="8f66" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">createMarketItem(newTokenId, price)</code> —这是合同内的功能，接下来会解释。<br/> <code class="fe mx my mz na b">return newTokenId </code> —返回新的令牌ID。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/687abed053a949dcdaa4ffac18ae058b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1H8eQMTuZduLupMsjEAmQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">概述NFT是如何铸造的。</p></figure><p id="91e5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">最后，该函数将0.00025 ETH(挂牌费)作为挂牌价格转移到合同中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8e2e80fcd02c5ccb3d6e966e62486112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0vcjEnNQPrnvkvUiAY8mA.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">截图自goerli.etherscan.io</p></figure><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="787d" class="nx lv iq na b gy ny nz l oa ob">function createMarketItem(uint256 tokenId, uint256 price) private {</span><span id="5925" class="nx lv iq na b gy om nz l oa ob"><strong class="na ir">require</strong>(price &gt; 0, “Price must be at least 1 wei”);</span><span id="3235" class="nx lv iq na b gy om nz l oa ob"><strong class="na ir">require</strong>(<em class="kw">msg</em>.value == listingPrice);</span><span id="b463" class="nx lv iq na b gy om nz l oa ob"><strong class="na ir">idToMarketItem</strong>[<strong class="na ir">tokenId</strong>] = <strong class="na ir">MarketItem</strong>(tokenId,payable(<em class="kw">msg.sender</em>),payable(address(<em class="kw">this</em>)),price,false);</span><span id="59ab" class="nx lv iq na b gy om nz l oa ob">_transfer(<em class="kw">msg.sender</em>, address(<em class="kw">this</em>), tokenId);</span><span id="b6ce" class="nx lv iq na b gy om nz l oa ob"><strong class="na ir">emit</strong>  MarketItemCreated( tokenId , <em class="kw">msg.sender</em>, address(<em class="kw">this</em>),price,false);</span><span id="740d" class="nx lv iq na b gy om nz l oa ob">}</span></pre><p id="5ac1" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">上面的函数由<code class="fe mx my mz na b">createToken </code>函数调用，一旦一个令牌被创建，它需要在市场上，为此我们调用这个函数。注意我们在这里是如何提到可见性是私有的，这告诉契约它只能从契约内部被调用</p><p id="1b74" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">前两行检查要在市场上列出的令牌的价格是否应该大于0，以及随函数一起发送的金额是否应该正好等于列出费用。0.00025乙醚。</p><p id="5dc0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">下一行<code class="fe mx my mz na b"><strong class="kx ir">idToMarketItem</strong>[<strong class="kx ir">tokenId</strong>] = <strong class="kx ir">MarketItem </strong>(tokenId, payable(<em class="kw">msg.sender</em>) ,payable(address(<em class="kw">this</em>)),price,false)</code>，如上所述，idToMarketItem是一个映射，它将结构MarketItem映射到一个特定的键，这里是<code class="fe mx my mz na b">tokenId</code>。所以对于一个特定的令牌ID，我们有它所指向的结构。我们可以像上面提到的那样传递结构体的参数。</p><p id="263f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">payable(msg.sender) </code> —调用合同的钱包地址。<br/> <code class="fe mx my mz na b">payable(address(this))</code> —合同地址。<br/><code class="fe mx my mz na b">price </code>—NFT的价格。<br/> <code class="fe mx my mz na b">false </code> —指布尔<code class="fe mx my mz na b">sold</code>。</p><p id="1704" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">_transfer(<em class="kw">msg.sender</em>, address(<em class="kw">this</em>), tokenId);</code> —这也是一个从ERC721.sol契约继承的函数。它用来表示代币从一个地址转移到另一个地址。在这种情况下，这是从<code class="fe mx my mz na b">msg.sender</code> → <code class="fe mx my mz na b">address(this)</code>的转移。</p><p id="61a4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><code class="fe mx my mz na b">emit MarketItemCreated(tokenId,<em class="kw">msg.sender</em>,address(<em class="kw">this</em>),price,false);</code> —这发出一个事件。事件就像契约中的日志，通知是否发生了什么事情。为此，我们需要在代码中定义事件<code class="fe mx my mz na b">MarketItemCreated</code>。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="b4c4" class="nx lv iq na b gy ny nz l oa ob">event MarketItemCreated (<br/>     uint256 indexed tokenId,<br/>     address seller,<br/>     address owner,<br/>     uint256 price,<br/>     bool sold<br/>);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/24355f2d952d65bc3326ad3e9236ccd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMnDlfYBHPurQdVOlJ00nw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">在goerli.etherscan.io上创建的事件MarketItemCreated日志</p></figure><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="2d5a" class="nx lv iq na b gy ny nz l oa ob">function <strong class="na ir">resellToken</strong>(uint256 tokenId, uint256 price) public payable {<br/>     require(idToMarketItem[tokenId].owner == <em class="kw">msg.sender</em>);<br/>     require(<em class="kw">msg</em>.value == listingPrice);<br/>     idToMarketItem[tokenId].sold = false;<br/>     idToMarketItem[tokenId].price = price;<br/>     idToMarketItem[tokenId].seller = payable(<em class="kw">msg.sender</em>);<br/>     idToMarketItem[tokenId].owner = payable(address(<em class="kw">this</em>));<br/>      _itemsSold.decrement();<br/>      _transfer(<em class="kw">msg.sender</em>, address(<em class="kw">this</em>), tokenId);<br/>}</span></pre><p id="f06a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">几乎类似于<code class="fe mx my mz na b">createToken</code>函数，这个函数已经有了指定数据的IPFS URL。所以在我们的代码中，我们只是将所有者从我们的地址更改为契约的地址。除此之外，我们还提到了NTF的新价格，同时将出售的<code class="fe mx my mz na b">bool </code>改为<code class="fe mx my mz na b">false</code>。</p><p id="922c" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">最后，我们将变量<code class="fe mx my mz na b">_itemsSold</code>减1，最后，我们从我们继承的<code class="fe mx my mz na b">ERC721.sol</code>契约中调用<code class="fe mx my mz na b">_transfer </code>函数来转移所有权。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="40b9" class="nx lv iq na b gy ny nz l oa ob">function createMarketSale(uint256 tokenId) public payable {</span><span id="3704" class="nx lv iq na b gy om nz l oa ob">   uint price = idToMarketItem[tokenId].price;<br/>   address payable creator = idToMarketItem[tokenId].seller;<br/>   require(<em class="kw">msg</em>.value == price);<br/>   idToMarketItem[tokenId].owner = payable(<em class="kw">msg.sender</em>);<br/>   idToMarketItem[tokenId].sold = true;<br/>   idToMarketItem[tokenId].seller = payable(address(0));<br/>   _itemsSold.increment();<br/>   _transfer(address(<em class="kw">this</em>), <em class="kw">msg.sender</em>, tokenId);<br/>   payable(owner).transfer(listingPrice);<br/>   payable(creator).transfer(<em class="kw">msg</em>.value);</span><span id="1f3c" class="nx lv iq na b gy om nz l oa ob">}</span></pre><p id="38ce" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这个函数处理从一个地址到另一个地址的资金转移。这就产生了市场销售——当有人购买NFT时就会发生这种情况。<br/> <code class="fe mx my mz na b">.transfer()</code> —内置传输密码的功能。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="f4e9" class="nx lv iq na b gy ny nz l oa ob">function fetchMarketItems() public view returns (MarketItem[] memory) {</span><span id="0ce0" class="nx lv iq na b gy om nz l oa ob">uint itemCount = _tokenIds.current();<br/>uint unsoldItemCount = _tokenIds.current() - _itemsSold.current();<br/>uint currentIndex = 0;<br/>MarketItem[] memory items = new MarketItem[](unsoldItemCount);<br/>for (uint i = 0; i &lt; itemCount; i++) <br/>    {<br/>      if (idToMarketItem[i + 1].owner == address(<em class="kw">this</em>)) <br/>       {<br/>         uint currentId = i + 1;<br/>         MarketItem storage currentItem = idToMarketItem[currentId];<br/>         items[currentIndex] = currentItem;<br/>          currentIndex += 1;<br/>       }<br/>    }<br/>return items;</span><span id="c937" class="nx lv iq na b gy om nz l oa ob">}</span></pre><p id="ef48" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">在这个返回函数中，我们获取合同当前拥有的NFT—<code class="fe mx my mz na b"> idToMarketItem[i + 1].owner == address(<em class="kw">this</em>)</code>。</p><p id="73e6" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">为此，我们首先创建一个名为<code class="fe mx my mz na b">items</code>的临时数组<code class="fe mx my mz na b">MarketItem </code>，并给它一个固定的大小<code class="fe mx my mz na b">unsoldItemCount</code>，这是通过用合同中当前售出的商品数量<code class="fe mx my mz na b">_itemsSold.current()</code>减去当前索引<code class="fe mx my mz na b">_tokenIds</code>得到的。</p><p id="1948" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">然后，我们遍历该数组，并应用条件来检查NFT的所有者是否是合同，如果是，则将NFT的详细信息推送到创建的临时数组中(<code class="fe mx my mz na b">items</code>)。最后返回数组<code class="fe mx my mz na b">items</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/a52d077d33d992b1e2497c2774db2549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYSZiRLK8ppDPVblxrDE0g.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">市场项目</p></figure><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="a567" class="nx lv iq na b gy ny nz l oa ob">function fetchMyNFTs() public view returns (MarketItem[] memory) {</span><span id="3bab" class="nx lv iq na b gy om nz l oa ob">uint totalItemCount = _tokenIds.current();<br/>uint itemCount = 0;<br/>uint currentIndex = 0;<br/>for (uint i = 0; i &lt; totalItemCount; i++) {<br/>    <em class="kw">// check if nft is mine<br/>    </em>if (idToMarketItem[i + 1].owner == <em class="kw">msg.sender</em>) <br/>    {<br/>     itemCount += 1;<br/>    }<br/>  }</span><span id="d1d6" class="nx lv iq na b gy om nz l oa ob">MarketItem[] memory items = new MarketItem[](itemCount);</span><span id="c54a" class="nx lv iq na b gy om nz l oa ob">for (uint i = 0; i &lt; totalItemCount; i++) {<br/>     if (idToMarketItem[i + 1].owner == <em class="kw">msg.sender</em>) <br/>     {<br/>      uint currentId = i + 1;<br/>      MarketItem storage currentItem = idToMarketItem[currentId];<br/>      items[currentIndex] = currentItem;<br/>      currentIndex += 1;<br/>      }<br/>    }<br/>return items;<br/>}</span></pre><p id="9d7b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">类似于上面的函数，这里我们增加一个额外的步骤，即。为了找到我们拥有的NFT的数量<strong class="kx ir"> </strong>我们遍历所有NFT的列表。</p><p id="0de4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这样做是为了提供临时数组<code class="fe mx my mz na b">items</code>，其大小为<code class="fe mx my mz na b">itemCount</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/bb83469fd3aaa81661ce9fc43c7c77bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGCbdLY0pzyc9NNqsDCZcg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">我的NFTs</p></figure><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="e138" class="nx lv iq na b gy ny nz l oa ob">function fetchItemsListed() public view returns (MarketItem[] memory) {</span><span id="bdae" class="nx lv iq na b gy om nz l oa ob">uint totalItemCount = _tokenIds.current();<br/>uint itemCount = 0;<br/>uint currentIndex = 0;</span><span id="af53" class="nx lv iq na b gy om nz l oa ob">for (uint i = 0; i &lt; totalItemCount; i++) {<br/>    if (idToMarketItem[i + 1].seller == <em class="kw">msg.sender</em>) {<br/>      itemCount += 1;<br/>    }<br/>  }</span><span id="1762" class="nx lv iq na b gy om nz l oa ob">MarketItem[] memory items = new MarketItem[](itemCount);</span><span id="de5a" class="nx lv iq na b gy om nz l oa ob">for (uint i = 0; i &lt; totalItemCount; i++) {<br/>    if (idToMarketItem[i + 1].seller == <em class="kw">msg.sender</em>) {<br/>      uint currentId = i + 1;<br/>      MarketItem storage currentItem = idToMarketItem[currentId];<br/>      items[currentIndex] = currentItem;<br/>      currentIndex += 1;<br/>     }<br/>   }<br/>return items;</span><span id="1c12" class="nx lv iq na b gy om nz l oa ob">}</span></pre><p id="51b3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这里也类似于上面的函数，我们得到我们正在销售的NFT的列表，<code class="fe mx my mz na b">idToMarketItem[i + 1].seller == <em class="kw">msg.sender</em></code> <em class="kw">。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/bd954d6388ba7fd876458e1f50c7c347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQEI_1zanbjGorcybfIebw.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">列出的非功能性测试。</p></figure><p id="92d5" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">这是完整的可靠性代码。</p><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="7b8b" class="nx lv iq na b gy ny nz l oa ob"><a class="ae ns" href="https://gist.github.com/Khanisic/ac54144abd4eea043ff31953a98ab29f" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Khanisic/ac54144abd4eea043ff31953a98ab29f</a></span></pre><h1 id="0e51" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">链接</h1><ul class=""><li id="16da" class="mm mn iq kx b ky mo lb mp lr mq ls mr lt ms lq og mu mv mw bi translated"><a class="ae ns" href="https://github.com/Khanisic/nft_marketplace" rel="noopener ugc nofollow" target="_blank"> Github </a></li><li id="05c6" class="mm mn iq kx b ky oh lb oi lr oj ls ok lt ol lq og mu mv mw bi translated"><a class="ae ns" href="https://nft-marketplace-khanisic.vercel.app/" rel="noopener ugc nofollow" target="_blank"> Vercel部署的链接</a></li></ul><pre class="kg kh ki kj gt nt na nu nv aw nw bi"><span id="25e9" class="nx lv iq na b gy ny nz l oa ob">Special thanks to Adrian from <a class="ae ns" href="https://www.youtube.com/c/JavaScriptMastery" rel="noopener ugc nofollow" target="_blank">Javascript Mastery </a>who taught me this project in his <a class="ae ns" href="https://javascript-mastery.teachable.com/p/nft-marketplace" rel="noopener ugc nofollow" target="_blank">course </a>NFT Marketplace.</span></pre></div></div>    
</body>
</html>