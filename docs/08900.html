<html>
<head>
<title>React Class vs. Functional Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应类别与功能组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-class-vs-functional-components-2327c7324bdd?source=collection_archive---------1-----------------------#2021-06-24">https://betterprogramming.pub/react-class-vs-functional-components-2327c7324bdd?source=collection_archive---------1-----------------------#2021-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类和功能组件的定义、道具、纯组件、内部状态、生命周期和性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0540a72fa098a06bedc5035c773ed918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVjpZGVI-a8MPHaJCP8uXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者原图</p></figure><p id="a2da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>让您选择是对类组件使用更命令式的代码风格，还是对功能组件使用更声明式的函数方法。</p><p id="e00f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React允许您将组件创建为纯函数，这是我喜欢该框架的主要原因之一。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="4fe6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">定义反应组件</h1><p id="2e1e" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">这是一个在React中以三种不同风格定义组件的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="b0d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，第一个，<code class="fe mv mw mx my b">ClassHelloWorld</code>，是一个类组件。<code class="fe mv mw mx my b">FunctionHelloWorld</code>是使用经典函数的功能组件，<code class="fe mv mw mx my b">ArrowHelloWorld</code>是使用箭头函数的功能组件。</p><p id="c090" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三个函数的输出是相等的。</p><h1 id="423c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">在组件中使用React道具</h1><p id="ee6a" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">Props在React中用于将变量传递给组件。这是在两种类型的组件中使用它们的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="b78a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主要的区别在于，在函数组件中，您需要将props定义为函数的一个参数，并且您没有使用<code class="fe mv mw mx my b">this</code>。</p><p id="02a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论您使用哪种类型的组件，道具的使用方式都是一样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="8ad9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在脚本中看到，我只是在定义<code class="fe mv mw mx my b">name</code>的值，这会显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6b200b8656e79308c97605fde7bd0c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*frL1EC4DYMbmglDZsrm4gw.png"/></div></figure><h1 id="f824" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">创建纯组件</h1><p id="8f5c" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">在React中使用纯函数组件与在JavaScript的函数式编程中使用纯函数是一样的。</p><p id="fcdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是你如何用每种方法定义一个纯组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="0ebe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在类组件中，你扩展了<code class="fe mv mw mx my b">React.PureComponent</code>而不是<code class="fe mv mw mx my b">React.Component</code>，在功能组件中，你将你的函数包装在高阶函数<code class="fe mv mw mx my b">React.memo</code>中。</p><p id="38da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中以这种方式创建的纯组件基于它们的属性和内部状态值进行缓存。这意味着React不会每次都初始化整个组件，而是在提高性能的情况下重用它。</p><p id="dd2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数名<code class="fe mv mw mx my b">memo</code>是<em class="na"> memoization </em>的缩写，是一种针对缓存计算的函数式编程优化技术。</p><p id="2cd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，如果您在纯组件中使用其他组件，它们的渲染也会被缓存。这样，您可以创建一个需要几个其他组件来渲染的组件，但通过这种方法，所有内容都只渲染一次，并且在重用一个纯组件时，您可以获得性能提升。</p><h1 id="ac89" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">管理React组件状态</h1><p id="d1f1" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">管理组件的内部状态在类组件和功能组件之间会有很大的不同。</p><p id="711f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是在类组件中使用状态的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="eb84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意状态被定义为你的类的<code class="fe mv mw mx my b">constructor</code>中的一个对象。只需访问<code class="fe mv mw mx my b">this.state.name</code>即可读取当前值。</p><p id="156f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在使用<code class="fe mv mw mx my b">this.setState</code>函数基于输入元素的<code class="fe mv mw mx my b">onChange</code>事件编辑状态。通过<code class="fe mv mw mx my b">this.state.name = 'value'</code>直接编辑状态是不行的。</p><p id="96c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/eda5a694b3ba9d9d365845ef52ad41f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54pR2b3AxVUCuLCKXwgVuA.png"/></div></div></figure><p id="5d90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在功能组件中，通过使用以下代码可以获得相同的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="9a16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到功能组件仍然遵循更短的趋势，仅使用了14行代码，而我们对类组件使用了22行代码。</p><p id="478d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">功能组件使用<code class="fe mv mw mx my b">useState</code> React钩子定义变量<code class="fe mv mw mx my b">name</code>和函数<code class="fe mv mw mx my b">setName</code>。如果您的组件需要跟踪多个变量，您需要为每个变量调用<code class="fe mv mw mx my b">useState</code>。</p><p id="e516" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">传递给<code class="fe mv mw mx my b">useState</code>的参数是你的默认值。</p><p id="12e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该状态不能在组件外部共享或访问，但可以作为一个属性传递给另一个组件。</p><p id="a113" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的类组件和功能组件仍然可以被定义为纯组件，它们的任何行为都没有任何问题，并且内部状态被绑定到组件的每个实例。如果您的组件在应用程序生命周期中的状态数量有限，那么使用<code class="fe mv mw mx my b">React.PureComponent</code>定义类组件或者使用<code class="fe mv mw mx my b">React.memo</code>定义功能组件，将它定义为一个纯组件会很有好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/677a55d361415c4bc69c383a517dbbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fo8O-4NwYhvP2NfWexshtg.png"/></div></div></figure><p id="c873" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您需要您的应用程序来管理全局状态，您应该使用诸如Redux或React hooks之类的库来为分离关注点的全局状态构建中间件。</p><h1 id="ec29" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">管理组件安装</h1><p id="c01f" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">您可能希望管理组件的安装、卸载和更新。所有这些同样适用于纯组件。</p><p id="effa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在类组件中，您可以通过以下函数管理安装:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="2cf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三个主要状态由功能<code class="fe mv mw mx my b">componentDidMount</code>、<code class="fe mv mw mx my b">componentWillUnmout</code>和<code class="fe mv mw mx my b">componentDidUpdate</code>管理。</p><p id="03ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在实践中进行测试，我们还将在这个脚本中演示可视化管理和状态传递:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="225f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是控制台视图的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/938b64a683bb2d3a3c522413ddbba562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1a-1_EFudI-mNwtSKU0tA.jpeg"/></div></div></figure><p id="994a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将通过一个功能组件实现同样的目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu lw l"/></div></figure><p id="2949" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次，功能组件使用了16行代码，而类组件使用了26行代码。</p><p id="61eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们利用React钩子<code class="fe mv mw mx my b">useEffect</code>，它旨在观察变量数组的变化。当我们像第一种情况一样传递一个空数组<code class="fe mv mw mx my b">[]</code>时，这个函数只在组件被挂载时被调用，然后当组件被卸载时，返回的函数被调用。</p><p id="7acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们通过带有道具<code class="fe mv mw mx my b">[props]</code>的数组时，React会在每次<code class="fe mv mw mx my b">props</code>变化时调用函数，包括第一次在挂载组件时使用。</p><h1 id="763b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">性能差异</h1><p id="cdf7" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">人们普遍认为功能组件比类组件更快，React团队一直承诺对功能组件进行优化。</p><p id="fad4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我还没有找到任何证据证明这两种方法的直接性能差异。在这个渲染测试中，两种方法产生了相同的结果:【https://jsfiddle.net/69z2wepo/136096/】T4。</p><h1 id="4c37" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="fd0c" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">React中的函数组件和类组件提供相同的功能。在使用这两种方法中的任何一种时，您都不应该错过任何东西，并且它们在渲染性能上没有区别。</p><p id="a065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文的代码示例中，功能组件平均只使用了一半的代码行数。写更少的代码意味着你的同事在试图理解它的时候也需要读得更少。</p><p id="c3a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，这在很大程度上取决于您是更喜欢命令式面向对象的类方法，还是更喜欢声明式函数式编程。对我来说，功能组件是最受欢迎的。</p><p id="daa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在评论中告诉我你是否在自己的代码中使用了类或函数组件。</p></div></div>    
</body>
</html>