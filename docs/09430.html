<html>
<head>
<title>Lazy Loading React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性加载反应组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-react-components-cdd76006b35a?source=collection_archive---------7-----------------------#2021-08-24">https://betterprogramming.pub/lazy-loading-react-components-cdd76006b35a?source=collection_archive---------7-----------------------#2021-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c50e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">延迟加载在服务器和浏览器环境中为各种框架反应组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53aabefb70c06cf36cd1c7f0c69c0636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LfbgI6v4FhPGIs9Pnmndg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank">插画</a>。</p></figure><p id="8e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React应用程序，像任何其他类型的web应用程序(Angular，Vue等)一样，在浏览器中下载和执行时，可能会变得非常大，并且在任何给定的时间都充满了未使用的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/9461909dc405f37b09c415973464e3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s5DKcyjUeq7ZSken.png"/></div></div></figure><p id="4a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常见的UX模式有许多组件，如对话框、警告和消息，它们只在用户交互或特定事件后出现。以点击网站上的“添加到购物车”为例，然后出现一个弹出消息说“已成功添加到购物车！”。当web应用程序最初被下载到浏览器中时，并不需要弹出组件，因此它可以被代码分割(例如，从主JS包中移除)并在用户向购物车添加内容时延迟加载。</p><p id="18a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">捆绑器变得更加聪明，可以为你树摇一些未使用的代码，但是他们不能决定每个文件/组件是否应该被延迟加载并从主JS包中完全删除。这种代码分割和延迟加载功能通常由动态<code class="fe lw lx ly lz b">import()</code>方法完成，该方法是bundler编译运行时的一部分<em class="ma">，不同于浏览器方法</em>。</p><p id="0789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> React的JSX </a>，我们需要做的不仅仅是用动态<code class="fe lw lx ly lz b">import()</code>导入和渲染组件。在本文中，我们将看到如何在不同的运行时上下文中(服务器对浏览器)以及针对不同的web框架(Next.js和Gatsby.js)对React组件进行代码拆分和延迟加载。</p><h2 id="4170" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">React.js</h2><p id="e73d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">注意:</strong>以下方法适用于在浏览器中执行所有代码的客户端渲染(CSR) web应用。</p><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们使用React自己的惰性加载组件<code class="fe lw lx ly lz b"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">lazy</a></code> <a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lw lx ly lz b"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">Suspense</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React负责将导入的JS文件翻译成React组件，以便可以使用JSX进行渲染。当Webpack看到动态<code class="fe lw lx ly lz b">import()</code>函数被调用时，它会在编译期间处理代码拆分和延迟加载部分。</p><p id="233f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果<code class="fe lw lx ly lz b">import()</code>功能没有被你的捆绑器识别，你可能需要安装<a class="ae ky" href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import.html" rel="noopener ugc nofollow" target="_blank">这个巴别塔插件</a>。</p><p id="52bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要延迟加载的组件在下载、解析和呈现时需要一个占位符，所以React要求使用<code class="fe lw lx ly lz b">&lt;Suspense&gt;</code>来提供那个<code class="fe lw lx ly lz b">fallback</code>组件。这实际上可以是任何东西，一个spinner、动画SVG，或者只是一个普通的文本，表示将在它的位置加载一些东西。</p><p id="a2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个活生生的例子，请看<a class="ae ky" href="https://glitch.com/edit/#!/react-component-lazy-loading" rel="noopener ugc nofollow" target="_blank">这个小故障</a>。</p><h2 id="10a4" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">在Webpack中命名输出块</h2><p id="f1d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时你可能想给你的代码分割块命名，因为默认情况下捆绑器<strong class="lb iu">不会给它们命名。当我在一个页面上有许多延迟加载的组件时，它确实有助于我进行调试。</strong></p><p id="31c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Webpack，你只需要使用如下的<code class="fe lw lx ly lz b">webpackChunkName</code>魔法注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="833e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，以前面的例子为例，我们延迟加载了<code class="fe lw lx ly lz b">&lt;NavMenu&gt;</code>组件，我们会这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="9512" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">使用<code class="fe lw lx ly lz b">react-router</code></h2><p id="952e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">代码膨胀是单页应用程序的常见问题。如果没有正确完成，您最终会得到一个包含web应用程序中所有可能路径的主JS包，而您一次只需要一个。</p><p id="3857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这很容易解决。当您指定路由时，只需使用上述方法来延迟加载组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="0693" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">Next.js</h2><p id="ed06" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">注意:</strong>next . js的方法不同，因为它处理服务器端呈现(SSR ),其中代码并不总是在浏览器中执行——它也在服务器中执行。</p><p id="cf16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Next.js提供<a class="ae ky" href="https://nextjs.org/docs/advanced-features/dynamic-import" rel="noopener ugc nofollow" target="_blank">开箱即用的动态导入</a>，包含<em class="ma"> SSR！</em></p><p id="7a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对任何组件进行代码拆分和转换都相当简单。如果我们以前面的<code class="fe lw lx ly lz b">&lt;Header /&gt;</code>组件为例，它看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="0b47" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">盖茨比</h2><p id="4ce1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">注意:</strong>Gatsby . js的方法有所不同，因为它处理服务器端呈现(SSR ),其中代码并不总是在浏览器中执行——它也在服务器中执行。</p><p id="24e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Gatsby目前不像Next.js那样提供带SSR的现成惰性加载。要添加延迟加载，我们必须考虑以下三个选项之一。尽管这个列表并不详尽，但我发现它更方便😊。</p><p id="2cd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong> Gatsby.js默认使用Webpack构建并捆绑代码。</p><h2 id="d823" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><em class="nb">盖茨比#1: </em>反应<code class="fe lw lx ly lz b">lazy</code>和<code class="fe lw lx ly lz b">Suspense</code></h2><p id="871f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就像在浏览器的plain React.js中一样，我们可以使用React <code class="fe lw lx ly lz b">lazy</code>和<code class="fe lw lx ly lz b">Suspense</code>但是首先，我们需要检查<code class="fe lw lx ly lz b">window</code>对象是否不是<code class="fe lw lx ly lz b">undefined</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个变通办法的更多信息可以在<a class="ae ky" href="https://www.gatsbyjs.com/docs/using-client-side-only-packages/#workaround-4-use-reactlazy-and-suspense-on-client-side-only" rel="noopener ugc nofollow" target="_blank"> Gatsby.js文档</a>中找到。</p><p id="dcca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>上面的懒加载组件不会被服务器端渲染！</p><h2 id="ae85" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><em class="nb">盖茨比#2: </em>可加载组件</h2><p id="7ce3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://loadable-components.com/" rel="noopener ugc nofollow" target="_blank">可加载组件</a>是一个内置SSR的React组件延迟加载库。react-universal-component库也提供了类似的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="67d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个变通办法的更多信息可以在<a class="ae ky" href="https://www.gatsbyjs.com/docs/using-client-side-only-packages/#workaround-3-load-client-side-dependent-components-with-loadable-components" rel="noopener ugc nofollow" target="_blank"> Gatsby.js文档</a>中找到。</p><p id="9aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:这篇<a class="ae ky" href="https://dev.to/itmayziii/better-performance-using-dynamic-code-splitting-in-gatsby-with-loadable-components-6am" rel="noopener ugc nofollow" target="_blank">深入的文章</a>解释了如何用Gatsby设置可加载组件。</p><h2 id="c7fd" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><em class="nb">盖茨比选项#3: </em>动态<code class="fe lw lx ly lz b">import()</code> +反应状态</h2><p id="6af2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要考虑的最后一个变通方法是利用我们之前在React <code class="fe lw lx ly lz b">lazy</code>函数中看到的动态<code class="fe lw lx ly lz b">import()</code>函数以及React <a class="ae ky" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">状态</a>。</p><p id="53f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们本质上是在用户交互之后导入组件文件(第12行),并通过调用<code class="fe lw lx ly lz b">React.createElement</code>方法在运行时创建一个新的React组件(第14行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个示例项目，请查看这个<a class="ae ky" href="https://github.com/charisTheo/gatsby-dynamic-imports" rel="noopener ugc nofollow" target="_blank">演示Gatsby GitHub库</a>。</p><h1 id="8aaf" class="nc mc it bd md nd ne nf mg ng nh ni mj jz nj ka mm kc nk kd mp kf nl kg ms nm bi translated">进一步阅读</h1><ul class=""><li id="bc76" class="nn no it lb b lc mu lf mv li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#code-splitting" rel="noopener ugc nofollow" target="_blank">反应拆码单据</a></li><li id="6e57" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank"> Webpack代码拆分文档</a></li><li id="4517" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/gregberge/loadable-components" rel="noopener ugc nofollow" target="_blank">loadable-components</a></code> <a class="ae ky" href="https://github.com/gregberge/loadable-components" rel="noopener ugc nofollow" target="_blank"> Github资源库</a></li><li id="b72c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/twobin/react-lazyload" rel="noopener ugc nofollow" target="_blank">react-lazyload</a></code> <a class="ae ky" href="https://github.com/twobin/react-lazyload" rel="noopener ugc nofollow" target="_blank"> Github资源库</a></li><li id="b9d5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/hadeeb/react-lazy-hydration" rel="noopener ugc nofollow" target="_blank">react-lazy-hydration</a></code> <a class="ae ky" href="https://github.com/hadeeb/react-lazy-hydration" rel="noopener ugc nofollow" target="_blank"> Github资源库</a></li></ul></div></div>    
</body>
</html>