<html>
<head>
<title>A First Step Into Writing Recursive Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写递归函数的第一步</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-first-step-into-writing-recursive-functions-aeb823b4636d?source=collection_archive---------18-----------------------#2020-02-13">https://betterprogramming.pub/a-first-step-into-writing-recursive-functions-aeb823b4636d?source=collection_archive---------18-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b371" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习编写调用自身的函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad6a5ae0365ff6019417a171d7207d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vpt_gFNRtaKta8Sx3FSm-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@vision?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">视觉网</a>在<a class="ae ky" href="https://unsplash.com/s/photos/repeat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b4e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归是导致眨眼、抓头和整体混乱的主题之一。函数调用自己的想法就像你掉进了一个兔子洞，事实是，这是对你的函数实际所做的相当准确的感觉。</p><p id="8bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在理解了递归多年之后，每当一个问题被递归地解决时，我必须停下来多花一分钟来确保我理解了我正在看的东西。</p><p id="2145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要担心，因为我们将分解递归，并通过一个真实世界的例子。</p><p id="9f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用Python和JavaScript编写示例，到本文结束时，您将有望理解文章的标题实际上是一个双关语。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">递归函数的组成部分</h1><p id="de2a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我发现通过例子教递归更容易。这个概念太抽象了，无法形象化。所以，让我们定义一个函数来计算一个数的阶乘。</p><p id="9f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个数的阶乘值是该数乘以它下面的每个正整数。所以，3阶乘——写成3！—应该是3 * 2 * 1，等于6。</p><h2 id="5a60" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">计算机编程语言</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="ee4c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">Java Script语言</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fd2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解这些例子，递归函数有两个主要部分:基本情况和递归情况。</p><p id="46e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的阶乘函数中，我们使用一个<code class="fe nn no np nq b">if/else</code>语句来分隔两者。现在，让我们一个命令一个命令地看一下这个函数实际上是如何执行的。</p><ol class=""><li id="d64e" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">调用<code class="fe nn no np nq b">factorial(3)</code>被执行。在这个函数中，<code class="fe nn no np nq b">3 * factorial(2)</code>的值应该被返回。所以，我们需要执行<code class="fe nn no np nq b">factorial(2)</code>来完成我们的返回。</li><li id="09d3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">调用<code class="fe nn no np nq b">factorial(2)</code>被执行。请注意，我们的<code class="fe nn no np nq b">factorial(3)</code>呼叫仍在等待完成。现在，<code class="fe nn no np nq b">factorial(1)</code>必须进行评估。</li><li id="bb83" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">执行对<code class="fe nn no np nq b">factorial(1)</code>的调用。<code class="fe nn no np nq b">factorial(3)</code>和<code class="fe nn no np nq b">factorial(2)</code>都在等待完成。我们向下递归到<code class="fe nn no np nq b">factorial(0)</code>。</li><li id="4a96" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">对<code class="fe nn no np nq b">factorial(0)</code>的调用返回<code class="fe nn no np nq b">1</code>。</li><li id="0e4e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">现在，<code class="fe nn no np nq b">factorial(1)</code>返回<code class="fe nn no np nq b">1 * 1</code>，其中第二个1是<code class="fe nn no np nq b">factorial(0)</code>的返回值。</li><li id="c7d2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">然后，<code class="fe nn no np nq b">factorial(2)</code>返回<code class="fe nn no np nq b">2 * 1</code>，其中1是<code class="fe nn no np nq b">factorial(1)</code>的返回。</li><li id="cae8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">最后，<code class="fe nn no np nq b">factorial(3)</code>返回<code class="fe nn no np nq b">3 * 2</code>，其中2是<code class="fe nn no np nq b">factorial(2)</code>的返回。</li></ol><p id="8db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用缩进可视化这些步骤有助于理解一切。</p><pre class="kj kk kl km gt of nq og oh aw oi bi"><span id="cf87" class="mz md it nq b gy oj ok l ol om">factorial(3)<br/>  factorial(2)<br/>    factorial(1)<br/>      factorial(0) =&gt; returns 1<br/>    returns 1 * 1<br/>  returns 2 * 1<br/>returns 3 * 2</span></pre><p id="61e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，本质上，为了评估我们的原始函数调用<code class="fe nn no np nq b">factorial(3)</code>，我们需要一遍又一遍地调用函数，直到遇到基本情况，打破递归循环，并允许所有先前的调用以相反的顺序进行评估。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c0f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我什么时候使用递归？</h1><p id="217b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我们已经完成了一个例子，我们需要一个令人信服的理由来花时间真正地记住和理解这个例子。</p><p id="4d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，递归是必要的。我最常用递归来操作复杂的数据结构，比如数组、字典和列表。</p><p id="c69b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我想从一个字典/对象中删除所有的空值，并且需要为嵌套的字典/对象做准备，那么我会使用这样的递归函数。</p><h2 id="3acd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">计算机编程语言</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="f97f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">Java Script语言</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f251" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">理解递归的局限性也很重要。递归函数非常占用内存。由于每个调用都要等待后续的递归调用，因此进程堆栈会很快变得很大。</p><p id="ae93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习实现递归函数，并在适当的时候识别用例。不是每一个可以用递归解决的问题都应该用递归解决；然而，一旦你需要它，你会很高兴它是你箭囊中的一支箭。</p><p id="1dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在明白了这个双关语，那么你已经在路上了！</p></div></div>    
</body>
</html>