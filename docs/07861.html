<html>
<head>
<title>How To Create Smooth Endless Scrolling in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vue.js中创建流畅的无止境滚动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-smooth-endless-scrolling-in-vue-js-4fc9180645ef?source=collection_archive---------7-----------------------#2021-02-26">https://betterprogramming.pub/how-to-create-smooth-endless-scrolling-in-vue-js-4fc9180645ef?source=collection_archive---------7-----------------------#2021-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有任何抖动或外部库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56654092345cb5cade8cd7fe734288bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N66eMXmw2VZVIHX9wUpc4Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@slothxbear?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">熊燕</a>在<a class="ae ky" href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="6f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何在Vue.js中创建一个平滑无休止滚动的页面。为了说明如何做到这一点，我将创建一个非常简单的搜索页面，您可以在上面无休止地滚动搜索结果。</p><p id="9650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是让页面流畅、快速，并且没有潜在的性能问题。</p><p id="e251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我把它叫做<em class="lv">平滑</em> <strong class="lb iu"> <em class="lv"> </em> </strong>无休止滚动页面？为了让最终用户体验流畅，他们必须能够无休止地滚动页面，而不是一直等待页面加载。记住这一点，让我们从简单的应用程序开始。</p><p id="d52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用vue-cli和<code class="fe lw lx ly lz b">vue create my-project-name</code>创建一个新项目。</p><p id="2a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要三个组件:</p><ul class=""><li id="de62" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">我们的搜索页面和列表的一个通用组件</li><li id="1b1d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">单个搜索结果的组件</li><li id="4237" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">加载器组件</li></ul><p id="bdfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这个组件作为虚拟滚动条的一部分，用于单独的搜索结果。我稍后会解释它的好处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的Vue应用程序的HTML部分，您会看到搜索框、在用户输入内容之前开始搜索的消息和虚拟滚动列表。</p><p id="0482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的虚拟滚动条，我们使用<a class="ae ky" href="https://github.com/tangbc/vue-virtual-scroll-list" rel="noopener ugc nofollow" target="_blank"> Vue虚拟滚动列表</a>，这是GitHub上的一个2.5K星的项目，它可以帮助你创建虚拟滚动条(类似于react中的<a class="ae ky" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank"> react-virtualized </a>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/dd2a6b51184b9bab6f6bf7bf338b7098.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*FvTYWsUGUJJ4VwJabqrbAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创作。</p></figure><p id="aafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有很多HTML元素会让你的前端变得非常沉重。包含超过1，500-2，000个DOM元素的页面会开始滞后，尤其是在小型设备上。</p><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，有一个无限滚动的页面，过一段时间后，它可能会有数千个父元素，每个父元素包含几个子节点。对性能的影响将是巨大的。</p><p id="78f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟滚动条通过从DOM中移除不可见的元素来规避这个问题。唯一真正的DOM元素是那些可见的元素，加上上面和下面的一些作为缓冲的元素。大的填充是到该点为止所有元素的高度之和，它被添加到顶部以显示滚动条并保持平滑。</p><p id="1401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然一切都解释清楚了，让我们开始研究迷你应用程序的JavaScript部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为HTTP请求导入组件和axios。<code class="fe lw lx ly lz b">lodash</code>也被导入，因为我们将使用它的一个助手函数。</p><p id="b701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">&lt;virtual-list&gt;</code>内部传递了<code class="fe lw lx ly lz b">itemComponent</code>属性，它需要指向将呈现单个搜索结果的组件。在我们的例子中，这就是我们现在将要创建的<code class="fe lw lx ly lz b">SearchResult</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟列表将通过<code class="fe lw lx ly lz b">source</code>道具，我们可以用它来呈现搜索结果的标题和描述。如您所见，我使用了<code class="fe lw lx ly lz b">v-html</code>指令来呈现代码片段，因为API以HTML格式返回描述。</p><p id="466d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经有了虚拟列表和搜索结果的基本基础，所以是时候连接Wikipedia API并带来一些结果了。我们将首先创建一个<code class="fe lw lx ly lz b">search</code>方法，该方法将基于用户输入的文本执行搜索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dd66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好了一个搜索函数，是时候调用它了。这个搜索方法需要被调用:</p><ul class=""><li id="f578" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">当用户开始在搜索框中键入时。</li><li id="8339" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">当用户向下滚动时。</li></ul><p id="7658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过在我们的<code class="fe lw lx ly lz b">EndlessList</code> Vue组件中添加拼图的最后部分来处理这两种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="37c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在为<code class="fe lw lx ly lz b">searchQuery</code>使用一个观察器，这样每次<code class="fe lw lx ly lz b">searchQuery</code>的值改变时，我们都可以得到新的结果。正如你可能注意到的，我们还使用了一个<code class="fe lw lx ly lz b"><a class="ae ky" href="https://lodash.com/docs/#debounce" rel="noopener ugc nofollow" target="_blank">debounce</a></code> <a class="ae ky" href="https://lodash.com/docs/#debounce" rel="noopener ugc nofollow" target="_blank">函数</a>来确保<code class="fe lw lx ly lz b">search</code>不是在每一个输入的字母上被调用，而是在最后一个字母之后200毫秒被调用。</p><p id="9acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个需要注意的重要事情是，我们在第一次搜索时加载两页结果，以便用户一开始有一些空间来滚动。为了保持流畅，提前加载一页很重要。</p><p id="d82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lw lx ly lz b">mounted</code>方法中，我们添加了滚动监听器，它将再次调用search方法并更新页面计数。我们在滚动事件上也使用了<code class="fe lw lx ly lz b">debounce</code>，但是我们将<code class="fe lw lx ly lz b">leading</code>设置为<code class="fe lw lx ly lz b">true</code> <strong class="lb iu"> </strong>，因为我们希望在<em class="lv">第一个</em>(或前导)事件之后100毫秒运行预期的方法，而不是最后一个(尾随)事件。</p><p id="3292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lw lx ly lz b">npm run serve</code>运行我们的Vue应用，这是最终结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/81e1d47248eff5777447415e868ed923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*08L0WmYbqncJJ765_27SSQ.gif"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f8d2" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">结论</h1><p id="c4b1" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">我写这篇文章的目的是帮助你看到一个无限滚动的完整例子。我本可以只展示当你接近页面底部时加载更多结果的部分，但是这并没有解释一些重要的部分。</p><h2 id="9a9f" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">1.平滑</h2><p id="2133" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">对于终端用户来说，无休止的滚动应用程序必须感觉流畅。如果我们在页面底部加载结果，用户将不得不不断地等待结果加载，这将导致挫败感。</p><p id="9e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是在用户到达页面底部之前提前加载。</p><h2 id="5609" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">2.滚动性能</h2><p id="e08a" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">这个例子非常简单，但是在像脸书这样的实际应用程序中，单个部分(比如我们例子中的搜索结果)在DOM上占用的内存要多得多，因为它们包含更多的元素。</p><p id="6adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用户无休止地滚动——几分钟甚至几小时——页面会变得非常慢。但当你在脸书或Instagram上滚动时，你不会体验到这样的缓慢。使用的技术被称为虚拟化，它确保当您向下滚动并获得更多结果时，DOM不包含成千上万的元素。</p><p id="df6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/tangbc/vue-virtual-scroll-list" rel="noopener ugc nofollow" target="_blank">vue-virtual-scrol-list</a></code>，您可以确保当用户在结果的第一页或第100页上滚动时，页面的效果是一样的。</p><h2 id="d960" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">3.事件处理</h2><p id="6e28" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">如你所见，我们使用<code class="fe lw lx ly lz b">debounce</code>来滚动和输入事件。原因是我们不想为用户输入的每个字符触发大量的请求，我们也不想检查每个滚动事件，因为那会使页面变慢。</p><p id="521c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些JavaScript事件被频繁触发，或者它们的事件回调需要时间来执行。在这两种情况下，使用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">debounce</a></code>或<code class="fe lw lx ly lz b"><a class="ae ky" href="https://lodash.com/docs/4.17.15#throttle" rel="noopener ugc nofollow" target="_blank">throttle</a></code>来限制它们被执行的次数可能是有意义的。</p><p id="baee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经看到了一个无止境滚动应用程序的完整示例，您可以开始自己构建一些东西了。如果你想进一步试验，你可以在GitHub 上找到<a class="ae ky" href="https://github.com/arisp8/vue-endless-scrolling" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p></div></div>    
</body>
</html>