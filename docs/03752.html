<html>
<head>
<title>How to Design a Complete IoT Solution Using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js设计完整的物联网解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-design-a-complete-iot-solution-using-node-js-674787409e57?source=collection_archive---------3-----------------------#2020-03-03">https://betterprogramming.pub/how-to-design-a-complete-iot-solution-using-node-js-674787409e57?source=collection_archive---------3-----------------------#2020-03-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="23bf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Node.js、MQTT和InfluxDB来测量、传递和存储温度读数</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/51f732e249780a0067b16fa0149f8733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH-5KGaOWmcoDMRTdEAxng.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">利用物联网控制温室气候。图片由作者提供。</p></figure><p id="2d63" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本文描述了一个使用新的Raspberry Pi 4B的物联网(IoT)实验。</p><p id="b233" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它从一个连接到树莓皮的传感器开始，测量温度。服务使用MQTT将测量结果安全地传递给MQTT代理。最后，另一个服务检索测量结果并将其存储在数据库中</p><p id="e5d4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">完整的解决方案可在GitHub上获得，并在Docker容器中运行。你可以使用<a class="ae lv" href="https://github.com/PatrickKalkman/clima-link/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>来启动它。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="de1f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">体系结构</h1><p id="5e79" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">生产就绪的物联网解决方案必须能够每秒处理超过100，000个样本。因此，我的解决方案的设计应该能够处理这些类型的数字。</p><p id="4fde" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了使解决方案能够每秒处理如此多的事务，它应该是可伸缩的。因此，我将解决方案分成四个不同的服务。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj na"><img src="../Images/f857a6919101e50ee1ec5f5baeab46fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yyq4E_Q8GVx9_AXM5yibOA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">clima-link物联网架构</p></figure><p id="e1e0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每个服务都运行在Docker容器中，负责特定的功能。在实验过程中，我在Raspberry Pi上运行了所有Docker容器。</p><p id="6c93" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我选择容器，因为这使得在开发期间在单个节点上或者在生产期间在多个节点上扩展和运行完整的解决方案变得更加容易。</p><p id="93e2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个解决方案的瓶颈是存储所有输入测量值的数据库。因此，我使用了一个专门的数据库，一个时间序列数据库。时间序列数据库是专门为存储带时间戳的数据而设计的。根据设计，这些数据库能够读写大量数据。</p><p id="35fa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我将该解决方案分为以下四种服务:</p><h2 id="599f" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">气候测量</h2><p id="dc32" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated"><a class="ae lv" href="https://github.com/PatrickKalkman/clima-link/tree/master/clima-measure" rel="noopener ugc nofollow" target="_blank"> clim-measure </a>服务处理从传感器检索测量温度。它使用MQTT协议发布温度。</p><h2 id="5d11" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">clim-broker</h2><p id="b75f" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clim-broker服务是解决方案的MQTT代理。它负责接收和路由所有MQTT消息。</p><h2 id="f7bc" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">clim-存储</h2><p id="f0b7" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clim-storage服务负责通过MQTT接收温度事件，并将它们发送到数据库。</p><h2 id="ad27" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">clim-db</h2><p id="9b7e" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clim-db 服务负责将温度传感器数据保存在数据库中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="949a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">选择正确的传感器(clim-measure)</h1><p id="0282" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">为了方便使用，我选择了Dallas <a class="ae lv" href="https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf" rel="noopener ugc nofollow" target="_blank"> DS18B20 </a>数字传感器来测量温度。它使用一根导线来传递温度，不需要总净转换。它直接以双精度形式返回测得的温度。</p><p id="27d9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我将传感器连接到Raspberry Pi 4B的一个通用输入/输出(GPIO)端口。Raspberry Pi运行的是Raspbian Lite。</p><p id="81b2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在使用DS18B20之前，必须在Pi上启用单线协议。Raspberry PI教程创建了一个<a class="ae lv" href="https://tutorials-raspberrypi.com/raspberry-pi-temperature-sensor-1wire-ds18b20/" rel="noopener ugc nofollow" target="_blank">优秀教程</a>，解释了如何启用它。</p><p id="a2d1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">启用单线协议后，您可以执行以下脚本来读取温度。</p><pre class="kk kl km kn gu nn no np nq aw nr bi"><span id="5fe2" class="nb me iu no b gz ns nt l nu nv">cat /sys/bus/w1/devices/28-00000ab45db8/w1_slave | sed -n 's/^.*\(t=[^ ]*\).*/\1/p' | sed 's/t=//' | awk '{x=$1}END{print(x/1000)}'</span></pre><p id="7161" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我的树莓派上，脚本输出的是<code class="fe nw nx ny no b">13.812</code>，当时房间里的温度。</p><h2 id="f18b" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">自动化温度读数</h2><p id="e846" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">启用传感器后，我们可以创建clim-measure服务。这是一个Node.js应用程序，它读取传感器并使用MQTT发布它。</p><p id="937e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用了<a class="ae lv" href="https://github.com/thisdavej/ds18b20-raspi" rel="noopener ugc nofollow" target="_blank"> ds18b20-raspi </a>，这是Dave Johnson创建的一个npm包，有助于读取传感器数据。我将它包装在一个名为<code class="fe nw nx ny no b">sensor.js</code>的模块中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">sensor.js模块，用于从DS18B20传感器读取温度</p></figure><p id="7b87" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第13行的<code class="fe nw nx ny no b">if</code>语句检查程序是否在生产模式下运行。如果它在生产模式下运行，它会从传感器读取温度。否则，它会生成一个随机数。这让我可以在我的笔记本电脑上开发和测试解决方案。</p><h2 id="55da" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">使用MQTT发布温度读数</h2><p id="19a4" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">传感器读取温度后，应用程序使用MQTT协议发布温度。<a class="ae lv" href="http://mqtt.org/" rel="noopener ugc nofollow" target="_blank"> MQTT </a>是用于物联网解决方案的轻量级发布-订阅协议。</p><p id="6e19" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">MQTT将客户机分为发布者和订阅者。中央MQTT代理负责将消息从发布者路由到订阅者。</p><p id="a6af" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">消息被分成多个主题。如果您想要接收某个主题的消息，您可以向MQTT代理表明您想要订阅这个主题。</p><p id="d077" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一方面，如果您想要发布特定主题的消息，您可以直接将它发送给MQTT代理。</p><p id="371d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">clim-measure，读取温度的服务，是一个MQTT客户机。我使用npm模块<a class="ae lv" href="https://github.com/mqttjs/MQTT.js" rel="noopener ugc nofollow" target="_blank"> MQTT.js </a>来实现MQTT客户端。MQTT.js是Node.js的MQTT客户端库。</p><p id="2443" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">服务启动后做的第一件事是连接到MQTT代理。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启动时连接到MQTT代理</p></figure><p id="0c5d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">MQTT代理使用用户名和密码来验证MQTT客户机。</p><p id="10d8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用<code class="fe nw nx ny no b">mqtt</code>客户端库的<code class="fe nw nx ny no b">publish</code>方法发送温度。我构造了一个包含温度和时间戳的对象。就在发送之前，我使用<code class="fe nw nx ny no b">JSON.stringify</code>将对象转换成JSON字符串。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="6ef9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将把这个消息发送给MQTT代理。它使用了主题<code class="fe nw nx ny no b">house/bedroom/temperature</code>。</p><h2 id="ebe4" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">MQTT主题</h2><p id="0d06" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">MQTT使用主题作为一种寻址形式，为连接的客户端过滤消息。主题本身是由一个或多个字符组成的区分大小写的UTF-8字符串。</p><p id="c5e8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以使用正斜杠(/)作为分隔符来定义主题中的层次结构。以下都是有效的MQTT主题。</p><ul class=""><li id="e69c" class="ob oc iu lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><code class="fe nw nx ny no b">house/bedroom/temperature</code></li><li id="c876" class="ob oc iu lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny no b">house/bathroom/relativehumidity</code></li><li id="5654" class="ob oc iu lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny no b">house/bathroom/temperature</code></li><li id="0551" class="ob oc iu lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe nw nx ny no b">house/garage/temperature</code></li></ul><p id="76ed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">多级通配符</strong></p><p id="476c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">订阅时，可以使用通配符来订阅多个主题。使用散列符号定义多级通配符。哈希符号必须是主题的最后一个字符。</p><p id="eca8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，当MQTT客户机订阅主题<code class="fe nw nx ny no b">house/bathroom/#</code>时，它将接收所有以<code class="fe nw nx ny no b">house/bathroom</code>开头的主题。</p><p id="fd70" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以看前面的题目列表，这个会是<code class="fe nw nx ny no b">house/bathroom/relativehumidity</code>，还有<code class="fe nw nx ny no b">house/bathroom/temperature</code>。</p><p id="6150" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">单级通配符</strong></p><p id="8af2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通过使用加号，单级通配符可以替换单个主题级别。</p><p id="adc6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，当MQTT客户机订阅主题<code class="fe nw nx ny no b">house/+/temperature</code>时，它将接收以<code class="fe nw nx ny no b">house</code>开始并以<code class="fe nw nx ny no b">temperature</code>结束的所有主题。所以看前面的题目列表，这个会是<code class="fe nw nx ny no b">house/bathroom/temperature</code>、<code class="fe nw nx ny no b">house/bedroom/temperature</code>、<code class="fe nw nx ny no b">house/garage/temperature</code>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a575" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">MQTT代理(clim-broker)</h1><p id="b6dc" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clim-broker是负责接收MQTT消息并将其路由到MQTT客户机的服务。在启动过程中，服务打开一个套接字并监听传入的MQTT消息。</p><p id="0e14" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我希望MQTT客户机和MQTT代理之间有安全的通信。这在使用TLS的MQTT中是可能的。要使用TLS，您必须使用SSL证书。</p><p id="c507" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我创建了一个自签名证书和一个私钥，以便在MQTT代理中使用它。如果您在创建自签名证书方面需要一些帮助，请参阅我以前的文章。</p><div class="op oq gq gs or os"><a href="https://medium.com/better-programming/how-to-create-ssl-certificates-for-development-861237235933" rel="noopener follow" target="_blank"><div class="ot ab fp"><div class="ou ab ov cl cj ow"><h2 class="bd iv gz z fq ox fs ft oy fv fx it bi translated">如何为开发创建SSL证书</h2><div class="oz l"><h3 class="bd b gz z fq ox fs ft oy fv fx dk translated">自动生成SSL证书</h3></div><div class="pa l"><p class="bd b dl z fq ox fs ft oy fv fx dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kt os"/></div></div></a></div><h2 id="018d" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">Aedes，一个基本的MQTT经纪人</h2><p id="15f5" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">为了实现MQTT代理，我使用了npm包<a class="ae lv" href="https://github.com/moscajs/aedes" rel="noopener ugc nofollow" target="_blank"> Aedes </a>。Aedes是一个MQTT代理，具有基本的功能，可以使用扩展进行扩展。</p><p id="d47e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在clim-broker服务启动期间，它创建一个<code class="fe nw nx ny no b">aedes</code>的实例，启动服务器，并开始监听指定端口上的MQTT消息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="606b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建服务器时，私钥和公钥都被添加到<code class="fe nw nx ny no b">options</code>中。</p><h2 id="a656" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">认证客户端</h2><p id="8433" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">除了使用TLS，MQTT客户机还必须经过身份验证。这是使用用户名和密码完成的。你必须实现一个认证功能，并将其分配给伊蚊。</p><p id="d8f7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nw nx ny no b">broker.js</code>中的<code class="fe nw nx ny no b">setupAuthentication</code>方法设置当MQTT客户机连接到代理时执行的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">当MQTT客户机连接到MQTT代理时处理身份验证</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d0a1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">接收和存储温度样本(clim存储)</h1><p id="ec9c" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clim-storage服务负责接收温度事件并将它们存储在数据库中。</p><p id="83f4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">clim-storage服务就像clim-measure——一个MQTT客户机。但是它没有发布，而是订阅了<code class="fe nw nx ny no b">house/bedroom/temperature</code>主题来接收温度信息。</p><p id="6d67" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在启动过程中，clim-storage服务连接到MQTT代理。</p><h2 id="60f3" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">接收温度信息</h2><p id="34d5" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">为了接收消息，clim-storage服务首先订阅第4行的<code class="fe nw nx ny no b">house/bedroom/temperature</code>主题。然后，它使用<code class="fe nw nx ny no b">client.on('message', ...)</code>接收消息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="9eb8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">传入的<code class="fe nw nx ny no b">message</code>是Node.js <code class="fe nw nx ny no b">Buffer</code>类的一个实例。</p><p id="28e9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我在转换收到的邮件时遇到了一些问题。在我发现传入的<code class="fe nw nx ny no b">message</code>实际上是一个<code class="fe nw nx ny no b">Buffer</code>之后，我可以将它转换成一个字符串。</p><p id="fb7b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以我首先将它转换成一个字符串，然后使用<code class="fe nw nx ny no b">parseJsonToObject</code> helper函数将JSON字符串转换回一个对象。</p><h2 id="189d" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">存储温度样本</h2><p id="b6d4" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">收到温度样品后，我们必须将其储存起来。所有的样本都使用一个<a class="ae lv" href="https://github.com/influxdata/influxdb" rel="noopener ugc nofollow" target="_blank"> InfluxDB数据库持久化。</a></p><p id="e525" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">连接到数据库<br/> </strong>为了与InfluxDB交互，我使用了npm包<a class="ae lv" href="https://github.com/node-influx/node-influx#readme" rel="noopener ugc nofollow" target="_blank"> node-influx </a>。要连接到数据库，您必须创建InfluxDB类的一个实例，同时提供主机、端口和模式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">连接到InfluxDB并指定一个模式</p></figure><p id="c5cb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果数据库不存在，connect函数也会创建它。</p><p id="875a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">保存样本<br/> </strong>收到的消息包含温度和测量时间。函数<code class="fe nw nx ny no b">save</code>在数据库中保存一条记录。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将收到的消息保存到InfluxDB中</p></figure><h1 id="6b3b" class="md me iu bd mf mg ph mi mj mk pi mm mn ka pj kb mp kd pk ke mr kg pl kh mt mu bi translated">存储测量值(clima-db)</h1><p id="8b42" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">InfluxDB 是一个开源的时间序列数据库(TSDB)。我使用官方的<a class="ae lv" href="https://hub.docker.com/_/influxdb" rel="noopener ugc nofollow" target="_blank"> InfluxDB Docker映像</a>来运行数据库。</p><p id="24db" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">TSDBs是专门为存储大量带时间戳的数据而设计的。大多数物联网解决方案提供商都使用它们。在我们的例子中，我们用它们来存储特定时间的室内温度。</p><p id="598a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">更详细地描述TSDBs将是以后文章的主题。</p><p id="f9ed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你等不及了，那就看看泰德·邓宁的精彩演讲吧。Ted Dunning是MapR的首席应用架构师。MapR是一个数据平台，也提供时间序列数据库。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="pm oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Ted Dunning解释了TSDBs</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8d3b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">码头细节</h1><p id="f18e" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">clima-link中的每个服务都在Docker容器中运行。您可以使用Docker Compose启动完整的解决方案。我将所有Docker图像基于Arm32基本图像，因为我希望能够在Raspberry Pi上运行所有服务。</p><p id="94e2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">每个服务的源代码都存储在<a class="ae lv" href="https://github.com/PatrickKalkman/clima-link" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>的一个文件夹中。每个文件夹都包含该特定服务的docker文件。我使用了下面文章中的清单来创建生产就绪的docker文件。</p><div class="op oq gq gs or os"><a href="https://medium.com/better-programming/docker-for-node-js-in-production-b9dc0e9e48e0" rel="noopener follow" target="_blank"><div class="ot ab fp"><div class="ou ab ov cl cj ow"><h2 class="bd iv gz z fq ox fs ft oy fv fx it bi translated">生产中Node.js的Docker</h2><div class="oz l"><h3 class="bd b gz z fq ox fs ft oy fv fx dk translated">在生产环境中使用Docker运行Node.js应用程序的清单</h3></div><div class="pa l"><p class="bd b dl z fq ox fs ft oy fv fx dk translated">medium.com</p></div></div><div class="pb l"><div class="pn l pd pe pf pb pg kt os"/></div></div></a></div><p id="bd6f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用bash脚本自动创建Docker图像。这为我节省了开发时间。下面的脚本创建并上传clim-broker服务的Docker映像。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用于生成Docker图像的Bash脚本</p></figure><h2 id="b45f" class="nb me iu bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">运行完整的解决方案</h2><p id="9823" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">如果你有一个Raspberry Pi并且想要运行这个解决方案，你必须在Pi上安装<a class="ae lv" href="https://dev.to/rohansawant/installing-docker-and-docker-compose-on-the-raspberry-pi-in-5-simple-steps-3mgl" rel="noopener ugc nofollow" target="_blank"> Docker和Docker Compose </a>。</p><p id="ab57" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">安装后，将下面的内容复制到一个名为<code class="fe nw nx ny no b">docker-compose.yml</code>的文件中。使用<code class="fe nw nx ny no b">docker-compose up</code>，Docker图像将被下载并启动。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz oa l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用于启动完整解决方案的docker-compose.yml文件</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/eaab6bb22162d2c52a7755c2ea12c352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZi2r7NN0Qk4LeSmo8Fovg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Docker Compose启动物联网解决方案</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6171" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="7a8e" class="pw-post-body-paragraph kz la iu lb b lc mv jv le lf mw jy lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">本文展示了使用开源组件创建可扩展的物联网解决方案的可能性。通过将解决方案拆分成服务并在Docker容器中运行它们，它可以用于开发和生产中的扩展。</p><p id="317f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>