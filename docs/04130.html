<html>
<head>
<title>How to Build a Simple Restful API in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用PHP构建一个简单的Restful API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-simple-restful-api-in-php-c719f03cfa0a?source=collection_archive---------0-----------------------#2020-03-25">https://betterprogramming.pub/how-to-build-a-simple-restful-api-in-php-c719f03cfa0a?source=collection_archive---------0-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ba9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用PHP构建restful API的入门工具包，包含服务器端和客户端示例代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ba7266d37bc84f5ccaef6e3259e042f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jj3L5aY6_7c0R9a8U0d_Qw.png"/></div></div></figure><p id="5e1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，如果您想要一个可伸缩的web应用程序，在某个时候您将不得不考虑构建基于云的API服务，无论是微的还是其他的，它允许您的分布式应用程序能够共享公共功能。</p><p id="1edf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将向您展示如何用PHP构建一个简单的restful API。我们将构建一个服务器端API，它从客户端接收API密钥，连接到MySQL数据库获取API密钥，然后返回一个用密钥保护的JSON Web令牌(JWT)。</p><p id="28bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">客户端应用程序是一个简单的PHP页面，它调用API来检索令牌，然后在写出页面之前将其存储在cookie中。页面本身包含一些简单的jQuery，允许您删除cookie，然后通过JavaScript使用相同的API接口检索新的令牌。目标是为您提供一个页面，您可以在其中看到PHP和JavaScript代码调用相同的API。</p><p id="ed89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还包含了一些MySQL脚本来构建我们的示例数据库。</p><p id="3934" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们完成后，您将拥有一些坚实的基础代码，您可以扩展这些代码来创建自己的应用程序。事实上，我以后写的文章将会回来，在这个API项目的基础上进行改进和构建，以提供其他类型的真实服务。</p><p id="046e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="80f9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">示例代码</h1><p id="db8c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">以下三个GitHub资源库中提供了所有的示例代码。请随意下载并以任何方式使用此代码，无需注明出处:</p><ul class=""><li id="970f" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">后端API:<a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter" rel="noopener ugc nofollow" target="_blank">medium-PHP-API-starter</a></li><li id="4381" class="mu mv it kw b kx ne la nf ld ng lh nh ll ni lp mz na nb nc bi translated">客户端前端:<a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter-client" rel="noopener ugc nofollow" target="_blank">中端-php-api-starter-client </a></li><li id="62f5" class="mu mv it kw b kx ne la nf ld ng lh nh ll ni lp mz na nb nc bi translated">数据库脚本:<a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter-dbscripts" rel="noopener ugc nofollow" target="_blank">medium-PHP-API-starter-db scripts</a></li></ul><p id="6613" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，我在我的<code class="fe nj nk nl nm b">localhost</code>上构建了这个项目，后端API在一个项目中，客户端前端在一个单独的项目中。为了使这个简单的演示工作，有一些硬编码的引用(例如，数据库连接细节、API主机URL等)。我将在以后的文章中回来，我们将通过将这些东西移动到INI文件和数据库表中来改进我们的项目，这样我们的代码中就没有这些东西了。但是现在，我们的想法是保持简单。</p><p id="416a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我决定为每样东西建立单独的存储库，因为我确实打算在以后的文章中回来构建这个项目。每个存储库中的<code class="fe nj nk nl nm b">master</code>分支总是最新版本的代码，但是我会将每个特性分支留在存储库中，这样您可以在任何时候回滚并在任何阶段使用应用程序。也就是说，这些存储库中的每一个都包含一个名为<code class="fe nj nk nl nm b">original</code>的分支，这将是我们在这里工作的代码的起点。</p><p id="e144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便提一下，我的开发环境完全是在Docker容器中使用我最近的文章《<a class="ae nd" href="https://medium.com/better-programming/php-how-to-run-your-entire-development-environment-in-docker-containers-on-macos-787784e94f9a" rel="noopener">如何在macOS上的Docker容器中运行整个开发环境</a>》中的说明建立的</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2e2e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">数据库脚本</h1><p id="ea54" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们从运行MySQL数据库脚本开始。只有两个。一个创建了<code class="fe nj nk nl nm b">api_starter</code>数据库，另一个创建了一个<code class="fe nj nk nl nm b">app_api_key</code>表，该表将由API键索引，并为API后端提供一个相关的密钥，用于对JWT进行编码。</p><p id="e0a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要将这个库克隆到您的机器上，请打开一个终端窗口并导航到您想要用于您的项目的位置(我个人在我的根用户文件夹中有一个<code class="fe nj nk nl nm b">Sites</code>文件夹)。使用下面的命令来下拉这个库的<code class="fe nj nk nl nm b">original</code>分支:</p><p id="9a8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>下面的Git命令是一个已经换行的单行。确保复制并粘贴整个内容。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="6b4a" class="nr ly it nm b gy ns nt l nu nv">git clone -b original <a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter-dbscripts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/crmcmullen/medium-php-api-starter-dbscripts.git</a> phpapistarter_dbscripts</span></pre><p id="b2be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开您最喜欢的MySQL工具(我使用MySQL Workbench)并运行<code class="fe nj nk nl nm b">apistarter.sql</code>。这将构建将在该项目中使用的数据库和数据库用户。</p><p id="561c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一次运行<code class="fe nj nk nl nm b">apistarter_app_api_key.sql</code>。这将构建<code class="fe nj nk nl nm b">app_api_key</code>表，向其中插入一条我们将在示例中使用的记录，然后在表上构建一个视图。</p><p id="14c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据库到此为止。很简单。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9535" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">服务器端API后端</h1><p id="0f7d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">接下来，拉下API的后端代码。我再次打开终端，导航到我的<code class="fe nj nk nl nm b">Sites</code>文件夹。在我的项目中，我为API服务器代码使用了一个名为<code class="fe nj nk nl nm b">phpapistarter</code>的文件夹，您会看到它在代码中被引用为API主机。如果您使用不同的文件夹，请确保在代码中更新该文件夹。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="e012" class="nr ly it nm b gy ns nt l nu nv">git clone -b original <a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter.git" rel="noopener ugc nofollow" target="_blank">https://github.com/crmcmullen/medium-php-api-starter.git</a> phpapistarter</span></pre><p id="8354" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">API服务包含以下文件:</p><h2 id="a630" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated"><strong class="ak">index.php</strong></h2><p id="ba53" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">允许跨来源请求的简单页面。它预先要求所有必需的类，验证传入的API请求，并将函数请求交给API处理程序。</p><h2 id="0091" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated"><strong class="ak"> /src/api_handler.php </strong></h2><p id="517c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这是API服务的核心。函数将所有面向公众的端点和它们所属的类预加载到一个数组中。如果需要，数组允许您在内部给函数起别名。例如，如果面向公众的端点是<code class="fe nj nk nl nm b">getToken</code>，但是在你的代码内部，你将<code class="fe nj nk nl nm b">function_name</code>称为<code class="fe nj nk nl nm b">fnGetToken</code>，你可以这样做。在第一个版本中，唯一有效的终点是<code class="fe nj nk nl nm b">getToken</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/334bf6a3be3627819dbcc9e72429eca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jmOOc8rXUpr_1ReQWR4Wg.png"/></div></div></figure><p id="7c23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">未来的端点需要添加到此阵列中。如果终结点不在数组中，将向客户端引发无效的方法调用错误。</p><p id="2650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">validateRequest</code>函数评估请求以确保它包含API密钥和令牌，检索调用者的<code class="fe nj nk nl nm b">app_api_key</code>记录并使用API密钥解码JWT。然后，它确保所有内容都匹配，并且令牌没有过期。</p><p id="c92b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">getCommand</code>函数从函数映射中检索类和内部函数名，<code class="fe nj nk nl nm b">execCommand</code>将其转换成带有相关参数的函数调用。</p><p id="a49f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然,<code class="fe nj nk nl nm b">getToken</code>命令是API处理程序中的核心API端点命令之一，也是本演示的重点。</p><h2 id="8b65" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated"><strong class="ak">/src/app _ auto loader . PHP</strong></h2><p id="f889" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这个文件预先注册了所有将被API引用的类，并将加速类的加载。</p><h2 id="98ec" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/src/app_jwt.php</h2><p id="e8bc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这个类建立在由Neuman Vong和Anant Narayanan <a class="ae nd" href="https://github.com/firebase/php-jwt" rel="noopener ugc nofollow" target="_blank">提供的JSON Web Token编码器/解码器代码之上。</a></p><h2 id="7663" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/src/app_response.php</h2><p id="ab84" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一个简单的类库，提供标准的HTML响应代码和描述。</p><h2 id="5c77" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/src/db _ class/data _ access . PHP</h2><p id="21bd" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这个抽象类由其他数据库类扩展，通过<code class="fe nj nk nl nm b">db_connect</code> <em class="oi"> </em>函数提供到MySQL数据库的连接，以及一个用<code class="fe nj nk nl nm b">getResultSetArray</code>检索<code class="fe nj nk nl nm b">ResultSet</code>数组的抽象函数。</p><p id="a096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe nj nk nl nm b">db_connect</code>有硬编码的连接变量。这些将在后面的项目中被替换，我们将把它们移动到一个INI文件中。</p><h2 id="972a" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/src/db _ classes/app _ API _ key . PHP</h2><p id="86d2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这是数据库表<code class="fe nj nk nl nm b">app_api_key</code>的数据库类。目前，它只有一个方法，那就是为API密钥检索调用者的API记录，以便对令牌进行编码/解码。</p><p id="de65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是API服务。当然，它只有一个自己的终点。但是框架现在已经就绪，可以在将来添加其他API端点。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="fb76" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">客户端应用程序</h1><p id="a6b1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">对于客户端应用程序，我使用了一个名为<code class="fe nj nk nl nm b">phpapistarter_client</code>的文件夹。您可以通过导航到您的<code class="fe nj nk nl nm b">Sites</code>文件夹并使用以下命令来获取代码:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="4973" class="nr ly it nm b gy ns nt l nu nv">git clone -b original <a class="ae nd" href="https://github.com/crmcmullen/medium-php-api-starter-client.git" rel="noopener ugc nofollow" target="_blank">https://github.com/crmcmullen/medium-php-api-starter-client.git</a> phpapistarter_client</span></pre><p id="817a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你和我使用相同的项目文件夹(如<code class="fe nj nk nl nm b">phpapistarter</code>和<code class="fe nj nk nl nm b">phpapistarter_client</code>，你可以立即在<code class="fe nj nk nl nm b"><a class="ae nd" href="http://localhost/phpapistarter_client" rel="noopener ugc nofollow" target="_blank">http://localhost/phpapistarter_client</a></code>的浏览器中打开这个项目并开始玩它。</p><p id="4343" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个客户端应用程序真的不是火箭科学。这是一个包含两个JavaScript文件的页面。</p><h2 id="eba4" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">index.php</h2><p id="3bc1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果不存在cookie，该页面将对<code class="fe nj nk nl nm b">getToken</code>端点进行API调用以检索令牌。然后，它将令牌打包到一个cookie中。</p><p id="f355" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到API键和API主机是硬编码的。后续文章将把这些值移到INI文件和数据库表中，这样它们就不会出现在源代码中。我只是想把事情简单化。</p><p id="e8cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，从流程的角度来看，这将是您在生产中检索令牌的方式，因为整个事务将在写入页面之前发生在服务器端。</p><p id="765b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">页面本身的HTML部分非常简单。它显示创建的令牌，并提供一个按钮来删除它，第二个按钮通过对完全相同的API的JavaScript调用来检索新的令牌。这为您提供了代码，展示了如何在PHP和JavaScript中进行相同的API调用。</p><p id="a4e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还使用Bootstrap来添加一些基本的CSS。</p><h2 id="bef3" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/js/API _ handle . js</h2><p id="f54a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这个Javascript文件是一个通用的jQuery API处理程序。给它传递一些变量，它会为您进行调用，然后执行回调。</p><p id="6803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，您不会将API键或API主机作为变量传递。取而代之的是，这个JavaScript将检索cookie，获得这些变量和令牌，并在API调用中传递它们。然而，由于这个演示可能会在没有cookie的情况下进行API调用，所以我们需要做一些不同的事情。</p><p id="ae6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，后面的文章将解决这个问题。PHP代码将总是创建cookie，这个JavaScript将从中提取它所需要的内容以供后续调用。</p><h2 id="ce3c" class="nr ly it bd lz nw nx dn md ny nz dp mh ld oa ob mj lh oc od ml ll oe of mn og bi translated">/js/cookie_handler.js</h2><p id="21d3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一个JavaScript文件，具有非常基本和通用的cookie处理功能。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="afba" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="552d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">本文到此为止。有了这一小段演示代码，您就有了一个PHP restful-API服务的良好开端。我将撰写一些基于这个项目的文章，并向您展示如何在服务器上设置API处理程序，以调用其他真实类型的类，甚至连接其他服务，如SendGrid电子邮件或Google reCAPTCHA验证。</p><p id="0534" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章和支持代码对您的项目有所帮助。</p></div></div>    
</body>
</html>