<html>
<head>
<title>Modify Variables In Go Binaries During Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在构建期间修改Go二进制文件中的变量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modify-variables-in-go-binary-during-build-51b61cee86a8?source=collection_archive---------9-----------------------#2022-03-11">https://betterprogramming.pub/modify-variables-in-go-binary-during-build-51b61cee86a8?source=collection_archive---------9-----------------------#2022-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可以在构建期间使用build命令设置变量值，例如版本号、客户机id。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be8ba9ccf4526118de002c00e8f2cb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeLTkn_pHRlgKFo3EGUrAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="c5a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您是否曾经使用过硬编码的版本号，或者尝试过将配置传递给表示软件版本的二进制文件？</p><p id="4579" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我试过了，而且很有效，但是很容易出错。很容易忘记更改配置等，或者跨多个合并请求维护版本。</p><p id="f3d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我终于找到了一个很好的解决方案，我们可以在编译期间通过添加编译标志来修改二进制文件中的变量。这允许我们设置CI/CD来传递git commit作为版本等等，或者让不同的版本基于部署指定runner ID。</p><p id="98c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这种方法可以更容易地维护和控制特定的值，因为我们可以很容易地将它们放在CI/CD中。我们可以通过利用链接器标志来做到这一点。</p><p id="582f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你更愿意看视频教程，可以看下面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本教程的视频</p></figure><h2 id="e32a" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">链接器&amp; Ldflags</h2><p id="4961" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated"><code class="fe mu mv mw mx b">go build</code>工具允许我们将选项传递给<a class="ae my" href="https://en.wikipedia.org/wiki/Linker_(computing)" rel="noopener ugc nofollow" target="_blank">链接器</a>，它是负责组装二进制文件的组件。</p><p id="7981" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过使用构建工具的<code class="fe mu mv mw mx b">--ldflags</code>标志将选项传递给链接器。有很多选项可以传递，但是在本文中，我们将只关注其中的一个。<code class="fe mu mv mw mx b">--ldflags</code>接受一串配置，因此输入将被<code class="fe mu mv mw mx b">""</code>括起来。</p><p id="0e2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过运行带有<code class="fe mu mv mw mx b">--help</code>选项的构建来查看所有选项。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="b5c8" class="lw lx it mx b gy nd ne l nf ng">go build --ldflags="--help"</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成工具中可用的所有链接器选项</p></figure><p id="6f4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们感兴趣使用的选项是<code class="fe mu mv mw mx b">-X</code>选项。这是帮助打印中的定义。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="4e0d" class="lw lx it mx b gy nd ne l nf ng">-X definition        add string value definition of the form importpath.name=value</span></pre><p id="1698" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，我们可以使用<code class="fe mu mv mw mx b">-X</code>标志，通过使用导入路径(您用来导入包的路径)和使用<code class="fe mu mv mw mx b">.variableName</code>使用它的名称，然后使用我们想要的值，来定位我们想要修改的变量。</p><p id="de7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个简单的示例项目来尝试一下。</p><h2 id="b995" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">-X，设置变量值</h2><p id="8838" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">首先创建一个新项目，我使用模块名<code class="fe mu mv mw mx b">programmingpercy.tech/buildflags</code>。这一点很重要，因为它稍后将被用作导入路径。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="1ebe" class="lw lx it mx b gy nd ne l nf ng">mkdir buildflags<br/>go mod init programmingpercy.tech/buildflags<br/>touch main.go<br/></span></pre><p id="36b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将用一个简单的函数填充<code class="fe mu mv mw mx b">main.go</code>,打印版本和客户名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —打印变量值的简单程序。</p></figure><p id="50ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以尝试通过构建和运行程序来查看输出。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="f6aa" class="lw lx it mx b gy nd ne l nf ng">go build -o main &amp;&amp; ./main<br/>// Outputs<br/>2022/03/08 19:23:28 Starting runner client-1.0.0 version 0.0.1</span></pre><p id="ba7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试重新构建二进制文件，但这次我们将使用<code class="fe mu mv mw mx b">--ldflags</code>并应用<code class="fe mu mv mw mx b">-X</code>命令将runner设置为<code class="fe mu mv mw mx b">client-2.0.0</code>。我们工作的包是<code class="fe mu mv mw mx b">main</code>，所以这将是导入路径。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="7b2d" class="lw lx it mx b gy nd ne l nf ng">go build -o main --ldflags="-X 'main.runner=client-2.0.0'"</span></pre><p id="071f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尝试再次运行程序，并查看输出，更改跑步者名称。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="0f54" class="lw lx it mx b gy nd ne l nf ng">./main<br/>// Outputs<br/>2022/03/08 19:27:21 Starting runner client-2.0.0 version 0.0.1</span></pre><p id="1701" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以修改多个标志，你需要做的就是在命令中添加一个新的<code class="fe mu mv mw mx b">-X</code>标志。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="62c9" class="lw lx it mx b gy nd ne l nf ng">go build -o main --ldflags="-X 'main.runner=client-2.0.0' -X 'main.version=0.0.2'"</span></pre><p id="8891" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你应该试着运行二进制，不出意外，版本也变了。</p><p id="57cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更好的是，如果你愿意的话，你也可以将目标指向子包。为此，创建一个名为<code class="fe mu mv mw mx b">version</code>的子文件夹，并添加一个名为<code class="fe mu mv mw mx b">version.go</code>的文件，该文件包含变量<code class="fe mu mv mw mx b">Version</code>而不是<code class="fe mu mv mw mx b">main.go</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">version/version.go —我们将要修改的子包</p></figure><p id="372a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保我们更新<code class="fe mu mv mw mx b">main.go</code>以使用令人惊叹的新版本包。</p><blockquote class="ni nj nk"><p id="8b78" class="ky kz nl la b lb lc ju ld le lf jx lg nm li lj lk nn lm ln lo no lq lr ls lt im bi translated">实际上，我并不推荐你有一个版本包，但是你应该明白</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —现在使用构建包的主包。</p></figure><p id="5ae7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以尝试重建二进制文件，并确保使用<code class="fe mu mv mw mx b">-X</code>标志更新版本号。这一次，您可以传递完整的导入路径，即模块名称。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="9233" class="lw lx it mx b gy nd ne l nf ng">go build -o main --ldflags="-X 'programmingpercy.tech/buildflags/version.Version=0.0.2' -X 'main.runner=client-1.0.1'"</span></pre><p id="24a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行该二进制文件时，您应该会看到值发生了变化。</p><h2 id="1a91" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">将Git提交标记添加为版本</h2><p id="e846" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">一件很酷的事情是，现在我们可以在构建期间修改值，您可以通过使用git commit等来自动化版本处理。</p><p id="69c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在项目的文件夹中，我们将初始化一个git存储库并提交当前文件，这样我们就可以获得一个提交散列。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="6ac4" class="lw lx it mx b gy nd ne l nf ng">git init<br/>git add .<br/>git commit -m "test"</span></pre><p id="9497" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要打印一个简短的提交散列，可以使用下面的git命令。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="7fc4" class="lw lx it mx b gy nd ne l nf ng">git rev-parse --short HEAD</span></pre><p id="1527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以简单地将其注入到<code class="fe mu mv mw mx b">-X</code>标志中，并设置该输出的值。</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="2d45" class="lw lx it mx b gy nd ne l nf ng">go build -o main --ldflags="-X 'programmingpercy.tech/buildflags/version.Version=$(git rev-parse --short HEAD)' -X 'main.runner=client-1.0.1'"</span></pre><p id="9971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，用这个二进制文件运行程序会打印出以下结果</p><pre class="kj kk kl km gt mz mx na nb aw nc bi"><span id="6b66" class="lw lx it mx b gy nd ne l nf ng">2022/03/08 20:54:35 Starting runner client-1.0.1 version f525917</span></pre><h2 id="324b" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">结论</h2><p id="4bad" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们用的例子很简单，但是你可以用它做很多事情。我已经看到了被注入的版本、特性标志等等。对于客户机之间应该不同的特性标志，一个简单的解决方案是为启用的函数传递一个真值。这可能是最容易使用的特征标志解决方案，不需要框架来管理它。</p><p id="80a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我的看法，拥有这些标志的最佳位置是在CI/CD中，以控制不同的发布、版本和客户机id。</p><p id="3fb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你觉得这很有趣，我发现当我学习这个的时候它非常有用。</p><p id="87fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你已经在使用ldflags了吗，如果是，是为了什么？以及你能想到的用例有哪些？我很想听听你对这些旗帜的看法。</p></div></div>    
</body>
</html>