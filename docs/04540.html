<html>
<head>
<title>Solidity vs. Ligo: The Main Differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity与Ligo的主要区别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-vs-ligo-the-main-differences-e763a52ba2d7?source=collection_archive---------18-----------------------#2020-04-20">https://betterprogramming.pub/solidity-vs-ligo-the-main-differences-e763a52ba2d7?source=collection_archive---------18-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a62c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当你来自以太坊时，你需要知道在Tezos区块链上写智能合同</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2839b9dc4760aeaa1987ddab249cca18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FgtpslDfiA2uphTDJ14Dw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.vecteezy.com/free-vector/boxer" rel="noopener ugc nofollow" target="_blank">由Vecteezy提供的Boxer Vectors</a></p></figure><p id="278e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">泰佐斯区块链是2020年你需要关注的主要项目之一。其流动性的股权证明制度对寻求稳定收入的人越来越有吸引力。自去年12月以来，其代币价格已经上涨了一倍多，令投资者颇感兴趣。还有许多新项目计划在2020年部署在区块链上(一款<a class="ae kv" href="https://www.coindesk.com/tezos-co-founder-turns-to-gaming-with-hearthstone-competitor" rel="noopener ugc nofollow" target="_blank">基于NFT的游戏</a>、<a class="ae kv" href="https://usdtz.com/" rel="noopener ugc nofollow" target="_blank"> USDTez </a>和新<a class="ae kv" href="https://tzbtc.io/" rel="noopener ugc nofollow" target="_blank"> tzBTC </a>等等)。</p><p id="c23d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有一些以太坊区块链的经验，你正在考虑冒险尝试Ligo。恭喜你！然而，你会很快注意到，即使它们都被贴上了“区块链”的标签，在Tezos区块链和以太坊区块链上编程可能会像用两种不同的语言编程一样不同。在用Ligo编码时，您从Solidity中了解到的一些概念并不适用(甚至可能适得其反)。同样，Ligo中的一些概念在Solidity中并不存在。</p><p id="23a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看看主要的区别、陷阱，以及当您习惯了Solidity并希望加入我们成为Tezos智能合约开发人员时需要记住的事情。</p><p id="796a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设你对可靠性和JavaScript有(相当)好的了解。不需要Ligo的知识，尽管它可以帮助你更好地理解比较。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="91e4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">类型系统</h1><p id="1e81" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Solidity和Ligo中简单值的类型系统非常相似。Ligo有整数、字符串、地址、NAT(Solidity的无符号整数)、布尔等。Ligo类型的一个好处是你可以声明你自己的类型，它允许你的代码有一个更好的结构和组织。例如，有时创建一个新类型而不是使用一个原始类型(用<code class="fe mw mx my mz b">username</code>代替<code class="fe mw mx my mz b">string</code>，<code class="fe mw mx my mz b">score</code>代替<code class="fe mw mx my mz b">nat</code>)可能会更清楚。</p><p id="a01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复杂类型呈现出更多的差异:Ligo有元组、集合和列表，但没有数组。集合可以看作是无序的数组，包含相同类型的唯一值，而列表可以看作是有序的数组，包含相同类型的值。Ligo还提供了许多方法来读取、修改或返回关于集合和列表的信息，这非常方便。</p><p id="19a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ligo还提供了非常有用的<code class="fe mw mx my mz b">records</code>，在坚固性上与<code class="fe mw mx my mz b">structs</code>相似。Ligo没有枚举，但是它的<a class="ae kv" href="https://ligolang.org/docs/language-basics/unit-option-pattern-matching#variant-types" rel="noopener ugc nofollow" target="_blank">变种</a>给了你枚举的所有功能和额外的好处！当验证提供了正确的值时，一种叫做<code class="fe mw mx my mz b">option</code>的特殊变体会让你避免很多错误。</p><p id="ab55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity和Ligo的另一个主要区别是它的映射(Solidity的映射)，这是下一段的主题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="22b9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">地图和大地图</h1><p id="1c52" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Ligo提供了地图和大地图，它们的行为本质上是一样的。大地图更适合包含大量数据。它们类似于坚固性的映射，但有一些好处。</p><p id="c070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Solidity中，一个映射的所有键都是缺省存在的，如果你试图获得与一个不存在的键相关联的值，你将获得其类型的缺省值。Ligo就不是这样的。多亏了模式匹配，当您在map中查询一个值时，您可以精确地知道它是否返回某个值。如果没有返回任何内容，您将得到一个值为 <code class="fe mw mx my mz b"><a class="ae kv" href="https://ligolang.org/docs/language-basics/unit-option-pattern-matching#optional-values" rel="noopener ugc nofollow" target="_blank">None</a></code>的<a class="ae kv" href="https://ligolang.org/docs/language-basics/unit-option-pattern-matching#optional-values" rel="noopener ugc nofollow" target="_blank">选项。您不必担心返回的<code class="fe mw mx my mz b">0</code>或空字符串是实际值还是默认值，因为键不存在！</a></p><p id="d46e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Ligo中，可以迭代一个映射(这在Solidity的映射中是不可能的)。当迭代一个映射时，你可以检查返回值，你可以修改它们或者你可以"<a class="ae kv" href="https://ligolang.org/docs/language-basics/maps-records#folded-operations-over-maps" rel="noopener ugc nofollow" target="_blank">折叠</a>"它们。来自Solidity(或JavaScript之类的语言)需要花一些时间来适应的一个特性是，您将使用的函数不是map(或set/list)实例的方法，而是Map (list/set)对象的方法。例如，如果你想知道地图的大小，你不会写<code class="fe mw mx my mz b">my_map.size()</code>而是<code class="fe mw mx my mz b">Map.size(my_map)</code>。要添加一个元素到集合中，你不应该写<code class="fe mw mx my mz b">my_set.add(el)</code>而是<code class="fe mw mx my mz b">Set.add(el, my_set)</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3989" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">字符串操作和集合/列表</h1><p id="f1cd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我将这两种不同的情况放在一起，因为它们是小亮点，会使您的工作更容易，代码更安全。</p><p id="c91e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity因缺乏任何类型的原生字符串操作而臭名昭著——你不能分割它们，连接它们，等等。庆幸吧，因为Ligo让你这么做！有三种方法可以帮助你处理字符串。<code class="fe mw mx my mz b">String.length()</code>将返回字符串的长度，<code class="fe mw mx my mz b">String.sub()</code>将返回字符串的子串，字符串可以很容易地用<code class="fe mw mx my mz b">++</code>操作(<code class="fe mw mx my mz b">string1 ++ string2</code>)在ReasonLigo中连接起来。</p><p id="45cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Ligo中编写智能合同时，我特别喜欢使用集合和列表。集合是同一类型的唯一值的无序列表。有几个函数可以帮助你轻松地操作它们(<code class="fe mw mx my mz b">Set.add()</code>、<code class="fe mw mx my mz b">Set.remove()</code>)，并且你可以确保它们中有唯一的不重复的值。</p><p id="309f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列表是相同类型元素的有序集合。如果需要按照一定的顺序存储一些值，就用这个。不同的方法可以帮助你处理列表，比如<code class="fe mw mx my mz b">List.iter()</code>、<code class="fe mw mx my mz b">List.map()</code>和<code class="fe mw mx my mz b">List.fold()</code>。这些类型为您的智能合约增加了另一个级别的安全性和健壮性。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="605e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">合同部署和初始化</h1><p id="4905" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">成为一名智能合同开发人员的一个亮点是将您的合同部署到区块链，并让它开始独立的生活！</p><p id="47e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在Solidity中编写一个智能合同时，你通常从构建<code class="fe mw mx my mz b">constructor</code>开始。此功能负责在部署合同期间初始化存储。这在Ligo是不存在的。没有构造函数。相反，您需要在部署智能合同时提供初始存储！在Tezos的行话中，它被称为“<em class="na">发起合同</em>”。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d1b5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">入口点</h1><p id="1722" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Tezos区块链上使用智能合约的逻辑与在以太坊区块链上使用合约的逻辑有些不同。在Solidity中，你的契约有多个访问点，你可以直接调用它们来修改或返回一些数据。这就产生了对“后备功能”的需求，以防用户试图调用一个不存在的功能。</p><p id="e731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Ligo中，智能合约只有一个访问点，称为入口点。这一开始听起来可能有点奇怪(对我来说确实如此)，但它实际上是一个强大的系统，消除了对后备功能的需求。您的主入口点接收您试图调用的函数的名称作为参数，并将使用模式匹配来确保该函数存在。然后，它将调用称为“伪入口点”的匹配函数如果它不存在，它只会失败。在Solidity中，调用一个不存在的函数会触发回退功能。在Ligo中，它抛出一个错误。</p><p id="2c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:Ligo中智能契约的主入口点只接受两个参数:一个参数随事务和存储一起发送。不可能像在Solidity <code class="fe mw mx my mz b">function myFunc(param1 uint, param2 uint, param3 string)</code>中那样提供多个参数。但是，您可以向函数发送记录。当以错误的顺序传递参数时，这种限制有助于避免在可靠性方面的常见错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="51f5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">状态更新</h1><p id="97d8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Solidity和Ligo的另一个主要区别在于事务流。在Solidity中，当您向智能合约发送事务时，智能合约的状态会一直更新，直到事务到达函数的末尾。如果流程中的任何一点出现错误(例如由<code class="fe mw mx my mz b">assert</code>或<code class="fe mw mx my mz b">require</code>异常抛出)，状态将恢复到事务发生前的原始值。如果你不注意更新状态的时间和方式，你的代码就容易受到<a class="ae kv" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy-on-a-single-function" rel="noopener ugc nofollow" target="_blank">重入攻击</a>。</p><p id="d9b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在泰佐斯区块链上签订一份聪明的合同，再入攻击是不太可能的。在Ligo中，主入口点<em class="na">总是</em>返回两件事:要执行的事务列表和新状态。在交易流程的任何时候，智能合约的存储都不会改变。如果有一个错误，交易将停止，没有任何改变。由于该函数返回整个存储，模式匹配将确保您返回具有预期值的正确存储。如果您的存储属性应该是nat，则不可能存储整数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b137" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模式匹配</h1><p id="88cd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">模式匹配是Ligo智能合约的特性之一，它将帮助你使它没有错误。下面是两个模式匹配的例子，但这是一个内置的特性，它将证明自己在您的智能合约中非常有用！</p><h2 id="2708" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">在伪入口点中</h2><p id="e9a0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如前所述，在你的Ligo智能合约中只有一个“真正的”切入点。通过模式匹配，它将负责将事务调用重定向到正确的函数。让我们来看看Ligo网站上提供的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/54880d3ac2e543fa6688933c405f92cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rjnj9VOgzXbzmyMIggQ2mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">交易流程</p></figure><p id="1283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当事务到达智能合约时，将根据其名称和参数对其进行评估。如果参数的类型匹配，它将通过开关模式被重定向到相应的函数。在函数处理完事务后，新的存储被返回。</p><h2 id="23d9" class="nb ma iq bd mb nc nd dn mf ne nf dp mj lf ng nh ml lj ni nj mn ln nk nl mp nm bi translated">在更新地图时</h2><p id="0afc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当你想更新地图时，模式匹配是一个强大的盟友。</p><p id="f526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Solidity中，当更新一个映射时，你必须大胆猜测，并假设这个键已经用一个值初始化了(因为默认情况下所有的键都存在)。有时这是一种理想的模式——例如，如果您想要创建一个新的键，因为向一个之前在映射中没有初始化的键添加一个值将会创建它。</p><p id="6aa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Ligo中，不可能给一个map中不存在的键添加值。地图的每次搜索和更新都要经过模式匹配。假设我们有一个类型为<code class="fe mw mx my mz b">map(address, tez)</code>的映射，它存储了用户拥有的tezzies的数量。这是您更新所提供地址的值的方式:</p><pre class="kg kh ki kj gt no mz np nq aw nr bi"><span id="04d5" class="nb ma iq mz b gy ns nt l nu nv">switch (<strong class="mz ir">Map.find_opt</strong> (user, wallets)) {<br/>  | Some (<strong class="mz ir">wallet</strong>) =&gt; Map.update(user, wallet + 1tez, wallets)<br/>  | None =&gt; <strong class="mz ir">failwith</strong> ("No wallet found") : return_type<br/>}</span></pre><p id="7e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这段代码中的内容。</p><p id="7212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Map.find_opt</code>是一个返回<a class="ae kv" href="https://ligolang.org/docs/language-basics/unit-option-pattern-matching#optional-values" rel="noopener ugc nofollow" target="_blank">选项类型</a>的函数，即只包含两个选项的变量类型。要么有(<code class="fe mw mx my mz b">Some</code>)要么没有(<code class="fe mw mx my mz b">None</code>)。如果找到了与该键相关联的值，则用<code class="fe mw mx my mz b">Some</code>返回该值。否则，返回<code class="fe mw mx my mz b">None</code>(在这种情况下，我们只是抛出一个错误，但是您也可以创建键/值对或完成另一个动作)。这样就不可能试图更新一个不存在的键的值。</p><p id="6819" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Solidity中，你应该写<code class="fe mw mx my mz b">wallets[user] += 1 ether</code>,因为默认情况下这个键是存在的，你不能控制它的存在。钱包也可能等于<code class="fe mw mx my mz b">0ether</code>，你不会知道它是一个理想值还是仅仅是默认值。在Ligo中，如果一个键的值是<code class="fe mw mx my mz b">0tez</code>，你知道它是被故意设置为等于0的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4b25" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">存储读数</h1><p id="6a4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我开始为Tezos区块链编写智能合同时，对我来说，Ligo和Solidity之间最令人困惑的区别之一是如何将合同存储中的值保存到我的dapp中。如前所述，Ligo契约的入口点总是返回整个存储和一个操作列表。如果你想返回一个单独的值，就不需要实现getter函数。此外，Ligo智能合约中的存储是一个单独的变量(通常是一个记录)，而不是像Solidity中那样是不同的独立变量。</p><p id="4b51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我开始玩dapps的库时，我才得到这个问题的满意答案，比如优秀的<a class="ae kv" href="https://tezostaquito.io/" rel="noopener ugc nofollow" target="_blank"> Taquito </a>。对于每一个来自Solidity并想知道Tezos智能合约如何导出其值以在dapp中使用它们的智能合约开发人员来说，简单的答案是:他们没有。它们不会返回任何值，但是你可以从外部读取它们。Tezos节点公开了契约存储，像Taquito这样的库可以让您访问整个存储(例如，如果使用Taquito，可以使用<code class="fe mw mx my mz b">await contractInstance.storage()</code>)。</p><p id="4560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity必须为你的变量自动创建getter函数，而Ligo不关心这个。在Ligo中，存储的每一个价值都离你只有一个承诺！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f309" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">坚固性的理想特征</h1><p id="7789" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我已经花了整篇文章试图向您展示为Tezos区块链编写智能合同是多么令人惊奇，那么让我们来看看当您转向Ligo时，作为一名Solidity开发人员将会错过的一些事情。</p><p id="d70f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，Tezos生态系统还没有达到以太坊生态系统的成熟度，许多工具和功能都有待开发。以下是一些有望进入智能合约和Tezos生态系统的公司:</p><ol class=""><li id="2a28" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><strong class="ky ir">事件。</strong>与以太坊不同，Tezos智能合约中没有事件。您不会收到智能合约状态已更改的通知。Taquito有一个监听存储变化的功能(<code class="fe mw mx my mz b">Tezos.stream.subscribeOperation</code>)，但我在一个沙盒节点上尝试了一下，有一半的存储更新没有注册。时至今日，获得存储更新通知的最可靠方式是一个很好的老式<code class="fe mw mx my mz b">setInterval</code>，它具有比较新获取的存储和旧存储的值的功能。</li><li id="a1a6" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><strong class="ky ir">混音。Remix就像是在线编写、测试和部署智能合约的圣杯。Ligo(就此而言，还有SmartPy)在创建在线编辑器方面做得很好，但与Remix相比，它们仍然显得脆弱。使用Ligo编辑器，您可以编写您的智能契约(变量名和方法/属性的语法高亮和自动补全非常简洁)，将它们编译到Michelson，测试您的入口点，并将其部署到Carthagenet(理论上)。然而，编辑器不会让你保存你的智能合同——在我的神奇鼠标上的一次错误点击意味着我不得不重新开始。要了解如何格式化您的存储初始值以测试智能合约入口点，需要一些尝试和失败。最后，没有用于测试的JavaScript VM。</strong></li><li id="b27e" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><strong class="ky ir"> MetaMask。</strong>很抱歉带来坏消息，但对于泰佐斯·区块链来说，没有超面具。在你找到(并接受)TezBridge之前，你会想知道dapp的用户如何签署他们的交易。TezBridge是一个很棒的工具，因为它允许dapp用户在不安装任何东西的情况下签署他们的交易，并且它与Taquito集成得很好。然而，您将会错过MetaMask的优雅、简单和方便。您将无法检查您的交易历史，您将看不到您的余额、您拥有的代币，并且您将无法从界面发送tezzies。TezBridge只做一件事，帮你签署交易，而且做得很好！</li><li id="0c65" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><strong class="ky ir">一般的工具。</strong>由于Tezos才成立两年，帮助您开发智能合约和dapps的可用工具仍处于起步阶段，非常匮乏。可用的文档通常不适合初学者，因为您必须对迈克尔逊和/或函数式编程有很好的了解，才能理解不完整或高度技术性的文档。如果你是一名初级JavaScript开发人员，可能需要花几个小时在Solidity中编写一个简单的智能契约，弄清楚如何在Remix中测试它，旋转Ganache和Truffle，并用web3js构建一个简单的dapp。换成Tezos就不会这样了(至少目前不会)。你将不得不做一些研究，阅读文档，在Ligo Telegram上窃听那些了不起的、非常有帮助的人，并且不断尝试和失败，直到你找到正确的方法。</li><li id="5ff2" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><strong class="ky ir">资源丰富。无论你是想在Solidity中创建一个简单的智能合同，使用OpenZeppelin，还是创建可升级的合同或开发下一个DeFi hit，都有无数的教程可以指导你。Tezos就不是这样了。你会找到一些简单的教程，但是对于更高级的概念，教程很少或者根本不存在。学习Ligo将要求您对函数式编程有一个基本的了解(尽管ReasonLigo使它变得容易得多)。我能找到的许多智能合同都是用PascaLigo编写的，这给初学者增加了另一层复杂性。</strong></li></ol><h1 id="e864" class="lz ma iq bd mb mc ok me mf mg ol mi mj jw om jx ml jz on ka mn kc oo kd mp mq bi translated">结论</h1><p id="b66b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可以想象，从Solidity切换到Ligo需要耐心和大量的阅读。你必须学会如何为智能合约使用一种新的编程语言，这种语言与Solidity截然不同。您需要找到新的工具来帮助您测试您的智能合约并开发您的dapps。您需要学习如何从您的应用程序中与Tezos上的智能合约进行交互。</p><p id="66fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你像我一样是一个自学成才的开发人员，你需要一些时间来弄清楚所有的东西是如何一起工作的。然而，这是一个非常值得的过程。在过去的几个月里，我学到了很多关于函数式编程、智能合约、Tezos和dapps的知识。如果您继续在Solidity中编写智能合同，那么浏览一下创建它们的另一种方法可能会帮助您成为一名更好的开发人员。只是要小心——为Tezos编写智能合同是非常容易上瘾的，只要你意识到它们是多么安全、健壮和优雅！</p><p id="2551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要犹豫，留下你的意见或建议！</p></div></div>    
</body>
</html>