<html>
<head>
<title>Custom Events in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的自定义事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-events-in-rust-c4e534b6b8cb?source=collection_archive---------5-----------------------#2020-11-16">https://betterprogramming.pub/custom-events-in-rust-c4e534b6b8cb?source=collection_archive---------5-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义和实现可重用的事件信号</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ca6f2821c99a3b88a1043d3fec6dbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5zWXIr33nELMpNyk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米奇·奥尼尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="501c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">(我最近发布了这篇文章</em>  <em class="lv">的升级版</em> <a class="ae ky" href="https://rossketeer.medium.com/rust-events-revisited-926486721e3f" rel="noopener"> <em class="lv">，它解释了一个更好的解决方案，但是如果你愿意，请继续按顺序阅读！)</em></a></p><p id="0e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust是一种年轻而令人兴奋的系统语言，在广泛的应用领域有很大的潜力。Rust程序可以针对任何平台进行构建。如果人们开始使用Rust编写操作系统之类的东西，我不会感到惊讶(而且人们已经在使用Rust构建很酷的东西了)。Rust最不可思议的地方在于它是内存安全的——Rust中甚至不存在一整类行业瘫痪性的隐伏错误。微软甚至在未来的项目中支持Rust。也许有一天它甚至会成熟到取代C家族语言！不管怎样，Rust将会继续存在，我感觉在不久的将来它将会是一个主要的玩家，至少在物联网和网络领域。</p><p id="0482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，今天我想谈谈我们如何在Rust中制作一个事件信号系统。让我们从发出事件的信号和处理事件的接收器的角度来考虑事件。在Rust中，我们可以将这些品质翻译成<code class="fe lw lx ly lz b">trait</code> s。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/b346ed1cd777e16988fbcbdd3529fa6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arL__20PTpKYgdBpMiGT1w.png"/></div></div></figure><p id="91c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe lw lx ly lz b">Sig</code>和<code class="fe lw lx ly lz b">Rec</code>特征具有必须在实现者上声明的相关类型。<code class="fe lw lx ly lz b">Data</code>和<code class="fe lw lx ly lz b">Receiver</code>对应的是编译时可以知道的硬类型。这样，内容可以保持大小不变，我们可以利用拷贝和克隆的优势。在<code class="fe lw lx ly lz b">Sig</code>特性中，我们定义了三个额外的接口函数。<code class="fe lw lx ly lz b">emit</code>向接收者发送一条数据。<code class="fe lw lx ly lz b">conn</code>连接一个新的接收器并返回给我们。<code class="fe lw lx ly lz b">disc</code>通过接收器的<code class="fe lw lx ly lz b">usize</code> id断开接收器。<code class="fe lw lx ly lz b">Rec</code>也有一些功能。<code class="fe lw lx ly lz b">on_emit</code>是我们的接收者对事件发射的响应。<code class="fe lw lx ly lz b">get_id</code>只是给我们一些<code class="fe lw lx ly lz b">usize</code>值，这些值在我们的接收器集合中是唯一的。</p><p id="f3cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Sig</code>和<code class="fe lw lx ly lz b">Rec</code>是我们需要发送和接收事件信号的基本接口。但是由于实现它们需要为每个不同的事件和侦听器做大量的工作，所以我选择了一种不同的方法——我们将在一个可重用的声明性宏中编写所有的实现逻辑。宏会吓到一些人，但是锈宏并不邪恶。恰恰相反，它们实际上是高效和有用的，不仅仅是像c中那样替换文本。我们可以用<code class="fe lw lx ly lz b">macro_rules!</code>定义一个新的声明性宏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/b90c6ca9cb2038fb88648657fbcd5266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMV87zVjUoOE5qoVlXcfjw.png"/></div></div></figure><p id="7239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就产生了一个名为<code class="fe lw lx ly lz b">def_signal</code>的宏，我们可以像调用函数一样调用它，但是在圆括号前有一个<code class="fe lw lx ly lz b">!</code>宏展开操作符(<code class="fe lw lx ly lz b">!</code>在Rust中用于宏展开之外时也代表<code class="fe lw lx ly lz b">never</code>类型)。</p><p id="73a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust中的声明性宏只是花哨的匹配臂模式。在我们的<code class="fe lw lx ly lz b">def_signal</code>宏中，我们只需要一个调用签名，所以我们只需要一个匹配臂。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/e36043a2ffbbc24e5526d6aa165fbee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0RDXcKByNdjAL2th6IVFA.png"/></div></div></figure><p id="88a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用后跟变量名和标记类型的<code class="fe lw lx ly lz b">$</code>来声明语法标记捕获。我们可以在Rust宏中使用许多不同的标记类型，对应于不同的语言语法。我们将在这里使用一些。s是标识符。在这里，任何合法的标识符都可以，只要它可以用作结构的名称。</p><p id="bd21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用我们的<code class="fe lw lx ly lz b">ident</code>作为<code class="fe lw lx ly lz b">Signal</code>和<code class="fe lw lx ly lz b">Receiver</code>实现者结构的名称，我们将使用这个宏来一般地定义它们。<code class="fe lw lx ly lz b">$data</code>捕获是一个<code class="fe lw lx ly lz b">ty</code>。<code class="fe lw lx ly lz b">ty</code>对应于某种预先存在的类型。我们将使用这个参数来传递我们计划用作事件数据对象的结构。</p><p id="2516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们传入捕获<code class="fe lw lx ly lz b">$cls</code>，一个<code class="fe lw lx ly lz b">expr</code>。是有效Rust语法的任何表达式。我希望<code class="fe lw lx ly lz b">$cls</code>是一个闭包，我们将使用它作为事件的回调。</p><p id="7496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始研究宏之前，有一件事我们应该做。到目前为止，我们的特征期望我们的实现者拥有惟一的id。让我们编写一个简单的计数器来生成可以用作id的<code class="fe lw lx ly lz b">usize</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/c6b3b99480eda5a93d980b4232446369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGa3h2xtvBr9GqRHzRYySA.png"/></div></div></figure><p id="dd92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个简单的递增计数器。事实上，对于现实世界来说，这可能太简单了，但对于我们的目的来说，它肯定会起作用。我们可以使用它的当前状态通过ID来跟踪我们的<code class="fe lw lx ly lz b">Signal</code>的接收者。它只是创建一个对象，并在我们请求时创建该对象的增量副本。稍后，我们将详细说明这将如何为我们实现唯一的id。现在，让我们开始编写宏展开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/e7d493bf5bce229f4720d6e646a420d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Fahd9Jf3Z4pRN7JoX9LMg.png"/></div></div></figure><p id="c5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，一个宏可以扩展到几乎任何合法的Rust代码。包括命名结构！我们使用我们的<code class="fe lw lx ly lz b">ident</code>捕获作为<code class="fe lw lx ly lz b">Sig</code>和<code class="fe lw lx ly lz b">Rec</code>实现者的结构名。这样我们就可以从宏中选择命名我们的结构。我们也可以使用这些<code class="fe lw lx ly lz b">ident</code>来进行类型声明，就像在<code class="fe lw lx ly lz b">Vec&lt;$rec&gt;</code>中一样。查看生成的代码，我们在<code class="fe lw lx ly lz b">Signal</code>上使用了我们的<code class="fe lw lx ly lz b">Ctr</code>类型，这样它就可以向它用<code class="fe lw lx ly lz b">conn</code>生成的任何接收者提供唯一的id。我们将<code class="fe lw lx ly lz b">$sig</code>接收器存储在<code class="fe lw lx ly lz b">$rec</code>结构的<code class="fe lw lx ly lz b">Vec</code>中。我们的receiver结构很简单，只保存自己的ID。</p><p id="2dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们也可以制作<code class="fe lw lx ly lz b">impl</code>积木:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/60f5953033b72e3983df4a2fe0a20daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnBDf53O01w6HtT2C3AQIw.png"/></div></div></figure><p id="adb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以直接将实现块添加到我们的<code class="fe lw lx ly lz b">ident</code>和<code class="fe lw lx ly lz b">$sig</code>和<code class="fe lw lx ly lz b">$rec</code>中。我们添加了惯用的<code class="fe lw lx ly lz b">new</code>构造函数，并在<code class="fe lw lx ly lz b">$sig</code>上添加了一个助手来从它的<code class="fe lw lx ly lz b">Ctr</code>中获取下一个值。我们也可以在宏扩展中实现这些特征:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/62b491afd25e8745a3392cb0d6c42490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4KrybI-wv4CB9PMVEblPw.png"/></div></div></figure><p id="9765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在生成的<code class="fe lw lx ly lz b">$sig</code>结构上为<code class="fe lw lx ly lz b">Sig</code>写一个<code class="fe lw lx ly lz b">impl</code>块。这里发生了很多事情，但这将定义每个事件将实现的基本行为。</p><ul class=""><li id="2412" class="mb mc it lb b lc ld lf lg li md lm me lq mf lu mg mh mi mj bi translated">首先，我们定义我们需要的类型。这种做法将允许我们的事件在编译时知道它们的处理程序的大小，这很好。</li><li id="44f9" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">就像我们在trait契约中所做的一样，<code class="fe lw lx ly lz b">emit</code>将遍历连接的接收者列表，并向每个接收者发送一条消息。</li><li id="36d5" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lw lx ly lz b">conn</code>从计数器获取一个唯一的ID，构造一个新的接收者，将新的接收者推送到接收者的<code class="fe lw lx ly lz b">Vec</code>上，然后返回该接收者。</li><li id="b484" class="mb mc it lb b lc mk lf ml li mm lm mn lq mo lu mg mh mi mj bi translated">最后，<code class="fe lw lx ly lz b">disc</code>通过查找接收方的索引来断开连接，并调用<code class="fe lw lx ly lz b">Vec::remove</code>。</li></ul><p id="1758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从接收器<code class="fe lw lx ly lz b">Vec</code>中检查<code class="fe lw lx ly lz b">iter</code>的功能使用！我们可以通过向<code class="fe lw lx ly lz b">Iterator::position</code>函数传递一个谓词闭包来获取一个条目的索引。对于一门系统语言来说，非常具有表现力和抽象性！</p><p id="5f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该为我们的接收器结构实现<code class="fe lw lx ly lz b">Rec</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/43a70c97425dc8e93508986dd3e4ca14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pn5iDklpc5u0teZv7vrLGg.png"/></div></div></figure><p id="b25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个很简单。我们只需要定义我们的数据类型，我们期望通过宏调用得到它，从<code class="fe lw lx ly lz b">on_emit</code>中调用我们的<code class="fe lw lx ly lz b">$cls</code>闭包，并定义一个<code class="fe lw lx ly lz b">get_id</code>，它返回构造这个接收器的<code class="fe lw lx ly lz b">id</code>。现在我们已经有了样板文件，让我们创建一个测试信号，并对其进行一些处理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/2dcdc14498864aae3cc3b59052935b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXUUzhumBVZr_hdStBUgmw.png"/></div></div></figure><p id="861e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须在宏之外声明一个数据结构。<code class="fe lw lx ly lz b">MySigData</code>是一个保存i32值的简单结构。我们调用我们的<code class="fe lw lx ly lz b">def_signal!</code>宏，并分别为它提供我们想要的<code class="fe lw lx ly lz b">Signal</code>和<code class="fe lw lx ly lz b">Receiver</code>的名称。然后我们传递预定义的数据结构(<code class="fe lw lx ly lz b">MySigData</code>)。最后，我们有机会用最终的闭包参数在<code class="fe lw lx ly lz b">on_emit</code>中定义一些逻辑。让我们编写一个简单的测试来证明它是有效的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/864cb8d814432356f80af5a4610a3999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rz4Evl9PSGEZRdZnBdekqA.png"/></div></div></figure><p id="ad25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，看起来很成功。接收者在呼叫<code class="fe lw lx ly lz b">conn</code>后接收消息。如果<code class="fe lw lx ly lz b">disc</code>被调用，接收器将停止接收。只要我们恰当地处置了所有的接收器(当我们不再关心它们的订阅时)，我们也就不用担心编译器警告了！</p><p id="21c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">局限性在于，您可能必须使用enum数据类型来处理同一个事件的多个接收者。然后，在每个接收者的基础上适当地响应变量，以保持事情的预期大小。否则，宏将生成您需要的一切，以使一个微型事件系统脱离地面。</p><p id="0e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c791c9ed0f349ba2c2df4758d49b82c8" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">通往铁锈操场的一个链接。</strong>T19】</a></p><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢更多的Rust乐趣和实验。</p><p id="a8a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了看看我的其他材料。直到我的生锈之旅的下一章，FP上，读者们！</p></div></div>    
</body>
</html>