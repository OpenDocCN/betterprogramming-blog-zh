# 理解 C++ Const 的所有细节

> 原文：<https://betterprogramming.pub/understanding-all-the-details-of-c-const-4d2a4b714b63>

## 理解 const 限定符的细节非常重要，有助于提高代码质量和编码效率

![](img/44588ed54fc3fee62dea023bf293aa6b.png)

照片由 [Zany Jadraque](https://unsplash.com/@jenrielzany?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# C++常量

C++ `const`限定词是你学习 C++的第一件事。你通常从理解我们应该使用`const`作为常量开始。这可能是真的，但实际上我们应该把它看作是告诉编译器和其他程序员我们对代码的意图的一种方式。

当我们将`const`添加到一个变量时(后面还有其他用例讨论)，我们实际上是在说我们希望这个变量是 ***只读*** 或者不可变的。任何修改它的尝试都应该被编译错误所阻止。

在接下来的章节中，我将介绍我们可以在 C++代码中使用`const`限定符的不同场景，以及实际发生的情况。

## 常量变量

首先想到的，最简单的例子就是`const`变量。这可能是函数中的局部变量、类中的成员变量或全局变量。

添加一个`const`限定词的目的是明确表示我们的意图是让变量是只读的。例如，看看下面的函数:

这个函数表明作者希望参数`val`和局部变量`two`是只读的。这里没有什么特别的事情发生。这两个变量都像非常数变量一样存储在堆栈内存中。唯一的区别是，当我们试图改变这个值时，我们会得到一个编译错误。以下代码显示了修改`val`的尝试。

```
error: assignment of read-only parameter ‘val’
```

对于类中的`const`成员变量也是如此，非常数成员变量的唯一区别是，当我们试图修改它们时，我们会得到与上面相同的编译错误。

对于全局变量，还有一个区别，当我们给变量添加一个`const`限定符时，变量将被存储在内存的只读段而不是数据段。其余都一样。

所以很明显，`const`关键字是我们向编译器和其他程序员传达我们的意图的一种方式，告诉他们我们不希望变量在运行时改变。

## 函数返回常量

我发现这种情况很少见，但也是可能的。我们可以给函数的返回类型添加一个`const`限定符。只有当我们返回用户定义的类型，而不是像`int`这样的原始类型时，这才有意义。看看下面的例子:

注意，`CreateT()`返回一个临时变量，可以用来调用`SetVal()`。将返回值改为`const`可以防止这种情况发生。

```
error: passing ‘const T’ as ‘this’ argument discards qualifiers [-fpermissive]
```

编译器抛出这个错误是因为我们试图将一个指向`const`对象的指针传递给只接受非常数的`SetVal()`。以防你不知道或者忘记，调用成员函数意味着隐式地传递一个指针(**这个**指针)给函数。在这种情况下，

```
int SetVal(T* this, const int val);
```

将`const T*`传递给这个函数会导致编译错误，因为我们试图隐式删除`const`限定符。

然而，返回一个`const`对象有一个缺点，它阻止了从 C++11 引入的移动语义。现在，让我们假设我们的类`T`动态分配内存来管理它的一些成员变量。当然，我们希望使用移动语义来避免昂贵的复制过程。

如果`CreateT()`返回一个`const`对象，上面代码中的行`3`将调用复制赋值操作符，而如果它返回一个非常数对象，它将调用移动赋值操作符。这是因为编译器会选择接受`const`对象引用的复制赋值操作符重载。

所以除非你用的是旧版本的 C++，否则没有理由返回一个`const`对象。调用方最好不要调用试图修改临时对象的函数。

## 常量(成员)函数

限定符的另一个用途是用于类的成员函数。这种语法是独特的或者说是笨拙的，因为它被放在函数声明的末尾。

应该这样写，因为它限定的变量是隐藏的。回想一下，所有非静态成员函数都有一个指向自己的隐藏指针叫做 ***this*** 。我们在这里讨论的`const`限定符是用来限定指针的。

回到我们上面的例子，`T`类有一个名为`SetVal()`的成员函数。

```
int SetVal(const int val);
```

编译代码时，编译器会将其修改为:

```
int SetVal(T* this, const int val);
```

为了生成第一个变量`const`，我们需要将代码写成:

```
int SetVal(const int val) const;
```

因此，编译器将其修改为:

```
int SetVal(const T* this, const int val);
```

现在，忽略`SetVal()`成为`const`没有意义的事实，因为我们想要修改对象。我在这里要说明的是`const`限定符的存在使得 ***这个*** 指针指向一个`const`对象。

任何改变该函数中任何成员变量的尝试都将导致编译错误。另一个要点是我们上面讨论过的，当你声明一个类型为`T`的`const`对象时，你只能调用`const`函数。那是因为你不能将一个指向`const`对象的指针转换成一个指向非常数对象的指针，因为这会违反常量。

## 将常数转换为非常数，反之亦然

有些事情我觉得很困惑，尤其是对初学者来说。即通过引用或指针传递参数，从函数返回引用或指针。

令人困惑的部分是`const`限定词的不同。让我们看一些例子。

当我们在第`10`行调用`Process(input);`时，我们复制了`input`对象，从非常数版本转换到`const` `Input`版本没有问题，因为有两个副本。另一种方式也是正确的:

返回值也是一样，无论我们在哪里添加`const`限定符，它都会起作用，因为我们做了一个拷贝。

当我们处理推荐人时，就不一样了。当我们改变函数来接受`const`引用时，行为保持不变，我们可以传递`const`和非常数对象给它。

下面两个版本都可以。

但是当我们改变函数来接受下面显示的非常数引用时，我们只能传递非常数对象给它。

这是因为与按值传递不同，当我们使用引用时，我们不复制，我们使用同一个对象。因此，我们不能将对象的限定符从`const`更改为非常数。

下面的例子很有趣。

在这个例子中，我们将第`9`行上的`const`引用传递给一个通过值接受对象的函数。在这种情况下，它是有效的，即使我们从`const`变成了非常数。

由于编译器的魔力，这很令人困惑。参考只是引擎盖下的指针。编译器会为我们完成所有的转换工作。在这种情况下，会发生以下情况:

编译器将我们的代码修改为按值传递，所以在这种情况下，我们制作了它的副本。这就是为什么它有效。为了完成这个例子，在前面的版本中，这是编译器修改我们的代码后发生的情况:

当我们看到指针版本时，一切都变得更清楚了。

## 使用 const_cast 添加/删除 const 限定符

在上一节中我们已经看到，我们可以有一个指向非常数对象的`const`指针或`const`引用，反之则不可能。

现在，如果您有需要修改常量的场景，无论哪种方式，您都可以使用`const_cast`。以下是一些例子。

在这个例子中，库代码允许我们出于某种原因修改`value`。但是，我们决定我们不想这样做。在这种情况下，我们可以使用`const_cast`给它添加一个`const`限定符。

另一种方式也可以，但不推荐。

这段代码是可行的，因为第`7`行的原始变量`value`是非常量对象。所以我们可以删除`const`限定符并修改值。但是，如果原始变量是下面代码所示的`const`，那么结果就是*。*

*这段代码编译无误，但结果是 ***未定义*** 。该示例将打印以下内容(用 GCC 和 clang 测试):*

```
*mutableValue: 100
value after callback: 10*
```

*请注意，如果我们写对了代码，我们就不应该使用`const_cast`。唯一的用例可能是当我们处理给我们一个指向非常数对象的指针的库代码时，我们想通过把它修改成一个指向`const`对象的指针来使它更安全。*

# *关键要点*

*   *`const`限定符对于向编译器和其他程序员表达我们希望对象是只读的意图非常重要*
*   *当试图改变我们的只读变量时，编译器通过抛出错误来帮助我们执行检查*
*   *成员函数上的`const`限定符只是给`this`指针添加一个`const`限定符的语法*
*   *我们可以从函数中返回一个`const`值来防止临时的对象修改，但是这样做会产生意想不到的影响，即防止移动语义*
*   *我们可以使用`const_cast`来修改对象的常量，但是有效的用例非常少，例如在处理第三方遗留库时，您不能修改它*