<html>
<head>
<title>Angular CanActivate vs. Interceptors— A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角激活器与截击机——综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-vs-interceptors-guide-c256b72f3415?source=collection_archive---------2-----------------------#2019-08-10">https://betterprogramming.pub/angular-vs-interceptors-guide-c256b72f3415?source=collection_archive---------2-----------------------#2019-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="28f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在它们之间做出选择以得到你想要的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b20822332b54a9c8c5b3a1dfc5c9cec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QN4mRDGHkBlZUvdYHNxePA.jpeg"/></div></div></figure><p id="7a41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://angular.io/api/router/CanActivate" rel="noopener ugc nofollow" target="_blank"> CanActivate </a>和<a class="ae lq" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank">拦截器</a>都是操作和设置认证模式的伟大工具。但是它们经常被误解，因为它们看起来代表相似的机制，但是它们彼此之间却有很大的不同。</p><p id="6eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个工具之间唯一的共同点是它们都是实现角度接口的类，并且两个接口都需要实现一个方法。对它们进行编码非常简单。但是由于这些类没有通用的设计模式，所以很难选择使用哪一个或者更喜欢哪一个。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4d44" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">CanActivate界面</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/2062989cdf5d84f43e7e2697904fd4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgJAj4z-SXT06DnHkrEcyA.jpeg"/></div></div></figure><p id="990b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该接口要求该类实现<code class="fe mr ms mt mu b">canActivate()</code>方法，其参数是当前路线和状态。</p><p id="de52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该接口的主要目标是产生一个布尔值，指示当前路线是否可通过导航访问。</p><p id="7b30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个接口的重要之处在于，返回值可以是普通的布尔值、<code class="fe mr ms mt mu b">Promise&lt;boolean&gt;</code>或<code class="fe mr ms mt mu b">Observable&lt;boolean&gt;</code>。这使得实现接口方式的类更加通用，因为我们可以在某一点产生一个布尔值，甚至不是立即产生。我们可以使用web服务来验证URL调用，而不是直接响应Angular路由器。那么我们有两种常见的实现模式:</p><ol class=""><li id="c571" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><strong class="kw iu">同步</strong>:使用RBAC(基于角色的访问控制)系统或通过简单地检查认证令牌是否正确地存储在它应该存储的位置以及它是否过期，来验证当前用户是否具有访问路由的特权</li><li id="e53a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">异步</strong>:通过AJAX验证用户是否可以访问路由器，再次使用RBAC服务器端控件或验证令牌及其摘要，以检查它是否被黑客攻击或出现任何错误</li></ol><p id="c2cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在同步的情况下，记住你必须使用Rx操作符如<code class="fe mr ms mt mu b">pipe()</code>、<code class="fe mr ms mt mu b">map()</code>、<code class="fe mr ms mt mu b">catchError()</code>和可观察构造函数如<code class="fe mr ms mt mu b">of()</code>来发出一个<code class="fe mr ms mt mu b">Observable&lt;boolean&gt;</code>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ef28" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">HttpInterceptor接口</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/109a9b0548c8032ec433bb215e518d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lzjuR13ftNQaVgVP8kkcg.png"/></div></div></figure><p id="8eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个接口需要实现<code class="fe mr ms mt mu b">intercept()</code>方法。角度拦截器类似于中间件(比如像Express’中间件)，拦截并处理所有HTTP请求。拦截器通常用于将HTTP头附加到请求上，读取或过滤请求。Angular拦截器作用于每个HTTP请求，不能只拦截其中的一部分，除非您对每个HTTP URL进行编码和切换，定义规则来这样做。</p><p id="ab70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拦截器处理所有请求，操纵或读取其中的数据。在单页面应用程序中，它们基本上处理AJAX请求，因为我们不使用服务器端导航模式。</p><p id="ce6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接口方法获得两个参数:第一个检查当前请求，第二个在链中转发请求并使HTTP进程继续进行。请注意，角度<code class="fe mr ms mt mu b">HttpRequest</code>不能直接修改，而必须克隆，然后按照<a class="ae lq" href="https://angular.io/api/common/http/HttpRequest" rel="noopener ugc nofollow" target="_blank">官方文档</a>中的描述转发。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c868" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">角度实现</h1><p id="f733" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">在Angular应用程序中有两种不同的方式来使用拦截器和激活器。每一个实现这些接口的类都必须在<code class="fe mr ms mt mu b">app.module.ts</code>或者你的定制模块中被包含和声明。</p><p id="1f7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为它们互不相同，所以它们在模块中的包含也有所不同。拦截器和激活器(有时称为<em class="np">守卫</em>)都必须在提供者数组中声明。但是，虽然只需要包括守卫，拦截器需要一点更棘手的声明:</p><pre class="kj kk kl km gt nq mu nr ns aw nt bi"><span id="03b0" class="nu lz it mu b gy nv nw l nx ny"><strong class="mu iu">// app.module.ts</strong></span><span id="783f" class="nu lz it mu b gy nz nw l nx ny">providers: [<br/> MyService,<br/> MyOtherService,<br/> ...,<br/> AuthGuard,    // &lt;- implements canActivate<br/> RoleGuard,    // &lt;- implements canActivate<br/> ...,<br/> // Interceptor <br/> {<br/>    provide : HTTP_INTERCEPTORS,<br/>    useClass : TokenInterceptor,<br/>    multi : true<br/> }<br/> ],<br/> // continue...<br/> ],</span></pre><p id="c5c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，CanActivates只是被简单地包含在内，但是拦截器需要在一个特殊的对象中用这些字段来声明:</p><p id="72f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mu b">provide</code>:用于注入拦截器的多提供者令牌</p><p id="13b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mu b">useClass</code>:表示当前的拦截器类</p><p id="4005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mu b">multi</code>:描述<code class="fe mr ms mt mu b">HTTP_INTERCEPTORS</code>是否是注入一组值而不是单个值的<code class="fe mr ms mt mu b">multiProvider</code>的标记</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="174e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论和主要差异</h1><p id="8668" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">can activatives(guards)和interceptors都可以用来将导航锁定到某条路线或实现授权机制。然而，它们是完全不同的，必须在不同的环境中分别使用。</p><ul class=""><li id="e3d2" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp oa nb nc nd bi translated"><strong class="kw iu">可以激活单个路由上的工作，接口可以处理所有HTTP请求</strong>。这意味着如果您必须完整地操作HTTP，那么您需要一个拦截器。如果你需要控制一条路线，那么你应该使用警卫。</li><li id="86b5" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp oa nb nc nd bi translated">CanActivates可以是异步的，而拦截器不能。让一个拦截器异步地做一些事情，然后使用一个防护来验证您的令牌或者通过AJAX授权访问，这是没有意义的。</li><li id="2be3" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp oa nb nc nd bi translated"><strong class="kw iu">创新者被制成锁链</strong>。很少需要多个拦截器，而守卫通常是一个接一个的。这允许多个警卫分析对特定路线的访问，并避免或允许访问。</li></ul><p id="73dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码守卫和拦截器的实现和模式非常依赖于应用程序的上下文，因为不同的应用程序需要不同的和特定的认证机制。一些应用程序需要在启动时显示登录页面。其他应用程序要求用户在特定的关键点登录，就像CRM(完全锁定)和电子商务web应用程序一样，可以要求用户仅在结账时登录。</p><p id="1bf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用守卫和拦截器很容易，但是您需要练习一些模式来避免计算开销，并了解您是否需要其中一个。</p></div></div>    
</body>
</html>