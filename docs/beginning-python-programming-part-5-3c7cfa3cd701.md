# Python 编程入门—第 5 部分

> 原文：<https://betterprogramming.pub/beginning-python-programming-part-5-3c7cfa3cd701>

## 理解代码层次结构，以及如何使代码可重用

![](img/30722bb0a3e65e7fecfe6906d4b3cfba.png)

照片由[伊恩·托莫](https://unsplash.com/@tormius?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在上一篇文章中，我们讨论了 if 语句、while 循环和 for 循环。

[](https://medium.com/better-programming/beginning-python-programming-part-4-716a40d5636b) [## Python 编程入门—第 4 部分

### How if 语句、for 循环和 while 循环可以帮助您做出更好的决策，并简化重复的任务。

medium.com](https://medium.com/better-programming/beginning-python-programming-part-4-716a40d5636b) 

那些`if`语句中的一些非常大，如果我们想在那个`if`语句中做多件事情呢？它们会变得巨大而难以阅读。这就是今天的意义所在。让我们开始吧。

# 功能

实际上，你可以用 Python 写一个没有任何函数的程序——但你通常不应该这样做。我们将在作用域部分详细讨论这一点，但是在*全局作用域*编写的代码被用作程序的*入口点*。入口点只是一种说法，这是程序启动时首先运行的代码。很简单，对吧？

我们编写函数是因为它将我们的代码分解，使其更容易阅读。我们可以遵循一些编程原则，这些原则实际上只是使您的工作更容易的指南。这不是一个详尽的列表，但足以让您思考如何使您的代码更好:

*   **关注点分离** —如果您计算一个字符串中的字母数，然后将两个数字相加，那么使用这两个独立的函数是有意义的，一个函数计算字符串中的字母数，另一个函数将数字相加。
*   **单一责任原则** —这可以用一句话来概括:每件事都有一个工作，每件事都做好自己的工作。
*   **不要重复你自己(干)**——这很明显:为什么不止一次地输入相同的文本？为什么多次键入相同的文本？如果你是 A 型人格，知道我这样做了，你会发疯，但是 A 型开发人员看到一遍又一遍写同样的东西时会发疯——这里有一个坏消息:几乎每个阅读你的代码的开发人员都在使用 A 型思维。

你明白了吗？很好！我们稍后会详细介绍，但现在，这是一个很好的基础。

让我们首先向您展示一个用 Swift 编写的函数示例。语法可能看起来很奇怪，但我们将涵盖这一切。

首先，我们使用`def`关键字定义一个函数，它是 *define* 的缩写。

接下来，我们将我们的函数命名为`add`。

函数名称后有括号。如果没有参数，我们让它像这样空着:
`def do_stuff():`

如果有参数(我们可以*传递*到函数中的东西),那么我们将它们包含在声明中。在上面的例子中，我们有参数，确切地说是两个，我们有`first_number`和`second_number`。在这个例子中这些不是很好描述，但是它们*应该是*。

`first_number`和`second_number`将在函数的*主体*中使用。函数体是在函数声明下面缩进四个空格的所有代码。不要忘记函数使用冒号`:`来开始函数体。

接下来，我们有这部分`first_number: i*nt*` *。当我们调用这个函数时，Int 是我们期望使用的类型。同样适用于`second_number: int`。*

最后，我们在括号外的末尾有一个奇怪的语法。
`-> int`。

这意味着当这个函数结束时，我们应该返回一个整数值。Return 只是退出这个函数的一种方式，返回 return 右边的值。在我们上面的例子中，我们创建了一个名为`result`的常量，它是`first_number`和`second_number.`的和，我们可以把 result 称为任何东西，但这是有意义的，然后我们用`return result`。

我们调用实际使用的函数`result = ...`,因为我们需要记住从函数返回的常量或变量的值。如果我们的函数不应该返回任何东西，我们会得到一个错误。如果我们的函数应该返回一些东西，但是我们没有*捕获*这个值，我们就不会得到警告——相反，函数会返回`None`。这可能会导致以后的问题，所以要记住在需要的时候从函数中返回值。

我们也可以使用下划线来忽略我们不关心的返回值。`_ = add(4, 3)`执行 add 函数，但函数完成时不保存返回值。

我们可以省略函数参数中的`: int`，以及末尾的
`-> int`。这些只是安全预防措施，您可以采取这些措施来确保参数应该只允许使用特定的类型，或者在修改函数后，它应该总是返回特定的类型。

我们也可以从函数体中删除`result`，因为我们只需要`first_number + second_number`的结果。让我们看看这些变化是如何实现的:

至少在我看来更好。在大型程序中，我怎么强调强类型参数和返回值的重要性都不为过，我希望你总是在函数中使用*类型提示*。不仅仅是为了你的理智，也是为了五年后挖掘出你的代码并对其进行修改的可怜灵魂的理智。

您可以看到描述性名称是如何派上用场的。如果你对变量名感到困惑，请记住这句话:

> "计算机科学中只有两个难题:缓存失效和事物命名."—菲尔·卡尔顿

帮助我在函数中命名参数的是问我自己，*“这个句子对其他人来说有意义吗？”我的意思是，如果你能把逗号换成像`with`、`to`、`from`或类似的介词，会有意义吗？让我们在我们的`add`函数上测试这个理论。*

*将第一个号码添加到第二个号码中。*

它对我有意义，所以我认为它通过了测试。

我不会说这是一个完美的例子，但是代码的清晰性，尤其是函数的清晰性，是你应该努力追求的，所以试着经常思考这个问题。

所以我们用几种不同的方法写了一个函数。每种方式都是正确的。您可以完全控制它如何读取，以及它将使用什么参数名称和变量。

print 语句`print("Hello, World!")`实际上是一个返回字符串值的函数。我们用它在*控制台*中显示变量(把它想象成一个只读终端窗口或命令提示符)。真正酷的是它知道如何将一种类型转换成一个字符串，比如将一个整数转换成一个字符串，甚至是一个字典。我不会说它看起来总是很漂亮，因为有时它并不漂亮，但是它在构建你的程序时和在*调试*时被广泛使用。调试程序只是说明出错的另一种方式，现在我们正试图找出问题所在。

稍后我们将通过一个有趣的故事来讨论更多关于调试的内容，但是现在，让我们继续使用 print 语句来找出我们的问题:

从现在开始，我将使用`print("something")`而不是
`# result is equal to "something"`，因为这是你在实际程序中期望使用它的方式。

函数不一定要返回值。相反，我们可以嵌套 print 语句来为我们处理错误日志，如下所示:

现在我们已经把`print("Aww...")`和*封装成一个函数，我们可以在任何需要的时候调用它。这叫做*分解*。如果说*组合*是构建一段代码的工作方式，那么分解就是提取一遍又一遍重复使用的代码，使其更容易引用。对于这个简单的例子，我们可以只写 print 语句，因为它只有一行，但是为了简洁，也许有点懒惰，这应该足以理解这个想法。*

通过这个函数不返回值，当它结束时，我们没有*使用*返回关键字。我们*可以*使用返回，但是当主体中的所有代码都被执行并且我们到达了结束花括号时，函数还是会返回。唯一可能在不返回值的函数中使用 return 关键字的时候是当你想在所有代码运行之前退出函数*的时候。*

*注意:如果你在条件检查之外放入一个 return 语句，某些编辑器比如 PyCharm 会声明“这段代码可能永远不会被执行”或者类似的意思。这只是一个提示，说“我们知道你这样做了，但这是一个机会，让你清理那些永远不会被使用的代码，或者修改你的 return 语句，以便下面的代码有机会运行。”*

"吉他鲍勃是怎么回事？"我不会无缘无故把吉他放在页面顶部。我想举一个真实世界的例子来说明函数应该如何工作。

想象一下，如果你愿意，那把吉他被完美地调到 A440，也就是音乐会 a。

如果我弹奏第一弦(底部的 E 弦)，你会听到一个完美的 E 音。无论我拨第一弦多少次，你都会听到同样完美的 e 音。这是一个函数的例子。当我们弹奏琴弦时，它会以一定的频率振动并发出声音。这可能与函数的主体和返回有关。

总的想法是，我们不关心函数是如何工作的，我们只是希望当我们调用它时，它做我们期望的事情。

还有一件事…

如果你知道你想使用一个函数，但是还不知道它应该做什么，你可以使用关键字`pass`跳过函数的执行。这也可以用在`if`的语句中。举个简单的例子，看看这个函数的开始:

```
def calculate_driving_distance(starting_city, ending_city):
    pass
```

![](img/62217b1f348d746f5c20976cd5a42083.png)

安妮·斯普拉特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 范围

接下来是最后一部分:范围。到目前为止，我们已经经历了范围。我们在函数、if 语句、while 循环和 for 循环中体验过。一般意义上，我们一直都在报道。那么什么是范围呢？

*作用域定义了对象在代码中的位置。*

"好吧，鲍勃，你疯了，你刚刚告诉我一个无生命的物体有生命."不，实际上，在程序中，我们让它们活起来，让它们完成工作。为什么不这样考虑呢:

代码中的对象有一个生命周期。对于我们从一开始所做的大部分事情，你的变量在程序开始时就已经被创建了，当程序结束时，它们就消失了。这被认为是物体的寿命。

当你创建一个对象时，它只是一个包含变量和常量的通用名称，它有一个固定的生命周期。一个对象的寿命是由它在程序中的位置决定的。如果你把一个对象单独放在一个像`my_object: str = "Hello World"`这样的程序中，只要程序还在运行，它就会一直存在。程序一停止，`my_object`就会从内存中删除。

问题是我们不能把所有的东西都加载到内存中。我们会耗尽空间，所以我们通过定义程序的作用域来挑选在程序的任何给定点应该可用的内容。

我已经讨论了什么是作用域，但是让我们来看一些实际的例子，看看如何在代码中定义和使用作用域，以及它如何让您考虑将变量放在哪里:

我已经在这里定义了各种级别的范围，所以让我们从顶部开始。

`my_global_integer`是一个对象，只要程序还在运行，就可以在代码中的任何地方使用。

`my_global_function`是一个只要程序还在运行就可以在代码中任何地方使用的函数，但是，主体内的`name`变量只在主体的内**使用。一旦函数退出，`name`变量及其值将从内存中删除。**

*如果我们在函数外使用* `*name*` *变量，Python 会识别它并在运行时自动生成一个全局变量。这可能会导致内存效率问题；但是，如果您在一个函数中定义了* `*name*` *，然后又在另一个函数中定义了它，那么它将在每个函数的局部函数作用域中使用。*

除了返回值之外，`my_global_returning_function`与`my_global_function`完全相同，你可能会认为它返回的是在主体内部创建的变量，因为这就是它返回的内容，但它实际上只返回变量的**值**。当函数到达主体的末尾时，变量`name`从内存中被删除，你就有了一个你希望赋给另一个变量的值的副本。

因为我们知道返回函数返回`"Katy"`这个`if`语句将比较`if "Katy" == "Katy",`是的，它们是相同的！所以我们从全局范围引用回`global_name`变量，并从那里获取值(因为我们在执行评估之前已经赋值)。

然而，假设返回的名字是类似于`"Sophie"`的东西，它与`"Katy"`不同。在`else`语句中，有一个常量和一个变量被创建和初始化。它们只能在 else 语句的花括号中使用。如果我们要在`if`语句的`if`部分创建一个变量，它只能在`if`部分使用。

我们仍然可以打印`my_global_variable`和`my_global_function`，因为它们是在主体之外定义的。

Python 作为一种解释型语言的特别之处在于，如果我在第 16 行输入错误的`my_global_integer`并使用`myGlobalInteger`，程序仍然会运行。

Python 这样做是因为它甚至不知道它不使用的行。这在编译语言中是不同的，因为所有的行在运行之前都被编译成字节码。因为 Python 在运行时进行所有的编译，所以它只编译需要的东西，跳过其余的。

如果你忘记了我说过的所有东西，你只需要知道你可以用一个变量更深入，但是你永远不能离开这个变量最初被声明的主体。

想象一下，当你离开包含变量的身体时，Bones 说，“他死了，Jim！”不太喜欢星际迷航？嗯，我知道很多人喜欢加州旅馆，它的工作原理是一样的:你永远不能离开。也不是老鹰队的球迷？嗯，我相信如果你觉得需要的话，你可以想出自己的助记法来帮助你记住 scope 是如何工作的。

这就是范围。

# 摘要

所以今天，在纠结的鞋带的帮助下，我们意识到我们到目前为止写的代码有点草率。

我们从 **3 原则**开始，帮助我们想象我们的代码应该是什么样子:关注点分离，单一责任原则，不要重复自己。

然后我们谈到了**功能**以及它们如何帮助我们遵守这些原则。我强烈建议您练习编写自己的函数，这样您就掌握了窍门，并且明白什么是允许的，什么是不允许的。我们学习了如何使用`return`提前退出函数，以及如何使用`pass`跳过执行。

最后，我们谈到了**范围**。提示一下，*在将要使用的最低范围内声明变量，然后当你需要在其他地方可用的变量时，将声明移到更高的范围。随着我们继续前进，这将在我们的工作方式中变得更加明显。我相信我未来的例子会做到这一点。*

# 推荐阅读

Python 教程 4.5 到 4.7

 [## 4.更多控制流工具——Python 3 . 7 . 3 文档

### Python 中的语句与您可能习惯的 C 或 Pascal 中的语句略有不同。而不是总是迭代一个…

docs.python.org](https://docs.python.org/3/tutorial/controlflow.html#pass-statements) 

# 下一步是什么

你成功了！接下来我们将讨论类、属性和方法。

如果您一直在学习，那么您已经知道了属性和方法。我只需要先给你介绍一下课程。

[](https://medium.com/better-programming/beginning-python-programming-part-6-f128360f44ab) [## Python 编程入门—第 6 部分

### 为您的代码创建可重用的蓝图

medium.com](https://medium.com/better-programming/beginning-python-programming-part-6-f128360f44ab)