<html>
<head>
<title>How to Bridge Async/await Functions to Combine’s Future Type in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中将Async/await功能与未来类型结合起来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-bridge-async-await-functions-to-combines-future-type-in-swift-16c668333bdc?source=collection_archive---------17-----------------------#2022-08-29">https://betterprogramming.pub/how-to-bridge-async-await-functions-to-combines-future-type-in-swift-16c668333bdc?source=collection_archive---------17-----------------------#2022-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在基于Combine的API中调用异步/等待代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b36b46289fb883a1058c0b1b1add3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LK_E2MvlOfXj_29QXXHWVA.jpeg"/></div></div></figure><p id="f2f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当在Swift中处理异步代码时，我们可能必须找到混合和连接不同异步模式的方法，比如将Combine框架与Swift的async/await API一起使用。</p><p id="c4f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将研究如何在基于Combine的API中调用异步标记的函数。</p><p id="6f16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面的异步函数，它使用异步/等待模式从服务器加载用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了用Combine实现同样的行为，它的<em class="ls"> Future </em> publisher就派上了用场。一个未来用一个带<em class="ls">未来的闭包来初始化。许诺</em>。在做了一些异步工作后，我们称这个闭包的<em class="ls">结果</em>要么是成功，要么是失败。然后，Combine会自动将结果映射到适当的发布者事件中。</p><p id="15fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何用未来的<em class="ls">发布者实现上面的异步功能:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6a5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是由于我们已经有了一个加载用户的实现，我们希望避免重复编写相同的逻辑两次。</p><p id="2f6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们尝试找到一个更通用的解决方案，允许我们将一个<em class="ls">异步func </em>转换为一个<em class="ls">未来</em>发布者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5686" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们用一个方便的初始化器扩展了<em class="ls"> Future </em>类型，该初始化器允许我们用异步闭包初始化一个实例。应用于我们的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9713" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于非抛出异步函数，我们可以添加另一个扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="276b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这样一个通用的解决方案，我们现在有可能在任何异步函数上使用它，以将其连接到Combine的未来类型。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="943d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ls">原载于</em><a class="ae ma" href="https://tanaschita.com/20220822-bridge-async-await-to-combine-future" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://tanaschita.com</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>