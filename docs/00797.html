<html>
<head>
<title>Building a Scalable Tinyurl Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建可伸缩的Tinyurl应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-massively-scalable-tinyurl-application-with-python-docker-compose-and-kubernetes-90ff5d4d7f91?source=collection_archive---------8-----------------------#2019-07-15">https://betterprogramming.pub/building-a-massively-scalable-tinyurl-application-with-python-docker-compose-and-kubernetes-90ff5d4d7f91?source=collection_archive---------8-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8912" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python、Docker Compose和Kubernetes</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee4356381c316528e18ae8a0778cdaed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJmBHR9rAaeDeABnPCIJBA.jpeg"/></div></div></figure><p id="7089" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您有一个应用程序，它可以在您的笔记本电脑或一些只有几个用户的服务器上很好地运行。你如何将它扩展到数百万用户？</p><p id="1725" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可伸缩性对于用户体验来说是绝对重要的:不管系统中有多少用户，我们如何维持合理的用户体验？这些是我们将在这篇博客中通过一个具体的例子逐步解决的问题。</p><p id="40a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">读完这篇博客后，你应该能够:</p><ul class=""><li id="0b2f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">组织您的应用程序功能以实现可伸缩性</li><li id="c1c5" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">使用Docker Compose在您的笔记本电脑上快速开发和迭代分布式应用程序</li><li id="4403" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">通过Kubernetes，在几分钟内将该应用程序部署到云中，面向更多用户！</li></ul><p id="40b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，Python是开发人员生产力的绝佳选择。</p><h2 id="8601" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">概观</h2><p id="2381" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我们将讨论众所周知的<em class="nc"> Tinyurl </em>应用程序的设计，我们将从头开始构建它。</p><p id="19b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Tinyurl应用程序也是一个流行的系统设计主题，它的功能是将一个长的url转换成一个较短的版本。尽管这个应用程序从功能方面看起来很简单，但我们仍然可能会遇到在更复杂的应用程序中可能会发现的所有可伸缩性缺陷。这让我们有机会在设计主题上工作，而不会被功能细节所困扰。</p><p id="4351" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在Docker Compose中部署该应用程序进行本地测试，稍后在<a class="ae nd" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中进行公共云中的可扩展部署。</p><p id="28d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">具体来说，我们将创建一个REST服务，它将提供API来创建一个微小的url并检索原始url。</p><p id="6318" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将从高级架构以及软件堆栈和计划的部署选项开始。将向您介绍Docker和容器管理软件，特别是Docker Compose和Kubernetes，它们构成了构建可伸缩/分布式应用程序的有用工具集。</p><p id="32f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将把应用程序分解成多个自治服务，这有助于应用程序各部分的独立扩展。Kubernetes是这种基于微服务的应用程序的可伸缩性的强大推动者。此外，简单易懂的设计对于构建可伸缩性可以随着时间的推移而提高的软件大有帮助。我们的核心逻辑大概是50行左右的Python！</p><p id="0bcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此同时，Docker Compose使本地开发变得简单而有趣。</p><p id="e096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从我们需要的API开始:</p><ul class=""><li id="d505" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">给定一个url，返回短url</li><li id="cac3" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">给定一个短url，返回原始url</li></ul><p id="86a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nd" href="http://bit.ly" rel="noopener ugc nofollow" target="_blank"> bit.ly </a>是一个流行的在线网址缩短服务，你可以尝试一下，感受一下我们在这里想要实现的目标。</p><p id="b62c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们详细讨论单个服务之前，让我们列出API的性能和可伸缩性需求。</p><h1 id="5ca3" class="ne mf it bd mg nf ng nh mj ni nj nk mm jz nl ka mp kc nm kd ms kf nn kg mv no bi translated">要求和API</h1><p id="9522" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">API: url缩短</p><ul class=""><li id="7715" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">响应时间应少于1秒</li><li id="fb03" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">每秒缩短100个URL</li><li id="3902" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">主动管理的“大量”URL</li></ul><p id="45d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">API:返回原始url</p><ul class=""><li id="8c0e" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">响应时间应少于100毫秒</li><li id="c17d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">每秒返回10000个URL</li></ul><p id="3749" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对API检索原始url的性能期望更高，因为它会被频繁请求，因此对最终用户体验至关重要。此外，服务应该是“弹性的”,并且随着流量的增加，通过将更多的节点投入服务来自动扩展。</p><p id="2a63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们希望达到的性能和吞吐量是系统设计和硬件的函数。一个完全可扩展的系统可以通过增加硬件来扩展；从而使上面列出的任意吞吐量成为可能。</p><p id="839d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在现实中，当试图扩展系统时，应用程序中的子系统可能会成为瓶颈。我们将反复定位并消除这样的瓶颈。</p><h1 id="d6bc" class="ne mf it bd mg nf ng nh mj ni nj nk mm jz nl ka mp kc nm kd ms kf nn kg mv no bi translated">体系结构</h1><p id="a1a2" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在，让我们从一个高级设计开始，我们将应用程序分成独立的服务，并为它们选择合适的软件堆栈。</p><p id="3845" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个实现REST APIs的前端服务器，它需要一个数据库来存储和获取URL。前端服务器是无状态的，在多台机器上启动以处理增加的负载。相比之下，我们选择的Postgres数据库在默认情况下是有状态的，很快就会成为瓶颈。因此，我们添加了一个Redis缓存来保护Postgres。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/7a009d8d1c90d8302c430c44cad89799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y7_DVK8guc9h1p0Q6lUWhA.gif"/></div></div></figure><p id="0262" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上图所示，简单的架构应该有助于我们在遇到瓶颈时轻松定位。</p><p id="73ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">负载平衡器在云环境中的多个前端实例之间分派传入的请求。</p><h1 id="4ed4" class="ne mf it bd mg nf ng nh mj ni nj nk mm jz nl ka mp kc nm kd ms kf nn kg mv no bi translated">服务</h1><ul class=""><li id="2368" class="lq lr it kw b kx mx la my ld nq lh nr ll ns lp lv lw lx ly bi translated">Postgres数据库:URL的持久存储。有许多其他的选择，我们将从一个熟悉的RDBS开始，暂时保持事情简单。</li><li id="3958" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">Redis缓存:我们可以考虑使用高读(为了获得原始url)写(创建微小的url)比率的缓存</li><li id="c1ef" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">API server/'frontend': API server将编排Postgres和Redis服务来实现REST端点。我们选择一个Django，一个生产级web服务器，来托管REST端点。还有许多其他选项，如带有快速/哈比神或Java Spring Boot的节点。我们喜欢Python/Django，因为它能产生可伸缩且易于理解的代码，这就是我们的目的。此外，Django附带了许多基本元素，比如内置的用户管理和模板。从这里开始，你可以很容易地过渡到一个高效的系统。</li></ul><h1 id="5a72" class="ne mf it bd mg nf ng nh mj ni nj nk mm jz nl ka mp kc nm kd ms kf nn kg mv no bi translated">部署</h1><p id="03c7" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我们将容器化我们的服务，并在本地开发期间将应用程序部署在<a class="ae nd" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>中，这允许我们用一个命令启动和停止所有服务。这也为更快地开发和迭代代码提供了便利。</p><p id="e0fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将在不修改代码的情况下在cloud/Kubernetes中部署我们的应用程序。</p><h1 id="aa19" class="ne mf it bd mg nf ng nh mj ni nj nk mm jz nl ka mp kc nm kd ms kf nn kg mv no bi translated">概念</h1><p id="57bc" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在我们已经有了一个大致的计划，下面简单介绍一下Docker、Docker Compose和Kubernetes。</p><h2 id="0a12" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">码头工人</h2><p id="f0ba" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Docker 类似于VMware和VirtualBox等虚拟机技术，只是它更加高效和轻量级，因为Docker容器直接在底层主机操作系统内核上工作。另一方面，VMware和VirtualBox技术在主机操作系统的基础上增加了一个客户操作系统(更多差异见<a class="ae nd" href="https://blog.netapp.com/blogs/containers-vs-vms/" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><h2 id="0ff8" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">Docker图像和容器</h2><p id="c602" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Docker <em class="nc">镜像</em>是一个操作系统镜像的声明，上面有你想要的用于特定目的的软件层。例如节点/快速网络服务器。运行docker映像时，您得到的是一个Docker <em class="nc">容器</em>。</p><h2 id="7684" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">Dockerfile文件</h2><p id="6200" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><a class="ae nd" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> Dockerfile </em> </a>是一个文本文件，包含描述如何构建一个Docker镜像的指令，该镜像应该作为一个容器运行(例如，一个带有Python 3的Ubuntu镜像，Django +你的应用代码)。我们将为我们的每个服务创建一个docker文件。</p><h2 id="cd72" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">Docker撰写</h2><p id="306a" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><a class="ae nd" href="https://docs.docker.com/engine/docker-overview/" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> Docker </em> </a>提供构建和运行应用程序的工具，通过Dockerfile声明为容器实例。</p><p id="3a23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nd" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"><em class="nc">Docker-compose</em></a><em class="nc"/>帮助部署和运行在文本文件/YAML中声明配置的<strong class="kw iu">多</strong>容器应用程序。YAML依次引用应用程序所需的各个docker文件。</p><p id="40c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来看看代码，逐个服务。从g it克隆应用程序后，首先安装所有需要的软件并运行它是一个好主意。这将有助于我们了解应用程序的各个部分。</p><h2 id="cfe5" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">先决条件</h2><ul class=""><li id="546a" class="lq lr it kw b kx mx la my ld nq lh nr ll ns lp lv lw lx ly bi translated">安装docker: <a class="ae nd" href="https://docs.docker.com/v17.12/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>或<a class="ae nd" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a></li><li id="8072" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">安装<a class="ae nd" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> Docker-compose </a>(通常Docker Compose应与之前步骤中的Docker安装一起安装；仅当您无法在终端上运行命令'<em class="nc"> docker-compose -version </em>'时才执行此步骤)</li><li id="8cad" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">安装<a class="ae nd" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" rel="noopener ugc nofollow" target="_blank"> git </a></li><li id="5efe" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在一个合适的文件夹里，比如说<tinyroot>，克隆一个小小的网址git repo<a class="ae nd" href="https://github.com/irnlogic/tiny" rel="noopener ugc nofollow" target="_blank">https://github.com/irnlogic/tiny</a>，然后运行这个应用程序。</tinyroot></li></ul><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6870" class="me mf it nu b gy ny nz l oa ob">&lt;tinyroot&gt; git clone <a class="ae nd" href="https://github.com/irnlogic/tiny.git" rel="noopener ugc nofollow" target="_blank">https://github.com/irnlogic/tiny.git</a><br/>&lt;tinyroot&gt; cd tiny/dockercompose/<br/>&lt;tinyroot&gt; docker-compose up</span><span id="7cfa" class="me mf it nu b gy oc nz l oa ob">Visit <a class="ae nd" href="http://localhost:3000/867nv/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>, tinyurl app should be running. Hit Ctrl-C on the command line to stop the app.</span></pre><p id="886b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">‘docker-compose up’命令构建所需的docker映像并启动容器实例，如<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yaml </a>中所配置的。可以在浏览器上访问<a class="ae nd" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>与端点进行交互。</p><p id="afa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台日志还应该显示一些性能数据，这些数据让您对Redis之类的缓存和Postgres之类的RDBMS所涉及的响应时间范围有所了解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/51c2df32572348ad10962b027c281cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIU2BP6VPO_uXtWpj9VA8Q.png"/></div></div><p class="oe of gj gh gi og oh bd b be z dk translated">Docker编写控制台输出</p></figure><h2 id="ff85" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">代码和实现</h2><p id="236d" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><strong class="kw iu">文件夹结构</strong></p><p id="df60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请参见下面的文件夹结构。每个服务在dockercompose文件夹下都有自己的子目录。kubernetes包含在Kubernetes中部署我们的应用程序所需的描述符。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="507d" class="me mf it nu b gy ny nz l oa ob">&lt;tinyroot&gt; - dockercompose      # Docker-compose and Dockerfiles<br/>             -- db              # Dockerfile Postgres<br/>             -- redis           # Dockerfile Redis<br/>             -- django          # Dockerfile and source for Django<br/>             -- docker-compose.yml<br/>           - kubernetes      # Deployment, service descriptors <br/>           </span></pre><p id="bcd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Postgres数据库</strong></p><p id="41d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只是在docker hub使用基于Postgres映像的Dockerfile。您可以在https://hub.docker.com<a class="ae nd" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">的docker hub</a>上搜索可用图像，以找到其他图像和版本。</p><p id="8fdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/db/Dockerfile" rel="noopener ugc nofollow" target="_blank"> db/Dockerfile </a></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="3efa" class="me mf it nu b gy ny nz l oa ob">FROM postgres:11.1-alpine<br/></span></pre><p id="cc70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里来自命令的<a class="ae nd" href="https://docs.docker.com/engine/reference/builder/#from" rel="noopener ugc nofollow" target="_blank">设置了一个基础映像，在本例中，它安装了Postgres。我们没有在基础图像上添加更多的层——我们还不如直接使用基础图像呢！</a></p><p id="e01c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该docker文件使用版本'<em class="nc">11.1-阿尔卑斯山</em>'的'<em class="nc">postgres</em>' image<strong class="kw iu"/>。从该映像实例化的容器将在端口5432上运行Postgres。省略版本将绘制图像的最新版本。我们指定了一个显式版本，以避免在发布图像的新版本时出现潜在的不兼容性。</p><p id="2ff2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜，您已经有了一个基本的Postgres服务器映像！</p><p id="a2ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Redis缓存</strong></p><p id="fc98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/redis/Dockerfile" rel="noopener ugc nofollow" target="_blank"> redis/Dockerfile </a></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="c08a" class="me mf it nu b gy ny nz l oa ob">FROM redis<br/>CMD [“redis-server”]</span></pre><p id="34a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们获取标准Redis映像，并在启动容器时使用CMD启动Redis服务器。同样，我们还没有对Dockerfile做太多的工作。</p><p id="facc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Django网络服务器</strong></p><p id="7ef6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Django web服务器实现rest API端点，并与Postgres和Redis服务交互。</p><p id="a3b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们回顾一下<a class="ae nd" href="https://github.com/irnlogic/tiny/tree/master/dockercompose/django/src/tinyapp" rel="noopener ugc nofollow" target="_blank">tiny/docker compose/Django/tiny app</a>下的Django源代码，它被组织成如下图所示的文件夹结构。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="938e" class="me mf it nu b gy ny nz l oa ob">tinyapp/<br/>├── web/<br/>│   ├── __init__.py<br/>│   ├── settings.py<br/>│   ├── urls.py<br/>│   └── wsgi.py<br/>└── <strong class="nu iu">tinurl</strong>/<br/>│   ├── <strong class="nu iu">lib/tiny.py</strong> <br/>|   ├── <strong class="nu iu">migrations<br/></strong>│   ├── <strong class="nu iu">views.py</strong><br/>│   └── <strong class="nu iu">urls.py</strong><br/>│<br/>└── manage.py</span></pre><p id="804e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的许多文件夹和文件都是Django“管道”的一部分，你可以通过查看<a class="ae nd" href="https://docs.djangoproject.com/en/2.2/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank">这个</a>教程来了解。现在只需要关注文件夹‘tinyurl’下用<strong class="kw iu">粗体</strong>显示的项目就足够了，其中包含相关代码。该文件夹作为一个独立的Django“应用程序”,包含路由、视图、迁移和核心应用程序逻辑。</p><ul class=""><li id="08fa" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><em class="nc"> migrations/models.py </em> —声明“Url模型”，它也转换成Postgres表结构来存储Url</li><li id="8002" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="nc"> lib/tiny.py </em> —包含使用Postgres/Redis读写URL的核心逻辑的模块</li><li id="a5f0" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="nc"> views.py </em> —用于呈现url端点的简单视图，使用lib/tiny.py</li><li id="4fcb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="nc"> urls.py </em> —指向上图的路线</li></ul><p id="5e56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当调用一个API时，urls.py在views.py中触发一个特定的“视图”,该视图调用tiny.py中的相关函数，其输出与一个用于呈现响应的模板相融合。即使对Django框架没有很深的理解，您也应该能够很容易地跟踪到这一点。</p><p id="919b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从URL的数据库模式开始。</p><p id="dbf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的模型在<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/src/tinyapp/tinyurl/models.py" rel="noopener ugc nofollow" target="_blank"> models.py </a>中声明，这是一个Python类:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="420f" class="me mf it nu b gy ny nz l oa ob">from django.db import models<br/>class Url(models.Model):<br/>    shorturl = models.CharField(max_length=10, primary_key=True)<br/>    originalurl = models.CharField(max_length=300)</span></pre><p id="4e57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型<em class="nc"> Url </em>用两个属性声明，这将产生一个简单的关系表，用于存储由两列组成的Url。</p><ul class=""><li id="e337" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><em class="nc"> shorturl </em> —我们的应用程序生成的url的短代码，标记为主键。主键充当索引，因此有助于快速查找原始url。</li><li id="7272" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="nc">原网址</em> —原网址</li></ul><p id="b614" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/start_django.sh" rel="noopener ugc nofollow" target="_blank">命令</a>:</p><ul class=""><li id="a401" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">生成迁移，描述如何从一个版本的数据库模式迁移到另一个版本，反之亦然</li><li id="f7a4" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">基于这些迁移生成Postgres表。这些包括在内</li></ul><p id="ce77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Django <a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>中引用的<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/start_django.sh" rel="noopener ugc nofollow" target="_blank"> start_django.sh </a>:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="e80f" class="me mf it nu b gy ny nz l oa ob">python tinyapp/manage.py makemigrations<br/>python tinyapp/manage.py migrate</span></pre><p id="49d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们案例中生成的迁移:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4c2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的—我们的高级算法如下:</p><p id="c0e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成微小的url-对于给定的url，生成散列短代码，并且生成的短代码元组和原始url保存在Url表中。</p><p id="ab83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检索原始url —给定一个url，可以通过在url表中进行简单的查询来获取原始url，并在WHERE子句中使用短url，然后缓存该Url。后续请求将从Redis缓存中得到响应。</p><p id="cdc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续到<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/src/tinyapp/tinyurl/lib/tiny.py" rel="noopener ugc nofollow" target="_blank"> tiny.py </a> …</p><p id="8558" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/6a9bae0aa084697d3ecc4950f3449f78d76f0d2e/dockercompose/django/src/tinyapp/tinyurl/lib/tiny.py#L12" rel="noopener ugc nofollow" target="_blank">行</a>设置了一个到Redis的连接，其中6379是Redis基础映像中设置的Redis端口，它在我们的<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/6a9bae0aa084697d3ecc4950f3449f78d76f0d2e/dockercompose/docker-compose.yml#L7" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>中公开，供其他容器访问。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6ec9" class="me mf it nu b gy ny nz l oa ob">g_redis = redis.Redis(host=’redis’, port=6379, db=0, decode_responses=True)</span></pre><p id="c267" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nc">注意:连接redis服务请参见主机名'</em> <strong class="kw iu"> <em class="nc"> redis </em> </strong> <em class="nc">'的使用。每个服务容器加入由Docker-compose设置的默认</em> <a class="ae nd" href="https://docs.docker.com/compose/networking/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">网络</em> </a> <em class="nc">，该网络可由主机名与容器名相同的其他容器访问。请参考我们的</em><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/30715f81c5f362b64b00417a8f4ff7770fad5c75/dockercompose/docker-compose.yml#L5" rel="noopener ugc nofollow" target="_blank"><em class="nc">docker-compose . yml</em></a><em class="nc">文件，其中服务/容器名声明为“</em><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/2bba2e61aca63674d6dd6e24eb22d955f7ce9d87/dockercompose/docker-compose.yml#L4" rel="noopener ugc nofollow" target="_blank"><em class="nc">redis</em></a><em class="nc">”。</em></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="50ef" class="me mf it nu b gy ny nz l oa ob"><em class="nc">services: <br/> redis: <br/> </em><strong class="nu iu"><em class="nc"> </em></strong><em class="nc">build:</em><strong class="nu iu"><em class="nc"> ./redis </em></strong><em class="nc"><br/>  ports: <br/>     — 6379:6379</em></span></pre><p id="8c6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，以下简单明了的帮助器函数包装Redis的set (key/value)和get(key):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9e3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是生成并持久化短url的核心逻辑:<em class="nc"> get_tinyurl </em>，其中真正的作品get in<em class="nc">_</em><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/2bba2e61aca63674d6dd6e24eb22d955f7ce9d87/dockercompose/django/src/tinyapp/tinyurl/lib/tiny.py#L44" rel="noopener ugc nofollow" target="_blank"><em class="nc">get _ or _ create _ in _ db</em></a>:</p><ul class=""><li id="77aa" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">使用<a class="ae nd" href="https://docs.python.org/2/library/hashlib.html" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> hashlib </em> </a>模块生成32个字符的md5散列，并选择其最后6个字符作为url短代码。这限制了我们可以生成的URL的数量。如果我们取整个散列，我们的url就不再“微小”了。下面的while循环检查所选择的散列段是否被分配给不同的url，如果是，我们向左滑动md5散列并选择一个新的6字符窗口作为候选tinyurl代码。我们任意地进行最多10次尝试来解决散列冲突，尽管我们永远不会达到这种情况。一件好事是生成的散列具有这样的属性，即对于相同的URL，生成相同的散列。</li><li id="f5d2" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">然后使用Django ORM接口将生成的短url和原始url保存到Postgres数据库中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="085c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拼图中的最后一块是<em class="nc"> get_originalurl，</em>，它检索给定小url的原始url。首先，尝试从Redis缓存中获取原始url。如果它没有被缓存，那么我们从Postgres获取原始Url，缓存它并返回原始Url。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8c29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Django docker文件生成包含上述Python/Django代码的图像。</p><h2 id="e9b9" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/django/Dockerfile" rel="noopener ugc nofollow" target="_blank"> django/Dockerfile </a></h2><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="c56c" class="me mf it nu b gy ny nz l oa ob">FROM python:3<br/>RUN mkdir /code<br/>WORKDIR /code<br/>ADD requirements.txt /code/<br/>RUN pip install -r requirements.txt<br/>ADD src/ /code/<br/>ADD start_django.sh /code/<br/>CMD ./start_django.sh</span></pre><ul class=""><li id="1ac1" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">'【T8 FROM python:3'中的第一行从<a class="ae nd" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> docker hub </a>获取标准的Python映像，我们通过它安装软件和代码。</li><li id="633b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">运行命令运行一个命令，即在基础图像上添加一个层。<em class="nc">运行mkdir /code </em>创建目录“代码”</li><li id="d47c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><em class="nc"> WORKDIR /code </em>'将'/code '设置为下面后续docker命令的工作目录。</li><li id="e2a7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">“ADD requirements.txt /code/”将requirements.text从包含“Dockerfile”的目录复制到“/code/”目录。Requirement.txt列出了我们的应用程序所需的Python模块。例如psycopg2 — Postgres客户端、Redis — redis客户端</li><li id="649b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">后续添加命令将' src '文件夹和' start_django.sh '复制到'/code '文件夹</li><li id="38b9" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">最后'<em class="nc"> CMD。/start_django.sh </em>'在容器运行期间执行'<em class="nc"> start_django.sh </em>'中的命令，即每次容器启动时(相比之下，<em class="nc"> RUN </em>命令将在构建映像时运行一次！).Shell脚本'<em class="nc"> start_django.sh </em>'允许我们运行多个命令，例如创建、运行迁移和启动Django web服务器。</li></ul><h2 id="b97b" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">Docker撰写</h2><p id="25de" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">启动多个docker容器并设置它们相互通信是一件相当麻烦的事情。这就是Docker Compose的用武之地——它允许您在一个配置中定义所有服务，并使用一个命令启动所有服务。</p><p id="a72b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中<a class="ae nd" href="https://github.com/irnlogic/tiny/blob/master/dockercompose/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">tiny/docker compose/docker-compose . YAML</a>定义了组成Tinyurl应用程序的所有服务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/423a65bca7ed21f3a9ed3ad65eaf4879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeNEr3kvW49fkprmtCa3HA.png"/></div></div><p class="oe of gj gh gi og oh bd b be z dk translated">docker-compose.yaml</p></figure><p id="db21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在文件的顶部‘version:3’声明了我们正在使用的Docker compose yaml文件的<strong class="kw iu">格式</strong>的版本。</p><p id="16cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在yaml文件中的服务下，您可以注意到四个服务:redis、postgres、adminer和frontend。你现在可以忽略“管理员”。</p><h2 id="5a4a" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">雷迪斯</strong></h2><p id="4f66" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">服务的名称是' redis '，构建规范是'<em class="nc"> build:。/redis </em>告诉我们在启动这个服务时要构建哪个映像，在本例中是目录下的Dockerfile。/redis。或者，docker hub中的图像也可以使用“image”标签调用，但我们选择不在这里调用。</p><p id="bc31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“ports”部分<em class="nc"> "6379:6379" </em>将把容器上的一个端口(冒号右边的数字)映射到主机上的一个端口(这里是localhost ),在这种情况下两者是相同的。</p><p id="84ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker Compose中的服务名充当访问Redis服务的端点。例如，在Docker Compose网络中运行的另一个服务可以使用主机名' redis '和6379作为端口来引用Redis。</p><h2 id="9c0d" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak"> Postgres </strong></h2><p id="4819" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">同样，Postgres服务链接到Dockerfile。/db目录。“environment”部分用于声明Postgres用户名和密码，然后可以在生成的Postgres容器中访问它们。有问题的Postgres映像识别这些环境变量来配置自己。</p><p id="f0c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">前端</strong></p><p id="d4eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是Django中的REST服务器，设置类似。<em class="nc"> depends_on </em>声明一个依赖关系，使Redis和Postgres容器在Django服务之前被实例化。</p><p id="ddca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于Docker Compose yaml文件的更正式的文档，请参见<a class="ae nd" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="9c78" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated"><strong class="ak">在Kubernetes的部署</strong></h2><p id="02e2" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在，你可以按照这里的一步一步的指示，在Google Cloud Kubernetes中部署我们的Tinyurl应用程序。Kubernetes值得一个更详细的治疗比可以容纳在这个博客。尽管如此，到目前为止，您应该能够使用Docker Compose。Kubernetes的服务定义类似于Docker Compose中的服务定义，除了它还提供了“部署”，这提供了对计算单元、内存、CPU等扩展方面的精细控制。Kubernetes的“服务”本质上为其他服务与部署通信提供了稳定的端点。</p><p id="7a48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，<a class="ae nd" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>将在云环境中做Docker compose在我们的开发机器中为我们做的事情:管理容器。</p><h2 id="2c01" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">结论和下一步措施</h2><p id="c2cd" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在本主题的下一期中，我们希望更详细地讨论Kubernetes。</p><p id="7278" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，该应用程序当前版本的一些限制值得一提:</p><ul class=""><li id="1c01" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">没有为Postgres装载卷，重新启动后URL可能会丢失</li><li id="5a57" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">HTTP GET用于实现REST端点，这有助于在浏览器上进行简单的测试，但是某些URL可能会中断功能。这可以通过使用HTTP POST很容易地解决</li><li id="d8a2" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">其他人</li></ul><p id="6500" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，需要进行性能测试，以了解我们的应用程序如何扩展，并探索进一步扩展的方法。</p><p id="d701" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时:</p><ul class=""><li id="6c3d" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">您已经使用Docker和Docker Compose在笔记本电脑上构建并运行了一个分布式架构Tinyurl应用程序</li><li id="e9c2" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">将它部署在公共云中的Kubernetes上，以供更多用户通过互联网访问</li></ul><h2 id="096e" class="me mf it bd mg mh mi dn mj mk ml dp mm ld mn mo mp lh mq mr ms ll mt mu mv mw bi translated">更新</h2><p id="7964" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">对于库伯内特斯更详细的治疗，见我的后续<a class="ae nd" href="https://medium.com/better-programming/a-practical-step-by-step-guide-to-understanding-kubernetes-d8be7f82e533" rel="noopener">片</a>。</p></div></div>    
</body>
</html>