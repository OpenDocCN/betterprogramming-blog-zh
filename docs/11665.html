<html>
<head>
<title>Client-side Caching of a REST API in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中REST API的客户端缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/client-side-caching-of-a-rest-api-in-python-7f2ce483efb8?source=collection_archive---------13-----------------------#2022-04-06">https://betterprogramming.pub/client-side-caching-of-a-rest-api-in-python-7f2ce483efb8?source=collection_archive---------13-----------------------#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bf9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简单的缓存，用于在客户端缓存REST API响应。这减少了网络负载和API调用，提高了性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15e7e0388b95f22f56e3ebbec3ef40ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KETi_smnjtd6sY-w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扬·安东宁·科拉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们生活在一个支持API的世界里。越来越多的应用程序建立在开放的API之上。有时频繁调用同一个API、同一个端点和同一个参数，会导致相同的响应。</p><p id="6a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户端缓存上执行搜索并没有产生一个适合我使用的好的解决方案，所以我决定构建我自己的非常简单的解决方案。在这个例子中，它缓存来自REST apis的JSON结果。但是JSON部分是可选的。</p><p id="7d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存构建在python函数中，该函数执行web调用并将生成的JSON内容翻译成字典。当代码中的某个地方需要REST调用时，使用这个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ed22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">json_api_call</code>对指定的主机和基本url执行HTTPS请求。<code class="fe lx ly lz ma b">params</code>参数必须包含URL编码的参数，例如<code class="fe lx ly lz ma b">start=5.110%2C52.088&amp;end=5.113%2C52.088&amp;units=km</code>。</p><p id="210c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个版本增加了缓存机制。请求URL用作键，响应的JSON解码值是值。如果缓存返回None(第17–18行)，则进行API调用，结果存储在缓存中(第24行)。通过使用主机名、基本URL和参数，我们得到了一个唯一的字符串。如果API调用的头包含使调用唯一的相关信息，可以将它添加到键中。对于当前目的，这不是必需的。</p><h1 id="1b23" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">首次天真实现</strong></h1><p id="8144" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">缓存的第一个简单实现存储一个[key，value]对，并将其无限期地保存在缓存中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">add</code>函数将[key，value]对添加到字典中。<code class="fe lx ly lz ma b">get</code>方法检查这个键是否存储在字典中，如果是，返回相关的值。</p><h1 id="ea60" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">优化实施</strong></h1><p id="34d8" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">这种实现有两个主要缺点。首先,[key，value]无限存储，因为没有到期时间。第二，它基于(长)字符串比较键，这些字符串可能只在结尾之后不同。</p><p id="197b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个问题可以通过添加过期时间(秒)来解决。一个[key，value]对在这段时间后变得无效，并且不会被<code class="fe lx ly lz ma b">get</code>方法返回，而是从字典中删除。[键，值]对用到期时间扩展为[键，到期，值]。</p><p id="9eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个问题可以通过使用字符串的散列而不是字符串本身作为密钥来解决。当添加一个项目时，散列被用作键。这导致了以下版本的<code class="fe lx ly lz ma b">Cache</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="239a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造类的过程中，会指定过期时间的默认值。通过指定<code class="fe lx ly lz ma b">timeout</code>参数(第14–16行),可以在将项目添加到缓存时覆盖该默认值。第28行创建了一个默认过期时间为60秒的缓存。</p><p id="4a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从缓存中检索值时，会检查到期时间。如果该值仍然有效，则返回该值(第20–23行)。如果过期时间已过，则从字典中删除该值(第25行),并返回<code class="fe lx ly lz ma b">None</code>。</p><h1 id="d915" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">最后的话</strong></h1><p id="5d26" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">我希望你喜欢这篇文章。要获得更多灵感，请查看我的其他文章:</p><ul class=""><li id="b8a7" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><a class="ae ky" href="https://towardsdev.com/perform-a-function-on-columns-in-a-csv-file-a889ef02ca03" rel="noopener ugc nofollow" target="_blank">对CSV文件中的列执行功能</a></li><li id="328e" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657" rel="noopener" target="_blank">根据你的活动跟踪器的日志创建热图</a></li><li id="bf09" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://towardsdatascience.com/remove-personal-information-from-text-with-python-232cb69cf074" rel="noopener" target="_blank">用Python删除文本中的个人信息</a></li><li id="c76a" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989" rel="noopener" target="_blank">使用Python的并行web请求</a></li><li id="5487" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><a class="ae ky" href="https://towardsdatascience.com/all-public-transport-leads-to-utrecht-not-rome-bb9674600e81" rel="noopener" target="_blank">所有公共交通工具都通向乌得勒支，而不是罗马</a></li></ul><p id="3946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">免责声明:本文包含的观点和看法仅归作者所有。</em></p></div></div>    
</body>
</html>