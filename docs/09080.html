<html>
<head>
<title>The Safe Rust String Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全防锈字符串类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-safe-rust-string-types-688fcc8d5df1?source=collection_archive---------13-----------------------#2021-07-13">https://betterprogramming.pub/the-safe-rust-string-types-688fcc8d5df1?source=collection_archive---------13-----------------------#2021-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4884" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道String和&amp;str如何工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b7d15427dff59775a514155bbc293373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gpXSrn6YfDYartvY.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mit耶尔德勒姆@ Unsplash</p></figure><p id="e61c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你开始学习用Rust编程时，可能你的第一个挫折是来自不同类型字符串的编译错误。</p><p id="29e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust的字符串设计不同于大多数只有单一字符串类型的编程语言。Unicode安全的字符串设计和独特的所有权机制使得Rust中的<code class="fe lu lv lw lx b">String</code>对初学者来说是违反直觉的。</p><p id="2822" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是不要害怕！</p><p id="ee6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，字符串数据结构比大多数程序员认为的更复杂。而Rust关注的是安全性，所以编译器会在你编码的时候告诉你潜在的字符串问题。最好在开发阶段保持安全，否则您可能会在调试之夜迷失方向。</p><p id="9e29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，让我们来深入了解一下《铁锈》中的<code class="fe lu lv lw lx b">String</code>。</p><h1 id="095e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是字符串</h1><p id="0be0" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在Rust中，<code class="fe lu lv lw lx b">String</code>仅仅是<code class="fe lu lv lw lx b"><strong class="la iu">u8</strong></code>的一个向量。我们可以在<a class="ae mv" href="https://github.com/rust-lang/rust/blob/master/library/alloc/src/string.rs" rel="noopener ugc nofollow" target="_blank">源代码</a>中找到它的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0f64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">String</code>类型由Rust的标准库提供，它的大小是可增长的，是一个堆分配的可变字符串类型。当<code class="fe lu lv lw lx b">String</code>变量超出范围时，缓冲区将自动释放。</p><p id="c27a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用几种方法创建一个<code class="fe lu lv lw lx b">String</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ec0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust的字符和字符串类型是围绕Unicode设计的。<code class="fe lu lv lw lx b">String</code>不是ASCII字符序列，而是Unicode字符序列。Rust <code class="fe lu lv lw lx b">char</code>类型是保存Unicode代码的32位值。<code class="fe lu lv lw lx b">String</code>使用<a class="ae mv" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>将Unicode字符编码成vec:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而<code class="fe lu lv lw lx b">.len()</code>方法将返回以字节计量的长度，而不是以字符计量的长度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fdae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最不自然的字符串是与<code class="fe lu lv lw lx b">indexing</code>相关的操作。例如，你不能仅仅使用<code class="fe lu lv lw lx b">s[i]</code>从一个字符串中获取<code class="fe lu lv lw lx b">i-th</code>单独的字符。Rust字符串不支持索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ec846bee1970e036c2bb6a38deec0f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*h1ua3T_jMGVIu0u2.png"/></div></figure><p id="445e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么？</p><p id="4932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为UTF-8是一种可变宽度的编码格式，所以字符串中的每个ASCII字符都存储在一个字节中，而其他字符可能会占用多个字节。因此，在这种格式中，对字符串字节的索引并不总是与有效的Unicode标量值相关联。</p><p id="f193" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于包含ASCII字符和非ASCII字符的字符串，<code class="fe lu lv lw lx b"><strong class="la iu">s[1]</strong></code>表示无效值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/b141cc74da33a9b70d294099b5d8ef03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jdz2o3oumAzax53L.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:编程Rust</p></figure><p id="7b5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们需要用迭代器访问字符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="caff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您知道您的字符串全部是ASCII字符，您可以使用非恐慌版本的<code class="fe lu lv lw lx b">get</code>和<code class="fe lu lv lw lx b">get_mut</code>在O(1)时间内访问或修改字符串的一部分。<code class="fe lu lv lw lx b">get_mut</code>将返回一个<code class="fe lu lv lw lx b">&amp;mut str</code>，但是它仍然非常严格——<code class="fe lu lv lw lx b">&amp;mut str</code>上唯一可用的操作是<code class="fe lu lv lw lx b">make_ascii_uppercase</code>和<code class="fe lu lv lw lx b">make_ascii_lowercase</code>，它们就地修改文本，并且只影响单字节字符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a763" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想更自由地修改一个<code class="fe lu lv lw lx b">String</code>中的特定字节，您需要将它转换成一个<code class="fe lu lv lw lx b">mut vec&lt;u8&gt;</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ab5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，关于<code class="fe lu lv lw lx b">String</code>我们已经说了很多了。请记住，Rust中的字符串保证是有效的UTF-8——如果您感到困惑，请更加熟悉<code class="fe lu lv lw lx b">String</code> API。<a class="ae mv" href="https://utf8everywhere.org/" rel="noopener ugc nofollow" target="_blank"> UTF-8无处不在</a>是你了解Rust为什么选择UTF-8作为编码格式的最佳资源。</p><h1 id="05b9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是<code class="fe lu lv lw lx b">&amp;str</code></h1><p id="73bb" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">另一方面，<code class="fe lu lv lw lx b">str</code>也称为<code class="fe lu lv lw lx b">string slice</code>，是编译器的基本类型。我们通常以借用的形式使用:<code class="fe lu lv lw lx b">&amp;str</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aa9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，编译器把它当作一个<code class="fe lu lv lw lx b">fat pointer</code>，这意味着:<code class="fe lu lv lw lx b">&amp;str</code>由两部分组成:一个指向某些字节的指针和一个长度。<br/>我们可以用<code class="fe lu lv lw lx b">as_ptr()</code>的方法得到指针，用<code class="fe lu lv lw lx b">len()</code>的方法得到长度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="7947" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">字符串和&amp;str</h1><p id="8c1d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe lu lv lw lx b">String</code>和<code class="fe lu lv lw lx b">&amp;str</code>的关系就像C++里的<code class="fe lu lv lw lx b">std::string</code>和<code class="fe lu lv lw lx b">char*</code>:</p><ul class=""><li id="2e0a" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">一个Rust <code class="fe lu lv lw lx b">String</code>就像一个<code class="fe lu lv lw lx b">std::string</code>——它拥有内存并做着管理内存的脏活。</li><li id="bbba" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">Rust <code class="fe lu lv lw lx b">&amp;str</code>就像一个<code class="fe lu lv lw lx b">char*</code>(但是有长度)——它用<code class="fe lu lv lw lx b">std::string</code>的内容向我们指出一个块的开始。</li></ul><p id="504a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么<code class="fe lu lv lw lx b">&amp;str</code>需要存储长度，这是因为我们可以用使用<code class="fe lu lv lw lx b">&amp;str</code>来指向<code class="fe lu lv lw lx b">String</code>的特定部分的指针。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2160" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对应的示意图是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/4c9758cf4aff2adfe6007c4ccd634c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*epfS_xi_lDqqSiVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者</p></figure><h1 id="bb43" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">弦还是<code class="fe lu lv lw lx b">&amp;str</code>？</h1><p id="5689" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们如何根据场景选择使用哪种类型？</p><p id="9d2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两条规则要遵循:</p><ul class=""><li id="700a" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">当你需要拥有内存时，使用<code class="fe lu lv lw lx b">String</code>。例如，你在一个函数中创建了一个字符串，需要返回它。</li><li id="de3e" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当您想要对一个<code class="fe lu lv lw lx b">String</code>变量(或者代码中的一个字符串)的不可变引用时，请使用<code class="fe lu lv lw lx b">&amp;str</code>。</li></ul><p id="f0a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住，当你把它作为参数传递给一个函数时，Rust将跟随<code class="fe lu lv lw lx b">String</code>的<code class="fe lu lv lw lx b">move</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="44db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该程序将报告以下错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/fca6f1bd45392f49b1665065f34c7b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j9h34u0pPgBCTjWa.png"/></div></div></figure><p id="222f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为<code class="fe lu lv lw lx b">v</code>被移到了函数<code class="fe lu lv lw lx b">func</code>中，我们不能再在main的范围内读取它了。检查者遵循Rust所有权的规则。Rust有一个超级强大的功能，叫做<em class="nq">解除强制</em>，允许它将任何<code class="fe lu lv lw lx b">&amp;String</code>变成<code class="fe lu lv lw lx b">&amp;str</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aee4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，当你在设计一个只需要以只读方式访问字符串的API时，<code class="fe lu lv lw lx b">&amp;str</code>是最好的选择。</p><p id="cfc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是当你需要修改一个<code class="fe lu lv lw lx b">String</code>的内容时，你却无法通过一个<code class="fe lu lv lw lx b">&amp;mut str</code>，你可能认为这是合理的。<code class="fe lu lv lw lx b">&amp;mut str</code>确实存在，但是用处不大，因为<em class="nq">一个切片不能重新分配它的引用对象</em>。当你需要修改一个字符串的内容时，你需要把<code class="fe lu lv lw lx b">&amp;mut String</code>作为参数传递，就像上面的<code class="fe lu lv lw lx b">set_char_inplace</code>例子。</p><p id="c987" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">struct</code>的场景中，大多数情况下，你需要拥有字符串，所以<code class="fe lu lv lw lx b">String</code>几乎总是比<code class="fe lu lv lw lx b">&amp;str</code>更好的选择。如果你想在<code class="fe lu lv lw lx b">struct</code>中使用<code class="fe lu lv lw lx b">&amp;str</code>作为属性，你需要处理寿命问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="9f4b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">其他类似绳子的东西</h1><p id="727e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">除了以上两种字符串，Rust还提供了其他类字符串类型用于特殊场景。请查阅参考资料，以下是我们可以遵循的一些通用规则:</p><ul class=""><li id="5952" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">对于Unicode文本，坚持使用<code class="fe lu lv lw lx b">String</code>和<code class="fe lu lv lw lx b">&amp;str</code>。</li><li id="f679" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当处理文件名时，使用<code class="fe lu lv lw lx b">std::path::PathBuf</code>和<code class="fe lu lv lw lx b">&amp;Path</code>代替。</li><li id="3bf5" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当处理非UTF-8编码的二进制数据时，使用<code class="fe lu lv lw lx b">Vec&lt;u8&gt;</code>和<code class="fe lu lv lw lx b">&amp;[u8]</code>代替。</li><li id="36f8" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当使用操作系统提供的本机形式的环境变量名和命令行参数时，使用<code class="fe lu lv lw lx b">OsString</code>和<code class="fe lu lv lw lx b">&amp;OsStr</code>。</li><li id="aed7" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当与使用空终止字符串的C库交互时，使用<code class="fe lu lv lw lx b">std::ffi::CString</code>和<code class="fe lu lv lw lx b">&amp;CStr</code>。</li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="f349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">加入我的</strong> <a class="ae mv" href="http://codercat.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">邮件列表</strong> </a> <strong class="la iu">获取更多有用的见解，这是免费的！</strong></p></div></div>    
</body>
</html>