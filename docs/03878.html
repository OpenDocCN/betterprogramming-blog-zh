<html>
<head>
<title>JavaScript Interview Questions: Events in Detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题:详细事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-interview-questions-events-in-detail-d13f74d4fe9b?source=collection_archive---------13-----------------------#2020-03-10">https://betterprogramming.pub/javascript-interview-questions-events-in-detail-d13f74d4fe9b?source=collection_archive---------13-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c435" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">准备好下次面试官问你关于JavaScript事件的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7cae697131b7e933c0b14b5ddc84fa3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zdEdfx5N-cPj0T7V"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@aranxa_esteve?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aranxa Esteve </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="be89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨在前端JavaScript中处理事件的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a18a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">JavaScript中如何使用事件处理程序？</strong></h1><p id="bcb1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">事件是用户活动的结果，如点击链接或输入文本。当在元素中触发事件时，需要事件处理程序来运行代码。</p><p id="7681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件处理程序被设置为对象的额外属性。例如，如果我们想处理一个按钮的事件，那么我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2269" class="ne md it na b gy nf ng l nh ni">const button = document.getElementById('button');<br/>button.onclick = (event) =&gt; {<br/>  //...<br/>}</span></pre><p id="2999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设按钮的ID是<code class="fe nj nk nl na b">button</code>，我们可以通过为<code class="fe nj nk nl na b">onclick</code>属性设置一个事件处理函数来附加一个<code class="fe nj nk nl na b">onclick</code>监听器来处理点击事件。</p><p id="53f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">event</code>参数是一个拥有关于事件的各种信息的对象。</p><p id="303f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe nj nk nl na b">addEventListener</code>调用来做同样的事情:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d700" class="ne md it na b gy nf ng l nh ni">const button = document.getElementById('button');<br/>button.addEventListener('click', (event) =&gt; {<br/>  //...<br/>})</span></pre><p id="18c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数具有事件名称。事件监听器位于<code class="fe nj nk nl na b">addEventListener</code>方法调用的第二个参数中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">“<code class="fe nj nk nl na b">event.preventDefault()'</code>和“<code class="fe nj nk nl na b">event.stopPropagation()'</code>有什么区别？</h1><p id="3d12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">event.preventDefault()</code>用于停止触发事件发生的任何元素的默认行为。</p><p id="1bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它和一个<code class="fe nj nk nl na b">form</code>元素一起使用，那么我们阻止它提交。</p><p id="cc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它和一个<code class="fe nj nk nl na b">a</code>元素一起使用，那么<code class="fe nj nk nl na b">preventDefault()</code>会阻止它导航。</p><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">event.stopProgation()</code>专门用于阻止事件的传播，在冒泡和捕获阶段阻止事件发生。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="447d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们如何知道元素中是否使用了'<code class="fe nj nk nl na b">event.preventDefault()'</code>？</h1><p id="1f38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以检查事件对象中的<code class="fe nj nk nl na b">event.defaultPrevented</code>属性。如果是<code class="fe nj nk nl na b">true</code>，那么<code class="fe nj nk nl na b">event.preventDefault()</code>被调用。</p><h1 id="f66f" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">什么是“事件.目标”？</h1><p id="6616" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">event.target</code>是发生事件的元素或触发事件的元素。</p><p id="277f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下HTML:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="91f9" class="ne md it na b gy nf ng l nh ni">&lt;div id='div'&gt;<br/>  &lt;button id='button'&gt;<br/>    Click Me<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="4ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和下面的JavaScript代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="78da" class="ne md it na b gy nf ng l nh ni">const button = document.getElementById('button');<br/>button.onclick = (event) =&gt; {<br/>  console.log(event.target.id);<br/>}</span></pre><p id="4faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们点击<code class="fe nj nk nl na b">Click Me</code>按钮时，我们将从<code class="fe nj nk nl na b">console.log</code>中得到<code class="fe nj nk nl na b">button</code>，因为它是点击事件的起源。</p><p id="6e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明<code class="fe nj nk nl na b">event.target</code>是事件被触发的元素。</p><p id="c5f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们为div添加一个事件处理程序，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2fc6" class="ne md it na b gy nf ng l nh ni">const button = document.getElementById('button');<br/>const div = document.getElementById('div');<br/>button.onclick = (event) =&gt; {<br/>  console.log(event.target.id);<br/>}</span><span id="3515" class="ne md it na b gy nr ng l nh ni">div.onclick = (event) =&gt; {<br/>  console.log(event.target.id);<br/>}</span></pre><p id="767b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还让<code class="fe nj nk nl na b">button</code>登录到那里，所以<code class="fe nj nk nl na b">event.target</code>肯定是点击事件起源的元素。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="606a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是“event.currentTarget”？</h1><p id="8ca5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">event.currentTarget</code>是显式附加事件处理程序的元素。</p><p id="2bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下HTML:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="65bb" class="ne md it na b gy nf ng l nh ni">&lt;div id='div'&gt;<br/>  &lt;button id='button'&gt;<br/>    Click Me<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="a751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个JavaScript:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7d4d" class="ne md it na b gy nf ng l nh ni">const button = document.getElementById('button');<br/>const div = document.getElementById('div');<br/>button.onclick = (event) =&gt; {<br/>  console.log(`button.onclick ${event.currentTarget.id}`);<br/>}</span><span id="078b" class="ne md it na b gy nr ng l nh ni">div.onclick = (event) =&gt; {<br/>  console.log(`div.onclick ${event.currentTarget.id}`);<br/>}</span></pre><p id="6a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们单击<code class="fe nj nk nl na b">Click Me</code>按钮时，我们看到从<code class="fe nj nk nl na b">button.onclick</code>事件处理程序记录的<code class="fe nj nk nl na b">button.onclick button</code>和从<code class="fe nj nk nl na b">div.onclick</code>事件处理程序记录的<code class="fe nj nk nl na b">div.onclick div</code>。</p><p id="2ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们看到<code class="fe nj nk nl na b">event.currentTarget</code>是我们附加到事件处理程序的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/feb251f2a5d6e1eef95e2bbc187b38d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7tzLICcE7Sz6xSes"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克·🇬🇧</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="02b2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是活动委托？</h1><p id="f998" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nt">事件委托</em>是我们将事件监听器添加到父元素，而不是添加到子元素。</p><p id="d5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">侦听器将触发子代上触发的任何元素，因为事件是从触发事件的元素冒泡出来的。</p><p id="0afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为我们只有一个附加到父元素的处理程序。</p><p id="a42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也不需要将处理程序从被移除的元素上解除绑定，并将其绑定到新元素上。</p><p id="db3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有下面的HTML …</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a891" class="ne md it na b gy nf ng l nh ni">&lt;div id='div'&gt;<br/>  &lt;button id='button-a'&gt;<br/>    Click Me<br/>  &lt;/button&gt;<br/>  &lt;button id='button-b'&gt;<br/>    Click Me<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="0840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们可以编写以下JavaScript代码来添加事件委托:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6008" class="ne md it na b gy nf ng l nh ni">const div = document.getElementById('div');</span><span id="01a7" class="ne md it na b gy nr ng l nh ni">div.onclick = (event) =&gt; {<br/>  if (event.target.matches("button#button-a")) {<br/>    alert('Button A clicked');<br/>  } else if (event.target.matches("button#button-b")) {<br/>    alert('Button B clicked');<br/>  }<br/>}</span></pre><p id="e5cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，通过ID获取<code class="fe nj nk nl na b">div</code>,然后为它附加一个click-event处理程序。</p><p id="06e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在事件处理函数中，我们通过使用<code class="fe nj nk nl na b">matches</code>方法检查调用click事件的<code class="fe nj nk nl na b">event.target</code>。</p><p id="5664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果点击了ID为<code class="fe nj nk nl na b">button-a</code>的按钮，那么我们会显示一个带有<code class="fe nj nk nl na b">Button A clicked</code>的警告框。</p><p id="ea54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果点击ID为<code class="fe nj nk nl na b">button-b</code>的按钮，我们会显示一个带有<code class="fe nj nk nl na b">Button B clicked</code>的警告框。</p><p id="cbe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们只有一个事件处理器，但是我们可以处理里面所有按钮的点击事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c8a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文档- <code class="fe nj nk nl na b">Load</code>事件和文档<code class="fe nj nk nl na b">DOMContentLoaded</code>事件有什么区别？</h1><p id="2979" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当初始的HTML文档已经被完全加载和解析，而没有等待样式表、图像和子框架完成加载时，触发<code class="fe nj nk nl na b">DOMContentLoaded</code>事件。</p><p id="8635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">load</code>事件仅在DOM和所有相关资源和资产被加载后被触发。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是事件循环？</h1><p id="cd1f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">事件循环是一个单线程循环，它监视调用堆栈并检查任务队列中是否有要运行的代码。</p><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果调用堆栈为空，而任务队列中有回调函数，那么它们将从任务队列中出列，并通过将它们推送到调用堆栈来运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c9c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4c17" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，我们通过将事件监听器附加到元素来处理事件。</p><p id="c638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用事件委托来避免将事件侦听器附加到每个元素上。它对处理动态元素事件也很有帮助，因为我们不必通过事件委托来附加和删除事件侦听器。</p><p id="b0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，事件循环是一个单线程循环，它监视调用堆栈并运行那里的内容。如果调用堆栈中没有任何东西，那么任务队列中的任何东西都将被移出队列，并通过将其推送到调用堆栈来运行。</p></div></div>    
</body>
</html>