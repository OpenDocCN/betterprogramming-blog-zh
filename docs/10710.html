<html>
<head>
<title>Introduction to Kotlin Multiplatform Mobile — Getting Started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin多平台移动设备简介—入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-kotlin-multiplatform-mobile-part-i-333af55741af?source=collection_archive---------5-----------------------#2022-01-24">https://betterprogramming.pub/introduction-to-kotlin-multiplatform-mobile-part-i-333af55741af?source=collection_archive---------5-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8959" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第一部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/46db93cf254aebce1eea1067e5127c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZiHycfkyw-0QN603mQA-aQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自科特林文件</p></figure><p id="e7f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一系列关于Kotlin多平台移动(KMM)的文章，如果你想开始使用它，你应该知道。这些分为三个部分:</p><ul class=""><li id="98da" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">第一部分:Kotlin多平台简介</strong></li><li id="d233" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">第二部分:KMM配置</li><li id="27f7" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">第三部分:KMM样本(缓存+网络)</li></ul><h1 id="cd70" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">第一部分将涉及的要点</h1><ul class=""><li id="fc27" class="lr ls iq kx b ky mx lb my le mz li na lm nb lq lw lx ly lz bi translated">什么是科特林多平台(KMP)？</li><li id="f336" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">KMP对KMM</li><li id="09d2" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">KMM试图解决什么问题？</li><li id="cacd" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如何使用KMM构建代码？</li><li id="17f3" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用KMM的局限性是什么？</li><li id="42b4" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">结论</li></ul><h1 id="7b9f" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是科特林多平台(KMP)？</h1><p id="3367" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">它于17年11月在Kotlin 1.2中推出(<a class="ae nf" href="https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/" rel="noopener ugc nofollow" target="_blank">见Kotlin博客</a>)，根据<a class="ae nf" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank"> Kotlin文档</a>:</p><blockquote class="ng nh ni"><p id="c88c" class="kv kw nj kx b ky kz jr la lb lc ju ld nk lf lg lh nl lj lk ll nm ln lo lp lq ij bi translated">对多平台编程的支持是Kotlin的主要优势之一。它减少了为不同平台编写和维护相同代码的时间，同时保留了原生编程的灵活性和优势</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/068762287923778e8e1f3839f294c379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XYmyUKAVEotS8rdGatNXQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">科特林多平台目标</p></figure><p id="ce33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，KMP是一种在业务层、数据层、表示层等平台之间共享代码，只为特定平台编写原生组件的方式。也就是说，您可以编写一个封装了业务逻辑的KMP组件(即登录组件)，特定的平台可以使用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/719007fe2546728645732b878fc8f1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQcoIsSxMjt60rd6abEKPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">KMP登录业务层示例</p></figure><h1 id="9fb7" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><strong class="ak"> KMP对KMM </strong></h1><p id="c1eb" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">可能你听到的第一个术语是Kotlin多平台(KMP)，然后是Kotlin多平台移动(KMM)。但是两者有区别吗？让我们找到答案！</p><p id="bfb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最简单的理解方法就是看下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/00ad942637b0cd2112a9a8d9270fb5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxGvDYSpd6-k5fcBdwGQwA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">KMP对KMM</p></figure><p id="f63b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，KMM是KMP的一个专业。这意味着KMP可以编译成特定平台的原生二进制代码(<a class="ae nf" href="https://kotlinlang.org/docs/mpp-supported-platforms.html" rel="noopener ugc nofollow" target="_blank">参见kotlin支持的平台完整列表</a>)，但KMM是KMP负责移动目标(Android + iOS)的一部分。为了实现这一点，有工具，插件，库等。</p><h1 id="0238" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">KMM试图解决什么问题？</h1><p id="8149" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">由于KMM是关于移动目标的，它试图解决的问题是在平台之间共享需要共享的内容，需要共享的部分是开发者的责任。这意味着你可以共享一个特定的模块或者几个模块(包括UI，稍后会详细介绍)。让我们看一个例子。</p><p id="2ef1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比方说，我想开发一个应用程序，将设备信息发送到任何远程服务器。没有KMM，看起来像是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/3c3e147c6c45a89e7f4dd0aaed460787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_T0vBXqYAIEH4NkSWJTKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有KMM的Android和iOS应用程序</p></figure><p id="0412" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上一张图来看，表示层正在使用来自Android和iOS的特定API，以便从设备获取信息。</p><p id="5e90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，<code class="fe np nq nr ns b">domain</code>层使用来自表示层的信息，以便创建具有特定格式的对象，并在需要时添加额外的业务规则(即，为某些属性添加特定格式，或者如果某些传感器不可用，我们可能应该发送空数据)。</p><p id="1f82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，<code class="fe np nq nr ns b">data</code>层负责将信息发送到服务器。在Android的情况下，我们可以使用<a class="ae nf" href="https://github.com/square/retrofit" rel="noopener ugc nofollow" target="_blank">改进</a>，对于iOS，我们可以使用<a class="ae nf" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank"> Alamofire </a>。也许你开始在这个应用程序中看到一些常见的模式，特别是对于领域和数据层。</p><p id="9c02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看一下同一个应用程序，但是现在使用KMM</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/6c24a34a84b637499da33222ed425800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qwE1vLAEiSAHekS0ihhDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用KMM的Android和iOS应用程序</p></figure><p id="9277" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，使用KMM，我们避免了在域和数据层重复代码。这两层可以用Kotlin编写和共享，在<code class="fe np nq nr ns b">domain</code>的情况下，它可以是一个纯Kotlin模块，对于<code class="fe np nq nr ns b">data</code>层，它可以用Kotlin编写，并使用<code class="fe np nq nr ns b">Ktor</code>客户端库，以便向服务器发送信息。</p><p id="21e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回答最初的问题。KMM试图使用可以在特定平台上使用的共享模块来解决重复代码的问题。</p><h1 id="8798" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何使用KMM构建代码？</h1><p id="2a59" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">构建代码/模块是每个开发人员的责任。但是，在互联网上搜索例子时，我看到了一些在KMM背景下可以分享的常见模式。所以，我们开始吧！</p><h1 id="7a8e" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><strong class="ak">共享业务逻辑+具体平台目标</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/3bf3a8ec81a11fa4af04432863a6298d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niPjMUE4A6NjN60nT5WBFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用KMM共享业务逻辑</p></figure><p id="77a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于KMM来说，这可能是最常见和最流行的用例。通过使用这种结构，您可以使用每个平台的原生工具包(即Android中的Jetpack Compose和iOS中的SwiftUI)构建原生UI组件，并且共享模块可以使用称为<a class="ae nf" href="https://kotlinlang.org/docs/kmm-connect-to-platform-specific-apis.html" rel="noopener ugc nofollow" target="_blank"> actual/expect </a>的功能添加基于平台的特定功能。</p><p id="f393" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它看起来类似于为每个平台创建一个接口并构建一个特定的实现，KMM共享模块负责根据您正在执行的目标选择特定的实现。这种结构的一些例子:</p><ul class=""><li id="0a59" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae nf" href="https://github.com/Kotlin/kmm-basic-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/Kotlin/kmm-basic-sample</a></li><li id="bbd0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae nf" href="https://github.com/mitchtabian/Food2Fork-KMM" rel="noopener ugc nofollow" target="_blank">https://github.com/mitchtabian/Food2Fork-KMM</a></li><li id="0a9b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae nf" href="https://github.com/Kotlin/kmm-production-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/Kotlin/kmm-production-sample</a></li></ul><h1 id="9be1" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">共享业务逻辑+视图模型(表示层)</h1><p id="1799" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">就表示层而言，有不同的架构模式(MVVM、MVC、MVP等)可以用来构建你的代码。让我们使用MVVM在这种情况下，看看下面的图片。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/eaaa7ab480d7dbf98f51653d7e6c32e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6E6Q8Mekv-LQ1dI_3Gbzg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android / iOS中的表示层</p></figure><p id="e2c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，<code class="fe np nq nr ns b">ViewModel</code>是两个平台上的通用类。一般来说，这个类负责向UI发送事件/动作，保存一些属性，并在需要时从外部源获取额外的数据。</p><p id="bde9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看到整个画面，因为我们在KMM的上下文中，我们可以将这个类包含到我们共享的KMM模块中，并将UI的实现留给本机。让我们看看它是什么样子的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ade14f6a636b912e45b9044a672024d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deOd7_Iz4cJTSF80aJ_H4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">KMM与ViewModel共享模块</p></figure><p id="4a1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这种结构，您只需要担心本机UI组件，KMM共享模块将负责管理业务逻辑并通知UI更新。让我们看一些例子:</p><ul class=""><li id="188c" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae nf" href="https://github.com/icerockdev/moko-template" rel="noopener ugc nofollow" target="_blank">https://github.com/icerockdev/moko-template</a></li><li id="f62a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae nf" href="https://github.com/dbaroncelli/D-KMP-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/dbaroncelli/D-KMP-sample</a></li></ul><p id="efa1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是使用KMM的最常见的模式，但是还有更多，也可以根据用例进行定制。</p><ul class=""><li id="9142" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">使用小工具共享UI</strong>:<a class="ae nf" href="https://github.com/dbaroncelli/D-KMP-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/dbaroncelli/D-KMP-sample</a></li><li id="2ddb" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">KMM+React Native:</strong><a class="ae nf" href="https://shopify.engineering/managing-native-code-react-native" rel="noopener ugc nofollow" target="_blank">https://shopify . engineering/managing-Native-code-React-Native</a></li><li id="ccfe" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">来自科特林网站的例子:</strong><a class="ae nf" href="https://kotlinlang.org/docs/kmm-samples.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/kmm-samples.html</a></li></ul><h1 id="601b" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">使用KMM的局限性是什么？</h1><ul class=""><li id="3a89" class="lr ls iq kx b ky mx lb my le mz li na lm nb lq lw lx ly lz bi translated"><strong class="kx ir"> ViewModel: </strong>原生来说，Android中的一个ViewModel <strong class="kx ir"> </strong>应该是从<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>扩展而来，对于iOS，我们应该使用协议<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">ObservableObject</a></code>。如果这些视图模型被移动到一个共享模块。很可能你不能在一个视图模型中同时实现两者(<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>和<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">ObservableObject</a></code>)。所以为了共享视图模型，你可以实现一个设计模式(观察者、发布订阅者等等)或者使用另一个封装了这个功能的库(例如<a class="ae nf" href="https://github.com/dbaroncelli/D-KMP-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/dbaroncelli/D-KMP-sample</a></li><li id="2b16" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">观察属性变化</strong>:在<code class="fe np nq nr ns b">ViewModel</code>内部，通常有不断变化的属性，被UI观察到。在Android的情况下，可以使用<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>来实现，而对于iOS，则是通过用<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">@Published</a></code>标记属性来实现，问题与上一个相同。在一个共享模块中，可能没有办法在同一个属性中同时使用两者，解决方案将是使用另一个库或实现一个设计模式。</li><li id="fc00" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">协程:</strong>让我们想一想<strong class="kx ir"/><code class="fe np nq nr ns b">ViewModel</code>不是共享的。因此，我们可以在每个平台上本地实现它。但在大多数情况下，应用程序需要在UI线程之外做一些工作，将它委托给一些关于后台工作的机制。在Android中，现在最常见的可能是<a class="ae nf" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>，在iOS中是<code class="fe np nq nr ns b"><a class="ae nf" href="https://developer.apple.com/videos/play/wwdc2021/10133/" rel="noopener ugc nofollow" target="_blank">Actors</a></code>。由于共享模块使用Kotlin作为主要语言，在Android中我们可以安全地使用协程或流，但iOS不知道流和协程。好的一面是，我们可以在iOS中使用回调，并且还有一篇由<code class="fe np nq nr ns b">@joreilly</code>撰写的名为<a class="ae nf" href="https://johnoreilly.dev/posts/kmp-native-coroutines/" rel="noopener ugc nofollow" target="_blank">的文章，介绍了一种可能的强大解决方案，该解决方案通过KMP-本地例程</a>弥合了Swift 5.5并发性和Kotlin协同例程之间的差距。</li><li id="1103" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx ir">iOS中的模块化问题:</strong>显然当一个iOS应用试图在不同的模块中使用同一个共享模块时会出现问题。基本上，KMM多次创建同一个模块，而不是只共享一个。更多细节，你可以阅读这篇<a class="ae nf" href="https://medium.com/xorum-io/three-framework-problem-with-kotlin-multiplatform-mobile-16267c5afa53" rel="noopener">文章</a>作者<a class="nv nw ep" href="https://medium.com/u/1ed4e1d57aec?source=post_page-----333af55741af--------------------------------" rel="noopener" target="_blank">耶夫·卡尼维茨</a>。</li></ul><h1 id="285a" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="2c6a" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">暂时就这样了。如果有一些东西需要在不同的移动平台上共享，KMM是一个很好的选择，因为新的选项存在一些限制，这些限制将会逐步得到解决。</p><p id="7d58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，还有一些大型项目在生产中使用KMM(即<a class="ae nf" href="https://netflixtechblog.com/netflix-android-and-ios-studio-apps-kotlin-multiplatform-d6d4d8d25d23" rel="noopener ugc nofollow" target="_blank">网飞</a>、<a class="ae nf" href="https://kotlinlang.org/lp/mobile/case-studies/philips" rel="noopener ugc nofollow" target="_blank">菲利普</a>和<a class="ae nf" href="https://kotlinlang.org/lp/mobile/case-studies/" rel="noopener ugc nofollow" target="_blank">莫尔</a>)，可能没有提到，但是使用KMM也可以进行单元测试。</p><p id="bf87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上可以把KMM看作是一个在平台间共享代码的新选择，Kotlin社区将对其进行改进，你可以控制什么需要共享，什么不需要共享。</p><h1 id="318a" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">参考</h1><ul class=""><li id="715f" class="lr ls iq kx b ky mx lb my le mz li na lm nb lq lw lx ly lz bi translated"><a class="ae nf" href="https://johnoreilly.dev/posts/swift_async_await_kotlin_coroutines/" rel="noopener ugc nofollow" target="_blank">https://johnoreilly . dev/posts/swift _ async _ await _ kot Lin _ coroutines/</a></li><li id="95ec" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae nf" href="https://www.techyourchance.com/kotlin-multiplatform-expert-opinion/" rel="noopener ugc nofollow" target="_blank">https://www . techyourchance . com/kot Lin-multi platform-expert-opinion/</a></li><li id="b827" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">【https://kotlinlang.org/docs/multiplatform.html T4】</li></ul></div></div>    
</body>
</html>