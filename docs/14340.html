<html>
<head>
<title>Configuring App Updates for Mac Catalyst Apps With Sparkle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sparkle为Mac Catalyst应用配置应用更新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/configuring-app-updates-for-mac-catalyst-apps-with-sparkle-beef7a90a515?source=collection_archive---------6-----------------------#2022-11-30">https://betterprogramming.pub/configuring-app-updates-for-mac-catalyst-apps-with-sparkle-beef7a90a515?source=collection_archive---------6-----------------------#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4743" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们在应用商店之外发布应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3d90aaf2b66f92219dafa937a2a133a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMSSdzXzP7jD4XQTUwz1NA.jpeg"/></div></div></figure><p id="f7ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Sparkle是一个开源框架，用于在不通过App Store发布应用程序时将应用程序更新集成到Mac应用程序中。它非常灵活，允许您以简单的方式将自动更新推送到您的应用程序。很可能你已经在你使用的许多应用程序中看到过Sparkle例如，它被用于<em class="ln"> Docker </em>、<em class="ln"> Arc、Hex friend</em>、<em class="ln"> Rectangle、</em>和无数其他应用程序中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/5d10172156cd518f36583d492447ec30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqAVewDdBzTvsKTOm8X-Eg.png"/></div></div></figure><p id="de62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Sparkle的主要特点之一是易于实施。在常规的Cocoa应用程序中，您可以支持应用程序更新，而无需一行代码。</p><p id="986c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，Sparkle也可以在Catalyst应用中工作，但是需要一些额外的工作来启动和运行。</p><h1 id="20d2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak"> 1。创建一个捆绑包</strong></h1><p id="633e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">Sparkle框架需要能够与AppKit对话，因此如果设置在我们的主应用程序中，它将无法正常工作。因此，我们需要制作一个可以访问AppKit APIs的bundle。</p><p id="1fbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Xcode中为macOS创建一个新的目标，在<code class="fe mm mn mo mp b">Framework &amp; Library</code>下选择<code class="fe mm mn mo mp b">Bundle</code>。我称它为“火花插件”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/f9ae4564dbb128cc7add1c519c358e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RC5Imn4u6EITpmaVH7F2ww.png"/></div></div></figure><p id="4fc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，进入你的项目设置，将这个包添加到你的主应用程序的<code class="fe mm mn mo mp b">Frameworks, Libraries, and Embedded Content</code>下。</p><p id="9481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保通过按下过滤器下拉菜单并选择仅<code class="fe mm mn mo mp b">Mac Catalyst</code>来<code class="fe mm mn mo mp b">Embed &amp; Sign</code>并仅使捆绑包在macOS上可用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/f6819259d47f3e9d98b5742ae6d9815c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffCszOWkbip5OS_NGk2PKA.png"/></div></div></figure><h2 id="fe80" class="ms lq iq bd lr mt mu dn lv mv mw dp lz la mx my mb le mz na md li nb nc mf nd bi translated"><strong class="ak"> 2。添加闪耀框架</strong></h2><p id="0f13" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">现在，我们可以将Sparkle作为一个依赖项包含在新创建的包中。选择<code class="fe mm mn mo mp b">File</code> &gt; <code class="fe mm mn mo mp b">Add packages…</code>，使用<code class="fe mm mn mo mp b">https://github.com/sparkle-project/Sparkle</code>作为包URL。</p><p id="812c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当提示选择软件包产品时，记得选择您创建的软件包作为目标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f5a69dce6ea741e258c9e63409f02cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sSmH1Fli84svtXqKf-J-w.jpeg"/></div></div></figure><p id="f0f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们正在将Sparkle添加到我们的捆绑包中，并从我们的主应用程序加载捆绑包，所以应用程序将在我们的应用程序的<code class="fe mm mn mo mp b">/Frameworks</code>目录中寻找Sparkle框架，而不是我们的捆绑包的<code class="fe mm mn mo mp b">/Frameworks</code>中它实际所在的位置——导致出现带有消息<code class="fe mm mn mo mp b">Library not loaded: @rpath/Sparkle.framework/Versions/B/Sparkle</code>的<code class="fe mm mn mo mp b">NSExecutableLinkError (3588)</code>。</p><p id="048e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，进入包的构建设置，搜索“Runpath搜索路径”并添加<code class="fe mm mn mo mp b">@loader_path/../Frameworks</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/4ed01649fe5a7bd0af7dc78e5efae55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHjaMEwkG8P3CcvSz6idHA.jpeg"/></div></div></figure><h1 id="5897" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak"> 3。实现对Sparkle API的调用</strong></h1><p id="e5b5" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">接下来，我们可以开始实现调用，让Sparkle寻找更新。</p><p id="5d8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在此之前，我们的主应用程序需要与我们的Sparkle bundle进行对话。这可以使用协议来完成。</p><p id="7c1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为您的捆绑包在组中创建一个新的Swift文件，并确保将该文件添加到您的应用程序目标和捆绑包目标中。我将协议命名为<code class="fe mm mn mo mp b">SparklePluginProtocol</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/759ca1399f8a4190f90c896eae6d9f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6iN5UemTyULK0Y9uCpxdQ.jpeg"/></div></div></figure><p id="25a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用一个<code class="fe mm mn mo mp b">init()</code>和一个启动更新程序的方法<code class="fe mm mn mo mp b">startUpdater()</code>填充它。</p><p id="0cf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，bundles只能加载暴露给Objective-C的类，所以我们需要使我们的协议符合<code class="fe mm mn mo mp b">NSObjectProtocol</code>来声明这个类是一个NSObject，并使用<code class="fe mm mn mo mp b">@objc(SparklePluginProtocol)</code>进行注释，以便在运行时以Objective-C友好的方式声明协议的名称。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="da89" class="nl lq iq mp b be nm nn l no np">/* SparklePluginProtocol.swift */<br/><br/>@objc(SparklePluginProtocol)<br/>protocol SparklePluginProtocol: NSObjectProtocol {<br/>    init()<br/>    <br/>    func startUpdater()<br/>}</span></pre><p id="bd84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，创建一个仅对Sparkle插件目标可用的新文件。</p><p id="2301" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将用于实现协议的类，并且是负责对Sparkle进行API调用的类。</p><p id="2810" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回想一下，该类需要向Objective-C公开，因此也从NSObject继承。</p><p id="09cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在初始化器中，创建一个新的<code class="fe mm mn mo mp b">SPUStandardUpdaterController</code>，同时确保<code class="fe mm mn mo mp b">startingUpdater</code>是<code class="fe mm mn mo mp b">false</code>，以防止我们在主应用程序中加载包时控制器启动。</p><p id="6a27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，我们将创建一个方法，在正确的时刻从我们的<code class="fe mm mn mo mp b">AppDelegate</code>启动更新程序:</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="fb71" class="nl lq iq mp b be nm nn l no np">/* SparklePlugin.swift */<br/><br/>import Sparkle<br/><br/>@objc<br/>final class SparklePlugin: NSObject, SparklePluginProtocol {<br/>    <br/>    private let updaterController: SPUStandardUpdaterController<br/>    <br/>    override init() {<br/>        <br/>        updaterController = SPUStandardUpdaterController(<br/>            startingUpdater: false,<br/>            updaterDelegate: nil,<br/>            userDriverDelegate: nil<br/>        )<br/>        <br/>    }<br/>    <br/>    func startUpdater() {<br/>        updaterController.startUpdater()<br/>    }<br/>    <br/>}</span></pre><h1 id="25b3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak"> 4。创建一个与捆绑包通信的接口</strong></h1><p id="7444" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">回到我们的主应用程序，只为您的应用程序目标创建一个新文件，该文件将包含加载软件包的代码，并通过我们刚刚制定的协议调用Sparkle APIs。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/33ef4a74c2e11ed155ef301e2657830c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RWUPcVVfdTrOQzTIfHgYA.jpeg"/></div></div></figure><p id="8850" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从加载包开始，创建一个新的结构，并通过将它包装在<code class="fe mm mn mo mp b">#if targetEnvironment(macCatalyst)</code>中确保它只在Mac Catalyst中可用。</p><p id="9fbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于加载包可能会失败，我们创建了一个可选的初始化器，如果成功的话，就将<code class="fe mm mn mo mp b">sparklePlugin</code>设置为静态函数<code class="fe mm mn mo mp b">loadSparklePlugin()</code>的结果。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="acd8" class="nl lq iq mp b be nm nn l no np">/* SparklePluginInterface.swift */<br/><br/>#if targetEnvironment(macCatalyst)<br/>struct SparklePluginInterface {<br/>    <br/>    private let sparklePlugin: SparklePluginProtocol<br/>    <br/>    init?() {<br/>        guard let sparklePlugin = Self.loadSparklePlugin() else {<br/>            return nil<br/>        }<br/>        <br/>        self.sparklePlugin = sparklePlugin<br/>    }<br/>}<br/>#endif</span></pre><p id="a68a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">加载插件的过程如下。如果加载包失败，程序将仅由于<code class="fe mm mn mo mp b">assertionFailure()</code>而在<code class="fe mm mn mo mp b">DEBUG</code>暂停。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="5a62" class="nl lq iq mp b be nm nn l no np">/* SparklePluginInterface.swift */<br/><br/>private static func loadSparklePlugin() -&gt; SparklePluginProtocol? {<br/>    guard<br/>        let bundleUrl = Bundle.main.builtInPlugInsURL?.appendingPathComponent("SparklePlugin.bundle"),<br/>        let bundle = Bundle(url: bundleUrl)<br/>    else {<br/>        return nil<br/>    }<br/>    <br/>    do {<br/>        try bundle.loadAndReturnError()<br/>    } catch {<br/>        print(error)<br/>        assertionFailure()<br/>        return nil<br/>    }<br/>    <br/>    guard<br/>        let SparklePlugin = bundle.classNamed("SparklePlugin.SparklePlugin") as? SparklePluginProtocol.Type<br/>    else {<br/>        return nil<br/>    }<br/>    <br/>    return SparklePlugin.init()<br/>}</span></pre><p id="6329" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们可以添加一个方法来启动更新程序:</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="d833" class="nl lq iq mp b be nm nn l no np">/* SparklePluginInterface.swift */<br/><br/>func startUpdater() {<br/>  sparklePlugin.startUpdater()<br/>}</span></pre><p id="d189" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">产生接口的完整代码:</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="7100" class="nl lq iq mp b be nm nn l no np">/* SparklePluginInterface.swift */<br/><br/>#if targetEnvironment(macCatalyst)<br/>struct SparklePluginInterface {<br/>    <br/>    private let sparklePlugin: SparklePluginProtocol<br/>    <br/>    init?() {<br/>        guard let sparklePlugin = Self.loadSparklePlugin() else {<br/>            return nil<br/>        }<br/>        <br/>        self.sparklePlugin = sparklePlugin<br/>    }<br/>    <br/>    func startUpdater() {<br/>        sparklePlugin.startUpdater()<br/>    }<br/><br/>}<br/><br/>extension SparklePluginInterface {<br/>    private static func loadSparklePlugin() -&gt; SparklePluginProtocol? {<br/>        guard<br/>            let bundleUrl = Bundle.main.builtInPlugInsURL?.appendingPathComponent("SparklePlugin.bundle"),<br/>            let bundle = Bundle(url: bundleUrl)<br/>        else {<br/>            return nil<br/>        }<br/>        <br/>        do {<br/>            try bundle.loadAndReturnError()<br/>        } catch {<br/>            print(error)<br/>            assertionFailure()<br/>            return nil<br/>        }<br/>        <br/>        guard<br/>            let SparklePlugin = bundle.classNamed("SparklePlugin.SparklePlugin") as? SparklePluginProtocol.Type<br/>        else {<br/>            return nil<br/>        }<br/>        <br/>        return SparklePlugin.init()<br/>    }<br/>}<br/><br/>#endif</span></pre><h1 id="7d33" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak"> 5。在AppDelegate中启动Sparkle</strong></h1><p id="e34e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">接下来，您可以启动Sparkle并查看更新。</p><p id="19d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在AppDelegate中初始化Sparkle接口，并在AppDelegate的<code class="fe mm mn mo mp b">didFinishLaunchingWithOptions</code>方法中运行<code class="fe mm mn mo mp b">startUpdater()</code>。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="f162" class="nl lq iq mp b be nm nn l no np">/* AppDelegate.swift */<br/><br/>#if targetEnvironment(macCatalyst)<br/>let sparkleInterface = SparklePluginInterface()<br/>#endif<br/><br/>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {<br/><br/>    // Setup sparkle<br/>    #if targetEnvironment(macCatalyst)<br/>    sparkleInterface?.startUpdater()<br/>    #endif<br/><br/>    return true<br/>}</span></pre><h1 id="0915" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">6。配置闪耀设置</h1><p id="331b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">最后，可以在你的主App的<code class="fe mm mn mo mp b">Info.plist</code>中配置Sparkle。您需要在<code class="fe mm mn mo mp b">SUFeedURL</code>键下提供一个到appcast流的URL，您的更新驻留在该流中。</p><p id="e139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Sparkle还需要一个公钥来检查<code class="fe mm mn mo mp b">SUPublicEDKey</code>密钥下的更新签名。有关更多信息，请参见<a class="ae nr" href="https://sparkle-project.org/documentation/#3-segue-for-security-concerns" rel="noopener ugc nofollow" target="_blank"> Sparkle的文档</a>，特别是步骤3–6。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="610d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以根据自己的喜好定制Sparkle，并添加更多功能。</p><p id="4c01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个常见的附加功能是为用户创建一个菜单项来手动检查更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/09bbcd842a49f9657cb310a1adf8b239.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*y2FKlWXFDRUy4sAo-4eZQw.png"/></div></figure><p id="43e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从我们的AppDelegate开始，在<code class="fe mm mn mo mp b">buildMenu</code>方法中添加一个新的应用程序菜单项。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="13a1" class="nl lq iq mp b be nm nn l no np">/* AppDelegate.swift */<br/><br/>override func buildMenu(with builder: UIMenuBuilder) {<br/>    super.buildMenu(with: builder)<br/><br/>    guard builder.system == UIMenuSystem.main else { return }<br/><br/>    // Add `Check for updates`<br/>    #if targetEnvironment(macCatalyst)<br/>    if let appMenu = builder.menu(for: .application) {<br/>        let checkForUpdatesItem = UICommand(title: "Check for updates", action: #selector(didPressCheckForUpdates(sender:)))<br/>        var children = appMenu.children<br/>        children.insert(checkForUpdatesItem, at: 1)<br/>        let menu = UIMenu(title: appMenu.title, image: appMenu.image, identifier: appMenu.identifier, options: appMenu.options, children: children)<br/>        builder.replace(menu: .application, with: menu)<br/>    }<br/>    #endif<br/>}<br/><br/>#if targetEnvironment(macCatalyst)<br/>@objc<br/>func didPressCheckForUpdates(sender: Any?) {<br/>    sparkleInterface?.checkForUpdates(sender: sender)<br/>}<br/>#endif</span></pre><p id="1caf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，在SparklePluginInterface中添加一个方法，将消息转发给插件。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="f3ae" class="nl lq iq mp b be nm nn l no np">/* SparklePluginInterface.swift */<br/><br/>struct SparklePluginInterface {<br/>    <br/>    /* ... */<br/>    <br/>    func checkForUpdates(sender: Any?) {<br/>        sparklePlugin.checkForUpdates(sender: sender)<br/>    }<br/>}</span></pre><p id="05ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在包中，添加一个<code class="fe mm mn mo mp b">checkForUpdates(sender:)</code>方法，并在您的<code class="fe mm mn mo mp b">SparklePlugin</code>类中实现。</p><pre class="kg kh ki kj gt nh mp ni bn nj nk bi"><span id="5d60" class="nl lq iq mp b be nm nn l no np">/* SparklePluginProtocol.swift */ <br/><br/>@objc(SparklePluginProtocol)<br/>protocol SparklePluginProtocol: NSObjectProtocol {<br/>    <br/>    /* ... */<br/><br/>    func checkForUpdates(sender: Any?)<br/>}</span></pre><pre class="oa nh mp ni bn nj nk bi"><span id="05be" class="nl lq iq mp b be nm nn l no np">/* SparklePlugin.swift */<br/><br/>@objc<br/>final class SparklePlugin: NSObject, SparklePluginProtocol {<br/>    <br/>    private let updaterController: SPUStandardUpdaterController<br/>    <br/>    /* ... */<br/>    <br/>    func checkForUpdates(sender: Any?) {<br/>        updaterController.checkForUpdates(sender)<br/>    }<br/>    <br/>}</span></pre><p id="b99d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是实现对Sparkle的新调用时的一般方法:</p><ul class=""><li id="6684" class="ob oc iq kt b ku kv kx ky la od le oe li of lm og oh oi oj bi translated">在包中的SparklePlugin类中实现对Sparkle的调用。</li><li id="c179" class="ob oc iq kt b ku ok kx ol la om le on li oo lm og oh oi oj bi translated">将方法描述添加到SparklePluginProtocol中。</li><li id="f4a3" class="ob oc iq kt b ku ok kx ol la om le on li oo lm og oh oi oj bi translated">向SparklePluginInterface添加一个方法，将调用转发到您的bundle。</li></ul></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="94ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你。您已成功将Sparkle应用更新添加到您的Mac Catalyst应用。</p><p id="5316" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与普通的Cocoa应用程序相比，Mac Catalyst应用程序中的过程更加繁琐，因为它需要为框架创建一个单独的包来与AppKit进行对话。</p></div></div>    
</body>
</html>