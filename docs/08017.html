<html>
<head>
<title>Battle of the iOS Architecture Patterns: Model View Controller (MVC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS架构模式之战:模型视图控制器(MVC)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6?source=collection_archive---------5-----------------------#2021-03-16">https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6?source=collection_archive---------5-----------------------#2021-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="46c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">iOS开发最常见的架构模式入门</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e77fc3ca0073e398566e7006e0661704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTIRA_rPd19jNWSE9k67ig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">架构系列—模型视图控制器(MVC)</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="852e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">动机</h1><p id="f842" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在开始开发一个iOS应用之前，我们必须考虑项目的结构。我们需要考虑如何将这些代码添加到一起，以便它们在以后有意义——当我们回来重新访问应用程序的一部分时——以及如何与其他开发人员形成已知的“语言”。</p><p id="83a4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们从一系列文章开始，在这些文章中，我们通过最著名的iOS开发模式来开发一个应用程序。我们将检查构建时间和每个模式的优缺点，但最重要的是，我们将看到实际的实现和源代码。</p><p id="d6b4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果您只想看代码，可以跳过这篇文章。该代码可以在<a class="ae mv" href="https://github.com/radude89/footballgather-ios" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上开源获得。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="e3fb" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">为什么你的iOS应用需要一个架构模式？</h1><p id="5f71" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">最需要考虑的是要有一个可维护的app。你知道视图在那里，这个视图控制器应该做X而不是y。更重要的是，其他人也知道。</p><p id="52ff" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">以下是选择一个好的架构模式的一些优势:</p><ul class=""><li id="511b" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">更易于维护</li><li id="8580" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更容易测试业务逻辑</li><li id="2322" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">与其他队友发展共同语言</li><li id="8dfa" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">分离实体的职责</li><li id="b315" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更少的错误</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="c2e9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">定义需求</h1><p id="e5b9" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">给定一个有六七个屏幕的iOS应用程序，我们将使用iOS世界最流行的架构模式来开发它:MVC、MVVM、MVP、VIPER、VIP和Coordinators。</p><p id="f386" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">该演示应用程序名为Football Gather，是朋友们跟踪业余足球比赛比分的一种简单方式。</p><h2 id="9397" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">主要特征</h2><p id="4637" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">能够:</p><ul class=""><li id="3131" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">在应用程序中添加玩家</li><li id="76ae" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">给运动员分配队伍</li><li id="656a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">编辑玩家</li><li id="18ef" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">为比赛设置倒计时</li></ul><h2 id="51ee" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">屏幕模型</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b97818c3cb481cc6d4dbb47fa8d7b77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPn1fBii-lnU4ZfbgjwszQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS应用“Football Gather”的屏幕模型</p></figure><h2 id="35b1" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">后端</h2><p id="d490" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">该应用由在Vapor web框架中开发的web应用提供支持。你可以查看我的<a class="ae mv" href="radude89.com/blog/vapor.html" rel="noopener ugc nofollow" target="_blank"> Vapor 3初始篇</a>和<a class="ae mv" href="https://www.radude89.com/blog/migrate-to-vapor4.html" rel="noopener ugc nofollow" target="_blank">关于迁移到Vapor 4 </a>的文章中的app。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="b434" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">什么是MVC？</h1><p id="918e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">MVC可能是世界上最著名的架构模式。</p><p id="24f6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">有三个组件:<strong class="lw ir">模型</strong>、<strong class="lw ir">视图、</strong>和<strong class="lw ir">控制器</strong>。</p><h2 id="35ec" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">模型</h2><ul class=""><li id="b7a9" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">它包含你所有的数据类，助手，网络代码。</li><li id="a12d" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它拥有特定于您的应用程序的所有数据，并定义了处理这些数据的逻辑，</li><li id="7aab" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">在我们的应用中，模型代表了在实用程序、存储和网络组中发现的内容。</li><li id="d376" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它可以与其他模型对象有1:M和多对多关系，就像我们有玩家和聚集(多对多)或用户和玩家/聚集(1:M)。</li><li id="6d64" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它不应该直接与视图通信，也不应该关心用户界面。</li></ul><p id="e52b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">通讯</strong></p><ul class=""><li id="603d" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">当视图层中发生一些事情时，例如当用户发起一个动作时，它通过控制器传递给模型。</li><li id="083e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">当模型改变时，例如当新数据可用时，模型通知控制器。</li></ul><h2 id="8421" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">视角</h2><ul class=""><li id="733b" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">视图代表用户在屏幕上看到的内容。</li><li id="af8f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它响应用户的动作。</li><li id="c109" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">视图的目的是显示来自模型的数据，并使其可用于用户交互。</li><li id="04eb" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">关键的苹果框架是UIKit和AppKit。</li><li id="4524" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">我们应用程序中的例子有:<code class="fe oa ob oc od b">LoadingView</code>、<code class="fe oa ob oc od b">EmptyView</code>、<code class="fe oa ob oc od b">PlayerTableViewCell</code>和<code class="fe oa ob oc od b">ScoreStepper</code>。</li></ul><p id="1d3d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">通信</strong></p><ul class=""><li id="c98b" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">视图不能直接与模型交流。一切都是通过控制器来完成的。</li></ul><h2 id="cdbf" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">控制器</h2><ul class=""><li id="964e" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">这是MVC的核心层。</li><li id="5369" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它负责视图更新并改变模型。</li><li id="c55e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">它负责模型更新和视图更新。</li><li id="3a20" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">控制器可以有设置方法或任务来管理其他对象的生命周期。</li></ul><p id="8277" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">沟通</strong></p><ul class=""><li id="d9b5" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">可以与模型层和视图层进行通信。</li><li id="52d5" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">控制器解释用户操作，并通过模型层触发对数据的更改。</li><li id="7855" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">当数据改变时，它确保那些改变被传达给用户界面，更新视图</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="ed6b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">不同风格的MVC</h1><p id="d18d" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">传统的MVC与Cocoa的MVC不同:视图层和模型层可以相互通信。</p><p id="4fd7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">视图是无状态的，一旦模型被更新，就由控制器呈现。</p><p id="2ffd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">它被引入到<a class="ae mv" href="https://en.wikipedia.org/wiki/Smalltalk" rel="noopener ugc nofollow" target="_blank"> Smalltalk-79 </a>中，并被创建在几种设计模式之上:复合、策略和观察者。(下面的定义来自<a class="ae mv" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#:~:text=Strategy%E2%80%94A%20controller%20object%20implements,meaning%20of%20the%20interface%20behavior" rel="noopener ugc nofollow" target="_blank">苹果的模型-视图-控制器文档</a>。)</p><h2 id="b255" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">复合材料</h2><blockquote class="oe of og"><p id="b338" class="lu lv oh lw b lx mq jr lz ma mr ju mc oi ms mf mg oj mt mj mk ok mu mn mo mp ij bi translated">应用程序中的视图对象实际上是以协调方式(即视图层次结构)一起工作的嵌套视图的组合。这些显示组件的范围从窗口到复合视图(如表格视图)，再到单个视图(如按钮)。用户输入和显示可以发生在复合结构的任何级别。”</p></blockquote><p id="986a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">想想<code class="fe oa ob oc od b">UIView</code>的等级制度。视图是用户界面的主要组成部分。它们可以包含其他子视图。例如，在我们的应用程序中，<code class="fe oa ob oc od b">LoginViewController</code>的主视图包含一系列堆栈视图，其中有用于输入用户名和密码的文本字段以及登录按钮。</p><h2 id="cfb6" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">战略</h2><blockquote class="oe of og"><p id="faff" class="lu lv oh lw b lx mq jr lz ma mr ju mc oi ms mf mg oj mt mj mk ok mu mn mo mp ij bi translated">控制器对象为一个或多个视图对象实现策略。视图对象将其自身限制在维护其视觉方面，并且它将所有关于界面行为的应用特定含义的决定委托给控制器。”</p></blockquote><h2 id="e7d9" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">观察者</h2><blockquote class="oe of og"><p id="e868" class="lu lv oh lw b lx mq jr lz ma mr ju mc oi ms mf mg oj mt mj mk ok mu mn mo mp ij bi translated">"模型对象让应用程序中感兴趣的对象(通常是视图对象)知道其状态的变化."</p></blockquote><p id="42b5" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">旧MVC的主要缺点是所有三层都是紧密耦合的。很难测试、维护它们，甚至重用一些逻辑。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="de47" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">如何以及何时使用MVC</h1><p id="3410" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">看情况。</p><p id="d4dd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果做对了，每个app都可以用。没有明确的是或否的答案——这取决于你的应用、团队、组织、项目的发展、开发人员的技能、最后期限等等。</p><p id="9ea7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">但是，您应该考虑一些脆弱点:</p><ul class=""><li id="5221" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">正如您所看到的，控制器是这个架构模式的中心。它与视图和模型层有很强的耦合。</li><li id="6071" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">控制器可能变成众所周知的大规模视图控制器。</li><li id="4ae9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更难测试。</li></ul><p id="d8ba" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">有很多方法可以解决上面提到的问题。其中一个是将视图控制器拆分成小视图控制器，其中有一个大容器/父视图控制器充当协调器，应用程序的每个区域由不同的或子视图控制器处理。</p><p id="9614" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为什么应该使用MVC:</p><ul class=""><li id="255d" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">这是Apple推荐的，并在他们的框架中使用(例如UIKit)</li><li id="9f5e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">许多开发人员都知道这种模式，这使得与他们合作变得很容易。</li><li id="42a9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">与其他架构模式相比，您编写代码的速度更快。</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="8828" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">将MVC应用于我们的代码</h1><p id="a6a5" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在Football Gather中，我们将每个屏幕实现为一个视图控制器:</p><h2 id="27f8" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><strong class="ak">登录屏幕—登录视图控制器</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/502ece9608ce558d6578ce43541b4825.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*6YphldwVxPepmLLwXoykEA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">登录屏幕</p></figure><p id="90a4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="69c8" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">用户可以使用其凭据登录或创建新用户的登录页面</li></ul><p id="e806" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="782b" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">usernameTextField</code> —用户输入用户名的文本字段</li><li id="e6ff" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">passwordTextField</code> —用于输入密码的安全文本字段</li><li id="63ed" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">rememberMeSwitch</code>—<code class="fe oa ob oc od b">UISwitch</code>用于在登录后将用户名保存在钥匙串中，以便下次我们进入应用程序时自动填充该字段</li><li id="e248" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView</code> —用于在进行服务器调用时显示指示器</li></ul><p id="f2f2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务</strong></p><ul class=""><li id="23c4" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loginService</code> —用于使用输入的凭证调用登录API</li><li id="b05c" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">usersService</code> —用于调用注册API，创建新用户</li></ul><p id="725d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们可以看到，这个类有三大功能:登录，注册，记住我的用户名。通过<code class="fe oa ob oc od b">performSegue</code>跳转到下一个屏幕。</p><p id="f99f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">代码片段</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="6112" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">播放器列表屏幕—播放器列表视图控制器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d8caaa5faec6759a0a8371cbdfe7b5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*QXuIozIdYMrVVmlND7TKVQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">玩家列表和选择屏幕</p></figure><p id="78f4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="b880" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">为登录用户显示玩家。由主牌桌视图组成，每个玩家显示在单独的一行中。</li></ul><p id="2960" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="b219" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerTableView</code> —显示玩家的桌面视图</li><li id="f74b" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">confirmOrAddPlayersButton</code> —视图底部的动作按钮，可以对应于添加玩家的动作，也可以确认选中的玩家</li><li id="7bb5" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView</code> —用于在进行服务器调用时显示指示器</li><li id="8c90" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">emptyView </code> —当用户没有添加任何玩家时显示</li><li id="8c8f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">barButtonItem</code> —右上角的按钮，根据我们所处的视图模式可以有不同的状态。当我们进入选择模式选择我们想要聚集的玩家时，标题为“取消”,或者当我们处于查看模式时，标题为“选择”。</li></ul><p id="e04e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务</strong></p><ul class=""><li id="9f22" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b"><strong class="lw ir">playersService </strong></code> —用于检索玩家列表和删除玩家</li></ul><p id="c771" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">型号</strong></p><ul class=""><li id="dc34" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">players </code> —用户创建的玩家数组。这些是我们在<code class="fe oa ob oc od b">playerTableView</code>中看到的行。</li><li id="f06f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">selectedPlayersDictionar</code> y —一个缓存字典，将所选播放器的行索引存储为键，将所选播放器存储为值</li></ul><p id="378b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果你打开<code class="fe oa ob oc od b">Main.storyboard</code>，你可以看到从这个视图控制器你可以执行三个阶段。</p><ul class=""><li id="1d91" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">ConfirmPlayersSegueIdentifier </code> —在你选择了你想要的队员后，你进入一个确认界面，在那里你可以分配他们所属的队伍。</li><li id="7673" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">PlayerAddSegueIdentifier </code> —转到可以创建新玩家的屏幕</li><li id="4963" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">PlayerDetailSegueIdentifier</code> —打开一个屏幕，您可以在其中查看玩家的详细信息</li></ul><p id="f11b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们有以下函数来检索这个视图控制器的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5b5b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果我们想删除一个玩家，我们做以下事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8479" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">服务呼叫如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="6d28" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">添加播放器屏幕— PlayerAddViewController</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/457377a2397e4d5a21c7511c248d500c.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*gLqs6i3Bk5IETskYnVZZXg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加玩家屏幕</p></figure><p id="c5de" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="5942" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">该屏幕用于创建播放器。</li></ul><p id="9c05" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="9a22" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerNameTextField</code> —用于输入玩家的名字</li><li id="44a9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">doneButton </code> —用于确认要创建的播放器并发起服务呼叫的条形按钮项</li><li id="886b" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView</code> —用于在进行服务器调用时显示指示器</li></ul><p id="ffa7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务</strong></p><ul class=""><li id="80a9" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">我们使用指向/api/players的<code class="fe oa ob oc od b">StandardNetworkService</code>。要添加玩家，我们需要发起一个发布请求。</li></ul><p id="2847" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">代码片段</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="73f0" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">玩家详细信息屏幕—玩家详细视图控制器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c328a559e7be0ef88f456ab8bab728a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*jo4gTeJ5KJrNgHAfipVc1A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">玩家详细信息屏幕</p></figure><p id="d7ef" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="cc78" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">映射一个显示玩家详细信息的屏幕(姓名、年龄、位置、技能和最喜欢的球队)</li></ul><p id="6aec" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="7d69" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerDetailTableView<strong class="lw ir"> </strong></code> —显示玩家详细信息的表格视图</li></ul><p id="fa94" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">型号</strong></p><ul class=""><li id="9eee" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">player </code> —玩家的型号为<code class="fe oa ob oc od b">PlayerResponseModel</code></li></ul><p id="8b15" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们在此<code class="fe oa ob oc od b">ViewController</code>没有服务。从<code class="fe oa ob oc od b">PlayerEditViewController</code>接收更新玩家信息的请求，并通过委托传递给<code class="fe oa ob oc od b">PlayerListViewController</code>。</p><p id="5cec" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这些部分由工厂模式制成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="db5c" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">编辑播放器屏幕— PlayerEditViewController</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/b7e74f21494d5c8785826ee53cf332d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GqBPxJYr0Ltos2rXbI-VA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编辑玩家-首选位置、技能或年龄</p></figure><p id="9bf3" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="a109" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">编辑玩家的信息</li></ul><p id="74ed" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">用户界面元素</strong></p><ul class=""><li id="5752" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">d——填充了我们想要编辑的玩家详细信息的字段</li><li id="04ca" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerTableView</code> —我们希望有一个类似的行为和用户界面，就像我们在iOS常规设置中编辑细节一样。这个表格视图要么有一行带有文本字段，要么有多行带有选择行为。</li><li id="c4f3" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView</code> —用于在进行服务器调用时显示指示器</li><li id="ba64" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">doneButton</code> —执行编辑动作的<code class="fe oa ob oc od b">UIBarButtonItem</code></li></ul><p id="9d27" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务</strong></p><ul class=""><li id="961e" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">更新播放器API，用作<code class="fe oa ob oc od b">StandardNetworkService</code>:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="822a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">型号</strong></p><ul class=""><li id="6bf6" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">viewType</code> —可以是<code class="fe oa ob oc od b">.text</code>(用于通过键盘输入的玩家详细信息)或<code class="fe oa ob oc od b">.selection</code>(用于通过点击其中一个单元格选择的玩家详细信息，例如，首选位置)的枚举</li><li id="e121" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">player </code> —我们想要编辑的球员</li><li id="3cbe" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">items </code> —对应于首选职位或技能的所有可能选项的字符串数组。当一个文本条目将要被编辑时，这个数组是<code class="fe oa ob oc od b">nil</code>。</li></ul><h2 id="517d" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">确认屏幕—确认播放器视图控制器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/362bc67d05ecbefb8f508567be851447.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*I4IIAem61DPQvhcfAOmX8w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">确认玩家屏幕</p></figure><p id="62e8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="214d" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">在到达集合界面之前，我们想把玩家放在想要的队伍中。</li></ul><p id="df32" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="08c2" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerTableView</code> —一个分成三个部分(替补、A队和B队)的表格视图，显示我们想要集合的选定球员</li><li id="5607" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">startGatherButton</code> —最初禁用，当点击时会触发一个动作来执行开始收集所需的网络API调用，最后，它会推动下一个屏幕</li><li id="b64a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView</code> —用于在进行服务器调用时显示指示器</li></ul><p id="36e9" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务业</strong></p><ul class=""><li id="0ce6" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">Create Gathe</code> r —通过向<code class="fe oa ob oc od b">/api/gathers</code>发出POST请求来添加新的集合。</li><li id="5b06" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">Add Player to Gather</code> —在我们为玩家选择完队伍后，我们通过向<code class="fe oa ob oc od b">api/gathers/{gather_id}/players/{player_id}</code>发送POST请求将他们添加到集合中。</li></ul><p id="7e48" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">型号</strong></p><ul class=""><li id="2c48" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b"><strong class="lw ir">playersDictionary </strong></code> —每支球队都有一个球员数组，所以字典将球队作为键(A队、B队或替补)，对于值，我们有选定的球员(球员数组)。</li></ul><p id="9349" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">当我们完成选择(UI)时，会创建一个新的集合，并为每个玩家分配一个团队。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d2c2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">添加玩家的for循环如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="9465" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">收集屏幕—确认播放视图控制器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/eec92a4a4b976883105dd28b5e7e19d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*wsLkeuopxP3zEHqIYdB0Fw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">收集屏幕</p></figure><p id="ccbf" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">描述</strong></p><ul class=""><li id="9386" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">这是应用程序的核心屏幕，在这里你处于聚集模式，启动/暂停或停止计时器，最后，完成比赛。</li></ul><p id="97ae" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir"> UI元素</strong></p><ul class=""><li id="4c39" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">playerTableView </code> —用于显示集合中的玩家，分为两部分:A队和B队</li><li id="8829" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">scoreLabelView</code> —一个视图有两个显示分数的标签，一个用于团队A，另一个用于团队B</li><li id="ee5f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">scoreStepper</code> —有两个团队步进器的视图</li><li id="97bd" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">timerLabel</code> —用于以mm:ss格式显示剩余时间</li><li id="e18e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">timerView </code> —具有UIPickerView视图的叠加视图，用于选择采集时间</li><li id="81cf" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">timePickerView </code> —具有两个组件(分和秒)的选取器视图，用于选择采集时间</li><li id="ec4d" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">actionTimerButton</code> —管理倒计时定时器的不同状态按钮(恢复、暂停和开始)</li><li id="0f50" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">loadingView </code> —用于在进行服务器调用时显示指示器</li></ul><p id="506a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">服务</strong></p><ul class=""><li id="6e7d" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">Update Gather</code> —当一次收集结束时，我们发出一个上传请求来更新获胜团队和分数。</li></ul><p id="c6e2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">型号</strong></p><ul class=""><li id="6bd8" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">GatherTime </code> —以分钟和秒为整数的元组</li><li id="cd82" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">gatherModel</code> —包含聚集ID和一组玩家团队模型(玩家响应模型和玩家所属的团队)。这是从<code class="fe oa ob oc od b">ConfirmPlayersViewController</code>创建和传递的。</li><li id="b59e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">timer</code> —用于倒计时采集的分钟和秒钟。</li><li id="c101" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">timerState</code> —可以有三种状态:<code class="fe oa ob oc od b">stopped</code>、<code class="fe oa ob oc od b">running</code>和<code class="fe oa ob oc od b">paused</code>。我们观察其中一个值何时被设置，这样我们就可以相应地更改<code class="fe oa ob oc od b">actionTimerButton</code>的标题。当它暂停时，按钮的标题将是<code class="fe oa ob oc od b">Resume</code>。当它运行时，按钮的标题将是<code class="fe oa ob oc od b">Pause</code>和<code class="fe oa ob oc od b">Start</code>当定时器停止时。</li></ul><p id="50ed" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">当点击<code class="fe oa ob oc od b">actionTimerButton</code>时，我们验证是否要使计时器无效或启动计时器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b729" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">要取消计时器，我们需要执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="c38c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">选择器<code class="fe oa ob oc od b">updateTimer</code>每秒调用一次:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a885" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在结束集合之前，我们会检查获胜者团队:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="65de" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">服务呼叫:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e518" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">私有方法<code class="fe oa ob oc od b">updateGather</code>是从<code class="fe oa ob oc od b">endGather</code>调用的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="c9ce" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">测试我们的业务逻辑</h1><p id="70f3" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们看到了将MVC应用于演示应用Football Gather的第一次迭代。当然，我们可以重构代码，让它变得更好，分离一些逻辑，把它分成不同的类，但是为了练习，我们将保留这个版本的代码库。</p><p id="dead" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们看看如何为我们的类编写单元测试。我们将以<code class="fe oa ob oc od b">GatherViewController</code>为例，试图达到接近100%的代码覆盖率。</p><p id="5f11" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">首先，我们看到<code class="fe oa ob oc od b">GatherViewController</code>是<code class="fe oa ob oc od b">Main storyboard</code>的一部分。为了使我们的生活更容易，我们使用一个标识符，并用方法<code class="fe oa ob oc od b">storyboard.instantiateViewController</code>实例化它。让我们将<code class="fe oa ob oc od b">setUp</code>方法用于此逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ae69" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">对于我们的第一个测试，我们验证所有插座都不是<code class="fe oa ob oc od b">nil</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2706" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在我们来看看<code class="fe oa ob oc od b">viewDidLoad</code>是否被调用。已经设置了标题并配置了一些属性。我们验证公共参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b232" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">变量<code class="fe oa ob oc od b">timerView</code>是一个弹出的自定义视图，用户可以在其中设置他们的比赛计时器。</p><p id="1032" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">接下来，让我们对表视图方法进行单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="886a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们只有两个团队:<code class="fe oa ob oc od b">Team A</code>和<code class="fe oa ob oc od b">Team B</code>。<code class="fe oa ob oc od b">Bench</code>团队不可见，也不属于这个屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="076c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们的表格视图应该有两个部分，两个标题都设置为团队名称(团队A和团队B)。</p><p id="5b38" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了检查行数，我们注入一个模拟的聚集模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2c3e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">单元测试用于验证部分中的行数，加上部分无效时的Nil场景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4324" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了显示玩家的详细信息，我们使用普通的表格视图单元格，用玩家的名字设置<code class="fe oa ob oc od b">textLabel</code>,用玩家的首选位置设置<code class="fe oa ob oc od b">detailTextLabel</code>。</p><p id="9de4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们验证这些属性是否已设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b7ea" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">太好了！我们现在已经成功地测试了我们的模型。这并不难，但我们必须模仿一些东西，使用故事板，检查表格视图委托和数据源，以及许多用于验证业务逻辑的UI东西。</p><p id="058c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们继续使用<code class="fe oa ob oc od b">pickerView</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dc3b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">验证组件数量的唯一方法是公开枚举<code class="fe oa ob oc od b">GatherCountDownTimerComponent</code>。</p><p id="ce85" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">测试组件中的行数有点类似于我们为玩家<code class="fe oa ob oc od b">tableView</code>所做的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="af2c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">行数应该等于分钟数和秒数。行的标题是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5e28" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们看看如何测试<code class="fe oa ob oc od b">IBActions</code>。</p><p id="0e1b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">setTimer</code>动作配置选取器视图(它将选取器视图组件设置为选定的分和秒。如果没有，默认为10分钟)并隐藏<code class="fe oa ob oc od b">timerView</code>叠加。</p><p id="a0bb" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们唯一的公共财产是<code class="fe oa ob oc od b">timerView</code>。我们调用<code class="fe oa ob oc od b">setTimer</code>并验证<code class="fe oa ob oc od b">timerView</code>没有隐藏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="3191" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们为<code class="fe oa ob oc od b">cancelTimer</code>复制相同的逻辑，但是这次我们的<code class="fe oa ob oc od b">timerView</code>应该被隐藏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b080" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">和<code class="fe oa ob oc od b">timerView</code>弹出菜单中覆盖按钮的类似方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b85d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">事情变得越来越难:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8365" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们验证<code class="fe oa ob oc od b">timerView</code>是否隐藏，分钟和秒钟是否已设置。我们无法访问<code class="fe oa ob oc od b">ViewController</code>的默认时间，所以我们使用<code class="fe oa ob oc od b">XCTAssertGreaterThan</code>作为分钟组件。</p><p id="fd34" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们看看我们的计时器是否对行更改做出反应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e112" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在这个测试中，我们选择第一行，所以时间将是<strong class="lw ir"> 00:00 </strong>。然后我们调用<code class="fe oa ob oc od b">timerDone</code>方法和<code class="fe oa ob oc od b">actionTimer</code>。它会击中卫兵的声明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f4b6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在，测试快乐路径:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="983d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">当我们处于初始状态时，我们检查<code class="fe oa ob oc od b">actionTimerButton</code>是否有标题<code class="fe oa ob oc od b">Start</code>。在我们调用了<code class="fe oa ob oc od b">actionTimer</code>之后，<code class="fe oa ob oc od b">actionTimerButton</code>现在应该有了标题<code class="fe oa ob oc od b">Pause</code>(因为计时器正在计时，比赛已经开始)。</p><p id="458b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们将秒部分设置为1。因此，如果我们在两秒钟后调度，我们应该已经停止，计时器应该失效，并且<code class="fe oa ob oc od b">actionTimerButton</code>应该回到其初始状态，标题为<code class="fe oa ob oc od b">Start</code>。</p><p id="6fce" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了等待期望的实现，我们使用<code class="fe oa ob oc od b">waitForExpectations</code>，超时5秒。</p><p id="01a6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">检查<code class="fe oa ob oc od b">Resum<strong class="lw ir">e</strong></code>和<code class="fe oa ob oc od b">Pause</code>之间的开关类似:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8781" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们为秒组件设置了一个更长的时间段(三秒)。我们调用<code class="fe oa ob oc od b">actionTimer</code>开始，一秒钟后，我们再次调用该函数。比赛应该暂停，<code class="fe oa ob oc od b">actionTimerButton</code>应该有<code class="fe oa ob oc od b">Resume</code>标题。</p><p id="a83f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了检查选择器是否被调用，我们可以验证<code class="fe oa ob oc od b">timerLabel</code>文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cbfc" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在这个测试中，我们检查了当分钟部分达到零时秒是否减少。</p><p id="ca27" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">进入网点后，我们可以轻松验证<code class="fe oa ob oc od b">stepperDidChangeValue</code>代表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7c87" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">最后，我们在<code class="fe oa ob oc od b">GatherViewController</code>中最难也可能是最重要的方法是<code class="fe oa ob oc od b">endGather</code>方法。这里，我们做了一个服务调用来更新收集模型。我们通过<code class="fe oa ob oc od b">winnerTeam</code>和比赛的比分。</p><p id="c6e1" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">它是一个大方法，不止做一件事，而且是私有的。(我们按例使用:函数不要大，函数要做一件事！).</p><p id="cda3" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">该职能的职责详述如下。<code class="fe oa ob oc od b">endGather</code>执行以下操作:</p><ul class=""><li id="00f8" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">从<code class="fe oa ob oc od b">scoreLabelViews</code>得到分数</li><li id="c1a1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">通过比较分数来计算获胜队</li><li id="3157" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">为服务调用创建<code class="fe oa ob oc od b">GatherModel</code></li><li id="4f85" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">显示了加载微调器</li><li id="765e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">updateGather</code>服务呼叫吗</li><li id="c598" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">隐藏加载微调器</li><li id="aef0" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">处理成功和失败</li><li id="17f5" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">如果成功，视图控制器被弹出到<code class="fe oa ob oc od b">PlayerListViewController</code>(这个视图应该在堆栈中)</li><li id="d68a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">对于失败，它会给出一个警告</li></ul><p id="29c8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们应该如何测试所有这些？(同样，作为最佳实践，此功能应被拆分为多个功能。)</p><p id="b019" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们一步一步来。</p><p id="b2c1" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">创建一个模拟服务并将其注入我们的<code class="fe oa ob oc od b">sut</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cd48" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了测试成功处理程序，我们使用了一个协议来代替具体的类<code class="fe oa ob oc od b">PlayerListViewController</code>，并且在我们的测试类中模拟了它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6527" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这应该是导航控制器的一部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1082" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们检查初始<code class="fe oa ob oc od b">viewState</code>。应该是真的。</p><p id="e3a6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">单元测试的其余部分如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7554" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们准备好我们的模拟终点，并称之为<code class="fe oa ob oc od b">endGather</code>。</p><p id="3e40" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">屏幕上会出现一个确认对话框(<code class="fe oa ob oc od b">UIAlertController</code>)。我们点击“确定”结束收集。</p><p id="267b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">使用<code class="fe oa ob oc od b">waitForExpectation</code>，我们等待闭包被执行，并验证成功路径；<code class="fe oa ob oc od b">viewState</code>现在应该是假的。</p><p id="237c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因为<code class="fe oa ob oc od b">endGather</code>是一个私有方法，我们必须使用调用这个方法的<code class="fe oa ob oc od b">IBAction</code>。为了在显示的警报控制器中点击OK，我们必须使用它的私有API:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9815" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们不能保证这种单元测试在未来的Swift版本中也能工作。这很糟糕。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="98af" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">关键指标</h1><h2 id="8dde" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">代码行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="e0c8" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">单元测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="04d5" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">构建时间</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="16a8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><em class="oh"> *测试在iPhone 8模拟器中运行，iOS 14.3，使用Xcode 12.4，并在i9 MacBook Pro 2019上运行。</em></p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="51e0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="507d" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">就iOS开发而言，MVC是最广为人知的架构模式。</p><p id="4119" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在第一篇文章中，我们看到了它在一个小型应用程序中的实际应用。我们使用简单的方法，每个屏幕由一个视图控制器表示。</p><p id="c4b2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在现实世界中，对于有很多动作的屏幕，您不应该遵循这种方法。相反，你应该分担责任。一种解决方案是使用子视图控制器。</p><p id="8f1d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们还拍摄了应用程序的每个屏幕，并解释了它的作用，提供了一个小描述，它的一部分是什么UI元素，以及控制器与之交互的模型，我们还看到了关键方法的代码片段。</p><p id="a0f2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">最后，我们描述了编写关键类<code class="fe oa ob oc od b">GatherViewController</code>的单元测试的感觉。这不像我们希望的那么容易。我们甚至不得不使用一个私有的方法<code class="fe oa ob oc od b">UIAlertController</code>，这是很糟糕的做法。苹果可能会在未来的版本中改变这个类的公共API，破坏我们的单元测试。</p><p id="7417" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然而，用得好的话，MVC在iOS应用程序开发方面真的很酷，真的很棒。</p><p id="cda9" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">通过查看关键指标，我们还不能说太多。我们需要看看其他模式的表现。我们可以猜测，MVC中的代码行数和类数要少得多。其他模式引入了更多的层，因此有更多的代码行。</p><p id="1e62" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">谢谢你坚持到最后！你会在下面找到一些有用的链接。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="b876" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">有用的链接</h1><ul class=""><li id="2864" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">iOS应用程序Football Gather — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a></li><li id="84d4" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">Vapor制作的web服务器应用— <a class="ae mv" href="https://github.com/radude89/footballgather-ws" rel="noopener ugc nofollow" target="_blank"> GitHub Repo Link </a></li><li id="c19d" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">Vapor 3后端API<a class="ae mv" href="https://radu-ionut-dan.medium.com/using-vapor-and-fluent-to-create-a-rest-api-5f9a0dcffc7b" rel="noopener">文章链接</a></li><li id="e4f9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">迁移到Vapor 4 <a class="ae mv" href="https://radu-ionut-dan.medium.com/migrating-to-vapor-4-53a821c29203" rel="noopener">文章链接</a></li><li id="6557" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图控制器(MVC) — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVC" rel="noopener ugc nofollow" target="_blank"> GitHub Repo链接</a>和<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6">文章链接</a></li><li id="94e1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图ViewModel (MVVM) — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVVM" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e">文章链接</a></li><li id="3ecc" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图演示者(MVP)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e" rel="noopener">文章链接</a></li><li id="6cb6" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">协调员模式—带协调员的MVP(MVP-C)—<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP-C" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36" rel="noopener">文章链接</a></li><li id="623a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">查看交互器演示者实体路由器(VIPER)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIPER" rel="noopener ugc nofollow" target="_blank">GitHub Repo链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960" rel="noopener">文章链接</a></li><li id="d283" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">查看互动者展示者(VIP)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" href="https://radu-ionut-dan.medium.com/battle-of-the-ios-architecture-patterns-view-interactor-presenter-vip-59ebdae86e84" rel="noopener">文章链接</a></li></ul></div></div>    
</body>
</html>