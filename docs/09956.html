<html>
<head>
<title>10 Ways to Improve Your Python Application’s Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Python应用程序性能的10种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-ways-to-improve-your-python-applications-performance-78e697e8dc2a?source=collection_archive---------6-----------------------#2021-11-05">https://betterprogramming.pub/10-ways-to-improve-your-python-applications-performance-78e697e8dc2a?source=collection_archive---------6-----------------------#2021-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0593" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为Python专业人士的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fed2b8986fc4b5d5c0a4fba93f165779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZWXJsT4Mv3Fx7mV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">沙哈达特·拉赫曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="af42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们使用Python应用程序时，概要分析都是必要的，因为它提高了应用程序的性能——更快的用户响应时间和对输入的快速处理。分析有助于优化代码，例如，用消耗较少资源的语句和函数替换消耗过多CPU资源的语句和函数。有必要优化云环境的利用率，因为在云环境中，一切通常都是按使用付费的。因此，如果程序或应用程序使用了大量资源，将会给组织带来巨大的成本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.正确利用CPU资源的分析</h1><p id="fcfc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，我们使用分析器来找出程序的统计数据，例如执行函数所用的时间、调用函数的次数、使用了多少内存等等。Python内置了一些分析器，比如cProfile、line_profiler和memory_profiler，它们可以给你很多关于程序的统计数据。</p><p id="4f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在生产环境中运行Python时，可能会出现这样的情况:许多CPU资源被一个程序或代码使用，只剩下很少的内存来执行其他程序。当应用程序或服务器无法处理用户请求时，这会导致较慢的响应和拒绝服务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d44b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.使用连续剖面仪</h1><p id="d361" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一:什么是连续剖析？我们从生产环境中捕获生产线级性能数据，并将其交付给开发人员和其他团队，以便在持续分析中进行快速分析。如果有了这个系统，我们将能够逐行了解代码的性能，比如内存和CPU的使用情况；即一些重要的有限资源的耗尽，当耗尽时可能导致瓶颈。有许多连续的分析器，但是对于本文，我们只看一个。</p><p id="d6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://profiler.granulate.io/" rel="noopener ugc nofollow" target="_blank"> gProfiler </a>是一个开源的持续剖析工具，远优于Python中可用的剖析工具。它可以跟踪各种语言的统计数据，包括Python、Java和Go。它是即插即用的，所以它提供了无缝的产品概要，不需要修改代码；所有需要的是一个简单的安装。你需要做的就是创建一个帐户来获得API密匙。</p><p id="1890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用下面的命令在您的服务器上下载并运行gProfiler。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6350" class="ne md it na b gy nf ng l nh ni">wget <a class="ae ky" href="https://github.com/Granulate/gprofiler/releases/latest/download/gprofiler" rel="noopener ugc nofollow" target="_blank">https://github.com/Granulate/gprofiler/releases/latest/download/gprofiler</a></span><span id="f9f2" class="ne md it na b gy nj ng l nh ni">sudo chmod +x gprofiler</span><span id="4aad" class="ne md it na b gy nj ng l nh ni">sudo ./gprofiler -cu --token <strong class="na iu">"&lt;API_TOKEN_HERE&gt;" </strong>--service-name <strong class="na iu">"Service name"</strong></span></pre><p id="f6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦它被安装和执行，它就开始监控你的服务器上的所有Python程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1de399d579641b640f60856c72e2a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*Gzp8uwOIKTslSEcI"/></div></div></figure><p id="daf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此后，不需要进行手动分析。gProfiler <strong class="lb iu">在后台</strong>运行，自动监控所有程序，同时使用更少的CPU资源。因此，它减少了您需要使用的云空间量，从而减少了您需要为云环境花费的<strong class="lb iu">资金</strong>。您将在<a class="ae ky" href="https://profiler.granulate.io/view" rel="noopener ugc nofollow" target="_blank">仪表板</a>、<strong class="lb iu"> </strong>上看到所有数据，以便您可以查看和检查这些数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="960d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.Python片段应该小而轻</h1><p id="1d39" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">编写代码时，尽量保持简单，不要声明大量不需要的变量或函数——将一个变量的值赋给第二个变量，第二个变量赋给第三个变量会占用太多的缓冲内存和CPU资源。当我们编写代码时，我们总是考虑该特性是否是必需的。</p><p id="89d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python为开发人员提供了一种方法，使他们可以在一行中用多个运算符进行多重比较。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fa01" class="ne md it na b gy nf ng l nh ni">a = 12</span><span id="5b72" class="ne md it na b gy nj ng l nh ni">print(2 &lt; a &lt; 20)<br/>print(1 == a &lt; 11)</span></pre><p id="1b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户输入分配给变量“a”的任何值，当前分配给它的值是12。因此它将基于它执行比较。</p><p id="0f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码片段的输出如下所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a1fb88e925770a5c749714cbdd4272f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/0*VHUCQSGVjIgIso_Q"/></div></figure><p id="fce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为第一个条件为真，所以结果为“真”，因为第二个条件为假，所以输出为“假”</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3fe3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.多重编码方法</h1><p id="0dbd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要在Python中执行单个操作，有几个选项。在实施之前考虑这些选项有助于找到应对任何挑战的最佳答案。它鼓励开发者走出盒子去寻找解决方案。但是，作为开发人员，我们可以更进一步，通过做一些测试来确定哪种策略更好，以及从哪种策略我们可以在更短的时间内获得可靠的结果。</p><p id="849e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">示例:</em>我们如何使用python来添加数字。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fa7d" class="ne md it na b gy nf ng l nh ni">number1 = 1.5<br/>number2 = 6.3</span><span id="db6a" class="ne md it na b gy nj ng l nh ni">sum = number1 + number2</span><span id="1fec" class="ne md it na b gy nj ng l nh ni">print('The sum of {0} and {1} is {2}'.format(number1, number2, sum))</span></pre><p id="42ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们使用一个简单的python程序将两个数字“数字1”和“数字2”相加。该程序的输出将是</p><p id="52ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">输出:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e6af1a2d2968fc882e9519984b99ba2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/0*lnR9A78EF9eJyyMf"/></div></figure><p id="6cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用不同的方法创建这个程序，就像我们可以用函数来实现一样。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c8f4" class="ne md it na b gy nf ng l nh ni">def add_num(number1, number2):<br/>    sum = number1 + number2;<br/>    return sum;</span><span id="cb61" class="ne md it na b gy nj ng l nh ni">num1 = float(input("input the number one: "))<br/>num2 = float(input("input the number second: "))</span><span id="b779" class="ne md it na b gy nj ng l nh ni">print("The sum is", add_num(num1, num2))</span></pre><p id="3579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们使用了一个名为add_num的函数。用户必须输入<code class="fe no np nq na b">num1</code>和<code class="fe no np nq na b">num2</code>的值，函数<code class="fe no np nq na b">add_num</code>将进行计算。</p><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d4acbde958f3cfadc502b20534e49839.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/0*tw41kZAuToBbSLjM"/></div></figure><p id="5f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们有多种编码方法来解决一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="376b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.尽可能避免循环</h1><p id="35fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当开发人员在程序中使用许多循环时，会给服务器带来额外的负担，因为它需要更加努力地工作才能获得正确的结果。</p><p id="3c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，将数组的长度保存在单独的变量中，而不是在循环的每次迭代中读取数组的长度，这有助于减少响应时间，同时保持相同的功能。</p><p id="f208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们可以创建一个“集合”或“联合”来存储许多值，而不考虑循环。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a6e7" class="ne md it na b gy nf ng l nh ni">a = 4<br/>b = 4<br/>for x in a:<br/>    for y in b:<br/>        if x == y:<br/>            print("Compare")</span></pre><p id="0df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有必要使用循环:“集合(a)”或“集合(b)”就足够了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a1c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.键的排序和使用生成器</h1><p id="4f49" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，“生成器”帮助开发人员创建他们自己的迭代器函数，这些函数不是一次返回一个项，而是使用迭代器对象返回一系列值。</p><p id="7deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<strong class="lb iu"> : </strong>没有使用return语句，因为它会结束程序。</p><p id="037a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的代码片段中看到，我们可以声明一个使用迭代器的函数，这使得代码片段的执行速度比以前更快，最重要的是，它易于实现。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="71b2" class="ne md it na b gy nf ng l nh ni">def mygenerator():<br/>    print('First item')<br/>    yield 10</span><span id="6365" class="ne md it na b gy nj ng l nh ni">    print('Second item')<br/>    yield 20</span><span id="af0a" class="ne md it na b gy nj ng l nh ni">    print('Last item')<br/>    yield 30</span><span id="ee5f" class="ne md it na b gy nj ng l nh ni">for item in mygenerator():<br/>    print(item)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/258b2b8acb4f499ff2e6288bd9dd624b.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/0*FiGBE7S3O-vcBVvu"/></div></figure><p id="d27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它总是有助于减少反应时间和代码优化。</p><p id="c1e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在Python中排序，请避免使用默认的排序函数。相反，使用键，从优化的角度来看，键总是更好的，对字符串和整数都有效。在前面的代码片段中，我们将一个索引值传递给<code class="fe no np nq na b">item.getter</code>。这种情况下我过了“0”。当我改变它时，输出将基于索引而改变。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f4d2" class="ne md it na b gy nf ng l nh ni">import operator</span><span id="9ef7" class="ne md it na b gy nj ng l nh ni">li = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]</span><span id="486e" class="ne md it na b gy nj ng l nh ni">li.sort(key = operator.itemgetter(0))</span><span id="655f" class="ne md it na b gy nj ng l nh ni">print("Sorted output basis of keys", li)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2c85a8ccd8e9d92659d3ea401aa8bdbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/0*4pu9G6hKWhFpP9Ym"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3970" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.使用xrange()代替range()</h1><p id="8074" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，开发人员使用<code class="fe no np nq na b">range()</code>和<code class="fe no np nq na b">xrange()</code>函数在循环中提供迭代。</p><ol class=""><li id="3610" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><code class="fe no np nq na b">range()</code>:调用<code class="fe no np nq na b"><a class="ae ky" href="https://www.w3schools.com/python/ref_func_range.asp" rel="noopener ugc nofollow" target="_blank">range()</a></code>函数时，保存指定范围内所有整数的相关数据，并返回数字列表。</li><li id="2793" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe no np nq na b">xrange()</code>:但是在<a class="ae ky" href="https://www.educba.com/python-xrange/" rel="noopener ugc nofollow" target="_blank"> xrange </a>中，数据的存储是在从一个循环中调用对象并显示特定范围的地方使用的。当迭代大范围的数据时，它提供了良好的性能。<br/>注意:<strong class="lb iu"> </strong>在Python 2.0之前，这两个函数的行为是不同的。在Python3中，它们都产生相同的结果。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.使用join()函数连接字符串</h1><p id="a54e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用“+”或使用<code class="fe no np nq na b">join()</code>函数连接一个字符串；两者都是内置的。</p><ol class=""><li id="2929" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">“+”的使用:</li></ol><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9e65" class="ne md it na b gy nf ng l nh ni">x = 'Testing' + 'is' + 'done'</span><span id="0eb4" class="ne md it na b gy nj ng l nh ni">print(x)</span></pre><p id="7edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以清楚地看到,+不会在输出中提供任何空格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cec91941c73c58491da3ce1eb7f4bb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/0*D0dFp4-UjpcsX6Vu"/></div></figure><p id="99c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.Join:但是当我们使用<code class="fe no np nq na b">join</code>连接字符串时，我们可以提供空间。它将列表、元组、字符串或集合等可迭代对象连接在一起。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/7e0efde25cc36900058e99aaef71fe53.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/0*Xbmy7ByaduyfoOlp"/></div></figure><p id="19c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">join函数作用于基于字符串的函数，从这里开始，我们只想插入空格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/478705cd3497244241970b3764c484cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/0*WgtgtCAVUbfFDL0W"/></div></figure><p id="cb1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出中，我们可以看到join()通过组合所有iterable对象返回一个字符串。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="939f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.itertools的使用</h1><p id="0533" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，<code class="fe no np nq na b">itertools</code>是用于高效迭代的内置功能，只需使用<code class="fe no np nq na b">import itertools</code>就可以将它们包含在我们的代码片段中。</p><p id="d1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq na b">itertools</code>中，我们有许多帮助开发者的选项:</p><ol class=""><li id="fb55" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><code class="fe no np nq na b">itertools.count()</code>:用于程序需要无限计数的地方。</li><li id="99f1" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe no np nq na b">itertools.cycle()</code>:当用户需要从有限的输入集合中得到一个无限的序列时使用。</li><li id="346b" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe no np nq na b">itertools.islice()</code>:当用户想从一个无限序列中提取一个有限切片时使用。</li><li id="daaf" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe no np nq na b">itertools.filterfalse()</code>:只过滤那些函数评估为<code class="fe no np nq na b">false</code>的输入。</li></ol><p id="dce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq na b"><a class="ae ky" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank">itertools</a></code>通过支持内存的功能提供简单、快速的开发。它用于排列和组合。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4456" class="ne md it na b gy nf ng l nh ni">import itertools</span><span id="ec62" class="ne md it na b gy nj ng l nh ni">iter = itertools.permutations(["A", "B", "C"])</span><span id="f922" class="ne md it na b gy nj ng l nh ni">print(list(iter))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b84e75ac4d2073f2bb04d78697b111db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bMcTVrsQX_w8g0tm"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.使用更少的全局变量</h1><p id="2d70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">变量的声明永远在开发者手里。因此，开发人员可以实现这种做法来声明最少数量的全局变量。尽管这减少了内存空间或执行时间，但它也跟踪了变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/513dd8380bbd25d5f77092ecada82f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*bZXidZ0FQpJWaSrn"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9170" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d96a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们介绍了开发人员提高基于python的应用程序性能的10种方法。</p><p id="8e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的建议是不要错过对应用程序进行概要分析——没有这个，就不可能监控代码的性能，所以你实际上不知道它是否有效。</p></div></div>    
</body>
</html>