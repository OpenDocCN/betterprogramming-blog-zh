<html>
<head>
<title>Implement a Clean VIP Architecture in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中实施干净的VIP架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-clean-vip-architecture-in-swift-5-e1a27c7c92a7?source=collection_archive---------1-----------------------#2020-06-04">https://betterprogramming.pub/implement-a-clean-vip-architecture-in-swift-5-e1a27c7c92a7?source=collection_archive---------1-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对VIPER设计模式的改进</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/855ccf03a4fe4f1a02af52537f549bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm4YWsNDvYncSjcvHS0rpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·科尔派在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="341b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解如何在Swift中实施干净的VIP架构。我们将通过创建一个核心数据驱动的应用程序来做到这一点，该应用程序可以在<code class="fe lv lw lx ly b">UITableView</code>中保存、删除和显示项目。它还有一个详细页面来说明我们如何在模块之间导航和传递数据。</p><p id="1227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建VIP模式是为了解决VIPER架构的一些问题。一个问题是<code class="fe lv lw lx ly b">Presenter</code> ( <code class="fe lv lw lx ly b">P</code>)组件可能会变得太大——因为它负责处理UI动作并为视图准备数据。为了促进单一责任原则，改变了对象之间的关系。蝰蛇的<code class="fe lv lw lx ly b">V</code>部分意味着<code class="fe lv lw lx ly b">ViewController</code>和一个<code class="fe lv lw lx ly b">UIView</code>，而VIP的<code class="fe lv lw lx ly b">V</code>仅仅意味着<code class="fe lv lw lx ly b">ViewController</code>。因此，<code class="fe lv lw lx ly b">UIView</code>现在是一个独立的组件，这使得视图控制器变得更薄。</p><p id="2402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，让我们理解VIP模式背后的术语。每个模块或场景通常涉及以下组件及其相应的职责:</p><ul class=""><li id="4dd3" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">View</code> : <em class="mi"> </em>任何属于<code class="fe lv lw lx ly b">UIView</code>子类的东西。它应该是可重用的，尽可能被动的。</li><li id="99f0" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ViewController</code> : <em class="mi"> </em>为管理特定视图的行为而创建的对象。可以充当数据源或事件处理程序。调用必要的<code class="fe lv lw lx ly b">Interactor</code>的方法来响应视图事件，并从<code class="fe lv lw lx ly b">Presenter</code>接收原始的可表示视图的数据。</li><li id="86da" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Interactor</code>:在应用程序中执行业务逻辑，但不知道较低层的实现，如网络客户端或数据库。为此，我们依赖于知道它们并直接使用它们的服务。当一个服务的任务被执行时，<code class="fe lv lw lx ly b">Interactor</code>获取结果并发送给<code class="fe lv lw lx ly b">Presenter</code>。</li><li id="6dc6" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Presenter</code>:从交互器接收任务的结果，并将其转换成适合视图的格式。例如，它可以将复杂的核心数据对象数组转换成简单的<code class="fe lv lw lx ly b">String</code>数组</li><li id="cd61" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Router</code>:负责在app内部进行导航。通常依赖于由<code class="fe lv lw lx ly b">Configurator</code>提供的<code class="fe lv lw lx ly b">UINavigationController</code>。</li><li id="5d94" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Configurator</code>:链接前面所有组件创建模块的对象。</li><li id="aa98" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Entity</code>:普通对象，比如核心数据实体或者<code class="fe lv lw lx ly b">Codable</code>模型。</li></ul><p id="0f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下这个图(被指向的对象归指向的对象所有):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/365f89befa40103e65c240415881dc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSER5qbVsRS4snwmVp64Tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">干净的VIP架构图</p></figure><p id="249f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到在<code class="fe lv lw lx ly b">ViewController</code>、<code class="fe lv lw lx ly b">Interactor</code>和<code class="fe lv lw lx ly b">Presenter</code>之间有一个<em class="mi">单向</em>数据流。</p><p id="fb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有以下关系:</p><ul class=""><li id="848e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ViewController</code>有一个<em class="mi">强</em>参照<code class="fe lv lw lx ly b">View</code>、<code class="fe lv lw lx ly b">Interactor</code>、<code class="fe lv lw lx ly b">Router</code>。它符合a <code class="fe lv lw lx ly b">Presenter</code>用来发送a <code class="fe lv lw lx ly b">View</code>需要的数据的协议。</li><li id="4380" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Interactor</code>有一个<em class="mi">强</em>引用一个<code class="fe lv lw lx ly b">Presenter</code>。它符合一个<code class="fe lv lw lx ly b">View Controller</code>用来发送事件的协议(例如当<code class="fe lv lw lx ly b">viewDidLoad()</code>方法运行时)。</li><li id="192a" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Presenter</code>有一个<em class="mi">弱</em>参照<code class="fe lv lw lx ly b">View Controller</code>。它符合<code class="fe lv lw lx ly b">Interactor</code>用来发送业务逻辑任务结果的协议。</li><li id="abab" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Router</code>拥有<code class="fe lv lw lx ly b">View Controller</code>运行来导航到另一个模块的方法。通常，它们涉及以下模式:通过使用该模块的静态<code class="fe lv lw lx ly b">configureModule()</code>方法创建另一个模块，并调用<code class="fe lv lw lx ly b">UINavigationController</code>的<code class="fe lv lw lx ly b">pushViewController</code>方法。</li></ul><p id="6e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以开始探索一个示例项目中的实现。该项目的源代码可以在文章的底部找到。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ed12" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">我们开始吧</h1><p id="91e7" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">看看我们的项目结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/2d94fd57f3608128773c804dbda74bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3OSRpmInXqzsrhlLgEP3w.png"/></div></div></figure><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用分为四层:</p><ul class=""><li id="8818" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">应用层:包含<code class="fe lv lw lx ly b">AppDelegate.swift</code>文件。</li><li id="b559" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated">表示层:由VIP模块、<code class="fe lv lw lx ly b">Titles</code>和<code class="fe lv lw lx ly b">Title Detail</code>组成。</li><li id="2249" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated">业务逻辑层:具有交互器使用的实体和服务。</li><li id="2bdb" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated">核心层:包含业务逻辑层运行所必需的较低级别的特性。</li></ul><p id="596c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe lv lw lx ly b">Titles</code>模块。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5083" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">标题</h1><p id="9e22" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果有任何使用核心数据持久化的项目，该屏幕将显示一个经典的<code class="fe lv lw lx ly b">UITableView</code>。否则，它会显示一个占位符标签:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e8f990b97d21a7f8b2aecc78b32e21c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uu59n2QftZgCQ8EVnMA-BA.jpeg"/></div></div></figure><h2 id="12c5" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题核心数据对象</h2><p id="200b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们的核心数据对象叫做<code class="fe lv lw lx ly b">Title</code>，有两个<code class="fe lv lw lx ly b">String</code>属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/5692d439f92d1c182059530673d9b3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnJ9s90QGO8kZMWaKjD20A.png"/></div></div></figure><p id="cee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看如何配置该模块。</p><h2 id="f340" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题配置器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们在一个静态的<code class="fe lv lw lx ly b">configureModule()</code>方法中链接依赖关系。</p><h2 id="c8b4" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">应用委托</h2><p id="b336" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这是我们为应用程序设置初始视图控制器的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初始模块已经设置好了，现在让我们实现VIP组件，一次一个。</p><h2 id="f453" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题视图</h2><p id="0ee5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这只是显示了一个占位符标签和一个<code class="fe lv lw lx ly b">UITableView</code>，提供了在视图控制器中使用的方便操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="6399" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题视图控制器</h2><p id="2763" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这负责将<code class="fe lv lw lx ly b">TitlesView</code>分配给它的<code class="fe lv lw lx ly b">view</code>属性。它通过充当<code class="fe lv lw lx ly b">UITableView</code>数据源和事件处理器来管理<code class="fe lv lw lx ly b">TitlesView</code>的行为。</p><p id="b508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个名为<code class="fe lv lw lx ly b">TitlesPresenterOutput</code>的协议，它包含一些方法，当<code class="fe lv lw lx ly b">TitlesPresenter</code>需要向<code class="fe lv lw lx ly b">TitlesViewController</code>发送转换后的数据时，就会运行这些方法。控制器依次用接收到的数据更新视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="fafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看到如何运行不同的交互器方法来响应事件的发生。例如，当用户选择一行时，我们触发交互器的<code class="fe lv lw lx ly b">didSelectRow(at: )</code>方法。</p><h2 id="be72" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题互动程序</h2><p id="d0af" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><code class="fe lv lw lx ly b">TitlesInteractor</code>使用<code class="fe lv lw lx ly b">TitlesInteractor</code>协议监听<code class="fe lv lw lx ly b">TitlesViewController</code>事件，并调用服务来执行某项任务。然后，它将结果发送到<code class="fe lv lw lx ly b">TitlesPresenter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="439a" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">TitlesPresenter</h2><p id="6014" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><code class="fe lv lw lx ly b">TitlesPresenter</code>通过从<code class="fe lv lw lx ly b">TitlesPresenter</code>协议方法中的<code class="fe lv lw lx ly b">TitlesInteractor</code>获取任务结果，准备适合视图的数据；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="bbb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到在<code class="fe lv lw lx ly b">interactor(didRetrieveTitles titles: )</code>方法中，一个由<code class="fe lv lw lx ly b">Title</code>对象组成的数组被转换成一个由<code class="fe lv lw lx ly b">String</code>对象组成的数组。然后我们将这个数组发送给<code class="fe lv lw lx ly b">TitlesViewController</code>，T3更新<code class="fe lv lw lx ly b">UITableView</code>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="1a49" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题路由器</h2><p id="5c84" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">它唯一的职责是导航到另一个模块。当用户选择一行时，<code class="fe lv lw lx ly b">TitlesInteractor</code>获取一个相关的<code class="fe lv lw lx ly b">Title</code>对象并将其发送给<code class="fe lv lw lx ly b">TitlesPresenter</code>，后者依次获取其<code class="fe lv lw lx ly b">id</code>属性并将其转发给<code class="fe lv lw lx ly b">TitlesViewController</code>。然后<code class="fe lv lw lx ly b">TitlesViewController</code>触发<code class="fe lv lw lx ly b">routeToDetail(with id:)</code>方法，传入接收到的<code class="fe lv lw lx ly b">id</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b7c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe lv lw lx ly b">Titles</code>模块后，现在让我们快速探索<code class="fe lv lw lx ly b">TitleDetail</code>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="1505" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">标题详细信息</h1><p id="b82a" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">该模块仅在屏幕中央的<code class="fe lv lw lx ly b">UILabel</code>上显示所选的<code class="fe lv lw lx ly b">Title</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/503b5845646f39907e4868e6195f528b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqA7X31iQOJlAhS4aQxR7Q.png"/></div></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="2b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">TitleDetail</code>模块的构造与<code class="fe lv lw lx ly b">TitlesConfigurator</code>中的相似:</p><h2 id="7690" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">TitleDetailConfigurator</h2><p id="5b08" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们知道，当我们从标题模块导航时，我们将<code class="fe lv lw lx ly b">id</code>属性传递给了<code class="fe lv lw lx ly b">TitleDetailConfigurator</code>的<code class="fe lv lw lx ly b">configureModule</code>方法。</p><p id="fbca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将<code class="fe lv lw lx ly b">titleId</code>属性发送给<code class="fe lv lw lx ly b">TitleDetailInteractor</code>，以进一步加载和显示必要的<code class="fe lv lw lx ly b">Title</code>对象。我们这里没有<code class="fe lv lw lx ly b">Router</code>对象，因为这个屏幕不是用来导航的(我们只能使用后退按钮弹出它):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="6757" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">标题详细视图</h2><p id="db75" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">和以前一样，这个视图是被动的——它简单地定义了它的属性，并展示了它自己的子视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="d2c4" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">TitleDetailViewController</h2><p id="22bf" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">视图控制器非常简单。它所做的只是向<code class="fe lv lw lx ly b">TitleDetailInteractor</code>发送事件，并最终从<code class="fe lv lw lx ly b">TitleDetailPresenter</code>接收数据。然后它更新<code class="fe lv lw lx ly b">TitleDetailView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="ea78" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">TitleDetailInteractor</h2><p id="639a" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">交互器根据提供的<code class="fe lv lw lx ly b">titleId</code>属性从核心数据中提取一个<code class="fe lv lw lx ly b">Title</code>对象，然后将结果转发给<code class="fe lv lw lx ly b">TitleDetailPresenter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="7226" class="nv mx it bd my nw nx dn nc ny nz dp ng li oa ob ni lm oc od nk lq oe of nm og bi translated">TitleDetailPresenter</h2><p id="ea47" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果在<code class="fe lv lw lx ly b">TitleDetailInteractor</code>的工作过程中没有出现错误，演示者会将<code class="fe lv lw lx ly b">Title</code>对象转换为<code class="fe lv lw lx ly b">String</code>，然后将结果<code class="fe lv lw lx ly b">String</code>转发给<code class="fe lv lw lx ly b">TitleDetailViewController</code>。否则，它运行<code class="fe lv lw lx ly b">didFailRetrieveTitle</code>方法，传入错误描述，<code class="fe lv lw lx ly b">TitleDetailViewController</code>用它来显示警告:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终在项目中实现了VIP架构。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="e0e4" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">资源</h1><p id="8e59" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">GitHub上提供了源代码:</p><div class="ol om gp gr on oo"><a href="https://github.com/zafarivaev/Clean-VIP-Architecture" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">zafarivaev/Clean-VIP-建筑</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在GitHub上创建一个帐户，为zafarivaev/Clean-VIP-Architecture开发做贡献。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5edd" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">包扎</h1><p id="0a14" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">对不同的架构模式实现感兴趣？欢迎访问我的其他相关文章:</p><ul class=""><li id="23ad" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/mvvm-in-swift-infinite-scrolling-and-image-loading-d47780b06e23" rel="noopener">在Swift 5中实施反应式MVVM架构</a></li><li id="67f3" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener">在Swift 5中实施VIPER架构</a></li><li id="176d" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu me mf mg mh bi translated"><a class="ae ky" href="https://medium.com/better-programming/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b" rel="noopener">在Swift 5中实施模型-视图-展示者架构</a></li></ul><p id="fe87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>