<html>
<head>
<title>Want To Build Faster Web Apps? Use JavaScript Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想要构建更快的Web应用程序吗？使用JavaScript记忆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-memoization-dca99a5614fe?source=collection_archive---------6-----------------------#2021-03-15">https://betterprogramming.pub/javascript-memoization-dca99a5614fe?source=collection_archive---------6-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的HTTP性能的实际例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5034c94e8aa3f0e33bf647bcd8998632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFUlLAgu9Ig_dlKkdWEbbQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戴维·贝克尔在<a class="ae ky" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="de14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记忆化就是简单地缓存一个函数的输出，以便后续调用只使用缓存的结果，消除任何繁重的计算。如果实现得当，JavaScript中的记忆化也可以产生惊人的性能优势。</p><p id="b134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想让你的JavaScript代码运行得更快吗？在本文中，我们将看看JavaScript记忆化的一个实际例子。</p><p id="0b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剧透:你不会看到下面提到的斐波那契或阶乘。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是记忆化？</h1><p id="ab9a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">记忆化的一个过于简单的定义是，当你运行一个带有参数a和b的昂贵函数时，你将缓存那个函数的结果。当使用相同的参数a和b调用相同的昂贵函数时，由于输出是已知的并且在缓存中，缓存的结果被发送回来。</p><p id="c314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">维基百科</a>将记忆化定义为:</p><blockquote class="mz na nb"><p id="6565" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序</p></blockquote><p id="03ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它进一步补充说:</p><blockquote class="mz na nb"><p id="c9c7" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“记忆功能‘记住’与某组特定输入相对应的结果。具有记忆的输入的后续调用返回记忆的结果，而不是重新计算它，从而消除了使用给定参数调用的主要开销，除了使用这些参数对函数进行的第一次调用。</p></blockquote><p id="0550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">专业提示:记忆化对于软件的可伸缩性也很有用。我们将在本文后面了解这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f662" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不是另一个阶乘或斐波那契的例子</h1><p id="824e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">老实说，我已经厌倦了用同样的斐波那契和阶乘的例子来解释记忆化。维基百科和谷歌搜索“JavaScript memoization”的十个结果中的八个都使用factorial或Fibonacci作为例子。是的，我们曾经在大学里做过，也许是为了理解递归。但是在日常的实际编码中，我在过去的14年中没有使用过像阶乘或斐波那契这样的东西。</p><p id="ac98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还想阅读其中的一些例子，请阅读<a class="ae ky" href="https://flaviocopes.com/javascript-memoization/" rel="noopener ugc nofollow" target="_blank">这些帖子</a>。自由代码营上的一个甚至展示了如何构建自己的记忆功能。但是我们在这里不是为了建造一个，我们在这里是为了更实际地使用一个。我们将在下一部分看到如何实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc32" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">假设</h1><p id="4549" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们进入代码之前，下面是我们正在做的一些假设:</p><ol class=""><li id="f23a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">您通常知道JavaScript中的承诺和异步代码是如何工作的。</li><li id="8938" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">您已经了解了REST APIs是如何工作的。</li><li id="5c76" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">你知道谁应该用编程语言编写一个基本的API，用关系型DBMS作为数据存储。</li></ol><p id="be24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d21" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实际例子:Web响应的Javascript记忆化</h1><p id="89f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将举一个例子引用API并记忆响应，这是一个使用<a class="ae ky" href="https://github.com/sindresorhus/p-memoize" rel="noopener ugc nofollow" target="_blank"> p-memoize </a>库的承诺。当然，还有其他选择。例如，lodash.memoize、mem和fast-memoize是一些<a class="ae ky" href="https://www.npmtrends.com/p-memoize-vs-memoizee-vs-memoizejs-vs-fast-memoize-vs-memoize-one-vs-mem-vs-lodash.memoize" rel="noopener ugc nofollow" target="_blank">超受欢迎的</a>。</p><p id="7933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，最流行的是mem(至少在我的比较中)，p-memoize是mem的promise/async版本。mem和p-memoize都是由同一个开发者开发的。</p><p id="a6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我在过去使用过p-memoize，所以在这个例子中我将坚持使用它。我们的示例货币转换器API是<a class="ae ky" href="https://github.com/geshan/nodejs-posgresql" rel="noopener ugc nofollow" target="_blank">开源的</a>并部署在<a class="ae ky" href="https://geshan-nodejs-posgresql.zeet.app/quotes" rel="noopener ugc nofollow" target="_blank"> Zeet </a>上。如果您有兴趣以每月0美元的价格托管Node.js应用程序，请阅读更多关于免费Node.js托管的信息。</p><p id="5594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择Zeet是因为它不是无服务器的，所以在实现内存化后，我们会看到响应时间明显减少。接下来，我们将看到JavaScript内存化如何加快响应时间。</p><h2 id="b2b9" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">JavaScript记忆前的响应时间</h2><p id="a3dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们记忆这个函数之前，让我们看一下<code class="fe og oh oi oj b">/routes/quotes.js</code> <a class="ae ky" href="https://github.com/geshan/nodejs-posgresql/blob/master/routes/quotes.js" rel="noopener ugc nofollow" target="_blank">文件</a>中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的Express.js路径，我们从<code class="fe og oh oi oj b">quotes.getMultiple</code>获取行。在这种情况下，它将在每次调用时运行一个<a class="ae ky" href="https://github.com/geshan/nodejs-posgresql/blob/d51ef7298cba039130fe8bf98486ba32bf19ad7d/services/quotes.js#L7" rel="noopener ugc nofollow" target="_blank">数据库查询</a>。</p><p id="8cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速看一下这种方法的响应时间。我们将使用<a class="ae ky" href="https://geshan.com.np/blog/2020/09/vegeta-load-testing-primer-with-examples/" rel="noopener ugc nofollow" target="_blank">贝吉塔负载测试</a>工具运行一个简单的负载测试，每秒两个请求，持续30秒。我们可以运行如下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上述贝吉塔负载测试运行30秒时，它将向我们显示如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/12471c63e813d893b02a2a5063e359cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUqul5jU-yfzfcvBYQBJVw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript记忆前30秒50 RPS</p></figure><p id="4218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们得到的最快响应是~205 ms，最慢是1.5 s，我故意做到了每秒50个请求。那些红点是由数据库连接问题引起的500个错误。</p><p id="945f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最初的几个请求之后，响应时间非常好，因为我们使用了一个数据库连接池。</p><h2 id="02dc" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">JavaScript内存化后的响应时间</h2><p id="2939" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将使用JavaScript内存化和p-memoize库来内存化报价服务上的<code class="fe og oh oi oj b">getMultiple</code>函数。做<code class="fe og oh oi oj b">npm i p-memoize</code>后<code class="fe og oh oi oj b">routes/quotes.js</code>文件的变化如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="24dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分析一下我们在这里改变的东西:</p><ol class=""><li id="7199" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们在第4行添加了p-memoize库。</li><li id="46d2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">接下来，我们将常数设置为60000毫秒，相当于1分钟，这是我们在内存上完成的JavaScript内存化缓存的缓存生存期。</li><li id="e470" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">因此，我们使用p-memoize来记忆第6行的<code class="fe og oh oi oj b">quotes.getMultiple</code>函数。</li><li id="72e2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">稍后在get路径中，我们将使用memoized函数，而不是原来的函数。</li></ol><p id="0097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以参考这个<a class="ae ky" href="https://github.com/geshan/nodejs-posgresql/pull/17" rel="noopener ugc nofollow" target="_blank">拉取请求</a>的变化。当我们在30秒内以每秒50个请求的速度运行相同的负载测试时，会产生以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会导致:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c0acf71d268e73a3eac8503cd28f4955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ffm6cQdNPQBES4wQ28w5pw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript记忆后30秒50 RPS</p></figure><p id="0cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里与上面的负载测试相比，我们得到的最快响应时间大约是157毫秒，最慢的(可能是第一个)是1.05秒。总的来说，我们可以清楚地看到，与之前的测试相比，每个请求减少了50-75毫秒。</p><p id="2455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的另一个优势是，对于1500 (30*50)个请求，数据库仅在30秒内被命中一次。</p><p id="82f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，来自Zeet的这个分支部署的日志如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/a8df488366fa009edd922e5eb4efa518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzN5sPSnfBmAtyp_xZWeJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript内存化后的服务器日志—数据库仅命中一次</p></figure><p id="49f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如这里看到的，第一个请求命中数据库，显示日志为<code class="fe og oh oi oj b">Getting quotes from the db</code>，然后在接下来的一分钟内，它不会命中数据库。</p><p id="2a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在我们的负载测试中，所有剩余的1499个请求都获得了用于获取多个引号的内存化(缓存)结果。前两个请求花了大约320毫秒，之后花了0.5毫秒到2.4毫秒，这都要归功于内存化。</p><p id="b0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在本地运行测试，记忆化后的结果会快得多，因为它不需要使用互联网。本地测试也可以避免任何复杂性，比如<a class="ae ky" href="https://www.cloudflare.com/en-gb/learning/ssl/what-happens-in-a-tls-handshake/" rel="noopener ugc nofollow" target="_blank"> SSL握手</a>。</p><p id="1ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，我想展示一个更实际、更真实的JavaScript记忆化的例子，因为我对所有的阶乘和斐波那契例子都感到厌烦。</p><p id="e0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了p-memoize，但是你可以使用任何库。我建议看看快速记忆法或者T4记忆法。Fast-memoize还致力于成为“JavaScript中最快的支持N个参数的记忆库”旋转一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afd6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">其他考虑</h1><p id="47f9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据您使用的库，请注意以下事项:</p><ol class=""><li id="da9d" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">当memoizing可能只是缓存第一个参数，给出意外的结果。例如，在p-memoize中，如果有多个参数，我们需要<a class="ae ky" href="https://github.com/sindresorhus/mem#caching-strategy" rel="noopener ugc nofollow" target="_blank">连接</a>参数。</li><li id="af13" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">并非所有语言都支持它。例如，没有直接的本地方法来记忆一个函数的返回值，因为所有的PHP进程都会根据请求加速或停止。同样的逻辑也适用于无服务器功能。</li><li id="a4e7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">很明显，只有返回值的函数才能被记忆。<a class="ae ky" href="https://www.cs.fsu.edu/~cop3014p/lectures/ch7/index.html" rel="noopener ugc nofollow" target="_blank">无效功能</a>无法记忆。</li></ol><p id="38da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们还可以利用<code class="fe og oh oi oj b">Cache-Control</code>响应<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank">头</a>在浏览器上缓存响应。如果您想探索的话，这将是HTTP级别的缓存选项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8b7d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对记忆化的理解有所不同，并更多地将其用于实际目的。</p><p id="745f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打破JavaScript内存化只能用于阶乘和斐波那契这样的事情的观念，将它用于任何可以缓存的资源密集型事情，比如GET请求。</p><p id="bfa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你学到了更多关于记忆化的东西，特别是JavaScript中的记忆化。继续学习！</p></div></div>    
</body>
</html>