<html>
<head>
<title>Want Proper String Representations in Custom Python Classes? Use These 2 Built-in Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想要在自定义Python类中使用正确的字符串表示吗？使用这两种内置方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/want-proper-string-representations-in-custom-python-classes-use-these-2-built-in-methods-72731434d7c8?source=collection_archive---------8-----------------------#2021-11-08">https://betterprogramming.pub/want-proper-string-representations-in-custom-python-classes-use-these-2-built-in-methods-72731434d7c8?source=collection_archive---------8-----------------------#2021-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b072" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高代码的可读性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45d01654f6b2ceda19c827f51872e5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mNc4kmB04b7Jjv1d"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德鲁·海姆尔(安德鲁夫)在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着项目的增长，您将不可避免地定义定制类。在这些类中，您可以定义各种执行特定操作的方法来满足业务需求。</p><p id="ea0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您或其他用户需要通过这些自定义实例的字符串表示来检查它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">repr和str函数概述</h1><p id="4763" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有两个与Python对象的字符串表示相关的基本内置函数:<code class="fe mz na nb nc b">repr</code>和<code class="fe mz na nb nc b">str</code>。这两个函数都提供了Python对象的可打印字符串表示。我们可以在一些内置数据类型中观察到这个特性，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内置类的字符串表示</p></figure><p id="3f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些例子中，这两个函数创建相同的字符串，有意义地表示被检查的对象。如果你仔细观察，你会注意到<code class="fe mz na nb nc b">str</code>数据类型的字符串表示是不同的，我们将在本文后面讨论这种差异。</p><p id="4830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这些内置的数据结构支持这两种功能，但是这些打印输出不能告诉我们幕后发生了什么。接下来就来探索一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d154" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重写特殊方法</h1><p id="8bdb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了观察底层的实现机制，让我们创建一个简单的定制类。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="6c73" class="nj md it nc b gy nk nl l nm nn">class Student:<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span></pre><p id="812b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个定制类的基本结构，我们可以看看<code class="fe mz na nb nc b">repr</code>和<code class="fe mz na nb nc b">str</code>函数揭示了这个简单类的什么。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="6626" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; student = Student(“John”, 15)<br/>&gt;&gt;&gt; print(f”repr: {student!r}”)<br/>repr: &lt;__main__.Student object at 0x0000023B519238E0&gt;<br/>&gt;&gt;&gt; print(f”str: {student!s}”)<br/>str: &lt;__main__.Student object at 0x0000023B519238E0&gt;</span></pre><p id="fcd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与内置数据结构不同，在这个自定义类实例上调用<code class="fe mz na nb nc b">repr</code>和<code class="fe mz na nb nc b">str</code>不会产生任何有意义的东西，除了显示它的类和内存地址。</p><p id="be01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了定义自定义类的正确字符串表示，我们需要覆盖两个特殊的方法:<code class="fe mz na nb nc b">__repr__</code>和<code class="fe mz na nb nc b">__str__</code>，如下所示。重要的是，这两种方法都应该返回字符串值，因为它们应该为自定义实例提供字符串表示。目前，这些字符串只是占位符，我们将在后面讨论这些方法的最佳实践实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖str和repr</p></figure><p id="36be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特殊方法是在名字前后有双下划线的函数(例如，自定义类中的<code class="fe mz na nb nc b">__init__</code>),有些人把它们称为magic或dunder方法。值得注意的是，它们旨在由Python解释器调用，以在幕后实现特定的操作。换句话说，我们通常不直接调用特殊方法。例如，我们通过调用ClassName()创建一个类实例对象，这个类实例对象调用Python的<code class="fe mz na nb nc b">__init__</code>方法。</p><p id="8964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用更新后的类，我们可以观察到通过调用<code class="fe mz na nb nc b">__repr__</code>和<code class="fe mz na nb nc b">__str__</code>特殊方法来调用<code class="fe mz na nb nc b">repr</code>和<code class="fe mz na nb nc b">str</code>方法的效果。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="55b8" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; student = Student(“John”, 15)<br/>&gt;&gt;&gt; print(f”repr: {student!r}”)<br/>repr: Student __repr__ string<br/>&gt;&gt;&gt; print(f”str: {student!s}”)<br/>str: Student __str__ string</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b08" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为__repr__和__str__返回正确的字符串</h1><p id="9e26" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如上所示，当前的字符串表示不是这两个特殊方法所需的输出值。你可能想知道我们应该为它们返回什么字符串。</p><p id="46e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自定义类中正确实现这两个方法需要理解它们的区别。一般来说，我们定义<code class="fe mz na nb nc b">__repr__</code>方法是为了开发(例如，调试)，而<code class="fe mz na nb nc b">__str__</code>方法是为了显示对象的有用信息。</p><p id="d2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这个区别，让我们在相关的讨论之前看看一个合适的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">repr和str的正确覆盖</p></figure><p id="1fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了更新后的类，我们现在可以看到这两种方法的字符串表示。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="cae1" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; student = Student(“John”, 15)<br/>&gt;&gt;&gt; print(f”repr: {student!r}”)<br/>repr: Student(‘John’, 15)<br/>&gt;&gt;&gt; print(f”str: {student!s}”)<br/>str: Student Name: John; Age: 15</span></pre><p id="9dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法之间的区别对于Python如何使用它们有着重要的意义。对于<code class="fe mz na nb nc b">__str__</code>方法，就其具体实现而言，您有更多的自由。经验法则是，它应该向最终用户显示关于对象数据的有用信息。与此相关，需要注意的一点是，每当我们使用print函数检查对象时，都会调用<code class="fe mz na nb nc b">__str__</code>方法。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="745a" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; print(student)<br/>Student Name: John; Age: 15</span></pre><p id="3cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，当在交互式Python控制台中输入一个对象时，会自动调用<code class="fe mz na nb nc b">repr</code>方法。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="80f7" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; student<br/>Student(‘John’, 15)</span></pre><p id="6c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印出的字符串的格式很重要，因为我们可以重新创建另一个实例，该实例与当前实例具有相同的属性值。这就是为什么我们说<code class="fe mz na nb nc b">repr</code>方法是为开发而设计的。我们可以观察到这种效应:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="eec3" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; another_student0 = Student(‘John’, 15)<br/>&gt;&gt;&gt; another_student0<br/>Student(‘John’, 15)<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; student_repr = repr(student)<br/>&gt;&gt;&gt; another_student = eval(student_repr) #B<br/>&gt;&gt;&gt; another_student<br/>Student(‘John’, 15)</span></pre><p id="7aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在<code class="fe mz na nb nc b">__repr__</code>方法中，我们将name属性的转换格式指定为字符串的表示形式。这种转换格式是必要的，因为如果我们忽略它(即<code class="fe mz na nb nc b">f”Student({self.name}, {self.age})”)</code>)，<code class="fe mz na nb nc b">Student</code>实例将具有以下表示:<code class="fe mz na nb nc b">Student(John, 15)</code>，由于语法错误，它不能用于重新创建相同属性的新实例。</p><p id="4bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从字符串表示重新创建的相同原则也适用于内置数据结构。记住，<code class="fe mz na nb nc b">repr</code>和<code class="fe mz na nb nc b">str</code>函数为一个字符串实例返回稍微不同的字符串:前者产生一个带引号的字符串，而后者产生一个不带引号的字符串。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="c7c6" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; name = “John”<br/>&gt;&gt;&gt; print(f”repr: {name!r}”)<br/>repr: ‘John’<br/>&gt;&gt;&gt; print(f”str: {name!s}”)<br/>str: John</span></pre><p id="d057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引号的使用有很大的不同，因为带引号的字符串可以用来实例化一个字符串对象，而不带引号的则不能，因为它将被解释为变量。这再次反映了这样一个事实，即使用<code class="fe mz na nb nc b">repr</code>方法生成的字符串可以用来创建另一个具有相同值的实例。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e93d" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; str(‘John’)<br/>‘John’<br/>&gt;&gt;&gt; str(John)<br/>Traceback (most recent call last):<br/>    File “&lt;input&gt;”, line 1, in &lt;module&gt;<br/><strong class="nc iu">NameError</strong>: name ‘John’ is not defined</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2fb8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ade3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在自定义类中，<code class="fe mz na nb nc b">__repr__</code>方法的实现应该模拟我们如何使用初始化方法从被检查的对象中重新创建实例对象。</p><p id="da97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本目的是以明确的方式解释对象是什么。因为从<code class="fe mz na nb nc b">repr</code>方法生成的字符串应该表示一个我们可以重新构造类似对象的文本，所以由<code class="fe mz na nb nc b">repr</code>生成的任何字符串都应该有引号，以使它们成为有效的Python字符串文字。</p><p id="b855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自定义类中，<code class="fe mz na nb nc b">__str__</code>方法的实现应该为最终用户提供有用的信息。主要目的是以可读的方式解释对象包含什么数据。</p><p id="660a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议为自定义类实现这两种方法。但是，如果您希望只实现一个，请覆盖<code class="fe mz na nb nc b">__repr__</code>方法，因为当<code class="fe mz na nb nc b">__str__</code>方法没有实现时，Python将使用<code class="fe mz na nb nc b">__repr__</code>方法。</p></div></div>    
</body>
</html>