<html>
<head>
<title>Bit Harmony: A New Tool To Create and Collaborate on Independent Node.js Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bit Harmony:在独立Node.js组件上创建和协作的新工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bit-harmony-a-new-tool-to-create-and-collaborate-on-independent-node-js-components-f871658edcb6?source=collection_archive---------7-----------------------#2021-04-02">https://betterprogramming.pub/bit-harmony-a-new-tool-to-create-and-collaborate-on-independent-node-js-components-f871658edcb6?source=collection_archive---------7-----------------------#2021-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b93" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您开发工作流程所需的最新开源工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d32d710b23525dbba8e2451ce703233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N72iE7plaqTS-tkrDzTWvg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/photo/six-woman-standing-and-siting-inside-the-room-1181622/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kv" href="https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Christina Morillo </a>拍摄。</p></figure><p id="2d47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个人都知道，如果你想将一段<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>代码作为一个单独的组件与其他人共享，你需要创建一个包并将其发布到某个地方——最好是在NPM，人们可以在那里找到、安装并使用它。</p><p id="9078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个工作流程没有任何问题。到目前为止，它一直在工作，当你只关心人们使用它时，它是完美的。但是如果你想要更多呢？如果您的意图是让其他人使用您的代码，在他们认为合适的时候更新它，然后再发布回来，该怎么办？如果您考虑到公司试图在多个项目中使用标准模块，这并不是一个不常见的用例。</p><p id="c2bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的问题？使用当前可用的工具，你需要NPM和Git的混合体来完成它。或者复杂的工作流程。你选吧。</p><p id="58dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在处理一个单一回购出错的教科书案例呢？一个单一的存储库，其中包含您的企业平台的代码库以及围绕它的每一个内部扩展。每个开发人员和他们的叔叔都在从事回购工作，所以你要么建立一个非常复杂的分支模型并祈祷你的开发人员遵循它，要么解决合并冲突并向开发人员解释Git如何工作。这不是你想要的情景(相信我，我经历过)。</p><p id="aefb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，Bit的最新版本，代号为<a class="ae kv" href="https://harmony-docs.bit.dev/" rel="noopener ugc nofollow" target="_blank"> Harmony </a>，来帮忙了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://bit.dev/deleteman/node-components/logger/logger"><div class="gh gi ls"><img src="../Images/451a6620c5283aac06ce0242c0dfb366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNU728oEPv6fG-qoEVDoMw.jpeg"/></div></a><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://bit.dev/deleteman/node-components/logger/logger" rel="noopener ugc nofollow" target="_blank">我的节点组件导出到Bit.dev上的远程作用域</a></p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b975" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是比特？</h1><p id="e3e4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你还没听说过，Bit是一个开源工具(原生集成到<a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> Bit.dev </a>的远程托管平台)，它可以帮助你创建和共享原子组件。这是什么意思？您可以从头开始构建独立的组件，或者提取您的代码部分，并在Bit服务器上将它们作为独立的组件共享(例如<a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> Bit.dev </a>)。</p><p id="faba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这听起来很像NPM，但还是有一些主要的区别:</p><ul class=""><li id="9c10" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">你不必提取代码来分享它。您可以直接从存储库中导出组件。Bit允许您将代码的一部分标识为一个组件，并将其与项目的其余部分分开处理。这反过来有助于简化共享过程，因为您不必设置单独的repo，也不必重新设计将这些文件导入项目的方式。</li><li id="f993" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">导入您的组件的人(而不仅仅是安装它们)也可以对它们进行协作、修改，并将它们导出回注册中心。如果您在同一个组织内作为一组团队工作，这是非常强大的，因为您可以跨团队使用相同的工具进行协作，而不必从事单独的项目。导入一个Bit组件会将代码下载下来，并将其复制到您的工作目录中(而不是一个讨厌的<code class="fe nl nm nn no b">npm_modules</code>文件夹，在那里您不能对它做任何事情)。</li></ul><p id="830e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在有了Bit的最新版本，团队协作变得更加容易和快速，这要归功于诸如<a class="ae kv" href="https://harmony-docs.bit.dev/environments/overview" rel="noopener ugc nofollow" target="_blank">开发环境</a>之类的附加功能，你可以预先配置这些开发环境并与每个人分享，这样你就可以使用相同的配置进行工作。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="dcae" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">创作节点组件</h1><p id="ed92" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">注意我说的是“组件”而不是“包”Bit的组件概念不同于包的概念，因为它包含的不仅仅是你共享的代码。</p><p id="074c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您要构建一个标准的节点包，您需要使用以下工具:</p><ul class=""><li id="7350" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">NPM安装依赖项，当然，与社区共享最终结果。</li><li id="88e4" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">Mocha，Just，或者其他一些测试框架。这不是一个硬性要求，但是如果您希望其他人信任您的代码，您肯定希望测试您的代码。</li><li id="c98f" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">饭桶。同样，这不是一个特别难的要求，但它和大的要求一样高。通常，如果你共享你的包给其他人使用，你也会希望他们让你知道它是否有问题，甚至贡献他们的想法和改进。Git通过在GitHub或Bitbucket等地方发布代码来实现这一点。</li><li id="e8d4" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">棉绒。通常这是你想要的——尤其是当你希望人们为你的工作做出贡献的时候。这将有助于确保他们添加的每一段代码都写得正确。</li></ul><p id="8c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可能会继续下去，但我认为这些小组有助于表明构建一个包——至少是以正确的方式——对于您的IDE来说不是微不足道或不可行的。</p><p id="4aa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，感谢Harmony的环境，我们可以开始少担心那些工具，更多地关注于实际构建我们的组件。</p><p id="c130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速地看一下当您将一段代码提取到一个组件中时所经历的过程，以及您如何使用Bit Harmony与其他团队共享它。</p><h2 id="8119" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">入门指南</h2><p id="83f6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">关于如何安装和创建你的第一个组件的详细步骤指南，你可以查看他们的官方文档<a class="ae kv" href="https://harmony-docs.bit.dev/tutorial/install-bit" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="00b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我将假设您已经在系统上安装了Bit，并准备开始使用。</p><p id="49e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里要向你展示的是如何提取一段代码，并把它变成一个组件，而不影响你当前的项目。为此，我将使用我较早的开源项目之一，<a class="ae kv" href="https://github.com/deleteman/jwhisper" rel="noopener ugc nofollow" target="_blank"> jWhisper </a>(我不久前构建的JSON-WSP兼容库<a class="ae kv" href="https://blog.bitsrc.io/writing-an-rpc-library-in-node-js-673632413f5f" rel="noopener ugc nofollow" target="_blank"/>)。这是为了向您展示，您不需要以任何特殊的方式构建您的项目。</p><p id="aa06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的系统上安装Bit，使用CLI工具登录，并在Bit.dev上设置您的帐户(同样，查看他们的教程了解这些步骤)之后，您需要做的第一件事是创建一个作用域(也称为集合)，这是您的组件将驻留的地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/6e2fe059a6ed447b26326903eabf0176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSL2Y-9fQSOs8i3GwIBQNQ.png"/></div></div></figure><p id="0530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这里看到，我已经创建了自己的组件，并将其命名为“节点组件”我还选中了“从和谐开始”复选框。我是在我自己的用户下而不是在我的组织下创建的，但那只是我。</p><p id="48be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经解决了这个问题，让我们回到我们的代码并创建我们的工作空间，这是您想要做的第一件事。这是通过项目文件夹中的一个非常基本的命令完成的:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="14a0" class="np mb iq no b gy og oh l oi oj">$ bit init --harmony</span></pre><p id="bcc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">旗非常重要。否则，您将使用旧版本创建工作区。你现在需要关心的是刚刚为你创建的两个文件:</p><ol class=""><li id="7c2b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr ok nd ne nf bi translated"><code class="fe nl nm nn no b">.bitmap</code>文件。不要被名字弄糊涂了。虽然这听起来像一个图像，但它只是一个JSON文件，其中Bit跟踪所有组件并将它们的名称映射到它们的物理位置。你不需要手动更新这个文件，所以现在忽略它。</li><li id="3dfb" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr ok nd ne nf bi translated"><code class="fe nl nm nn no b">workspace.jsonc</code>。这是你要打开的。在这里，您将配置项目所需的一切。一会儿我们会看到更多。现在，你需要编辑<code class="fe nl nm nn no b">yourusername.your-scope</code>的<code class="fe nl nm nn no b">defaultScope</code>键。对我来说，那就是<code class="fe nl nm nn no b">"deleteman/node-components"</code>。</li></ol><p id="1e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们仔细看看什么是环境，以及我们能从环境中得到什么。</p><h2 id="b7e5" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">使用环境</h2><p id="fef7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">环境本质上是一组预先配置好的工具，供您在开发过程中使用。如果你过去用过Bit，这是一个新概念。</p><p id="11a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于有了环境，您可以配置您正在构建的项目的类型和您正在使用的工具(即所需的包管理器、linter、测试库等等)。这是因为从现在开始，你唯一需要担心的工具就是钻头。</p><p id="b790" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过环境，Bit抽象出对单个工具的需求，给你一个单一的入口点:它的CLI。</p><ul class=""><li id="4544" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">你需要构建你的代码吗？没问题。您可以配置构建管道或使用默认管道。</li><li id="b33f" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">您需要安装您的依赖项吗？没问题。通过环境，您可以为您的项目配置默认的包管理器(无论是npm、pnpm、yarn还是其他什么), Bit会在需要时负责调用它。</li><li id="bd1d" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">您需要在构建项目之前运行linter吗？太好了，你可以配置你最喜欢的linter并把它添加到环境提供的构建管道中。</li></ul><p id="363c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的组件的整个生命周期都是由Bit处理的，并且这样做的工具是在环境中配置的。</p><p id="23f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">配置环境的方法是编辑<code class="fe nl nm nn no b">teambit.workspace/variants</code>部分下的<code class="fe nl nm nn no b">workspace.jsonc</code>文件。让它看起来像这样:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="ebd4" class="np mb iq no b gy og oh l oi oj">"teambit.workspace/variants": {<br/>    "*": {<br/>      "teambit.harmony/node": { }<br/>    }<br/>  }</span></pre><p id="4f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们告诉Bit，我们对所有的<em class="ol">组件都使用了“节点”环境。但是我们可以对不同的文件夹使用不同的环境，这允许您在同一个项目中导出和处理不同的默认设置(你好，灵活性！).</em></p><p id="34d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过选择“node”环境，我们选择了Bit理解的最适合Node.js项目的默认行为。本质上，它选择<a class="ae kv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为默认测试库，理解所有以<code class="fe nl nm nn no b">*.spec.*</code>和<code class="fe nl nm nn no b">*.test.*</code>结尾的文件都是单元测试。它将使用TypeScript作为默认编译器和其他一些默认编译器。您可以查看整个列表。</p><p id="476c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这些默认值不满意，或者它们对你没有意义，你可以自己<a class="ae kv" href="https://harmony-docs.bit.dev/nodejs/extending-node" rel="noopener ugc nofollow" target="_blank">覆盖它们</a>。由于这是一篇基本的介绍文章，我将把高级的东西留到将来。我们将暂时使用默认设置。</p><p id="c978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续之前，您必须启动dev服务器，它将负责多项工作，包括为我们新配置的环境安装所需的文件:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="2073" class="np mb iq no b gy og oh l oi oj">$ bit start</span></pre><p id="cab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令需要一段时间，但是完成后，您可以导航到<code class="fe nl nm nn no b">localhost:3000/</code>来查看本地工作区UI。它现在是空的，但是当我们开始添加组件时，您将会看到它们。</p><h2 id="2d1a" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">将我们的代码设置为组件</h2><p id="f632" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要将我们的代码作为一个组件共享，我们需要使用Bit的CLI将其作为一个组件添加。重要的是要记住，一个组件不仅仅是一个包含代码的文件，而是包含代码、文档、单元测试以及它们之间的一切。这就是为什么我们的代码需要放在单独的文件夹中。</p><p id="bbb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的例子中，我将把我的日志模块作为目标，它只是Winston日志器的一个实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/2f40b8752b77eadc2f9579138f809e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Uo-w5HR9Vhx-jxfszhT3g.png"/></div></div></figure><p id="0db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用以下命令将文件夹添加为组件:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="6435" class="np mb iq no b gy og oh l oi oj">$ bit add lib/logger --namespace logger</span></pre><p id="7c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">namespace</code>标志用于在我的工作空间中对我的组件进行分组，然后在它们的远程作用域中进行分组。</p><p id="3e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在可以返回到您的本地用户界面，您将看到更新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/944227b071830281c1bd10968ead7388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_i974kaqlMT28z_-Y_thQ.png"/></div></div></figure><p id="d5a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们给它命名空间中的组件。太棒了。然而，似乎有一个问题。红色的<code class="fe nl nm nn no b">1,N</code>表示我们的组件有问题。</p><p id="91fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你跑步:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="38ea" class="np mb iq no b gy og oh l oi oj">$ bit status</span></pre><p id="b936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会注意到Bit已经拿起它需要Winston来工作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e108bdd7fa412140f1d22be830c42628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_Ze5zXdOVtv7QqVt42oZg.png"/></div></div></figure><p id="45ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要手动将这种依赖性添加到组件中，我们可以通过Bit:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="e5b5" class="np mb iq no b gy og oh l oi oj">$ bit install winston</span></pre><p id="0ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使用预先配置的包管理器安装依赖项(你可以在<code class="fe nl nm nn no b">workspace.jsonc</code>上看到——默认为<code class="fe nl nm nn no b">pnmp</code>)。这也将更新<code class="fe nl nm nn no b">workspace.jsonc</code>文件，向<code class="fe nl nm nn no b">teambit.dependencies/dependency-resolver</code>键添加新的依赖项。如果您重新启动dev服务器，您会在本地UI上看到红色消失了。</p><h2 id="380f" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">添加测试</h2><p id="1c5f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">此时，组件已经完成，可以导出了。但在此之前，我想向您展示向它添加测试是多么容易。</p><p id="6f78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:为了让下面的测试工作，您还需要使用下面的命令安装软件包<code class="fe nl nm nn no b">@babel/runtime</code>:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="22f2" class="np mb iq no b gy og oh l oi oj">$ bit install  <a class="ae kv" href="http://twitter.com/babel/runtime" rel="noopener ugc nofollow" target="_blank">@babel/runtime</a></span></pre><p id="6af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将把它作为一个依赖项包含在您的项目中。现在，您可以在components文件夹中创建一个简单的测试文件。我称之为<code class="fe nl nm nn no b">logger.spec.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="55bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我实际上是在模仿Winston，检查我的模块是否调用了基本的<code class="fe nl nm nn no b">createLogger</code>函数。这不是理想的测试，但足以向您展示Bit如何处理它。</p><p id="486b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加这个文件后，您可以运行<code class="fe nl nm nn no b">$ bit test</code>，它会负责调用Jest(或者您决定配置的测试框架)。最棒的是，您还可以在本地UI上获得图形更新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/90d872a23d41b214ff100d4f4118d428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77n8h3860MspINGIIoAYcQ.png"/></div></div></figure><p id="56f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意“测试”选项卡。它显示您的文件的结果。</p><h2 id="3f99" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">添加文档</h2><p id="bfc9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你希望有一天有人会用到你的组件，记录它们是必不可少的。Bit的伟大之处在于它有一些缺省值可以用来创建文档，并且它会将这些缺省值添加到它的UI中(本地和远程)。</p><p id="539c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在组件的文件夹中创建一个快速的<code class="fe nl nm nn no b">logger.docs.mdx</code>文件(注意,<code class="fe nl nm nn no b">*.docs.mdx</code>扩展名告诉Bit这个文件只是文档),如下所示:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="7628" class="np mb iq no b gy og oh l oi oj">---<br/>displayName: Logger Component<br/>description: A simple logger component using Winston<br/>labels: ['node.js', 'winston', 'logger']<br/>---<br/>This is the actual documentation of my module, you can add all the markdown you want.</span></pre><p id="a274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这转化为(减去最后一行，截屏显示了我花一些时间记录组件后的最终结果):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/22e598431f508d525b793ac33182add8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d12RCjPqASalESi1QcN1Xw.png"/></div></div></figure><p id="db89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意添加的标题、副标题和标签，以及可以扩展解释并添加示例和代码片段的最后一行。“Package name”字段是由Bit生成的，它向您展示了如何在代码中导入新的组件。这是因为它在<code class="fe nl nm nn no b">node_modules</code>文件夹中创建了一个符号链接，指向组件的实际文件夹。这有助于您从代码的实际物理位置提取代码。</p><p id="1b83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，您可以将JS代码更改为TypeScript，通过Bit导出组件，然后更改require语句以使用该包名(在本例中为<code class="fe nl nm nn no b">@deleteman/node-components.logger.logger</code>)提取文件。使用TS组件，您的JS代码仍然可以没有任何缺陷地工作(这是因为Bit编译了代码，并将JS输出保存在<code class="fe nl nm nn no b">node_modules</code>的适当文件夹中)。</p><h2 id="4c54" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">导出模块</h2><p id="5f9d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最后但肯定不是最不重要的，你现在准备好与世界分享你的模块。您已经提取了代码，添加了测试，设法创建了一些基本的文档，现在您可以简单地使用以下代码行来标记(即添加一个版本)您的组件并导出它:</p><pre class="kg kh ki kj gt oc no od oe aw of bi"><span id="3634" class="np mb iq no b gy og oh l oi oj">$ bit tag --all 1.0.0 --message "first version"<br/>$ bit export </span></pre><p id="5571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当运行第一个命令时，您实际上是在设置组件的版本号，并提交所有更改(就像使用Git一样)。在此过程中，测试将被触发，如果测试失败，整个过程将被取消。这是为了确保所有被标记的东西都能正常工作。</p><p id="248e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个命令将负责将所有内容导出到<a class="ae kv" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> Bit.dev </a>服务器中(注意，您可以创建自己的<a class="ae kv" href="https://docs.bit.dev/docs/bit-server" rel="noopener ugc nofollow" target="_blank">自托管Bit服务器</a>并在内部使用它，而无需将您的组件放在公共云上)。您应该会看到与您在本地看到的相同的文档和组件列表，但是是在您的帐户上。<a class="ae kv" href="https://bit.dev/deleteman/node-components" rel="noopener ugc nofollow" target="_blank">见矿，例如</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e263" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="053d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">恭喜，您已经成功地从Node.js项目中创建了一个可重用的组件。您从单个文件开始，将它转换成TypeScript(可能)，添加文档、测试文件，并在不影响项目安全的情况下与全世界共享它。</p><p id="4d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程涵盖了Bit Harmony添加的所有新功能的基础知识。我将在接下来的文章中涉及更深入的主题，但是请随意留下问题或建议场景，我将尝试在下一篇文章中涉及它们。</p></div></div>    
</body>
</html>