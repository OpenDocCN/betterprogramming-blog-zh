<html>
<head>
<title>Implementing Sign in with Apple Using Django (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Django实现苹果登录(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-sign-in-with-apple-using-django-a-recipe-part-2-of-3-12d673cf6eaf?source=collection_archive---------1-----------------------#2019-12-07">https://betterprogramming.pub/implementing-sign-in-with-apple-using-django-a-recipe-part-2-of-3-12d673cf6eaf?source=collection_archive---------1-----------------------#2019-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4857" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建您的自定义后端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cc201fc3012bc450277e8e2dc7a6bb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*dhPwRinHBrKUuR2GWbbohg.png"/></div></figure><p id="7bd5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是“使用Django实现苹果登录:一个诀窍”系列的第二部分，旨在为开发人员展示一条清晰的路径，以Django为后端在他们的iOS应用中实现苹果登录功能。</p><p id="8a29" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请参考<a class="ae lm" href="https://medium.com/better-programming/implementing-sign-in-with-apple-using-django-a-recipe-part-1-of-3-fc5695e6e9db" rel="noopener">此链接</a>阅读该系列的第一部分。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="2533" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.通过实现与Apple的登录，准备好后端</h1><p id="fe53" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">为了在Django驱动的后端上实现与苹果的登录，我们需要一个运行Django 2.0或更高版本项目的服务器，带有Python Social Auth。我们已经有了在本系列的“密钥和标识符的配置”ep中生成的密钥。</p><p id="8f02" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">API的身份验证部分构建在现有标准OAuth 2.0和OpenID Connect之上。为了让您清楚地了解事情是如何工作的，下面的图表显示了整个身份验证流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5aa6baabe7c75a9bc9fa0df2fac42881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RlWKTY41ZEZjPQ4D.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">来源:GitHub上的truffls </p></figure><h2 id="b30f" class="mw lv it bd lw mx my dn ma mz na dp me kz nb nc mg ld nd ne mi lh nf ng mk nh bi translated">构建身份验证请求</h2><p id="0ea7" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">正如我们在上面给出的图表中看到的，iOS应用程序联系AppleID服务并接收Apple ID凭据，其中包含一个<code class="fe ni nj nk nl b">authorizationCode</code>。然后这个<code class="fe ni nj nk nl b">authorizationCode</code>被发送到后端，在那里构建认证请求。身份验证请求由几部分组成:</p><ul class=""><li id="4b49" class="nm nn it ks b kt ku kw kx kz no ld np lh nq ll nr ns nt nu bi translated">Key ID:它是我们在苹果开发者门户中生成的密钥的ID。</li><li id="ce56" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated">苹果开发团队ID</li><li id="626e" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated">客户端ID:这是iOS应用程序的捆绑包ID。例如，<code class="fe ni nj nk nl b">com.samplecompany.sampleapp</code>。</li><li id="a685" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated">客户机密</li></ul><h2 id="0356" class="mw lv it bd lw mx my dn ma mz na dp me kz nb nc mg ld nd ne mi lh nf ng mk nh bi translated">如何创建客户端密码？</h2><p id="d255" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">客户秘密每次都是由我们自己从我们的私钥中生成的。Apple使用ES256 JWT算法来生成客户端密码。关于这一点的更多信息在<a class="ae lm" href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中给出，标题为“创建客户端秘密”</p><p id="4a12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的例子中，我们使用PyJWT来生成客户端秘密。为了将PyJWT安装到Django项目中，我们可以在项目文件夹中打开终端，键入并运行:</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="cce6" class="mw lv it nl b gy oe of l og oh">pip install pyjwt</span></pre><p id="af89" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，我们可以导入该包，并如下所示使用它来创建一个完整的身份验证请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6daa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">关于<code class="fe ni nj nk nl b">payload</code>中给出的按键的更多信息可以在<a class="ae lm" href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>中找到。</p><h2 id="fbfe" class="mw lv it bd lw mx my dn ma mz na dp me kz nb nc mg ld nd ne mi lh nf ng mk nh bi translated">自定义后端的实现</h2><p id="980a" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">既然我们已经为构建身份验证请求做了安排，现在我们可以开始后端工作了。虽然Python Social Auth实现了OAuth 2.0标准，但我们必须扩展<code class="fe ni nj nk nl b">BaseOAuth2</code>并覆盖一些函数，因为苹果在它们的流程上有一些差异。我们将不得不覆盖以下方法:</p><ul class=""><li id="cbfb" class="nm nn it ks b kt ku kw kx kz no ld np lh nq ll nr ns nt nu bi translated"><code class="fe ni nj nk nl b">get_user_details</code>:需要覆盖这个方法，将电子邮件地址或其他用户信息返回给Python Social Auth框架。</li><li id="36c2" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated"><code class="fe ni nj nk nl b">get_key_and_secret</code>:我们需要覆盖这个方法，因为我们必须以上面提到的方式生成客户端秘密。</li><li id="fe62" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated"><code class="fe ni nj nk nl b">do_auth</code>:由于我们需要验证移动客户端从Apple发送的访问令牌，并获取可以从中提取其他详细信息的ID令牌，因此我们需要覆盖此方法。</li></ul><h2 id="79f8" class="mw lv it bd lw mx my dn ma mz na dp me kz nb nc mg ld nd ne mi lh nf ng mk nh bi translated">为什么ID令牌很重要？</h2><p id="7bc3" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">作为验证令牌调用的响应，Apple返回了<code class="fe ni nj nk nl b">id_token</code>字段。这个字段包含了很多信息，其中<code class="fe ni nj nk nl b">sub</code>和<code class="fe ni nj nk nl b">email</code>最为重要。<code class="fe ni nj nk nl b">sub</code>是保存唯一用户ID的主题字段，<code class="fe ni nj nk nl b">email</code>是用户的假或真的电子邮件地址。</p><p id="46ce" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">可以通过以下方式利用JWT对<code class="fe ni nj nk nl b">id_token</code>进行解码:</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="570e" class="mw lv it nl b gy oe of l og oh">decoded = jwt.decode(id_token, ‘’, verify=False)</span></pre><p id="8b76" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这一点在<a class="ae lm" href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>中也有说明。</p><p id="497f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们创建一个名为<code class="fe ni nj nk nl b">AppleOAuth2</code>的类，作为使用Python Social Auth处理Apple登录的自定义后端。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2a0b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们应该记住的一点是，只有当我们第一次提出请求时，才会返回电子邮件地址和姓名。因此，如果出现我们需要反复测试的情况，我们每次都需要从我们的<a class="ae lm" href="https://appleid.apple.com/" rel="noopener ugc nofollow" target="_blank"> AppleID帐户</a>中的授权应用列表中删除我们的应用。</p><h2 id="2377" class="mw lv it bd lw mx my dn ma mz na dp me kz nb nc mg ld nd ne mi lh nf ng mk nh bi translated">不想用Python社交Auth怎么办？</h2><p id="3e8f" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">如果不想使用Python Social Auth，可以在用户验证后手动创建用户，并解码我们从苹果收到的<code class="fe ni nj nk nl b">id_token</code>字段的值。如果<code class="fe ni nj nk nl b">uid</code>已经存在，那么我们必须理解它是同一个用户。因此，我们只需登录。然而，如果使用Python Social Auth，所有这些事情都会自动处理。</p><p id="27a4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们已经设置了我们的后端，使其能够使用Apple功能登录。剩下的唯一步骤是第三步，也是最后一步，即<a class="ae lm" href="https://medium.com/@sagunraj/implementing-sign-in-with-apple-using-django-a-recipe-part-3-of-3-12d66947d4f5" rel="noopener">在我们的iOS应用</a>中实现与苹果的登录。如果你还没有读完第一步，一定要看看这个系列的<a class="ae lm" href="https://medium.com/better-programming/implementing-sign-in-with-apple-using-django-a-recipe-part-1-of-3-fc5695e6e9db" rel="noopener">第一部分</a>。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="0ffd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><ul class=""><li id="7df2" class="nm nn it ks b kt mm kw mn kz ok ld ol lh om ll nr ns nt nu bi translated"><a class="ae lm" href="https://developer.apple.com/documentation/authenticationservices" rel="noopener ugc nofollow" target="_blank">认证服务文档</a></li><li id="e527" class="nm nn it ks b kt nv kw nw kz nx ld ny lh nz ll nr ns nt nu bi translated"><a class="ae lm" href="https://github.com/truffls/sign-in-with-apple-using-django" rel="noopener ugc nofollow" target="_blank">GitHub上的truffls</a></li></ul></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="90a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你觉得这篇文章有用，并且愿意支持我，请"<a class="ae lm" href="https://www.buymeacoffee.com/sagunraj" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a>"</p><div class="on oo gp gr op oq"><a href="https://www.buymeacoffee.com/sagunraj" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Sagun Raj Lage正在撰写博客和书籍，并免费教授编程。</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">我是一名iOS开发人员，有从事各种领域相关项目的经验，如交通和…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.buymeacoffee.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ko oq"/></div></div></a></div></div></div>    
</body>
</html>