<html>
<head>
<title>Want to Master React? Think About Renders, Not Lifecycles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想让主人有什么反应？考虑渲染，而不是生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/youre-looking-at-function-components-wrong-8b2ac4c51737?source=collection_archive---------11-----------------------#2022-05-18">https://betterprogramming.pub/youre-looking-at-function-components-wrong-8b2ac4c51737?source=collection_archive---------11-----------------------#2022-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fdf8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你看错了功能组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b674b1e2034c8db459b27f9e1b272a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i7lQAD3GTlPK6JYv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">劳拉·吉尔克里斯特在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="2291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，您可能很好地理解了React中的函数组件，但许多人并不理解。这很遗憾，因为它们提供了一种可预测的和声明性的方法来构建UI。</p><p id="5759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管它很优雅，但这种方法并不总是直观的，特别是对于习惯于具有大量反应性“魔法”的库(如Vue和Svelte)或采用更强制性方法的库(如jQuery)的开发人员来说。</p><p id="807e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过一些例子，我们将深入React中函数组件的基础，以及为什么你可能会想错它们。</p><h1 id="92d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">胡克之前的日子</h1><p id="6dce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在钩子被引入反应之前，函数组件必须是纯的(没有状态或副作用)。尽管有这些限制，它们提供了类组件所缺乏的简单性和可预测性。</p><p id="a883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，他们还引入了一个基本原则，这个原则现在是React的基础:<strong class="lb iu">视图是模型的函数</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/dd77d3738812dbf32be8ab3c00cbe915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLbAvGZYvziAkWvrDppbdw.png"/></div></div></figure><p id="8cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于纯组件来说，“模型”只不过是组件的道具。所以就目前来说，我们可以把函数组件看成只是一个接受道具并返回视图的函数。直截了当，对吧？</p><p id="0b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在现实世界中，用户界面并不纯粹。最重要的是，他们有一个讨厌的叫做国家的东西，它会毁掉一切。根据定义，状态不能作为函数的输入(那只是一个道具)，这意味着函数组件需要一种方法来“了解”有状态数据，而不接受它作为参数。输入钩子。</p><h1 id="c574" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">钩子是什么？</h1><p id="167b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可能认为钩子完全违背了我们的心智模型，即视图是模型的一个函数。他们没有。视图不是模型的一个纯粹的函数——有状态性阻止了这一点——但是从<code class="fe mu mv mw mx b">V = f(M)</code>的角度考虑仍然有助于我们编写更好的代码。</p><p id="d7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子就像是从我们的函数到外部有状态世界的一种逃避。它们实际上是如何工作的<a class="ae ky" href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" rel="noopener">实际上并没有那么复杂</a>，但是现在已经超出了范围。</p><p id="552e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于钩子，真正重要的是要理解没有反应魔法。它们只是普通的变量，可以在函数组件的范围内访问。</p><p id="9d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在实践中是如何运作的？</p><h1 id="f933" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这一切都回到渲染</h1><p id="ef23" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">呈现一个函数组件就像调用函数一样简单。这听起来是显而易见的，但重要的是要真正理解这一点:每次组件被渲染或重新渲染时，并没有什么神奇的事情发生，只是一个简单的函数调用，返回一个视图(JSX，在React的情况下)。</p><p id="4451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纯组件只需要在道具变化时重新渲染。React在这种情况下的工作非常简单:每当道具改变时，调用组件函数，传入新的道具值，并显示返回的JSX。</p><p id="0af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用钩子渲染一个组件更复杂。我们以<code class="fe mu mv mw mx b">useState</code>挂钩为例。它在渲染过程中扮演两个重要角色:</p><ol class=""><li id="2bb3" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">它告诉React在调用setter函数时重新呈现组件</li><li id="a8d4" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">它必须在每个渲染中提供状态的当前值和setter函数</li></ol><p id="f37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将关注第二个问题的含义，因为第一个问题并不特别有趣，也超出了本次讨论的范围。</p><p id="94ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，重新渲染就像调用函数一样简单。假设我们重新渲染这个组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本反应计数器应用程序</p></figure><p id="3b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为<code class="fe mu mv mw mx b">counter</code>有一些神奇的反应，但事实并非如此。这是一个<code class="fe mu mv mw mx b">const</code>:它的值在函数调用的范围内不会改变。</p><p id="8006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(顺便说一下，现在是复习Javascript中闭包的好时机。不理解闭包就无法掌握React。)</p><p id="1353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一次从类组件迁移到函数组件的React用户来说，这是一个典型的陷阱。对于类组件，状态是可变的，所以任何对状态值的引用都会给你真正的最新值。</p><p id="cd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在功能组件中并非如此。假设我们在增量回调中添加了一个延迟打印语句。如果我们第一次点击增量按钮，你认为会打印出什么数字？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器app，超时…会怎么样？</p></figure><p id="8706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe mu mv mw mx b">1</code>可能看起来是直观的答案，但打印出来的值实际上是<code class="fe mu mv mw mx b">0</code>。但是为什么呢？</p><p id="02d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住<code class="fe mu mv mw mx b">counter</code>是函数调用范围内的常数。按钮处理程序是在这个函数调用过程中创建的，并且<code class="fe mu mv mw mx b">counter</code>被永久设置为<code class="fe mu mv mw mx b">0</code>。因此，在第一次呈现中，<code class="fe mu mv mw mx b">useState</code>提供初始状态值，并像在任何其他Javascript函数中一样进行替换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们组件的第一个渲染看起来像什么</p></figure><p id="a3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以更清楚地看到，<code class="fe mu mv mw mx b">setTimeout</code>回调只能打印创建回调时<code class="fe mu mv mw mx b">counter</code>的值。而且重要的是，即使后来更新了<code class="fe mu mv mw mx b">counter</code>的值，重新渲染了组件，初始的回调也不会改变；相反，新的呈现将创建一个新的回调，然后打印更新后的值。</p><p id="5f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个过程大概是这样的:</p><ol class=""><li id="e88e" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">初始渲染。<code class="fe mu mv mw mx b">counter</code>为0，因此点击处理程序创建一个回调函数，该函数将在1秒后<code class="fe mu mv mw mx b">console.log(0)</code></li><li id="9d35" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">重新渲染，因为已经调用了<code class="fe mu mv mw mx b">setCounter</code>。现在，同样的渲染函数再次被调用，但这次<code class="fe mu mv mw mx b">counter</code>的值为1，而<em class="mt">只在这个新函数调用</em>的范围内。仍在等待执行的超时处理程序保持不变(多亏了闭包)。</li><li id="b0c2" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">3秒钟后，执行在初始渲染中创建的回调，打印<code class="fe mu mv mw mx b">0</code>。</li></ol><h1 id="5b3c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这一切意味着什么？</h1><p id="c938" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很多人认为React中函数组件和类组件的区别只是组件实际上是如何编写的问题。</p><p id="baaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要掌握React，你必须用与函数组件相同的方式思考。与其考虑组件的生命周期，不如从渲染的角度考虑:当组件重新渲染时，是什么导致了组件的重新渲染(属性改变，状态改变，等等)。)?道具和挂钩提供的价值是什么，是不可改变的吗？</p><p id="3194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种开发功能组件的方法将帮助您更深入地理解它们，更快地诊断和修复bug，并设计出更可预测、更干净的UI组件。</p></div></div>    
</body>
</html>