<html>
<head>
<title>Angular AJAX Interfaces Don’t Work As You Might Expect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有棱角的AJAX接口并不像你想象的那样工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-ajax-interfaces-dont-work-as-you-might-expect-fae73ad19f83?source=collection_archive---------8-----------------------#2019-09-01">https://betterprogramming.pub/angular-ajax-interfaces-dont-work-as-you-might-expect-fae73ad19f83?source=collection_archive---------8-----------------------#2019-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cb6379d43b28c7b576e605a13ffa04c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8MTLil0Xduz3N0L7"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">本·怀特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9849" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当从Angular web应用程序提供AJAX通信时，最好的做法是编写一个Typescript接口。这样，您就可以设置希望从JSON接收的字段，并设置可观察对象来管理它。不管怎样，底层发生了什么并不清楚，可能会让你认为Angular实际上是将JSON键和值映射到接口上。</p><p id="c260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但事实并非如此。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7bc6" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我应该用一个接口代替&lt;<em class="mj">any&gt;T15】吗？</em></h1><p id="7464" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe mp mq mr ms b">HttpClientModule</code>使您能够使用通常在服务中注入的提供者<code class="fe mp mq mr ms b">HttpClient</code>来执行AJAX请求。这种注入是使用角度依赖注入完成的，这是一种内置机制，可以将服务实例放入任何需要使用它的组件、服务或Typescript类中。</p><p id="9f89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该服务使您能够调用<code class="fe mp mq mr ms b">get</code>、<code class="fe mp mq mr ms b">post</code>和其他方法来用任何方法触发HTTP请求。这些服务方法中的每一个都必须以不同的方式传递参数，因为我们希望将参数放在HTTP主体请求中(使用<code class="fe mp mq mr ms b">POST</code>)或HTTP头中(例如，使用<code class="fe mp mq mr ms b">GET</code>)。</p><p id="4110" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到可观察对象时，有趣的部分就来了，因为所有这些方法都有一个可观察对象作为返回类型。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/ccfc67c60dfea4435ff8412f5f3dfe4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UdfPMPKVHYjR4xchVQthg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">所有HttpClient服务方法都返回Observables <any/></p></figure><p id="e2e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为默认的内置实现，所有这些方法都用可观察对象处理<code class="fe mp mq mr ms b">&lt;any&gt; </code>,这意味着每个订阅这个可观察对象(然后触发它)的人都会收到一个<code class="fe mp mq mr ms b">&lt;any&gt;</code>对象。</p><p id="6175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mp mq mr ms b">&lt;any&gt;</code>对象从来都不是一个好主意，除非它在您的特定用例中有内在的意义。请记住，使用通用对象会导致完全非结构化的对象建模方法，并且很容易在代码中生成对字段和方法的错误引用。</p><p id="25b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不使用<code class="fe mp mq mr ms b">&lt;any&gt;</code>，而是使用Typescript接口来定义JSON结构，并将其映射到我们的应用程序中。</p><p id="bbe5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的是，我们可以实例化一个自定义类，而不是接口，这样我们就可以编写代码来实现方法和有用的东西，使我们的实例更加强大。</p><p id="c5bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一些应用程序中，这个动作被称为<em class="my">序列化</em>(例如，将JSON序列化为模型)。我花了很多时间尝试在Angular中将JSON自动序列化为实例类，但是没有办法做到这一点，除非实现工厂设计模式或类似的东西。没有自动化允许它。即使您试图将处理JSON的可观察对象设置为一个类名，当您使用反射检查对象时，您将得到一个通用对象。这就是为什么大多数程序员使用工厂模式或助手方法来实例化一个类，而不是假装Angular会为你做这件事。</p><p id="d39a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论如何，如果你想了解更多关于建模接口的知识，请继续阅读。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f259" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">隐藏和怪异的行为</h1><p id="1547" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">一旦您将接口设置为由<code class="fe mp mq mr ms b">HttpClient</code> Observable处理，您会看到这样的情况:</p><pre class="mu mv mw mx gt mz ms na nb aw nc bi"><span id="41f5" class="nd lm it ms b gy ne nf l ng nh">import { Injectable } from '<a class="ae kf" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { HttpClient } from '<a class="ae kf" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';<br/>import { Observable } from 'rxjs';<br/>import { AjaxResponse } from '../interfaces/ajax.interfaces';</span><span id="64e9" class="nd lm it ms b gy ni nf l ng nh"><a class="ae kf" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>({<br/>  providedIn: 'root'<br/>})<br/>export class AjaxService {</span><span id="1b85" class="nd lm it ms b gy ni nf l ng nh">endPoint = `/assets/mock.json`</span><span id="4577" class="nd lm it ms b gy ni nf l ng nh">constructor(<br/>    private http : HttpClient<br/>  ) { }</span><span id="3151" class="nd lm it ms b gy ni nf l ng nh">getCandies() : Observable&lt;<strong class="ms iu">MyInterface</strong>&gt;{<br/>    return this.http.get&lt;<strong class="ms iu">MyInterface</strong>&gt;(`${this.endPoint}`)<br/>  }</span><span id="fd86" class="nd lm it ms b gy ni nf l ng nh">}</span></pre><p id="b1fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你必须记住的第一件事是，由可观察对象处理的类型的表达式实际上并没有做多少事情。</p><p id="17fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住，通过HTTP和<code class="fe mp mq mr ms b">XmlHttpRequest</code>传递的任何东西都只是一个非结构化的对象，反映了MIME类型application/JSON。这就是为什么Observable处理<code class="fe mp mq mr ms b">&lt;any&gt;</code>而不是一个类型化的泛型。无论谁遇到该接口，都可以访问该接口提供的字段，而不是<code class="fe mp mq mr ms b">&lt;any&gt;</code>字段。但是还有更多…</p><p id="0511" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，接口的指示形式化了可观察的数据，但它不会删除或丢弃任何超出的信息。因此，即使您将接口设置为有三个JSON键，您也将获得并在JVM内存中保存web服务器发送给您的所有内容。</p><p id="4c01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这基本上不受您的控制，因为这是Javascript和AJAX的固有行为:JavaScript只是获取一切并将其传递给应用程序上下文。如果你曾经认为Angular会从内存中清除任何你没有说过要继续使用接口字段的东西，你会发现这不会发生。</p><p id="a968" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试它很容易:发出一个AJAX请求，使用一个带有一些字段的接口，并使用一个web服务作为端点，它将向您发送比预期更多的内容。现在试着<code class="fe mp mq mr ms b">console.log</code>一下界面，你会看到里面会包含你收到的所有东西，就好像你根本没用过这个界面一样。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e14b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论和安全考虑</h1><p id="6964" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">注意这种角度行为，因为它可能会背叛你的假设。</p><p id="3c34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时候，在应用程序执行期间，来自AJAX的数据会在内存中浮动很长时间——这取决于您如何使用接口实例以及它的作用域何时结束。</p><p id="cbcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你使用一个远程API时，不要假装只得到你的接口定义的东西，因为你将得到所有的东西。</p><p id="6d6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">丢弃不需要的数据的唯一方法是使用我提到的第一种方法。如果您在Angular组件中获取即将到来的数据(甚至使用接口),并实例化您的定制模型，那么一旦接口范围结束，接口就会释放内存。</p><p id="134b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，JSON可能在底层启动的函数中包含恶意代码，而您甚至不应该在内存中包含这些代码。</p></div></div>    
</body>
</html>