<html>
<head>
<title>Implementing the Prefetch Pattern in React Concurrent Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React并发模式下实现预取模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-the-prefetch-pattern-in-react-concurrent-mode-c10c9813e2e7?source=collection_archive---------16-----------------------#2019-11-04">https://betterprogramming.pub/implementing-the-prefetch-pattern-in-react-concurrent-mode-c10c9813e2e7?source=collection_archive---------16-----------------------#2019-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a8e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">渲染时提取，提取后渲染，提取时渲染</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/919a0793b9afcdb8b31bd7eb91d99758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ILWRp2xtp-DeNfKc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@franki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，React公布了React生态系统的一个功能——<a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>。这将允许我们在需要的时候停止或延迟组件的执行。这将有助于React应用保持响应，并根据用户的设备功能和网络速度进行适当调整。</p><p id="9732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并发模式包含一系列新特性——其中最大的特性之一是<em class="ls">暂停</em>和一种新的数据获取方法。</p><p id="c8f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，有三种方法可以做到:</p><ul class=""><li id="b98a" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">渲染时提取:我们开始渲染组件，这些组件中的每一个都可能在其效果和生命周期方法中触发数据提取。一个很好的例子是<code class="fe mc md me mf b">useEffect</code>中的<code class="fe mc md me mf b">fetch</code>。</li><li id="a7c8" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">获取-然后-渲染:尽可能早地开始获取下一个屏幕的所有数据。当数据准备好时，呈现新的屏幕。在数据到达之前，我们什么也做不了。例如，有一个<code class="fe mc md me mf b">Container</code>组件，它处理数据获取，并在我们收到所有东西后有条件地呈现子表示组件。</li><li id="6151" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">获取即渲染:尽早开始获取下一个屏幕所需的所有数据，并立即开始渲染新屏幕<em class="ls">，甚至在我们得到网络响应</em>之前。当数据流进来时，React重新尝试渲染仍然需要数据的组件，直到它们都准备好。</li></ul><p id="63ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信前两种方法的概念是众所周知的，并且肯定会在您的代码中出现。让我们直接进入“随取随渲染”的方法。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2bd1" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated"><strong class="ak">随取随渲染</strong></h1><p id="e1f7" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">您可能已经注意到对这种方法的解释有两个部分:</p><ul class=""><li id="4782" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">尽早开始加载数据。</li><li id="7ed4" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">开始尝试呈现可能仍然需要数据的组件。</li></ul><h2 id="6fb7" class="np mt iq bd mu nq nr dn my ns nt dp nc lf nu nv ne lj nw nx ng ln ny nz ni oa bi translated">早点取</h2><p id="35cd" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们一起搭建一个加载主要股指的app吧。为此，我们有一个简单的“加载”按钮。一旦你点击它，我们立即开始加载数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mc md me mf b">prefetchQuery</code>是一个函数，它执行<code class="fe mc md me mf b">fetch</code>请求并返回一个对象，我们将把这个对象传递给<code class="fe mc md me mf b">&lt;IndexList /&gt;</code>组件。这个例子的关键是我们从<code class="fe mc md me mf b">onClick</code>事件中触发fetch，而不是在渲染阶段。</p><h2 id="ec6e" class="np mt iq bd mu nq nr dn my ns nt dp nc lf nu nv ne lj nw nx ng ln ny nz ni oa bi translated">带着悬念提前呈现</h2><p id="43a2" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">上面例子的第二部分是我们将对象从<code class="fe mc md me mf b">prefetchQuery</code>保存到状态，并立即开始渲染<code class="fe mc md me mf b">&lt;IndexList /&gt;</code>。</p><p id="2f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，我们也不希望用空数据来呈现列表，所以理想情况下，我们希望能够暂停呈现，直到我们获得所有数据，而无需编写<code class="fe mc md me mf b">if (isLoading) return null</code>。幸运的是，我们有<a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe mc md me mf b"><a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">Suspense</a></code><a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">组件</a>正是为了这个目的。</p><p id="e8a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂停是一种机制，用于数据获取库进行通信，以对组件正在读取的数据尚未就绪做出反应。React然后可以等待它准备好并更新UI。</p><p id="f3b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我给你看一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了利用悬念，你只需要用它包装你的组件。它接受一个<code class="fe mc md me mf b">fallback</code> prop:您希望在等待数据时显示的元素。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="4892" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">如何与悬念同步取数据？</h1><p id="09ca" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">现在你知道了悬念和预取的做法，你想知道这一切是如何一起工作的。这是这个拼图的最后一块。要解决它，我们最后来看看<code class="fe mc md me mf b">prefetchQuery</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="96fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要被它的复杂性吓到，它实际上相当简单。</p><p id="c538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们获取一个URL并将其传递给本机<code class="fe mc md me mf b">fetch</code>函数，接收一个承诺，然后将其传递给<code class="fe mc md me mf b">wrapPromise</code>函数。该函数使用<code class="fe mc md me mf b">read()</code>方法返回一个对象:</p><ul class=""><li id="f8f8" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">如果一个承诺仍然悬而未决，我们抛出这个承诺。</li><li id="5546" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">如果一个承诺被错误地解决，我们抛出错误。</li><li id="96d5" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">如果解决了一个承诺，只需返回数据。</li></ul><p id="acef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，与传统的获取实践相比，我们唯一的区别是抛出一个待定的承诺。</p><p id="3dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mc md me mf b">IndexList</code>中有<code class="fe mc md me mf b">usePrefetchedQuery</code>时，它只执行<code class="fe mc md me mf b">read()</code>方法。如果数据还没有出现，它会在实际渲染之前抛出一个承诺，而<code class="fe mc md me mf b">Suspense</code>会捕捉到它。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0c55" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">这个怎么实验？</h1><p id="6a37" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">React团队引入了带有现代API的<a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">一个</a> <code class="fe mc md me mf b"><a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">experimental</a></code> <a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">版本</a>分支。</p><p id="71c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，您需要运行<code class="fe mc md me mf b">npm i react@experimental react-dom@experimental</code>并在本地使用它。我还在<a class="ae kv" href="https://codesandbox.io/s/prefetch-suspense-6q4gj" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上为你创建了一个实例，展示了我在一个工作项目中一起做的所有事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oc l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="cab9" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">我可以在我的生产项目中使用它吗？</h1><p id="027c" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">编号<strong class="ky ir"> </strong>并发模式仍在开发中，一些实施细节可能会发生变化。使用实验版本来熟悉新的概念，也许可以提出你自己的想法。例如，如何在路由器中集成预取实践或提供一种缓存数据的好方法。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="5b7a" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">更多资源</h1><ul class=""><li id="032f" class="lt lu iq ky b kz nk lc nl lf oe lj of ln og lr ly lz ma mb bi translated"><a class="ae kv" href="https://relay.dev/docs/en/experimental/a-guided-tour-of-relay" rel="noopener ugc nofollow" target="_blank">带悬念的接力实验版</a>。</li><li id="9fac" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">很快，你就能把预加载功能连接到路由器上了。看看<a class="ae kv" href="https://github.com/ReactTraining/react-router/pull/7010" rel="noopener ugc nofollow" target="_blank">https://github.com/ReactTraining/react-router/pull/7010</a>或者<a class="ae kv" href="https://github.com/frontarm/navi" rel="noopener ugc nofollow" target="_blank">导航路由器</a>。</li><li id="2457" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated"><a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式介绍</a>。</li><li id="ec34" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated"><a class="ae kv" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">数据提取暂停介绍</a>。</li><li id="5f57" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated"><a class="ae kv" href="https://codesandbox.io/s/prefetch-suspense-6q4gj" rel="noopener ugc nofollow" target="_blank">带实例的真人沙盒</a>。</li></ul></div></div>    
</body>
</html>