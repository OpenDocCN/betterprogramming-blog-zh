# 为什么应该将远程数据存储在缓存中(而不是在状态中)

> 原文：<https://betterprogramming.pub/why-you-should-be-separating-your-server-cache-from-your-ui-state-1585a9ae8336>

## 从大规模反应中得到的教训

![](img/0c12e552a2ed377e3098a7c111856fa6.png)

照片:[亚采克·斯莫特](https://unsplash.com/photos/rEGEeXPQ1FU)

React 中处理远程数据的一个常见模式是在`useEffect`中取数据，并将结果复制到组件状态中。大概是这样的:

如果`userData`需要从不同嵌套层次的其他组件中读取怎么办？

例如，我们可能需要从应用程序中完全独立的区域读取用户权限。通过道具传递数据可能很快变得不可行。

一个解决方案可能是使用像 [context](https://reactjs.org/docs/context.html) 这样的全局状态库，或者像 [MobX](https://mobx.js.org/) 或 [Redux](https://redux.js.org/) 这样的状态管理库。这些都可以工作，但是它们引入了不必要的复杂性。

即使我们不需要跨其他组件重用数据，它仍然是冗长和混乱的。我们需要在获取数据的每个组件中重复这个样板文件。

需要编写`useEffect`,我们需要每次都保持异步进程的完全相同的状态。在一个更现实的场景中，我们的组件可能还混合了一些本地 UI 状态。

远程数据是只读的。它不属于与我们的 UI 状态相同的位置。

我们可以通过以下方式解决这些问题:

1.  抽象出异步过程的样板文件(加载、错误等)。).
2.  将我们的远程数据存储在内存缓存中。

前者可以用一个定制的钩子来解决，但是处理你自己的内存缓存是困难和费时的。

谢天谢地，两个新的库解决了这两个问题: [swr](https://github.com/zeit/swr) 和 [react-query](https://github.com/tannerlinsley/react-query) 。两个库都提供了定制的 [React 钩子](https://reactjs.org/docs/hooks-overview.html)来管理远程数据获取。

让我们看看如何使用 swr 来清理前面的例子:

`useSWR()`采用唯一标识符(键)和提取器函数来解析数据。

在上面的例子中，`fetchUser`可以是任何异步函数。这意味着你可以将这些库与你已经在使用的任何数据获取 API 或库一起使用( [Fetch](https://fetchsoftworks.com/) ， [axios](https://www.npmjs.com/package/axios) ， [Apollo](https://www.apollographql.com/) 等)。).

唯一标识符用于缓存和重复数据消除请求。如果我们想从另一个组件访问相同的数据，我们可以用相同的键调用`useSWR`, SWR 将从缓存中检索它。

两个组件都引用相同的底层请求实例，我们不需要担心重复！

默认情况下，在`dedupingInterval`(react-query 中的`staleTime`)之后，请求的结果变得陈旧。这意味着，如果组件 A 发出请求，那么组件 B 在该时间间隔内使用相同的键发出请求，则从缓存中检索数据。

如果请求是在该时间间隔之后发出的，将重新提取数据并重新验证缓存。swr 使用两秒的默认时间间隔，react-query 使用默认值零。

这两个库都采用了过时但重新验证的缓存策略。这意味着，如果一个请求被标记为陈旧，那么先前缓存的数据将被返回，并进行重新验证。

当新数据到达时，数据被更新以反映新的状态，并且引用该请求键的所有组件将被重新呈现。你可以在本文的[中阅读更多关于 stale-while-revalidate 的内容。](https://web.dev/stale-while-revalidate/)

这两个库都很小(在撰写本文时小于 4kb ),并且拥有优秀的文档。它们支持暂停、轮询、滚动恢复、失败重试、窗口焦点重新验证等等。

窗口焦点重新验证是一项提供最新 UI 的伟大技术。引用自 swr 文档的这段话说得很好:

> “组件将不断自动获得一系列数据更新。因此，用户界面将始终保持快速反应。”

除了这些特性，我发现使用缓存解决方案的最大好处是它给我的代码库带来的简单性。

远程数据的获取和读取仍然位于我的组件中，我可以相信我总是在我的组件树中提供最新和同步的数据。

这两个库之间只有很小的区别。决定在您的应用程序中使用哪一个可能取决于个人偏好。评估每种 API，并决定哪种最适合您的应用。

在使用它们之前，值得注意的是远程数据处理仍然是 React 社区中非常活跃的领域。

鉴于目前还不清楚 React 将来是否会提供一个缓存解决方案，我认为使用这两个库来填补空白没有什么坏处。随着稳定并发模式的到来，数据获取解决方案很可能会继续发展。

注意:swr 和 react-query 目前在其构建的输出中包含 ES6 特性，这意味着它们不能在 IE11 中工作。

如果你不幸有支持 IE11 的责任，你将需要为 ES5 而奋斗。在我的例子中，我必须更新我的 [webpack](https://webpack.js.org/) 配置来包含 swr:

```
// ...

  {
    test: /\.(js|jsx|ts|tsx)$/,
    include: [
      resolve('src'),
      resolve('node_modules/swr'),
    ],
    use: ['babel-loader'],
  },
```

# **结论**

将远程数据存储在组件状态中会导致冗长和样板文件过多的组件。触及全局状态存储增加了更多的复杂性，这是不值得的。

使用像 swr 或 react-query 这样的数据获取解决方案将极大地简化您的代码并提高您的生产率。

我对这些库感到非常兴奋，希望通过分享这种兴奋，你会发现这种技术在你自己的代码中很有用，感谢阅读！