<html>
<head>
<title>Advanced Argument Parsing for a Swift-Based CLI Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Swift的CLI应用程序的高级参数解析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-argument-parsing-for-a-swift-based-cli-application-6f42ac09e838?source=collection_archive---------8-----------------------#2021-05-27">https://betterprogramming.pub/advanced-argument-parsing-for-a-swift-based-cli-application-6f42ac09e838?source=collection_archive---------8-----------------------#2021-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在我们的CLI应用程序中指定不同类型的参数并利用类型安全</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/646c224af648c15330b112034a493dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g3ekPK7ujPfQzfRw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@hannahjoshua?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉娜·约书亚</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="99a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我们开始了一个新项目，从命令行实现了一个非常基本的计算器应用程序。</p><p id="ed49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开发这个项目是为了探索由苹果公司提供的<a class="ae ky" href="https://github.com/apple/swift-argument-parser" rel="noopener ugc nofollow" target="_blank"> ArgumentParser </a>库，它为我们提供了从标准输入中读取用户输入的自动化。</p><p id="b3d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本周，我们将深入探讨一些更高级的功能。在开始之前，我建议快速浏览一下上周的代码，以刷新一些概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="321a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">验证:实现Div命令</h1><p id="a9fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的应用程序使用Comand模式作为主要的架构风格。每当我们需要添加一个新命令时，我们知道我们必须用一个定义新命令的新结构来扩展<code class="fe mz na nb nc b">Command</code>名称空间。</p><p id="6450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构最重要的需求是实现<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Types/ParsableCommand.swift" rel="noopener ugc nofollow" target="_blank">ParsableCommand</a></code>协议，该协议让我们定义命令的<code class="fe mz na nb nc b">configuration</code>，并要求我们实现<code class="fe mz na nb nc b">run()</code>方法来实际执行一些工作。</p><p id="3551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以实现另一种方法:T4方法。这种方法允许我们清楚地将验证代码与执行代码分开。</p><p id="251c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，我们实现了执行除法的<code class="fe mz na nb nc b">Div</code>命令。当除数为<code class="fe mz na nb nc b">0</code>时，不定义该操作。这是利用<code class="fe mz na nb nc b">validate()</code>方法验证这一条件的绝佳机会:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，记住将这个新命令添加到<code class="fe mz na nb nc b">Main</code>的<code class="fe mz na nb nc b">subcommand</code>属性中。否则，<code class="fe mz na nb nc b">Calc</code>应用程序无法识别该命令。</p><p id="700d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是用<code class="fe mz na nb nc b">Div</code>命令更新的新<code class="fe mz na nb nc b">main</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行将零作为除数的<code class="fe mz na nb nc b">Calc</code>应用程序，我们会得到以下错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/6eddd411d347abf18b0d46d42ffb11fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuu2Hm5CtAULMihOFcA_zA.png"/></div></div></figure><p id="e299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到应用程序如何自动使用<code class="fe mz na nb nc b">LocalizedError</code>协议的<code class="fe mz na nb nc b">errorDescription</code>属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d019" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令属性包装:标志</h1><p id="4a1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上周，我们看到了如何为命令定义参数。这些参数是我们的命令将用来执行其操作的参数。</p><p id="9306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用其他属性包装器来定制命令的行为方式。最简单的是<code class="fe mz na nb nc b">@Flag</code>包装。我们可以指定一个新的属性，并用这个属性包装器对其进行注释。</p><p id="8229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们指定一个默认值:如果在执行时没有指定，这就是标志所采用的值。一旦定义了属性，我们可以在<code class="fe mz na nb nc b">command</code>方法中处理它来改变命令行为。下面的代码显示了如何添加一个<code class="fe mz na nb nc b">verbose</code>标志以及如何在<code class="fe mz na nb nc b">run()</code>方法中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第18行到第20行定义了新标志。它还允许我们添加一个<code class="fe mz na nb nc b">help</code>属性来记录它的用法。在第26行，我们访问标志的值并基于它执行不同的操作。</p><p id="3c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过进入常用的<code class="fe mz na nb nc b">Edit Scheme...</code>屏幕来指定是否要在启用标志的情况下运行应用程序。在下面的例子中，我们传递标志。所以它的值会是<code class="fe mz na nb nc b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/7d163d03467626862cf52f896eab9975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tdn05PBNKLtNAfvv-D7KFQ.png"/></div></div></figure><p id="b3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行应用程序时，我们获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/714cc8c9126164b3d3fcf7bd9a9c995a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9mr-3sTyVTW0676soKGAQ.png"/></div></div></figure><p id="6df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果我们决定不传递标志或禁用它，我们可以从传递给应用程序的参数列表中删除它。在这种情况下，将使用标志的默认值(<code class="fe mz na nb nc b">false</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/7f5cf22770c07e8985d7bc0a6efb08fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LQSpDwq3ox4Zyrcm8MXNg.png"/></div></div></figure><p id="ed93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们将获得以下非详细输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/294c5171718286891418c05eab910328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llobC1DTa99PrLUPJM29oQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="abd7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令属性包装:选项</h1><p id="82e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用第二个属性包装器来修改命令的行为方式。这个属性包装器是<code class="fe mz na nb nc b">@Option</code>包装器，通常在值可以采用不同的值时使用——可能来自<code class="fe mz na nb nc b">enum</code>或者可以是来自用户的自定义输入(例如文件路径)。</p><p id="1b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">争论有一个好处:它们带有一个标签。这可以帮助我们在使用它们时理解它们的含义。例如，我们可以考虑实现一个选项来改变我们计算的输出格式。我们可能想用<code class="fe mz na nb nc b">standard</code>符号或使用<code class="fe mz na nb nc b">scientific</code>符号来查看它们。</p><p id="7836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们实现格式化选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们扩展了<code class="fe mz na nb nc b">Command</code>名称空间来添加<code class="fe mz na nb nc b">Format</code>枚举。这里，我们将一个<code class="fe mz na nb nc b">scientificFormatter</code>实现为一个<code class="fe mz na nb nc b">static</code>属性，该属性只在第一次访问格式化程序时计算一次。然后我们继续使用第一次创建的格式化程序(第3到9行)。</p><p id="8bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们创建了两个我们想要处理的不同案例，并实现了一个基于枚举值提供不同输出的方法。</p><p id="7946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ArgumentParser的角度来看，最重要的信息是<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Types/ExpressibleByArgument.swift" rel="noopener ugc nofollow" target="_blank">ExpressibleByArgument</a></code>协议。该协议使用户插入的文本能够被自动解析为可用选项之一。</p><p id="98ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以更新<code class="fe mz na nb nc b">Add</code>命令，根据这个选项产生不同的输出。</p><p id="3703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个用<code class="fe mz na nb nc b">@Option</code>属性包装器注释的属性。我们还可以为<code class="fe mz na nb nc b">help</code>参数添加一个漂亮的描述，这样我们就可以免费获得一些文档。请注意我们如何将默认值传递给属性。在这种情况下，如果我们省略<code class="fe mz na nb nc b">--output-format</code>选项，将使用默认值。</p><p id="4b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe mz na nb nc b">run()</code>方法中，我们可以利用指定的选项，基于它计算不同的输出。以下代码显示了如何使用输出格式<code class="fe mz na nb nc b">option</code>修改<code class="fe mz na nb nc b">Add</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="296b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，从<code class="fe mz na nb nc b">Edit Scheme...</code>中，我们可以更新我们的参数，用<code class="fe mz na nb nc b">scientific</code>选项传递新的<code class="fe mz na nb nc b">--output-format</code>选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/69381eb97978f0b152507df6fd597100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_M8tZuYF29nDklAWw60-w.png"/></div></div></figure><p id="717e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这样做，我们将获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9e14fd0e90482dfc00d2dbda881fadfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RImf1k6_cjxk-6CK_76JJg.png"/></div></div></figure><p id="ac8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们甚至可以无缝地将标志和选项混合在一起。例如，如果我们传递以下参数:</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="9362" class="nq md it nc b gy nr ns l nt nu">add 5000 10000 --verbose --output-format scientific</span></pre><p id="9641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/09b62d0879d8bd376ce72d6f16c1a3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_D2YGt5B3-Yc666UAbJ-gw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f78c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令属性包装:OptionGroup</h1><p id="6d08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想谈的最后一个包装器是<code class="fe mz na nb nc b">@OptionGroup</code>。当我们必须找出不同命令之间共享的一些属性时，这个包装器就派上了用场。</p><p id="326b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mz na nb nc b">verbose</code>和<code class="fe mz na nb nc b">outputFormat</code>属性不仅对<code class="fe mz na nb nc b">Add</code>命令有意义，对<code class="fe mz na nb nc b">Div</code>命令也有意义。我们要尽可能遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>的原则。因此，我们希望重用那些共享的属性。</p><p id="ef8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这一点的第一步是创建一个独立的结构，并使其符合<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Types/ParsableArguments.swift" rel="noopener ugc nofollow" target="_blank">ParsableArgument</a></code>协议。然后我们可以从<code class="fe mz na nb nc b">Add</code>命令中剪切并粘贴两个属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们完成了这些，我们就可以简单地修改<code class="fe mz na nb nc b">Add</code>和<code class="fe mz na nb nc b">Div</code>命令，添加一个<code class="fe mz na nb nc b">CommandArgs</code>类型的属性并用<code class="fe mz na nb nc b">@OptionGroup</code>包装器对其进行注释。</p><p id="ed84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要稍微修改一下<code class="fe mz na nb nc b">run</code>方法来访问新字段中的属性。这是最后一个<code class="fe mz na nb nc b">Add</code>命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ed75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过一行代码，我们可以共享不同共享参数的定义。从现在开始，我们可以在任何需要的地方添加选项组。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="715d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8825" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在今天的文章中，我们探索了<a class="ae ky" href="https://github.com/apple/swift-argument-parser" rel="noopener ugc nofollow" target="_blank"> ArgumentParser </a>库的一些高级功能。我们学习了如何传递<a class="ae ky" href="https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Properties/Flag.swift" rel="noopener ugc nofollow" target="_blank">标志</a>和<a class="ae ky" href="https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Properties/Option.swift" rel="noopener ugc nofollow" target="_blank">选项</a>以及如何构建我们的代码，这样我们就不会一遍又一遍地重复相同的参数。</p><p id="c919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ArgumentParser库，我们可以做更多的事情。它让我们传递一系列参数、可选参数、带有子命令的命令等等。如果你感兴趣或者你需要一些更高级的特性，我建议你看一下库本身提供的各种<a class="ae ky" href="https://github.com/apple/swift-argument-parser/tree/main/Examples" rel="noopener ugc nofollow" target="_blank">例子</a>。</p><p id="3abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信你会找到你想知道的一切。我希望这些文章能说服您用Swift编写工具。如果你想知道如何在你的公司内部署你的工具，我<a class="ae ky" href="https://medium.com/swlh/export-swift-cli-apps-f9aaaca08772" rel="noopener">写了另一篇关于这个主题的文章</a>。</p></div></div>    
</body>
</html>