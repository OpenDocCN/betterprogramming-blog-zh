<html>
<head>
<title>Swift: Optional Views With UIKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">With UIKit的可选视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-optional-views-with-the-proxy-and-abstract-factory-patterns-5f24f8cf84b8?source=collection_archive---------12-----------------------#2020-05-18">https://betterprogramming.pub/swift-optional-views-with-the-proxy-and-abstract-factory-patterns-5f24f8cf84b8?source=collection_archive---------12-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="831e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何有效地重用可选视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d7c8e57f618535bf9ed33b77bdc8ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_Tr2g8A_WoVSvirPiEm5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">西蒙·伯杰在<a class="ae ky" href="https://unsplash.com/s/photos/view?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="288f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">各种应用程序中都有可选视图。有1000种理由需要根据应用状态、用户档案、功能/产品可用性、A/B测试等条件显示或隐藏视图<em class="lv"> </em>。</p><p id="d071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题也有很多方法，但是我们可以根据哪个组件负责这个逻辑，将它们分成三组。</p><ul class=""><li id="6812" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">容器/可选视图的父视图:它作为第一个选项出现，因为它似乎是最容易和最简单的方式。事实上，在简单的情况下。但是，随着逻辑的增长，或者可选视图在其他地方被重用，它就变得混乱了。</li><li id="84aa" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">可选视图本身:同样，在简单的情况下，可选视图本身中的工厂方法可能是一种简单的方法。然而，视图不应该负责知道它是否应该被显示。应该是断言。</li><li id="8f36" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">其他类/工厂:逻辑来自容器/可选视图的父类，指向一个新类，该类的职责是仅在视图应该显示时实例化视图。</li></ul><p id="a740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索第三组，因为它将在更多的情况下为我们服务。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d881" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">具体工厂方法模式</h1><p id="38ce" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以采取的第一种方法是使用一个具体的<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法模式</a>并维护对工厂和<code class="fe no np nq nr b">OptionalView</code>的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/07ea5be7075492266c6b2a06a0f49a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*zCzwC2pIquEDgemnX4X1gg.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift+UIKit中带具体工厂方法的可选视图</p></figure><p id="6639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些可以改进的地方:</p><ul class=""><li id="455f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们使用的是<code class="fe no np nq nr b">OptionalView</code>的实现，而不是抽象。如果我们需要修改或替换<code class="fe no np nq nr b">OptionalView</code>，保持相同的行为，我们仍然需要修改使用它的每个容器。</li><li id="e1b7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们为一个<code class="fe no np nq nr b">OptionalView</code>维护两个引用，并且我们让容器知道我们正在为<code class="fe no np nq nr b">OptionalView</code>使用一个工厂。如果在某个时候，<code class="fe no np nq nr b">OptionalView</code>变得不是可选的，我们可能想要或者需要移除工厂方法模式。在这种情况下，我们还需要修改所有使用<code class="fe no np nq nr b">OptionalView</code>的容器。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f2fd" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">抽象工厂方法模式</h1><p id="2f30" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">用工厂方法模式对可选视图进行抽象将解决第一个问题。让我们看看如何:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ea99a3c534b17bc11dbd0154f900faa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*vsWSdMJu_mkFu1kvPvc-8g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift+UIKit中带抽象工厂方法的可选视图</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift+UIKit中带抽象工厂的可选视图</p></figure><p id="4691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经将<code class="fe no np nq nr b">OptionalView</code>的实现从容器中分离出来，但是我们仍然公开了我们正在使用一个工厂来实例化可选视图。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a21c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">代理模式</h1><p id="1548" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">既然我们对<code class="fe no np nq nr b">OptionalView</code>使用了抽象，那么使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noopener ugc nofollow" target="_blank">代理模式</a>封装工厂就更容易了，所以容器不需要知道。让我们看看如何:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1d6fe14ed5e12b4e611ebe31f3da25f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*QUd_-TjklaAxeT2ZEdQ0LA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift+UIKit中带抽象工厂方法代理模式的可选视图</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只是引用了<code class="fe no np nq nr b">OptionalView</code>的抽象，但是我们实际上注入了一个代理。这个代理本身可以作为一个工厂方法，也可以将任务委托给另一个类。</p><p id="656f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器不知道关于工厂的任何事情，我们可以删除代理，而根本不需要修改任何容器。</p><p id="14e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。让我知道你的想法。</p></div></div>    
</body>
</html>