<html>
<head>
<title>Top 5 Distributed System Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五大分布式系统设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-5-distributed-system-design-patterns-ae9482f49128?source=collection_archive---------0-----------------------#2021-06-04">https://betterprogramming.pub/top-5-distributed-system-design-patterns-ae9482f49128?source=collection_archive---------0-----------------------#2021-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过高级系统设计面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e71d03574062bb6e0bda6062f10410f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*714ygMN8XQgCLy_KLOuaPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="787e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分布式应用程序是现代软件开发行业的主要组成部分。它们是云存储服务的关键，并允许大规模的web应用程序保持反应性。当程序员构建这些系统时，他们需要一些基本的构建模块，以此作为起点，并使用共享的词汇表进行交流。</p><p id="f239" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是分布式系统设计模式变得无价的地方。虽然它们有时会被过度使用，但理解如何使用它们是招聘人员寻找的一项关键技能，也是在高级系统设计面试中脱颖而出的关键。</p><p id="fcfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将探索五种顶级分布式系统设计模式，以帮助您了解它们的优点、缺点以及何时使用它们。</p><p id="f8aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我们今天要讲的内容:</p><ul class=""><li id="815e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">什么是分布式系统设计模式？</li><li id="7564" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">1.命令和查询责任分离</li><li id="50d7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">2.两阶段提交</li><li id="05eb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">3.冒险故事</li><li id="1dd3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">4.复制负载平衡服务</li><li id="7f05" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">5.分片服务</li><li id="5d86" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">接下来学什么</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ffd9" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">什么是分布式系统设计模式？</h1><p id="ef19" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">设计模式是构建适合特定用例的系统的经过试验和测试的方法。它们不是实现，而是构建系统的抽象方式。大多数设计模式已经由许多不同的开发人员开发和更新了多年，这意味着它们通常是非常有效的起点。</p><p id="9cec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设计模式是构建模块，允许程序员从现有的知识中提取，而不是从每一个系统开始。他们还为系统设计创建了一套标准模型，帮助其他开发人员了解他们的项目如何与给定的系统交互。</p><p id="92c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建设计模式在构建新对象时提供了一个基线。结构模式定义了解决方案的整体结构。行为模式描述了对象以及它们如何相互通信。</p><p id="78b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分布式系统设计模式是在开发分布式系统时使用的设计模式，分布式系统本质上是计算机和数据中心的集合，对于最终用户来说，它们就像一台计算机。这些分布式设计模式概述了不同节点如何相互通信、哪些节点处理每个任务以及不同任务的流程的软件架构。</p><p id="461c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在设计大规模云计算和可扩展微服务软件系统的分布式系统架构时，这些模式被广泛使用。</p><h2 id="cc12" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">分布式设计模式的类型</h2><p id="3e62" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">大多数分布式设计模式根据它们使用的功能分为三类:</p><ul class=""><li id="5f60" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">对象通信:描述系统不同组件通信的消息协议和权限。</li><li id="a9c1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">安全性:处理机密性、完整性和可用性问题，以确保系统不会受到未经授权的访问。</li><li id="d786" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">事件驱动的:描述系统事件的产生、检测、消费和响应的模式。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a217" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">1.指挥和查询责任分离(CQRS)</h1><p id="a6f2" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">CQRS模式侧重于分离分布式系统的读写操作，以提高可伸缩性和安全性。该模型使用命令将数据写入持久存储，并使用查询来定位和获取数据。</p><p id="7251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些由接收用户请求的指挥中心处理。然后，命令中心获取数据，进行必要的修改，保存数据，并通知读取服务。然后，读取服务更新读取模型，以向用户显示更改。</p><h2 id="ac4c" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">优势</h2><ul class=""><li id="862d" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">通过委派任务降低系统复杂性。</li><li id="50ce" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">强制在业务逻辑和验证之间进行清晰的分离。</li><li id="9112" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">帮助按工作对流程进行分类。</li><li id="0a16" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">减少对共享数据的意外更改。</li><li id="f5aa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">减少拥有数据修改权限的实体数量。</li></ul><h2 id="d05c" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">不足之处</h2><ul class=""><li id="fcb6" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">需要在命令和读取模型之间不断地来回通信。</li><li id="7f52" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在发送高吞吐量查询时会导致延迟增加。</li><li id="e842" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">无法在服务进程之间进行通信。</li></ul><h2 id="0735" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">用例</strong></h2><p id="f302" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">CQRS最适合数据密集型应用程序，如SQL或NoSQL数据库管理系统。这对数据密集型微服务架构也很有帮助。它非常适合处理有状态的应用程序，因为写入者/读取者的区别有助于处理不可变的状态。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6627" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">2.两阶段提交(2PC)</h1><p id="a7d9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">2PC在事务性方法和对中央命令的依赖方面类似于CQRS，但是分区是根据它们的类型和完成的阶段来处理的。这两个阶段是<em class="ob">准备</em>阶段(在此阶段，中央控制告诉服务准备数据)和<em class="ob">提交</em>阶段(通知服务发送准备好的数据)。</p><p id="ac8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，2PC系统中的所有服务都是锁定的，这意味着它们不能发送数据。锁定时，服务完成准备阶段，因此一旦解锁就可以发送。协调器逐个解锁服务并请求它们的数据。如果服务没有准备好提交它的数据，协调器就转移到另一个服务。一旦发送了所有准备好的数据，所有服务解锁以等待来自协调器的新任务。</p><p id="3957" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2PC本质上确保了一次只能运行一个服务，这使得该过程比CQRS更具抵抗性和一致性。</p><h2 id="41dd" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">优势</h2><ul class=""><li id="6c98" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">一致并能抵抗由于缺少并发请求而导致的错误。</li><li id="66c6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">可扩展—可以像处理单台机器上的数据一样轻松地处理大数据池。</li><li id="b5a3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">允许同时进行隔离和数据共享。</li></ul><h2 id="de44" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">不足之处</h2><ul class=""><li id="0a49" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">不具备容错能力，由于其同步性，容易出现瓶颈和阻塞。</li><li id="2640" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">比其他设计模式需要更多的资源。</li></ul><h2 id="350c" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">用例</strong></h2><p id="97a3" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">2PC最适合处理高风险事务操作的分布式系统，这些操作注重准确性而不是资源效率。它可以防止错误，并且在错误发生时很容易跟踪错误，即使是大规模的错误。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3eca" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">3.冒险故事</h1><p id="4a2c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Saga是一种异步模式，它不使用中央控制器，而是完全在服务之间进行通信。这克服了前面提到的同步模式的一些缺点。</p><p id="3596" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Saga使用事件总线来允许微服务系统中的服务相互通信。总线在服务之间发送和接收请求，每个参与的服务创建一个本地事务。然后，每个参与服务都发出一个事件供其他服务接收。其他服务都监听事件。接收事件的第一个服务将执行所需的操作。如果该服务未能完成操作，它将被发送到其他服务。</p><p id="5fcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种结构类似于2PC设计，因为如果不能完成任务，服务就会循环。然而，Saga删除了中央控制元素，以更好地管理流程并减少所需的来回通信量。</p><h2 id="8a0d" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">优势</strong></h2><ul class=""><li id="cacc" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">单个服务可以处理更长的事务。</li><li id="e7de" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">由于分散化，非常适合分布式系统。</li><li id="b920" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">由于服务之间的点对点通信，减少了瓶颈。</li></ul><h2 id="f02c" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">劣势</strong></h2><ul class=""><li id="c297" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">异步自治使得很难跟踪哪些服务正在执行单独的任务。</li><li id="35bf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">由于复杂的编排而难以调试。</li><li id="11a1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">比以前的模式更少的服务隔离。</li></ul><h2 id="05d5" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">用例</strong></h2><p id="d55a" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">Saga的分散方法非常适合可伸缩的无服务器功能，可以同时处理许多并行请求。AWS在许多函数中使用基于Saga的设计，如阶跃函数和lambda函数。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6ddd" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">4.复制负载平衡服务(rlb)</h1><p id="c4f3" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">RLBS模式是最简单和最常用的设计模式。在最基本的层面上，它由多个相同的服务组成，这些服务都向一个中央负载平衡器报告。每个服务都能够处理任务，并且在失败时可以复制。负载平衡器接收来自最终用户的请求，并以循环方式或有时通过使用更复杂的路由算法将它们分发到服务。</p><p id="b9fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重复的服务确保应用程序为用户请求保持高可用性，并且可以在服务的一个实例失败时重新分配工作。</p><p id="a1b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">RLBS经常与Azure Kubernetes一起使用，这是一种由微软开发的开源容器编排技术，提供基于工作流的自动服务扩展。</p><h2 id="00ed" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="8f1a" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">从最终用户的角度来看，性能始终如一。</li><li id="8cbe" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">可以从失败的服务中快速恢复。</li><li id="1674" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">高度可扩展，支持更多服务。</li><li id="d9c2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">非常适合并发。</li></ul><h2 id="9dda" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="a6a2" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">基于负载均衡算法的不一致性能。</li><li id="899f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">管理服务需要大量资源。</li></ul><h2 id="1c48" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">用例</strong></h2><p id="5480" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">RLBS非常适合全天工作负载不一致但必须保持低延迟的前端系统，如网飞或亚马逊Prime等娱乐web应用。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="36d8" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">5.分片服务</h1><p id="7df4" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">基于副本的设计的一个替代方案是创建一个服务选择，每个服务只完成特定类型的请求。这被称为“分片”,因为您将请求流分成了多个不相等的部分。例如，您可能有一个接受所有缓存请求的shard服务和一个只处理高优先级请求的shard服务。负载均衡器在收到每个请求时对其进行评估，并将其分配给适当的碎片来完成。</p><p id="0b6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分片服务通常用于构建有状态服务，因为状态的大小对于单个无状态容器来说通常太大了。分片允许您缩放单个分片以满足状态的大小。</p><p id="a597" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分片服务还允许您更快地处理高优先级请求。专用于高优先级请求的碎片总是可以在这些请求到来的那一刻处理它们，而不是将它们放在队列中。</p><h2 id="dfb9" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">优势</strong></h2><ul class=""><li id="f57c" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">允许您为常见请求缩放碎片。</li><li id="b4c0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">容易区分请求的优先级。</li><li id="fd9d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">由于自然排序，调试简单。</li></ul><h2 id="409e" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">劣势</strong></h2><ul class=""><li id="a978" class="lu lv it la b lb nh le ni lh ny ll nz lp oa lt lz ma mb mc bi translated">维护许多碎片会耗费大量资源。</li><li id="6cdb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果不成比例地使用碎片，会导致性能下降。</li></ul><h2 id="400d" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated"><strong class="ak">用例</strong></h2><p id="0efb" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">当您的系统接收到可预测的请求类型不平衡时，分片服务是最好的，但是有些请求有优先级。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e097" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">接下来学什么</h1><p id="5023" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">分布式系统设计模式是任何成功的后端系统的重要组成部分。然而，这些只是专业软件工程师使用的一些模式。</p><p id="378e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来您需要学习的一些模式是:</p><ul class=""><li id="3a5f" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">边车模式</li><li id="54bb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">预写日志</li><li id="f05f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">裂脑模式</li><li id="55a2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">暗示切换</li><li id="ebad" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">读取修复</li></ul></div></div>    
</body>
</html>