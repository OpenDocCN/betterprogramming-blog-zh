<html>
<head>
<title>5 Node.js Tricks To Make JavaScript Development Fascinating</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使JavaScript开发引人入胜的5个Node.js技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-node-js-tricks-to-make-javascript-development-fascinating-149ac8e101bd?source=collection_archive---------9-----------------------#2021-06-15">https://betterprogramming.pub/5-node-js-tricks-to-make-javascript-development-fascinating-149ac8e101bd?source=collection_archive---------9-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让发展变得有趣，让你的生活更有成效</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c5f429bffecbf473970c1239463b7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJsBlEwBSAHpEdAEV3Dn3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="bfce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>是开发应用程序最流行的平台之一，因为它具有极快的处理I/O操作的能力。但是它受欢迎还有很多其他的原因。</p><p id="f908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍一些有用的技巧，您现在就可以在Node.js <em class="lv">中使用这些技巧来增强您的开发体验，直到您着迷为止。由于JavaScript语言的灵活性，这些技巧中的大部分都是可行的。事不宜迟，我们开始吧！</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2312" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.在控制台中检查代码(增强)</h1><p id="11fd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我想我们都经历过这种情况——在开发过程中，在我们的所有功能中调用<code class="fe na nb nc nd b">console.log</code>。调试代码可能会变得非常枯燥，因为我们需要的大多数信息在默认情况下并没有真正打印在控制台中。</p><p id="0271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，想象下面的这个<code class="fe na nb nc nd b">Page</code>类，它有一些关于上一页、当前页、导航到的页面的历史等的状态。导航后:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图在导航后记录我们的<code class="fe na nb nc nd b">Page</code>实例，并想检查我们的实例是否行为正确，我们得到如下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，这很有用！不是。幸运的是，Node.js团队提供了一个方便的特性(以及您将在本文中找到的其他特性),我们可以立即在代码中使用它来改进我们的输出。</p><p id="f82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你所要做的就是将下面一行作为<em class="lv">方法</em>附加到一个对象上，并返回一个将被打印到控制台的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将它附加到我们的<code class="fe na nb nc nd b">Page</code>类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们将<code class="fe na nb nc nd b">Page</code>登录到控制台时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以将快照结果视为输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c12e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.纤维化</h1><p id="dbfa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">除了我们之前的技巧之外，还有一个巧妙的技巧，我们可以定制对象的字符串化。</p><p id="b600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，和以前一样，当被<code class="fe na nb nc nd b">toString()</code>调用时，我们的<code class="fe na nb nc nd b">Page</code>类的默认字符串化输出对我们来说不是很有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很重要的原因是，当我们将对象指定为属性时，也会用到<code class="fe na nb nc nd b">toString()</code>的返回值，因为默认情况下会调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以覆盖默认的<code class="fe na nb nc nd b">toString()</code>方法，并提供一种更合适的方法来序列化成一个键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要缓存和恢复(或者更传统的术语，“T1”)我们的应用程序以前的状态，以便为用户提供更好的用户体验，这可能会很有用。例如，如果输出被缓存到本地存储，用户退出并在7个小时后返回，我们可以通过获取最后一次缓存的状态并相应地初始化它，使我们的应用程序自动恢复:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="77fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">Page</code>构造函数可以把它作为一个参数，并相应地初始化它的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6141" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.发音</h1><p id="881c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">与前面的技巧类似，当我们在<code class="fe na nb nc nd b">Page</code>类上调用<code class="fe na nb nc nd b">JSON.stringify</code>时，也可以定制输出。默认情况下，我们在使用时会得到以下信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们回到了起点，我们一开始就直接登录了<code class="fe na nb nc nd b">Page</code>。</p><p id="b91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们覆盖默认的<code class="fe na nb nc nd b">toString()</code>方法以便它可以被转换成我们之前想要的字符串时，我们不得不调用<code class="fe na nb nc nd b">page.snapshot</code>来字符串化我们想要的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="df88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上可以让快照成为在其上调用<code class="fe na nb nc nd b">JSON.stringify</code>的输出(这更好，因为它更符合在使用API时用于序列化数据的<code class="fe na nb nc nd b">JSON.stringify</code>和<code class="fe na nb nc nd b">JSON.parse</code>的本质)。</p><p id="423f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您所要做的就是像这样定义一个定制的<code class="fe na nb nc nd b">toJSON</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们将<code class="fe na nb nc nd b">Page</code>传递给<code class="fe na nb nc nd b">JSON.stringify</code>时，它会给我们快照:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3583" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.以正确的方式清空终端</h1><p id="5f16" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可能对<code class="fe na nb nc nd b">console.clear</code>很熟悉，它看似清空了控制台。但是当你向上滚动时，前面的输出实际上还在。</p><p id="6da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清除所有数据并重新开始的正确方法是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这对我来说是一个常见的需求，所以在VSCode上将它设置为用户代码片段，以便在我键入<code class="fe na nb nc nd b">clear</code>时自动生成它(它可以是另一个类似<code class="fe na nb nc nd b">cls</code>的关键字，但我选择了<code class="fe na nb nc nd b">clear</code>)是非常有用的。</p><p id="dfe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将它放入您的代码片段中，请按Ctrl+P，选择“首选项:配置用户代码片段”，并选择<code class="fe na nb nc nd b">typescript.json</code>(或<code class="fe na nb nc nd b">javascript.json</code>，两者都选，或者甚至<code class="fe na nb nc nd b">typescriptreact.json</code>也为<code class="fe na nb nc nd b">.tsx</code>文件启用)并将它放入JSON对象中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="eb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您在一个<code class="fe na nb nc nd b">.ts</code>文件中键入<code class="fe na nb nc nd b">clear</code>并按回车键时，它将生成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9ae6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.前置，后置</h1><p id="b3a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在开发<code class="fe na nb nc nd b">package.json</code>中的应用程序时，我们都使用常用的<code class="fe na nb nc nd b">start</code>和<code class="fe na nb nc nd b">build</code>命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以定义另一个脚本在主脚本执行完之前和/或执行完之后运行<em class="lv">。</em></p><p id="82c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，要在用户对您的repo运行<code class="fe na nb nc nd b">npm install</code>之后运行一个文件，您所要做的就是在脚本名称前添加另一个带有前缀<code class="fe na nb nc nd b">post</code>的脚本命令。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fbeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-cli/scripts/postinstall.js" rel="noopener ugc nofollow" target="_blank">这个要点</a>中，Gatsby在他们的repo上运行<code class="fe na nb nc nd b">npm install</code>后自动打印一条欢迎消息给用户。</p><p id="5e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个前缀可以用于任何脚本的<em class="lv">，并且它仍然会在主脚本之前运行带有<code class="fe na nb nc nd b">pre</code>前缀的匹配脚本，在主脚本之后运行带有<code class="fe na nb nc nd b">post</code>前缀的匹配脚本，因此您可以得到类似于:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文档中阅读更多关于npm脚本技巧<a class="ae ky" href="https://docs.npmjs.com/cli/v7/using-npm/scripts#pre--post-scripts" rel="noopener ugc nofollow" target="_blank">的信息。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5547" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="0d58" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本文到此结束。我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>