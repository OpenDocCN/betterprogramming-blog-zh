<html>
<head>
<title>Integration Tests for Kafka Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对Kafka消费者的集成测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/integration-test-for-kafka-consumer-be76528b843a?source=collection_archive---------1-----------------------#2020-11-24">https://betterprogramming.pub/integration-test-for-kafka-consumer-be76528b843a?source=collection_archive---------1-----------------------#2020-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用<code class="fe ki kj kk kl b">embeddedKafka</code>和<code class="fe ki kj kk kl b">JUnit5</code></h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/52a1722f4405df006763ccb42e41d70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nt8BO--GunH1Qei8"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">absolute vision</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="ff21" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">介绍</h1><p id="0969" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">最近，我写了一篇关于如何用<a class="ae lc" href="https://kafka.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和<a class="ae lc" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>构建事件驱动应用的综合<a class="ae lc" href="https://medium.com/better-programming/a-comprehensive-guide-to-build-an-event-driven-application-with-kotlin-kafka-and-dynamodb-a8d9bfb19e42" rel="noopener">教程</a>。本教程涵盖了构建公开2个端点的工作应用程序的端到端过程:</p><ul class=""><li id="4c97" class="my mz it me b mf na mi nb ml nc mp nd mt ne mx nf ng nh ni bi translated">1 x <code class="fe ki kj kk kl b">POST</code>端点接收一个创建新用户的请求</li><li id="0c9c" class="my mz it me b mf nj mi nk ml nl mp nm mt nn mx nf ng nh ni bi translated">1 x <code class="fe ki kj kk kl b">GET</code>端点返回一条用户信息</li></ul><p id="b318" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><code class="fe ki kj kk kl b">POST</code>端点发布一条消息，该消息包含从客户端到Kafka主题的用户创建请求。有一个Kafka监听器管道订阅这个主题，使用消息，最后在DynamoDB表中持久化新的用户信息。查看教程了解更多信息。</p><p id="588b" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">在本教程中，我们将看看如何为我们的<code class="fe ki kj kk kl b">POST</code>路线编写一个集成测试，特别是在Kafka Producer组件上。我们将使用<code class="fe ki kj kk kl b">embeddedKafka</code>和<code class="fe ki kj kk kl b">JUnit5</code>。</p><p id="48a0" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">TLDR — Github回购<a class="ae lc" href="https://github.com/billydh/kotlin-kafka-dynamo-demo" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="e7f1" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">请注意<code class="fe ki kj kk kl b">build.gradle.kts</code>中的依赖项和Gradle包装版本已根据此<a class="ae lc" href="https://github.com/billydh/kotlin-kafka-dynamo-demo/pull/2" rel="noopener ugc nofollow" target="_blank">拉取请求</a>进行了升级。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="6307" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">先决条件</h1><p id="8b81" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">为了能够跟进，请将这个Github <a class="ae lc" href="https://github.com/billydh/kotlin-kafka-dynamo-demo" rel="noopener ugc nofollow" target="_blank"> repo </a>克隆到您的本地机器上。虽然不是强制性的，但是强烈建议您遵循关于使用Kafka和DynamoDB构建应用程序的教程，这也是我们将要编写集成测试的目的。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="113d" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">集成测试依赖项</h1><p id="8788" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">我们需要向<code class="fe ki kj kk kl b">build.gradle.kts</code>添加以下库来支持我们的Kafka集成测试:<code class="fe ki kj kk kl b">org.springframework.kafka:spring-kafka-test</code>。这个库提供了<code class="fe ki kj kk kl b">EmbeddedKafka</code>，这是一个内存中的卡夫卡，我们将在集成测试中使用它。</p><p id="aa4a" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">我们需要的另一个测试依赖项是<code class="fe ki kj kk kl b">org.springframework.kafka:spring-kafka</code>，它提供了<code class="fe ki kj kk kl b">KafkaTestUtils</code>类。我们将使用这个类在测试类中构造我们的Kafka producer属性。</p><p id="0ee6" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">我们还需要<code class="fe ki kj kk kl b">com.nhaarman.mockitokotlin2:mockito-kotlin</code>库来帮助模拟方法。这几乎是Mockito的Kotlin实现。</p><p id="5572" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">JUnit5依赖项已经被这个库覆盖:<code class="fe ki kj kk kl b">org.springframework.boot:spring-boot-starter-test</code>，它已经在我们的<code class="fe ki kj kk kl b">build.gradle.kts</code>文件中。</p><p id="cef3" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">我们的构建<code class="fe ki kj kk kl b">gradle</code>文件的依赖部分如下所示。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">build.gradle.kts —带有Kafka测试依赖项</p></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="75a2" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">卡夫卡听众测验</h1><p id="de66" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">让我们继续在<code class="fe ki kj kk kl b">test</code>目录中创建一个新文件来包含我们的集成测试。命名为<code class="fe ki kj kk kl b">KafkaListenerTest.kt</code>。</p><p id="240b" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">旁注:如果您在IntelliJ上开发，您可以这样做来在正确的位置生成测试类。将光标放在类名上，右键单击，并选择Show Context Actions，或者按键盘上的快捷键。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/d131909ab7f5b6ea17a3febd6ceb018a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swa36Pnmi5qCsjYIEVTNog.png"/></div></div></figure><p id="36be" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">一旦你完成了这些，你会看到<code class="fe ki kj kk kl b">KafkaListenerTest</code>类被创建如下。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/5d846eb712f31db1f6001057fb1c60a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afgu0qGcUcbDgVshqKX6OA.png"/></div></div></figure><h2 id="0b72" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">写出基本框架</h2><p id="5be7" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">我们将编写一个基于Spring Boot的测试，因为我们的Kafka监听器是一个Spring组件。我们最初的测试类如下所示。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">KafkaListenerTest.kt —初始测试类结构</p></figure><p id="5774" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">让我们简单地看一下这些注释的用途。</p><p id="7546" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><code class="fe ki kj kk kl b">@DirtiesContext</code>用于告诉Spring作为测试的一部分创建的应用程序上下文是脏的，应该在测试完成后清除。我们使用这个是因为如果我们有多个依赖于它的测试类，<code class="fe ki kj kk kl b">EmbeddedKafka</code>可能是“脏的”。</p><p id="3232" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><code class="fe ki kj kk kl b">@EmbeddedKafka</code>用于在基于Spring的测试中提供一个内存中的Kafka实例。它还提供了一个<code class="fe ki kj kk kl b">EmbeddedKafkaBroker</code> bean的实例，我们可以在测试中注入和使用它。</p><p id="6d03" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><code class="fe ki kj kk kl b">@SpringBootTest</code>用于运行基于Spring Boot的测试。这意味着Spring将管理beans的生命周期、依赖注入等等。</p><h2 id="d312" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">模仿处理程序bean</h2><p id="6ae2" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">因为我们只对测试Kafka消费者部分感兴趣，所以我们将使用另一个用于测试的Spring注释来模拟<code class="fe ki kj kk kl b">CreateUserRequestHandler</code>bean:<code class="fe ki kj kk kl b">@MockBean</code>。</p><p id="5118" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">这个注释用一个mock替换了应用程序上下文中相同类型的bean。这意味着我们可以很容易地控制测试的行为。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="3e74" class="nv ll it kl b gy ol om l on oo">@MockBean<br/>private lateinit var mockCreateUserRequestHandler: CreateUserRequestHandler</span></pre><h2 id="f000" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">为测试创建应用程序属性文件</h2><p id="4e77" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">正如主Spring Boot应用程序加载并使用在<code class="fe ki kj kk kl b">application.yml</code>中定义的配置一样，我们的Spring Boot测试类也做同样的事情。不同之处在于，测试类将在测试文件夹中的resources文件夹中查找文件，而不是在主文件夹中。我们需要为我们的测试类提供这个。</p><p id="2225" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">现在，让我们继续将<code class="fe ki kj kk kl b">application.yml</code>中的内容复制粘贴到主文件夹中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">application.yml —用于测试类</p></figure><h2 id="fd2a" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">准备一个卡夫卡制作人</h2><p id="83bc" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">因为我们正在测试我们的Kafka消费者，所以我们需要一个Kafka生产者将消息发布到同一个主题，这样我们的消费者将从该主题中做出反应并消费它。这个Kafka生产者依赖于自动连线的<code class="fe ki kj kk kl b">EmbeddedKafkaBroker</code>实例，因为它需要代理地址。让我们把它定义为一个后期初始化的变量。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="b794" class="nv ll it kl b gy ol om l on oo">@Autowired<br/>private lateinit var embeddedKafkaBroker: EmbeddedKafkaBroker</span><span id="b252" class="nv ll it kl b gy op om l on oo">private lateinit var producer: ReactiveKafkaProducerTemplate&lt;String, CreateUserRequest&gt;</span></pre><p id="8699" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">此外，我们希望Kafka制作者使用正确类型的连续剧，以确保我们的Kafka消费者能够将信息去序列化。为此，我们可以使用与在<code class="fe ki kj kk kl b">KafkaConfigProperties</code> bean中定义的值相同的值。让我们将它自动连接到测试类。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="6405" class="nv ll it kl b gy ol om l on oo">@Autowired<br/>private lateinit var kafkaConfigProperties: KafkaConfigProperties</span></pre><p id="a696" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">最后，我们需要在所有测试用例运行之前初始化这个Kafka生成器。为此，我们可以在test类的方法上使用JUnit5的<code class="fe ki kj kk kl b">@BeforeAll</code>注释。<code class="fe ki kj kk kl b">@BeforeAll</code>所做的是，它指定带注释的方法将在测试类中的所有测试用例之前运行。该方法将只执行一次。</p><p id="93fe" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">注意:测试类需要用<code class="fe ki kj kk kl b">@TestInstance(TestInstance.Lifecycle.<em class="oq">PER_CLASS</em>)</code>注释，这样<code class="fe ki kj kk kl b">@BeforeAll</code>注释的方法才能工作，否则你会得到这样的异常。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi or"><img src="../Images/d0b8bbe9be8d40f4a6f8cd5bf3485bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOGDPvF5yRVa_JuWOdvrcw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">JUnitException</p></figure><p id="e3bd" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">这是我们用<code class="fe ki kj kk kl b">@BeforeAll</code>注释的<code class="fe ki kj kk kl b">setup()</code>方法。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="1510" class="nv ll it kl b gy ol om l on oo">@BeforeAll<br/>fun setup() {<br/>    val producerProps = KafkaTestUtils.producerProps(embeddedKafkaBroker.<em class="oq">brokersAsString</em>)<br/>        .<em class="oq">apply </em><strong class="kl iu">{<br/>            </strong>this[ProducerConfig.<em class="oq">KEY_SERIALIZER_CLASS_CONFIG</em>] = kafkaConfigProperties.serializer<br/>            this[ProducerConfig.<em class="oq">VALUE_SERIALIZER_CLASS_CONFIG</em>] = kafkaConfigProperties.serializer<br/>            this[AbstractKafkaSchemaSerDeConfig.<em class="oq">SCHEMA_REGISTRY_URL_CONFIG</em>] = kafkaConfigProperties.schemaRegistryUrl<br/>        <strong class="kl iu">}<br/><br/>    </strong>producer = ReactiveKafkaProducerTemplate(SenderOptions.create(producerProps))<br/>}</span></pre><p id="10da" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">太好了！现在，我们的Kafka生产者已经准备好向<code class="fe ki kj kk kl b">KafkaListener</code> bean正在收听的主题发送消息。</p><h2 id="8f72" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">使用动态Kafka代理地址</h2><p id="b467" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">请注意，<code class="fe ki kj kk kl b">KafkaListener</code>被配置为在由<code class="fe ki kj kk kl b">KafkaConfigProperties</code>的<code class="fe ki kj kk kl b">broker</code>属性指定的地址与Kafka经纪人对话。当前值被设置为<code class="fe ki kj kk kl b">application.yml</code>文件中的<code class="fe ki kj kk kl b">localhost:9092</code>。</p><p id="3841" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">另一方面，<code class="fe ki kj kk kl b">EmbeddedKafka</code>每次都会在一个随机的端口上运行，所以我们无法预先确定代理的地址。为了解决这种情况，我们将修改测试文件夹中的<code class="fe ki kj kk kl b">application.yml</code>文件中的<code class="fe ki kj kk kl b">application.kafka.broker</code>属性。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="0c20" class="nv ll it kl b gy ol om l on oo">application:<br/>  ...<br/>  ...</span><span id="d4aa" class="nv ll it kl b gy op om l on oo">  kafka:<br/>    broker: "${spring.embedded.kafka.brokers:#{localhost:9092}}"</span></pre><p id="f386" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">上面的表达式被称为SpEL (Spring Expression Language)，它在这里所做的是，如果存在的话，它将获得<code class="fe ki kj kk kl b">spring.embedded.kafka.brokers</code>的值，否则默认为<code class="fe ki kj kk kl b">localhost:9092</code>。<code class="fe ki kj kk kl b">EmbeddedKafka</code>是设置<code class="fe ki kj kk kl b">spring.embedded.kafka.brokers</code>属性的那个。这样，我们的<code class="fe ki kj kk kl b">KafkaListener</code>将能够引用正确的经纪人。</p><h2 id="bb54" class="nv ll it bd lm nw nx dn lq ny nz dp lu ml oa ob lw mp oc od ly mt oe of ma og bi translated">编写测试用例</h2><p id="7a3f" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">我们已经准备好编写测试用例，看看我们的Kafka消费者是否做了它应该做的事情。测试案例很简单:</p><ul class=""><li id="3cc9" class="my mz it me b mf na mi nb ml nc mp nd mt ne mx nf ng nh ni bi translated">给定一个<code class="fe ki kj kk kl b">CreateUserRequest</code>消息发布到创建用户请求主题，</li><li id="cadf" class="my mz it me b mf nj mi nk ml nl mp nm mt nn mx nf ng nh ni bi translated">KafkaListener bean应该使用该消息，并且</li><li id="fcfb" class="my mz it me b mf nj mi nk ml nl mp nm mt nn mx nf ng nh ni bi translated">然后调用<code class="fe ki kj kk kl b">CreateUserRequestHandler</code>类的<code class="fe ki kj kk kl b">handleCreateUserRequest</code>方法。</li></ul><p id="bd72" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">让我们首先编写将消息发布到主题的测试用例部分。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="a36d" class="nv ll it kl b gy ol om l on oo">@Test<br/>fun `should consume CreateUserRequest message and calls the handler method`() {<br/>    val createUserRequest = CreateUserRequest("email@some.com", "Joe", "Jones")<br/><br/>    val producerRecord = ProducerRecord(<br/>        kafkaConfigProperties.createUserRequestTopic,<br/>        UUID.randomUUID().toString(),<br/>        createUserRequest<br/>    )<br/><br/>    StepVerifier.create(producer.send(producerRecord))<br/>        .expectNextMatches <strong class="kl iu">{ it </strong>is SenderResult <strong class="kl iu">}<br/>        </strong>.verifyComplete()<br/>}</span></pre><p id="cab6" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">在这里，我们用包含要创建的用户详细信息的<code class="fe ki kj kk kl b">CreateUserRequest</code>消息创建了生产者记录，并且我们已经将消息发布到由<code class="fe ki kj kk kl b">kafkaConfigProperties.createUserRequestTopic</code>定义的主题，并为消息键使用了随机UUID。</p><p id="9eea" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">我们用<code class="fe ki kj kk kl b">StepVerifier</code>包装<code class="fe ki kj kk kl b">producer.send(producerRecord)</code>调用，因为它使我们能够在订阅时验证异步发布者及其预期事件。如果我们看一下<code class="fe ki kj kk kl b">send()</code>的方法签名，它的返回值类型是<code class="fe ki kj kk kl b">Mono&lt;SenderResult&lt;Void&gt;&gt;</code>。</p><p id="955f" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><code class="fe ki kj kk kl b">Mono</code>是由Project Reactor提供的异步发布者类型。由此，我们知道预期事件的类型是<code class="fe ki kj kk kl b">SenderResult</code>。一旦经过验证，我们就知道消息已经成功发布。这基本上就是我们对<code class="fe ki kj kk kl b">StepVerifier</code>号所做的事情。</p><p id="acf3" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">既然消息已经发布，我们期望<code class="fe ki kj kk kl b">KafkaListener</code> bean会使用它。但是我们如何确定这一点呢？通过验证是否与<code class="fe ki kj kk kl b">mockCreateUserRequestHandler</code>有任何交互，特别是调用它的<code class="fe ki kj kk kl b">handleCreateUserRequest</code>方法，将发布的<code class="fe ki kj kk kl b">CreateUserRequest</code>作为它的输入，正好一次。</p><p id="8a30" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">在编写验证之前，我们还需要模拟<code class="fe ki kj kk kl b">handleCreateUserRequest</code>方法返回<code class="fe ki kj kk kl b">Mono&lt;Unit&gt;</code>。如果我们不这样做，当代码到达调用<code class="fe ki kj kk kl b">handleCreateUserRequest()</code>的部分时，我们将会以空指针异常结束。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="1cf6" class="nv ll it kl b gy ol om l on oo"><em class="oq">given</em>(mockCreateUserRequestHandler.handleCreateUserRequest(createUserRequest)).willReturn(Mono.just(Unit))<br/><br/><em class="oq">verify</em>(mockCreateUserRequestHandler, <em class="oq">timeout</em>(5000L).times(1))<br/>    .handleCreateUserRequest(createUserRequest)</span></pre><p id="1f5d" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">这是我们整合了上述所有步骤后测试用例的样子。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">KafkaListenerTest.kt</p></figure><p id="a822" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">现在，继续运行测试用例。</p><p id="f326" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">正在执行…</p><p id="8072" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">等待中…</p><p id="4e9a" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">哎哟！我们有一个例外！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi os"><img src="../Images/07975e960d0795d97173d27f26daf373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8cqX9IteiS_IC4npaukdA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">连接异常</p></figure><p id="c960" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">让我们把注意力放在这条线上。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="2ddb" class="nv ll it kl b gy ol om l on oo">Failed to send HTTP request to endpoint: <a class="ae lc" href="http://localhost:8081/subjects/create-user-request-key/versions" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/subjects/create-user-request-key/versions</a></span></pre><p id="d444" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">这看起来像我们的模式注册URL。这里的问题是，我们没有运行真正的模式注册中心，我们的Kafka生产者在发送消息时试图连接它。</p><p id="f707" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">我们如何解决这个问题？通过使用Kafka汇合库的<code class="fe ki kj kk kl b">MockSchemaRegistryClient</code>。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="fdfc" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">模拟Kafka Avro序列化器和反序列化器</h1><p id="1583" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">我们必须在测试文件夹中定义两个新的类。一个类将扩展<code class="fe ki kj kk kl b">KafkaAvroSerializer</code>，另一个将扩展<code class="fe ki kj kk kl b">KafkaAvroDeserializer</code>。两者都将使用<code class="fe ki kj kk kl b">MockSchemaRegistryClient</code>作为它们的模式注册客户端。</p><p id="b560" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated"><strong class="me iu">重要提示</strong>:要创建的两个mocks必须使用同一个<code class="fe ki kj kk kl b">MockSchemaRegistryClient</code>实例，否则当Kafka消费者试图从主题中去序列化一个消息时，它会抛出这样的去序列化错误。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ot"><img src="../Images/5025b1e67d007bf3a6ab181157385f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwMTEatqceC7kI0eZtnrEw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">序列化异常</p></figure><p id="1dbe" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">所以我们需要一个由模拟序列化器和反序列化器共享的<code class="fe ki kj kk kl b">MockSchemaRegistryClient</code>实例的单例。这是我们将在测试文件夹中拥有的三个新文件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">MockSchemaRegistry.kt</p></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">MockKafkaAvroSerializer.kt</p></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">MockKafkaAvroDeserializer.kt</p></figure><p id="f8da" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">此外，我们还需要更新测试文件夹中<code class="fe ki kj kk kl b">application.yml</code>文件中Kafka serialiser和deserialiser的值。</p><pre class="kn ko kp kq gt oh kl oi oj aw ok bi"><span id="3f32" class="nv ll it kl b gy ol om l on oo">application:<br/>  ...<br/>  ...<br/>  kafka:<br/>    broker: "${spring.embedded.kafka.brokers:#{localhost:9092}}"<br/>    serializer: io.codebrews.kotlinkafkadynamodemo.MockKafkaAvroSerializer<br/>    deserializer: io.codebrews.kotlinkafkadynamodemo.MockKafkaAvroDeserializer</span></pre><p id="d04d" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">现在，如果我们再次运行测试，它会通过。快乐的日子！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ou"><img src="../Images/243a4e8f0000ed25fb0683c583e3f23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlSO0ObdLBSUmrd3L9DV0w.png"/></div></div></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="ce7a" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">结论</h1><p id="92b4" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">我们已经学习了如何使用<code class="fe ki kj kk kl b">SpringBootTest</code>和<code class="fe ki kj kk kl b">EmbeddedKafka</code>为Kafka消费者建立一个集成测试。<code class="fe ki kj kk kl b">EmbeddedKafka</code>提供了一个内存中的卡夫卡实例，非常方便。另一方面，<code class="fe ki kj kk kl b">SpringBootTest</code>管理测试环境中所有Spring beans的生命周期，因此我们可以专注于编写测试用例。</p><p id="4075" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">如果您想查看为Kafka consumer编写集成测试而添加的内容，这里有到拉请求的<a class="ae lc" href="https://github.com/billydh/kotlin-kafka-dynamo-demo/pull/3" rel="noopener ugc nofollow" target="_blank">链接。</a></p><p id="a75e" class="pw-post-body-paragraph mc md it me b mf na ju mh mi nb jx mk ml no mn mo mp np mr ms mt nq mv mw mx im bi translated">在不久的将来，我将为Kafka producer写另一篇关于集成测试的文章。敬请关注。</p></div></div>    
</body>
</html>