<html>
<head>
<title>Battle of the iOS Architecture Patterns: A Look at Model-View-ViewModel (MVVM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS架构模式之战:查看模型-视图-视图模型(MVVM)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e?source=collection_archive---------2-----------------------#2021-03-26">https://betterprogramming.pub/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e?source=collection_archive---------2-----------------------#2021-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9167" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用流行的架构模式构建一个真实世界的足球运动员iOS游戏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3a844febbe644bcb959aeecb1984f84e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csrXZRf2CNmM3sWH8I8MLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">建筑系列—模型视图视图模型(MVVM)</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="8f70" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">动机</h1><p id="a457" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在开始开发一个iOS应用之前，我们必须考虑项目的结构。我们需要考虑如何将这些代码添加到一起，以便它们在以后有意义——当我们回来重新访问应用程序的一部分时——以及如何与其他开发人员形成已知的“语言”。</p><p id="7380" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这是这个系列的第二篇文章，全部是关于MVVM的。(第一篇文章关于MVC的链接出现在最后的有用链接列表中。)</p><p id="aa6a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在本文中，我们将检查构建时间和每个模式的优缺点，但最重要的是，我们将看到实际的实现和源代码。</p><p id="cb4d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果您只想看代码，可以跳过这篇文章。该代码可以在<a class="ae mv" href="https://github.com/radude89/footballgather-ios" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上开源获得。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="4951" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">为什么你的iOS应用需要一个架构模式？</h1><p id="8381" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">最需要考虑的是要有一个可维护的app。你知道视图在那里，这个视图控制器应该做X而不是y。更重要的是，其他人也知道。</p><p id="9802" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">以下是选择一个好的架构模式的一些优势:</p><ul class=""><li id="4b5f" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">更易于维护</li><li id="a9a2" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更容易测试业务逻辑</li><li id="be33" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">与其他队友发展共同语言</li><li id="370a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">分离实体的职责</li><li id="4ae9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更少的错误</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="36c1" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">定义需求</h1><p id="282a" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">给定一个有六七个屏幕的iOS应用程序，我们将使用iOS世界最流行的架构模式来开发它:MVC、MVVM、MVP、VIPER、VIP和Coordinators。</p><p id="0ff0" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">该演示应用程序名为Football Gather，是朋友们跟踪业余足球比赛比分的一种简单方式。</p><h2 id="ce6f" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">主要特征</h2><p id="cd5c" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">能够:</p><ul class=""><li id="3212" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">在应用程序中添加玩家</li><li id="7dad" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">给运动员分配队伍</li><li id="eca1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">编辑玩家</li><li id="f29e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">为比赛设置倒计时</li></ul><h2 id="9730" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">屏幕模型</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b97818c3cb481cc6d4dbb47fa8d7b77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPn1fBii-lnU4ZfbgjwszQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS应用“Football Gather”的屏幕模型</p></figure><h2 id="928e" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">后端</h2><p id="5a1a" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">该应用由在<a class="ae mv" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank"> Vapor web框架</a>中开发的web应用提供支持。你可以查看我的<a class="ae mv" href="https://www.radude89.com/blog/vapor.html" rel="noopener ugc nofollow" target="_blank"> Vapor 3初始篇</a>和<a class="ae mv" href="https://www.radude89.com/blog/migrate-to-vapor4.html" rel="noopener ugc nofollow" target="_blank">关于迁移到Vapor 4 </a>的文章中的app。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="5c2d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">什么是MVVM？</h1><p id="fa03" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">MVVM代表模型-视图-视图模型(Model-View-ViewModel)，这是一种与RxSwift一起自然使用的架构模式，在这里，您可以通过视图模型将UI元素绑定到模型类。</p><p id="a160" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这是一个较新的模式，由John Gossman在2005年提出，其作用是从视图控制器中提取模型。视图控制器和模型之间的交互是通过一个新的层完成的，称为视图模型。</p><h2 id="8e1f" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">模型</h2><ul class=""><li id="6f32" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">该模型与MVC中的模型是同一层，用于封装数据和业务逻辑。</li></ul><p id="dc2e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">通讯</strong></p><ul class=""><li id="d3fa" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">当视图层中发生一些事情时，例如当用户发起一个动作时，它通过视图模型传递给模型。</li><li id="6a9c" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">当模型发生变化时，例如，当新数据变得可用，我们需要更新UI时，模型会通知视图模型。</li></ul><h2 id="8e23" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">视角</h2><ul class=""><li id="2dc5" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">视图和视图控制器是可视元素所在的层。</li><li id="7b7a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">视图包含UI元素，比如按钮、标签和表格视图，视图控制器是视图的所有者。</li><li id="76c1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">这一层与MVC中的相同，但是视图控制器现在是它的一部分，并将被更改为引用视图模型。</li></ul><p id="affc" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">通讯</strong></p><ul class=""><li id="df1e" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">视图不能直接与模型交流。一切都是通过视图模型完成的。</li></ul><h2 id="083c" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">视图模型</h2><ul class=""><li id="79f4" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">位于视图/视图控制器和模型之间的新层</li><li id="0ef8" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">通过绑定，当模型中发生变化时，更新UI元素</li><li id="a929" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">是视图的规范表示</li><li id="e53f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">为视图提供接口</li></ul><p id="5ca4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><strong class="lw ir">通信</strong></p><ul class=""><li id="9a94" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">可以与模型和视图/视图控制器这两个层通信</li><li id="e209" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">通过绑定，触发对模型层数据的更改</li><li id="b0dd" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">当数据改变时，确保那些改变被传递到用户界面，更新视图(再次通过绑定)</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="fa3e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">MVVM的不同风味</h1><p id="77ab" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">应用MVVM的方式取决于您选择实现绑定的方式:</p><ul class=""><li id="c6d9" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">使用第三方，如RxSwift</li><li id="b6b3" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">KVO —键值观察</li><li id="2561" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">用手</li></ul><p id="befa" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在我们的演示应用程序中，我们将探索手动方法。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="4510" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">如何以及何时使用MVVM</h1><p id="6d4d" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">当你看到视图控制器做了很多事情，可能会变得很大，你可以开始寻找不同的模式，如MVVM。</p><h2 id="0556" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">优势</h2><ul class=""><li id="0b94" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">精简视图控制器</li><li id="92e0" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">更容易测试业务逻辑，因为现在有了处理数据的专用层</li><li id="4fad" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">提供了更好的关注点分离</li></ul><h2 id="7cfe" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">不足之处</h2><ul class=""><li id="eb35" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">与MVC中相同。如果应用不正确，并且不注意SRP(单一责任原则)，它可能会变成一个大规模视图模型。</li><li id="ab51" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">对于小项目来说可能太过复杂(例如，在黑客马拉松应用程序/原型中)</li><li id="f407" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">采用第三方会增加应用程序的大小，并会影响性能</li><li id="c0c2" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">使用UIKit开发iOS应用程序感觉不太自然。另一方面，对于用SwiftUI开发的应用程序来说，这非常有意义。</li></ul><p id="38bd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在底部，您可以找到一些链接，告诉您更多关于这种代码架构模式的信息。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="d64d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">将MVVM应用于我们的代码</h1><p id="d929" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">这很简单。我们进入每个视图控制器，并将业务逻辑提取到一个新的层(视图模型)。</p><h2 id="c6b6" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">从业务逻辑中分离出<code class="fe oa ob oc od b">LoginViewController</code></h2><p id="dc66" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">转换:</p><ul class=""><li id="433a" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated"><code class="fe oa ob oc od b">viewModel</code> —处理视图状态和模型更新的新层</li><li id="cc24" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">服务现在是视图模型层的一部分。</li></ul><p id="40a5" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在<code class="fe oa ob oc od b">viewDidLoad</code>方法中，我们调用<code class="fe oa ob oc od b">configureRememberMe()</code>函数。在这里，我们可以观察视图如何向视图模型请求“记住我”<code class="fe oa ob oc od b">UISwitch</code>和用户名的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="99dc" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">对于登录和注册操作，我们告诉视图模型处理服务请求。一旦服务器API调用完成，我们就使用闭包来更新UI。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="912f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">LoginViewModel</code>由以下属性定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5285" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们有从<code class="fe oa ob oc od b">LoginViewController</code>传来的服务(<code class="fe oa ob oc od b">LoginService</code>、<code class="fe oa ob oc od b">StandardNetworkService</code>用于注册用户，存储服务商:<code class="fe oa ob oc od b">UserDefaults</code>和<code class="fe oa ob oc od b">Keychain</code>包装器)。<br/>它们都是通过初始化器注入的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0fa4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果我们想使用自己的模拟服务或存储，这对于单元测试来说很方便。</p><p id="0745" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">公共API简洁明了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c9c1" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">和两个服务器API调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7401" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">正如您所看到的，通过将模型从视图控制器中分离出来，代码看起来更加清晰。现在，视图/视图控制器向视图模型询问它需要什么。</p><p id="4660" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">PlayerListViewController</code>比<code class="fe oa ob oc od b">LoginViewController</code>更大，更难重构，更难提取业务逻辑。</p><p id="fdad" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">首先，我们想留下这个类需要的插座和所有的<code class="fe oa ob oc od b">UIView</code>对象。</p><p id="2b73" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在<code class="fe oa ob oc od b">viewDidLoad</code>中，我们会做视图初始状态的设置和配置，设置视图模型委托，通过视图模型触发播放器加载。</p><p id="9442" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">加载播放器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7c74" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">响应处理类似于<code class="fe oa ob oc od b">LoginViewController</code>中的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9370" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了在表视图的单元格中显示模型属性并对其进行配置，我们要求ViewModel为我们提供原语，然后我们将它们设置为单元格的属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bbbd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">要删除玩家，我们需要执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f8ef" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">确认/详述和添加屏幕的导航通过<code class="fe oa ob oc od b">performSegue</code>完成。我们选择<code class="fe oa ob oc od b">PlayerListViewModel</code>负责创建下一个屏幕的视图模型，并将它们注入<code class="fe oa ob oc od b">prepareForSegue</code>。这不是最好的方法，因为我们违反了SRP原则，但是我们将在Coordinator文章中看到如何解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3c03" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">PlayerListViewModel</code>相当大，包含了很多暴露给视图的属性和方法，它们都是强制的。<br/>为了演示的方便，我们将保持原样，并将所需的重构留给读者作为练习。您可以:</p><ul class=""><li id="2744" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">在多个视图控制器/视图模型中分离<code class="fe oa ob oc od b">PlayerListViewController</code>,全部由父视图控制器或容器视图控制器处理。</li><li id="ad5f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">通过编辑/列表功能、服务组件或玩家选择将<code class="fe oa ob oc od b">PlayerListViewModel</code>分成不同的组件。</li></ul><p id="dfb5" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">视图状态(播放器选择和列表模式)通过工厂<strong class="lw ir"> </strong>模式实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="85e7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">以及列表和选择的具体类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2616" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">服务方法易于阅读:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="2edb" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><code class="fe oa ob oc od b">PlayerAddViewController </code>定义添加玩家界面</h2><p id="8551" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">一旦创建了一个播放器，我们使用委托模式通知播放器添加屏幕并弹出视图控制器。服务调用驻留在视图模型中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2496" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">视图模型实体如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="38ff" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><code class="fe oa ob oc od b">PlayerDetailViewController</code>定义详细信息屏幕</h2><p id="df66" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">视图模型是在<code class="fe oa ob oc od b">PlayerListViewController</code>的方法<code class="fe oa ob oc od b">prepareForSegue</code>中创建和传递的。当导航到<code class="fe oa ob oc od b">PlayerEditViewController</code>时，我们使用相同的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0048" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">显示玩家的详细信息与我们在PlayerList屏幕中所做的类似:视图向视图模型请求属性并设置标签的文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1115" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">当用户在呈现的屏幕中完成编辑一个播放器时，调用<code class="fe oa ob oc od b">didFinishEditing</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f229" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">PlayerDetailViewModel</code>具有以下特性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="c7d0" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><code class="fe oa ob oc od b">PlayerEditViewController</code></h2><p id="ced8" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">从PlayerDetails屏幕触发显示编辑屏幕的顺序。这是你可以编辑玩家资料的地方。</p><p id="e693" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">视图模型从<code class="fe oa ob oc od b">PlayerDetailsViewController</code>传递过来。<br/>按照同样的方法，我们将所有的服务器API交互以及模型处理都转移到了视图模型中。</p><p id="502c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">编辑文本字段基于视图模型的属性进行配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5b20" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">当我们编辑完玩家信息后，我们请求视图模型执行服务器更新，完成后，我们处理成功或失败响应。</p><p id="de55" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果失败，我们通知用户，如果服务器调用成功，我们通知代理并从视图控制器堆栈中弹出这个视图控制器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1212" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">PlayerEditViewModel</code>与其余类似。最重要的方法是玩家更新方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="1a2d" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><code class="fe oa ob oc od b">ConfirmPlayersViewController</code></h2><p id="8e0a" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在到达集合屏幕之前，我们必须确认选中的玩家。该屏幕由<code class="fe oa ob oc od b">ConfirmPlayersViewController</code>定义。</p><p id="3c83" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在<code class="fe oa ob oc od b">viewDidLoad</code>中，我们设置了UI元素，如表格视图，并配置了开始收集按钮:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c5d2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">服务器API调用如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e721" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">以及表视图委托和数据源:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5fa9" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">ConfirmPlayersViewModel</code>包含与所选玩家及其团队相关的<code class="fe oa ob oc od b">playersDictionary</code>,将玩家添加到集合并开始集合所需的服务，在服务器上创建集合后定义的<code class="fe oa ob oc od b">gatherUUID</code>,以及协调多个服务器调用的<code class="fe oa ob oc od b">dispatchGroup</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="43d6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这个类最复杂的地方是启动收集时的服务器API交互:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="cbae" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated"><code class="fe oa ob oc od b">GatherViewController</code></h2><p id="d54e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">最后，我们有<code class="fe oa ob oc od b">GatherViewController</code>，属于来自足球集锦最重要的屏幕。</p><p id="1cad" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们设法清理了属性，留下了<code class="fe oa ob oc od b">IBOutlet</code> s，加上加载视图和视图模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="43bd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在<code class="fe oa ob oc od b">viewDidLoad</code>中，我们设置和配置视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f158" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">计时器相关的功能看起来很简洁:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="435d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">和<code class="fe oa ob oc od b">endGather</code> API的交互:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="61b2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">表格视图的数据源和委托看起来也很棒，简洁明了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="caad" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">其余的方法是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5110" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">清理ViewController带来了视图模型类中的一些缺点。它有很多方法，类也很大(大约200行代码)。</p><p id="0e7a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们决定将计时器交互移到一个新的结构中，名为<code class="fe oa ob oc od b">GatherTimeHandler</code>。在这个结构中，我们公开了从类外部设置的<code class="fe oa ob oc od b">selectedTime</code>，它还有两个变量:计时器和一个状态变量(可以停止、运行或暂停)。</p><p id="7276" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">公共API有stop、reset、toggle timer等方法，还有<code class="fe oa ob oc od b">decrementTime</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2963" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">总的来说，这比我们通过MVC实现应用的第一次迭代要好得多。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="93df" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">测试我们的业务逻辑</h1><p id="0825" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">最重要的部分是视图模型。在这里，我们实现了业务逻辑。</p><p id="bc65" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">测试标题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8cc0" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">测试格式化的倒计时器标签文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a1ed" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">测试操作标题文本，应该是开始、继续或暂停。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0bac" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们遵循相同的暂停和启动方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5f21" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了测试<code class="fe oa ob oc od b">stopTimer</code>功能，我们模拟系统处于运行状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5bb4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">同样适用于<code class="fe oa ob oc od b">resetTimer</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3dfd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe oa ob oc od b">pickerView</code>和<code class="fe oa ob oc od b">tableView</code>的代表很容易测试。下面我们举例说明一些单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="014a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了结束聚集，我们使用模拟端点和模型。我们验证收到的响应是否为<code class="fe oa ob oc od b">true:</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6942" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了检查定时器是否被触发，我们使用了一个<code class="fe oa ob oc od b">MockViewModelDelegate</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="352b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">和单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="900e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">与在MVC架构中测试ViewController相比，在测试ViewModel层时，工作变得更加容易。单元测试更容易编写，更容易理解，也更简单。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="d859" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">关键指标</h1><h2 id="e5fd" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">代码行—视图控制器</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="5989" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">代码行—视图模型</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="408b" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">单元测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="4944" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">构建时间</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="90f0" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><em class="og">测试在iPhone 8模拟器中运行，iOS 14.3，使用Xcode 12.4，并在i9 MacBook Pro 2019上运行。</em></p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="e54f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="2377" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们的应用程序现在已经从MVC转换到了MVVM。我们添加了一个新的层来处理业务逻辑，并将其从视图控制器中分离出来，更好地分离职责。</p><p id="067d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">MVVM是一个很好的模式，它极大地降低了视图控制器的复杂性，使实现变得简单。涵盖业务逻辑的单元测试也更容易编写。</p><p id="aac7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然而，当在你的项目中使用UIKit时，MVVM是不自然的，很难应用。</p><p id="5e03" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">查看关键指标，我们可以记下以下观察结果:</p><ul class=""><li id="093c" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">我们通过<strong class="lw ir"> 607 </strong>行代码大大减少了视图控制器中的代码行数量。</li><li id="db7a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">另一方面，视图模型花了我们<strong class="lw ir">1113</strong>行代码来编写。</li><li id="437c" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">iI总共，我们在我们的应用程序中添加了<strong class="lw ir"> 506 </strong>行代码和<strong class="lw ir">七个</strong>文件。</li><li id="6905" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">对平均单元测试执行时间有轻微的负面影响，增加了5.1秒。</li><li id="5be5" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">应用于Gathers功能的代码覆盖率增加了<strong class="lw ir"> 1.6% </strong>，固化了总计<strong class="lw ir"> 97.3% </strong>，在采用更改和重构应用程序部分时给予了更多信心，而不会打破现有逻辑。</li><li id="9fc6" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">与MVC相比，覆盖业务逻辑的单元测试更容易编写。</li></ul><p id="1701" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">总之，MVVM是一个有趣的练习；我们现在有了一个更干净的应用程序，甚至可以说它更不容易出错。</p><p id="8765" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">谢谢你坚持到最后！我们下面有一些有用的链接。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="bdc7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">有用的链接</h1><ul class=""><li id="046b" class="mw mx iq lw b lx ly ma mb md nx mh ny ml nz mp nb nc nd ne bi translated">iOS应用程序，Football Gather — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a></li><li id="84d4" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">Vapor中的web服务器应用— <a class="ae mv" href="https://github.com/radude89/footballgather-ws" rel="noopener ugc nofollow" target="_blank"> GitHub Repo Link </a></li><li id="c19d" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">Vapor 3后端API<a class="ae mv" href="https://radu-ionut-dan.medium.com/using-vapor-and-fluent-to-create-a-rest-api-5f9a0dcffc7b" rel="noopener">文章链接</a></li><li id="e4f9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">迁移到蒸汽4 <a class="ae mv" href="https://radu-ionut-dan.medium.com/migrating-to-vapor-4-53a821c29203" rel="noopener">文章链接</a></li><li id="6557" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图控制器(MVC)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVC" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/battle-of-the-ios-architecture-patterns-model-view-controller-mvc-442241b447f6">文章链接</a></li><li id="94e1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图ViewModel (MVVM) — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVVM" rel="noopener ugc nofollow" target="_blank"> GitHub回购链接</a>和<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/battle-of-the-ios-architecture-patterns-a-look-at-model-view-viewmodel-mvvm-bdfd07d9395e">文章链接</a></li><li id="3ecc" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">模型视图演示者(MVP) — <a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP" rel="noopener ugc nofollow" target="_blank"> GitHub Repo链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-mvp-f693f6efd23e" rel="noopener">文章链接</a></li><li id="6cb6" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">协调员模式—带协调员的MVP(MVP-C)—<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/MVP-C" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-model-view-presenter-with-coordinators-mvp-c-99edf7ab8c36" rel="noopener">文章链接</a></li><li id="623a" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">查看交互者展示者实体路由器(VIPER)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIPER" rel="noopener ugc nofollow" target="_blank">GitHub Repo链接</a>和<a class="ae mv" href="https://medium.com/geekculture/battle-of-the-ios-architecture-patterns-view-interactor-presenter-entity-router-viper-8f76f1bdc960" rel="noopener">文章链接</a></li><li id="d756" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">查看互动主持人(VIP)——<a class="ae mv" href="https://github.com/radude89/footballgather-ios/tree/master/FootballGather/VIP" rel="noopener ugc nofollow" target="_blank">GitHub回购链接</a>和<a class="ae mv" href="https://radu-ionut-dan.medium.com/battle-of-the-ios-architecture-patterns-view-interactor-presenter-vip-59ebdae86e84" rel="noopener">文章链接</a></li><li id="aebb" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">关于MVVM的书。</li><li id="6336" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://medium.com/better-programming/mvvm-in-ios-from-net-perspective-580eb7f4f129" rel="noopener">iOS中关于MVVM的文章</a></li><li id="0b8d" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://medium.com/flawless-app-stories/how-to-use-a-model-view-viewmodel-architecture-for-ios-46963c67be1b" rel="noopener">文章《如何不与MVVM实现绝交》</a></li><li id="a4e6" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps" rel="noopener ugc nofollow" target="_blank">介绍构建WPF应用的模型/视图/视图模型模式</a></li><li id="b3e1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://www.appcoda.com/mvvm-vs-mvc/" rel="noopener ugc nofollow" target="_blank"> MVVM vs MVC </a></li><li id="880f" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://blog.pusher.com/mvvm-ios/" rel="noopener ugc nofollow" target="_blank">在iOS中使用MVV</a></li><li id="8991" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://medium.com/flawless-app-stories/practical-mvvm-rxswift-a330db6aa693" rel="noopener">实用MVVM + RxSwift </a></li><li id="f5af" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://academy.realm.io/posts/slug-max-alexander-mvvm-rxswift/" rel="noopener ugc nofollow" target="_blank"> MVVM与RxSwift </a></li><li id="b973" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://benoitpasquier.com/integrate-rxswift-in-mvvm/" rel="noopener ugc nofollow" target="_blank">如何将RxSwift集成到您的MVVM架构中</a></li><li id="0316" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://cocoacasts.com/what-are-the-benefits-of-model-view-viewmodel" rel="noopener ugc nofollow" target="_blank">模型-视图-视图模型</a>有什么好处</li><li id="bf0c" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://blogsnook.com/mvvm-pattern-advantages/" rel="noopener ugc nofollow" target="_blank"> MVVM模式的优势——使用MVVM模式的好处</a></li><li id="b0b5" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://docs.microsoft.com/en-us/archive/blogs/johngossman/advantages-and-disadvantages-of-m-v-vm" rel="noopener ugc nofollow" target="_blank">M-V-VM的优缺点</a></li><li id="014e" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated"><a class="ae mv" href="https://medium.com/swift-india/mvvm-1-a-general-discussion-764581a2d5d9" rel="noopener"> MVVM-1:一般性讨论</a></li></ul></div></div>    
</body>
</html>