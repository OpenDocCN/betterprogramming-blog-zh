<html>
<head>
<title>Why JavaScript Developers Should Prefer Axios Over Fetch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么JavaScript开发人员更喜欢Axios而不是Fetch</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-javascript-developers-should-prefer-axios-over-fetch-294b28a96e2c?source=collection_archive---------1-----------------------#2021-02-24">https://betterprogramming.pub/why-javascript-developers-should-prefer-axios-over-fetch-294b28a96e2c?source=collection_archive---------1-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c1d3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">比较</h2><div class=""/><div class=""><h2 id="29c9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">向后兼容、监控上传进度等等</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7524f1f09acd4dff24d48c092b44eeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jZV8QRYZyvN7oX4cGLm0w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/@zante?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Brixiv </a>从<a class="ae lh" href="https://www.pexels.com/photo/field-summer-animal-dog-4459859/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="b344" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的上一篇文章“深入了解JavaScript的Fetch API ”中，我讨论了Fetch API的基础知识。但是值得承认的是,<code class="fe me mf mg mh b">fetch()</code>并不总是一个理想的解决方案，有时有更好的替代方法来发出HTTP请求。这里我来描述一下为什么Axios在开发上比<code class="fe me mf mg mh b">fetch()</code>好。这是我的第36篇中型文章。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="05bc" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">概述和语法</h1><h2 id="8e19" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="0ac1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe me mf mg mh b">Fetch()</code>是获取API中JavaScript窗口对象方法的一部分。它是内置的，所以用户不必安装它。<code class="fe me mf mg mh b">Fetch()</code>允许我们从API异步获取数据，而无需安装任何额外的库。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="79f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面这段代码是一个简单的<code class="fe me mf mg mh b">fetch()</code> get请求。在<code class="fe me mf mg mh b">fetch()</code>方法中，有一个强制参数，即<code class="fe me mf mg mh b">url</code>。<code class="fe me mf mg mh b">url</code>是用户希望从中获取数据的路径。然后<code class="fe me mf mg mh b">fetch()</code>方法返回一个承诺，可以解析响应对象或者用错误拒绝它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7404" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">fetch()</code>方法中的第二个参数是选项，它们是可选的。如果用户不传递选项，请求总是得到，并从给定的URL下载内容。正如我之前提到的，promise返回响应对象，正因为如此，用户需要使用另一种方法来获得响应的主体。根据正文的格式，用户可以使用几种不同的方法。</p><ul class=""><li id="11ff" class="nz oa it lk b ll lm lo lp lr ob lv oc lz od md oe of og oh bi translated"><code class="fe me mf mg mh b">response.json()</code></li><li id="5ab8" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">response.text()</code></li><li id="e530" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">response.blob()</code></li><li id="cc4e" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">response.formData()</code></li><li id="75f0" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">response.arrayBuffer()</code></li></ul><p id="ee25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最受欢迎的是<code class="fe me mf mg mh b">response.json()</code>。</p><p id="162f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可惜内置的<code class="fe me mf mg mh b">fetch()</code>函数不在Node.js里，但是有一个类似<a class="ae lh" href="http://npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank">的polyfill，node-fetch </a>。在node-fetch和浏览器<code class="fe me mf mg mh b">fetch()</code>之间，存在几个已知的<a class="ae lh" href="https://github.com/node-fetch/node-fetch/blob/master/docs/v3-LIMITS.md" rel="noopener ugc nofollow" target="_blank">变体</a>。</p><h2 id="b567" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="7224" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">Axios是一个JavaScript库，用于从Node或XMLHttpRequest或浏览器发出HTTP请求。作为一个现代化的库，它基于Promise API。Axios有一些优势，比如防止跨站点请求伪造(CSFR)攻击。为了能够使用Axios库，用户必须使用CDN、npm、Yarn或Bower安装它并将其导入到您的项目中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7b35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面这段代码是一个get方法和一个简单的响应和错误回调。当用户创建一个配置对象时，他们可以定义一堆属性。最常见的有<code class="fe me mf mg mh b">url</code>、<code class="fe me mf mg mh b">baseURL</code>、<code class="fe me mf mg mh b">params</code>、<code class="fe me mf mg mh b">auth</code>、<code class="fe me mf mg mh b">headers</code>、<code class="fe me mf mg mh b">responseType</code>、<code class="fe me mf mg mh b">data</code>。</p><p id="d854" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为响应，Axios返回一个承诺，该承诺将通过响应对象或错误对象来解决。在响应对象中，有以下值:</p><ul class=""><li id="7a28" class="nz oa it lk b ll lm lo lp lr ob lv oc lz od md oe of og oh bi translated"><code class="fe me mf mg mh b">data</code> : <strong class="lk jd"> </strong>实际响应体</li><li id="4f00" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">status</code>:呼叫的HTTP状态码，如<code class="fe me mf mg mh b">200</code>或<code class="fe me mf mg mh b">404</code></li><li id="f8d7" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">statusText</code> : HTTP状态为文本消息</li><li id="f944" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">headers</code>:与请求中相同</li><li id="f765" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">config</code>:请求配置</li><li id="f818" class="nz oa it lk b ll oi lo oj lr ok lv ol lz om md oe of og oh bi translated"><code class="fe me mf mg mh b">request</code> : XMLHttpRequest (XHR)对象</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c785" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用户需要使用<code class="fe me mf mg mh b">fetch()</code>中的两个承诺。用户可以避免样板文件，在Axios中编写更干净、更简洁的代码。</p><p id="4518" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Axios使用<code class="fe me mf mg mh b">data</code>属性，但是<code class="fe me mf mg mh b">fetch()</code>使用<code class="fe me mf mg mh b">body</code>属性来处理数据。<code class="fe me mf mg mh b">fetch()</code>的<code class="fe me mf mg mh b">data</code>已经字符串化。在<code class="fe me mf mg mh b">fetch()</code>中，URL作为参数传递，但是在Axios中，URL是在config对象中设置的。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3dd7" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">JSON</h1><h2 id="58cf" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="8b1f" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">使用<code class="fe me mf mg mh b">fetch()</code>方法，用户需要对响应数据使用某种方法。当用户发送请求正文时，用户需要对数据进行字符串化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f3ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面这段代码中，有了响应，用户需要处理<code class="fe me mf mg mh b">response.json()</code>动作。在<code class="fe me mf mg mh b">fetch()</code>中处理JSON数据时，有一个两步的过程。用户需要首先发出实际的请求，然后在响应上调用<code class="fe me mf mg mh b">.json()</code>方法。</p><h2 id="58cc" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="21d8" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在Axios中，用户在请求中传递数据或从响应中获取数据，并且数据被自动字符串化。因此，不需要其他操作。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0528" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，你可以看到你只需要一个<code class="fe me mf mg mh b">then</code>。</p><p id="b5fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据的自动转换是Axios的一个很好的特性。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4a81" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">错误处理</h1><h2 id="a2bc" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="23b3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">每次从<code class="fe me mf mg mh b">fetch()</code>方法得到响应时，您都需要检查状态是否为成功，因为即使不是，您也会得到响应。在<code class="fe me mf mg mh b">fetch()</code>的情况下，当且仅当请求无法完成时，承诺才会被解决。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8102" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">Fetch()</code>不抛出网络错误。因此，在使用<code class="fe me mf mg mh b">fetch()</code>时，您必须始终检查<code class="fe me mf mg mh b">response.ok</code>属性。您可以将这种错误检查提取到一个函数中，以使它更容易和更可重用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="52d1" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="3f5a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在Axios中，处理错误非常容易，因为Axios会抛出网络错误。如果会出现类似<code class="fe me mf mg mh b">404</code>的不良反应，承诺会被拒绝，会返回错误。因此，您需要捕捉一个错误，并且可以检查它是什么类型的错误。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ac13" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">下载进度</h1><p id="2252" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">加载大型资产时，进度指示器对于网速较慢的用户非常有用。在以前实施的进度指标中。开发人员使用<code class="fe me mf mg mh b">XMLHttpRequest.onprogress</code>作为回调处理程序。</p><h2 id="a28f" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="b7da" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">要在<code class="fe me mf mg mh b">fetch()</code>中跟踪下载的进度，您可以使用<code class="fe me mf mg mh b">response.body</code>属性之一，一个<code class="fe me mf mg mh b">ReadableStream</code>对象。它逐块提供主体数据，并允许您及时计算消耗了多少数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0482" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子演示了使用<code class="fe me mf mg mh b">ReadableStream</code>在下载图像时向用户提供即时反馈。</p><h2 id="a8fd" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="e15e" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在Axios中，实现进度指示器也是可能的，而且更容易，因为有一个现成的模块可以安装和实现。叫做<a class="ae lh" href="https://github.com/rikmms/progress-bar-4-axios/" rel="noopener ugc nofollow" target="_blank"> Axios进度条</a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="dbfb" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">上传进度</h1><h2 id="818d" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="f672" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在<code class="fe me mf mg mh b">fetch()</code>中，你不能监控你的上传进度。</p><h2 id="d41b" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="d00e" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在Axios中，您可以监控上传进度。如果你正在开发一个视频或照片上传的应用程序，这可能会成为一个障碍。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="756a" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">HTTP拦截</h1><p id="ea80" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">当您需要检查或更改从应用程序到服务器或从服务器到应用程序的HTTP请求时(例如，身份验证、日志记录等)，拦截可能非常重要。</p><h2 id="258d" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="5a6a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe me mf mg mh b">Fetch()</code>默认不提供HTTP拦截。有可能覆盖<code class="fe me mf mg mh b">fetch()</code>方法，并定义在发送请求期间需要发生什么，但这将需要更多的代码，并且可能比使用Axios的功能更复杂。您可以覆盖全局<code class="fe me mf mg mh b">fetch()</code>方法并定义自己的拦截器，如以下代码所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="70f6" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="666f" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">Axios HTTP拦截是这个库的关键特性之一——这就是为什么您不需要创建额外的代码来使用它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="25a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，<code class="fe me mf mg mh b">axios.interceptors.request.use()</code>和<code class="fe me mf mg mh b">axios.interceptors.response.use()</code>方法用于定义在发送HTTP请求之前要运行的代码。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="f5ce" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">响应超时</h1><h2 id="ee4e" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="0eeb" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe me mf mg mh b">Fetch()</code>通过<code class="fe me mf mg mh b">AbortController</code>接口提供响应超时功能。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3ae0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，使用<code class="fe me mf mg mh b">AbortController.AbortController()</code>构造函数，您需要创建一个<code class="fe me mf mg mh b">AbortController</code>对象。<code class="fe me mf mg mh b">AbortController</code>对象允许您稍后中止请求。正如我在上一篇文章“深入了解JavaScript的Fetch API ”中提到的，我们讨论了<code class="fe me mf mg mh b">signal</code>如何成为只读的<code class="fe me mf mg mh b">AbortController</code>的属性。<code class="fe me mf mg mh b">signal</code>提供了一种与请求通信或中止请求的方式。如果服务器在五秒钟内没有响应，则通过调用<code class="fe me mf mg mh b">controller.abort()</code>终止操作。</p><h2 id="f932" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="dcfa" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">通过使用config对象中可选的timeout属性，可以设置请求终止前的毫秒数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7db0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">JavaScript开发人员选择Axios而不是<code class="fe me mf mg mh b">fetch()</code>的原因之一是设置超时的便利性。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4d9f" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">并发请求</h1><h2 id="aec5" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="8e69" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">要同时发出多个请求，可以使用内置的<code class="fe me mf mg mh b">Promise.all()</code>方法。只需将一组<code class="fe me mf mg mh b">fetch()</code>请求传递给<code class="fe me mf mg mh b">Promise.all()</code>，然后传递一个<code class="fe me mf mg mh b">async</code>函数来处理响应。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="fb5b" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="d894" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您可以使用Axios提供的<code class="fe me mf mg mh b">axios.all()</code>方法来实现上述结果。将所有获取请求作为数组传递给<code class="fe me mf mg mh b">axios.all()</code>方法。使用<code class="fe me mf mg mh b">axios.spread()</code>函数将响应数组的属性分配给单独的变量，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="7299" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">向后兼容</h1><p id="eb32" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">向后兼容也称为浏览器支持。</p><h2 id="9037" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">取得</h2><p id="5a7b" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe me mf mg mh b">Fetch()</code>仅支持Chrome 42+，Safari 10.1+，Firefox 39+，Edge 14+。完整的兼容表可在“<a class="ae lh" href="https://caniuse.com/?search=Fetch" rel="noopener ugc nofollow" target="_blank">我可以使用</a>吗？”为了在不支持<code class="fe me mf mg mh b">Fetch()</code>的web浏览器上实现类似于<code class="fe me mf mg mh b">fetch()</code>的特性，您可以将<code class="fe me mf mg mh b">fetch()</code>与类似<code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/github/fetch" rel="noopener ugc nofollow" target="_blank">windows.fetch ()</a></code>的polyfill一起使用。</p><p id="2a2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用获取聚合填充，请通过以下npm命令进行安装:</p><pre class="ks kt ku kv gt on mh oo op aw oq bi"><span id="9bc7" class="nh mq it mh b gy or os l ot ou">npm install whatwg-fetch --save</span></pre><p id="2733" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果出于某种原因需要访问polyfill实现，可以通过exports:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="be6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，在一些旧浏览器中，您可能还需要promise polyfill。</p><h2 id="db8e" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">Axios</h2><p id="eaa1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">Axios不像<code class="fe me mf mg mh b">fetch()</code>。Axios提供了广泛的浏览器支持。甚至像IE11这样的老浏览器也可以毫无问题地运行Axios。Axios的<a class="ae lh" href="https://github.com/axios/axios#browser-support" rel="noopener ugc nofollow" target="_blank">文档</a>提供了完整的兼容性表。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b034" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="c0c4" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">对于大多数HTTP通信需求，Axios在一个紧凑的包中提供了一个易于使用的API。</p><p id="95ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">HTTP通信有一些替代库，比如<a class="ae lh" href="https://github.com/sindresorhus/ky" rel="noopener ugc nofollow" target="_blank"> ky </a>，一个基于window.fetch的小巧优雅的HTTP客户端；superagent ，一个基于XMLHttpRequest的小型渐进式客户端HTTP请求库。</p><p id="2ba8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是对于有大量HTTP请求的应用程序和那些需要良好的错误处理或HTTP拦截的应用程序，Axios是一个更好的解决方案。</p><p id="17c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于只有几个简单API调用的小型项目来说，<code class="fe me mf mg mh b">fetch()</code>可能是一个很好的解决方案。</p></div></div>    
</body>
</html>