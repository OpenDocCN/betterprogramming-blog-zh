<html>
<head>
<title>Dynamic Programming Interview Questions: How to Maximize Stock Profits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划面试问题:如何实现股票利润最大化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-interview-questions-how-to-maximize-stock-profits-8ed4966c2206?source=collection_archive---------5-----------------------#2020-07-01">https://betterprogramming.pub/dynamic-programming-interview-questions-how-to-maximize-stock-profits-8ed4966c2206?source=collection_archive---------5-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给定股票价格列表，找出最大利润</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c2ed705a3873e712589972ce5975687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EusScM_lizAzvpjd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="099b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个数组，其中第<em class="lv">个</em>元素是一只股票在第<em class="lv"> i </em>天的价格。</p><p id="87c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只被允许完成最多一笔交易(即买一股卖一股)，设计一个算法来找出最大利润。</p><p id="b0dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，你不能在买入股票之前卖出。</p><p id="9bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例1:</p><p id="724d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入:[7，1，5，3，6，4]</p><p id="796c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:5</p><p id="6d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释:第2天买入(价格= 1)，第5天卖出(价格= 6)。利润= 6–1 = 5。不是7–1 = 6，因为卖价需要大于买价。</p><p id="377a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例2:</p><p id="ef55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入:[7，6，4，3，1]</p><p id="e1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:0</p><p id="c953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说明:在这种情况下，没有交易完成，即最大利润= 0。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="9c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到强力解决方案，我们需要考虑所有可能的事务，同样，这意味着自底向上的方法会更好。</p><blockquote class="md me mf"><p id="1bbd" class="kz la lv lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated"><em class="it">老实说，我只是随机选择我认为有趣的问题，它们似乎都巧合地更适合自下而上的方法。如果有人知道一个自上而下的方法更好的问题，请随时留下问题的回答，我会在未来的帖子中尝试这个问题。</em></p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e268" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最初的想法</h1><p id="fc83" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">有时候，我们应该如何制表的结构一开始并不清楚。深入了解这一点的一个方法是首先问自己，“有可能在线性时间(即O(n))内解决这个问题吗？”如果是的话，那么你很幸运，因为有可能你只需要使用一个简单的1D阵列。否则，通常需要更复杂的结构。</p><p id="93e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在这个问题中，你认为有可能在线性时间内解决这个问题吗？给自己一分钟时间来尝试回答这个问题。现在，对于答案…这是一个<em class="lv">是</em>。为什么？因为我们真正要做的就是计算我们在任何一天的最大利润。我们如何记录我们的最大利润？嗯，这实际上非常类似于我们之前在最大子阵列<a class="ae ky" href="https://medium.com/better-programming/dynamic-programming-interview-questions-part-3-f7d15f37cecb?source=friends_link&amp;sk=50789a31d591e3f016ca2adcb2572f65" rel="noopener">这里</a>所做的问题，但是我们不是跟踪最大总和，而是跟踪最大利润。这里使用一个简单的1D数组就可以了，其中数组的每个指数代表你在第<em class="lv"> i </em>天可以获得的最佳利润。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d93b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用Python实现</h1><p id="f5cb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">首先，我们将从0利润的初始列表开始。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e498" class="nl mk it nh b gy nm nn l no np">def solution(prices: List[int]) -&gt; int:<br/>    # initialization<br/>    max_profit = [0 for i in range(len(prices))]</span></pre><p id="34c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于基本情况，由于我们需要至少2天来为所有长度为1的输入数组获利(即，在给定的一天买入，然后卖出)，我们的最大利润为0(我们不想买入任何股票，因为没有第2天可以卖出；买股票只会是负盈利)，但是既然max_profit[0]从我们初始化的时候就已经是0了，那么这里就没什么好改变的了。</p><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用下面的结构从长度为2的输入数组开始，其中我们希望使用之前计算的max_profit[i-1]的解来计算max_profit[i]。那么我们如何做到这一点呢？</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="760a" class="nl mk it nh b gy nm nn l no np">for i in range(1, len(prices)):<br/>        max_profit[i] = ...</span></pre><p id="4d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这一点很清楚，如果max_profit[i-1]大于prices[i] — min(prices[:i])，我们可以设置max_profit[i] = max_profit[i-1]，否则我们要设置max _ profit[I]= prices[I]—min(prices[:I])。</p><blockquote class="md me mf"><p id="20a3" class="kz la lv lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">Python切片的工作方式是prices[:i]是从索引0到索引i-1的价格子数组</p></blockquote><p id="d3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是调用min(prices[:i])会浪费不必要的计算时间，实际上我们想要的是达到索引i-1的最低价格。我们只需创建一个名为min_price的新变量，并在整个while循环中跟踪它，而不是调用min()就可以做到这一点。</p><p id="36db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以返回max _ profit[len(prices)-1]作为我们的最终解决方案，这样我们完成的解决方案将如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0a27" class="nl mk it nh b gy nm nn l no np">def solution(prices: List[int]) -&gt; int:<br/>    if len(prices) == 0:<br/>        return 0</span><span id="dc5e" class="nl mk it nh b gy nq nn l no np">    # initialization<br/>    max_profit = [0 for i in range(len(prices))]<br/>    min_price = prices[0]</span><span id="28ee" class="nl mk it nh b gy nq nn l no np">    for i in range(1, len(prices)):<br/>        if prices[i] &lt; min_price:<br/>            min_price = prices[i]</span><span id="6e6c" class="nl mk it nh b gy nq nn l no np">        max_profit[i] = max(prices[i] - min_price, max_profit[i-1])</span><span id="70d5" class="nl mk it nh b gy nq nn l no np">    return max_profit[len(prices)-1]</span></pre><p id="2492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这些都有意义，在本系列的下一章再见。感谢阅读！</p><p id="151e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果你想知道，这绝不是最佳的解决方案。这只是解决这个问题的一种方法。本系列的目的是养成用DP方式处理和解决问题的习惯。更优的解决方案将具有O(1)空间复杂度:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="eac3" class="nl mk it nh b gy nm nn l no np">def solution(prices: List[int]) -&gt; int:<br/>    max_profit = 0<br/>    min_price = prices[0]<br/><br/>    for i in range(1, len(prices)):<br/>        min_price = min(min_price, prices[i])<br/>        max_profit = max(max_profit, prices[i]-min_price)<br/><br/>    return max_profit</span></pre></div></div>    
</body>
</html>