<html>
<head>
<title>How to Work With JSON in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rust中使用JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-work-with-json-in-rust-35ddc964009e?source=collection_archive---------1-----------------------#2022-07-12">https://betterprogramming.pub/how-to-work-with-json-in-rust-35ddc964009e?source=collection_archive---------1-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Rust学习读写无类型或强类型的JSON</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40164b9fc67f72d5f986077a4ed35403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oD04dB_aPPTV42VC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON现在被广泛使用，即使Rust可能不是使用JSON作为数据的工具和应用程序使用最多的语言，但在Rust这样一种快速发展的语言中，知道如何对待这种格式是很重要的。</p><p id="aad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇小文章中，您将学会:</p><ul class=""><li id="68c1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">读取无类型的JSON。</li><li id="d9d3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将JSON作为强类型数据结构读取。</li><li id="fbab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">写JSON字符串。</li></ul><p id="d7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全部只使用了<code class="fe mj mk ml mm b">serde</code>和<code class="fe mj mk ml mm b">serde-json</code> Rust依赖项。</p><h1 id="890f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">非类型化JSON</h1><p id="73db" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Rust是一种强类型语言，JSON是一种不指定其值的类型的数据格式(就其本身而言)。如果我们不想或者不关心接收具有精确结构和类型的JSON数据，那么将JSON作为递归枚举读取是由<code class="fe mj mk ml mm b"><a class="ae ky" href="https://docs.serde.rs/serde_json/value/enum.Value.html" rel="noopener ugc nofollow" target="_blank">serde_json</a></code>库提供的一种数据结构。这个结构接受布尔值、字符串、数字、数组和对象(以及空值)，因此任何有效的JSON都是可以接受的。</p><p id="565c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看在通过添加所需的dep来设置我们的cargo项目(<code class="fe mj mk ml mm b">cargo new handle_json</code>)之后它是如何工作的:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="bcbb" class="no mo it mm b gy np nq l nr ns">serde_json = "1.0"<br/>serde = { version = "1.0", features = ["derive"] }</span></pre><p id="d46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理非类型化的JSON值，我们将使用由<code class="fe mj mk ml mm b">serde_json</code>依赖项提供的<code class="fe mj mk ml mm b">from_str()</code>函数。此外，我们将需要使用我之前谈到的Enum表示来解析值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的解析是由<code class="fe mj mk ml mm b">read_json</code>函数完成的，该函数将一个字符串文字作为参数，然后由<code class="fe mj mk ml mm b">serde_json::from_str()</code>解析并展开(因为它是一个结果)。您可以看到，我们可以像使用大多数其他语言一样访问JSON中的字段:<code class="fe mj mk ml mm b">parsed["article"]</code>。</p><h1 id="2b14" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">类型化JSON</h1><p id="b418" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">对于大量的用例，我们可能希望在程序交互的数据上实施安全类型。Serde提供了一种很好的将JSON数据映射到rust结构的方法。这种方法类似于我们刚刚看到的方法，但是我们不是将Enum表示指定为read JSON的类型，而是指定一个本地rust数据结构。</p><p id="84b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个实现serde的反序列化特性的类型都可以被反序列化，并用于检查接收到的JSON数据是否与提供的结构的类型和名称匹配。这做起来容易，说起来难，所以我们来举个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="839b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到的第一个区别是，我们定义了两个实现serde的(反)序列化特征的结构。其次，我们已经为读取的JSON数据指定了<code class="fe mj mk ml mm b">Article</code> struct作为类型。第三，您会注意到我们并没有将解析后的变量作为枚举进行索引(就像我们之前对<code class="fe mj mk ml mm b">parsed[""]</code>所做的那样)，而是将其作为<code class="fe mj mk ml mm b">struct</code> : <code class="fe mj mk ml mm b">parsed.paragraph[0].name</code>进行索引。</p><p id="bc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您从结构中看到的，我们希望我们的结构有非常具体的类型和名称。让我们看看如果提供的JSON数据与结构的类型(和名称)不匹配会发生什么，如下所示:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="c371" class="no mo it mm b gy np nq l nr ns">{<br/>  "article": "how to work with json in Rust",<br/>  "author": "tdep",<br/>  "paragraph": [<br/>    {<br/>      "name": 1<br/>    },<br/>    {<br/>      "name": "strongly typed"<br/>    },<br/>    {<br/>      "name": "writing json"<br/>    }<br/>  ]<br/>}</span></pre><p id="66ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用这个JSON数据(注意，第一段的名称的值是一个数字)，程序将会出错:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="bf28" class="no mo it mm b gy np nq l nr ns">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error("invalid type: integer `1`, expected a string", line: 8, column: 15)', src/main.rs:44:58</span></pre><p id="f2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们试着用键<code class="fe mj mk ml mm b">"name"</code>改变键<code class="fe mj mk ml mm b">"article"</code>:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="3661" class="no mo it mm b gy np nq l nr ns">{<br/>  "name": "how to work with json in Rust",<br/>  "author": "tdep",<br/>  "paragraph": [<br/>    {<br/>      "name": "untyped"<br/>    },<br/>    {<br/>      "name": "strongly typed"<br/>    },<br/>    {<br/>      "name": "writing json"<br/>    }<br/>  ]<br/>}</span></pre><p id="b711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序再次出现混乱:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="3d8f" class="no mo it mm b gy np nq l nr ns">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error("missing field `article`", line: 17, column: 1)', src/main.rs:44:58</span></pre><p id="728a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Rust未能检测到JSON中的文章字段。</p><p id="68de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望对接收的数据有更多的控制，这是一个很好的方法，尤其是当您使用用户输入的JSON时。</p><p id="0599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们快速看看如何反过来:从Rust数据结构到JSON字符串。</p><h1 id="44a0" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">编写JSON</h1><p id="935e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们将使用<code class="fe mj mk ml mm b">serde_json::to_string()</code>函数将数据结构转换成JSON字符串，并使用serde的<code class="fe mj mk ml mm b">Serialize</code>特征使该结构能够被序列化。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是构建文章(根据定义的结构)，然后将其引用传递给<code class="fe mj mk ml mm b">serde_json::to_string()</code>函数。正如我们所料，这是运行cargo项目的结果:</p><pre class="kj kk kl km gt nk mm nl nm aw nn bi"><span id="ac33" class="no mo it mm b gy np nq l nr ns">the JSON is: {"article":"how to work with json in Rust","author":"tdep","paragraph":[{"name":"untyped"},{"name":"strongly typed"},{"name":"writing json"}]}</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="da84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了如何在Rust中快速、安全、高效地处理JSON。同样值得一提的是，我们用<code class="fe mj mk ml mm b">serde_json::from_string</code>或<code class="fe mj mk ml mm b">serde_json::to_string</code>完成的每一个操作，也可以用<code class="fe mj mk ml mm b"><a class="ae ky" href="https://docs.serde.rs/serde_json/ser/fn.to_vec.html" rel="noopener ugc nofollow" target="_blank">serde_json::to_vec</a></code>、<code class="fe mj mk ml mm b"><a class="ae ky" href="https://docs.serde.rs/serde_json/ser/fn.to_vec.html" rel="noopener ugc nofollow" target="_blank">serde_json::to_</a>writer</code>完成，结果不同:<code class="fe mj mk ml mm b">to_vec</code>序列化(或反序列化)为一个向量，<code class="fe mj mk ml mm b">to_writer</code>为任何可写输出(例如一个文件)。</p><p id="7d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>