<html>
<head>
<title>3 and 1/2 Reasons Why Your Tests Should Be Stateless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您的测试应该是无状态的3 . 5个原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-and-1-2-reasons-why-your-tests-should-be-stateless-ad93441705fe?source=collection_archive---------9-----------------------#2022-06-03">https://betterprogramming.pub/3-and-1-2-reasons-why-your-tests-should-be-stateless-ad93441705fe?source=collection_archive---------9-----------------------#2022-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用自封装测试节省时间并减少麻烦</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/efefafa05614e6445a962d8d84c01a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSGooWj16Zmwfn5Wjs5mzQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这个乐高小人生活在泡泡里，你的测试也应该如此！（📷:<a class="ae kv" href="https://www.shutterstock.com/image-photo/klang-selangor-malaysia-august-6-2021-2020379540" rel="noopener ugc nofollow" target="_blank">苏菲安·哈尼夫</a></p></figure><h1 id="4fce" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">定义</h1><p id="4066" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk">“一个无状态的过程或应用程序可以被孤立地理解。过去的交易没有储存的知识或参考。每一笔交易都仿佛是从零开始……”</em>—红帽(<a class="ae kv" href="https://www.redhat.com/en/topics/cloud-native-apps/stateful-vs-stateless" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><h1 id="49cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生活在泡沫中的🫧</h1><p id="13a9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">调试不明显的测试失败就像在鞋子里放块石头去爬乞力马扎罗山一样有趣。如果你曾经编写过单元、集成或端到端(E2E)测试，你可能经历过极度无聊的测试代码，试图追踪未知的错误。通过编写自我封装、自我配置的测试，而不是依赖于应用程序神奇地存在于期望的状态，可以节省无数小时的挫折。</p><h1 id="3a08" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.独立测试更容易调试</h1><p id="8d74" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">问题出在测试上。您不必窥探其他测试、您的应用程序的测试用户帐户，或者检查您的数据库以确保正确的信息存在并且可用于测试。确切地知道在哪里寻找测试失败的解决方案可以大大加快您解决测试问题的速度。</p><h1 id="3197" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.自封装测试可以并行运行</h1><p id="1693" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">编写只能以特定顺序运行的测试是一个严重的反模式。对于运行时间较长的测试，比如集成和E2E测试，并行运行测试以减少测试套件运行时间变得尤为重要。此外，能够独立于测试套件启动长期运行的测试也是至关重要的。</p><h1 id="a708" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.无状态测试可以在多种环境中运行</h1><p id="ca00" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在测试中依赖预先存在的应用程序状态意味着依赖测试作者未记录的记忆。依赖于在测试套件开始之前以特定方式配置的应用程序的测试通常不能在多种环境中运行，例如在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/ci-cd-for-angular-developers-be9a1485d22b"> CI/CD机器</a>或新员工的IDE中。为手动运行测试设置新环境是一项单调乏味的工作——不要这样做！</p><h1 id="5022" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">额外收获:无状态测试兼做文档</h1><p id="617f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">写得好的测试是技术文档的最好形式。测试描述了可以在系统上执行的操作，以及可以执行这些操作的条件。当一个测试包括所有必要的设置时，对于观察者来说，系统应该如何工作就更加透明了。</p><h1 id="e167" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">问题是</h1><p id="a619" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个场景中，我们团队中的一个开发人员编写了一个由两个<a class="ae kv" href="https://cypress.io" rel="noopener ugc nofollow" target="_blank">赛普拉斯</a> E2E测试组成的套件。第一个测试将用户添加到包含用户列表的表中。第二个测试对表进行过滤，并确保在应用过滤器后用户显示在列表中。</p><p id="e6ee" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">开发人员按如下方式编写测试套件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">依赖于先前测试结果的测试</p></figure><p id="1204" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，第二个测试基于第一个测试添加的用户进行过滤。第二个测试不能独立或并行执行。即使第二次测试中的功能工作正常，第一次测试中的失败也可能在第二次测试中触发假阳性失败。</p><h1 id="d0bf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">补救措施</h1><p id="46f1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">编写不依赖于外部状态的测试通常很简单。有多种选项可以改进上面的示例测试。最简单的解决方案是简单地将对<code class="fe ms mt mu mv b">cy.addUser()</code>的调用移动到<code class="fe ms mt mu mv b">beforeEach</code>块，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有问题的测试的一个稍微好一点的版本</p></figure><p id="c6f7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">上面的解决方案有一些缺点。第一个问题是我们在测试中引入了重复，上面写的两个测试都是测试<code class="fe ms mt mu mv b">cy.addUser(user)</code>命令。第二个问题是，使用用户操作来设置测试是很慢的，除非您专门测试用户操作，否则应该避免这样做。</p><p id="d9a6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了加速我们的测试并减少重复，我们可以重新编写测试来使用API客户机直接配置系统的状态。您可以定义一个Cypress <a class="ae kv" href="https://docs.cypress.io/guides/tooling/plugins-guide#cy-task" rel="noopener ugc nofollow" target="_blank">任务</a> <code class="fe ms mt mu mv b">cy.task('add:user', user)</code>，并利用它通过API调用在测试时添加用户，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对过滤器用户测试的进一步改进</p></figure><p id="f7f7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第二个解决方案更接近最优，但是我们真的需要通过API添加用户来过滤表吗？通过任务添加用户仍然容易失败，并且没有必要测试表过滤。在我们假设的应用程序中，用户的表在客户端被过滤，我们可以通过网络<a class="ae kv" href="https://docs.cypress.io/api/commands/intercept#Usage" rel="noopener ugc nofollow" target="_blank">拦截</a>模拟系统状态来改进测试。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个完全封装的测试套件，带有截取的网络请求</p></figure><h1 id="60a9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最后的想法</h1><p id="f61b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">像大多数事情一样，上述话题应该有所保留。在理想的场景中，所有的测试都能够完全独立运行，并且不依赖于以特定方式配置的环境。然而，现实世界是混乱的，有时让每个测试对其整体状态负责是不可行的。</p><p id="f944" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在一个示例场景中，可能不希望每次运行测试时都创建一个新用户。一个合理的选择可能是在整个测试套件的开始创建一个新用户，或者使用系统中已经存在的用户。在这种情况下，您的测试应该处理帐户的必要配置，而不依赖于测试运行开始时存在的任何现有配置。</p><p id="e5ad" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">感谢阅读！</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="9b2f" class="na kx iq mv b gy nb nc l nd ne"><strong class="mv ir">Want to connect?</strong></span><span id="b6ad" class="na kx iq mv b gy nf nc l nd ne">If you found the information in this tutorial valuable, follow me on <a class="ae kv" href="https://twitter.com/bobbyg603" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>