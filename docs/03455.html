<html>
<head>
<title>Working With the Combine Framework in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Combine框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-the-combine-framework-in-swift-cffdfcc6f32c?source=collection_archive---------8-----------------------#2020-02-11">https://betterprogramming.pub/a-deep-dive-into-the-combine-framework-in-swift-cffdfcc6f32c?source=collection_archive---------8-----------------------#2020-02-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d869" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让我们了解一下苹果自己的反应式框架</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/212d1d763db52ef19373a7bc6fd1e574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TYY7y4GK0e0r90ni"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="de91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过对Combine的介绍，Apple展示了函数式反应式编程在现代应用程序开发中的重要性。</p><p id="8ed1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">函数式反应式编程使处理异步任务变得更加容易，尤其是当您需要一次管理多个任务时。拥有一个基于事件的中央处理使代码更容易理解，并通过消除嵌套闭包使我们免于可怕的回调地狱。</p><p id="293c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">用苹果自己的话来说，Combine是一个声明性的Swift API，可以让你随时处理值。它是苹果公司内部的反应式框架，也是RxSwift的竞争对手。</p><p id="07f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就性能而言，它在大多数部门都轻而易举地击败了RxSwift。与RxSwift不同，Combine支持背压和类型化错误。</p><p id="936e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了非常适合SwiftUI之外，Combine还兼容许多其他基础类型— <code class="fe lw lx ly lz b">Timers</code>、<code class="fe lw lx ly lz b">NotificationCenter</code>、<code class="fe lw lx ly lz b">URLSession</code>都公开了<code class="fe lw lx ly lz b">publisher</code>属性，我们将会看到。</p><p id="ec99" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们深入研究Combine框架的两个最重要的协议。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="b605" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">发布者和订阅者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mz"><img src="../Images/076d6f2ebee8599c6203896310996bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S89EcWUJAZ4mk43cM9Mb9Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">水流的鸟瞰图</p></figure><p id="3b5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">发布者负责发出订户一旦连接到他们就可以接收的值。发布者仅在订阅者连接到它时发出值。</p><p id="294b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你来自RxSwift背景，发布者是可观察的，订阅者是观察者。</p><p id="1beb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">receive(subscriber:)</code>连接订阅者和发布者。</p><p id="a697" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然我们可以创建自己的定制发布者和订阅者，但Combine也为我们提供了一些内置的发布者和订阅者。</p><p id="d03f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个<code class="fe lw lx ly lz b">Just</code>发布者发出一个单一的值，永远不会失败。</p><p id="5ee6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">Sink</code>和<code class="fe lw lx ly lz b">Assign</code>是两个内置用户。以下是在发布服务器上连接它们的相应方法:</p><ul class=""><li id="a39c" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b">sink(receiveCompletion:receiveValue:)</code>包含两个闭包。当发布者正常完成或出现错误时，调用第一个函数。发布者发出的每个值都在第二个闭包中接收。</li><li id="6792" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b">.assign(to:, on:)</code>通过将值传递给key path属性用于元素。</li></ul><p id="21b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下示例显示了内置发布者和订阅者的运行情况:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="3966" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当存储在属性中时，上面的订阅属于类型<code class="fe lw lx ly lz b">AnyCancellable</code>。</p><p id="a835" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是Combine中的另一个例子，它使用<code class="fe lw lx ly lz b">publisher</code>属性将字典转换成流，并使用<code class="fe lw lx ly lz b">map</code>操作符转换值:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="2780" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">运算符负责转换值。然后返回新的发布者。</p><p id="0175" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以通过调用实例上的<code class="fe lw lx ly lz b">cancel()</code>方法来手动结束订阅。</p><p id="008b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了接收发布服务器上的所有事件(新建订阅、取消订阅、值、完成和请求的元素数量)，我们可以在发布服务器上实现以下实例方法:</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="8fb2" class="nu mi iu lz b gz nv nw l nx ny">handleEvents(receiveSubscription:receiveOutput:receiveCompletion:<br/>receiveCancel:receiveRequest:)</span></pre><p id="0f22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当发布者从上游发布者接收值时，闭包<code class="fe lw lx ly lz b">receiveOutput</code>被调用。闭包<code class="fe lw lx ly lz b">receiveRequest</code>包含一个<code class="fe lw lx ly lz b">Subscriber.Demand</code>值，表示订户请求的元素数量。零需求将导致发布者发出的值的下降。</p><p id="45b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">“上游”表示“前一个”，“下游”表示“下一个”。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="543e" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">学科</h1><p id="6d5f" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">主题可以充当发布者和订阅者。它可以传递来自其他发布者的值，也可以手动发出值。Combine目前提供了<code class="fe lw lx ly lz b">Subject</code>协议的两个内置实现:</p><ul class=""><li id="85b6" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/combine/passthroughsubject" rel="noopener ugc nofollow" target="_blank">PassThroughSubject</a></code> —将所有值广播给订阅者。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="f90b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码片段以<code class="fe lw lx ly lz b">Just</code>发出的值结束，紧接着完成的枚举被触发。</p><p id="2e73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的例子在<code class="fe lw lx ly lz b">Subject</code>中创建和传递了一个定制的错误类型。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="8ba0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，一旦失败通过，将不会收到任何值。</p><ul class=""><li id="f29c" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/combine/currentvaluesubject" rel="noopener ugc nofollow" target="_blank">CurrentValueSubject</a></code> —无论用户何时连接，都会从<code class="fe lw lx ly lz b">Subject</code>接收最后发出的值。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="1218" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码在订阅期间打印<code class="fe lw lx ly lz b">1</code>，然后在我们使用<code class="fe lw lx ly lz b">send</code>函数手动传递值时打印<code class="fe lw lx ly lz b">2</code>和<code class="fe lw lx ly lz b">3</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="a63d" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">@已发布的属性包装</h1><p id="417a" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">通过将这个属性包装器附加到一个属性，我们使它成为一个发布者。例如，要在UIKit中切换开关，我们执行以下操作:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="15c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过切换<code class="fe lw lx ly lz b">isSwitchOn</code>属性，分配给它的UISwitch将通过键绑定属性反映这些变化。</p><p id="39af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当<code class="fe lw lx ly lz b">ViewController</code>被取消初始化时，<code class="fe lw lx ly lz b">AnyCancellable</code>属性自动取消订阅。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="50f8" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">调度程序</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/26d279e764c3b1c51f9e94151023984d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2VHK5Sn4128g6_W_zqBgg.png"/></div></div></figure><p id="b215" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Combine中的调度器帮助我们在线程之间切换。默认情况下，调度程序在发出元素的同一线程上运行。</p><p id="fd32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">subscribe(on:)</code>和<code class="fe lw lx ly lz b">receive(on:)</code>类似于RxSwift中的<code class="fe lw lx ly lz b">observeOn</code>和<code class="fe lw lx ly lz b">subscribeOn</code> <strong class="lc iv"> </strong>。</p><p id="4e38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，调度程序通过将操作转移到后台调度程序并接收UI线程上的值来处理异步工作。</p><p id="7d14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">subscribe(on:)</code>改变下游的调度程序，直到<code class="fe lw lx ly lz b">receive(on:)</code>被指定。下面的代码显示了在UISwitch元素上使用计划程序的一个这样的示例。</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="d502" class="nu mi iu lz b gz nv nw l nx ny">$isOn<br/>.subscribe(on: DispatchQueue.global())<br/>.receive(on: DispatchQueue.main).assign(to: \.isOn, on: mySwitch)</span></pre><p id="981a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一个在延迟操作符中添加调度程序的例子。</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="b90b" class="nu mi iu lz b gz nv nw l nx ny">[1,2,3,4,5,6]<br/>.publisher<br/>.delay(for: .seconds(1), scheduler: DispatchQueue.global())<br/>.map { "\($0)" }<br/>.sink { value in print(value) }</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="a5e6" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">未来和承诺</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/86f099c5d8bdeced0d22b956a81f8320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*L8GIrUJ8qwEmO4yr39GQDw.png"/></div></figure><p id="56bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">期货是一次性发行商。这意味着，与可以发出任意数量的值的发布者不同，<code class="fe lw lx ly lz b">Future</code>将只发出一个值，并且不管订阅者如何完成。它通过一个<code class="fe lw lx ly lz b">promise</code>发布结果。下面的例子表明:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="270d" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">与计时器、通知中心和URLSession结合使用</h1><p id="8114" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">前面，我们讨论了一些基础类型是如何为Combine公开发布者功能的。让我们看看它们的实现。</p><h2 id="a4c7" class="nu mi iu bd mj og oh dn mn oi oj dp mr lj ok ol mt ln om on mv lr oo op mx oq bi translated">计时器发布者</h2><p id="66e5" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">计时器发布器对于筛选值非常有用。以下代码创建一个计时器发布器:</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="a804" class="nu mi iu lz b gz nv nw l nx ny">let timerPublisher = Timer.publish(every: 1.0, on: RunLoop.main, in: .default)</span></pre><p id="7175" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以调用发布者自身上面的<code class="fe lw lx ly lz b">autoconnect</code>,让订阅者一旦连接上就开始接收值。或者，当我们希望开始接收值时，我们可以手动调用<code class="fe lw lx ly lz b">connect()</code>方法，如下所示:</p><pre class="kk kl km kn gu nq lz nr ns aw nt bi"><span id="935d" class="nu mi iu lz b gz nv nw l nx ny">let cancellableSink = timerPublisher<br/>    .sink { timestamp in<br/>        print("Current time", timestamp)<br/>    }</span><span id="8080" class="nu mi iu lz b gz or nw l nx ny">timerPublisher.connect()</span></pre><p id="61e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了停止接收值，我们简单地在<code class="fe lw lx ly lz b">cancellableSink</code>属性上调用<code class="fe lw lx ly lz b">cancel()</code>。</p><h2 id="3da6" class="nu mi iu bd mj og oh dn mn oi oj dp mr lj ok ol mt ln om on mv lr oo op mx oq bi translated">通知中心发布者</h2><p id="e51b" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">NotificationCenter现在能够以下列方式充当发布者:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="e85c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">compactMap</code>操作符不仅进行转换，还在输出结果之前展开可选值。</p><h2 id="ae1f" class="nu mi iu bd mj og oh dn mn oi oj dp mr lj ok ol mt ln om on mv lr oo op mx oq bi translated">URLSession dataTaskPublisher</h2><p id="be75" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">URLSession现在公开了<code class="fe lw lx ly lz b">dataTaskPublisher</code>方法，该方法从URLSession结果中创建一个发布者。以下代码片段展示了具有合并功能的URLSession的格式。它使得解码和错误处理变得轻而易举:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="5fa9" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">排除故障</h1><p id="643c" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">尽管函数式反应式编程有它自己的好处，但由于代码的非命令性流动，调试可能会很棘手。谢天谢地，Combine框架给了我们一个良好的开端。</p><p id="022d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然我们前面看到了有助于理解事件生命周期的<code class="fe lw lx ly lz b">handleEvents</code>操作符，但是还有一些操作符:</p><ul class=""><li id="5ea5" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b">print()</code>:帮助在控制台记录所有发布事件的信息。</li><li id="a660" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/combine/publisher/3204689-breakpointonerror" rel="noopener ugc nofollow" target="_blank">breakpointOnError</a></code>:当发布者发送一个错误时，操作符触发一个断点并在该进程中停止调试器。</li><li id="9f81" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/combine/publisher/3204688-breakpoint" rel="noopener ugc nofollow" target="_blank">breakPoint()</a></code>:这更进一步，允许我们设置调试器发出信号SIGTRAP的条件，从而停止让我们查看调用层次结构。</li></ul><p id="3260" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面的代码中，收到负值时会触发断点:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="0ea2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了停止调试器，我们在相关的闭包里返回了<code class="fe lw lx ly lz b">true</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="3184" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结束语</h1><p id="78b9" class="pw-post-body-paragraph la lb iu lc b ld nz jv lf lg oa jy li lj ob ll lm ln oc lp lq lr od lt lu lv in bi translated">随着在iOS 13中引入Combine，苹果清楚地表明，它将成为与SwiftUI一起开发应用程序的关键角色。在接下来的几年里，它将缓慢而稳定地进入代码库。因此，拥抱它是至关重要的。</p><p id="dea2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的文章中，我们将深入探讨链接网络请求和利用不同的组合操作符。</p><p id="e882" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>