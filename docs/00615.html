<html>
<head>
<title>Git Workflow Etiquette</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git工作流礼仪</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/git-workflow-etiquette-f22d96b8b0b8?source=collection_archive---------4-----------------------#2019-06-19">https://betterprogramming.pub/git-workflow-etiquette-f22d96b8b0b8?source=collection_archive---------4-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0e70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净代码库的存储组织</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/8316fb83f6efe8c599bf5eb2a042fc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*-jgVlA3_4lC1_xgr5wymlA.png"/></div></figure><p id="6502" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Git的版本控制提供了强大的协作，无论是紧密结合的技术团队还是开源格式的分布式网络。尽管如此，还是要适当小心。</p><p id="1920" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Git 在软件开发领域广泛使用，可以管理不断发展的代码库。它的大部分有用性来自于从现有项目中分支出新的工作来独立工作，直到准备好集成到项目中。</p><p id="7561" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">高质量的软件由健壮、有弹性、安全和高性能的代码组成。</p><p id="bad9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些属性可以通过维护高质量代码的基础和坚实的文档历史来实现。任何人都应该能够加入到这个过程中来，并且很容易地了解和跟踪项目的状态。</p><p id="06a0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是Git和<a class="ae lm" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的用武之地。</p><p id="e8ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">跳到以下内容:</p><ul class=""><li id="012c" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#e339" rel="noopener">分支对分支</a></li><li id="9599" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#3336" rel="noopener">重设基础与合并</a></li><li id="e57f" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">CLI </li><li id="b7b3" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9617" rel="noopener">提交(消息)</a></li><li id="939b" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9f99" rel="noopener">拉取请求(和审核)</a></li><li id="3e49" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9cac" rel="noopener"> GitHub问题</a></li><li id="5054" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#1059" rel="noopener">开源</a></li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ea84" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">方法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/ec28ed89f3f5c9943aaf0ba194454d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzuuIR8ZyBnKAXGNjznvgg.png"/></div></div></figure><p id="3490" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为智能法律合同的开源项目<a class="ae lm" href="https://www.accordproject.org/" rel="noopener ugc nofollow" target="_blank"> Accord Project </a>的贡献者，我的经历使我采纳并实现了Git工作流和礼仪的标准，我认为这是彻底而有效的。</p><p id="da4c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我将分享这一点，作为对其他人的有益参考，以及对我自己未来的历史参考。很明显，我同时使用了Git和GitHub。</p><p id="6979" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">透视的话，可以参考GitHub官方的工作流程建议书(<a class="ae lm" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> GitHub flow </a>)。</p><p id="a4a8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我在Accord项目中的大部分工作都是在<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中完成的，混合了一些特定领域的语言，但是这里展示的原则应该适用于任何语言。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e339" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">分支和叉</h1><h2 id="4f16" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">分支</h2><p id="197f" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">赞成的意见</p><ul class=""><li id="f39a" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">所有项目工作都是集中的。</li><li id="cd95" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">易于协作。</li><li id="4f5c" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">一个遥控器就能搞定。</li></ul><p id="5e24" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">骗局</p><ul class=""><li id="a7fd" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">废弃的分支可能很容易混乱。</li></ul><h2 id="68ea" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">分支</h2><p id="a91f" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">赞成的意见</p><ul class=""><li id="7c95" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">增加用户分支之间的分离。</li><li id="4853" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">主储存库清洁度。</li></ul><p id="c01d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">骗局</p><ul class=""><li id="2f83" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">难以跟踪分支机构。</li><li id="78e3" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">协作需要额外的步骤。</li><li id="714a" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">经验不足的Git用户的可访问性较低。</li></ul><p id="ba07" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然这两种方法都有好处，但我的一般原则是分支一个开源项目，分支一个更小或孤立的团队。</p><p id="912e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在开源软件中，保持主存储库干净整洁的动机更强，而在分支上快速而肮脏的协作的机会更少。</p><p id="5a4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">相反，一个技术团队将受益于一个带有可跟踪分支的中央存储库。无论哪种方式都需要严密的组织。</p><p id="b47d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一个开源项目，Accord项目遵循fork工作流模型。</p><p id="105e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，<code class="fe nw nx ny nz b">master</code>分支应该保持同步(<a class="ae lm" href="https://help.github.com/en/articles/syncing-a-fork" rel="noopener ugc nofollow" target="_blank">同步指南</a>)，并且每个特性、错误修复、发布或代码更改应该发生在不同的分支中。这将在下一节的<a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#3336" rel="noopener">中详细讨论。</a></p><p id="3c20" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">命名一个新的分支将是保持问题、拉请求和Git历史的一致跟踪系统的第一步。这里重要的因素是一致性。</p><p id="e189" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nw nx ny nz b">name/issue-tracker/short-description</code></p><ul class=""><li id="e98f" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">name</code>:从姓名首字母到全名再到GitHub用户名。</li><li id="94a1" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">issue-tracker</code>:参考来自GitHub或其他敏捷用户故事来源的问题。</li><li id="03f2" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">short-description</code>:用一到三个单词描述这个分支的主要目标，用连字符分隔。</li></ul><h2 id="a36c" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated"><strong class="ak">示例</strong></h2><p id="a057" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated"><code class="fe nw nx ny nz b">irmerk/issue7/new-feature</code></p><p id="b419" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在单个特性上协作的情况下，为该特性维护一个单独的<code class="fe nw nx ny nz b">master</code>分支，并从其维护单独的分支。这可以遵循以前的命名约定:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="bab7" class="nf mj it nz b gy oe of l og oh">ma<!-- -->ster/issue14/routing-service // <strong class="nz iu">team branch</strong><br/>irmerk/issue14/routing-service // <strong class="nz iu">my branch</strong><br/>someone/issue14/routing-service // <strong class="nz iu">someone else’s branch</strong></span></pre><p id="eb3f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">个人分支可以合并到<code class="fe nw nx ny nz b">master</code>团队分支，然后通过<a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9f99" rel="noopener">拉取请求</a>与整体<code class="fe nw nx ny nz b">master</code>合并。合并分支后删除它们。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3336" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">重设基底和挤压</h1><p id="2d29" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">团队通常的做法是在合并到<code class="fe nw nx ny nz b">master</code>之前，将长提交消息链压缩或浓缩成一个或几个提交。</p><p id="7f97" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这在像我这样的人频繁提交从而导致Git日志混乱的情况下非常有用。压缩用于维护一个可读的Git日志。</p><p id="ccc4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在将一个特征分支合并到主(<code class="fe nw nx ny nz b">master</code>)分支之前，它应该从最新的<code class="fe nw nx ny nz b">master</code>开始重设基础。</p><p id="dbb9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">稍后讨论的<a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9f99" rel="noopener">拉请求</a>将会把这个分支的所有提交压缩成一个可构建的提交，并合并成<code class="fe nw nx ny nz b">master</code>。</p><p id="6516" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">重定基础本质上是将一个分支(<code class="fe nw nx ny nz b">master</code>)移植到您当前的分支中，方法是在那个分支(<code class="fe nw nx ny nz b">master</code>)上应用您所有的提交，然后用修改后的版本替换您的分支。这通过在您的本地Git中重写Git历史来让您到达一个分支(<code class="fe nw nx ny nz b">master</code>)。</p><p id="b48a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">把它想象成把你的分支移到<code class="fe nw nx ny nz b">master</code>的顶端，而不是从早期版本的master中分支。</p><p id="1fac" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不需要从一个分支中仔细调查单个提交，每个对<code class="fe nw nx ny nz b">master</code>的合并提交应该包含一个特性或bug修复的所有代码。这使得调查过程更加容易。</p><p id="df83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然在重置基础之前挤压减少了冲突，因为冲突解决的步骤更少，但它确实改变了每个人在GitHub上记录的存储库历史，因此不是最准确的表示。</p><p id="1f43" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">压缩前的重置保持了Git日志的整洁，并且在GitHub上记录之前不会改变历史。</p><h2 id="0c49" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">交互式rebase</h2><p id="f9c5" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated"><code class="fe nw nx ny nz b">git rebase -i</code>在一些情况下非常有用，比如需要快速删除一个提交。</p><p id="bb5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您的团队有一个策略，其中任何特性提交都必须包含该特性的测试，那么将几个提交压缩成一个会很有帮助。</p><p id="ce07" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将涉及到<code class="fe nw nx ny nz b">git rebase -i HEAD~n</code>并用提交的数量替换<code class="fe nw nx ny nz b">n</code>——替换那些提交行上的<code class="fe nw nx ny nz b">pick</code>到<code class="fe nw nx ny nz b">squash</code>。</p><p id="eb24" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你的项目，比如Accord项目，需要一个<a class="ae lm" href="https://developercertificate.org/" rel="noopener ugc nofollow" target="_blank">开发者原产地证书</a>的签署，你可能会发现自己需要快速地改变一系列提交的信息。</p><p id="5784" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与之前类似，在需要更改的提交上，将<code class="fe nw nx ny nz b">pick</code>更改为<code class="fe nw nx ny nz b">edit</code>，对于每个提交，只需简单地使用<code class="fe nw nx ny nz b">git commit --amend -s</code>和<code class="fe nw nx ny nz b">git rebase --continue</code>。</p><p id="8d59" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nw nx ny nz b">git push -f</code>入分支为拉取请求。警告:如果使用不当，用力会导致可怕的后果，如果不确定如何使用，请咨询他人。</p><p id="d567" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般来说，如果你没有大的，令人困惑的冲突，<code class="fe nw nx ny nz b">-i</code>(交互式rebase)将是过度的。</p><h2 id="46d0" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">重写历史</h2><p id="ac6d" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">虽然用<code class="fe nw nx ny nz b">git rebase</code>重写历史在某些情况下非常有用，但还是要小心。不要打断别人的历史，不要无意中犯下错误。</p><p id="90b1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意:避免将他人正在操作的力推向远处的分支。</p><h2 id="3b31" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">害怕</h2><p id="8256" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">我仍然害怕<code class="fe nw nx ny nz b">rebase</code>和<code class="fe nw nx ny nz b">squash</code>。合并冲突可能更频繁，看起来也更困难。我有过由于不正确地调整基数而丢掉工作的经历。</p><p id="32eb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，如果你经常提交正在进行的工作，重定基础的复杂性应该很少。起初，解决冲突和<code class="fe nw nx ny nz b">git rebase --continue</code>会让你感到害怕，但是继续努力。</p><p id="fbfe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将在这些冲突的情况下进行合并提交，但这是如何解决冲突的重要历史。如果你觉得<code class="fe nw nx ny nz b">git rebase --abort</code>进行得不顺利，你可以随时再试一次——这将恢复到重设基础之前的状态。</p><h2 id="ceb4" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">流动</h2><p id="d2d4" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">我对一般工作流程的建议是:</p><ol class=""><li id="a381" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll oi lt lu lv bi translated">确保您当前在<code class="fe nw nx ny nz b">master</code>中。<br/> →如果在<strong class="ks iu">分支</strong>工作，取:<br/> <code class="fe nw nx ny nz b">git checkout master<br/>git fetch --all --prune<br/>git merge --ff-only upstream/master<br/>git push origin master</code> <br/> →如果在<strong class="ks iu">分支</strong>工作，拉:<br/> <code class="fe nw nx ny nz b">git checkout master<br/>git pull origin master</code></li><li id="e99e" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll oi lt lu lv bi translated">为你的特性或者bug修复创建一个新的分支<br/> <code class="fe nw nx ny nz b">git checkout -b branchName</code>。</li><li id="bba5" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll oi lt lu lv bi translated">根据需要尽可能多地进行更改。最终提交应该构建并通过测试。</li><li id="37d1" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll oi lt lu lv bi translated">确保你的分支位于<code class="fe nw nx ny nz b">master</code>的顶部(相对于从分支分出的分支)。这确保了评审者只需要很少的努力就可以通过快进<code class="fe nw nx ny nz b">master</code> <br/> <code class="fe nw nx ny nz b">git rebase upstream/master</code>来整合你的工作。</li><li id="2150" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll oi lt lu lv bi translated">如果您以前将代码推送到远程分支，则需要强制推。如果不是，省略<code class="fe nw nx ny nz b">-f</code>标签。<br/> <code class="fe nw nx ny nz b">git push origin branchName -f</code></li><li id="77be" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll oi lt lu lv bi translated">从这个分叉的分支在GitHub中打开一个pull请求。一旦这已经被合并到<code class="fe nw nx ny nz b">master</code>，记得在本地清除你的分支<br/> <code class="fe nw nx ny nz b">git branch -D branchName</code></li></ol><h2 id="6c6d" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">合并</h2><p id="aaea" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">作为一种非破坏性的操作，合并可能很好。但是，如果您正在处理的<code class="fe nw nx ny nz b">master</code>非常活跃，Git日志可能会很快被合并操作创建的额外提交所污染。</p><p id="d974" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然许多开发人员不喜欢改变基础，并在他们的变更上求助于合并，但是合并并不总是最好的选择。</p><p id="0f88" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果是本地合并而不是重基础，最起码要压扁一个pull请求合并到GitHub上的<code class="fe nw nx ny nz b">master</code>。这允许对Git日志的<code class="fe nw nx ny nz b">master</code>中的提交消息进行更好的控制。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d8b3" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">硬币指示器 （coin-levelindicator的缩写）命令行界面（Command Line Interface for batch scripting）</h1><p id="a8e0" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">命令行界面(CLI)是您可以运行所有<em class="oj">Git命令的地方。</em></p><p id="cb06" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Git图形用户界面(GUI)如<a class="ae lm" href="https://www.gitkraken.com/" rel="noopener ugc nofollow" target="_blank"> GitKraken </a>和<a class="ae lm" href="https://www.git-tower.com/" rel="noopener ugc nofollow" target="_blank"> Tower </a>都很棒。我选择不使用它们，因为它们是有价格的，而且网上找到的绝大多数涉及Git的解决方案都是针对CLI的。</p><p id="8e9f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，了解Git的CLI方法可以让您轻松地导航GUI，但反过来就不一定了。</p><p id="c799" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">学习通过CLI与Git和GitHub交互将会极大地利用您的时间，尤其是如果您从事开源项目的话。</p><h2 id="bce0" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">差速器</h2><p id="ac61" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">一个好习惯是在做任何事情之前利用<code class="fe nw nx ny nz b">git diff</code>。这允许您确保提交的代码是您所期望的，所有调试语句都被删除，并且没有垃圾代码。</p><h2 id="31b4" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">原木</h2><p id="2677" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">日志揭示了存储库中发生的所有事情的历史。这个工具有许多以特定方式显示提交历史的选项。</p><p id="a45b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">完整的日志包含提交散列、作者、日期和消息。我的首选构建日志记录方式是表示分支结构的ASCII图:</p><p id="248c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nw nx ny nz b">git log --graph --decorate --pretty=oneline --abbrev-commit</code></p><h2 id="8534" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">责备</h2><p id="06dc" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">一种检查谁在什么时候修改了文件的方法是<code class="fe nw nx ny nz b">git blame</code>。如果你在<a class="ae lm" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">和</a>中编码，我强烈建议你查看<a class="ae lm" href="https://gitlens.amod.io/" rel="noopener ugc nofollow" target="_blank"> GitLens </a>，这使得这种检查是内联的并且非常有效。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9617" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">承诺</h1><p id="66a0" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">在提交中应该捕获单个逻辑更改。提交中不止一个逻辑变化——在这种情况下，您可能会发现自己在一个提交消息中编写了“<em class="oj">和</em>”——这是一个很好的迹象，表明需要分成两个单独的提交。</p><p id="5902" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">经常承诺——不要让自己在没有承诺的情况下走得太远。小的、增量的和自包含的提交在将来更容易跟踪或恢复。</p><p id="78b6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然按逻辑顺序提交是最理想的，但我建议按你工作的顺序提交——这是你所做事情的时间顺序历史。</p><h2 id="26a5" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">信息</h2><p id="976c" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">花一点时间来完成这个过程——提交消息不应该太匆忙。</p><p id="6600" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">提交的描述应该被很好地记录下来，因此对于将来阅读这篇文章试图理解为什么要进行更改的人来说是非常宝贵的，即使他们几乎没有上下文。</p><p id="76a0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种可访问性对于完整的Git历史和工作流来说是一个至关重要的目标。</p><p id="d3ef" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">包括外部信息参考，如问题或拉式请求。任何对他人或未来的自己有帮助的事情，现在就应该推理出来。</p><p id="9ca9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">项目的长期成功依赖于代码和日志的可维护性。起初的争论会带来健康习惯的回报。</p><p id="91e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">编写提交消息时，使用终端，而不是编辑器。从终端提交鼓励以增量方式描述变更的思维模式，以及保持提交的原子性——提交不需要一段解释。</p><p id="2c9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将帮助您创建一个pull请求消息，其中应该捕获整体变更。稍后将详细介绍。</p><p id="10a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">应该通过始终将<code class="fe nw nx ny nz b">-m &lt;msg&gt;</code>标志包含到<code class="fe nw nx ny nz b">git commit</code>中来捕获简洁一致的提交消息。</p><h2 id="989d" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">格式化</h2><p id="99e4" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">一个格式正确的Git提交主题行应该总是能够完成下面的句子:</p><p id="b4c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果应用，这个提交将<code class="fe nw nx ny nz b">your subject line here</code>。</p><p id="e626" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nw nx ny nz b">type<strong class="ks iu">(</strong>scope<strong class="ks iu">): </strong>subject <strong class="ks iu">—</strong> footer</code></p><p id="1aa3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">类型</strong></p><ul class=""><li id="0e21" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">feat</code>——新功能。</li><li id="5747" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">fix</code> —一个bug修复。</li><li id="b309" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">docs</code> —仅更改文件。</li><li id="50b1" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">style</code> —对格式的更改(缺少分号等)。).</li><li id="cce4" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">refactor</code> —既不修复bug也不增加特性的代码变更。</li><li id="b88b" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">test</code> —添加缺失的或纠正现有的测试。</li><li id="667a" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated"><code class="fe nw nx ny nz b">chore</code> —改变建造过程或辅助工具，或维护。</li></ul><p id="8b11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">范围</strong>:</p><ul class=""><li id="906c" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">新代码或最佳描述的焦点，在哪里可以找到更改。</li></ul><p id="766d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">主题</strong>:</p><ul class=""><li id="77a9" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">变更的命令性描述，保持在50个字符以内(不大写，无句号)。</li></ul><p id="3b3e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">页脚</strong>:</p><ul class=""><li id="b2e5" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">GitHub问题参考ID。</li></ul><h2 id="ff6e" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9f99" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">拉取请求</h1><p id="60dd" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">拉取请求(PR)是共享信息的最佳方式之一。虽然问题描述了什么可能是错误的或者是一个特性，但是PR为代码库实际发生的变化提供了一个媒介。</p><p id="b49a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，它对于同行评审和责任也是极好的，因为它鼓励高质量的提交。如果做得好，构建PR的提交将向那些将来审查或检查代码的人讲述整个故事。</p><p id="4ef3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">PRs应由包含价值的代码的完整补充组成。因为内部的提交遵循一种模式，所以标题应该是内部所有提交的扩展或总结。</p><p id="9910" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，在前面，当我谈到挤压时，Git日志将保留每次提交的模式，即使在它被整理之后。需要强调的是，<em class="oj">PR标题应该遵循</em> <a class="ae lm" href="https://medium.com/@jolene.langlinais/f22d96b8b0b8#9617" rel="noopener"> <em class="oj">以上</em> </a> <em class="oj">所述的提交消息格式。</em></p><p id="d328" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一个GitHub工作流工具，PR的内部结构没有标题重要，保持格式的一致性和效率。这使得无论有没有GitHub，Git日志都可以保持高效。</p><p id="fba0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与提交类似，PRs应该很小。一个试图做多件事的PR(发现自己在标题中写了“<em class="oj">和</em>”？)应该是分了吧。</p><h2 id="26f9" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">清除</h2><p id="8fa0" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">如前所述，在创建PR之前重新调整基线是一个很好的整理习惯。</p><p id="d661" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">花一点时间合并过程中创建的任何额外的提交，或者为了清晰起见重新措辞提交。公关中的每一次提交都应该直接面向公关标题的目标，甚至是相关的GitHub问题。</p><h2 id="5f70" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">格式化</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="om on gj gh gi oo op bd b be z dk translated">GitHub PRs处于降价状态</p></figure><p id="05cd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请记住:这种改变对解决问题有什么作用，可能会有哪些副作用？为什么有必要？尝试先发制人的审查需要问问题，在你的信息彻底。</p><h2 id="cd53" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">草稿</h2><p id="21bf" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">GitHub为还没有准备好接受审查的公关提供了一个有用的选择。</p><p id="eb23" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你想在PR中有一个真实的来源供其他人交互，在实际审查之前，或者甚至只是为了确保代码保存在GitHub上，而不仅仅是在你的本地机器上，打开一个draft pull请求。</p><h2 id="60b3" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">复习</h2><p id="25a5" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">为公关审查设定一个标准很重要，同样重要的是要彻底。评审者是Git历史和代码质量的守护者。这一点怎么强调都不为过。</p><p id="8d89" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在看来显而易见的事情，在几个月或几年后肯定不会如此。不要因为要求改变或别人要求你改变而感到难过。最好将原始代码合并到<code class="fe nw nx ny nz b">master</code>中，而不是急于完成某个特性。</p><p id="4ca8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在通过PRs的流程和不阻碍进一步的编辑或制作以及保持质量之间取得平衡。每个审查者都应该判断某个问题是否足以阻止PR。</p><p id="d55b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，任何参与PR的人都不应该审查合并到<code class="fe nw nx ny nz b">master</code>中的内容。在这些角色之间保持健康的分离。一般来说，PR作者修复代码比评审人员参与更快。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9cac" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">开源代码库</h1><h2 id="3deb" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">问题</h2><p id="3d82" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">非常容易维护，问题应该被宽松地使用。任何问题、想法或bug——无论是否重复——都应该成为提出问题的足够理由。</p><p id="e30f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些是项目中对话的基础，所以插入观点并建立具体的讨论记录，以便搜索和链接。</p><p id="b79a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">说到这里，在打开一个问题之前搜索一个项目。虽然重复可以很容易地关闭，但这是对其他贡献者的一种礼貌。</p><p id="8d33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，要彻底，并提供尽可能多的背景。也许甚至花一点时间阅读项目的文档，他们可能有格式化问题的指导方针。</p><h2 id="7245" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">噪音</h2><p id="5f9e" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">注意你展示给别人阅读的内容。值得他们花时间吗？避免张贴简短、仓促的回答或回应。花点时间让你的贡献对自己和他人都有价值。</p><p id="d7b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">提供尽可能多的背景信息，同时仍然有所帮助。太少和太多的上下文都很糟糕。</p><p id="1515" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果已经过了相当长的时间，向审阅者发送一个温和的提示。很容易忘记一个活跃的公关。</p><h2 id="4358" class="nf mj it bd mk ng nh dn mo ni nj dp ms kz nk nl mu ld nm nn mw lh no np my nq bi translated">开源</h2><p id="18f5" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">我推荐这本<a class="ae lm" href="https://opensource.guide/how-to-contribute/" rel="noopener ugc nofollow" target="_blank">指南</a>为开源做贡献。</p><p id="3473" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GitHub提供了很好的功能，应该被开发人员用来获得最好的体验。</p><p id="f0c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">可以标记问题以方便导航，可以实施保护以防止直接提交给<code class="fe nw nx ny nz b">master</code>，并且可能需要多个审查者。</p><p id="9a1a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本指南旨在提供一个培养健康、协作氛围的框架。所有这些都可以应用于任何开源或专有的技术团队环境。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="630b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="3d57" class="pw-post-body-paragraph kq kr it ks b kt nr ju kv kw ns jx ky kz nt lb lc ld nu lf lg lh nv lj lk ll im bi translated">贡献你想看的作品。礼貌、尊重、彻底和效率都是我们欣赏的东西，所以用Git培养和保持良好的习惯，合作将是最好的。</p><p id="cc1c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感知在开源中很重要，其他人如何看待Git日志会有很大的不同。花点时间用高效的提交和Git礼仪来关心日志。对于一个公司和一个新员工来说也是如此。</p><p id="f094" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如有任何问题或反馈，请随时联系我。</p></div></div>    
</body>
</html>