<html>
<head>
<title>Building a Safe Multi-Tenant System With Rate Limiting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建具有速率限制的安全多租户系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-safe-multi-tenant-system-with-rate-limiting-6114e5df3f3d?source=collection_archive---------10-----------------------#2022-02-28">https://betterprogramming.pub/building-a-safe-multi-tenant-system-with-rate-limiting-6114e5df3f3d?source=collection_archive---------10-----------------------#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是限速，如何正确使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8780f0478403efedbf57c44394df271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eR7leMivf2m_dP5H6pVLsg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图为<a class="ae ky" href="https://unsplash.com/@mael_balland?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梅尔·巴兰德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/market?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="8f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动您的web服务后，您如何保护它免于过载？本文将讨论使用一种称为速率限制的常见技术来保护您的服务的选项。</p><p id="d9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有时想要阻塞请求有许多不同的原因。仅举几个例子:</p><ul class=""><li id="6e45" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们希望防止嘈杂的邻居问题，这样那些产生过多请求的流氓客户端就不会给其他客户端带来问题。</li><li id="a0df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">机器人正在攻击我们的公共终端，窃取数据，我们希望阻止它们。</li></ul><p id="2d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管是什么原因，在这篇文章中，我们将探讨如何实施速率限制来防止这些不必要的情况发生。</p><p id="6cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论三个主题:</p><ol class=""><li id="d27a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mj mb mc md bi translated">我们用什么来识别客户？</li><li id="229c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mj mb mc md bi translated">一些必须知道的限速算法；</li><li id="d642" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mj mb mc md bi translated">使用多台应用服务器进行纵向扩展。</li></ol><h1 id="cc26" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">限速目标</h1><p id="bea5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在讨论速率限制算法之前，我们必须知道如何识别用户——我们应该对谁进行速率限制？</p><h2 id="44c7" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">基于IP地址的速率限制</h2><p id="7105" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">IP地址是一个数字标签，我们用它来识别互联网上的设备。对我们来说，评估IP地址的限制听起来很自然。</p><p id="aca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是——有可能伪造IP地址吗？嗯，是的，但它不是微不足道的。</p><p id="4bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了客户端和服务器建立连接，客户端和服务器需要经历一个<a class="ae ky" href="https://www.geeksforgeeks.org/tcp-3-way-handshake-process/" rel="noopener ugc nofollow" target="_blank">三次握手过程</a>:</p><ol class=""><li id="216d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mj mb mc md bi translated">客户端向服务器发送一个<code class="fe nt nu nv nw b">SYN</code>包来开始连接</li><li id="5790" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mj mb mc md bi translated">服务器向客户机发回一个<code class="fe nt nu nv nw b">SYN-ACK</code>包，确认它已经准备好建立连接</li><li id="53d6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mj mb mc md bi translated">客户端收到包并发回另一个<code class="fe nt nu nv nw b">ACK</code>来启动连接</li></ol><p id="5d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤2的问题是，如果客户端使用假IP地址发起连接，则无法成功建立网络连接。</p><p id="2949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，欺骗IP地址仅用于<a class="ae ky" href="https://en.wikipedia.org/wiki/SYN_flood" rel="noopener ugc nofollow" target="_blank"> DOS攻击</a>，其目的是关闭服务，而不是窃取数据。这是一个独立的话题，我们今天不会在这里讨论。</p><p id="99d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于其他合法的用例，为什么不总是根据IP地址进行速率限制呢？</p><p id="4512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IP地址的另一个限制是它们不是唯一的。我们有众所周知的<a class="ae ky" href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion" rel="noopener ugc nofollow" target="_blank"> IPv4地址耗尽</a>问题。多个用户可以共享同一个IP地址。同一ISP(互联网服务提供商)背后的用户可以共享同一个公有IP。如果用户在VPN上，也会发生同样的情况。最后，对于移动用户，移动服务提供商也有一个有限的已知IP地址列表。</p><p id="5562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个原因，基于IP地址实现速率限制可能不太有效，因为IP不能唯一地识别单个用户，而是一小群用户。</p><h2 id="c4dc" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">基于用户ID的速率限制</h2><p id="4260" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">除了IP地址，我们还可以考虑基于用户ID的速率限制。</p><p id="269c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这只有在系统需要登录时才有意义。例如，如果用户要求通过第二因素身份认证登录，那么我们可以可靠地识别用户。但是如果我们有一个不需要用户认证的面向公众的API端点，那么这就不是一个选项。</p><h2 id="00d5" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">基于API密钥的速率限制</h2><p id="69d7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">对于关键服务，我们可以为每个客户分配一个API密钥。为每个API键分配不同的访问速率也很常见，例如每天300个请求。</p><p id="a1c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与用户id相比，使用API密钥会给用户带来更多的麻烦。因此，它也只对某些应用程序有意义。这些应用程序通常访问更有价值的数据或服务，它们通常带有价格标签。这里有几个例子:</p><ul class=""><li id="a6ef" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.mapbox.com/help/glossary/access-token/" rel="noopener ugc nofollow" target="_blank">用于地图和导航的Mapbox API </a></li><li id="a88b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://tinyurl.com/app/dev" rel="noopener ugc nofollow" target="_blank"> Tinyurl </a>用于网址缩短</li><li id="29eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://cloud.google.com/natural-language/docs/" rel="noopener ugc nofollow" target="_blank">云自然语言API </a>用于自然语言处理</li></ul><h1 id="1be9" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">速率限制算法</h1><p id="86e3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本节中，我们将讨论几种常用的速率限制算法、它们的差异和权衡:</p><ul class=""><li id="5591" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">固定窗口计数器</li><li id="f10b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">滑动原木</li><li id="73df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">滑动窗口计数器</li><li id="34d9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">令牌桶</li></ul><h2 id="8087" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">固定窗口计数器</h2><p id="cf8c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们为每个时间窗口的每个客户端记录一个计数器。每当er允许一个请求时，我们就撞击计数器，如果计数器达到极限，就阻塞请求。</p><p id="8f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个每5秒钟5个请求的例子。每个框代表一个客户端请求。绿色方框表示允许，而红色方框表示阻止。在时间5，当它进入新的时间窗口时，我们将计数器重置为0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d6afe82c47baed43f2a751cbf1c7068e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vTa9l_mXHhswXoznM0Bkww.gif"/></div></div></figure><h2 id="a1a5" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">滑动原木</h2><p id="ed59" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">不难看出，上面的固定窗口计数器算法并不是很准确。有两个明显的缺点:</p><ul class=""><li id="1af6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于具有持续高请求量的客户。请求可能在窗口开始时被允许；在窗户的尽头被挡住了。</li><li id="19b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于有峰值流量的客户，我们可能会在短时间内收到大量流量。例如，如果一个客户端在一个窗口结束时发出5个请求，在下一个窗口开始时发出5个请求，那么服务器可以在很短的时间内收到10个请求(2x)。</li></ul><p id="9986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以使用滑动日志算法。我们跟踪请求的时间戳列表，而不是跟踪计数器。</p><p id="8d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是同样的例子，每5秒钟5个请求。在时间5，日志计数器从5减少到3，因为前两个请求已经过期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6ed6a9d645ac7f34090e365e9f6804c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*a8WTBB1FeITLtuWrxbEhVw.gif"/></div></div></figure><p id="f605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与固定窗口计数器相比，这种方法的一个缺点是它需要更多的存储器。如果请求率非常高，那么使用这种方法可能没有意义。</p><p id="e0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有100万个客户端，我们希望允许每个客户端每天有1000个请求。不考虑哈希映射的开销，跟踪这些请求所需的内存为:</p><pre class="kj kk kl km gt ny nw nz oa aw ob bi"><span id="8d7f" class="nh ml it nw b gy oc od l oe of">1 million * 1 thousand * 4 bytes = 4 gigabytes.</span></pre><h2 id="b784" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">滑动窗口计数器</h2><p id="8c15" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了利用固定窗口和滑动窗口计数器的优点，我们可以使用这两者的混合方法。</p><p id="6ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续上一节的例子。我们可以将窗口(一天)分成24个更小的窗口，每个窗口代表一个小时。现在，我们只需要记录24个计数器，而不必为每个客户端记录1000个时间戳。</p><p id="c261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查我们是否应该允许新的请求，我们需要对所有的24个计数器求和，看看总和是否小于1千(极限)。</p><h2 id="2601" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">令牌桶</h2><p id="d927" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">令牌桶算法类似于上面的固定窗口计数器算法，固定窗口计数器向上计数，而令牌桶向下计数。</p><p id="2d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个客户端，我们创建一个带有令牌的桶。每有一个请求，我们就把令牌减一。当桶中不再有给定客户端的令牌时，我们阻塞请求。同时，代币以某个预定的速率被重新填充。</p><p id="ad6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个每2秒钟用2个代币重新装满一个桶的例子。桶的大小是5。有趣的是，对于固定窗口计数器和滑动日志，这种配置的有效率与上面的其他两个动画相同。它们都是1 QPS ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Queries_per_second" rel="noopener ugc nofollow" target="_blank">查询/秒</a>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/55caedf1bbba2ee4b48b06a953fa41e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jn50lYX_fLxjX_DPFgnlsA.gif"/></div></div></figure><p id="d152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，桶从未满过(有5个代币)。这是因为我们的请求率一直很高。想象一下，如果服务器停止接收请求一段时间，桶最终会被填满。桶的大小本质上控制了我们允许的流量峰值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/30675bdaf24e39c3e9b861a7c13ce573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2XEryfw_0BtA3bjoY67k0g.gif"/></div></div></figure><p id="d715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总体而言，令牌桶算法更加灵活。它也没有预先定义的窗口，因此可以更好地分散来自多个客户端的请求高峰。</p><p id="0d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，由于它需要更多的写操作来更新令牌计数，因此计算开销更大。</p><p id="1b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令牌桶算法在业界被广泛使用。例如，<a class="ae ky" href="https://www.youtube.com/watch?v=yvBR71D0nAQ" rel="noopener ugc nofollow" target="_blank"> DynamoDB使用令牌桶进行速率限制读取容量单位(RCU) </a>。</p><h1 id="9569" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">存储状态</h1><p id="2296" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在上面的讨论中，我们假设我们只有一个应用服务器，并将所有信息存储在内存中。在上一节中，我们假设我们只有一个应用服务器，并且我们将所有信息存储在该服务器的内存中。然而，在现实世界中，这种情况很少发生。在本节中，我们将讨论当我们有多台服务器时不同的纵向扩展选项。</p><h2 id="c958" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">在应用服务器中存储状态</h2><p id="1879" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">通常，我们在应用服务器前面有一个负载平衡器。负载平衡有多种方法。出于本文的目的，我们将讨论两个:</p><ul class=""><li id="726c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一系列</li><li id="b7dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">粘性会话</li></ul><p id="806f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于粘性部分的更多信息，在下面的AWS文档中有很好的解释:<a class="ae ky" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html" rel="noopener ugc nofollow" target="_blank">应用负载平衡器的粘性会话</a>。关于循环法和不同变体的更多信息，“谷歌网站可靠性工程”一书<a class="ae ky" href="https://sre.google/sre-book/load-balancing-datacenter/" rel="noopener ugc nofollow" target="_blank">第20章:数据中心的负载平衡</a>有更多有见地的细节。</p><p id="de40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这两种方法的区别在于请求是如何被路由的。如果我们有一个客户端发出1000个请求，我们有10台服务器。使用循环法，每台服务器大约会收到100个请求。使用粘性会话，来自该客户端的所有1000个请求都将被路由到同一个服务器。</p><p id="97da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于循环调度，一种方法是将限制除以服务器数量。例如，如果我们希望将客户端的速率限制在1000 QPS，而我们有10台服务器，则每台服务器可以独立地将客户端的速率限制在100 QPS。现在，这不会给我们确定的结果，因为一个请求可能被一个服务器阻止，被下一个服务器接受。然而，这是一个非常好的近似，我们仍然可以保持简单的实现。</p><p id="2cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果我们确实想保持计数器同步，我们可以考虑使用一些分布式消息队列、领导者-追随者架构、<a class="ae ky" href="https://en.wikipedia.org/wiki/Gossip_protocol" rel="noopener ugc nofollow" target="_blank"> gossip协议</a>等。</p><p id="83ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了粘性会话，就更简单了。我们可以继续将计数器存储在应用服务器中，因为理想情况下，每个服务器都处理来自客户端子集的请求。</p><h2 id="f304" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated"><strong class="ak">在外部数据存储器中存储状态</strong></h2><p id="33f3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">除了将数据存储在应用服务器中，我们还可以将信息存储在单独的数据存储中，比如<a class="ae ky" href="https://youtu.be/HnSb8DFU5UA" rel="noopener ugc nofollow" target="_blank"> Redis </a>。这样做有多种好处:</p><ul class=""><li id="95ae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">因为速率限制是一个独立的部分，所以更容易推理。</li><li id="bab7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果应用服务器停止运行，我们不会丢失任何数据。我们可以更准确地执行我们的限速政策。</li></ul><p id="6839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用外部存储也有其利弊。</p><ul class=""><li id="f40b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们引入另一个失败点。如果我们的外部存储存在连接问题，该怎么办？在这种情况下，我们应该阻止还是允许请求？</li><li id="7796" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这可能会导致延迟增加。网络调用比访问本地内存慢。最重要的是，让多个服务器访问相同的计数器，我们需要花更多的时间来处理竞争情况。</li></ul><h1 id="e43b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="97ca" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在这篇文章中，我们讨论了速率限制的各个方面。</p><p id="eb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们介绍了可用于识别客户机的不同属性:IP地址、用户ID和API密钥。这些都是站在客户的角度看问题。但是我们也可以从服务器的角度来考虑同样的问题——在性能开始下降之前，服务器可以承受多少负载？这通常被称为甩负荷。对于那些想了解更多的人，这里有一个关于这个主题的有趣帖子:<a class="ae ky" href="https://aws.amazon.com/builders-library/using-load-shedding-to-avoid-overload/" rel="noopener ugc nofollow" target="_blank">使用减载来避免过载</a>。</p><p id="7da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们讨论了4种速率限制算法，从最简单的固定窗口计数器到更复杂的令牌桶。为了完整起见，指出这里没有提到的另一种算法也很重要，即漏桶算法。它类似于令牌桶。对于那些有兴趣了解更多的人来说，<a class="ae ky" href="https://en.wikipedia.org/wiki/Leaky_bucket" rel="noopener ugc nofollow" target="_blank">维基百科对其进行了详尽的解释</a>。</p><p id="f06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们简要地讨论了我们可以采取的方法，以便在多个服务器之间扩展和协调速率限制工作。</p><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用分布式系统令人着迷的一点是，几乎没有绝对最优的解决方案。虽然这个话题从表面上看起来微不足道，但总会有取舍。</p><p id="48d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">限速的问题也是如此。到处都有多种选择。全面理解它们是很有用的，这样我们就可以为我们的应用选择最佳选项。</p><h1 id="fb58" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">下一步是什么</h1><p id="df24" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">想玩更多不同类型的速率限制算法？上面模拟的源代码发表在<a class="ae ky" href="https://github.com/yzhong52/RateLimitingAnimations" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。请随意更改配置，并更多地使用它们。</p><p id="8077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。感谢阅读，并希望它有所帮助！</p></div></div>    
</body>
</html>