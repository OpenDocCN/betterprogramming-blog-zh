<html>
<head>
<title>JavaScript ES2021 Features With Simple Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有简单示例的JavaScript ES2021特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-es2021-features-with-simple-examples-ada723b55355?source=collection_archive---------0-----------------------#2021-01-01">https://betterprogramming.pub/javascript-es2021-features-with-simple-examples-ada723b55355?source=collection_archive---------0-----------------------#2021-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript的最新进展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64a62e15c98b993d4dd871801fa36a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_WJbyOV8GaHKulGO2v4eew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/2021?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Waldemar Brandt </a>拍摄的照片</p></figure><p id="e3a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将了解2015年的ECMAScript特性:</p><ul class=""><li id="7291" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">ES2015又名ES6</li><li id="c990" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/javascript-es2016-features-with-examples-a41b7aead589" rel="noopener"> ES2016又名ES7 </a></li><li id="2f26" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/javascript-es2017-features-with-examples-877f8406e770" rel="noopener"> ES2017又名ES8 </a></li><li id="49b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/javascript-es2018-features-with-examples-30fda8ac50fa" rel="noopener"> ES2018又名ES9 </a></li><li id="4e31" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/twelve-es10-features-in-twelve-simple-examples-6e8cc109f3d3" rel="noopener"> ES2019又名ES10 </a></li><li id="2e54" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/javascript-es2020-features-with-simple-examples-d301dbef2c37" rel="noopener"> ES2020又名ES11 </a></li><li id="5ecf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">ES2021又名ES12</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ed95" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍</h1><p id="28c4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">ES2021是对应于2021年的ECMAScript版本。这个版本没有ES6 (2015)中出现的那么多新功能。但是，已经加入了一些有用的功能。</p><p id="dc33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文通过简单的代码示例介绍了ES2021提供的特性。这样不需要复杂的解释就能快速理解新特性。</p><p id="5f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有必要对JavaScript有一个基本的了解，才能完全理解所介绍的最好的。</p><p id="35fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2021中新增的JavaScript <strong class="lb iu"> </strong>特性有:</p><p id="780c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">➡️<code class="fe nn no np nq b">String.prototype.replaceAll</code><br/>➡️<code class="fe nn no np nq b">Promise.any</code><br/>➡️<code class="fe nn no np nq b">WeakRef</code><br/>➡️逻辑赋值运算符<br/> ➡️数字分隔符</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6191" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">String.protype.replaceAll</h1><p id="a538" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">目前，如果不使用全局regexp ( <code class="fe nn no np nq b">/regexp/g</code>)，就无法替换字符串中子字符串的所有实例。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="29ea" class="nv mr it nq b gy nw nx l ny nz">const fruits = '🍎+🍐+🍓+';<br/>const fruitsWithBanana = fruits.replace(/\+/g, '🍌');<br/>console.log(fruitsWithBanana); //🍎🍌🍐🍌🍓🍌</span></pre><p id="60fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串原型中增加了一个新的<code class="fe nn no np nq b">replaceAll</code>方法。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="423d" class="nv mr it nq b gy nw nx l ny nz">const fruits = '🍎+🍐+🍓+';<br/>const fruitsWithBanana = fruits.replaceAll('+', '🍌');<br/>console.log(fruitsWithBanana); //🍎🍌🍐🍌🍓🍌</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3c22" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">承诺。任何</h1><p id="083c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">Promise.any</code>一旦承诺兑现，就给你一个信号。这个和<code class="fe nn no np nq b">Promise.race</code>差不多，只不过<code class="fe nn no np nq b">Promise.any</code>不会在其中一个承诺拒绝的时候提前拒绝。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6dc9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">WeakRef</h1><p id="a6ba" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">WeakRef</code>提案包含两个主要的新功能:</p><ul class=""><li id="4a83" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用<code class="fe nn no np nq b">WeakRef</code>类创建对对象的弱引用</li><li id="6652" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<code class="fe nn no np nq b">FinalizationRegistry</code>类在对象被垃圾收集后运行用户定义的终结器</li></ul><p id="fa50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些接口可以独立使用，也可以一起使用，这取决于使用案例。</p><p id="c29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nn no np nq b">WeakRef</code>对象包含一个对象的弱引用，这个对象被称为它的<em class="oc">目标</em>或<em class="oc">引用对象</em>。对一个对象的<em class="oc">弱引用</em>是一个不阻止对象被垃圾收集器回收的引用。</p><p id="8054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">弱引用的主要用途是实现保存大型对象的缓存或映射，其中希望大型对象不会仅仅因为出现在缓存或映射中而保持活动状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="dd1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">FinalizationRegistry</code>提供了一种方法，当在注册表中注册的对象被<em class="oc">回收</em>(垃圾收集)时，请求在某个时间点调用<em class="oc">清理回调</em> ( <em class="oc">终结器</em>)。</p><p id="1b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您创建了传入回调的注册表:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="486f" class="nv mr it nq b gy nw nx l ny nz">const registry = new FinalizationRegistry(heldValue =&gt; {<br/>  // ....<br/>});</span></pre><p id="8901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过调用<code class="fe nn no np nq b">register</code>方法，传入对象及其保存的值，注册任何想要清理回调的对象:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c776" class="nv mr it nq b gy nw nx l ny nz">registry.register(theObject, "some value");</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b27d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">逻辑赋值运算符</h1><p id="1687" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">逻辑赋值运算符组合了逻辑运算符和赋值表达式。有两个新运算符:</p><ul class=""><li id="3fdc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">或或等于</li><li id="0fbb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">和等于</li></ul><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e902" class="nv mr it nq b gy nw nx l ny nz">// Or Or Equals<br/>|   a   |   b   | a ||= b | a (after operation) |<br/>| true  | true  |   true  |        true         |<br/>| true  | false |   true  |        true         |<br/>| false | true  |   true  |        true         |<br/>| false | false |   false |        false        |</span><span id="5cd7" class="nv mr it nq b gy od nx l ny nz">a ||= b<br/>// Equivalent to:<br/>a || (a = b);</span><span id="7ecc" class="nv mr it nq b gy od nx l ny nz">// And And Equals<br/>|   a   |   b   | a &amp;&amp;= b | a (after operation) |<br/>| true  | true  |   true  |        true         |<br/>| true  | false |   false |        false        |<br/>| false | true  |   false |        false        |<br/>| false | false |   false |        false        |</span><span id="3104" class="nv mr it nq b gy od nx l ny nz">a &amp;&amp;= b<br/>// Equivalent to:<br/>a &amp;&amp; (a = b);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ad0c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">数字分隔符</h1><p id="1df1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">该特性允许使用数字组之间的可视分隔来提高数值的可读性。</p><p id="0e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用下划线(_，U+005F)作为分隔符有助于提高数值的可读性:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ad89" class="nv mr it nq b gy nw nx l ny nz">1_000_000_000           // A billion<br/>101_475_938.38          // Hundreds of millions</span><span id="0757" class="nv mr it nq b gy od nx l ny nz">const amount = 12345_00;  // 12,345 (1234500 cents, apparently)<br/>const amount = 123_4500;  // 123.45 (4-fixed financial)<br/>const amount = 1_234_500; // 1,234,500</span><span id="d39c" class="nv mr it nq b gy od nx l ny nz">0.000_001 // 1 millionth<br/>1e10_000  // 10^10000 -- granted, far less useful / in-range...</span><span id="e806" class="nv mr it nq b gy od nx l ny nz"><br/>const binary_literals = 0b1010_0001_1000_0101;<br/>const hex_literals = 0xA0_B0_C0;<br/>const bigInt_literals = 1_000_000_000_000n;<br/>const octal_literal = 0o1234_5670;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a59a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="ee59" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript是一种活的语言，这对于web开发来说是非常有益的。自2015年ES6出现以来，我们一直在经历这种语言的蓬勃发展。在本文中，我们回顾了ES2021中出现的特性。</p><p id="979d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这些特性中的许多对于web应用程序的开发来说可能并不重要，但它们提供了以前只需技巧或大量赘述就能实现的可能性。</p></div></div>    
</body>
</html>