<html>
<head>
<title>Updating SwiftUI Views From Objective-C Using MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MVVM从Objective-C更新SwiftUI视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/updating-swiftui-views-from-objective-c-mvvm-9c4f38d6d9c8?source=collection_archive---------12-----------------------#2022-09-06">https://betterprogramming.pub/updating-swiftui-views-from-objective-c-mvvm-9c4f38d6d9c8?source=collection_archive---------12-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a38a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索非标准的情况</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1fc0266d1b3ee63c46fe79926e8c4907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MIYNYcm-Dq7MzzC0bECGA.jpeg"/></div></div></figure><p id="1987" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在互联网上，在Apple文档中，以及在Medium上，有大量关于SwiftUI的信息，如何从UIKit使用它，反之亦然。但是今天，让我们考虑一个在现实生活中并不常见的案例，它有助于反思iOS开发中的非标准情况。</p><p id="142a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任务:从Objective-C代码库显示SwiftUI视图。此外，当Objective-C模型应该是可观察的时，相应的SwiftUI应该被更新。</p><p id="7e75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果:当您从Home按下Sign In按钮时，View Controller应该被推送到一个SwiftUI视图，其中包含一个标题、文本字段和一个Sign In按钮。在编辑文本视图和按下登录按钮时，标题标签应该被更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/4217420954f2c38f2f46263dbb4b6bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*h1kZCuij8faEtLW77QLTTQ.gif"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">结果呢</p></figure><h1 id="d6fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h1><div class="mk ml gp gr mm mn"><a href="https://github.com/maxkalik/uikit-objc-to-swiftui" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">GitHub—maxkalik/ui kit-objc-to-swiftui:从Objective-C MVVM更新swift ui视图</h2><div class="mu l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kp mn"/></div></div></a></div><h1 id="79f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动MVVM+C项目</h1><p id="d2d9" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">从上面的链接克隆项目。存储库有一个start文件夹，其中有一个我们将要使用的初始项目。</p><p id="0951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个iOS应用程序是使用MVVM +协调员开发的。我同意使用这种架构来解释如何显示SwitUI视图并从Objective-C更新它们已经有点复杂了，但是我想说，这更像是一种我们需要坚持特定模式的真实情况。别担心，我们现在只有一个屏幕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/b1e03e858560f741c52d9412aa945d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itjLKbpiFTxxAcCYNVu8LQ.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">主屏幕</p></figure><p id="ef0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目的结构由几个实体组成:<code class="fe nh ni nj nk b">AppCoordinator</code>、<code class="fe nh ni nj nk b">Protocols</code>和MVVM模块。<code class="fe nh ni nj nk b">AppCoordinator</code>只有一个普通的应用协调员。对于协议，我决定在那里存储我们将在项目中使用的所有协议。并且模块组具有屏幕；目前，它只有一个带有黑色登录按钮的主屏幕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/586f312b9a235719a6e3b35bf55bc340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OobCU9sic7ZwTZMZWFVtXw.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">初始项目结构</p></figure><p id="2c08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">登录按钮使用了一个典型的协调者代表，我们必须从协调者那里准备显示SwiftUI登录视图的解决方案。但是在实现SwiftUI视图之前，让我们的任务稍微复杂一点。假设我们已经在Objective-C中实现了<code class="fe nh ni nj nk b">LoginViewModel</code>,并且不允许我们将其重构到Swift中。只有<code class="fe nh ni nj nk b">LoginView</code>应该在SwiftUI中实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/9c9effe5230f67e1730a541bb5f381c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50YlRBK2wyAhiQpiuqx0IQ.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">使用LoginViewModel的项目结构</p></figure><p id="d788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧。我们来看看<code class="fe nh ni nj nk b">LoginViewModel</code>。我们有三个<code class="fe nh ni nj nk b">NSString</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="56f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nh ni nj nk b">name</code>属性应该从SwiftUI TextView中存储。标题应在文本视图编辑中更改。<code class="fe nh ni nj nk b">buttonTitle</code>将是“登录”，方法<code class="fe nh ni nj nk b">buttonTap</code>将改变标题值。没什么疯狂的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="d03b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">桥接Swift文件</h1><p id="cdc6" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">是时候开始向我们的Objective-C项目添加Swift文件了。</p><p id="9ccb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转到文件新文件SwiftUI视图。当将这个文件保存到Modules/Login/Views/文件夹时，这将更好地保持项目结构。</p><p id="f8f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这之后，你会被要求创建桥接头，是的，我们需要这个。按创建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/3222464a7f502c84ab61d9f7395a2548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4YWUmf4GG8ktSv3tMXDng.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">创建桥接标题</p></figure><p id="db88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将在视图组中看到两个文件:<code class="fe nh ni nj nk b">LoginViewModel.swift</code>和<code class="fe nh ni nj nk b">UIKitObjCToSwiftUI-Bridging-Header.h</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/bec75304eb617440baadf77427425f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XF3X7sQObSD-CFjTuzaww.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">登录模块结构</p></figure><p id="8f9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建后最初的桥接头将为空。但是我们已经知道我们将要使用<code class="fe nh ni nj nk b">LoginViewModel.h</code>。所以我们需要导入这个头。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/6aa755c6ca0895ec1104bdef7e2c8418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SHmCv3lU5XaD2iIvIlEYg.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">桥接头文件</p></figure><p id="7619" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">桥接的最后一步是让我们的Objective-C文件看到Swift文件。因此，我们需要另一个导入，我们将在<code class="fe nh ni nj nk b">AppCoordinator.m</code>中这样做。但是过了一会儿。</p><h1 id="c489" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">SwiftUI视图和协调界面</h1><p id="e6a6" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">目前，我们不使用任何视图模型。我们只需要显示一个带有虚拟数据的纯SwiftUI视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="851b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了显示SwiftUI视图，我们需要使用<code class="fe nh ni nj nk b">UIHostingController</code>，它将在Objective-C世界中扮演<code class="fe nh ni nj nk b">UIViewController</code>的角色，因此，我们需要创建一个“接口”来连接<code class="fe nh ni nj nk b">AppCoordinator</code>和SwiftUI视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候过渡一下了，让客观-见斯威夫特。让我们在<code class="fe nh ni nj nk b">AppCoordinator.m</code>中导入我们的桥接头。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/ed5e1ebddac26918bc4114089b502813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zV80jBh95DI6LyixTRUF2Q.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">正在导入UIKitObjCToSwitUI-Swift标题</p></figure><p id="6d54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对了，别害怕。您会注意到自动完成功能不适用于该邮件头。这个文件的最后一部分应该是<code class="fe nh ni nj nk b">-Swift.h</code>。如果您对此不确定，请检查:</p><p id="b125" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建设置Swift编译器-通用目标-C生成的接口标题名称</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f2d6073b1ad1a80007bd2f4e8084386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWwxTlumz8q0NdgOHGs2qw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">目标-C生成的接口题头名称</p></figure><p id="b3ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在AppCoordinator中使用所有这些部分，以便更新<code class="fe nh ni nj nk b">(void)showLogin</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eba8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行构建。如果你做的都正确，在主视图控制器上点击登录按钮后，你会看到一个SwiftUI视图。</p><h1 id="a85f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Objective-C视图模型和视图模型接口</h1><p id="7aa9" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们需要使我们的视图模型在SwiftUI视图中可见，并且应该更新登录视图的标题。一个<code class="fe nh ni nj nk b">Implementation</code>将有点类似于<code class="fe nh ni nj nk b">Coordinator</code>接口，但是有一些额外的增强。</p><p id="15cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了统一我们的“可观察”解决方案，我们需要几个协议:<code class="fe nh ni nj nk b">ObservableNSObject</code>和<code class="fe nh ni nj nk b">ObservableNSObjectDelegate</code>。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">ObservableNSObject和ObservableNSObjectDelegate</p></figure><p id="ed77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">诀窍是使用这些协议来实现所有Objective-C模块的一致性，这将在SwiftUI和<code class="fe nh ni nj nk b">viewModelDidUpdate</code>方法中使用。对于视图模型中属性或方法的每次更新，他们都会这样做。</p><pre class="kg kh ki kj gt nr nk ns nt aw nu bi"><span id="6a94" class="nv lt iq nk b gy nw nx l ny nz">@interface LoginViewModel : NSObject &lt;ObservableNSObject&gt;</span></pre><p id="bc9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nh ni nj nk b">LoginViewModel.m</code>中，更新这些方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5c0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们准备了要更新的视图模型，所以让我们创建我们的视图模型接口，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3a8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">主要技巧是使用<code class="fe nh ni nj nk b">ObservableNSObjectDelegate</code>更新已发布的<code class="fe nh ni nj nk b">viewModel</code>。让我们使用这个视图模型界面来更新我们的<code class="fe nh ni nj nk b">LoginView</code>。我称之为可观察的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我们需要更新<code class="fe nh ni nj nk b">Coordinator</code>界面。如您所见，<code class="fe nh ni nj nk b">SwiftUIViewModelInterface</code>就像Objective-C视图模型和SiwftUI视图之间的中间件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e1ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nh ni nj nk b">AppCoordinator</code> <code class="fe nh ni nj nk b">showLogin</code>也应该用<code class="fe nh ni nj nk b">LoginViewModel</code>更新。当然，理想情况下，看到SwiftUI对象会很酷，但是Objective-C只看到UIKit的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="97e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。运行build，您可以看到它是如何工作的。您可以在项目资源库的<code class="fe nh ni nj nk b">final</code>文件夹中找到结果:<a class="ae oa" href="https://github.com/maxkalik/uikit-objc-to-swiftui/tree/master/final" rel="noopener ugc nofollow" target="_blank">https://github . com/maxkalik/ui kit-objc-to-swift ui/tree/master/final</a></p><h1 id="9866" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="d68d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在我看来，这个任务最好的部分是非标准的情况，我相信你很可能不会遇到这种情况。但是在Objective-C中使用SwiftUI的问题是存在的，为什么不尝试回答一下呢？</p><p id="2cc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我称之为——一项不舒服的任务。意思是这种任务让你很困惑，你一开始不知道具体怎么做这个。他们迫使你跳出框框思考，这会让你更专业。</p><pre class="kg kh ki kj gt nr nk ns nt aw nu bi"><span id="6477" class="nv lt iq nk b gy nw nx l ny nz"><strong class="nk ir">Want to Connect?</strong></span><span id="62a3" class="nv lt iq nk b gy ob nx l ny nz">Don't hesitate to follow me on <a class="ae oa" href="https://twitter.com/maxkalik" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span><span id="3bae" class="nv lt iq nk b gy ob nx l ny nz">I appreciate any suggestions or comments regarding my research and articles.</span></pre></div></div>    
</body>
</html>