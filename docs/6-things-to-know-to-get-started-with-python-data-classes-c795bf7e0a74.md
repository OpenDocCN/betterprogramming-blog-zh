# Python 数据类入门的 6 件事

> 原文：<https://betterprogramming.pub/6-things-to-know-to-get-started-with-python-data-classes-c795bf7e0a74>

## 在你的自定义类中去掉一些样板代码

![](img/f1e6646c26a1d9b5fb4de0c3235079d0.png)

Philipp Katzenberger 在 Unsplash 上拍摄的照片

数据是任何编程项目中最基本的元素。所有的程序都注定与数据有一定的交互。例如，如果你的项目是一个网站，你必须以用户友好的方式呈现数据(例如，文本和图像)。如果你的项目使用机器学习来预测金融趋势，你必须准备好你的模型可以学习的数据。

作为一种通用编程语言，Python 已经发展到拥有一套通用的工具来支持项目中的数据管理。在这些工具中，数据类是一种有用且易于掌握的技术。在本文中，我将向您介绍数据类模型，其中的主要亮点使您可以开始使用这个数据管理工具。

# 1.定义数据类

与数据类相关的功能在`dataclasses`模块中定义，它是标准 Python 库的一部分。这个模块最重要的元素是`dataclass`装饰器。下面的代码展示了我们如何使用自定义类的`dataclass`装饰器来管理餐馆的账单。

数据类示例

具体来说，我们使用`dataclass`装饰器来装饰我们正在定义的定制类。在定义的类中，我们指定属于该类的属性(数据类的术语字段)。

你可能会问我们为什么要费心使用`dataclass`装饰器。是因为这个装饰器可以帮我们去掉一些样板，比如`__init__`和`__repr__`。换句话说，在我们的定制类中使用这个装饰器，我们不需要实现这些函数——相反，装饰器会为我们处理这些，如下所示。

初始化和表示

如上所示，在没有明确定义初始化和表示方法的情况下，两者都是习惯性实现的。是不是很酷？

# 2.类型注释和默认字段值

在上面显示的数据类中，它的字段都有类型注释来清楚地表明它们的类型。毕竟，开发数据类主要是为了处理数据，我们明确数据类包含的数据类型是有意义的。

机械地说，数据类的字段需要有类型注释。否则，您的代码无法执行。在幕后，`dataclass` decorator 基于您的类的注释生成字段，可以使用`__annotations__`特殊方法检索这些字段。

```
>>> Bill.__annotations__
{'table_number': <class 'int'>, 'meal_amount': <class 'float'>, 'served_by': <class 'str'>, 'tip_amount': <class 'float'>}
```

另一件要注意的事情是，对于您为数据类定义的字段，您可以有默认值。您可能已经注意到了，`tip_amount`字段的默认值是 0.0。重要的是要知道，当您没有为所有字段定义默认值时，有默认值的字段应该在没有默认值的字段之后。您不想看到下面的错误。

```
@dataclass
... class SpecialBill:
...     table_number: int = 888
...     meal_amount: float
...     served_by: str
...     tip_amount: float = 0.0
... 
Traceback (most recent call last):
  ...some traceback info omitted
TypeError: **non-default argument 'meal_amount' follows default argument**
```

# 3.平等/不平等比较

除了初始化和表示方法之外，`dataclass` decorator 还为我们实现了与比较相关的功能。我们知道，对于一个常规的定制类，如果我们不定义比较行为，我们就不能在实例之间进行有意义的比较。考虑下面这个没有使用`dataclass`装饰器的定制类。

平等比较

如上所示，对于常规类，所有属性值都相同的两个实例被评估为不相等，因为默认情况下，这些自定义类实例通过它们的标识进行比较。在这种情况下，这两个实例是两个不同的对象，它们被认为是不相等的。

然而，对于数据类，这样的相等比较评估`True`。这是因为`dataclass`装饰器也会自动为我们生成`__eq__`特殊方法。具体来说，进行相等性比较时，假设这些实例中的每一个都是一个元组，该元组按照定义的顺序包含字段。因为两个数据类实例具有相同值的字段，所以它们被认为是相等的。

不等式比较怎么样，比如大于小于？通过为装饰器指定`order`参数，也可以使用`dataclass`装饰器，如下面的第 1 行所示。

不平等比较

类似于等式比较，数据类实例就像它们是这些字段的元组一样进行比较，并且它们按照字典顺序作为元组进行比较。为了验证概念，上面的代码只包含两个字段，正如您所看到的，比较结果是基于元组的顺序的。

# 4.可变性考虑

默认情况下，数据类的字段可以被修改，因此我们可以说数据类实例是可变的。这就是为什么有些人把数据类称为*可变命名元组*。考虑以下命名元组和数据类在可变性方面的对比。

命名元组与数据类

如上图，不能设置命名元组的属性。然而，我们可以用数据类实例来实现，这突出了支持数据类可变性的优点。

然而，数据可变性并不总是理想的。在某些情况下，您不希望您的数据是可变的。在这样的场景中，当您使用`dataclass`装饰器时，您可以考虑将`frozen`参数指定为`True`。下面是一个简单的例子。

冻结数据类实例

# 5.继承考虑

数据类的核心与其他常规自定义类具有相同的可扩展性。因此，如果我们有这样的需要，我们可以子类化一个数据类。

数据类子类化

如上面的代码片段所示，`dataclass`装饰器将考虑子类的基类字段。换句话说，从子类的初始化可以看出，它自动拥有基类和子类本身的字段签名。值得注意的是，顺序是基于定义顺序的——首先是基类的字段，然后是子类的字段，如果有多代子类，依此类推。

由于子类中这些字段的顺序以及数据类中有默认值的字段应该在没有默认值的字段之前的要求，这意味着如果一个基类有带默认值的字段，子类的添加字段也应该有默认值。否则，您可能会看到下面的错误—与我们之前看到的错误相同。

```
[@dataclass](http://twitter.com/dataclass)
... class BaseBill:
...     meal_amount: float = 20
... 
[@dataclass](http://twitter.com/dataclass)
... class TippedBill(BaseBill):
...     tip_amount: float
... 
Traceback (most recent call last):
  ... some traceback info omitted
TypeError: **non-default argument 'tip_amount' follows default argument**
```

# 6.具有默认值的可变字段

在上面的例子中，字段都是不可变的数据类型，比如 floats 和 strings。如果需要使用易变数据作为数据类的字段，该怎么办？考虑下面的代码片段，它涉及 Python 程序员可能会犯的一些错误。

可变默认值

上面的代码向您展示了当您的函数使用可变默认值时，您不能真正使用可变实例来设置默认值，因为这个对象将被所有没有指定参数的调用者共享。在上面的例子中，您可以看到，两个实例共享同一个底层列表对象，这导致了不希望的副作用。

在数据类的上下文中，问题是我们如何为可变字段指定默认值。我们不应该做下面的事情，并且会引发一个`ValueError`异常。

```
@dataclass
class IncorrectBill:
    costs_by_dish: list = []ValueError: **mutable default <class 'list'> for field costs_by_dish is not allowed: use default_factory**
```

错误消息告诉我们解决方案，这涉及到在我们指定字段时使用`default_factory`。下面的代码向您展示了它是如何工作的。

字段默认工厂

*   我们从`dataclasses`模块中导入了`field`函数。
*   在`field`函数中，我们将`list`指定为`default_factory`参数。本质上，该参数设置默认的工厂函数，这是一个在创建实例时使用的零参数函数。在这种情况下，`list`函数是 list 对象的构造方法，当我们调用`list()`时，它创建一个新的 list 对象。
*   正如您所看到的，在这两个实例中，它们都有不同的列表对象用于`costs_by_dish`属性，正如所预期的那样。

# 结论

在本文中，我们回顾了开始使用 Python 时应该知道的六个最基本的元素。本质上，它们对于存储数据非常有用，并且`dataclass` decorator 为我们处理了许多样板文件。与命名元组相比，它们更灵活，允许可变性。