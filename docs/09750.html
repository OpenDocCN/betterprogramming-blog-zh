<html>
<head>
<title>How To Make Parallel Async HTTP Requests in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python发出并行异步HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-parallel-async-http-requests-in-python-d0bd74780b8a?source=collection_archive---------1-----------------------#2021-10-06">https://betterprogramming.pub/how-to-make-parallel-async-http-requests-in-python-d0bd74780b8a?source=collection_archive---------1-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e416" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用线程的请求与使用信号量的aiohttp</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/647cdc0e236915198b95b89f801c3295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*se5zv2v1vhMYWgPg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马特·邓肯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fdb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过阅读这篇文章，您将学会用Python并发地发出多个异步请求。本教程涵盖了两种不同的方法:</p><ul class=""><li id="5973" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过带有线程的请求包(每个请求一个本地线程)</li><li id="c587" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过带有信号量的aiohttp客户端(限制和共享任务的数量)</li></ul><p id="e9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种实现都受到了以下<a class="ae ky" href="https://blog.jonlu.ca/posts/async-python-http" rel="noopener ugc nofollow" target="_blank">博客文章</a>中的解释的启发。作者提供的代码样本是为了在Jupyter Notebook上运行，它自带事件循环，不需要调用<code class="fe mj mk ml mm b">asyncio.run</code>。在本教程中，将对代码进行清理和修改，使其能够在Python文件中工作。</p><p id="78cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们将实现自己的服务器，而不是调用外部API。因此，您可以根据自己的意愿轻松增加或减少并发请求的数量。</p><p id="02b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一部分，开始安装必要的模块。</p><h1 id="12cc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">设置</h1><p id="c76b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">强烈建议您在继续安装之前创建一个新的虚拟环境。</p><h2 id="5730" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">aiohttp</h2><p id="731b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">激活它并运行以下命令来安装<code class="fe mj mk ml mm b">aiohttp</code>:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="8c37" class="nk mo it mm b gy oa ob l oc od">pip install aiohttp[speedups]</span></pre><p id="4ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将自动为您安装所有必需的组件和依赖项。这包括:</p><ul class=""><li id="ddbd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">aiodns</code></li><li id="9740" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">chardet</code></li><li id="b879" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">brotlipy</code></li></ul><h2 id="403e" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">要求</h2><p id="a467" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">确保你的虚拟安装了<code class="fe mj mk ml mm b">requests</code>包。如果没有，请按如下方式安装:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="f44f" class="nk mo it mm b gy oa ob l oc od">pip install requests</span></pre><h1 id="537c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">模拟服务器</h1><p id="0cb8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们首先创建一个名为<code class="fe mj mk ml mm b">mockup_server.py</code>的新Python文件。它充当模型API服务器。实现将基于<code class="fe mj mk ml mm b">aiohttp</code>。</p><h2 id="e97c" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">导入</h2><p id="8076" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">从<code class="fe mj mk ml mm b">aiohttp</code>导入web模块并实例化一个新的<code class="fe mj mk ml mm b">RouteTableDef</code>对象:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="8b23" class="nk mo it mm b gy oa ob l oc od">from aiohttp import web</span><span id="6ba7" class="nk mo it mm b gy oe ob l oc od">routes = web.RouteTableDef()</span></pre><p id="b271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，定义一个新函数并用<code class="fe mj mk ml mm b">route.get</code>修饰它，如下所示:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="8310" class="nk mo it mm b gy oa ob l oc od">@routes.get('/user/{id}')<br/>async def user(request):<br/>    id = request.match_info.get('id', 0)<br/>    data = {'id': int(id)}<br/>    return web.json_response(data)</span></pre><p id="755b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将使用名为<code class="fe mj mk ml mm b">id</code>的路径参数来处理所有传入的对<code class="fe mj mk ml mm b">/user/</code> url的请求。随后，它将向用户返回一个JSON响应。</p><p id="43e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，定义<code class="fe mj mk ml mm b">Application</code>对象并调用<code class="fe mj mk ml mm b">run_app</code>函数，如下所示:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="4e90" class="nk mo it mm b gy oa ob l oc od">app = web.Application()<br/>app.add_routes(routes)</span><span id="042c" class="nk mo it mm b gy oe ob l oc od">if __name__ == '__main__':<br/>    web.run_app(app)</span></pre><p id="e72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存文件并运行服务器:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="3b96" class="nk mo it mm b gy oa ob l oc od">python mockup_server.py</span></pre><p id="da0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会在控制台上看到以下输出:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="cc07" class="nk mo it mm b gy oa ob l oc od">======== Running on <a class="ae ky" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080</a> ========<br/>(Press CTRL+C to quit)</span></pre><p id="f4ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，它将服务于端口8080，并可通过以下方式访问:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="e61d" class="nk mo it mm b gy oa ob l oc od"># IP<br/>http://0.0.0.0:8080</span><span id="102e" class="nk mo it mm b gy oe ob l oc od"># localhost<br/>http://localhost:8080</span></pre><h1 id="2688" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">方法1:使用线程的请求</h1><p id="a0dc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本节中，您将实现一个具有以下特性的测试脚本:</p><ul class=""><li id="72ef" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个<code class="fe mj mk ml mm b">Worker</code>类，作为单个线程执行来自给定任务队列的任务</li><li id="55d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<code class="fe mj mk ml mm b">ThreadPool</code>类表示使用队列中任务的线程池</li><li id="a9b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过<code class="fe mj mk ml mm b">requests</code>模块调用HTTP API的函数</li><li id="c635" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用40个工人实例化一个<code class="fe mj mk ml mm b">ThreadPool</code>对象以调用1000个API请求的代码</li></ul><p id="0785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数代码片段取自JonLuca的博客上创建的第二代实现。</p><h2 id="0f74" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">导入</h2><p id="e60c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们首先创建一个名为<code class="fe mj mk ml mm b">test_requests.py</code>的新Python文件。将以下导入语句追加到文件的顶部:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="c0dd" class="nk mo it mm b gy oa ob l oc od">from queue import Queue<br/>import requests<br/>from threading import Thread<br/>import time</span></pre><h2 id="5499" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">工人阶级</h2><p id="3a57" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">继续添加下面的<code class="fe mj mk ml mm b">Worker</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="56f3" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">线程池类</h2><p id="fff8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">你将需要另一个类作为<code class="fe mj mk ml mm b">ThreadPool</code>。实现应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="85bc" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">HTTP GET函数</h2><p id="978e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">之后，创建一个名为<code class="fe mj mk ml mm b">get</code>的新函数，负责通过<code class="fe mj mk ml mm b">requests</code>模块进行HTTP GET调用。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="5deb" class="nk mo it mm b gy oa ob l oc od">def get(url):<br/>    i = url.split('/')[-1]<br/>    r = session.get(url)<br/>    results[i] = r.json()</span></pre><h2 id="a2c7" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">主代码</h2><p id="da90" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用以下代码片段为您的Python脚本添加最后一笔:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="236b" class="nk mo it mm b gy oa ob l oc od">urls = [f"http://localhost:8080/user/{i}" for i in range(1000)]<br/>pool = ThreadPool(40)<br/>results = {}<br/>session = requests.session()</span><span id="cf61" class="nk mo it mm b gy oe ob l oc od">now = time.time()<br/>pool.map(get, urls)<br/>pool.wait_completion()<br/>time_taken = time.time() - now</span><span id="c536" class="nk mo it mm b gy oe ob l oc od">print(time_taken)</span></pre><ul class=""><li id="ecc1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在列表中创建1，000个URL</li><li id="69a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用40个线程初始化一个线程池对象</li><li id="ccde" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">初始化一个<code class="fe mj mk ml mm b">requests.session</code>对象</li><li id="4f57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将所有任务添加到队列中，并开始异步运行它们</li><li id="76f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">等待所有任务完成，并打印出总时间</li></ul><p id="7132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下<a class="ae ky" href="https://gist.github.com/wfng92/76f3ea11ad185bc073b7b8c004baaf7a" rel="noopener ugc nofollow" target="_blank">要点</a>中找到完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="fe65" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">运行测试</h2><p id="b3b7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">保存文件并打开一个新的终端。确保您的模拟服务器正在后台运行。然后，在您的终端上运行以下命令:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="73ca" class="nk mo it mm b gy oa ob l oc od">python test_requests.py</span></pre><p id="cfbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它需要几秒钟的时间，您应该会看到一个浮点值作为输出，指示运行1，000个HTTP请求所用的总时间。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="5d8c" class="nk mo it mm b gy oa ob l oc od">5.294068336486816</span></pre><h1 id="de65" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">方法2:带有信号量的aiohttp</h1><p id="76a7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们创建另一个使用带有信号量的<code class="fe mj mk ml mm b">aiohttp</code>的测试脚本。实现的结构如下:</p><ul class=""><li id="e14a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用<code class="fe mj mk ml mm b">n</code>线程实例化信号量并通过<code class="fe mj mk ml mm b">asyncio.gather</code>等待任务的函数</li><li id="5b5c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过<code class="fe mj mk ml mm b">aiohttp</code>模块调用HTTP API的函数</li><li id="80af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用40个线程实例化<code class="fe mj mk ml mm b">aiohttp.ClientSession </code>并调用1000个API请求的主函数</li><li id="4371" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过<code class="fe mj mk ml mm b">asyncio.run</code>运行主要功能的代码</li></ul><p id="d67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码片段取自JonLuca的博客上创建的第三代实现，并进行了相应的修改。</p><h2 id="29e6" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">导入</h2><p id="45a1" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">用下面的import语句创建一个名为<code class="fe mj mk ml mm b">test_aiohttp.py</code>的新文件:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="34d3" class="nk mo it mm b gy oa ob l oc od">import asyncio<br/>import aiohttp<br/>import time</span></pre><h2 id="feb5" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">信号量的帮助函数</h2><p id="881d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">下一步是创建一个新函数，用n个线程实例化一个信号量实例。请注意，信号量会限制一次可以执行的任务数量。此外，使用信号量会有额外的开销，但是使用池化是一个很好的做法。</p><p id="c4b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将调用<code class="fe mj mk ml mm b">gather</code>函数，基于任务并发运行一个合适的对象，并在所有任务完成后返回结果；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="8e9b" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">HTTP GET函数</h2><p id="7311" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">然后，创建一个名为<code class="fe mj mk ml mm b">get_async</code>的新函数。该函数负责通过<code class="fe mj mk ml mm b">aiohttp</code>进行HTTP GET调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="4da6" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">主代码</h2><p id="14f2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">主要功能的实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将生成1000个URL，并用40个线程调用<code class="fe mj mk ml mm b">gather_with_concurrency</code>函数。随后，它将打印出所用的总时间，并关闭会话连接。最后一点就是用<code class="fe mj mk ml mm b">asyncio.run</code>执行主功能。</p><p id="b2d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码位于以下<a class="ae ky" href="https://gist.github.com/wfng92/2d2ae4385badd0f78612e447444c195f" rel="noopener ugc nofollow" target="_blank">要点</a>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="ee73" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">运行测试</h2><p id="7bbf" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">保存文件并在终端上运行以下命令:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="9213" class="nk mo it mm b gy oa ob l oc od">python test_aiohttp.py</span></pre><p id="89ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到下面的输出，显示处理1，000个请求所用的总时间。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="195c" class="nk mo it mm b gy oa ob l oc od">0.35976457595825195</span></pre><p id="0498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:我做了一个实验，用FastAPI框架替换模型服务器，当使用aiohttp和Semaphore时，总时间大约是2.5秒。对于有线程的请求，花费的时间几乎是两倍。</p><h1 id="ac99" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="776b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们回顾一下你今天所学的内容。</p><p id="92ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文首先概述了运行并行异步HTTP请求的两种方法。</p><p id="6621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，它通过<code class="fe mj mk ml mm b">pip install</code>转移到安装过程，并提供了对服务器模型实现的解释。</p><p id="9b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它深入探讨了如何通过带有线程的请求来调用模型服务器。随后，它介绍了第二种方法，这种方法使用了带有信号量的<code class="fe mj mk ml mm b">aiohttp</code>。</p><p id="c258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。祝你有美好的一天！</p><h1 id="b22f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">参考</h1><ol class=""><li id="97e2" class="lv lw it lb b lc nf lf ng li oh lm oi lq oj lu ok mb mc md bi translated"><a class="ae ky" href="https://blog.jonlu.ca/posts/async-python-http?ref=rpr" rel="noopener ugc nofollow" target="_blank"> JonLuca的博客——用Python编写快速异步HTTP请求</a></li><li id="e2cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ok mb mc md bi translated"><a class="ae ky" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp —官方文件</a></li><li id="adc4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ok mb mc md bi translated"><a class="ae ky" href="https://docs.python-requests.org/en/master/index.html" rel="noopener ugc nofollow" target="_blank">请求——正式文件</a></li></ol></div></div>    
</body>
</html>