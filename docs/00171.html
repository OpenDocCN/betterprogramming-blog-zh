<html>
<head>
<title>Networking in Swift the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以正确的方式快速联网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/networking-in-swift-the-right-way-17cd34d11b7b?source=collection_archive---------0-----------------------#2018-08-11">https://betterprogramming.pub/networking-in-swift-the-right-way-17cd34d11b7b?source=collection_archive---------0-----------------------#2018-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">正确检索资源的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8d985d321b211088588fe980539c745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jp3LTM5eUP2OFWtx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="27d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于网络的初级读本，讲述了检索资源的正确方法。</p><p id="7bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想把资源分成三组，从离你的应用最近的资源开始，这将为你接下来的文章提供参考点。</p><ol class=""><li id="a546" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">应用程序资源-应用程序项目中包含的资源。它们可能位于一个<code class="fe me mf mg mh b">.xcassets</code>文件夹或一个通常命名的resources文件夹中。</li><li id="0b0a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">本地资源-运行应用程序的设备上的资源。在iOS中，这将是应用程序的沙箱；在macOS上，这将是应用程序在电脑上可以到达的所有允许的位置。</li><li id="9c4f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">远程资源—存在于其他地方的资源，如网站或您家中的另一台计算机。</li></ol><p id="f0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那些讨厌我说网站而不是URL或API的人来找我之前，我想提一下URL代表“统一资源定位器”,它甚至存在于本地文件和路径中。API，“应用程序编程接口”也不一定是远程资源。广告拦截器可能会使用Safari的API来拦截广告。</p><p id="1aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义说够了，让我们从一个我经常看到的例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，所有这些看起来都不错。我们首先使用URL字符串创建我们的<code class="fe me mf mg mh b">imageURL</code>。因为<code class="fe me mf mg mh b">Data:contentsOf</code>可以抛出一个错误，所以我们用<code class="fe me mf mg mh b">try/catch</code>语句将它括起来。</p><p id="86bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们没有抛出错误，我们可以在屏幕上显示图像。否则，我们会向控制台显示一条错误消息。</p><p id="e383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上是可行的，但是，这被认为是执行网络调用的错误方式。为什么？让我们参考文档。</p><div class="mp mq gp gr mr ms"><a href="https://developer.apple.com/documentation/foundation/nsdata/1407864-init" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">init(contents of:options:)—ns data | Apple开发者文档</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">不要使用这种同步方法来请求基于网络的URL。对于基于网络的网址，这种方法可以阻止…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">developer.apple.com</p></div></div></div></a></div><blockquote class="nb nc nd"><p id="9c76" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">不要使用这种同步方法来请求基于网络的URL。对于基于网络的URL，这种方法在慢速网络上可以阻塞当前线程数十秒，导致用户体验不佳，而在iOS中，可能会导致你的app被终止。</p></blockquote><p id="74bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来不吉利。因为它是一个同步方法，意味着它使用主队列，所以它可以阻塞你的主线程。现在你可能会说，“但是我的图像只有几KB大小，应该没什么大不了的。”让我问一下，如果你试图在一个非常慢的网络上下载那个文件呢？如果你的手机信号不好怎么办？</p><p id="4e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的用户界面可能会有一秒钟无法使用，如果这种情况经常发生，这足以让你得到差评。</p><p id="31a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果你只知道怎么做，那么当你通过同样糟糕的连接下载一个50 MB的文件时，你会怎么做呢？如果你需要50 MB来向用户展示你的游戏的新水平呢？<code class="fe me mf mg mh b">Data:contentsOf:</code>还不够，因为一旦用户结束应用程序，数据就会丢失。它不会存储部分数据，并在您的应用程序恢复时神奇地恢复。</p><p id="fc0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一重任正是Swift网络库的用武之地。</p><p id="b137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不允许我轻描淡写<code class="fe me mf mg mh b">Data:contentsOf:</code>，它有它的位置，而且很精彩。此方法仅适用于本地和应用程序资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><blockquote class="nb nc nd"><p id="08d0" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果你想在你的应用之外获取本地系统资源，你需要关闭沙盒。</p></blockquote><p id="cb44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想尝试上面的例子，只需创建一个新的playground，并在playground的resources文件夹中放置一个名为wishlist.txt的文件，其中包含您的愿望列表。</p><p id="550a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们讨论了本地文件，T2是处理远程资源的错误方式，但是什么是正确的方式呢？</p><p id="68b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确的做法是使用<code class="fe me mf mg mh b">URLSession</code>。<code class="fe me mf mg mh b">URLSession</code>提供了一个很好的实用程序库来帮助你下载文件和跟踪请求。让我们从上面看一个使用亚瑟猫的简单实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有新的内容要介绍。首先，我们创建一个会话，而不是使用默认的实现。虽然我可以直接使用<code class="fe me mf mg mh b">URLSession.shared.dataTask</code>键，但我选择了创建会话。这样，我就可以随时选择在以后定制连接属性。这是我个人的喜好。</p><p id="4481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关共享会话的更多信息，请参阅Apple的文稿。</p><div class="mp mq gp gr mr ms"><a href="https://developer.apple.com/documentation/foundation/urlsession/1409000-shared" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">共享— URLSession | Apple开发者文档</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">通常，在使用共享会话时，应该避免自定义缓存、cookie存储或凭据…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">developer.apple.com</p></div></div></div></a></div><p id="e543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须创建一个任务。该任务负责下载文件和处理响应。任务本身是一个闭包，但是我们使用尾随闭包语法并将<code class="fe me mf mg mh b">(data, response, error)</code>传递给闭包。这些都是可选值，如果您使用Xcode，自动完成功能会指出这些是可选的。<code class="fe me mf mg mh b">data</code>是我们期望从远程位置接收的数据，<code class="fe me mf mg mh b">response</code>是我们接收的响应头信息，<code class="fe me mf mg mh b">error</code>仅在发生错误时填充。</p><p id="fef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在闭包内部，我们首先检查是否收到了错误。该错误与客户端或服务器错误无关，而是设备通信错误，例如设备处于飞行模式。</p><blockquote class="nb nc nd"><p id="f1de" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">如果我们从服务器收到404-Page Not found消息，即使数据检索不成功,<code class="fe me mf mg mh b"><em class="it">URLSession</em></code>仍会认为呼叫成功。这就是错误与响应分开的原因。</p></blockquote><p id="178c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有收到错误，那么我们可以继续，首先检查以确保我们收到了状态代码200。<code class="fe me mf mg mh b">URLResponse</code>类型不包含状态代码属性，但是<code class="fe me mf mg mh b">HTTPURLResponse</code>包含。更好的是<code class="fe me mf mg mh b">URLResponse</code>可以被转换成<code class="fe me mf mg mh b">HTTPURLResponse</code>，这样我们就可以访问状态代码了。</p><p id="919f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">200 — OK不是我们可以检查的唯一好的响应代码，但它是最受欢迎的。要获得完整的参考资料，可以参考以下资源。这个很不错。</p><div class="mp mq gp gr mr ms"><a href="https://www.restapitutorial.com/httpstatuscodes.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">HTTP状态代码</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">HTTP状态代码以及如何在RESTful API或Web服务中使用它们。</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.restapitutorial.com</p></div></div></div></a></div><p id="e1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们期望得到一个状态码200，所以这是我们唯一需要检查的。如果我们想要检查更多，我们可以创建一个我们想要检查的所有状态代码的数组，例如:</p><pre class="kj kk kl km gt ni mh nj nk aw nl bi"><span id="639f" class="nm nn it mh b gy no np l nq nr">let acceptableCodes = [200, 201, 202, 203, 304]</span></pre><p id="148a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用以下内容检查状态:</p><pre class="kj kk kl km gt ni mh nj nk aw nl bi"><span id="3a5a" class="nm nn it mh b gy no np l nq nr">if acceptableCodes.contains(httpResponse.statusCode) { ... }</span></pre><p id="736f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们根据需要向数组中添加更多可接受的代码，从而简化我们未来的更改。</p><p id="1979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，因为<code class="fe me mf mg mh b">data</code>是可选的，我们需要将<code class="fe me mf mg mh b">data?</code>展开成我们可以立即使用的东西。我将<code class="fe me mf mg mh b">data</code>解包到<code class="fe me mf mg mh b">receivedData</code>中，这给了我们非可选的数据，万一<code class="fe me mf mg mh b">data</code>仍然为零，我们不会让程序崩溃。</p><p id="693c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用我们展开的数据，我们可以将<code class="fe me mf mg mh b">imageView</code>的<code class="fe me mf mg mh b">image</code>属性设置为<code class="fe me mf mg mh b">receivedData</code>的一个<code class="fe me mf mg mh b">UIImage</code>表示。因为这是UI工作，所以我们需要在主队列上完成:</p><pre class="kj kk kl km gt ni mh nj nk aw nl bi"><span id="7c6e" class="nm nn it mh b gy no np l nq nr">DispatchQueue.main.async {<br/>    imageView.image = UIImage(data: receivedData)<br/>}</span></pre><p id="3e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。</p><p id="6556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下载文件之前，还需要做一件事。</p><p id="17bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们创建一个负责下载文件的任务吗？这个任务有一个与之相关联的方法叫做<code class="fe me mf mg mh b">resume()</code>。<code class="fe me mf mg mh b">resume()</code>告知任务执行本次下载任务。我们需要调用这个方法来真正开始下载过程。</p><p id="635c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这样做似乎很麻烦，请考虑一下这为您的应用程序提供了多大的灵活性。您可以创建您的下载任务，然后在合适的时间调用它们，或者您可以创建一个通用的下载任务，并将其用于多个调用，对多个远程资源重用同一个下载任务。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="87cc" class="nz nn it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">摘要</h1><p id="ab10" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">当谈到<code class="fe me mf mg mh b">URLSession</code>时，我们可以展开更多的讨论，但这只是对下载文件的正确方法的简单介绍，而不是认为<code class="fe me mf mg mh b">data:contentsOf:</code>就是这样做的。</p><p id="bfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">URLSession</code>还提供代理，这样你就可以允许你的用户暂停、继续和停止下载，就像用户在使用Apple Music、App Store甚至观看视频时一样。</p><p id="b3e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至还有一个后台任务选项，允许你继续下载文件，即使应用程序已经被推到后台(而不是当用户强制退出应用程序)。</p><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于开发中的快速一次性测试(例如，弄清楚收到的JSON的格式)，使用<code class="fe me mf mg mh b">Data:contentsOf:</code>就可以了，但是对于生产环境，对于远程数据，您应该总是使用<code class="fe me mf mg mh b">URLSession</code>。</p></div></div>    
</body>
</html>