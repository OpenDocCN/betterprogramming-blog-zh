<html>
<head>
<title>Go Reactive With Angular Async Pipe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与角度异步管道反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/go-reactive-with-angular-async-pipe-b290988f4000?source=collection_archive---------6-----------------------#2022-05-04">https://betterprogramming.pub/go-reactive-with-angular-async-pipe-b290988f4000?source=collection_archive---------6-----------------------#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="da5d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">有角度的</a></h2><div class=""/><div class=""><h2 id="c8aa" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">订阅模板中的一个<code class="fe ko kp kq kr b">Observable</code>或<code class="fe ko kp kq kr b">Promise</code>并获取它发出的最新值</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/f5d999ea4eaf28c63cb06e3a5e1551a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4L-CiZGnwBsfywLZOtcb9A.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">根据<a class="ae li" href="https://unsplash.com/@roma_kaiuk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Roma Kaiuk </a>在<a class="ae li" href="https://unsplash.com/s/photos/pipe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片建造的角形管道</p></figure><p id="4009" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们可以使用Angular异步管道从模板中访问一个可观察对象或一个承诺。</p><p id="088a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae li" href="https://angular.io/api/common/AsyncPipe#description" rel="noopener ugc nofollow" target="_blank"> angular文档</a>很好地描述了异步管道:“<em class="mf">异步管道订阅一个可观察或承诺，并返回它发出的最新值。</em>”。</p><p id="ee0c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我将在这里展开一点:</p><ul class=""><li id="d113" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated">当组件初始化时，异步管道订阅一个可观察的或承诺。</li><li id="99ab" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">它返回承诺发出的或可观察到的每个值。</li><li id="b67f" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">当发出一个新值时，异步管道标记要检查更改的组件。它运行更改检测来相应地更新UI。</li><li id="6a20" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">当组件被破坏时，异步管道会自动取消订阅，以避免潜在的内存泄漏。</li></ul><p id="bc12" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最后一点特别令人兴奋，因为我们不需要手动退订！</p><h1 id="e18d" class="mu mv iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">实践中的角异步管道</h1><p id="b82b" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">我们来看看下面的角度应用。</p><h2 id="0068" class="nr mv iq bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iw bi translated">类别组件</h2><p id="e964" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">类组件声明了<em class="mf">数字</em>变量。变量是数字数组类型，它被初始化为<code class="fe ko kp kq kr b">[1, 3, 5, 7, 9]</code>。</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="e2db" class="nr mv iq kr b gy og oh l oi oj">import { Component } from '@angular/core';</span><span id="1ca3" class="nr mv iq kr b gy ok oh l oi oj">...<br/>export class AppComponent{<br/>  numbers: number[] = [1, 3, 5, 7, 9];<br/>}</span></pre><p id="856b" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">该模板使用<em class="mf">数字</em>为<em class="mf">数字</em>数组中的每个元素显示一个段落。每个段落显示数组中的一个项目。</p><p id="611c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">此时，我们正在模板中使用<code class="fe ko kp kq kr b">*ngIf="numbers"</code>。这是多余的，但以后会有用的。此外，这是一种处理有条件情况的简单方法。</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="efe7" class="nr mv iq kr b gy og oh l oi oj">&lt;div *ngIf="numbers"&gt;</span><span id="1ed2" class="nr mv iq kr b gy ok oh l oi oj">  &lt;p *ngFor="let n of numbers"&gt;{{ n }}&lt;/p&gt;</span><span id="2a80" class="nr mv iq kr b gy ok oh l oi oj">&lt;/div&gt;</span></pre><p id="ad8a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在，我们将使代码具有反应性。</p><p id="3da0" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，当组件初始化时，我们导入OnInit来初始化新的可观察对象。</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="e079" class="nr mv iq kr b gy og oh l oi oj">import { Component, OnInit } from '@angular/core';<br/><br/>...<br/>export class AppComponent implements OnInit{<br/>  numbers: number[] = [1, 3, 5, 7, 9];<br/><br/>  ngOnInit() {}<br/>}</span></pre><p id="a9e8" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">其次，我们将变量<em class="mf">的名称数字</em>改为<code class="fe ko kp kq kr b">Observable&lt;number[]&gt;</code>类型的<code class="fe ko kp kq kr b">numbers$ </code>。美元符号<code class="fe ko kp kq kr b">$</code>是一种惯例，表示变量是可观察的。</p><p id="d58f" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最后，我们将由<code class="fe ko kp kq kr b">of</code>创建的可观察对象分配给可观察属性<code class="fe ko kp kq kr b">numbers$</code>。简而言之，<a class="ae li" href="https://www.vitainbeta.org/hands-on-3-rxjs-of-rxjs-from/" rel="noopener ugc nofollow" target="_blank">内置函数</a> <code class="fe ko kp kq kr b"><a class="ae li" href="https://www.vitainbeta.org/hands-on-3-rxjs-of-rxjs-from/" rel="noopener ugc nofollow" target="_blank">of</a></code>将参数转换成可观察的序列。</p><p id="ae73" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面是app.component.ts中的代码:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="f7f2" class="nr mv iq bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iw bi translated">模板</h2><p id="7c8d" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">我们使用模板来使用Angular异步管道，并获得由<code class="fe ko kp kq kr b">numbers$</code> Observable返回的值。</p><ol class=""><li id="db09" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me on mm mn mo bi translated">首先，我们检查是否用<code class="fe ko kp kq kr b">*ngIf=”numbers$”</code>定义了<code class="fe ko kp kq kr b">numbers$</code>可观测值，</li><li id="5ff3" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">然后，我们通过异步管道(如<code class="fe ko kp kq kr b">”numbers$ | async”</code>)传输<code class="fe ko kp kq kr b">numbers$</code>可观察对象，以访问其发出的值。正如我们上面所说的，angular异步管道自动订阅可观察对象并处理取消订阅。</li><li id="dd76" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">通过使用<code class="fe ko kp kq kr b">as numbers</code>，我们将发出的值赋给一个可以在模板中使用的变量。在我们的例子中，<em class="mf">数字</em>将是一个数字数组。</li><li id="9695" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">最后，我们使用ngFor中的<em class="mf"> numbers </em>变量，遍历数组中的项目，为每个项目生成一个新段落。</li></ol><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="7bd1" class="nr mv iq kr b gy og oh l oi oj">&lt;div *ngIf="numbers$ | async as numbers"&gt;</span><span id="2ff5" class="nr mv iq kr b gy ok oh l oi oj">  &lt;p *ngFor="let n of numbers"&gt;{{ n }}&lt;/p&gt;</span><span id="53fa" class="nr mv iq kr b gy ok oh l oi oj">&lt;/div&gt;</span></pre><h1 id="6059" class="mu mv iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">使用角形异步管道的好处</h1><p id="9e1a" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">以下是使用异步管道的一些主要好处:</p><ul class=""><li id="b2a7" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated">不需要订阅</li><li id="c81d" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">无需退订</li><li id="1344" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">更好的变化检测</li></ul><p id="c716" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">变化检测指的是当底层数据发生变化时更新UI的能力。由于变化检测，用户界面将始终显示组件的最新数据。</p><p id="a0ca" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最常见的变化检测策略是</p><ul class=""><li id="ccfb" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated"><strong class="ll ja">默认</strong>。它使用默认的<code class="fe ko kp kq kr b">checkAlways</code>策略。当检测到任何变化时，检查每个组件</li><li id="33a6" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated"><strong class="ll ja">按下</strong>。它只在<code class="fe ko kp kq kr b">@Input</code>属性改变、事件发出或Observables发出时检查组件的变化。这样，推送策略通过使用<em class="mf"> CheckOnce </em>策略来最小化变更检测周期。</li></ul><p id="7fbd" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">通过在模板中绑定一个可观察对象，我们遵循推送策略。为了启用这个变更检测策略，我们需要在组件装饰器中设置它，如下所示:</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="41ef" class="nr mv iq kr b gy og oh l oi oj">@Component({<br/>  templateUrl: './app.component.html',<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>})</span></pre><h1 id="0ff5" class="mu mv iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">用catchError处理错误</h1><p id="714b" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">如果我们得到一个错误，可观察的流停止，不再发出任何项目。因此，正确捕捉和处理错误非常重要。</p><p id="f74e" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">RxJS <code class="fe ko kp kq kr b"><a class="ae li" href="https://rxjs.dev/api/operators/catchError" rel="noopener ugc nofollow" target="_blank">catchError</a></code> <a class="ae li" href="https://rxjs.dev/api/operators/catchError" rel="noopener ugc nofollow" target="_blank">运算符</a>是一个错误处理运算符:</p><ol class=""><li id="f996" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me on mm mn mo bi translated">它订阅输入流。</li><li id="fd83" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">如果出现错误，<code class="fe ko kp kq kr b">catchError</code>取消订阅输入流，并返回一个替换可观察值。如果没有错误发生，输入流将向输出流发出项。</li><li id="abe4" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">然后，它根据错误的发生创建一个输出流。它可能会选择性地再次抛出一个错误。</li></ol><p id="8479" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如文档中所述，<code class="fe ko kp kq kr b">catchError</code><em class="mf">通过返回一个新的可观察对象或抛出一个错误</em>来捕获待处理的可观察对象上的错误。[…] <em class="mf">处理来自源可观测值的错误，并将它们映射到新的可观测值。</em>”。</p><p id="5f45" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">因此，我们可以推断出两种基本的错误处理策略:</p><ul class=""><li id="585d" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated">捕捉和替换</li><li id="71e8" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">接住并再次抛出</li></ul><p id="fd5f" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">两种策略都使用了<code class="fe ko kp kq kr b">catchError</code>操作符。</p><h2 id="afd0" class="nr mv iq bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iw bi translated">捕捉和替换</h2><p id="cbd7" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">使用捕捉和替换策略，我们捕捉错误并用更适合继续的内容替换它:</p><ul class=""><li id="b1ed" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated">发出一些替代数据的可观察值</li><li id="60a6" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">发出空值的可观察对象</li><li id="8e82" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated"><a class="ae li" href="https://rxjs.dev/api/index/const/EMPTY" rel="noopener ugc nofollow" target="_blank">空rxjs常量</a>。<code class="fe ko kp kq kr b">EMPTY</code>常数定义了一个不发射任何项目并完成的可观察对象。</li></ul><p id="0173" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用捕捉和替换策略，<code class="fe ko kp kq kr b">catchError</code>用新的可观测值替换错误可观测值。</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="9d7b" class="nr mv iq kr b gy og oh l oi oj">// Catch &amp; Replace Strategy</span><span id="4e75" class="nr mv iq kr b gy ok oh l oi oj">catchError((err) =&gt; {</span><span id="4364" class="nr mv iq kr b gy ok oh l oi oj">    this.errorMessage = err;<br/>    return EMPTY;</span><span id="9a85" class="nr mv iq kr b gy ok oh l oi oj">})</span></pre><p id="2e57" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae li" href="https://rxjs.dev/api/index/function/catchError" rel="noopener ugc nofollow" target="_blank"> rxjs文档</a>中的大理石图很好地解释了这个策略。</p><p id="4d92" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">箭头代表可观察值，而大理石代表发射值。</p><p id="23ea" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在下面的<code class="fe ko kp kq kr b">catchError</code>大理石图中，我们看到一个可观察对象在遇到X符号表示的错误之前发出值<code class="fe ko kp kq kr b">a</code>和<code class="fe ko kp kq kr b">b</code>。</p><p id="1675" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用捕捉和替换策略，<code class="fe ko kp kq kr b">catchError</code>捕捉错误并发出值1、2、3和complete，用|符号表示。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/143c65efa4af2dd744ada6202a96f043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*BhWbpq1MVTMXYvDh"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">rxjs catchError运算符的大理石图</p></figure><p id="887d" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">由于这种方法，最终的结果将看起来像一个发出a、b、1、2、3和complete的单个可观察的流。</p><h2 id="1615" class="nr mv iq bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iw bi translated">接住并再次抛出</h2><p id="1865" class="pw-post-body-paragraph lj lk iq ll b lm nm ka lo lp nn kd lr ls no lu lv lw np ly lz ma nq mc md me ij bi translated">catch &amp; rethrow策略通过使用rxjs <a class="ae li" href="https://rxjs.dev/api/index/function/throwError" rel="noopener ugc nofollow" target="_blank"> throwError创建操作符</a>返回一个替换可观察值。</p><p id="7b8e" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">throwError操作符“<em class="mf">创建一个可观察对象，该可观察对象将创建一个错误实例，并在订阅后立即将其作为错误推送给消费者</em>。该运算符不发出任何项目。</p><p id="bf21" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">throwError运算符是一个创建运算符:</p><ol class=""><li id="3a06" class="mg mh iq ll b lm ln lp lq ls mi lw mj ma mk me on mm mn mo bi translated">它创建并返回一个不发射任何项目的替换可观察对象。从技术上讲，它返回<code class="fe ko kp kq kr b">Observable&lt;never&gt;</code></li><li id="1bec" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me on mm mn mo bi translated">它发出一个错误通知，并停止新创建的可观察对象。</li></ol><p id="ab73" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这种策略通常用于错误传播。</p><pre class="kt ku kv kw gt oc kr od oe aw of bi"><span id="bed1" class="nr mv iq kr b gy og oh l oi oj">// Catch &amp; Rethrow Strategy<br/><br/>catchError((err) =&gt; {<br/><br/>    return throwError(err);</span><span id="e59d" class="nr mv iq kr b gy ok oh l oi oj">})</span></pre><p id="1909" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">文档字面意思是“<em class="mf">只是错误，不做其他事情</em>”。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi op"><img src="../Images/252832e9fa432add6230069ee94e553b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rIbL205UJeZTTL2t.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">大理石图(？)的操作符</p></figure><h1 id="9c40" class="mu mv iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">摘要</h1><ul class=""><li id="71db" class="mg mh iq ll b lm nm lp nn ls oq lw or ma os me ml mm mn mo bi translated">使用角度异步管道来避免手动使用订阅和取消订阅。此外，在Angular 中使用<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/rxjs-declarative-pattern-in-angular-cafba3983d21"> RxJS声明模式是一个好方法</a></li><li id="737d" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">角度异步管道优化了变化检测</li><li id="2eeb" class="mg mh iq ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">通过使用catch &amp; replace或catch and rethrow，用<code class="fe ko kp kq kr b">catchError</code>处理错误</li></ul></div></div>    
</body>
</html>