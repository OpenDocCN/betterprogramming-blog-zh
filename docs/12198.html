<html>
<head>
<title>Understanding the IntersectionObserver API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解IntersectionObserver API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-intersectionobserver-b19fca5a194e?source=collection_archive---------13-----------------------#2022-05-18">https://betterprogramming.pub/the-intersectionobserver-b19fca5a194e?source=collection_archive---------13-----------------------#2022-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这远没有听起来那么可怕，我会告诉你的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/bfa630720299ac8f1d93232235e3291f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*gXJRGEOSw92iSK2QdRVXlQ.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">路口观察者是如何工作的</p></figure><p id="643b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">IntersectionObserver是所有主流浏览器都支持的浏览器API。它有一个有点吓人的名字和一个有点混乱的API。但这不应该阻止我们使用它，因为它为我们提供了一些非常酷的功能。</p><p id="3c26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，这个API非常适合:</p><ul class=""><li id="d7c9" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">懒惰的东西</li><li id="0a9b" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">跟踪元素的视图内度量</li><li id="59af" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">无限卷轴</li></ul><p id="104c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，API可以帮助确定一个HTML元素是否与另一个元素相交，或者更常见的是，一个元素是否与视口相交。</p><p id="50a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从高层次来看，API需要3样东西</p><ol class=""><li id="2404" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm mb lt lu lv bi translated">HTML元素</li><li id="ba68" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm mb lt lu lv bi translated">配置对象</li><li id="f2f9" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm mb lt lu lv bi translated">回调函数</li></ol><p id="426a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这个API有点奇怪，我写了一个小包装器来帮助使用这个API</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">IntersectionObserver API的包装器</p></figure><p id="9cae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我不打算深入讨论参数的细节，因为它们在<a class="ae me" href="https://developer.chrome.com/blog/intersectionobserver/" rel="noopener ugc nofollow" target="_blank">这里</a>有详细描述</p><p id="381c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将使用一个简单的例子，它包含一个id为<code class="fe mf mg mh mi b">target</code>的HTML元素和一些配置，这些配置将在该元素与视窗“相交”时执行回调函数。</p><p id="cf4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用上述包装器的方式如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="a661" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这两个部分，我们可以快速地组装一个可以使用这个功能的演示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj md l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">StackBlitz示例</p></figure><p id="7020" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的例子只是将一些内容打印到控制台并修改一些文本。但是如果你开始围绕这个模式构建更多的逻辑，你可以开始延迟加载你的一些代码或图像(尽管<code class="fe mf mg mh mi b">&lt;img loading=lazy&gt;</code>可能很快会得到广泛的支持)</p><p id="0989" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用上面的方法进行内部跟踪，来计算有多少人滚动到了您页面上的某一点。</p><p id="6b61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的专业工作中，我们使用上面的方法来检测元素何时进入视口，并刷新它(外部资源),如果自上次刷新以来已经超过30秒。</p><p id="ac6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要有可能，我总是喜欢使用浏览器API，因为它让我免去了很多考虑边缘情况的麻烦。</p><p id="18ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">保持懒惰！</p></div></div>    
</body>
</html>