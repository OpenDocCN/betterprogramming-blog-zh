<html>
<head>
<title>Should You Care About Immutability in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中应该关心不变性吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-care-about-immutability-in-javascript-a-brief-intro-to-immer-js-ft-react-febabd7e73b2?source=collection_archive---------1-----------------------#2020-11-15">https://betterprogramming.pub/should-you-care-about-immutability-in-javascript-a-brief-intro-to-immer-js-ft-react-febabd7e73b2?source=collection_archive---------1-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1fc0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Immer.js简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f17bf54687e25af733fa7b2fe2a5d329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PDYsmvf1A1qvJ94J"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@rossf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗斯·芬登</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="1b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL；DNR——是的，你应该这么做。</p><p id="299e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:本文主要在React的背景下介绍Immer，并假设您对它有一些经验。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8aa3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们先理解不变性</h1><p id="cd78" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw">不可变</em>的字典含义是“不随时间变化或者不能改变。”在编程中，不变性意味着数据或对象一旦被创建就不应该被修改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/0e0a02bd137df4cae1643dc74e710595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-AGheuxIpWz-Jsy33338Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在JavaScript中声明变量。作者截图。</p></figure><p id="1111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传统上，在多线程编程语言中使用不变性来维护多线程之间的数据一致性。但是既然JavaScript是单线程编程语言，我们为什么还要关心不可变性呢？</p><p id="0664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">const</a></code>关键字的引入让您可以在一个范围内创建常量。那何必呢？</p><p id="ea15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看几个例子来理解这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="de32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe my mz na nb b">const</code> <strong class="ky ir"> <em class="mw">，</em> </strong>来创建常量，但是这有一个问题。以下来自<a class="ae kv" href="https://mdn.io/" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="ne nf ng"><p id="d78f" class="kw kx mw ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">“<code class="fe my mz na nb b"><em class="iq">const</em></code>声明创建了一个对值的只读引用。这并不意味着它保存的值是不可变的——只是变量标识符不能被重新赋值。例如，在内容是对象的情况下，这意味着对象的内容(例如，其属性)可以被改变。”</p></blockquote><p id="2174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据这个例子，很明显，如果您在更改数据时没有格外小心，您的应用程序将容易出现错误，因为您可能会在不知不觉中更改(和破坏)某些东西。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9535" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">JavaScript本质上是可变的</h1><p id="9f4f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">JavaScript属于可变编程语言的范畴，我们最喜爱的数据结构，<a class="ae kv" href="https://mdn.io/Arrays" rel="noopener ugc nofollow" target="_blank">数组</a>和<a class="ae kv" href="https://mdn.io/Objects" rel="noopener ugc nofollow" target="_blank">对象</a>，总是被作为引用传递(如上所示)，因此这些语言的绝大多数内置方法本质上都是破坏性的，也就是说，它们就地改变了数据。(是的，我在看着你，<a class="ae kv" href="https://mdn.io/push" rel="noopener ugc nofollow" target="_blank">推</a>，<a class="ae kv" href="https://mdn.io/pop" rel="noopener ugc nofollow" target="_blank">弹出</a>，<a class="ae kv" href="https://mdn.io/splice" rel="noopener ugc nofollow" target="_blank">拼接</a>等。但是因为它们是<a class="ae kv" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">就地算法</a>的一个实现，它们应该表现得像那样。)也有几种非破坏性的方法，如<a class="ae kv" href="http://mdn.io/slice" rel="noopener ugc nofollow" target="_blank">切片</a>、<a class="ae kv" href="http://mdn.io/ArrayMap" rel="noopener ugc nofollow" target="_blank">贴图</a>、<a class="ae kv" href="http://mdn.io/ArrayFilter" rel="noopener ugc nofollow" target="_blank">过滤</a>、<a class="ae kv" href="http://mdn.io/ArrayReduce" rel="noopener ugc nofollow" target="_blank">还原</a>，它们不会原地改变数据，也不会在对数据进行操作后返回数据的新副本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/d8133d16c12d6eb06e4fb3492d0e4dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz-jUVxtkJ8vEHGV9L-2QQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自"<a class="ae kv" href="https://medium.com/@elizarov/immutability-we-can-afford-10c0dcb8351d" rel="noopener">不变性我们买得起</a>"</p></figure><p id="d04a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，您可能已经猜到了可变代码的一些问题。</p><ul class=""><li id="1d90" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">使代码不可预测</li><li id="5f28" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">如果多人在同一个代码库上工作，会增加引入错误的漏洞</li><li id="afc5" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">更难测试</li><li id="d7f5" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">很难调试。不支持时间旅行调试(如Redux开发工具)</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b592" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">怎样才能防止变异，避免bug？</h1><p id="26ce" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">答案是否定的，你不能(完全)阻止突变(没有一些帮助)。</p><p id="fa42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这篇文章不应该深入讨论函数式编程与面向对象编程<strong class="ky ir"> </strong>范例之间永无休止的争论，但是<a class="ae kv" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>有一个非常简单的想法:</p><blockquote class="ne nf ng"><p id="5574" class="kw kx mw ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">“当用一些给定的参数调用一个函数时，它将总是返回相同的结果，并且不会受到任何可变的<a class="ae kv" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel="noopener ugc nofollow" target="_blank">状态</a>或其他<a class="ae kv" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>的影响。纯函数式编程声称，通过限制副作用，程序可以有更少的<a class="ae kv" href="https://en.wikipedia.org/wiki/Software_bug" rel="noopener ugc nofollow" target="_blank">错误</a>，更容易<a class="ae kv" href="https://en.wikipedia.org/wiki/Debugging" rel="noopener ugc nofollow" target="_blank">调试</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Software_testing" rel="noopener ugc nofollow" target="_blank">测试</a>。”</p></blockquote><p id="8816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这听起来绝对是我们可以从中受益的事情。由于我们已经确定了本地数据结构的可变性，我们可以按照下面的简单步骤来实现不变性。</p><ul class=""><li id="9a88" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">如果需要更改数据，不要直接做。相反，创建数据的副本。</li><li id="c38d" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">对副本进行修改/操作。</li><li id="1ac2" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">返回修改后的副本。</li></ul><p id="c89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使原始数据保持完整，作为回报，我们可能会处理更少的错误。听起来很棒，对吧？直到你意识到复制数据通常是低效的，会消耗额外的内存，如果你的代码运行在一个不太强大的设备上(比如一个低端的移动设备)，会导致严重的性能问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4a84" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">事情现在要变得严重了(一个小的迂回)</h1><p id="eb68" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最初，我决定不讨论这个问题，您完全可以跳过这一部分。但是，如果能知道<a class="ae kv" href="https://immerjs.github.io/immer/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Immer </a>和其他几个库用来让我们的生活变得更容易的底层技术，那就太好了。</p><p id="d3a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建和管理数据结构的副本是一个老问题，有几种DS实现和一些非常强大的技术可以优化这个过程。</p><h2 id="9973" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">数据结构</h2><ol class=""><li id="82d6" class="nl nm iq ky b kz mr lc ms lf ol lj om ln on lr oo nr ns nt bi translated">不可变DS——一旦创建，状态永远不会改变。</li><li id="9fd4" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr oo nr ns nt bi translated">部分持久DS —保留状态的所有先前版本。您可以读取所有以前的状态，但只能修改最近的状态。</li><li id="910f" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr oo nr ns nt bi translated">持久性DS —您可以访问状态的所有先前版本，并且可以修改任何版本。这可以被认为是版本控制，您可以及时返回并查看以前的状态，还可以修改内容。<a class="ae kv" href="https://en.wikipedia.org/wiki/Persistent_data_structure" rel="noopener ugc nofollow" target="_blank">维基百科</a>将它们描述为:</li></ol><blockquote class="ne nf ng"><p id="3952" class="kw kx mw ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">“在<a class="ae kv" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，持久数据结构是一种<a class="ae kv" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，当它被修改时，它总是保持其自身的先前版本。这种数据结构实际上是<a class="ae kv" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不可变的</a>，因为它们的操作不会(明显地)就地更新结构，而是总是产生一个新的更新结构。”</p></blockquote><ol class=""><li id="684a" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr oo nr ns nt bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>—“<em class="mw">是一种资源管理技术，用于高效地对可修改的资源执行“复制”或“拷贝”操作。如果资源被复制但没有被修改，则没有必要创建新的资源；资源可以在副本和原件之间共享。修改仍然必须创建一个拷贝，因此出现了这种技术:拷贝操作被推迟到第一次写操作。通过以这种方式共享资源，可以显著减少未修改副本的资源消耗，同时给资源修改操作增加少量开销。”</em></li><li id="ed36" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr oo nr ns nt bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Persistent_data_structure#Path_copying" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">路径复制</strong></a><strong class="ky ir"/>——“W<em class="mw">利用路径复制方法，在到任何将要被修改的节点的路径上制作所有节点的副本。然后这些变化必须通过数据结构</em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Fractional_cascading" rel="noopener ugc nofollow" target="_blank"> <em class="mw">级联</em> </a> <em class="mw">回来。所有指向旧节点的节点必须改为指向新节点。这些修改导致更多的级联变化，等等，直到到达根节点。</em></li><li id="cb81" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr oo nr ns nt bi translated"><strong class="ky ir">结构共享</strong> —要理解这一点，首先我们必须了解<a class="ae kv" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> Trie </a> <strong class="ky ir"> </strong>数据结构。Trie是一种特殊的树数据结构。看看维基百科上的下图。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/be6de648fcd687ec333bc7484757674a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLg6XUHVqRJNBHBGe7frMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank">维基百科</a>。关键字A、to、tea、ted、ten、I、in和inn的trie。</p></figure><p id="7e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在二叉查找树中，每个内部节点存储与该节点相关联的键以供遍历。但是在Trie中，没有节点存储代表该节点的键。节点在树中的位置定义了它所关联的键。根据维基百科:</p><blockquote class="ne nf ng"><p id="b629" class="kw kx mw ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">一个节点的所有后代都有一个与该节点相关联的字符串的公共<a class="ae kv" href="https://en.wikipedia.org/wiki/Prefix" rel="noopener ugc nofollow" target="_blank">前缀</a>，并且根与空字符串的<a class="ae kv" href="https://en.wikipedia.org/wiki/Empty_string" rel="noopener ugc nofollow" target="_blank">相关联。键往往与叶相关联，尽管一些内部节点可能对应于感兴趣的键。因此，键不一定与每个节点相关联。</a></p></blockquote><p id="6c8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实际理解这一点，让我们以一个表示为Trie的数组为例，并尝试修改某个索引处的值。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="ca6e" class="nz ma iq nb b gy ou ov l ow ox"><strong class="nb ir">let</strong> cities = ['Amsterdam', 'Berlin', 'Delhi', 'London', 'Chicago', 'Toronto', 'Mumbai', 'Munich']</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/a674f3879b4530690b38d6ea492cc17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBsta82b1f-6hX_Ndy5HpA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="e57d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">城市和索引1的地址是根节点的“001”。0表示左节点，1表示右节点。这样，每个叶节点都可以被索引，并且将具有唯一的地址。</p><p id="1ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将数组表示/存储为Trie使得以持久的方式进行改变成为可能。例如，如果我们必须将最后一个城市从“慕尼黑”更改为“悉尼”，我们可以重新使用旧的Trie结构，并修改最后一个索引(111)处的值。这是非常有效的，因为我们不需要对整个结构进行新的复制。相反，我们更改了结构的特定部分，并且仍然引用旧结构中未更改的值。</p><p id="e2c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仍然可以从旧根访问未更改索引处的值。具有新根的结构包含我们添加的新城市。修改后，我们的结构将如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/b26476fce92fb0a8668610b247a2d437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zu4-fKboGx_lgyWPqoPNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="1d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，这就是结构共享。</p><p id="8c9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似的技术可以应用于<a class="ae kv" href="https://mdn.io/Objects" rel="noopener ugc nofollow" target="_blank">对象</a>来产生副本。在对象中，我们为每个键获取一个数字散列，并使用它来创建数据的下一个版本/状态。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="aa4c" class="nz ma iq nb b gy ou ov l ow ox"><strong class="nb ir">hash</strong>('name') = 034334 // hash value will be used as address in Trie<br/><strong class="nb ir">hash</strong>('role') = 045356 // hash value will be used as address in Trie</span></pre><h2 id="368e" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Branching_factor" rel="noopener ugc nofollow" target="_blank">分支因子</a>和时间复杂度</h2><p id="3bb4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在上面的例子中，我们看到每个节点被分成两个分支。但是在实际情况中，大的数组(或对象)会导致非常深的嵌套树，因此修改的时间也会增加。已经证明分支因子和性能的良好平衡是32。在<a class="ae kv" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>中十亿个元素的数组深度只有6个节点。</p><p id="fa59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新数组和改变一个元素需要O(n)时间。但是通过结构共享和使用尝试，这可以减少到O(log(branching_factor) n)，并且由于分支因子是常数，这意味着时间复杂度将为O(log n)。</p><p id="3b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">有趣的事实</strong>——Tries在读取数据时速度非常快<strong class="ky ir"> <em class="mw"> trie </em> </strong>这也是这个名字的由来。谷歌在谷歌搜索的自动完成功能中使用它们。</p><p id="d5ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下我们的(不那么)小弯路，这些强大的技术已经被Immer和其他几个库所利用，所以我们不必太担心性能，同时保持不变性。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8a5b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">不变性和反应</h1><h2 id="f6fc" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">问题</h2><p id="fa21" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设您在本地状态中有一个用户信息(嵌套对象),需要更新对象中的一个值。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="c217" class="nz ma iq nb b gy ou ov l ow ox"><strong class="nb ir">state</strong> = {<br/>  <strong class="nb ir">user</strong>: { <br/>    <strong class="nb ir">personalDetails</strong>: {<br/>      name: "Rajat Kumar",<br/>      address: {<br/>        house: 1234,<br/>        street: "street1",<br/>        city: "Chandigarh",<br/>        pin: "000001"<br/>      }<br/>    },<br/>   <strong class="nb ir">employmentDetails</strong>: {<br/>     company: "Paytm",<br/>     role: "Software Engineer"<br/>   }<br/>}</span></pre><p id="db57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在保持不变性和更新街道地址的同时，它看起来会像下面这样。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="53ec" class="nz ma iq nb b gy ou ov l ow ox">this.<strong class="nb ir">setState</strong>({<br/>  <strong class="nb ir">user</strong>: {<br/>    ...this.state.user,<br/>    <strong class="nb ir">personalDetails</strong>: {<br/>      ...this.state.user.personalDetails,<br/>      <strong class="nb ir">address</strong>: {<br/>        ...this.state.user.address,<br/>        <strong class="nb ir">street</strong>: 'New Street Value' // this is the change<br/>      }<br/>    }    <br/>  }<br/>})</span></pre><p id="bfeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了看起来很难看之外，这种方法还会迫使您编写更多的代码。这是一种常见的方法，你们中的许多人可能正在这样做。连我以前也这么做。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9b49" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们解决这个问题</h1><h2 id="6355" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">解决方案1</h2><p id="cbaa" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">还记得我们讨论过创建数据副本吗？让我们试着利用这一点。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="5e6f" class="nz ma iq nb b gy ou ov l ow ox">import <strong class="nb ir">deepcopy</strong> from 'deepcopy'</span><span id="e9d2" class="nz ma iq nb b gy pa ov l ow ox"><strong class="nb ir">updateUserStreet</strong> = () =&gt; {<br/>   <strong class="nb ir">const</strong> userCopy = <strong class="nb ir">deepcopy</strong>(this.state.user);<br/>   userCopy.personalDetails.address.street = 'New Street Value';<br/>   this.<strong class="nb ir">setState</strong>({ user: userCopy })<br/>}</span></pre><p id="95f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法看起来更DX友好，可读性更好。但是有一个问题。这将创建我们整个用户对象的深层副本，可能导致组件不必要的重新渲染，甚至会破坏通过使用<a class="ae kv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo </a> <strong class="ky ir">实现的性能优化。</strong>花几分钟时间理解下面的例子，看看它为什么会中断React.memo</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用深度复制对setState做出反应</p></figure><p id="6fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">注意:—点击“查看源代码”打开代码</em></p><p id="4015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您得出的结论是，每次调用<code class="fe my mz na nb b">handleInput</code>时，深度复制都会为<code class="fe my mz na nb b">EmploymentDetails</code>组件创建一个新的props值，从而绕过React.memo，那么您是对的。</p><h2 id="a3c3" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">解决方案2</h2><p id="9aa3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用<a class="ae kv" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>提供的解决方案。</p><p id="7e13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不可变是由脸书在2014年发布的，它提供了JavaScript原生数据结构的不可变版本(以及更多)。它解决了以不可变方式更新状态的问题，并遵循自顶向下的数据流方法，因此不需要订阅数据更改。</p><p id="e2bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Immutable很棒，目前在NPM<a class="ae kv" href="https://www.npmjs.com/package/immutable" rel="noopener ugc nofollow" target="_blank"/><strong class="ky ir">上每周下载量超过330万。但是它有一个有点不寻常的API 和一个巨大的学习曲线(个人观点)。例如，请参见下面的API列表。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/754efe7ee391b55e64cfe70ac5ff90bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6Y0ApMlIQsGHHXRy0ONjw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">地图的不可变. js API</p></figure><p id="bd24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些只针对<a class="ae kv" href="https://immutable-js.github.io/immutable-js/docs/#/Map" rel="noopener ugc nofollow" target="_blank">映射</a>数据结构。我确信这样设计API是有原因的，但是你明白我在说什么。</p><h2 id="2509" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">解决方案3</h2><p id="5554" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">方案三也用Immer <strong class="ky ir">。Immer的主页用一个更简单的类比解释了这一点。</strong></p><blockquote class="ne nf ng"><p id="7919" class="kw kx mw ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">“使用Immer就像拥有了一个私人助理；他/她会拿一封信(当前状态)给你一份副本(草稿),让你在上面草草修改。一旦你完成了，助理会拿走你的草稿，为你产生真正的不可改变的，最终的信(下一个状态)。”</p></blockquote><p id="0901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你希望有一个更简单的API来完成我们讨论过的所有这些，Immer就是这样。它实际上只是公开了一个名为<code class="fe my mz na nb b"><a class="ae kv" href="https://immerjs.github.io/immer/docs/produce" rel="noopener ugc nofollow" target="_blank">produce</a></code> <strong class="ky ir"> <em class="mw"> </em> </strong>的简单函数，可以简单地如下使用。</p><pre class="kg kh ki kj gt oq nb or os aw ot bi"><span id="8ecf" class="nz ma iq nb b gy ou ov l ow ox">import <strong class="nb ir">produce</strong> from "immer"</span><span id="ab3b" class="nz ma iq nb b gy pa ov l ow ox"><strong class="nb ir">const</strong> baseState = [<br/>    {<br/>        todo: "Learn typescript",<br/>        done: true<br/>    },<br/>    {<br/>        todo: "Try immer",<br/>        done: false<br/>    }<br/>]</span><span id="de92" class="nz ma iq nb b gy pa ov l ow ox"><strong class="nb ir">const</strong> nextState = <strong class="nb ir">produce</strong>(baseState, draftState =&gt; {<br/>    draftState.push({todo: "Tweet about it"})<br/>    draftState[1].done = true<br/>})</span></pre><p id="c339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">produce</code>函数有两个参数，即。,</p><ol class=""><li id="ad46" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr oo nr ns nt bi translated"><strong class="ky ir">当前状态</strong> —您想要变异的状态</li><li id="982c" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr oo nr ns nt bi translated"><strong class="ky ir">配方功能</strong> — <strong class="ky ir"> </strong>接收可自由改变的当前状态的草稿/副本的功能</li></ol><p id="94c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为Immer运行在JavaScript的原生数据结构上，所以它使用了<a class="ae kv" href="https://javascript.info/proxy" rel="noopener ugc nofollow" target="_blank">代理和反射</a>API来实现这一点。</p><p id="acbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子来自Immer文档。</p><ul class=""><li id="4eec" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><strong class="ky ir">设置状态并产生</strong></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="7313" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><strong class="ky ir"> useState vs. useImmer </strong></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">易于在useState和useImmer之间更新状态</p></figure><ul class=""><li id="664b" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><strong class="ky ir">减速器/用户减速器与产品</strong></li></ul><p id="46b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在</strong>之前</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b99c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在</strong>之后</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们上面的<code class="fe my mz na nb b">setState</code>使用Immer的例子看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Immer反应setState</p></figure><p id="dc68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">注意:—点击“查看源代码”打开代码</em></p><p id="c9ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们没有改变<code class="fe my mz na nb b">setState</code>中的<code class="fe my mz na nb b">employmentDetails</code>，引用保持不变:没有重新渲染<code class="fe my mz na nb b">employmentDetails</code>组件。</p><p id="48f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近在工作中，我不得不编写一个复杂的表单(分为几个部分，如订阅计划详情、计划频率、支付设置等。)以及各种输入类型和验证。我最初的设计方法是使用<code class="fe my mz na nb b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code>、<strong class="ky ir">、</strong>将(相关)状态传递给表单的不同部分(子组件)、<strong class="ky ir">、<strong class="ky ir">、</strong>(以更易读的方式更新状态)。结果很棒，但是我对<code class="fe my mz na nb b">FormReducer</code>的最终版本特别不满意。这是Immer表现最好的一个用例。如果你有兴趣看最终版本，请在评论中告诉我。</strong></p><div class="kg kh ki kj gt ab cb"><figure class="pd kk pe pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/faa165fd187ac69360a5efc3519f9abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*QJGDHoE6zV-7c4QQWqGoNw.png"/></div></figure><figure class="pd kk pj pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/99718a4603efc98b724bd58d5314bc45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*7m1Na8humQMziVows_B97A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk pk di pl pm translated">作者截图。</p></figure></div><p id="8b92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Immer有一个特别小的API(和大小),并声称其性能和不可变的一样好。它还附带了<a class="ae kv" href="https://immerjs.github.io/immer/docs/async" rel="noopener ugc nofollow" target="_blank">异步生产者</a>，并且还支持<a class="ae kv" href="https://immerjs.github.io/immer/docs/typescript" rel="noopener ugc nofollow" target="_blank">类型脚本</a>。Immer也暴露为自定义钩子—<a class="ae kv" href="https://www.npmjs.com/package/use-immer" rel="noopener ugc nofollow" target="_blank">use—immer</a>。</p><p id="498f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该是一个简短的介绍，而不是深入探讨。但是如果你对学习Immer感兴趣，这里有一个<a class="ae kv" href="https://egghead.io/courses/immutable-javascript-data-structures-with-immer" rel="noopener ugc nofollow" target="_blank">免费Egghead.io课程</a>，来自Immer的作者Michel Weststrate。</p><p id="ece0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React喜欢不变性，并在差分算法和最终的<a class="ae kv" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调阶段</a>中占据很大优势。Redux还通过使用<a class="ae kv" href="https://facebook.github.io/flux/docs/in-depth-overview/" rel="noopener ugc nofollow" target="_blank">自顶向下</a>(单向)数据流方法来保持不变性。如果你最近使用了<a class="ae kv" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>并且发现reducers有一个非常简单的API来更新状态，你应该感谢Immer，因为它<a class="ae kv" href="https://redux.js.org/tutorials/fundamentals/part-8-modern-redux#immutable-updates-with-immer" rel="noopener ugc nofollow" target="_blank">在引擎盖下使用Immer</a>。</p><p id="63da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最后一个有趣的事实</strong> — <a class="ae kv" href="https://github.com/omcljs/om" rel="noopener ugc nofollow" target="_blank"> Om </a>是(曾经是)一个UI库，发布于2013年，是React本身的一个包装器。事实上，它比React更快，因为它实现了不变性。</p><h2 id="a14d" class="nz ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">解决方案4</h2><p id="47ee" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">无论哪种方法适合您的代码风格。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="5068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章本来没打算这么长，但是如果您能够利用我们讨论的各种陷阱和方法，它绝对是值得的。</p><p id="c909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我计划写<a class="ae kv" href="https://rkrajat.medium.com/react-hooks-and-forms-dedb8072763a" rel="noopener">一篇后续文章</a>来演示一个更真实的场景和更多使用Immer和use-immer的代码示例。</p><p id="fb18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">继续学习… </em></p></div></div>    
</body>
</html>