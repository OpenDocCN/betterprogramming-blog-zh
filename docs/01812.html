<html>
<head>
<title>Serialization and Deserialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列化和反序列化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serialization-and-deserialization-ba12fc3fbe23?source=collection_archive---------7-----------------------#2019-10-15">https://betterprogramming.pub/serialization-and-deserialization-ba12fc3fbe23?source=collection_archive---------7-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么——什么时候使用？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b29b1ddc6772c236403f97cfdc389f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h8mi-AYMEjRnIOnW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1cbf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">序列化</h1><p id="44c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">序列化将内存中的数据结构转换为可以存储或传输的值。</p><p id="dd15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们在一个JavaScript脚本中有一个<code class="fe ms mt mu mv b">users</code>对象，它包含用户总数和用户列表，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ca14" class="na la it mv b gy nb nc l nd ne">const usersObject = {<br/>  "total": 2,<br/>  "users": [<br/>    {<br/>      "name": "Patrick"<br/>    },<br/>    {<br/>      "name": "Michael"<br/>    }<br/>  ]<br/>}</span></pre><p id="66b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当JavaScript运行时执行上面的代码时，它会在内存中创建一个类似下面的数据结构。引擎会将每个对象和数组存储在内存中单独的位置，并提供对它们使用位置的引用:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4a3a" class="na la it mv b gy nb nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_a</em></strong><br/>{<br/>  name: "Patrick"<br/>}</span><span id="109b" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_b</em></strong><br/>{<br/>  name: "Michael"<br/>}</span><span id="2692" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">array_in_memory_c</em></strong><br/>[<br/>  <strong class="mv iu"><em class="nf">object_in_memory_a</em></strong>,<strong class="mv iu"><br/>  <em class="nf">object_in_memory_b<br/></em></strong>]</span><span id="6225" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_d</em></strong><br/>{<br/>  total: 2,<br/>  users: <strong class="mv iu"><em class="nf">array_in_memory_c</em></strong><br/>}</span></pre><p id="1f39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在程序的进程结束后，上述内容不容易传输到另一台机器或被同一台机器使用。为此，我们必须序列化数据。也就是说，我们必须将内存中的数据结构转换成一系列字节(通常是ASCII字符)，这些字节以可恢复的格式记录数据结构。</p><p id="1264" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的JavaScript示例中，我们可以通过将<code class="fe ms mt mu mv b">usersObject</code>传递给<code class="fe ms mt mu mv b">JSON.stringify()</code>函数来序列化它，如下所示。</p><p id="2da7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b382" class="na la it mv b gy nb nc l nd ne">JSON.stringify(usersObject);</span></pre><p id="e28a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">结果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="90b4" class="na la it mv b gy nb nc l nd ne"><strong class="mv iu">"{"total":2,"users":[{"name":"Patrick"},{"name":"Michael"}]}"</strong></span></pre><p id="8ddb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们所看到的，内存中的对象已经被转换为一个字符串。这个字符串现在可以转移到其他机器上，或者存储到磁盘上以备后用。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d01c" class="kz la it bd lb lc no le lf lg np li lj jz nq ka ll kc nr kd ln kf ns kg lp lq bi translated">反序列化</h1><p id="1a44" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们的例子中，我们知道我们可以将序列化的结果传递到另一台机器，或者如果我们将它保存到磁盘上，我们可以在以后自己检索它。</p><p id="0e63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设这种序列化发生在服务器上，当对系统用户发出请求时，我们希望将它传递给浏览器客户端。客户端将收到我们的序列化结果，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8d0f" class="na la it mv b gy nb nc l nd ne"><strong class="mv iu">"{"total":2,"users":[{"name":"Patrick"},{"name":"Michael"}]}"</strong></span></pre><p id="fb88" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据很棒，但是是个<code class="fe ms mt mu mv b">string</code>。</p><p id="4479" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此时，浏览器客户端不能使用这些数据来知道有多少用户或他们的名字。</p><p id="7814" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要具备这种能力，我们必须将这个序列化的字符串转换成内存中的数据结构。从序列化字符串到内存中数据结构的转换是反序列化。我们可以用JavaScript <code class="fe ms mt mu mv b">JSON.parse()</code>函数来完成这个任务。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="52fa" class="na la it mv b gy nb nc l nd ne">const usersObject = JSON.parse(responseFromServer);</span></pre><p id="c3c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在反序列化之后，<code class="fe ms mt mu mv b">usersObject</code>将变成与我们在服务器端看到的相同的内存数据结构:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d102" class="na la it mv b gy nb nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_a</em></strong><br/>{<br/>  name: "Patrick"<br/>}</span><span id="73c5" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_b</em></strong><br/>{<br/>  name: "Michael"<br/>}</span><span id="7c81" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">array_in_memory_c</em></strong><br/>[<br/>  <strong class="mv iu"><em class="nf">object_in_memory_a</em></strong>,<strong class="mv iu"><br/>  <em class="nf">object_in_memory_b<br/></em></strong>]</span><span id="588b" class="na la it mv b gy ng nc l nd ne"><strong class="mv iu"><em class="nf">object_in_memory_d</em></strong><br/>{<br/>  total: 2,<br/>  users: <strong class="mv iu"><em class="nf">array_in_memory_c</em></strong><br/>}</span></pre><p id="3183" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然浏览器客户端有了内存中的数据结构，我们就有能力导航它。</p><p id="a192" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在可以知道用户的数量以及他们的名字。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8054" class="na la it mv b gy nb nc l nd ne">console.log(usersObject.total); // 2<br/>console.log(usersObject.users[0].name); // Patrick<br/>console.log(usersObject.users[1].name); // Michael</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="7d2c" class="kz la it bd lb lc no le lf lg np li lj jz nq ka ll kc nr kd ln kf ns kg lp lq bi translated">摘要</h1><p id="e9e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">序列化采用内存中的数据结构，并将其转换为一系列可以存储和传输的字节。</p><p id="09e4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">反序列化接受一系列字节，并将其转换为可以以编程方式使用的内存中数据结构。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="297f" class="kz la it bd lb lc no le lf lg np li lj jz nq ka ll kc nr kd ln kf ns kg lp lq bi translated">资源</h1><ul class=""><li id="1de8" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Serialization</a></li></ul></div></div>    
</body>
</html>