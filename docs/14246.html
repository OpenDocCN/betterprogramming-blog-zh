<html>
<head>
<title>NextAuth.js vs. Serverless Stack Authentication — A Side-by-Side Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NextAuth.js与无服务器堆栈身份验证—并列比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/next-auth-vs-sst-auth-d5675b6c5b7b?source=collection_archive---------12-----------------------#2022-11-21">https://betterprogramming.pub/next-auth-vs-sst-auth-d5675b6c5b7b?source=collection_archive---------12-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比较实施、部署等的容易程度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbb2d2f9f913781796957c9fda0a4e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yuJqpp2Fs1ZQglxj.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bf09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上一篇文章中，我描述了如何使用<a class="ae lr" href="https://sidoine.org/oauth-with-serverless-using-sst/" rel="noopener ugc nofollow" target="_blank"> SST Auth </a>构造为您的应用程序实现OAuth认证工作流。</p><p id="c31d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>，React生产框架，也提供了一个名为<a class="ae lr" href="https://next-auth.js.org/" rel="noopener ugc nofollow" target="_blank"> NextAuth.js </a>的组件，可以用来实现这样的认证系统。让我们来比较两种解决方案！</p><h1 id="d414" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是SST Auth？</h1><p id="8893" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">SST是一个最初设计用来构建后端无服务器应用的框架。我已经写了几篇关于这个解决方案的文章(例如，这里的<a class="ae lr" href="https://sidoine.org/sst-the-most-underrated-serverless-framework-you-need-to-discover/" rel="noopener ugc nofollow" target="_blank">这里的</a>和<a class="ae lr" href="https://sidoine.org/sst-the-most-underrated-serverless-framework-you-need-to-discover/" rel="noopener ugc nofollow" target="_blank">这里的</a>)。它还提供了部署web应用程序的特性(例如，通过<a class="ae lr" href="https://docs.sst.dev/constructs/StaticSite" rel="noopener ugc nofollow" target="_blank"> StaticSite </a>构造)，所以它被宣传为构建全栈无服务器应用程序的工具。</p><p id="f1d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://docs.sst.dev/auth" rel="noopener ugc nofollow" target="_blank"> Auth </a>模块是SST团队构建的一组专用组件，用于在您的应用程序内部实现一个身份验证系统。它与React应用程序这样的web应用程序配合得很好。</p><h1 id="4631" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是NextAuth.js？</h1><p id="3e1b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>可能是目前最著名的基于React的框架，在过去几年中获得了很多关注。如今的版本13是真正的全栈框架解决方案，支持服务器端渲染选项和API层。可以查一下，比如<a class="ae lr" href="https://www.youtube.com/watch?v=W4UhNo3HAMw" rel="noopener ugc nofollow" target="_blank"> Theo Browne video: Next.js是后端框架</a>很好的介绍了后端部分。</p><p id="551c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://next-auth.js.org/" rel="noopener ugc nofollow" target="_blank"> NextAuth.js </a>是一个独立的库(不受Vercel支持)，它的座右铭是:“对Next.js进行身份验证”，它提供了一个内置的解决方案来实现基于OAuth协议的Next.js的身份验证系统。</p><p id="c886" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你知道演员。现在，是时候进行比较了。让我们战斗吧😇。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/0e563522ed907b9ca472f460d212bafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sS4q8fRbavTkAaASINk2EA.jpeg"/></div></div></figure><h1 id="b63f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第一轮:支持的适配器/提供商！</h1><p id="6ca2" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如今，认证不仅仅是电子邮件密码凭证。更多的是像谷歌、脸书或GitHub这样的社交登录。对应用程序开发人员来说更安全(不再需要存储密码！)和应用程序最终用户(无需记住新密码！).让我们检查一下我们的两个选择支持什么。</p><p id="0f7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，SST Auth今天(2022年11月)<a class="ae lr" href="https://docs.sst.dev/auth#adapters" rel="noopener ugc nofollow" target="_blank">支持开箱即用的七个适配器</a> : Google、GitHub、Twitch、脸书、Magic Link、OAuth和OIDC。最后两个是通用适配器，可用于支持<a class="ae lr" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>或<a class="ae lr" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OIDC </a>的任何应用。最后，如果没有适合您的需求，可以选择构建一个定制适配器<a class="ae lr" href="https://docs.sst.dev/auth#custom-adapters" rel="noopener ugc nofollow" target="_blank">。例如，在这篇</a><a class="ae lr" href="https://sidoine.org/oauth-with-serverless-using-sst/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我构建了一个自定义适配器来支持SmugMug，它依赖于OAuth 1.0a协议。</p><p id="64e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">NextAuth.js支持超过<a class="ae lr" href="https://next-auth.js.org/providers/" rel="noopener ugc nofollow" target="_blank"> 20个提供者</a>开箱即用:经典的如谷歌、脸书和GitHub都在这里，但是比SST Auth有更多的选择。还有一个<a class="ae lr" href="https://next-auth.js.org/configuration/providers/email" rel="noopener ugc nofollow" target="_blank"> email </a>提供者(可以比作SST Auth上的Magic Link one)或者一个<a class="ae lr" href="https://next-auth.js.org/configuration/providers/oauth#using-a-custom-provider" rel="noopener ugc nofollow" target="_blank">自定义提供者</a>。最后，如果您需要通过用户名、密码或其他任意凭证(例如YubiKey)登录，那么<a class="ae lr" href="https://next-auth.js.org/configuration/providers/credentials" rel="noopener ugc nofollow" target="_blank">凭证</a>提供程序是理想的选择。</p><p id="df37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与SST Auth相比，使用NextAuth.js有更多现成的选项。但是如果需要的话，这两种解决方案都可以为您提供定制。</p><h1 id="e0ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第2轮:易于实施</h1><p id="d209" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">认证是一个<a class="ae lr" href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">严肃的</a>课题，你不会想依赖一个你100%不信任的系统。这就是为什么理解如何实现解决方案以及理解和调整它有多容易是很重要的。</p><p id="b8ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看SST Auth:</p><ul class=""><li id="db98" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">首先需要在基础设施栈中添加<code class="fe mz na nb nc b">Auth</code>构造(通常是<code class="fe mz na nb nc b">stacks/MyStack.ts</code>文件)</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="06bf" class="nh lt iq nc b be ni nj l nk nl">import { Auth } from "@serverless-stack/resources";<br/><br/>const auth = new Auth(stack, "auth", {<br/>  authenticator: {<br/>    handler: "functions/auth.handler",<br/>  },<br/>});<br/><br/>auth.attach(stack, {<br/>  api: myApi,<br/>  prefix: "/auth", // optional<br/>});ty</span></pre><ul class=""><li id="877c" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">然后您可以在<code class="fe mz na nb nc b">src/functions/auth.ts</code>中构建一个新的无服务器函数，它将负责所有的认证调用(例如，OAuth2的<code class="fe mz na nb nc b">authorize</code>和<code class="fe mz na nb nc b">callback</code>端点):</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="c49f" class="nh lt iq nc b be ni nj l nk nl">import { AuthHandler, GoogleAdapter } from "@serverless-stack/node/auth";<br/><br/>export const handler = AuthHandler({<br/>  providers: {<br/>    google: GoogleAdapter({<br/>      mode: "oidc",<br/>      clientID: "XXXX",<br/>      onSuccess: async (tokenset) =&gt; {<br/>        return {<br/>          statusCode: 200,<br/>          body: JSON.stringify(tokenset.claims()),<br/>        };<br/>      },<br/>    }),<br/>  },<br/>});</span></pre><p id="93d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个示例案例(来自<a class="ae lr" href="https://docs.sst.dev/auth#add-a-handler" rel="noopener ugc nofollow" target="_blank">认证文档</a>)正在创建一个基于Google SignIn的认证系统。它将公开两个端点:</p><ul class=""><li id="7484" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated"><code class="fe mz na nb nc b">/auth/google/authorize</code></li><li id="c1f1" class="mq mr iq kx b ky nm lb nn le no li np lm nq lq mv mw mx my bi translated"><code class="fe mz na nb nc b">/auth/google/callback</code></li><li id="dcdf" class="mq mr iq kx b ky nm lb nn le no li np lm nq lq mv mw mx my bi translated">最后，由您的前端应用程序(例如React)将用户重定向到<code class="fe mz na nb nc b">autorize</code>后端端点(这将启动OAuth2流)。</li></ul><p id="96db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们放大一下NextAuth.js:</p><ul class=""><li id="abf4" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">首先，您需要在Next.js项目中安装NextAuth.js:</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="88ae" class="nh lt iq nc b be ni nj l nk nl">yarn add next-auth</span></pre><ul class=""><li id="0164" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">然后，您必须在设计的<code class="fe mz na nb nc b">pages/api/</code>文件夹中的下一个项目中创建一个新的API。因此，创建一个名为<code class="fe mz na nb nc b">pages/api/auth/[...nextauth].js</code>的文件，内容如下:</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="afb6" class="nh lt iq nc b be ni nj l nk nl">import NextAuth from "next-auth"<br/>import GoogleProvider from "next-auth/providers/google"<br/>export const authOptions = {<br/>  // Configure one or more authentication providers<br/>  providers: [<br/>    GoogleProvider({<br/>      clientId: process.env.GOOGLE_ID,<br/>      clientSecret: process.env.GOOGLE_SECRET,<br/>    }),<br/>  ],<br/>}<br/>export default NextAuth(authOptions)</span></pre><p id="a923" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个API代理端点完全等同于为SST创建的<code class="fe mz na nb nc b">auth.ts</code>。NextAuth.js将负责为<code class="fe mz na nb nc b">authorize</code>和<code class="fe mz na nb nc b">callback</code>创建多个端点来支持OAuth2。</p><ul class=""><li id="d6b1" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">那么建议在应用程序的顶层实现<code class="fe mz na nb nc b">SessionProvider</code>(在<code class="fe mz na nb nc b">pages/_app.jsx</code>):</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="7115" class="nh lt iq nc b be ni nj l nk nl">import { SessionProvider } from "next-auth/react"<br/>export default function App({<br/>  Component,<br/>  pageProps: { session, ...pageProps },<br/>}) {<br/>  return (<br/>    &lt;SessionProvider session={session}&gt;<br/>      &lt;Component {...pageProps} /&gt;<br/>    &lt;/SessionProvider&gt;<br/>  )<br/>}</span></pre><ul class=""><li id="19b5" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">最后，使用NextAuth.js提供的专用方法允许最终用户登录或注销:</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="cb29" class="nh lt iq nc b be ni nj l nk nl">import { useSession, signIn, signOut } from "next-auth/react"<br/>export default function Component() {<br/>  const { data: session } = useSession()<br/>  if (session) {<br/>    return (<br/>      &lt;&gt;<br/>        Signed in as {session.user.email} &lt;br /&gt;<br/>        &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>  return (<br/>    &lt;&gt;<br/>      Not signed in &lt;br /&gt;<br/>      &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="f6c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文不会深入讨论实现，但是每个解决方案都提供了一个会话系统来检索前端和后端的用户数据。也有可能阻止未经认证的用户访问。</p><p id="911e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总结这一点，两种解决方案都足够简单，可供前端开发人员使用，并且不需要大量代码。提供的文档也非常完整。打平了！</p><h1 id="9816" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第三轮:存储用户相关信息！</h1><p id="e5b9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一旦实现了身份验证，您可能需要存储一些与每个用户相关的信息。例如，profile部分需要持久化，或者任何与您的精确业务案例相关的信息。同样，这两种解决方案都有一个解决方案。</p><p id="0f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于SST Auth，依赖于一个独特的SST构造<a class="ae lr" href="https://docs.sst.dev/constructs/Table" rel="noopener ugc nofollow" target="_blank">表</a>是相当自然的，它依赖于AWS DynamoDB。通过实现每个适配器中可用的<code class="fe mz na nb nc b">onSuccess</code>方法，可以将用户数据存储在DynamoDB:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="fa9b" class="nh lt iq nc b be ni nj l nk nl">export const handler = AuthHandler({<br/>  providers: {<br/>    smugmug: SmugMugAdapter({<br/>      clientId: process.env.SMUGMUG_CLIENT_ID!,<br/>      clientSecret: process.env.SMUGMUG_CLIENT_SECRET!,<br/>      onSuccess: async (user: SmugMugUser) =&gt; {<br/>        const ddb = new DynamoDBClient({});<br/>        await ddb.send(<br/>          new PutItemCommand({<br/>            TableName: Table.users.tableName,<br/>            Item: marshall(user),<br/>          })<br/>        );<br/><br/>        return Session.parameter({<br/>          redirect: process.env.IS_LOCAL<br/>            ? "http://127.0.0.1:3000"<br/>            : ViteStaticSite.site.url,<br/>          type: "user",<br/>          properties: {<br/>            userID: user.userId,<br/>          },<br/>        });<br/>      },<br/>    }),<br/>  },<br/>});</span></pre><p id="365c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nr">示例取自</em> <a class="ae lr" href="https://sidoine.org/oauth-with-serverless-using-sst/" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> OAuth，无服务器使用SST </em> </a></p><p id="5716" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用NextAuthjs，可以实现一个<a class="ae lr" href="https://next-auth.js.org/adapters/overview" rel="noopener ugc nofollow" target="_blank">适配器</a></p><p id="f641" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong> : NextAuthjs适配器不同于SST Auth适配器！</p><p id="cb8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有十多个选项，包括DynamoDB、Firebase、Prisma、FaunaDB……让我们在这里放大DynamoDB适配器:</p><ul class=""><li id="19e8" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">安装相应的适配器:</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="1cb3" class="nh lt iq nc b be ni nj l nk nl">yarn add next-auth @next-auth/dynamodb-adapter</span></pre><ul class=""><li id="cf48" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">在<code class="fe mz na nb nc b">pages/api/auth/[...nextauth].js</code>中编辑您现有的API:</li></ul><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="902d" class="nh lt iq nc b be ni nj l nk nl">import { DynamoDB } from "@aws-sdk/client-dynamodb"<br/>import { DynamoDBDocument } from "@aws-sdk/lib-dynamodb"<br/>import NextAuth from "next-auth";<br/>import Providers from "next-auth/providers";<br/>import { DynamoDBAdapter } from "@next-auth/dynamodb-adapter"<br/><br/>const config: DynamoDBClientConfig = {<br/>  credentials: {<br/>    accessKeyId: process.env.NEXT_AUTH_AWS_ACCESS_KEY as string,<br/>    secretAccessKey: process.env.NEXT_AUTH_AWS_SECRET_KEY as string,<br/>  },<br/>  region: process.env.NEXT_AUTH_AWS_REGION,<br/>};<br/><br/>const client = DynamoDBDocument.from(new DynamoDB(config), {<br/>  marshallOptions: {<br/>    convertEmptyValues: true,<br/>    removeUndefinedValues: true,<br/>    convertClassInstanceToMap: true,<br/>  },<br/>})<br/><br/>export default NextAuth({<br/>  providers: [<br/>    Providers.Google({<br/>      clientId: process.env.GOOGLE_ID,<br/>      clientSecret: process.env.GOOGLE_SECRET,<br/>    }),<br/>  ],<br/>  adapter: DynamoDBAdapter(<br/>    client<br/>  ),<br/>});</span></pre><p id="ce2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里您将获得关于适配器<a class="ae lr" href="https://next-auth.js.org/adapters/dynamodb" rel="noopener ugc nofollow" target="_blank">的更多信息。注意，在使用DynamoDB表之前，您需要创建它(NextAuth.js不处理资源的创建)。</a></p><p id="d191" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两种解决方案都实现了存储与用户相关的信息的选项。SST依赖于构造，NextAuth依赖于适配器。SST是一个更加集成的解决方案，因为它将处理资源创建(代码内置的基础设施)。又没有明显的赢家了！</p><h1 id="4e1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第4轮:部署选项！</h1><p id="b128" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在是时候发布您的应用程序了！每个解决方案的流程有多简单？让我们找到它！</p><p id="a404" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SST Auth是SST的一部分。这个无服务器框架是为AWS设计的。因此，如果您依赖于这个特定的云提供商，这将是最好的，但它有一个专用的CLI命令来推送您的应用程序。正如<a class="ae lr" href="https://docs.sst.dev/quick-start#4-deploy-to-prod" rel="noopener ugc nofollow" target="_blank">所记录的</a>，这个命令将把你的应用程序发送到天堂云:</p><pre class="kg kh ki kj gt nd nc ne bn nf ng bi"><span id="1e34" class="nh lt iq nc b be ni nj l nk nl">yarn deploy --stage prod</span></pre><blockquote class="ns nt nu"><p id="81cf" class="kv kw nr kx b ky kz jr la lb lc ju ld nv lf lg lh nw lj lk ll nx ln lo lp lq ij bi translated">建议为生产环境使用特定的阶段，因为SST被设计为使用多个实例:当您在应用程序上开发时，您使用的是具有强大的<a class="ae lr" href="https://docs.sst.dev/live-lambda-development" rel="noopener ugc nofollow" target="_blank"> Live Lambda开发</a>模式的独特阶段(如dev)。</p></blockquote><p id="7505" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于NextAuth.js，您必须部署一个Next.js应用程序。这里的捷径是在Next.js的创建者<a class="ae lr" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>上部署你的应用程序。它有一个慷慨的免费层，开箱即用:用GitHub自动部署，预览部署，等等。但是Next.js应用程序也可以部署在许多其他提供者中。对于您自己的受管节点服务器到无服务器的部署，选择正确的部署取决于您！完整列表见<a class="ae lr" href="https://nextjs.org/docs/deployment" rel="noopener ugc nofollow" target="_blank"> Next.js文档页面</a>。</p><blockquote class="ns nt nu"><p id="633d" class="kv kw nr kx b ky kz jr la lb lc ju ld nv lf lg lh nw lj lk ll nx ln lo lp lq ij bi translated">让我们提一下，使用SST部署Next.js应用程序是可能的😅。<br/>这个设置依赖于<a class="ae lr" href="https://github.com/serverless-nextjs/serverless-next.js" rel="noopener ugc nofollow" target="_blank"> serverless-next.js </a>项目，它隐藏在一个名为<a class="ae lr" href="https://docs.sst.dev/constructs/NextjsSite" rel="noopener ugc nofollow" target="_blank"> NextJsSite </a>的构造后面。当您想要在AWS环境上发布应用程序时，它可能是一个非常有效的解决方案(我在当前公司的生产工作负载中使用它)。</p></blockquote><p id="ee74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总结本节，SST的设计在部署中更受限制(仅AWS)。对于Next.js，经典的方式是依赖于Vercel，但也有其他选择(包括AWS上的SST本身)。</p><h1 id="1827" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="89e6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">比较不同类别的工具是不公平的！但是我认为有时比较特定的特性(这里是身份验证)是有用的，因为两个解决方案中的实现非常相似。</p><p id="1748" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您需要构建一个必须依赖多个AWS服务的应用程序时，SST是一个非常好的选择；可以将基础设施定义为代码，然后使用一个<a class="ae lr" href="https://docs.sst.dev/constructs/Queue" rel="noopener ugc nofollow" target="_blank">队列</a>、一个<a class="ae lr" href="https://docs.sst.dev/constructs/Bucket" rel="noopener ugc nofollow" target="_blank">桶</a>和一个<a class="ae lr" href="https://docs.sst.dev/constructs/RDS" rel="noopener ugc nofollow" target="_blank">数据库</a>，仅举几个例子。这是这里最具扩展性的解决方案。在这里阅读我对SST的介绍:<a class="ae lr" href="https://sidoine.org/sst-the-most-underrated-serverless-framework-you-need-to-discover/" rel="noopener ugc nofollow" target="_blank"> SST是你需要发现的最被低估的无服务器框架</a></p><p id="0696" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">NextAuth.js只是一个库，使用这个解决方案可以更快地在现有的Next.js应用程序中添加身份验证层。这是这里集成程度最高的解决方案。</p><p id="cafe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我建议在这里试用这两种解决方案，并在<a class="ae lr" href="https://twitter.com/_julbrs" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我你的反馈(如果你读它的时候它还在运行！).</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="9299" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nr">原载于</em>【https://sidoine.org】<em class="nr"/></p></div></div>    
</body>
</html>