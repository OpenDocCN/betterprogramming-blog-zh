<html>
<head>
<title>Deploy GoLambda With MongoDB and AWS SAM (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB和AWS SAM部署GoLambda(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sam-deploys-golambda-w-mongodb-a03cd97bae45?source=collection_archive---------11-----------------------#2019-12-30">https://betterprogramming.pub/sam-deploys-golambda-w-mongodb-a03cd97bae45?source=collection_archive---------11-----------------------#2019-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8360" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">微服务风雨兼程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69350f4a5fe08807245b9735576b1279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cScxYumqz3H1AtpOsZNunw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">萨姆-蒙戈得布-戈[弗]</p></figure><p id="6adf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你喜欢<em class="lr">而不是</em>有参照物来造东西吗？尽管这三种技术广为人知，但我很难找到另一篇文章来展示它们协同工作的模型。事实上，我没有找到。所以，我生了这个！</p><p id="d1ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想用一种新的语言开始新的一年。我还想记录一些我在这个过程中学到的东西。这篇文章更多的是解释我是如何让Go在本地运行的，以及我用SAM、Go和Mongo驱动程序在本地开发的经历。我将带您开始我的设置之旅，然后带您了解制作这个API的大约九个方法。<em class="lr"> Ahora </em>，我们开始吧！</p><p id="6c4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文假设您有一些使用Lambda函数和SAM以及MongoDB的经验，但是没有在Go中使用它们。如果没有，首先要有<a class="ae ls" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>、<a class="ae ls" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> SAM </a>、<a class="ae ls" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>和<a class="ae ls" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker </a>。这是一个周末项目，我和我的介绍去。请欣赏！</p><p id="1122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装好所有东西后，就可以开始工作了。</p><p id="205e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，你需要<code class="fe lt lu lv lw b">cd</code>到你的Go目录。我用的是Mac，所以对我来说这个目录最初位于<code class="fe lt lu lv lw b">$HOME/go</code>。把它放在哪里很重要，因为你所有的Goroutines都需要放在这里的<code class="fe lt lu lv lw b">src/</code>目录中——稍后会详细介绍。所以，既然我喜欢把<em class="lr">东西个性化</em>，我决定把它移到我的<code class="fe lt lu lv lw b">projects/</code>目录里。</p><p id="cc5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">*自从添加了<a class="ae ls" href="https://blog.golang.org/migrating-to-go-modules" rel="noopener ugc nofollow" target="_blank">模块</a>后，这种情况有所改变。</p><p id="fa8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了做到这一点，并仍然有工作，我需要更新我的<code class="fe lt lu lv lw b">$PATH</code>。因为我使用Zsh，所以我需要用下面几行代码更新我的<code class="fe lt lu lv lw b">.zshrc</code>:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="57f0" class="mb mc iq lw b gy md me l mf mg">export GOPATH=$HOME/porjects/go<br/>export PATH="$PATH:$HOME/projects/go/bin"</span></pre><p id="5076" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行以下程序为您的Goroutine制作<code class="fe lt lu lv lw b">dir</code>:</p><p id="c9a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lt lu lv lw b">$ mkdir $HOME/projects/go/src/test-go</code></p><p id="641a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我所有的围棋程序都需要在这里运行<code class="fe lt lu lv lw b">$HOME/projects/go/src</code>。这就是所谓的Go <em class="lr">工作空间。</em>你可以在这里阅读更多关于Go Workspaces <a class="ae ls" href="https://golang.org/doc/code.html#Workspaces" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="aead" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我运行以下代码，使用SAM CLI创建一个锅炉板Hello World Golang Lambda:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="37d8" class="mb mc iq lw b gy md me l mf mg">$ cd $HOME/projects/go/src/test-go<br/>$ sam init — runtime go1.x — name test-go</span></pre><p id="c062" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您在终端中运行上面的命令时，您会得到这样的结果。</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="0de7" class="mb mc iq lw b gy md me l mf mg">.<br/>└── test-go<br/>    ├── Makefile<br/>    ├── README.md<br/>    ├── hello-world<br/>    │   ├── test-go<br/>    │   ├── hello-world<br/>    │   ├── main.go<br/>    │   └── main_test.go<br/>    └── template.yaml</span></pre><p id="9ba1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们要运行:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="32df" class="mb mc iq lw b gy md me l mf mg">$ make deps<br/>$ make build<br/>$ sam local start-api</span></pre><p id="03d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在新的终端窗口中，你可以运行<code class="fe lt lu lv lw b">curl localhost:3000/hello</code>或者直接在浏览器中打开它。</p><p id="cf32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您所有的<code class="fe lt lu lv lw b">aws-cli</code>凭证都准备好了，第一次运行<code class="fe lt lu lv lw b">$ sam local start-api</code>时，您会在控制台上看到类似这样的内容:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="e0cc" class="mb mc iq lw b gy md me l mf mg">Mounting HelloWorldFunction at <a class="ae ls" href="http://127.0.0.1:3000/hello" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/hello</a> [GET]<br/>You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. You only need to restart SAM CLI if you update your AWS SAM template<br/>2019-12-15 13:23:18  * Running on <a class="ae ls" href="http://127.0.0.1:3000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/</a> (Press CTRL+C to quit)<br/>Invoking hello-world (go1.x)<br/>2019-12-15 13:23:35 Found credentials in shared credentials file: ~/.aws/credentials</span><span id="1a36" class="mb mc iq lw b gy mh me l mf mg">Fetching lambci/lambda:go1.x Docker container image..........................................................................................................................</span></pre><p id="5bc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，你可以使用<code class="fe lt lu lv lw b">curl <a class="ae ls" href="http://localhost:3000/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello</a></code>或者通过浏览器访问我上面提到的URL来调用你的lamba。</p><p id="d24b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！您已经开始运行并正在发展，但现在是谈论几个<em class="lr">问题</em>的好时机。</p><ul class=""><li id="95e8" class="mi mj iq kx b ky kz lb lc le mk li ml lm mm lq mn mo mp mq bi translated">现在所有这些都是假设您还没有将<code class="fe lt lu lv lw b">test-go/</code>初始化为一个Git库。如果您这样做并试图运行<code class="fe lt lu lv lw b">$ make deps</code>命令，您可能会遇到类似如下的错误:</li></ul><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="1141" class="mb mc iq lw b gy md me l mf mg">$ make deps<br/>go get -u ./...<br/># cd /Users/jahagitonga/projects/go/src/test-go; git submodule update --init --recursive<br/>fatal: No url found for submodule path 'test-go' in .gitmodules<br/>package aahs-go-back-end/aahs-func/test-go: exit status 128</span></pre><ul class=""><li id="d21a" class="mi mj iq kx b ky kz lb lc le mk li ml lm mm lq mn mo mp mq bi translated">SAM将<em class="lr">不会</em>原生热重装Golang lambdas，这<em class="lr">太可怕了</em>。有鉴于此，我们需要一个名为<a class="ae ls" href="https://www.npmjs.com/package/supervisor" rel="noopener ugc nofollow" target="_blank"> supervisor </a>的节点包来帮助我们观察变化。是的，我们需要Node，所以如果你没有Node，请点击<a class="ae ls" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多关于Node的信息，并在你的机器上安装Node。</li></ul><p id="550c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们更新Makefile。我的Makefile看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Go Makefile支持代码更改时的热重载</p></figure><p id="989c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个想法来自于Ucchishta Sivagur。他的回购可以在这里查看<a class="ae ls" href="https://github.com/uccmen/serverless-go" rel="noopener ugc nofollow" target="_blank"/>。谢谢uccmen！如果您更新了Makefile run <code class="fe lt lu lv lw b">$ make &amp;&amp; make watch</code>，您就可以为Golang Lambda启用热重装了。太棒了。</p><ul class=""><li id="9b9a" class="mi mj iq kx b ky kz lb lc le mk li ml lm mm lq mn mo mp mq bi translated">构建lambda时，如果您忘记在<code class="fe lt lu lv lw b">template.yaml</code>文件中声明方法，您会在本地看到这个错误:</li></ul><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="0838" class="mb mc iq lw b gy md me l mf mg">{<br/>  "message": "Missing Authentication Token"<br/>}</span></pre><p id="a8d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，请确保您相应地更新了您的<code class="fe lt lu lv lw b">template.yaml</code>文件，尽管该消息极具误导性，也不要惊慌。希望AWS工作人员可以很快得到一个更好的错误消息！</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="8fd5" class="na mc iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">启动并运行MongoDb！</h1><p id="f2b7" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">由于这是一个小项目，我不关心复制或分片；我只需要云中的一个MongoDb实例，所以我选择了<a class="ae ls" href="https://mlab.com/" rel="noopener ugc nofollow" target="_blank"> mLab </a>，因为它是<strong class="kx ir">免费的</strong>，并且是MongoDB旗下的一家公司。如果将来我需要升级和利用复制和分片的能力，我可以毫无问题地迁移到Atlas。</p><p id="1fe4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要一些依赖项来完成这项工作:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="ee73" class="mb mc iq lw b gy md me l mf mg">"github.com/joho/godotenv"</span><span id="224e" class="mb mc iq lw b gy mh me l mf mg">"go.mongodb.org/mongo-driver/bson/primitive"</span><span id="5825" class="mb mc iq lw b gy mh me l mf mg">"go.mongodb.org/mongo-driver/mongo"</span><span id="d98b" class="mb mc iq lw b gy mh me l mf mg">"go.mongodb.org/mongo-driver/mongo/options"</span><span id="d8a3" class="mb mc iq lw b gy mh me l mf mg">"go.mongodb.org/mongo-driver/mongo/readpref"</span><span id="af48" class="mb mc iq lw b gy mh me l mf mg">bson "go.mongodb.org/mongo-driver/bson"</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="8843" class="na mc iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">造拉姆达！</h1><p id="1f04" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们可以将上述内容添加到我们的<code class="fe lt lu lv lw b">main.go</code>文件的导入语句中。我用过的所有软件包的完整列表可以在<a class="ae ls" href="https://github.com/JNaeemGitonga/first-golang-app" rel="noopener ugc nofollow" target="_blank"> repo </a>中的<a class="ae ls" href="https://github.com/JNaeemGitonga/first-golang-app/blob/master/aahs-func/aahs-backend/main.go" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们开始看<code class="fe lt lu lv lw b">func main()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">func main() {…}</p></figure><p id="b068" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我喜欢让事情变得简单，所以<code class="fe lt lu lv lw b">func main()</code>要做的第一件事就是获取我们的环境变量，检查是否已经有一个Mongo客户端，并且<code class="fe lt lu lv lw b">mongoURI</code>没有被赋值为空字符串。一旦我们这样做了，我们就连接到我们的MongoDb实例，或者启动lambda。</p><p id="2809" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我注意到的来自JavaScript的第一件事是Go在处理环境变量时需要一点帮助。你可以使用你的系统和Go给你的<code class="fe lt lu lv lw b">os</code>包来制作和访问它们。但是如果你习惯于使用<code class="fe lt lu lv lw b">.env</code>文件存储这些变量，而不是在你的系统上，你将需要导入<code class="fe lt lu lv lw b"><a class="ae ls" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank">"github.com/joho/godotenv"</a></code>。即使在Node中，您也需要<code class="fe lt lu lv lw b"><a class="ae ls" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a></code>包，以便Node进程从您的系统和<code class="fe lt lu lv lw b">.env</code>文件中收集这些<code class="fe lt lu lv lw b">env</code>变量。要访问它们，你只需要<code class="fe lt lu lv lw b">proces.env.YOUR_VAR_NAME</code>。但是我们不是在处理Node的简单性！检查<code class="fe lt lu lv lw b">getMongoURIEnvVar</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe lt lu lv lw b">func getMongoURIEnvVar() {...}</code></p></figure><p id="48c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数只是取了一个类型为<code class="fe lt lu lv lw b">string</code>的名字。首先，我们必须加载<code class="fe lt lu lv lw b">.env</code>文件，然后我们可以使用<code class="fe lt lu lv lw b">os</code>包来检索分配给该名称的值。注意<code class="fe lt lu lv lw b">Load</code>方法如何只返回一个错误——有趣的假设。如果没有错误，它一定是有效的，对吗？</p><p id="a15b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经了解了所有这些，让我们看看如何连接到我们的mongo实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="933a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里你可以看到我首先检查客户是否不是<code class="fe lt lu lv lw b">nil</code>。如果不是，程序将继续运行，并使用可用于连接池的缓存实例(最佳实践)。如果是<code class="fe lt lu lv lw b">nil</code>，我们创建一个<code class="fe lt lu lv lw b">connectionError</code>变量，因为简写声明/赋值<code class="fe lt lu lv lw b">:=</code>不会干扰我们在<code class="fe lt lu lv lw b">line 7</code>上全局使用<code class="fe lt lu lv lw b">client</code>。我们还创建了一个<code class="fe lt lu lv lw b"><a class="ae ls" href="https://golang.org/pkg/context/" rel="noopener ugc nofollow" target="_blank">context</a></code>,我们的函数将在其中运行并连接到数据库(我们也有一些基本的错误处理日志)。在高级术语中，这个<em class="lr">上下文</em>表示如果程序在15秒内没有连接，就停止并继续运行。Go有很棒的关于谷歌如何使用上下文的文档。</p><p id="2c2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在使用上下文之后注意并规范我们的使用，我们也可以开发出超高效的API。我在这里做得不错，但我希望更有经验的<em class="lr">地鼠</em>能给我一些关于如何优化这里的<em class="lr">指点</em>——双关语！你需要传递上下文以确保你的应用程序的效率，并且一旦在上下文中执行了一些事情，这些资源就会得到适当的释放。语境越来越深，所以请查看我在这一段列出的两个资源，以了解关于语境的所有事情。</p><p id="5724" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不管连接与否，我们的Goroutine的下一步是启动我们的处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7004" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我尽量保持简单(接吻)，对吧？请注意，我创建了另一个上下文。这是我们的CRUD操作运行的环境。我将把它传递给我的函数，一旦它们返回了这个Goroutine将运行对<code class="fe lt lu lv lw b">cancel()</code>的<code class="fe lt lu lv lw b">defer</code>调用，这将取消上下文，从而释放那些资源。接下来，我将检查客户端是否是<code class="fe lt lu lv lw b">nil</code>。如果是，这是不应该的，程序将向客户端发送一个错误，警告最终用户无法建立连接——用这么多的话来说。</p><p id="2d03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我使用一个简单的<code class="fe lt lu lv lw b">switch</code>语句来决定接下来会发生什么。我选择这样做是因为这个项目很小，我只使用一个<em class="lr">通吃</em>路线来处理我的请求。如果项目更大，我可能不会，但看到这是一个使用Go、MongoDb和SAM的例子，就知道这里的一切并不完全符合RESTful规范——但我们真的很接近了！</p><p id="4753" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">话虽如此，我们还是来看看<code class="fe lt lu lv lw b">func getStories()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0b27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我联系了客户。我这样做是为了确保事情进展顺利。如果不是，程序会抛出一个错误。但是假设事情是这样的，那么我们在我们的集合上执行一个find，评估它的错误，并使用<code class="fe lt lu lv lw b">cursor</code>的<code class="fe lt lu lv lw b">.Next()</code>方法循环遍历光标，将它的元素解码成我们的Goroutine稍后可以使用的东西。然后，我们将它们添加到一个故事列表中，并返回对<code class="fe lt lu lv lw b">func marshalJSONAndSend()</code>的调用，将我们的列表传递给它。在<code class="fe lt lu lv lw b">return</code>执行后做的最后一件事是<em class="lr">延迟</em>调用<code class="fe lt lu lv lw b">cursor.Close(ctx)</code>。</p><p id="f2ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是<code class="fe lt lu lv lw b">func marshalJSONAndSend()</code>呢。好吧，让我们来看一看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fcb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个小家伙将获取我们的故事列表，将其转换为数据类型— <code class="fe lt lu lv lw b">[]byte</code> —然后可以转换为字符串—<code class="fe lt lu lv lw b">line 7</code>，并通过我们的API网关响应发送给客户端。</p><p id="3950" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！</p><p id="a780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我一直在用这个<code class="fe lt lu lv lw b">func handleError()</code>但是没有显示出来。没什么大不了的。你自己看看吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">func handleError(err error)(事件。APIGatewayProxyResponse，错误){…}</p></figure><p id="202e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们快完成了。我们能够从数据库中读取数据，但是让我们创建一个文档。我们用我们的<code class="fe lt lu lv lw b">func postStory()</code>做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我遵循其他方法中使用的相同模式，所以没有任何变化，但我确实需要做一些类型转换，以便它可以正确地添加到我的数据库中。完成之后，我使用一个变量<code class="fe lt lu lv lw b">newDbResult</code>，根据结果的类型创建一个结果图。我这样做是为了减少一些用于处理结果和发送适当响应的代码。在我们跳到<code class="fe lt lu lv lw b">func handleResultSendResponse()</code>之前，让我们先来看看这个故事<code class="fe lt lu lv lw b">struct</code>。<a class="ae ls" href="https://tour.golang.org/moretypes/2" rel="noopener ugc nofollow" target="_blank">struct</a>让我想起了TypeScript中的<code class="fe lt lu lv lw b">interfaces</code>(记得我来自JavaScript之地)。它们用于枚举一段数据的字段。它们包含作为字段的名称以及与所述字段相关联的值类型。它们还包含对我们的API的正常运行至关重要的元数据。看看这个故事<code class="fe lt lu lv lw b">struct</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4173" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果字段类型右侧没有元数据，我们的结构就不会映射到JSON/BSON模式。我们还需要大写字段名。看看这个家伙对大写<code class="fe lt lu lv lw b">structs</code>的字段名有什么看法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/094c2a03e2cee799359bb5021f2c6439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gckielj4oSdCHBWGFNyGEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae ls" href="https://github.com/asaskevich/govalidator/issues/187" rel="noopener ugc nofollow" target="_blank">https://github.com/asaskevich/govalidator/issues/187</a></p></figure><p id="3a3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么<code class="fe lt lu lv lw b">func handleResultSendResponse()</code>呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ed5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我对代码做了注释，所以，现在你知道了。这里重要的是<em class="lr">反射</em>。Golang使用<code class="fe lt lu lv lw b">reflect</code>允许我们以更动态的方式使用Go，例如，在运行时和编译时检查类型。反思理应有自己的岗位。以至于除了Go docs <a class="ae ls" href="https://golang.org/pkg/reflect/" rel="noopener ugc nofollow" target="_blank">这里</a>和他们的blog <a class="ae ls" href="https://blog.golang.org/laws-of-reflection" rel="noopener ugc nofollow" target="_blank">这里</a>之外，我在这里找到了一个不错的<a class="ae ls" href="https://medium.com/capital-one-tech/learning-to-use-go-reflection-822a0aed74b7" rel="noopener">。一旦我们正确地<em class="lr">反射了</em>，我们就能够<code class="fe lt lu lv lw b">fmt.Sprintf</code>一个<code class="fe lt lu lv lw b">string</code>，这样我们就可以将它发送回我们的客户端<code class="fe lt lu lv lw b">func handleResultSendResponse()</code>的<code class="fe lt lu lv lw b">line 18</code>。了解反射让我可以在其他地方重用一些代码。你会喜欢的！</a></p><p id="25ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们最后拥有的是更新功能。让我们开始吧！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f9c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我说我必须习惯所有的类型转换，这是<em class="lr">需要</em>来运行这个API。如果有人有更好的方法或优化，请随时给我留言。</p><p id="90df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先我们声明一个变量。把我们得到的更新转换成<code class="fe lt lu lv lw b">[]byte</code> s。在第四行，我喜欢的方式允许我们做一些速记赋值，并在我们的<code class="fe lt lu lv lw b">if/else</code>语句中使用这些变量。当然，这些都在<code class="fe lt lu lv lw b">if</code>块的范围之内，如果它有一个的话，还有它各自的<code class="fe lt lu lv lw b">else</code>。事实上，我非常喜欢它，以至于我愿意违背go的linter，在一个<code class="fe lt lu lv lw b">else</code>块中使用这种语法，这个块除了<code class="fe lt lu lv lw b">return</code>一个函数调用之外什么也不做。我最终重构了代码。</p><p id="751b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们查看我们的<code class="fe lt lu lv lw b">filter</code>和<code class="fe lt lu lv lw b">upDate</code>变量时，我们看到Go驱动程序使用了BSON。这对我来说是新的，双卷边让我想到了棱角。这里有一个关于使用Go驱动程序的很棒的教程。</p><p id="3bb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是部署的时候了。要进行部署，请遵循SAM提供的<code class="fe lt lu lv lw b">README.md</code>中的说明。公开地说，这是让你进入云端的最简单的方法。你可以在这里现场体验这个API<a class="ae ls" href="http://americanairlineshorror.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ee33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管我必须说，当我真的上线时，我还有一个问题要解决。最初，我在全局范围内放置了一些变量。其中一个正在<code class="fe lt lu lv lw b">func getStories()</code>中使用；那是<code class="fe lt lu lv lw b">stories []Story</code>名单。这在本地工作得很好，但是在优化的云中，每次我发出get请求，lambda都会返回一个相同的故事——我在Db中只有一个。我花了大约15分钟才意识到潜在的问题是什么。我能想到的最好的情况是，lambda的上下文比实际的请求持续的时间长，并且每次它收到一个新的请求时，都会向集合中附加一个新的文档。最好的做法是在<code class="fe lt lu lv lw b">func getStories()</code>的范围内使用<code class="fe lt lu lv lw b">stories</code>集合。一旦我这样做了，事情就恢复正常了。</p><p id="7431" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我只有这些了。我希望这能让一些人受益，并节省几个小时的研究时间。让我知道我可以如何改进，你会有什么不同的做法，你喜欢什么！</p><p id="3289" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>