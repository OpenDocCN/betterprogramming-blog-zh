<html>
<head>
<title>The Oddities of SwiftUI NavigationLink</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI NavigationLink的奇特之处</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-navigationlink-does-what-67947249bd8c?source=collection_archive---------3-----------------------#2021-05-04">https://betterprogramming.pub/swiftui-navigationlink-does-what-67947249bd8c?source=collection_archive---------3-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d52c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">大多数人对NavigationLink和SwiftUI本身的第一个问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/941e90325b9c1d032d780ff7d12ce95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QLH779gNssFJo2uB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Safar Safarov </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我非常喜欢SwiftUI。我喜欢写它。我喜欢学习它。我喜欢读关于它的文章。我喜欢揣摩它的内部和行为。</p><p id="6ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我是一个SwiftUI极客。</p><p id="2810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我在读一篇文章，其中一位读者评论说，当他们试图在自己的应用程序中实现建议的解决方案时，他们看到了一些意想不到的行为。</p><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么行为？很高兴你问了。</p><h1 id="91ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">了解导航链接</h1><p id="e583" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它使用<code class="fe ms mt mu mv b">NavigationLink</code>处理。查看以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d24d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简化的iDine应用程序的主菜单屏幕，我在几篇文章中用它来说明各种SwiftUI特性。</p><p id="ddf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们在<code class="fe ms mt mu mv b">NavigationView</code>内部有一个<code class="fe ms mt mu mv b">List</code>。使用<code class="fe ms mt mu mv b">ForEach</code>，我们在菜单上显示每个项目的名称。该名称被包装在一个<code class="fe ms mt mu mv b">NavigationLink</code>中，其目的地是一个用于显示该商品的<code class="fe ms mt mu mv b">DetailView</code>。</p><p id="e5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">足够简单和基本的SwiftUI。</p><p id="753a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当我们显示菜单时会发生什么呢？还有什么意想不到的行为？</p><h1 id="742f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">菜单上有什么？</h1><p id="9b51" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了找到答案，让我们添加一个带有print语句的初始化器到我们的<code class="fe ms mt mu mv b">DetailView</code>中，这样我们就可以看到视图是何时构造的。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="b9e4" class="nc lw it mv b gy nd ne l nf ng">struct DetailView: View {</span><span id="a767" class="nc lw it mv b gy nh ne l nf ng">    let item: MenuItem<br/>    <br/>    init(item: MenuItem) {<br/>        self.item = item<br/>        print("DetailView Initializing \(item.name)")<br/>    }</span><span id="6392" class="nc lw it mv b gy nh ne l nf ng">    var body: some View {<br/>        ScrollView(.vertical) {<br/>            VStack {<br/>                Image(item.mainImage)<br/>                ...</span></pre><p id="17ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行我们的主菜单屏幕并检查日志。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="fbaa" class="nc lw it mv b gy nd ne l nf ng">DetailView Initializing Maple French Toast<br/>DetailView Initializing Stack-o-Pancakes<br/>DetailView Initializing Power Muesli<br/>DetailView Initializing Fresh-baked Croissant<br/>DetailView Initializing Full English<br/>DetailView Initializing Porridge Deluxe<br/>DetailView Initializing Penne Carbonara<br/>DetailView Initializing Mushroom Tagliatelle<br/>DetailView Initializing Tower Burger<br/>DetailView Initializing Thai Red Curry<br/>DetailView Initializing Paella Alicante<br/>DetailView Initializing Superfood Salad<br/>DetailView Initializing Pesto Farfalle<br/>DetailView Initializing Corn on the cob<br/>DetailView Initializing Fillet Steak<br/>DetailView Initializing Cheese Toastie<br/>DetailView Initializing Pepperoni Pizza</span></pre><p id="2cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘣。</p><p id="cd96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对某些人来说，这种行为完全出乎意料。我是说，我们没有打开任何导航链接。那么，为什么我们的目的地视图的所有<em class="ni">都被创建和初始化呢？</em></p><h1 id="cb89" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">视图是结构</h1><p id="000a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我已经在几篇文章中讨论过这个问题，最近的一篇是在SwiftUI 中的<a class="ae ky" href="https://medium.com/p/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">深入内部视图、状态和性能，但它值得重复:</a></p><blockquote class="nj nk nl"><p id="57ef" class="kz la ni lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated"><strong class="lb iu"> SwiftUI视图不是视图。它们是视图的定义。</strong></p></blockquote><p id="1214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当SwiftUI想要呈现一个视图时，它调用它的<code class="fe ms mt mu mv b">body</code>变量来获得我们对这个特定视图应该如何出现的定义。这些定义只不过是Swift结构。</p><p id="074d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主菜单视图根处的<code class="fe ms mt mu mv b">NavigationView</code>实际上只是一个结构体，它希望初始化器中的一些参数告诉它包含什么内容。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="2a5b" class="nc lw it mv b gy nd ne l nf ng">struct NavigationView&lt;Content&gt; : View where Content : View {<br/>    init(@ViewBuilder content: () -&gt; Content) <br/>}</span></pre><p id="d6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的参数是一个<code class="fe ms mt mu mv b">ViewBuilder</code>，一个被调用时将提供视图内容的函数。在上述菜单视图的情况下，该内容将评估为一个<code class="fe ms mt mu mv b">List</code>。</p><p id="a924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">ViewBuilder</code>背后的实际机制超出了本文的范围。这里重要的是，我们需要初始化我们的<code class="fe ms mt mu mv b">NavigationView</code>，为了做到这一点，Swift编译器将需要首先评估该视图的内容，即列表。但是list只是另一个需要自己参数的结构，这意味着在之前的<em class="ni">Swift可以提供它需要的list来评估list的<em class="ni">内容</em>。</em></p><p id="adde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种递归求值一直发生，直到我们到达列表中的<code class="fe ms mt mu mv b">ForEach</code>结构。当SwiftUI呈现列表时，它基本上是用作为数据源的<code class="fe ms mt mu mv b">ForEach</code>来呈现一个<code class="fe ms mt mu mv b">TableView</code>。</p><p id="9295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当需要呈现给定的单元格时，SwiftUI会要求<code class="fe ms mt mu mv b">ForEach</code>数据源给它一个描述单元格内容的视图。这最终将我们引向<code class="fe ms mt mu mv b">NavigationLink</code>，这个特殊故事的罪魁祸首。</p><h1 id="68aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导航链接</h1><p id="db6b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们看一下<code class="fe ms mt mu mv b">NavigationLink</code>的相关初始化器的一个稍微简化的版本。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="ed73" class="nc lw it mv b gy nd ne l nf ng">struct NavigationLink&lt;Label, Destination&gt; : View {<br/>    init(destination: Destination, @ViewBuilder label: () -&gt; Label)<br/>}</span></pre><p id="4bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">NavigationLink</code>是一个结构，在这种情况下，它需要一个定义其目标视图的参数，并再次使用一个<code class="fe ms mt mu mv b">ViewBuilder</code>来定义单元格本身的内容。</p><p id="a620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是细则。</p><ul class=""><li id="68cc" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">为了构造一个<code class="fe ms mt mu mv b">NavigationLink</code>结构，我们必须给它的初始化器所有它需要的参数。</li><li id="c690" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">其中一个参数是目的地视图。</li><li id="8afa" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">那个“视图”反过来也只不过是一个结构。在之前必须完全构造和初始化<em class="ni">的值类型可以作为参数提供给<code class="fe ms mt mu mv b">NavigationLink</code>。</em></li></ul><h1 id="730f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">找到了。</h1><p id="9127" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这就是为什么我们从<code class="fe ms mt mu mv b">DetailView</code>的初始化器中看到所有的打印语句。</p><blockquote class="nj nk nl"><p id="bc78" class="kz la ni lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated"><strong class="lb iu">每个详细视图结构必须完全构建并完全初始化，以便作为参数传递给</strong> <code class="fe ms mt mu mv b"><strong class="lb iu">NavigationLink</strong></code> <strong class="lb iu">。</strong></p></blockquote><p id="a4b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你停下来想一想，它真的不能以任何其他方式工作。SwiftUI可能看起来很神奇，但当你真正了解它时，它只是Swift代码，与该语言中的其他东西一样受到相同的规则和限制。</p><p id="e6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数接受参数。这些参数在被传递之前必须被初始化——仅此而已。</p><h1 id="1ddc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果</h1><p id="102c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不完全是。因为有一个少校，<em class="ni">少校，</em>少校的分支。</p><blockquote class="nj nk nl"><p id="0bf2" class="kz la ni lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated"><strong class="lb iu">不要在你的视图初始化器中做任何繁重的工作。</strong></p></blockquote><p id="c45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说的举重是什么意思？</p><ul class=""><li id="0a80" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">不要在初始化器中创建基于类的对象。</li><li id="f4fd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">不要在初始化器中进行API调用。</li><li id="4d27" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">不要在初始化器中做大量耗时的处理。</li></ul><p id="5470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI视图是轻量级结构是有原因的。不要用堆分配来增加视图初始化过程的负担，或者在那个时间点进行大量的处理。</p><p id="b3ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您并不真正知道SwiftUI何时需要访问您的视图定义。或者多久会这样。</p><p id="17d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你不知道<em class="ni">什么时候</em>一个代码块将被调用，如果你不知道<em class="ni">经常</em>它将被调用，你应该把关键的或者时间密集型的代码放在那里吗？尤其是这样做会对应用程序的性能产生重大影响的时候？我不这么认为。</p><h1 id="3272" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">UIKit和UIViewController</h1><p id="0873" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">部分困惑源于在UIKit工作。当我们从一个视图控制器切换到下一个视图控制器时，目标视图控制器是在那个时间点构建的。</p><p id="86b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们点击一个按钮来显示一个新的视图控制器时，我们构造这个视图控制器并把它传递给导航控制器的<code class="fe ms mt mu mv b">present</code>函数。</p><p id="75f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，直到触发导航的动作发生后的<em class="ni">才构建目的地。</em></p><p id="2e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，正如我们已经看到的，<code class="fe ms mt mu mv b">NavigationLink</code>不是那样工作的。</p><p id="f5a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它<em class="ni">可能</em>有。Apple <em class="ni">可能</em>已经使用了autoclosure来捕获目的地视图，并且只有当导航动作发生时才评估闭包工厂。</p><p id="eb69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是他们没有，所以我们被当前的行为所困。</p><p id="5ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要记住。SwiftUI不是UIKit。</p><h1 id="2abf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">完成块</h1><p id="1889" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这就是为什么我们的读者会看到“意想不到”的行为。他对SwiftUI如何工作的心理模型与SwiftUI在幕后的实际工作方式不符。</p><p id="4acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果您还没有这样做，我强烈建议您阅读我之前的文章，<a class="ae ky" href="https://medium.com/p/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">SwiftUI中的深层视图、状态和性能</a>，在那里我将更详细地讨论这一点和其他swift ui行为。</p><p id="13af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见。</p></div></div>    
</body>
</html>