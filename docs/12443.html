<html>
<head>
<title>Handling UserDefaults in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中处理用户默认值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-userdefaults-in-swift-fc1d5f9448f0?source=collection_archive---------15-----------------------#2022-06-06">https://betterprogramming.pub/handling-userdefaults-in-swift-fc1d5f9448f0?source=collection_archive---------15-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2eae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在大型项目中使用用户默认值的最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a774e8db29925d8ab570a848b19115ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bb8Pu5588HD9fr_Zo9RWCQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@firmbee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Firmbee.com</a>在<a class="ae ky" href="https://unsplash.com/s/photos/macbook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，在应用程序或项目中存储永久信息非常普遍。苹果操作系统为我们提供了一些选项来完成这项任务，毫无疑问，<code class="fe lv lw lx ly b">UserDefaults</code>是最简单的。一行代码和数据被保存。一行代码和数据被检索。这种技术很棒，但是在更大的应用程序中，很容易失去控制，并以到处保存几十个<code class="fe lv lw lx ly b">UserDefaults</code>而告终。然后，你会忘记你是否已经在应用程序的某个地方使用或保存了某个东西。</p><p id="9821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的项目中，我改变了方法，创建了一个<code class="fe lv lw lx ly b">manager</code>类。我给你介绍一下<code class="fe lv lw lx ly b">Persistence</code>。</p><h1 id="f9e5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">脊梁</h1><p id="dc78" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这个想法很简单。我将创建一个类来保存所有需要永久保存的信息。该类在应用程序启动时从<code class="fe lv lw lx ly b">UserDefaults</code>加载，每次变量更新时，整个类都被保存。它基本上是所有持久变量的包装器。</p><p id="6cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Swift <code class="fe lv lw lx ly b">Codable</code>协议，执行此操作变得非常简单。</p><p id="abb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="24a3" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">第5行:需要一个私有的<code class="fe lv lw lx ly b">init</code>来强制从设计的函数中加载。</li><li id="01b5" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">第13行:函数被赋予一个<code class="fe lv lw lx ly b">key</code>，以保存/检索<code class="fe lv lw lx ly b">UserDafaults</code>中的项目。我更喜欢传递它，因为在许多应用程序中，我需要根据登录用户或环境(例如，开发、测试、生产等)保存不同的首选项集。).</li><li id="4cb7" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">第16行:如果该项为空，则使用私有初始化器创建一个全新的项。我们第一次访问它时就需要它。</li><li id="a10b" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">第22行:一个私有扩展添加了一些样板代码来保存和加载对象。请注意，由于对象本身符合<code class="fe lv lw lx ly b">Codable</code>协议，为了持久化它，我在<code class="fe lv lw lx ly b">Data</code>中转换它，然后保存它。另一方面，为了加载它，我检索了<code class="fe lv lw lx ly b">Data</code>，并用<code class="fe lv lw lx ly b">JSONDecoder</code>对其进行解码。</li></ul><p id="1e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类现在很笨，它只存储密钥...这是我们唯一不需要存储的变量！还请注意，从未使用过<code class="fe lv lw lx ly b">save()</code>功能。</p><h1 id="a5dd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">添加基本类型的变量</h1><p id="522c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">是时候加点东西储存了！</p><p id="edbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以这种方式修改这个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情现在开始变得有趣了。</p><ul class=""><li id="a1c8" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">第5行和第6行:添加了两个变量。每次值更新时，<code class="fe lv lw lx ly b">didSet</code>观察器触发<code class="fe lv lw lx ly b">save()</code>函数，整个持久性保存在<code class="fe lv lw lx ly b">UserDefaults</code>中。</li><li id="212f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">第8行:为了只保存想要的变量，需要使用<code class="fe lv lw lx ly b">CodingKeys</code>。<code class="fe lv lw lx ly b">key</code>变量未保存。请注意，您想要保存的每个新变量都需要它的<code class="fe lv lw lx ly b">CodingKey</code>。记得补充一下！</li></ul><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的<code class="fe lv lw lx ly b">extensions</code>不变。</p><p id="2774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的实际结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/99d80433b57085b1ee8c652c034882e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8fSMrSCqubvXzWmuaazKg.jpeg"/></div></div></figure><p id="a7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我已经创建了一个对象，给了它一些值，然后我使用相同的键创建了另一个对象，并打印了实际值。</p><p id="4143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">jsonRepresentation</code>是我编写的<code class="fe lv lw lx ly b">Encodable</code>的扩展，目的是以一种易于阅读的JSON格式打印任何<code class="fe lv lw lx ly b">Encodable</code>对象。</p><h1 id="6e44" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">处理集合</h1><p id="82e6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在较大的应用程序中，保存对象列表是很常见的。例如，您可能需要用户已经检查过的所有“不再显示”弹出窗口的列表。</p><p id="9b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新我们的类来处理这种情况。我将使用一个<code class="fe lv lw lx ly b">enum</code>列表，其中每个案例都是一种“不再显示”的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">enum</code>符合<code class="fe lv lw lx ly b">Codable</code>协议。</p><p id="0a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们更新我们的主类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我在第7行添加了一个新变量<code class="fe lv lw lx ly b">dontShowAnymores</code>，在第10行也添加了一个新变量<code class="fe lv lw lx ly b">CodingKey</code>。</p><p id="4f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到新变量是一个<code class="fe lv lw lx ly b">private (set)</code>。这意味着你需要一个函数来更新它的值。我将在一个扩展中完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bf67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，代码现在非常干净。第5行还有一个检查，如果列表为空，它将创建一个列表。所以现在您可以读取变量，但是您必须使用指定的函数来添加或删除项目。</p><p id="3d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是这样工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/161a0cd9c659b19ca830fb8d8989878e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*og1a0mpFkjtNobzTLmseog.jpeg"/></div></div></figure><p id="87ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，对吧？</p><h1 id="a2a2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">添加复杂对象</h1><p id="1b73" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">老实说，这种事情并不常见，因为在这种持久化中，您通常会保存简单的信息，但有时，您可能需要存储复杂的对象。让我们开始吧。</p><p id="256e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们用下面的代码创建我们的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的类，里面有一个枚举。请注意，这个类和往常一样，符合<code class="fe lv lw lx ly b">Codable</code>协议。</p><p id="42b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将新属性添加到<code class="fe lv lw lx ly b">Persistence</code>类中。你知道规矩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6249aac4427c67548b8e058dc953b1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mZj0Ih0KxT2_YgLLL4o6A.jpeg"/></div></div></figure><p id="131f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们注意一下。</p><p id="545d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要更新<code class="fe lv lw lx ly b">Starcraft</code>对象内部的值，则不会自动调用<code class="fe lv lw lx ly b">save()</code>函数:</p><p id="dfeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">persistence.starcraft.id = "SD777-DV</code>不会拯救整个<code class="fe lv lw lx ly b">Persistence</code>。</p><p id="866a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用三种方法解决它:</p><ol class=""><li id="c41a" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu np ne nf ng bi translated">编写大量代码并调用嵌套对象的每个变量中的<code class="fe lv lw lx ly b">save()</code></li><li id="0d8f" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated">使用<code class="fe lv lw lx ly b">struct</code>代替<code class="fe lv lw lx ly b">class</code>作为内部对象</li><li id="ad7b" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated">检索对象，修改它并更新<code class="fe lv lw lx ly b">Persistence</code>类中的整个对象</li><li id="487a" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated">公开<code class="fe lv lw lx ly b">save()</code>函数，更新内部对象，保存整个<code class="fe lv lw lx ly b">Persistence</code>类</li></ol><p id="730d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就个人而言，我更喜欢选项2或3，但有时选项2不可用，可能是因为对象是从其他地方给定的。比如来自第三方库。</p><h1 id="9c5d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最终代码</h1><p id="479f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这里你可以找到这个故事的所有代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="1ed2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后的话</h1><p id="7edb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如你所见，我向你展示了一种以相对简单的方式在你的应用程序中存储大量内容的方法。这是最好的方法吗？我不知道，但这是我的方式。</p><p id="5496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，如果您保留了许多<code class="fe lv lw lx ly b">Persistence</code>类的实例，那么它们将不会被同步。要解决这个问题，我可以建议三个选择:</p><ol class=""><li id="1223" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu np ne nf ng bi translated">一定要注意创建生活在同一时刻的多个实例。</li><li id="e6e0" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated">将<code class="fe lv lw lx ly b">Persistence</code>类转换成<code class="fe lv lw lx ly b">Singleton</code>。</li><li id="5829" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu np ne nf ng bi translated">将<code class="fe lv lw lx ly b">Dependency Injection</code>与容器一起使用，这样你将确保拥有所需类的一个实例。</li></ol><p id="7d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一般走第三条路！</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="d267" class="ob ma it ly b gy oc od l oe of"><strong class="ly iu">Want to Connect?</strong></span><span id="835b" class="ob ma it ly b gy og od l oe of">See more helpful content on my <a class="ae ky" href="https://www.youtube.com/channel/UCHv7KRr7VeG5Oe-6BxTIRww" rel="noopener ugc nofollow" target="_blank">YouTube channel</a></span></pre></div></div>    
</body>
</html>