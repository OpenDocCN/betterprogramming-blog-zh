# 合并排序:如何通过创建音乐来理解算法

> 原文：<https://betterprogramming.pub/merge-sort-how-to-understand-an-algorithm-by-creating-music-ruby-sonicpi-f68ee38d1a6b>

## 如何通过挑战你的创造力来推动你的学习进程

![](img/a45d32ff4deba21dad6ffd3b3d8d962f.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Austin Distel](https://unsplash.com/@austindistel?utm_source=medium&utm_medium=referral) 拍摄的照片

学习一个算法有时会感觉像学习一个神奇的配方。我们理解其背后的概念，但是准确理解每一步是如何完成的会非常令人困惑。

实时编码让我可以通过乐趣和挑战我的理解和创造力来深入研究算法。它给了我一个操场，在那里我可以通过创造一些有趣的东西来立即将我所学的东西应用于实践。

所以今天，我们将通过构建一个使用这种算法创建音乐的 Ruby 程序来深入理解合并排序是如何操作的。

# 设置我们的环境

在本教程中，我们将使用一个名为 Sonic Pi 的软件。

[Sonic Pi](https://sonic-pi.net/) 是开源的，轻量级的，易于安装。只需根据您的操作系统下载合适的版本。

Sonic Pi 为我们提供了一个声音合成环境(它与自己的 SuperCollider 实例捆绑在一起)和一个完整的 IDE。那是我们写代码和创作音乐的地方。它还为我们提供了一个函数库，我们可以专门用它来操纵声音。

Sonic Pi 附带了非常清晰和完整的文档，因此如果您在本教程中有任何不理解的术语，我鼓励您在 Sonic Pi 自己的文档中查找。

除此之外，你唯一需要做的就是带上一副好的耳机。

# 了解合并排序

归并排序的运行时间为 *O(n log n)* 。它属于分治型算法，这使它比选择和插入排序(当然还有最慢的冒泡排序)等算法更有效。

合并排序背后的思想是这样的:取一个列表，把它分成两半，然后一直分成两半，直到我们得到长度为 1 的子数组，分别代表列表的左边和右边。

然后，我们将这些子数组发送给另一个函数，该函数将合并它们并返回结果。因为我们总是合并两个已经排序的子数组，所以可以通过比较每个子数组中特定索引处的元素并选择两者中的最小值来合并它们。

所以要实现归并排序，我们需要写两个不同的函数。一个我称之为 *merge_sort* ，它会递归地将我们的列表分成右子数组和左子数组。另一个我称之为*合并，*将两个排序后的子数组合并在一起。

有多种方法可以做到这一点，但重要的是要注意，合并函数可以以递归或非递归的方式完成。

这在 Ruby 中是这样的:

Ruby 中递归和非递归合并函数的合并排序实现。

首先，让我们看看 merge_sort 函数:

*   它接受一个数组作为参数。
*   如果数组的长度为 1 或 0，则返回它，因为它已经排序过了。这是我们的基本场景，它将结束对 merge_sort 的递归调用。
*   通过将数组长度除以 2 来找到数组的中点。因为我们除以的是整数而不是小数，所以答案会自动四舍五入到最接近的值。
*   在左子数组和右子数组上递归调用 merge_sort。
*   最后，我们对产生的左右子数组调用 merge。

现在，合并函数:递归和非递归实现完成相同的事情。

我们先来看看非递归版本:

*   它有两个参数，一个数组代表列表的左边，另一个数组代表列表的右边。
*   我们定义一个名为*的空数组进行排序*。
*   当没有子数组为空时，比较它们的第一个元素。
*   如果左侧数组中的第一个元素较小，使用 *shift* 将其从左侧数组中取出，并将其推入排序后的数组中。如果相反，我们取出右边子数组的第一个元素，并将其推入排序后的数组。
*   一旦我们退出循环，我们就把排序后的数组连接到左数组或右数组中的剩余元素。

为了清楚地理解串联是如何工作的以及我们为什么需要它，请记住，我们退出循环是因为其中一个数组为空。这意味着至少一个元素保留在一个子阵列中。

通过连接，我们获取剩下的所有元素，并将它们添加到排序后的数组的末尾。空数组在连接过程中会被忽略。

这就是为什么你选择先连接右侧还是先连接左侧并不重要。其中一面是空的，所以它将被忽略。

merge_recurse 函数略有不同:

*   它采用和以前一样的参数，一个左子数组和一个右子数组。
*   我们建立我们的基本情况:如果右边的子数组是空的，我们返回左边的。如果左边的是空的，我们返回右边的。
*   如果左边数组中的第一个元素比右边数组中的第一个元素小，我们返回左边的第一个元素(在括号内，这样我们就有一个单元素的数组)，并将其与对 merge_recurse 的递归调用结合起来。我们传递 merge_recurse 左边(现在没有它的第一个元素)和右边的子数组。
*   如果右边的第一个元素小于左边的第一个元素，我们做同样的事情——这次使用 *shift* 取出右边数组的第一个元素。

现在，让我们用我们的理解创作一首音乐作品吧！

# 从算法到声音的映射信息

![](img/d310c8f5f24b6e089f68bae80210dc66.png)

由[坦纳·博瑞克](https://unsplash.com/@tannerboriack?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

## 选择我们想要跟踪的信息

对于本教程的其余部分，我将坚持使用非递归合并函数，因为我发现它更容易翻译成音乐。

首先，我们需要确定我们希望从算法过程中听到的信息片段。以下是我选择追踪的内容。我想知道:

1.  如果我在 merge 函数或 merge_sort 函数中
2.  如果值在右子阵列或左子阵列中
3.  如果我从一个函数中返回
4.  如果一个子阵列是空的，它是哪个子阵列(左边的还是右边的)

当然，我希望听到列表中的每个声音被排序，并听到排序过程的进展。

以下是我选择解决这些问题的方式:

1.  我将使用具有非常独特的打击乐声音的样本。这两个函数都有自己的样本，当函数被执行时，首先会被触发。
2.  因为我们正在操作我们的初始列表，并把它分成左右两边，所以我决定改变声音的方向。通过使用*声相*参数，我可以将声音从耳机的中央指向左侧或右侧。
3.  与第一个非常相似，我将选择一个有独特声音的样本，不同于已经使用的声音，它将在 return 语句之前被听到。
4.  同样，类似于上一点，除了在这种情况下，我将根据哪个子阵列是空的来平移左边或右边的声音。

## 创建一个播放声音列表的函数

Sonic Pi 有两个关键功能，可以操纵音频:播放和睡眠。播放声音的默认速度是每分钟 60 拍，这意味着如果我们写 *sleep 1* ，计算机将在执行下一步之前等待一秒钟。

我们可以做的第一件事是创建一个简单的函数，允许我们逐个播放给定列表中的每个值。

该函数将接受三个参数:

*   一组数字
*   音量数字(由 amp 参数定义，amp 代表振幅)
*   一个介于-1 和 1 之间的值，我们将使用它向左或向右平移声音

最后一个参数的默认值设置为 0，以防我们希望听到列表居中(就像我们通常不改变平移一样)。我还添加了对列表长度的检查，因为如果函数接收到一个空列表，我希望听到一个特定的样本。

我选择了样品ambi_swoosh，因为我喜欢它轻盈的质地，但可以自由尝试。你会看到 Sonic Pi 会自动显示可用样本的列表，只要你键入关键字 sample 后跟一个空格。

在 else 分支中，我们使用一个简单的 *each* 方法，在数组的每个元素上调用 *play* ，然后是 0.25 秒的静默。我添加了释放，延音和衰减参数，使每个音高更短，但你可以随意改变这些数字，自己看看它们是怎么做的！

## 修改 merge_sort 函数

因为我很想知道我听到的子数组是左边的还是右边的，所以我要给 merge_sort 增加一个额外的参数。我将把它命名为 *side* ，并给它一个默认值 nil。这将允许我使用合适的 pan 值来播放每个递归调用。

以下是我们需要做的修改:

*   首先，我们需要确定一个无序的价值列表。稍后，我将回到我选择这个特定数组的方式和原因。
*   当我们进入功能时播放一个有特色的样本。我选择样本 glitch_perc1。
*   我们需要决定一个 midi 合成器来播放被排序的值。Sonic Pi 附带各种内建的 midi 合成器。对于这个功能，我选择使用 synth *square，*它的播放简单的方波，声音明亮。
*   我们需要为平移参数找到正确的值。这将取决于调用该函数时传递给 merge_sort 的参数。
*   我们需要使用我们在上一步中创建的函数 play_list 来播放列表中的每个值。
*   如果数组的长度小于或等于 1，我们希望播放另一个独特的样本，表明我们正在从函数返回。为此，我选择了样本 elec_chime *。*
*   我们需要向 merge_sort 的每个递归调用添加额外的参数。
*   最后，我们需要调用我们的函数，以便我们可以听到结果。

下面是应用所有这些修改后 merge_sort 的代码:

现在，如果我们按播放，我们开始有一些声音！还没有达到我们期望的音乐效果，但是我们会达到的。

## 修改合并功能

修改 merge 函数与我们应用于 merge_sort 的修改非常相似，除了一个新概念:线程。

我正在使用内置函数 *in_thread* ，因为我想让左右子阵列有时同时播放*。*简而言之，in_thread 让你看似同时执行代码块。

来自 Sonic Pi 的文档:

> *in_thread*
> 
> 在新线程中执行给定的块(在 do … end 之间)。用于同时演奏多个“声部”。创建的每个新线程都继承了父线程的所有 use/with 默认值，如时间、当前合成、bpm、默认合成参数等。[…]

除此之外，过程是相似的:

*   当我们进入功能时播放一个有特色的样本。在本例中，我选择了样本 perc_bell2。
*   选择一个可以播放我们的值的合成器:在这种情况下，我选择使用 synth beep *，*，它的声音稍微有些低沉，听起来没有 square synth *那么明亮。*
*   用合适的声相值同时播放左右子阵列。
*   对 while 循环的每一次迭代执行与上一步相同的操作，以便我们可以清楚地听到排序的进度。
*   退出循环后，播放左边的子数组，然后是右边的子数组，最后是排序后的列表。

代码如下:

现在，如果我们按播放键，听听结果，我们应该会听到一些更有趣的东西！

首先，我们应该清楚地听到声音从中心向左右移动，这取决于我们正在排序的子阵列。

然后，样本和合成器声音的差异向我们表明哪个功能正在执行。

还有一些不错的图层，声音在合并功能中同时播放。当列表为空时触发的 ambi_swoosh 示例为整体结果提供了良好的纹理。

你听到了吗，在打击乐样本被触发的节奏中似乎有一个有趣的“节奏”?

## 把我们的算法实验变成音乐作品

在这最后一步，我们将添加的代码纯粹是为了让我们的合并排序算法听起来更悦耳。为此，我们需要熟悉 Sonic Pi 中另一个重要的内置函数:live loops。

实时循环是指无需停止程序即可实时修改的循环。它允许我们编写代码，运行程序，应用修改，并再次按下播放，而不必中断音乐。

下面是 Sonic Pi 文档中对活循环的定义:

> *live_loop* 名称(符号)
> 
> 永远循环 do/end 块。然而，与基本循环不同，live_loop 有两个特殊属性。首先，它在一个线程中运行——因此您可以同时(并发地)运行任意数量的活循环。第二，你可以改变一个正在运行的循环的行为，而不需要停止它。因此，活循环是用 Sonic Pi 进行活编码的秘密。[…]

是的，这是真的:活循环使得用 Sonic Pi 进行活编码成为可能并且易于理解。

我们需要做的第一件事是将对 merge_sort 的函数调用包装在一个活循环中。每个活循环都需要一个符号作为名称，所以我将我的命名为 merge_sort。

然后，我们将创建另一个现场循环，它将包含一个非常简单的节拍，这将为我们的作品提供一个稳定的脉冲以及一个永远不会改变的长低音。

具有稳定的节拍将突出显示由算法创建的*凹槽*。长而低的音符(在音乐语言中称为低音)将为所有不同的演奏值提供一些基础。

就我个人而言，我喜欢将这个过程定义为将声音放入视角。

最后，我们将两个现场循环包在混响效果中，给我们的作品增加一点氛围。我们通过使用内置的 with_fx 块来实现这一点。音速小子有各种不同的效果。请随意试用它们！

现在，让我们使用内置函数 use_bpm 并将默认值 60 改为 70，让整首曲子演奏得更快一些。

下面是完整的代码！

继续按播放，看看你对我们的作文有什么看法！

## 用代码帮助你踏上音乐之旅的实用小技巧

现在，很有可能你还有一些没有答案的问题。例如:

*   “为什么选择这个特定的阵列？”
*   "为什么长度为 12 的未排序数组？"
*   “你怎么知道无人机用哪个值？”
*   "你怎么知道如何创造节拍？"

好的。说实话，我总是尽力去写不需要音乐知识的教程。我想让以前没有音乐经验的程序员尽可能容易地使用音乐作为他们编码技能和创造力的游乐场。

但是我不会让你在黑暗中进行实验，我会给你一些建议，以防它会让你在音乐方面的事情变得更容易。如果它看起来太复杂，或者如果你喜欢自己做实验，可以跳过这一部分。

首先，未排序的数组。我知道播放的值将作为一种旋律，因此，它们需要在耳朵舒适的范围内。个人对于这种东西，我喜欢用 55 到 80 之间的数值。

这是我用来创建未排序列表的函数:

让我们看一下第 3 行，因为这一行几乎完成了所有的魔法。

您可以使用两个函数来创建非常匹配的值列表:和弦和音阶。和弦和音阶的主要区别在于音阶是一系列连续的值，和弦在每个值之间有空格。

因为我打算一起听声音(当我们使用 in_thread 时，在 merge 函数中)，所以我决定使用和弦，因为这消除了在一起演奏音阶的连续值时可以听到的许多声音簇。

chord 和 scale 函数都将符号作为第一个参数。此符号是音符的名称。音符有字母来命名，从 *a* 到 *g* 。你可以从这些字母中任选一个。符号名称的下一部分是一个数字。如果您想要非常高的频率，请选择较高的数字。在这种情况下，3 相当于中音。

下一个参数是 num_octaves。一个八度音程是一系列 12 个连续的声音，将您带回到您开始时的声音——仅高 12 步或低 12 步，取决于您前进的方向。例如，e4 比 e3 高一个八度。

如果我处理音阶，我通常给自己两个八度，如果我处理和弦，我给自己三个八度，因为音阶中的音符比和弦中的多。

接下来，我选择创建一个包含 12 个值的列表，因为 12 可以被 4 整除。我通常使用 16 个数值，但任何能被 4 整除的数字都可以。在这种情况下，你要创造一些非常容易听到的东西。因为基于 4 的节奏在西方音乐中是最常见的，所以我选择以此作为我的教程的基础。但同样，那是我，完全由你来决定和实验！

现在，要找到无人机的基音，取数组中的最小值，减去 12。根据您的最低值有多高以及您使用的合成器，您甚至可能想要减去 24。这是一个尝试的问题，看看什么最有效。

我希望这在基本层面上揭示了音乐的一面。如果你有任何问题或者任何不清楚的地方，欢迎在评论区问我。我很乐意更深入地解释任何事情。

# 最后的想法

希望你觉得这个算法实验有趣好玩！如果你想走得更远一点，这里有一些给你的建议:

*   如果使用 merge_recurse 函数，算法听起来会怎么样？
*   不要播放最终排序的列表，而是尝试用一个自定义函数来替换它，一旦列表被排序，这个函数就会被调用。这是创作多声部作品的一种非常酷的方式。
*   试着用音阶代替和弦来生成你的未排序数组，看看听起来怎么样。
*   在实时循环播放时修改代码；这是成为真正的现场程序员的第一步！

我给你们留下了这个 YouTube 视频，我播放了我们在这里创建的合并排序组合，并对其进行了略微扩展。

合并排序的声音——八哥玛丽对阿比盖尔来说是地球

我希望你喜欢它！如果你在本教程的启发下尝试并创作出令人惊叹的作品，请考虑制作一个[要点](https://gist.github.com/)，并在评论区发布链接，我很想听听你的想法。

编码快乐！