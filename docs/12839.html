<html>
<head>
<title>Automatically Create NBA Highlights With a Few Lines of Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用几行Python代码自动创建NBA集锦</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automatically-creating-nba-highlights-in-5-minutes-7f90bfedd775?source=collection_archive---------2-----------------------#2022-07-06">https://betterprogramming.pub/automatically-creating-nba-highlights-in-5-minutes-7f90bfedd775?source=collection_archive---------2-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">利用开源计算机视觉模型生成篮球集锦</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8a8a9826d740c934d700af49a5dd839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JQKSAldhGg9u0V0IZNDLQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@timhart0421?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·哈特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/nba?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们生活在一个由抖音、Snapchat、Instagram、Twitter、脸书、Youtube等引领的内容快速消费的世界。</p><p id="8da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着观看比赛直播的重要性越来越低，年轻球迷正在接受参与联赛的新方式。</p><p id="04eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据综艺情报平台<a class="ae kv" href="https://link.axios.com/click/23308324.376732/aHR0cHM6Ly92YXJpZXR5LmNvbS92aXAvdGhlLWNoYW5naW5nLWZhY2Utb2Ytc3BvcnRzLWZhbmRvbS0xMjM0OTIwNTYxLz91dG1fc291cmNlPW5ld3NsZXR0ZXImdXRtX21lZGl1bT1lbWFpbCZ1dG1fY2FtcGFpZ249bmV3c2xldHRlcl9heGlvc3Nwb3J0cyZzdHJlYW09dG9w/6047896a8246974e431c2738Bcdfc138d" rel="noopener ugc nofollow" target="_blank">的一项调查</a>，在18-34岁的美国体育迷中，58%的MLB球迷、54%的NBA球迷和48%的NFL球迷表示，他们更喜欢观看集锦而不是完整的比赛。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/9ab97704797777b35815df42819c9231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kime4ACCxx2-nxuwJhGltw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:综艺情报平台丸组</p></figure><p id="e4f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个住在离美国半个地球之外的NBA铁杆球迷，没有比我更喜欢这些集锦的了。</p><p id="de0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不需要更多的动机，我开始创建一个自动化的过程来创建NBA比赛的亮点。</p><h1 id="b5ab" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">什么</strong></h1><p id="a2ff" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个项目的目标是使用完全开源的技术来创建这些亮点，并尽可能保持简单。</p><h1 id="a697" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">如何</strong></h1><p id="00ba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">有许多方法可以尝试并找到游戏中的兴趣点——声音分析、运动检测等。有些公司正是以此为业，使用复杂的模型来识别兴趣点并创建精彩片段。但是这些复杂的输入和模型不一定等于更精确的结果。相反，我决定依靠一个稳定而清晰的信号——一个与游戏时钟相匹配的带时间戳的游戏详细记录。如此简单——却又如此精确。虽然这种解决方案不一定适用于任何运动，但在NBA(以及一般的篮球)中，时钟是神圣的…因此可靠性非常高，几乎不需要任何努力，并且计算水平非常低。</p><p id="c40e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该解决方案有三个部分:</p><ol class=""><li id="a256" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">建立一个简单的逐场比赛刮刀，以获取我们正在创建一个亮点的游戏数据。</li><li id="c1bd" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">使用开源的Tesseract OCR模型来查找游戏影片中的当前游戏时钟和季度。</li><li id="30cb" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">将我们从帧中提取的时钟和季度与我们的播放数据进行比较。</li></ol><p id="ec4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…如果我们有匹配的，瞧！我们有一个亮点！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c6186a9d15b5f6fad8bfd02fd2fc8ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/0*S3oJTWsaBhaahmEP"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目流程图。作者图片</p></figure><p id="a4bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们进入技术细节。</p><p id="7582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目是用python写的，但是可以很容易地用任何语言复制。<br/>在我们开始之前，这些是本项目中使用的库:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="95c1" class="nk lu iq ng b be nl nm l nn no">import pandas as pd<br/>import pytesseract<br/>import cv2<br/>from moviepy.editor import *<br/>import json<br/>import requests</span></pre><h1 id="09ab" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">建造一架详细报道的铲运机</strong></h1><p id="e1d6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">逐场播放以个人事件的形式提供游戏的抄本。</p><p id="c899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以在逐场播放数据中找到的一些数据示例:</p><ul class=""><li id="8f97" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr np mw mx my bi translated">控球时间(在游戏时钟上)</li><li id="1ac9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">占有发生的季度</li><li id="1c2d" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">开始控球的球员(在抢断或防守篮板的情况下)</li><li id="a949" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">开始控球的对方球员(在投篮不中或失误的情况下),包括投篮的位置，以及我们用来对控球类型进行分类的其他一些唯一标识符。</li></ul><p id="681f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们搜集的数据来自NBA官方API(data.nba.net和cdn.nba.com)。数据以JSON格式存储。要以更传统的格式获取数据，比如dataframe，我们只需要运行几行代码。</p><p id="2840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一部分提供了在给定日期玩的游戏:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="52ae" class="nk lu iq ng b be nl nm l nn no">jsn = f"https://data.nba.net/10s/prod/v1/{date}/scoreboard.json"<br/>page = requests.get(jsn)<br/>j = json.loads(page.content)</span></pre><p id="6d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们检查输入的球队确实在给定的日期比赛。如果有，我们获取游戏id并将其插入下一个API。</p><p id="d369" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们提取数据并将其加载到熊猫<code class="fe nq nr ns ng b">dataframe</code>:</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="c82c" class="nk lu iq ng b be nl nm l nn no">raw_game = f'https://cdn.nba.com/static/json/liveData/playbyplay/playbyplay_{game_id}.json'<br/>page = requests.get(raw_game)<br/>j = json.loads(page.content)<br/>df = pd.DataFrame(j['game']['actions'])</span></pre><p id="5f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/349c4022c566802c276af377cec68653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0jaiOv4cn52ExwT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">熊猫数据帧包含详细的比赛数据</p></figure><p id="0272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这里我们可以筛选出我们感兴趣的任何类型的打法(投篮、抢断、盖帽等……)。在我们的例子中，我只考虑投篮，不考虑罚球。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="8114" class="nk lu iq ng b be nl nm l nn no">ndf = df[['clock', 'period', 'description', 'teamTricode', 'shotResult', 'actionType']]<br/>ndf = ndf[ndf['shotResult'] == 'Made']<br/>ndf = ndf[ndf['actionType'] != 'freethrow']</span></pre><p id="db38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了游戏中所有兴趣点的数据集，是时候在实际的游戏镜头中找到它们了。</p><h1 id="02fd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">处理游戏影片</strong></h1><p id="90b8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下一步是将游戏影片处理成帧，并使用OpenCV模块操纵它们。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="fbb9" class="nk lu iq ng b be nl nm l nn no">cap = cv2.VideoCapture(video_path)<br/>ret, frame = cap.read()<br/>while cap.isOpened():<br/>…</span></pre><p id="a67d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，每一帧都将经过一系列的处理(预处理)，为OCR做准备(更多OCR内容将在后面介绍)。</p><p id="fa3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤:</p><ol class=""><li id="85cc" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">裁剪原始帧，只留下游戏时钟所在的底部三分之一(这是为了不浪费时间阅读整个帧)。</li><li id="29c7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">将图像转换为灰度。</li><li id="065e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">将灰度图像转换为黑白图像。</li><li id="0a15" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">将<a class="ae kv" href="https://en.wikipedia.org/wiki/Gaussian_blur#:~:text=In%20image%20processing%2C%20a%20Gaussian,image%20noise%20and%20reduce%20detail." rel="noopener ugc nofollow" target="_blank">高斯模糊</a>应用于黑色&amp;白色图像。</li></ol><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="e456" class="nk lu iq ng b be nl nm l nn no">height, width = frame.shape<br/>crop_img = frame[height-(height/3):height, 0:width]<br/>gray = cv2.cvtColor(crop_img, cv2.COLOR_BGR2GRAY)<br/>bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]<br/>blurred = cv2.GaussianBlur(bw, (5, 5), 0)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/8d00940672375de9e9ee5124d5f8a9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DrnvevCioFV_l6zd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始框架</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/984c5dad53fe150adb760dfdc8708c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bTkc5gUm_rjJ72OV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">底部三分之一裁剪</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/bedaab5e0b9952330b3222711646314f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PvDlF1K_f9EWx9gF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转换为灰度</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/18aa5dca19bf334fef79cb650fc05947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6tmJDJB10zEXjx3L"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转换为黑白</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/5268ee318b99b2ea6b0f9771ed7fb06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RyWnev3cJsYYu9Fb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用高斯模糊</p></figure><h1 id="0236" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">宇宙魔方</strong></h1><p id="2ae7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Tesseract —是一个开放源代码的光学字符识别引擎。这是最受欢迎和定性的OCR库。</p><p id="ab33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OCR使用人工智能在图像中进行文本搜索和识别。</p><p id="5cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tesseract在像素、字母、单词和句子中查找模板。</p><p id="6ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它具有开箱即可识别100多种语言的能力，并且可以通过训练识别其他语言。</p><p id="aa2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以基本上这个引擎从图像中搜索并提取文本。</p><p id="551d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，我们使用python-tesseract ( <code class="fe nq nr ns ng b"><a class="ae kv" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">pytesseract</a></code>)，它是Google的Tesseract-OCR引擎的python包装器。</p><p id="9702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有13种宇宙魔方<a class="ae kv" href="https://ai-facets.org/tesseract-ocr-best-practices/" rel="noopener ugc nofollow" target="_blank">配置模式</a>。我们将使用模式11: <em class="nw">稀疏文本。不按特定顺序查找尽可能多的文本。</em></p><h2 id="e940" class="nx lu iq bd lv ny nz dn lz oa ob dp md lf oc od mf lj oe of mh ln og oh mj oi bi translated"><strong class="ak">宇宙魔方实现</strong></h2><p id="a8d0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下一步是通过宇宙魔方引擎运行我们处理过的帧。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="008d" class="nk lu iq ng b be nl nm l nn no">data = pytesseract.image_to_string(blurred, lang='eng', config=' - psm 11')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/b0d3f12ae78c3a6ff76dab3b13189f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AyUIJ2opK37wjvXh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">宇宙魔方文本检测输出</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/97239d177176f01ba41993b726ac1b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Kks_ta-uX7UQjIw"/></div></div></figure><p id="1db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经在框架中有了所有的文本，我们可以搜索我们想要的信息，即当前季度和游戏时钟。</p><p id="25bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续上面的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/3c0e13390d62b5d0c429e6e958727b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2X9yzLv6Aspr0b0d"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/6be92b165926bd10d6e76f8d484aba31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5tX5528J3Z8Wnlz_"/></div></div></figure><p id="cca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">季度是“1日”，游戏时钟是“7:32”。但是，在Tesseract输出中，检测是“ist”。数字“1”被误认为是字母“I”。</p><p id="ab9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，下一步是为每个季度创建一个常见错误的映射。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="bcb9" class="nk lu iq ng b be nl nm l nn no">firstQ  = ['1st', 'ist', 'ast']<br/>secondQ = ['2nd', '2n', 'znd']<br/>thirdQ  = ['3rd', '3r', '3r0', '3ro', '37d', '3fd', '31d']<br/>fourth  = ['4th', '4t', '47h', '41h', '4h']</span></pre><h2 id="2916" class="nx lu iq bd lv ny nz dn lz oa ob dp md lf oc od mf lj oe of mh ln og oh mj oi bi translated"><strong class="ak">将比赛数据与比赛录像数据进行匹配</strong></h2><p id="6c44" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们总结一下到目前为止我们所拥有的:我们构建了一个逐场播放的刮刀，操纵游戏镜头帧，并通过Tesseract引擎运行它们以从帧中提取文本。</p><p id="4d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候结合数据点，找到亮点了。</p><p id="e1d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过如上所述处理游戏镜头的每一帧并检查所提取的硬币和游戏时钟的组合是否与精彩部分的硬币和游戏时钟相匹配来做到这一点。</p><p id="bf59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们有一个匹配，然后我们保存帧号。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="1531" class="nk lu iq ng b be nl nm l nn no">curr_frame = cap.get(cv2.CAP_PROP_POS_FRAMES)<br/>frame_loc.append(curr_frame)</span></pre><h2 id="245f" class="nx lu iq bd lv ny nz dn lz oa ob dp md lf oc od mf lj oe of mh ln og oh mj oi bi translated"><strong class="ak">拼接框架</strong></h2><p id="0dc6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦我们完成了游戏中的所有帧，并且我们有了一个所有出现高光的帧的列表，我们所要做的就是把它们拼凑起来。</p><p id="5ebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe nq nr ns ng b"><a class="ae kv" href="https://zulko.github.io/moviepy/" rel="noopener ugc nofollow" target="_blank">moviepy</a></code>模块来完成。</p><p id="e101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns ng b">Moviepy</code>允许我们从完整视频中裁剪出子片段。为了看到高潮部分的整个过程，我们在高潮部分发生的前几秒和后几秒拍摄。</p><pre class="kg kh ki kj gt nf ng nh bn ni nj bi"><span id="6123" class="nk lu iq ng b be nl nm l nn no">clips = []<br/>for frame in highlight_frames:<br/>clip_name = video.subclip(round(frame/fps) - 4, round(frame/fps)+ 2)<br/>clips.append(clip_name)<br/>final_clip = concatenate_videoclips(clips)<br/>final_clip.write_videofile(output_path,<br/>                           codec='libx264',<br/>                           audio_codec='aac',<br/>                           fps=fps)</span></pre><h1 id="6733" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">输出高亮示例</strong></h1><p id="0513" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们已经完成了高光的创建，让我们来看看结果…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">所有标志和镜头都是NBA及其附属机构的财产</p></figure><h1 id="ba14" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">提高效率</strong></h1><p id="9321" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是一个寻找兴趣点和创建精彩片段的基本脚本，但效率很低。</p><p id="bf3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举几个例子，可以通过各种不同的方式轻松提高效率:</p><ul class=""><li id="ec64" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr np mw mx my bi translated">不检查每一帧——跳过一秒而不是检查每一帧会将2小时游戏(60 fps)中处理的帧数从430，000减少到7，200。</li><li id="d4c2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">定位游戏时钟的坐标并通过OCR引擎仅运行该区域将减少运行时间。</li><li id="ae1b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">寻找分数的变化，而不是比赛时间(如果你只想得分)</li><li id="ccc6" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr np mw mx my bi translated">使用多重处理并行工作并加速进程，以及使用GPU。</li></ul><h1 id="a9e1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">总结一下</strong></h1><p id="301b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这只是一个小例子，说明如何利用开源技术来创造令人难以置信的产品。</p><p id="5867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是现在——我希望你觉得有趣，如果你有任何问题或意见，请告诉我！</p></div></div>    
</body>
</html>