<html>
<head>
<title>Using Hooks for Lazy-Loading Images in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中使用钩子来延迟加载图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/image-lazy-loading-in-react-intersection-observer-a9ae912ddafe?source=collection_archive---------3-----------------------#2019-10-30">https://betterprogramming.pub/image-lazy-loading-in-react-intersection-observer-a9ae912ddafe?source=collection_archive---------3-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过创建和使用一个定制的钩子:useIO，在React中使用Intersection Observer来延迟加载图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c67e3298051983b69daf22aef9d3ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q149QSTjV4ghXsZE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wenniel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文尼尔伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图片占据了你网站的很大一部分，你管理图片的方式会对你的网页加载时间产生很大的影响。</p><p id="0dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从你的服务器一次加载所有的图片到你的客户端会让你的网站非常慢，而且在很多情况下，用户可能不会访问所有的图片。因此，在许多情况下，最好只在需要时加载图像。</p><p id="13d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在这里看到如何使用<code class="fe lv lw lx ly b">IntersectionObserver</code>以最简单的方式加载图像。</p><p id="38dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建一个定制的<code class="fe lv lw lx ly b">IntersectionObserver</code>钩子，我们称之为<code class="fe lv lw lx ly b">useIO</code>，然后我们将在React中创建一个新的组件<code class="fe lv lw lx ly b">(Image)</code>，它将帮助我们封装我们的<code class="fe lv lw lx ly b">&lt;img&gt;</code> JSX，并增加一些功能。</p><p id="b185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将使用它们来编写我们的延迟加载代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="266e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">交叉口观测器</h1><p id="8381" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交集观察器API </a>用于观察一个称为<em class="nd">目标</em>的元素何时与设备视口或称为<em class="nd">根</em>的指定元素相交。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/362869f4660e94daf8296dc755cc6bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*QCDEIp2x34S-9iQ_8rxx7Q.png"/></div></figure><p id="5e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标元素与其根元素的相交程度就是<strong class="lb iu"> <em class="nd">的相交比。</em> </strong>这是以0.0到1.0之间的值表示可见的目标元素的百分比，其中0表示0%，1.0表示100%。</p><p id="71b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们观察目标元素与根元素的交集比率。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="5291" class="nj mh it ly b gy nk nl l nm nn">const io = new IntersectionObserver(callback, options);</span></pre><p id="6dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们不提供一个<code class="fe lv lw lx ly b">options</code>对象时，使用默认选项<code class="fe lv lw lx ly b">IntersectionObserver</code>，当使用默认选项时，当目标元素部分进入视图和完全离开视图时，我们的回调将被调用。</p><p id="9a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IntersectionObserver</code>的<code class="fe lv lw lx ly b">options</code>对象给了我们更多的控制权来控制我们的回调将如何以及何时被调用。<code class="fe lv lw lx ly b">Options</code>对象有以下字段:</p><ul class=""><li id="d5ce" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">root</code>:测量目标元素的交集比率的元素。根必须是目标元素的祖先。如果未指定或如果<code class="fe lv lw lx ly b">null</code>，则默认为浏览器视窗。</li><li id="3c81" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">rootMargin</code>:围绕<code class="fe lv lw lx ly b">root</code>的边距。它可以是正的，也可以是负的，收缩或增长根元素的每一边。可以具有类似于CSS margin属性的值，例如“<code class="fe lv lw lx ly b">10px 20px 30px 40px"</code>”。默认值全为零。</li><li id="6d4c" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">threshold</code>:0到1之间的单个数值或数值数组，0表示0%，0.5表示50%，1表示100%。默认值为0。该值定义了回调将被调用的交集比率。如果该值为0，则意味着只要目标元素的单个像素进入视口，就会调用callback。如果值是一个数组，那么对于该数组中的每个值，如果<code class="fe lv lw lx ly b">intersectionRatio</code>匹配，将调用回调。</li></ul><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="f8a2" class="nj mh it ly b gy nk nl l nm nn">let options = {<br/>  root: document.querySelector('#scrollArea'),<br/>  rootMargin: '0px',<br/>  threshold: [0, 0.25, 0.50, 1]<br/>}<br/><br/>const io = new IntersectionObserver(callback, options);</span></pre><p id="e372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，每当可见度越过另一个25%时，回调将被调用。</p><p id="991e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以开始在<code class="fe lv lw lx ly b">IntersectionObserver</code>实例上使用<code class="fe lv lw lx ly b">observe</code>方法来观察一个元素。</p><p id="b54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，为了停止观察一个元素，我们有<code class="fe lv lw lx ly b">unobserve</code>方法，为了禁用整个<code class="fe lv lw lx ly b">IntersectionObserver</code>，我们使用<code class="fe lv lw lx ly b">disconnect</code>方法。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="1bc5" class="nj mh it ly b gy nk nl l nm nn">// Start Observing target<br/>io.observe(<em class="nd">targetElement</em>)</span><span id="8e62" class="nj mh it ly b gy oc nl l nm nn">// Stop Observing target<br/>io.unobserve(<em class="nd">targetElement</em>)</span><span id="26d6" class="nj mh it ly b gy oc nl l nm nn">// Disable entire IntersectionObserver<br/>io.disconnect()</span></pre><p id="f598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过为多个目标元素调用<code class="fe lv lw lx ly b">observe</code>方法，我们可以使用单个<code class="fe lv lw lx ly b">IntersectionObserver</code>实例来观察多个元素。</p><p id="ff58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调函数接收一个<code class="fe lv lw lx ly b">entries</code>参数，它是一个<code class="fe lv lw lx ly b">IntersectionObserverEntry</code>对象的数组。</p><p id="5205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个对象有许多属性，但最常用的是<code class="fe lv lw lx ly b">intersectionRatio</code>，它给出了目标元素与根元素的当前交集比率。</p><p id="e42f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一些属性是<code class="fe lv lw lx ly b">isIntersecting</code>和<code class="fe lv lw lx ly b">target</code>，我们将使用它们。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="a18c" class="nj mh it ly b gy nk nl l nm nn">const io = new IntersectionObserver(<br/>  entries =&gt; {<br/>    console.log(entries);<br/>  },<br/>  {<br/>    //Options <br/>  }<br/>);<br/>// Start observing an element<br/>io.observe(element);</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d053" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用途</h1><p id="9d56" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了使用<code class="fe lv lw lx ly b">IntersectionObserver</code>，我们将创建一个自定义挂钩。这个钩子将接受一个对象作为<code class="fe lv lw lx ly b">IntersectionObserver</code>的选项对象。</p><p id="4ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个钩子将返回一个包含三个东西的数组。</p><ol class=""><li id="223f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu od nu nv nw bi translated">观察者的实例。</li><li id="20a1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu od nu nv nw bi translated">方法来设置目标元素。</li><li id="2e58" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu od nu nv nw bi translated">条目数组，由<code class="fe lv lw lx ly b">IntersectionObserver</code>提供给回调函数。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1</p></figure><p id="f4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IntersectionObserver</code>是一个副作用，所以我们将把它所有的连接和断开逻辑写在<code class="fe lv lw lx ly b">useEffect</code>钩子中。</p><p id="dae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用了React <code class="fe lv lw lx ly b">ref</code>，使用<code class="fe lv lw lx ly b">useRef</code>钩子来存储<code class="fe lv lw lx ly b">IntersectionObserver</code>实例，该实例被存储在ref的当前属性中。参见代码1中的<code class="fe lv lw lx ly b">line 14</code>。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="bfc4" class="nj mh it ly b gy nk nl l nm nn">//Create a ref<br/>const observer = useRef(null)</span><span id="d5ae" class="nj mh it ly b gy oc nl l nm nn">//Assign IntersectionObserver to ref<br/>observer.current = new IntersectionObserver(callback, options)</span></pre><p id="0025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的目标元素都将被存储在<code class="fe lv lw lx ly b">elements</code>状态，我们遍历<code class="fe lv lw lx ly b">elements</code>数组，并在<code class="fe lv lw lx ly b">useEffect</code>回调中为每个元素调用<code class="fe lv lw lx ly b">observe</code>。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="0e25" class="nj mh it ly b gy nk nl l nm nn">//calling observe<br/>observer.current.observe(element)</span></pre><p id="902a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为参数传递给<code class="fe lv lw lx ly b">IntersectionObserver</code>回调函数的所有条目都存储在<code class="fe lv lw lx ly b">entries</code>状态中。我们将使用这些条目来编写我们的延迟加载逻辑。</p><p id="1aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useIO</code>将返回<code class="fe lv lw lx ly b">IntersectionObserver</code>实例，<code class="fe lv lw lx ly b">setElements</code>设置<code class="fe lv lw lx ly b">elements</code>状态，该状态是所有目标元素和<code class="fe lv lw lx ly b">entries</code>的数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bd08" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">图像组件</strong></h1><p id="c7df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">很简单的逻辑。我们将只封装<code class="fe lv lw lx ly b">&lt;img&gt;</code> JSX，如果<code class="fe lv lw lx ly b">isLazy</code>道具被传递给我们的<code class="fe lv lw lx ly b">Image</code>组件，那么它将把<code class="fe lv lw lx ly b">lazy</code> <code class="fe lv lw lx ly b">class</code>添加到<code class="fe lv lw lx ly b">&lt;img&gt;</code>标签中。</p><p id="4d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">道具<code class="fe lv lw lx ly b">isLazy</code>将决定图像是否会被延迟加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2</p></figure><p id="442d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:您可以根据自己的需求进行修改。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="255c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">把它放在一起</h1><p id="0891" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有了<code class="fe lv lw lx ly b">Image</code>组件和为我们提供<code class="fe lv lw lx ly b">entries</code>的<code class="fe lv lw lx ly b">useIO</code>挂钩。Entries是一个<code class="fe lv lw lx ly b">IntersectionObserverEntry</code>对象的数组，它将帮助我们编写惰性加载的逻辑。</p><p id="cc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于图片，我们将使用<a class="ae ky" href="https://jsonplaceholder.typicode.com/photos" rel="noopener ugc nofollow" target="_blank">这个API </a>。它返回数千个结果，但我们将只使用15个结果。为了进行AJAX调用，我们将使用<a class="ae ky" href="https://www.axios.com/" rel="noopener ugc nofollow" target="_blank"> axios </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3</p></figure><p id="a5dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将遍历我们的数据数组并生成图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码4</p></figure><p id="cbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们提供了<code class="fe lv lw lx ly b">isLazy</code>道具，它将自动在<code class="fe lv lw lx ly b">&lt;img&gt;</code>上添加<code class="fe lv lw lx ly b">lazy</code>职业，我们也在这里添加了一些样式。我们还会看到一个后备图像，直到我们的图像被加载。</p><p id="bf82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有图像，所有我们必须延迟加载的图像都添加了<code class="fe lv lw lx ly b">lazy</code>类。现在，我们将获取类名为<code class="fe lv lw lx ly b">lazy</code>的所有元素，并调用<code class="fe lv lw lx ly b">setElements</code>方法，这样我们就可以使用这些元素作为我们的目标元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码5</p></figure><p id="5092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在参见<code class="fe lv lw lx ly b">useIO</code>定制挂钩的<em class="nd">代码1 </em> <strong class="lb iu"> </strong>。<code class="fe lv lw lx ly b">useEffect</code>挂钩取决于<code class="fe lv lw lx ly b">elements</code>状态。</p><p id="4963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，正如我们在<em class="nd">代码5中调用的<code class="fe lv lw lx ly b">setElements</code>，</em>将触发效果运行，这反过来将我们的观察者连接到我们的目标元素，并且<code class="fe lv lw lx ly b">ioEntries</code>被传递到回调，在回调中我们将设置我们的<code class="fe lv lw lx ly b">entries</code>状态。</p><p id="7fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经拥有了编写主惰性加载逻辑所需的一切，即与每个目标元素相关的条目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码6</p></figure><p id="6174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将遍历<code class="fe lv lw lx ly b">entries</code>数组，对于每个条目，我们将使用<code class="fe lv lw lx ly b">entry.isIntersecting</code>检查它是否与我们的根相交。</p><p id="59d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用<code class="fe lv lw lx ly b">entry.target</code>获取目标DOM元素。之后，我们将更改它的<code class="fe lv lw lx ly b">src</code>属性，我们之前将它设置为回退图像。</p><p id="9994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，从这里开始，所有其他事情都将由我们的浏览器来处理，比如加载图像。</p><p id="1fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要记住的一点是，一旦图像被加载，当我们来回滚动时就没有必要再次加载它，因此，我们将从它那里移除<code class="fe lv lw lx ly b">lazy</code>类，并且，我们需要停止观察那个目标元素。</p><p id="7ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe lv lw lx ly b">isIntersecting</code>和<code class="fe lv lw lx ly b">target</code>是<code class="fe lv lw lx ly b">IntersectionObserverEntry</code>对象的属性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4355" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">完全码</h1><p id="3c91" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">useIO</code>钩子和<code class="fe lv lw lx ly b">Image</code>组件，我们已经分别在代码1和代码2中看到了代码。现在让我们把所有的部分放在一起，为我们的懒惰加载图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码7</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/66ff3c5d41f7e4d1e22fca80b84458dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6qO3elA9jTtyvlfyN8Gi-w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只有当图像至少占可视区域的25%时，它才会被加载</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="527e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><div class="oh oi gp gr oj ok"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">交叉点观察器API</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">交叉点观察器API提供了一种异步观察目标元素交叉点变化的方法…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">developer.mozilla.org</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">延迟加载图片和视频|网络基础|谷歌开发者</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">如果你的网站有大量的图片和视频，但是你不想减少任何一个，延迟加载可能只是…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">developers.google.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>