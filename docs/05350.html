<html>
<head>
<title>Learning to Mock in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中学习嘲笑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learning-to-mock-in-swift-bc233f01da72?source=collection_archive---------12-----------------------#2020-07-01">https://betterprogramming.pub/learning-to-mock-in-swift-bc233f01da72?source=collection_archive---------12-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在单元测试中剔除嵌套函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0a805f2e038f0b9c798271857fd7ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVgSA8lppCUu7idWMgMMyw.png"/></div></div></figure><p id="6fdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据您在单元测试中的立场，您可能会发现这篇文章比其他文章更有用或更不有用。我选择测试，因为当我为自己开发时，我没有人可以提供代码审查，所以它给了我额外的保证，我没有破坏任何东西。我还发现看到一切都变得绿色起来令人奇怪地满足。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="774b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">为什么需要嘲笑？</h1><blockquote class="mm mn mo"><p id="34b8" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">“单元测试<strong class="kt ir"> </strong>是软件测试的一个层次，其中测试软件的单个单元/组件。目的是验证软件的每个单元都按照设计执行。单元是任何软件中最小的可测试部分。”</p><p id="2542" class="kr ks mp kt b ku kv jr kw kx ky ju kz mq lb lc ld mr lf lg lh ms lj lk ll lm ij bi translated">—国际软件测试资格委员会(ISTQB)</p></blockquote><p id="dd20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了很好地对一个函数进行单元测试，你需要覆盖你的函数可以采用的所有不同的路径。随着应用程序的增长，您的函数最终会调用您在代码库中编写的嵌套函数或其他库函数。</p><p id="770e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你对一个函数进行单元测试时，你可能会考虑那些嵌套函数的输出，并且想要测试某个路径。</p><p id="9fcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是嘲讽的由来。它使您能够单独测试有问题的函数，而不必考虑嵌套函数中的逻辑。例如，如果您的函数要进行API调用，您可以模拟网络层，这样您的测试实际上不会进行调用，但仍然会考虑所有可能的场景。</p><p id="493a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所想象的，这极大地加快了您的测试速度，并且意味着您不再依赖网络来决定您的测试是通过还是失败。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="654c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">迅速嘲笑</h1><p id="9388" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">通过观察一个典型的网络层，我们可以看到问题是什么，以及如何利用Swift的协议来模拟功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8fbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，如果我们要测试<code class="fe na nb nc nd b">executeRequest</code>函数，没有办法不调用真正的<code class="fe na nb nc nd b">URLSession</code>并对参数中提供的URL发出请求。相反，我们可以重构类来利用协议，这将允许我们在测试中注入一个mock。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="976a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们用函数的签名创建一个协议。然后，我们通过使<code class="fe na nb nc nd b">URLSession</code>符合<code class="fe na nb nc nd b">NetworkClientProtocol</code>来实现该功能。一旦我们看到如何调用它<strong class="kt ir">，这就更容易理解了。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2f19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过重构<code class="fe na nb nc nd b">NetworkClient</code>、<strong class="kt ir">、<em class="mp">、</em>、</strong>，我们可以传入任何符合我们在初始化阶段创建的协议的东西，并默认为正常的<code class="fe na nb nc nd b">URLSession.shared</code>，就像我们之前做的那样。</p><p id="8545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后当我们调用<code class="fe na nb nc nd b">executeRequest</code>时，它使用我们传入的值来调用它自己的函数实现。因此，我们只在使用真正的<code class="fe na nb nc nd b">URLSession</code>时调用网络请求。现在让我们看看如何在测试中模拟它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0931" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过在测试中动态创建一个符合<code class="fe na nb nc nd b">NetworkClientProtocol</code>的类来模拟这个函数。在这里，我们可以告诉它做我们想做的任何事情。在本例中，我告诉它返回<code class="fe na nb nc nd b">nil</code>数据来模拟函数中的<code class="fe na nb nc nd b">noData</code>错误。</p><p id="2535" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们初始化刚刚创建的模拟类，将它传递到<strong class="kt ir"> <em class="mp"> </em> </strong> <code class="fe na nb nc nd b">NetworkClient</code>，并发出请求和我们想要发出的任何断言。</p><p id="3528" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这种方法，我们避免了真实的网络请求，这意味着我们的测试更加稳定，并且我们可以测试网络可能带来的所有可能的场景。</p><p id="c62e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们免费得到的其他东西是不需要在我们的测试中使用<code class="fe na nb nc nd b">XCTestExpectation</code>。这在处理<code class="fe na nb nc nd b">@escaping</code>闭包时很常见，但是由于我们的模拟函数直接返回，我们可以避免这种情况。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="1ba2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="3cf3" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我希望你能看到，这种方法很容易与你在Swift中编写的任何函数复制。感谢阅读！</p><p id="89fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还有一份完全免费的时事通讯，我可以在上面撰写与swift相关的主题。请随意使用下面的链接注册！👇</p><div class="ne nf gp gr ng nh"><a href="https://swiftlythinking.substack.com" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">SwiftlyThinking的简讯</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">来自一位对SwiftUI和更多东西充满热情的iOS开发人员的博客帖子。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">swiftlythinking.substack.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div></div></div>    
</body>
</html>