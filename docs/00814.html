<html>
<head>
<title>A Guide to Swift Optionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift选项指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/befriending-swift-optionals-part-1-149aa5b91301?source=collection_archive---------8-----------------------#2019-07-16">https://betterprogramming.pub/befriending-swift-optionals-part-1-149aa5b91301?source=collection_archive---------8-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1264" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，如何使用它们来保护你的代码不崩溃？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f8be95d85d1270e869c93cc5a4d0ccde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*47zXOYVDsmPrPveIuJGw0w.png"/></div></figure><p id="a256" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我开始学习Swift已经一个月了。老实说，我觉得学习这门语言很有趣。但是当我不得不应用我所学的东西时，这变成了一个巨大的挑战<em class="lm">(幸运的是，我喜欢挑战！)</em>。</p><p id="23d2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">准确地说，我与Swift的期权进行了激烈的斗争。我认为期权是我最大的敌人。但是经过几天的工作和研究，Optionals和我终于达成了共识，现在我们是最好的朋友！</p><p id="19c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，本文是为那些刚开始学习Swift并在学习Swift选件时遇到困难的人而写的。我们开始吧！</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="e327" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">什么是可选的？</h1><p id="0180" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">Optionals是Swift中的一种变量，它或者包含一个值，或者具有成为<code class="fe mr ms mt mu b">nil</code>的超级能力。换句话说，<em class="lm">它们可能包含也可能不包含值</em>。可选变量可以在Swift中声明如下:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="8c8f" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>print(superOptional)</span></pre><p id="0e6c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，变量<code class="fe mr ms mt mu b">superOptional</code>是一个类型为<code class="fe mr ms mt mu b">String</code>的<code class="fe mr ms mt mu b">Optional</code>变量。这意味着它既可以包含某个字符串，也可以有<code class="fe mr ms mt mu b">nil</code>值。现在，因为我们还没有给变量赋值，所以<code class="fe mr ms mt mu b">superOptional</code>的当前值被打印为<code class="fe mr ms mt mu b">nil</code>。然而，在声明非可选变量时，情况就不同了。例如，如果我们这样做:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="f9b2" class="mz lv it mu b gy na nb l nc nd">var superVariable: String<br/>print(superVariable)</span></pre><p id="c585" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，一旦我们完成了下面的代码，IDE将开始对我们大喊<code class="fe mr ms mt mu b">Variable ‘superVariable’ used before being initialized</code>。</p><p id="3bc4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这清楚地表明我们不需要在使用前初始化一个<code class="fe mr ms mt mu b">Optional</code>变量(因为它自动用<code class="fe mr ms mt mu b">nil</code>初始化)，但是我们必须在使用前初始化一个非可选的或普通的变量。</p><p id="ec09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们继续并初始化我们的<code class="fe mr ms mt mu b">superOptional</code>变量。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="58e8" class="mz lv it mu b gy na nb l nc nd">superOptional = "Hello world!"<br/>print(superOptional)</span></pre><p id="a8f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">添加后，整个代码将如下所示:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="3ac1" class="mz lv it mu b gy na nb l nc nd">var superOptional: String? // old code<br/>print(superOptional)</span><span id="cdee" class="mz lv it mu b gy ne nb l nc nd">superOptional = "Hello world!" // new code<br/>print(superOptional)</span></pre><p id="7032" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出将是这样的:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="27af" class="mz lv it mu b gy na nb l nc nd">nil<br/>Optional(“Hello world!”)</span></pre><p id="b239" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们初始化变量<code class="fe mr ms mt mu b">superOptional</code>之前，它的值是<code class="fe mr ms mt mu b">nil</code>。然而，在用字符串<code class="fe mr ms mt mu b">“Hello world!”</code>初始化之后，该值不再是<code class="fe mr ms mt mu b">nil</code>，因此输出变成了<code class="fe mr ms mt mu b">Optional(“Hello world!”)</code>。</p><p id="e302" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是等等，输出应该只是<code class="fe mr ms mt mu b">“Hello world!”</code>！是的，当我创建我的第一个<code class="fe mr ms mt mu b">Optional</code>变量时，我就是这么想的。但是因为存储<code class="fe mr ms mt mu b">“Hello world!”</code>的变量是一个<code class="fe mr ms mt mu b">Optional</code>变量，所以它用<code class="fe mr ms mt mu b">Optional()</code>包装起来。有很多方法可以提取或解开这个价值并投入使用。我会在这篇文章中描述。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="d04c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">展开选项</h1><p id="5967" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">从<code class="fe mr ms mt mu b">Optional</code>变量中解包实际值(未在<code class="fe mr ms mt mu b">Optional()</code>内包装的值)有六种方法。它们是:</p><ol class=""><li id="f9ec" class="nf ng it ks b kt ku kw kx kz nh ld ni lh nj ll nk nl nm nn bi translated">使用if-else条件展开<code class="fe mr ms mt mu b">Optionals</code></li><li id="6df9" class="nf ng it ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">零合并算子</li><li id="b9db" class="nf ng it ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">强制展开</li><li id="fe49" class="nf ng it ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">可选装订(<code class="fe mr ms mt mu b">if let</code>)</li><li id="0e49" class="nf ng it ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated"><code class="fe mr ms mt mu b">guard let</code></li><li id="a5d7" class="nf ng it ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">可选链接</li></ol><h2 id="f314" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">1.使用if-else条件展开选项</h2><p id="3e5c" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">这是展开选项的方式，我们使用if-else条件来检查<code class="fe mr ms mt mu b">Optional</code>是否包含<code class="fe mr ms mt mu b">nil</code>值。如果<code class="fe mr ms mt mu b">Optional</code>没有保存一个<code class="fe mr ms mt mu b">nil</code>值，我们打开它，否则我们打印一个字符串<code class="fe mr ms mt mu b">“Default value”</code>。我们来实施吧。</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="352b" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>superOptional = "Hello world!"</span><span id="fda3" class="mz lv it mu b gy ne nb l nc nd">if superOptional != nil {<br/>    print(superOptional)<br/>} else {<br/>    print("Default value")<br/>}</span></pre><p id="be7f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于很多人来说，这可能是一种熟悉的释放价值的方式。然而，在Swift中有更好、更短的方法来完成这项工作。因此，不建议以这种方式展开。</p><h2 id="155f" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">2.零合并算子</h2><p id="0785" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">使用零合并运算符是展开选项的另一种方式。与使用if-else条件相比，这是一种更好、更短的展开方式(本文这一部分刚刚提到的方式)。这个操作符帮助我们展开一个<code class="fe mr ms mt mu b">Optional</code>，如果它有一个实际值，或者给出一个默认值，如果<code class="fe mr ms mt mu b">Optional</code>是<code class="fe mr ms mt mu b">nil</code>。例如:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="fb66" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>print(superOptional ?? "Default value") // nil coalescing operator</span></pre><p id="11cf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上面给出的例子中，<code class="fe mr ms mt mu b">superOptional</code>变量具有<code class="fe mr ms mt mu b">nil</code>值，因为它属于<code class="fe mr ms mt mu b">Optional</code>性质，并且没有被赋值。因此，当使用一个零合并操作符，后跟字符串<code class="fe mr ms mt mu b">“Default value”</code>来展开时，<code class="fe mr ms mt mu b">nil</code>不会被打印，而是<code class="fe mr ms mt mu b">“Default value”</code>。但是，如果<code class="fe mr ms mt mu b">superOptional</code>保持实际值，这种情况不会发生。让我们看看这个例子:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="9e7b" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>superOptional = "Hello world!"<br/>print(superOptional ?? "Default value")</span></pre><p id="8799" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上面的例子中输出是不同的，因为<code class="fe mr ms mt mu b">superOptional</code>在解包之前是用字符串<code class="fe mr ms mt mu b">“Hello world!”</code>初始化的。所以屏幕上印的是<code class="fe mr ms mt mu b">“Hello world!”</code>，而不是<code class="fe mr ms mt mu b">“Default value”</code>。</p><h2 id="dce6" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">3.强制展开</h2><p id="d7f6" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">顾名思义，强制解包是一种从可选值中解包值的方法，我们强制从变量中解包值，而不关心<code class="fe mr ms mt mu b">Optional</code>是实际值还是<code class="fe mr ms mt mu b">nil</code>值。我们通过添加感叹号(！)放在<code class="fe mr ms mt mu b">Optional</code>变量的名字后面。这是一种不安全的展开方式，因为在<code class="fe mr ms mt mu b">Optional</code>持有<code class="fe mr ms mt mu b">nil</code>值的情况下，它会导致致命错误。这个方法只在我们完全确定<code class="fe mr ms mt mu b">Optional</code>没有保存<code class="fe mr ms mt mu b">nil</code>值的情况下使用。让我们来看看它的实际应用:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="21e9" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>superOptional = “Hello world!”<br/>print(superOptional) // prints Optional("Hello world!")<br/>print(superOptional!) // prints Hello world!</span></pre><p id="9f70" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在示例中，我们可以看到有一个名为<code class="fe mr ms mt mu b">superOptional</code>的<code class="fe mr ms mt mu b">Optional</code>变量，它属于<code class="fe mr ms mt mu b">String</code>类型。字符串<code class="fe mr ms mt mu b">“Hello world!”</code>被分配给它并被初始化。当我们打印<code class="fe mr ms mt mu b">superOptional</code>变量而不展开它时，就会打印<code class="fe mr ms mt mu b">Optional(“Hello world!”)</code>。但是当我们通过在末尾加一个感叹号来打印的时候，<code class="fe mr ms mt mu b">Hello world!</code>就打印出来了。通过这种方式，在<code class="fe mr ms mt mu b">Optional</code>上执行强制展开以获得实际值。但是，如果我们试图在没有初始化变量<code class="fe mr ms mt mu b">superOptional</code>的情况下强制展开并打印它，会怎么样呢？或者，如果我们在变量值为<code class="fe mr ms mt mu b">nil</code>时尝试这样做呢？让我们看看代码:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="7b40" class="mz lv it mu b gy na nb l nc nd">var superOptional: String? // or var superOptional: String? = nil<br/>print(superOptional!) // force unwrapping</span></pre><p id="5423" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们执行上面给出的代码时，我们的代码崩溃，并得到以下错误:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="5fe3" class="mz lv it mu b gy na nb l nc nd">Fatal error: Unexpectedly found nil while unwrapping an Optional value</span></pre><p id="8d9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这里，由于我们对带有<code class="fe mr ms mt mu b">nil</code>值的<code class="fe mr ms mt mu b">Optional</code>使用了强制展开，代码崩溃了。因此，必须记住，如果我们使用强制展开，我们必须确保<code class="fe mr ms mt mu b">Optional</code>永远不会有<code class="fe mr ms mt mu b">nil</code>值。</p><h2 id="e2ae" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">4.可选绑定(如果有)</h2><p id="7f5c" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">可选绑定是强制解包的安全替代方法。如果我们试图展开的<code class="fe mr ms mt mu b">Optional</code>包含一个<code class="fe mr ms mt mu b">nil</code>值，强制展开会使我们的代码崩溃。但是通过使用可选绑定，我们可以阻止这种情况发生。在这种方法中，我们只有在确保<code class="fe mr ms mt mu b">Optional</code>包含一个实际值之后，才展开它。为此，我们使用了<code class="fe mr ms mt mu b">if let</code>。为了更好地说明这一点，让我们来看看这个例子:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="6055" class="mz lv it mu b gy na nb l nc nd">var superOptional: String?<br/>superOptional = "Hello world!"</span><span id="659b" class="mz lv it mu b gy ne nb l nc nd">if let superValue = superOptional { // optional binding<br/>    print(superValue)<br/>}</span></pre><p id="7846" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这里，我们已经检查了<code class="fe mr ms mt mu b">superOptional</code>是否是<code class="fe mr ms mt mu b">nil</code>。如果不是<code class="fe mr ms mt mu b">nil</code>，则该值被赋给<code class="fe mr ms mt mu b">superValue</code>。因此，使用从<code class="fe mr ms mt mu b">superOptional</code>获得其值的<code class="fe mr ms mt mu b">superValue</code>变得安全。</p><h2 id="e28b" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">5.警卫信</h2><p id="8513" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated"><code class="fe mr ms mt mu b">guard let</code>是<code class="fe mr ms mt mu b">if let</code>的一个很好的替代品，用于展开可选件。如果<code class="fe mr ms mt mu b">guard let</code>得到了我们试图解开的<code class="fe mr ms mt mu b">Optional</code>的<code class="fe mr ms mt mu b">nil</code>值，它希望我们退出使用它的函数、循环或条件。然而，<code class="fe mr ms mt mu b">if let</code>和<code class="fe mr ms mt mu b">guard let</code>的区别在于，即使在<code class="fe mr ms mt mu b">guard let</code>代码之后，我们仍然可以使用我们的unwrapped选项。让我们看一个例子:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="fd22" class="mz lv it mu b gy na nb l nc nd">func printName(personName: String?){<br/>    guard let name = personName else {<br/>        print(“No name has been passed.”)<br/>        return<strong class="mu iu"><br/>    </strong>}</span><span id="ba6c" class="mz lv it mu b gy ne nb l nc nd">print(“Your name is \(name).”)<br/>}</span><span id="53e8" class="mz lv it mu b gy ne nb l nc nd">printName(personName: “John Doe”) // outputs "Your name is John Doe."<br/>printName(personName: nil) // outputs "No name has been passed.</span></pre><p id="3e82" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，我们有一个函数<code class="fe mr ms mt mu b">printName(personName:)</code>。它接受一个名为<code class="fe mr ms mt mu b">personName</code>的可选<code class="fe mr ms mt mu b">String</code>，并利用<code class="fe mr ms mt mu b">guard let</code>来检查<code class="fe mr ms mt mu b">personName</code>是否为<code class="fe mr ms mt mu b">nil</code>，然后打印不同的输出。在带有<code class="fe mr ms mt mu b">guard let</code>的行中，<code class="fe mr ms mt mu b">personName</code>的值被分配给<code class="fe mr ms mt mu b">name</code>。如果发现<code class="fe mr ms mt mu b">personName</code>的值为<code class="fe mr ms mt mu b">nil</code>，则立即执行<code class="fe mr ms mt mu b">else</code>块，控制移出功能。在当前示例中，首先打印<code class="fe mr ms mt mu b">“No name has been passed”</code>并停止功能执行。但是，如果<code class="fe mr ms mt mu b">personName</code>不包含<code class="fe mr ms mt mu b">nil</code>值，则跳过<code class="fe mr ms mt mu b">else</code>块，打印该人的姓名。在当前情况下，打印<code class="fe mr ms mt mu b">“Your name is John Doe.”</code>。</p><p id="a544" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm">记住在</em> <code class="fe mr ms mt mu b"><em class="lm">guard let</em></code> <em class="lm">的</em> <code class="fe mr ms mt mu b"><em class="lm">else</em></code> <em class="lm">块中包含</em> <code class="fe mr ms mt mu b"><em class="lm">return</em></code> <em class="lm">语句是很重要的，因为我们希望一遇到</em> <code class="fe mr ms mt mu b"><em class="lm">nil</em></code> <em class="lm">值就停止函数执行。</em></p><h2 id="1a22" class="mz lv it bd lw nt nu dn ma nv nw dp me kz nx ny mg ld nz oa mi lh ob oc mk od bi translated">6.可选链接</h2><p id="8e99" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">如果我们必须同时处理多个选项，可选链接可能是一种有用的方法。假设我们有一个名为<code class="fe mr ms mt mu b">emailField</code>的带有文本字段的视图控制器，它的类型是<code class="fe mr ms mt mu b">UITextField?</code>。假设我们还设置了一个<code class="fe mr ms mt mu b">emailField</code>的<code class="fe mr ms mt mu b">@IBOutlet</code>，允许我们以编程方式设置<code class="fe mr ms mt mu b">emailField</code>的各种属性。在这个例子中，我们将处理它的<code class="fe mr ms mt mu b">text</code>属性。因此，如果我们要检查<code class="fe mr ms mt mu b">emailField</code>是由一个<code class="fe mr ms mt mu b">nil</code>值还是一些实际值组成，我们可以像这样使用可选绑定和强制解包:</p><p id="c342" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用可选绑定检索emailField的文本值:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="b35c" class="mz lv it mu b gy na nb l nc nd">if let email = emailField, let emailText = email.text {<br/>    print("The email address is: \(emailText)")<br/>}</span></pre><p id="5207" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用强制展开来检索emailField的文本值:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="4c76" class="mz lv it mu b gy na nb l nc nd">if emailField != nil &amp;&amp; emailField!.text != nil {<br/>    print("The email address is: \(emailField!.text)")<br/>}</span></pre><p id="fe0d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管这些方法可以用于展开，但是当视图控制器中UI组件的数量增加时，处理选项就变得很困难。它会变成一大堆条件句、括号和缩进，妨碍代码的可读性。因此，在这种情况下，可选的链接很方便。例如:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="969c" class="mz lv it mu b gy na nb l nc nd">emailField?.text = "someone@example.com"</span></pre><p id="3d63" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，变量<code class="fe mr ms mt mu b">emailField</code>是一个<code class="fe mr ms mt mu b">Optional</code>，后面跟一个问号。此时，在我们的代码中会发生两件事——要么变量<code class="fe mr ms mt mu b">emailField</code>不保存<code class="fe mr ms mt mu b">nil</code>值，对属性<code class="fe mr ms mt mu b">text</code>的访问成功，要么变量<code class="fe mr ms mt mu b">emailField</code>保存<code class="fe mr ms mt mu b">nil</code>值，对属性<code class="fe mr ms mt mu b">text</code>的访问失败。</p><p id="e497" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当对属性<code class="fe mr ms mt mu b">text</code>的访问失败时，该行的执行会安全地停止，而不会导致代码崩溃。在给出的例子中，当<code class="fe mr ms mt mu b">emailField</code>为<code class="fe mr ms mt mu b">nil</code>时，<code class="fe mr ms mt mu b">emailField</code>的<code class="fe mr ms mt mu b">text</code>属性没有设置为<code class="fe mr ms mt mu b">“someone@example.com”</code>。</p><p id="3ac8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">描述使用可选链接的另一个示例是:</p><pre class="kj kk kl km gt mv mu mw mx aw my bi"><span id="b50f" class="mz lv it mu b gy na nb l nc nd">car?.wheel?.airPercent = 50</span></pre></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="894a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那都是乡亲们！我希望这篇文章能给你一些关于结交Swift期权和利用它们的想法。我知道，一开始，他们看起来像是我们最大的敌人，但最终，你会意识到他们是多么有帮助。</p><p id="7a44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">快乐的雨燕！</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="4814" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你觉得这篇文章有用，并且愿意支持我，请"<a class="ae oe" href="https://www.buymeacoffee.com/sagunraj" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a>"</p><div class="of og gp gr oh oi"><a href="https://www.buymeacoffee.com/sagunraj" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Sagun Raj Lage正在撰写博客和书籍，并免费教授编程。</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">我是一名iOS开发人员，有从事各种领域相关项目的经验，如交通和…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.buymeacoffee.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ko oi"/></div></div></a></div></div></div>    
</body>
</html>