<html>
<head>
<title>WebSockets in iOS Using Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift的iOS中的WebSockets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/websockets-in-ios-using-swift-a176791e139f?source=collection_archive---------1-----------------------#2019-01-06">https://betterprogramming.pub/websockets-in-ios-using-swift-a176791e139f?source=collection_archive---------1-----------------------#2019-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fa6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WebSockets允许极快的双向网络通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dae2a845069ffd68d496a67513e9d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1iypsouAGB6jABtPW-JyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae ky" href="https://unsplash.com/search/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="319f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSockets允许极快的双向网络通信，这让您可以更快、更频繁地发送和接收更新，更不用说安全了。</p><p id="4153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket是一种使用套接字的通信协议，通过单个TCP连接提供双工通信。它在2011年由IETF标准化，是一种不同于HTTP的协议。</p><p id="1ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSockets广泛应用于聊天应用、流式实时通知和股票价格。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c321" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">WebSocket生命周期</h1><h2 id="b614" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">与服务器握手</h2><p id="7f7f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-4" rel="noopener ugc nofollow" target="_blank">握手</a>应用是WebSockets中的web部件。它是从HTTP到WebSocket的桥梁。客户端发送一个非常标准的HTTP <code class="fe nl nm nn no b">GET</code> <a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-4.2.1" rel="noopener ugc nofollow" target="_blank">请求</a>给服务器:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="cc5e" class="mu md it no b gy nt nu l nv nw">GET /chat HTTP/1.1<br/>Host: example.com:8000<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==<br/>Sec-WebSocket-Version: 1</span></pre><p id="9062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最有意思的是<code class="fe nl nm nn no b">Sec-WebSocket-Key</code>，出于安全考虑需要，按照<a class="ae ky" href="http://tools.ietf.org/html/rfc6455#page-7" rel="noopener ugc nofollow" target="_blank"> WebSocket标准</a>生成。</p><p id="b0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器验证请求，如果一切正常，就发回一个HTTP <a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-4.2.2" rel="noopener ugc nofollow" target="_blank">响应</a>:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="f972" class="mu md it no b gy nt nu l nv nw">HTTP/1.1 101 Switching Protocols<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span></pre><h2 id="3206" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">交换信息</h2><p id="c0e7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在任何时候，服务器或客户端都可以发送遵循以下特定格式的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/899a9ed05bb35d1e876a024b39049283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UEAu_ORwmasLH6zi.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket帧格式</p></figure><p id="d9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会详细介绍每一部分，但是您可以在<a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-5.6" rel="noopener ugc nofollow" target="_blank">标准</a>中找到更多信息。</p><h2 id="39ae" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">Pings和pongs</h2><p id="1cfa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在任何时候，客户端或服务器都可以发送一个<a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-5.5.2" rel="noopener ugc nofollow" target="_blank"> ping </a>，而另一方必须发回一个<a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-5.5.3" rel="noopener ugc nofollow" target="_blank"> pong </a>。</p><h2 id="1525" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">关闭</h2><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">任何一方都可以通过发送<a class="ae ky" href="https://tools.ietf.org/html/rfc6455#section-5.5.1" rel="noopener ugc nofollow" target="_blank">指定的控制序列</a>来关闭连接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b5b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在iOS中实现WebSockets</h1><p id="fb67" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在iOS、macOS、tvOS或watchOS中实现WebSockets并非易事。新的<a class="ae ky" href="https://developer.apple.com/documentation/network" rel="noopener ugc nofollow" target="_blank"> Network.framework </a>可以简化这一点，但你仍然需要处理底层任务，比如升级连接和建立WebSocket框架。</p><h1 id="d019" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">红蜘蛛</h1><p id="016a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Swift WebSocket客户端库<a class="ae ky" href="https://github.com/daltoniam/Starscream" rel="noopener ugc nofollow" target="_blank"> Startscream </a>简化了所有繁重的任务。安装库并将其导入任何Swift文件。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4b82" class="mu md it no b gy nt nu l nv nw">import Starscream</span></pre><h1 id="ddfb" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">创建连接</h1><p id="9250" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">之后，创建一个连接并设置代理。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="6059" class="mu md it no b gy nt nu l nv nw">let url = URl(string: "ws://echo.websocket.org")!<br/>  let request = URLRequest(url: url)<br/>  let websocket = WebSocket(request: request)</span></pre><h1 id="2160" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">设置委托</h1><p id="8566" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">然后，我们需要设置delegate并使用event <code class="fe nl nm nn no b">WebSocketEvent</code>类型实现<code class="fe nl nm nn no b">didReceive</code>方法。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="2d44" class="mu md it no b gy nt nu l nv nw">func didReceive(event: WebSocketEvent, client: WebSocket) {<br/>    switch event {<br/>    case .connected(let headers):<br/>      print("connected \(headers)")<br/>    case .disconnected(let reason, let closeCode):<br/>      print("disconnected \(reason) \(closeCode)")<br/>    case .text(let text):<br/>      print("received text: \(text)")<br/>    case .binary(let data):<br/>      print("received data: \(data)")<br/>    case .pong(let pongData):<br/>      print("received pong: \(pongData)")<br/>    case .ping(let pingData):<br/>      print("received ping: \(pingData)")<br/>    case .error(let error):<br/>      print("error \(error)")<br/>    case .viabilityChanged:<br/>      print("viabilityChanged")<br/>    case .reconnectSuggested:<br/>      print("reconnectSuggested")<br/>    case .cancelled:<br/>      print("cancelled")<br/>    }<br/>  }</span></pre><p id="56bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，我们就可以开始连接了。握手和升级连接由库在幕后完成。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="f3c0" class="mu md it no b gy nt nu l nv nw">socket.connect();</span></pre><h1 id="089d" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">发送数据</h1><p id="aa2a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">发送数据有几种方式:</p><ul class=""><li id="d0a1" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated">二进制的</li><li id="f75b" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">线</li><li id="40c7" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">砰</li><li id="5b95" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">恶臭</li></ul><p id="399f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是只发送一个字符串:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="aa2b" class="mu md it no b gy nt nu l nv nw">socket.write(string: "Hi Server!")</span></pre><h1 id="e0a2" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">关闭连接</h1><p id="77c1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在任何时候，如果不再需要，我们都可以选中关闭它。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4bcf" class="mu md it no b gy nt nu l nv nw">websocket.disconnect(closeCode: CloseCode.goingAway.rawValue)</span></pre><h1 id="b460" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="8acb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">WebSocket在iOS、macOS、tvOS、watchOS都不是一等公民。实施、使用和理解它可能会非常困难，但Swift library红蜘蛛可以帮助您完成所有这些任务。</p><h1 id="cf5b" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">链接</h1><ul class=""><li id="50a9" class="od oe it lb b lc ng lf nh li or lm os lq ot lu oi oj ok ol bi translated"><a class="ae ky" href="https://tools.ietf.org/html/rfc6455" rel="noopener ugc nofollow" target="_blank">web socket协议</a></li><li id="07f9" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" rel="noopener ugc nofollow" target="_blank">编写WebSocket服务器</a></li><li id="007f" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://github.com/daltoniam/Starscream" rel="noopener ugc nofollow" target="_blank">红蜘蛛Swift WebSocket库</a></li><li id="f10d" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://github.com/ZewoGraveyard/WebSocket/blob/master/Sources/WebSocket/Frame.swift" rel="noopener ugc nofollow" target="_blank">Swift中的Websocket框架实施</a></li><li id="4d2a" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="http://lucumr.pocoo.org/2012/9/24/websockets-101/" rel="noopener ugc nofollow" target="_blank"> WebSockets 101 </a></li><li id="4dd7" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><a class="ae ky" href="https://devcenter.heroku.com/articles/websocket-security" rel="noopener ugc nofollow" target="_blank"> WebSocket安全</a></li></ul></div></div>    
</body>
</html>