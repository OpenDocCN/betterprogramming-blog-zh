<html>
<head>
<title>Decouple Your Code With Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用依赖注入解耦你的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decouple-your-code-with-dependency-injection-d893ae9edcf8?source=collection_archive---------8-----------------------#2020-02-25">https://betterprogramming.pub/decouple-your-code-with-dependency-injection-d893ae9edcf8?source=collection_archive---------8-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要第三方框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57b706b64eedbb47c99e0160aa965e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfS1KYIt9IIDZTIyIIfMsQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@icons8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae ky" href="https://unsplash.com/s/photos/ingredients?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有多少组件是独立存在的，不依赖于其他组件。我们可以通过利用<em class="lv">依赖注入</em> (DI)来改进<a class="ae ky" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>，而不是创建紧密耦合的组件。</p><p id="b7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将向您介绍依赖注入的核心概念，不需要第三方框架。所有代码示例都将使用Java，但是一般原则也适用于任何其他语言。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0d9b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例:数据处理器</h1><p id="14f3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了更好地形象化如何使用依赖注入<em class="lv">、</em>，我们从一个简单的类型开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">DataProcessor</code>有两个依赖项:<code class="fe nc nd ne nf b">DbManager</code>和<code class="fe nc nd ne nf b">Calculator</code>。在我们的类型中直接创建它们有几个明显的缺点:</p><ul class=""><li id="740c" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">构造函数调用可能会崩溃。</li><li id="068b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">构造函数签名可能会改变。</li><li id="19d2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">紧密绑定到显式实现类型。</li></ul><p id="16cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候改进了！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f334" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">依赖注入</h1><p id="23e1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">《敏捷开发的艺术》 ，<a class="ae ky" href="https://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html" rel="noopener ugc nofollow" target="_blank">的作者James Shore说得很好</a>:</p><blockquote class="nu"><p id="809b" class="nv nw it bd nx ny nz oa ob oc od lu dk translated"><em class="oe">“依赖注入是一个5美分概念的25美元术语。”</em></p></blockquote><p id="bce0" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这个概念实际上非常简单:给一个组件完成它的工作所需的所有东西。</p><p id="0737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，这意味着通过从外部提供组件的依赖关系来解耦组件，而不是直接创建组件，这样会产生粘连。</p><p id="4d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过不同的方式为实例提供必要的依赖关系:</p><ul class=""><li id="a390" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">构造函数注入</li><li id="8de3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">资产注入</li><li id="84b2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">方法注入</li></ul><h2 id="9df2" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">构造函数注入</h2><p id="614b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">构造函数，或基于初始值设定项的依赖注入，意味着在实例初始化期间提供所有必需的依赖项，作为构造函数参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="48dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个简单的改变，我们可以抵消大部分最初的缺点:</p><ul class=""><li id="d289" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">容易替换:<code class="fe nc nd ne nf b">DbManager</code>和<code class="fe nc nd ne nf b">Calculator</code>不再被绑定到具体的实现，现在可以模拟单元测试。</li><li id="f19d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">已经初始化并且“准备就绪”:我们不需要担心依赖项所需的任何子依赖项(例如，数据库文件名、有效数字)，或者它们可能在初始化期间崩溃。</li><li id="276c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">强制性要求:调用者确切地知道创建一个<code class="fe nc nd ne nf b">DataProcessor</code>需要什么。</li><li id="a66c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">不变性:依赖仍然是最终的。</li></ul><p id="3c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管构造函数注入是许多DI框架的首选方式，但它也有明显的缺点。最重要的一点是，所有的依赖项都必须在初始化时提供。</p><p id="5b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们自己不初始化一个组件，或者我们不能在那时提供所有的依赖。或者我们需要使用另一个构造函数。而且依赖关系一旦设定，就无法更改。</p><p id="9ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以通过使用其他注射类型之一来缓解这些问题。</p><h2 id="bc0a" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">资产注入</h2><p id="e5fd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时我们无法访问类型的实际初始化，只有一个已经初始化的实例。或者在初始化时并不明确知道所需的依赖关系，而这在以后会知道。</p><p id="e6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些情况下，我们可以使用<em class="lv">属性注入</em>，而不是依赖于构造函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不再需要构造函数，我们可以在初始化后随时提供依赖关系。但是这种注射方式也有缺点:<em class="lv">可变性</em>。</p><p id="2632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nc nd ne nf b">DataProcessor</code>在初始化后不再保证“准备就绪”。能够随意改变依赖关系可能会给我们带来更多的灵活性，但也带来了更多运行时检查的缺点。</p><p id="9a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在必须处理访问依赖项时出现<code class="fe nc nd ne nf b">NullPointerException</code>的可能性。</p><h2 id="227d" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">方法注入</h2><p id="8816" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">即使我们用构造函数注入和/或属性注入来解耦依赖，通过这样做，我们仍然只有一个选择。如果我们在某些情况下需要另一个<code class="fe nc nd ne nf b">Calculator</code>怎么办？</p><p id="7a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想为第二个<code class="fe nc nd ne nf b">Calculator</code>添加额外的属性或构造函数参数，因为将来可能需要第三个。并且每次在我们调用<code class="fe nc nd ne nf b">calc(...)</code>之前改变属性也是不可行的，并且很可能导致错误使用错误的属性。</p><p id="2a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是用它的依赖项参数化方法调用本身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nc nd ne nf b">calc(...)</code>的调用者负责提供一个合适的<code class="fe nc nd ne nf b">Calculator</code>实例，<code class="fe nc nd ne nf b">DataProcessor</code>与之完全解耦。</p><p id="f464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过混合不同类型的注入，甚至可以获得更大的灵活性，并提供默认的<code class="fe nc nd ne nf b">Calculator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呼叫者<em class="lv">可以</em>提供不同类型的<code class="fe nc nd ne nf b">Calculator</code>，但是<em class="lv">不必</em>。我们仍然有一个解耦的、准备就绪的<code class="fe nc nd ne nf b">DataProcessor</code>，能够适应特定的场景。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d269" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">选择哪种注射方式？</h1><p id="a824" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每种依赖注入都有自己的优点，没有“正确的方法”。这完全取决于你的实际要求和环境。</p><h2 id="f975" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">构造函数注入</h2><p id="ce8f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">构造函数注入是我的最爱，也是DI框架的首选。</p><p id="369d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它清楚地告诉我们创建一个特定组件所需的所有依赖项，并且它们不是可选的。这些依赖关系在整个组件中都是必需的。</p><h2 id="3563" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">资产注入</h2><p id="11a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">属性注入更好地匹配可选参数，如侦听器或委托。或者如果我们不能在初始化时提供依赖关系。</p><p id="d24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一些语言，比如Swift，大量使用带有属性的<a class="ae ky" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托模式</a>。因此，使用它将使我们的代码为其他开发人员所熟悉。</p><h2 id="133d" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">方法注入</h2><p id="4b4d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果每个调用的依赖可能不相同，那么方法注入是一个完美的匹配。这将进一步解耦组件，因为现在，只有方法本身具有依赖性，而不是整个组件。</p><p id="16e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这不是非此即彼的问题。我们可以在合适的地方自由混合不同的类型。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d097" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">控制容器的倒置</h1><p id="ebdd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以用依赖注入的这些简单实现来覆盖很多用例。这是一个很好的解耦工具，但是我们实际上仍然需要在某些时候创建依赖关系。</p><p id="7ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是随着我们的应用程序和代码库的增长，我们可能需要一个更完整的解决方案来简化创建和组装过程。</p><p id="ee59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">控制反转</em> (IoC)是<a class="ae ky" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">控制流</a>的抽象原理。依赖注入是其更具体的实现之一。</p><p id="08fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IoC容器是一种特殊的对象，它知道如何实例化和配置其他对象，包括为你做依赖注入。</p><p id="548a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些容器可以通过反射来检测关系，有些则需要手动配置。有些是基于运行时的，有些是在编译时生成所有需要的代码。</p><p id="ba28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较所有不同的选项超出了本文的范围，但是让我们看一个小例子来更好地理解这个概念。</p><h2 id="0b08" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">例如:匕首2</h2><p id="ba4b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>是一个轻量级的编译时依赖注入框架。我们需要创建一个<code class="fe nc nd ne nf b">Module</code>，它知道如何构建我们的依赖关系，稍后只需添加一个<code class="fe nc nd ne nf b">@Inject</code>注释就可以注入它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">@Singleton</code>确保只创建一个依赖实例。</p><p id="feb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了被注入依赖项，我们只需将<code class="fe nc nd ne nf b">@Inject</code>添加到构造函数、字段或方法中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b0fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些只是绝对的基础知识，乍一看可能并不令人印象深刻。但是IoC容器和框架不仅允许我们分离组件，还允许我们最大化依赖创建的灵活性。</p><p id="e7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于所提供的高级特性，创建过程变得更加可配置，并支持使用依赖项的新方法。</p><h2 id="8c85" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">高级功能</h2><p id="cf69" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不同种类的IoC容器和底层语言之间的特性差异很大，比如:</p><ul class=""><li id="f4da" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">代理模式和延迟加载。</li><li id="681d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">生命周期范围(例如，单例与每个线程一个)。</li><li id="18dc" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">自动布线。</li><li id="fdf6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">单个类型的多个实现。</li><li id="960f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">循环依赖。</li></ul><p id="8ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些特性是IoC容器的真正力量。你可能认为像“循环依赖”这样的特性不是一个好主意。你是对的。</p><p id="ed9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果由于遗留代码或者过去不可改变的糟糕设计决策，我们确实需要这种奇怪的代码结构，我们现在有能力这样做。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8572" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="55eb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们应该针对抽象来设计我们的代码，比如接口，而不是具体的实现，以减少粘连。</p><p id="c0fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码需要的唯一信息必须在接口中可用，我们不能对实际的实现做任何假设。</p><blockquote class="nu"><p id="e9ae" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">一个人应该依赖抽象，而不是具体。<br/>  —罗伯特·c·马丁(2000)，设计原则和设计模式</p></blockquote><p id="a204" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">依赖注入是一个很好的方法，通过解耦我们的组件来做到这一点。它允许我们编写更干净、更简洁、更易于维护和重构的代码。</p><p id="9faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择三种依赖注入类型中的哪一种取决于环境和需求，但是我们也可以混合使用这些类型来最大化收益。</p><p id="fb5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IoC容器可以通过简化组件创建过程来提供另一种便利的布局，有时几乎是以一种神奇的方式。</p><p id="06a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该到处使用它吗？当然不是。</p><p id="6505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像其他模式和概念一样，我们应该在适当的时候应用它们，而不仅仅是因为我们可以。</p><p id="fcf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">永远不要把自己局限在单一的做事方式上。也许<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂模式</a>或者甚至广为厌恶的<a class="ae ky" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例模式</a>对你的需求来说可能是更好的解决方案。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2b9e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="f485" class="ng nh it lb b lc mv lf mw li ow lm ox lq oy lu nl nm nn no bi translated"><a class="ae ky" href="https://www.martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">控制容器的倒置和依赖注入模式</a>(马丁·福勒)</li><li id="cc8c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>(维基百科)</li><li id="6800" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">控制反转</a>(维基百科)</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="30e1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">国际奥委会集装箱</h1><h2 id="26df" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><ul class=""><li id="a64c" class="ng nh it lb b lc mv lf mw li ow lm ox lq oy lu nl nm nn no bi translated"><a class="ae ky" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank">匕首</a></li><li id="82d8" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-introduction" rel="noopener ugc nofollow" target="_blank">弹簧</a></li><li id="4f3a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://tapestry.apache.org/ioc.html" rel="noopener ugc nofollow" target="_blank">挂毯</a></li></ul><h2 id="f0f9" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">科特林</h2><ul class=""><li id="af8d" class="ng nh it lb b lc mv lf mw li ow lm ox lq oy lu nl nm nn no bi translated"><a class="ae ky" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank">锦鲤</a></li></ul><h2 id="811d" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">迅速发生的</h2><ul class=""><li id="3573" class="ng nh it lb b lc mv lf mw li ow lm ox lq oy lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/AliSoftware/Dip" rel="noopener ugc nofollow" target="_blank">倾斜</a></li><li id="6226" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">斯温杰特</li></ul><h2 id="6966" class="ok me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">C#</h2><ul class=""><li id="6e52" class="ng nh it lb b lc mv lf mw li ow lm ox lq oy lu nl nm nn no bi translated"><a class="ae ky" href="https://autofac.org/" rel="noopener ugc nofollow" target="_blank">自动飞行控制</a></li><li id="5320" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="http://www.castleproject.org/projects/windsor/" rel="noopener ugc nofollow" target="_blank">温莎城堡</a></li></ul></div></div>    
</body>
</html>