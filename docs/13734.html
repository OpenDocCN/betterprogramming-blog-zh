<html>
<head>
<title>Introducing Khipu: My Boilerplate Code-Free Implementation of Clean Architecture in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Khipu:我在Swift中干净架构的样板无代码实现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/meet-khipu-a-boilercode-free-implementation-of-clean-architecture-in-swift-f76ccab82ff3?source=collection_archive---------5-----------------------#2022-09-21">https://betterprogramming.pub/meet-khipu-a-boilercode-free-implementation-of-clean-architecture-in-swift-f76ccab82ff3?source=collection_archive---------5-----------------------#2022-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究这种完全声明性的、不可变的日常项目解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c62778f66340126b3d968255b312efa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsEpxJ-UgtXVK6QC-IOHTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Khipu代码在运行。作者图片</p></figure><p id="398a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MVVM-(X)、VIP、VIPER——所有这些所谓的架构都有两个共同点:它们都可以追溯到罗伯特·c·马丁的<a class="ae lu" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁架构</a>。在iOS中，我还没有看到一个有效的架构。它们并不完全独立于UI(Martin:“UI必须是一个I/O设备”)，或者允许您将决策推迟到以后的某个时间点，可能是无限的。</p><p id="14f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在iOS中，很长一段时间的问题是，“把<code class="fe lv lw lx ly b">ViewController</code>放在哪里”——让架构回答它不应该被打扰的问题。对于SwiftUI，这个问题已经转变为“在SwiftUI中构建(MVVM |蝰蛇| VIP)”——从一开始就将UI耦合到任何其他代码——并且违反了架构所代表的一切。</p><p id="082e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些非架构的一个共同点是，它们都需要实现不同的对象:</p><ul class=""><li id="4f10" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">协调者</li><li id="4fe4" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">路由器</li><li id="a41f" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">提出者</li><li id="cc55" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">视图模型</li><li id="3dba" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">DI框架</li></ul><p id="98f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些对象只是作为无效架构的一种需要而存在——它们对应用程序的域没有任何贡献——域是应用程序最初被委托的原因。没有客户在订购应用程序时会要求它包含一定数量的路由器和协调器。因此，所有这些对象都必须算作<a class="ae lu" href="https://medium.com/background-thread/accidental-and-essential-complexity-programming-word-of-the-day-b4db4d2600d4" rel="noopener">偶然复杂性</a>或<a class="ae lu" href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">样板代码</a>。</p><p id="f9d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看待样板代码和意外复杂性的另一种方式:<br/>从根本上说，所有的应用程序都非常相似:</p><ul class=""><li id="a53d" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">用户使用用户界面来触发动作</li><li id="d090" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">该应用程序的逻辑处理这个动作并生成一个新的状态</li><li id="b01c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">用户界面发生变化以反映变化后的状态</li></ul><p id="c3ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们称之为“内在设计”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/44dc6b39fd29614599de3c17f7fb66ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmcDoY8ersQ88JtAguvDmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个应用的内在设计</p></figure><p id="b4d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个简化的最小且无意外复杂性的架构，你会期望能够识别这种设计:它偏离得越少，架构就越符合内在设计。如果一个架构不容易被映射，那么它包含了大量的意外复杂性和样板代码。稍后我们将比较下面的架构和这个——让它成为意外复杂性的试金石。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="dc06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经看到大多数“架构”都是无效的，并且充满了样板代码，那么让我介绍一下“khi pu”——Robert c . Martin的“<a class="ae lu" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>”的一个有效实现，它根本没有任何意外的复杂代码。</p><p id="9b03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Khipu通过处处拥抱简单来实现这一点。</p><p id="2f14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它只允许数据单向流动，并且几乎是完全不可变的。以下两项都使代码变得简单:</p><ul class=""><li id="3881" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">单向数据流:易于理解和推理。如果数据只能单向流动，这将极大地简化体系结构</li><li id="0549" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">不可变数据类型:正如我们马上会看到的，我建议只使用不可变数据类型。可能会有很多人说为什么这是有益的，但我想简短地说:如果一些东西不能被故意改变，它也不能意外地改变——消除最有可能使系统崩溃的错误。</li></ul><p id="386b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，在无数被视为面向对象的类中杂乱无章的强制性结构化代码表明，增加复杂性是对现有复杂性的适当反应。这就像把隔壁房间的垃圾桶倒进房间里来打扫房间一样。通过在系统的中心使用类，这种影响被极大地放大了。</p><p id="5f1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类提供了大量的交互。它们允许(几乎)任何数量的方法。它们是可子类化的和可变的。虽然这些都是我们模块不需要的东西，但我们需要它们能够做的一件事，它们做得不好。几十年来，类一直被宣传为黑盒的完美工具，尽管它们最多只能提供灰盒，事实证明了这一点，即除了类的签名之外，通常还需要额外的子类化信息。</p><p id="d95a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">班级辜负了他们的核心承诺。此外，它们不能提供模块所期望的流通——实现这一点需要模式魔法。我加入了<a class="ae lu" href="https://suzdalnitski.medium.com/?source=post_page-----bd2c4fb3014c--------------------------------" rel="noopener"> Ilya Suzdalnitski </a>的行列，并认为，到目前为止，大多数<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">模式只是在处理OOP(和类)的缺点</a>时才是必要的:</p><blockquote class="mv mw mx"><p id="ae9e" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">没有客观公开的证据表明OOP比简单的过程化编程更好。</p><p id="4127" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">痛苦的事实是，OOP在它唯一想要解决的任务上失败了。理论上看起来不错——我们对动物、狗、人类等有清晰的等级划分。然而，一旦应用程序的复杂性开始增加，它就变得平淡无奇了。</p><p id="74fe" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><em class="it">它非但没有降低复杂性，反而鼓励混杂</em> <strong class="la iu"> <em class="it"> </em> </strong> <em class="it">共享</em> <a class="ae lu" href="https://suzdalnitski.com/terrible-coding-mistake-aa1fbebd83b4" rel="noopener ugc nofollow" target="_blank"> <em class="it">可变状态</em></a><strong class="la iu"><em class="it"/></strong><em class="it">，并以其众多的</em> <a class="ae lu" href="https://suzdalnitski.com/oop-design-patterns-bd2c4fb3014c" rel="noopener ugc nofollow" target="_blank"> <em class="it">设计模式</em> </a> <em class="it">引入额外的复杂性。OOP使得常见的开发实践，如重构和测试，变得不必要的困难。”</em></p></blockquote><p id="3c43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于蜘蛛人原则，我们将不再依赖于系统中心的类，而是依赖于一种在OO中并不出名但却比它早了几十年的技术:部分应用。好吧，让我们从那开始。</p><h1 id="d37c" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">部分应用</h1><p id="5ba0" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">部分应用是一种技术，其中调用一个函数，执行其主体，最后返回另一个函数。这个函数现在可以写入一个命名引用(变量或常量)。该函数被部分应用，因为它可以访问外部函数体中的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d5da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">createAdder</code>接受一个<code class="fe lv lw lx ly b">Int</code>值并返回另一个函数。返回的函数通过添加新提供的整数并返回新值来访问和更改值——部分应用程序是管理副作用和状态的一种方式(旁注:因此，它不属于您的函数式编程工具包)。</p><p id="0c79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将部分应用的函数与函数元组相结合，我们可以做到以下几点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="ec27" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">Stack&lt;T&gt;</code>被定义为一个push和pop函数的元组</li><li id="b8fd" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">createStack</code>创建一个数组，它的<code class="fe lv lw lx ly b">push</code>和<code class="fe lv lw lx ly b">pop</code>函数将访问并改变该数组。返回一个<code class="fe lv lw lx ly b">Stack&lt;T&gt;</code>-元组</li><li id="569e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">正如我们从第8行开始看到的，使用这个定制的对象与使用一个类或结构实例没有什么不同</li></ul><p id="c35d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Khipu中，我们使用以下定制的对象来存储应用程序状态(动态类型<code class="fe lv lw lx ly b">&lt;S&gt;</code>)并用动态类型<code class="fe lv lw lx ly b">&lt;C&gt;</code>来改变它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="beaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将存储定义为访问、更改、重置和销毁存储状态的通用函数元组。它还允许注册回调并通知更改——一个简单的订阅者模式。</p><p id="3e27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">苹果平台上磁盘存储的实现，<code class="fe lv lw lx ly b">&lt;S&gt;</code>变成了<code class="fe lv lw lx ly b">AppState</code>，<code class="fe lv lw lx ly b">&lt;C&gt;</code>，<code class="fe lv lw lx ly b">AppState.Change</code>——后面会解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f9bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我前面提到过Khipu可能接近绝对不可变。第10、11和12行中对变量<code class="fe lv lw lx ly b">state</code>和<code class="fe lv lw lx ly b">callbacks</code>的重新赋值是整个项目中仅有的这种赋值——所有其他代码都可以而且应该是不可变的。</p><h1 id="5a96" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">不可变数据类型和AppState</h1><p id="cd09" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们希望我们的代码——包括我们的模型数据类型——是不可变的，从而将出错的可能性降低很多倍。</p><p id="052b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下数据类型模型是智能照明应用的光源(想想:Phillips Hue)。正如我们在第19到30行看到的，所有属性都是类型化的<code class="fe lv lw lx ly b">let</code>——因此，我们知道这个结构是不可变的。为了反映变化，比如打开或关闭，改变色温或色调，饱和度和亮度，我们需要创建同一对象的新版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="e98c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们通过使用<code class="fe lv lw lx ly b">alter</code>方法(第42行)来实现它，该方法采用一个<code class="fe lv lw lx ly b">Change</code>值，如第2行的<code class="fe lv lw lx ly b">Change</code>枚举中所定义的。<br/> <code class="fe lv lw lx ly b">Change</code>定义了以下数值:</p><ul class=""><li id="0c78" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.renaming(.it(to:&lt;newname&gt;))</code></li><li id="5282" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.turning(.it(.on))</code>和<code class="fe lv lw lx ly b">.turning(.it(.off))</code></li><li id="c2a2" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.adding(.mode(&lt;lightmode&gt;))</code></li><li id="077a" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.toggling(.display(to:&lt;interface&gt;))</code></li><li id="50aa" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.setting(.hue(to:&lt;value&gt;))</code></li><li id="3ea0" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.setting(.saturation(to:&lt;value&gt;))</code></li><li id="5653" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.setting(.brightness(to:&lt;value&gt;))</code></li><li id="fd88" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">.setting(.temperature(to:&lt;value&gt;))</code></li></ul><p id="6e8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些值描述了期望的行为—<code class="fe lv lw lx ly b">Change</code>枚举对行为进行编码。</p><p id="5f42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后通过<code class="fe lv lw lx ly b">alter</code>方法中的模式匹配对行为进行解码(第48行)，所有情况都遵循相同的模式:</p><ul class=""><li id="eed6" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在每个case语句冒号(<code class="fe lv lw lx ly b">lhs : rhs</code>)的左侧，通过模式匹配对值进行解码来提取意图。在那个冒号的右边，定义了相应的动作<br/><em class="my">lhs:</em><code class="fe lv lw lx ly b">case .turning(.it(.on))<br/></code><em class="my">RHS:</em><code class="fe lv lw lx ly b">return .init(id,name,<strong class="la iu">.on</strong>,b,s,h,ct,display,modes,selectedMode)<br/></code>我们在这里看到的是一个公理:编译器正在被示教，<code class="fe lv lw lx ly b">.turning(.it(.on))</code>是什么意思——之前的<code class="fe lv lw lx ly b">onOrOff</code>值将被替换为<code class="fe lv lw lx ly b">.on</code>，而其他所有值都将被重用。这就是所谓的“构造函数递归”</li></ul><p id="fe07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将这八条公理组合成更复杂的行为，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6376" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，一个新的光被创建，并立即改变，以反映亮度，饱和度，色调和温度的某些值，并打开它。如果你仔细观察，你会发现这与英语口语非常相似，你可以阅读下面的内容:</p><blockquote class="mv mw mx"><p id="9bde" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">让灯光成为:id和名称为“01”的灯光，<br/>通过<br/>改变*设置亮度为0.5 <br/> *设置色调为0.5 <br/> *设置饱和度为0.5 <br/> *设置温度为200 mirek <br/> *打开</p></blockquote><p id="cdbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型对象保存在<code class="fe lv lw lx ly b">AppState</code>中，这是一个不可变的结构，就像模型类型一样工作，解码<code class="fe lv lw lx ly b">Change</code>枚举中的行为，并通过<code class="fe lv lw lx ly b">alter</code>方法中的模式匹配实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5f45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">AppState’s</code> <code class="fe lv lw lx ly b">Change</code> enum允许以下DSL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="db23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">AppState</code>本身也是不可变的，这意味着我们必须将它保存在引用类型中。我之前给你看过<code class="fe lv lw lx ly b">Store</code>。它是一个函数元组，这些函数必须是函数，因为元组本身是值类型，而函数是所需的引用类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">Store</code>的使用方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4ca3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经看到了如何以一种不变的方式处理我们的模型，让我们继续看一看<code class="fe lv lw lx ly b">UseCases</code>——Martin的干净架构的主要构件。</p><h1 id="4817" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">使用案例和功能</h1><p id="7a0a" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">Khipu的<code class="fe lv lw lx ly b">UseCases</code>灵感来自马丁的干净建筑<code class="fe lv lw lx ly b">UseCases</code>，遵循以下设置:</p><ul class=""><li id="5a83" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">一个<code class="fe lv lw lx ly b">UseCase</code>有一个<code class="fe lv lw lx ly b">Request</code>类型，用于对这个<code class="fe lv lw lx ly b">UseCase</code>的请求进行编码</li><li id="08eb" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">一个传入的请求将被分析并转换成对<code class="fe lv lw lx ly b">UseCase’s</code> <code class="fe lv lw lx ly b">Interactor</code>对象的调用，该对象将被创建并具有它需要的所有依赖关系。这包括网络和磁盘处理</li><li id="3b67" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">一旦<code class="fe lv lw lx ly b">Interactor</code>完成，它将向<code class="fe lv lw lx ly b">UseCase</code>报告，T3将使用新收集的数据创建一个<code class="fe lv lw lx ly b">Response</code>类型的对象</li><li id="a29b" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">Request</code>和<code class="fe lv lw lx ly b">Response</code>对于每个<code class="fe lv lw lx ly b">UseCase</code>都是唯一的——确保关注点的分离。这也使得值的数量非常少:通常一个用例只做一件事——通常有一个请求和一个成功响应用例，如果需要的话，还有一个错误响应用例。这并不是一成不变的，我认为在一个用例中实现互补的动作是有意义的，例如:一个用例同时处理登录和注销，产生两个请求用例。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a79cb4bc109cb1260569b61087a3a45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_dkc-79f3PHAtD_IhVWcA.png"/></div></div></figure><p id="e9d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Swift中，我们表述如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0ef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，交互器是一个实现细节，允许您以许多不同的方式实现它——对于大多数最简单的用例，包括根本不实现它。</p><p id="f0f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个PAT——“具有关联类型的协议”，我们按如下方式实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d22c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe lv lw lx ly b">Dimmer</code> <code class="fe lv lw lx ly b">UseCase</code>允许光的不同值被递增地改变。注意，对于这个简单的<code class="fe lv lw lx ly b">UseCase</code>,不需要<code class="fe lv lw lx ly b">Interactor</code>——因为它是一个实现细节，我们可以省略它。</p><p id="8696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码显示了调光器请求和响应的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a2c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们将几个用例组合到照明功能中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9c82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，一个特性只是一个部分应用的函数，它在创建过程中接受任何依赖项(这里:一个以无线方式控制灯光的灯光堆栈类和一个存储对象)和一个<code class="fe lv lw lx ly b">Output</code>(也称为回调)，并返回一个名为<code class="fe lv lw lx ly b">Input</code>的函数，这个函数接受一个<code class="fe lv lw lx ly b">Message</code>值(我们稍后将再次讨论它)作为参数，不返回任何内容。</p><p id="d210" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在主体中，我们看到用例被实例化，每个用例都需要依赖关系——<code class="fe lv lw lx ly b">LightStack</code>(系统集线器的网络网关)和一个商店——如果需要，回调函数将调用输出。</p><p id="3e48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">返回的函数只是模式匹配。如果<code class="fe lv lw lx ly b">Message</code>用于照明功能，如果为真，则将其转发给本地定义的函数<code class="fe lv lw lx ly b">execute(command:)</code>，该模式匹配每个可能的消息，并相应地调用用例。</p><p id="bf5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当<code class="fe lv lw lx ly b">UseCases</code>实现应用程序的逻辑并与他们自己的<code class="fe lv lw lx ly b">Request</code>和<code class="fe lv lw lx ly b">Response</code>类型——他们特定的<code class="fe lv lw lx ly b">DSLs</code>—进行通信时，功能会监听消息，并在需要时将其转换为用例。和<code class="fe lv lw lx ly b">UseCase</code> <code class="fe lv lw lx ly b">Responses</code>同样被翻译成消息——<code class="fe lv lw lx ly b">Message</code>是用于系统范围内特征间通信的<code class="fe lv lw lx ly b">DSL</code>。</p><h1 id="90ec" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">信息</h1><p id="6077" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们之前已经看到过几次被提及的消息，让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="08f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此<code class="fe lv lw lx ly b">Message</code>对三个特性的值进行编码:</p><ul class=""><li id="69ff" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">照明设备</li><li id="2622" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">仪表盘</li><li id="6c85" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">记录</li></ul><p id="d7b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">照明特性的值在<code class="fe lv lw lx ly b">Message._Lighting</code>(第30行)中编码，仪表板特性的值在<code class="fe lv lw lx ly b">Message._Dashboad</code>(第41行)中编码，日志记录的值在<code class="fe lv lw lx ly b">Message._Logging </code>(第48行)中编码。</p><p id="8d52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这看起来有点令人印象深刻，但这仍然是我们在<code class="fe lv lw lx ly b">Light</code>数据类型的<code class="fe lv lw lx ly b">Change</code> -DSL和<code class="fe lv lw lx ly b">UseCases</code>中的<code class="fe lv lw lx ly b">Request</code>和<code class="fe lv lw lx ly b">Response</code>类型中所看到的相同的想法:嵌套的注释枚举编码行为，甚至表达意图。</p><p id="40be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是<code class="fe lv lw lx ly b">Change</code>、<code class="fe lv lw lx ly b">Request</code>和<code class="fe lv lw lx ly b">Response</code>意味着与系统的较小组件交互，而<code class="fe lv lw lx ly b">Message</code>枚举类型意味着连接所有功能。因此，所有特征共享一个<code class="fe lv lw lx ly b">Message</code>类型。<code class="fe lv lw lx ly b">Message</code>类型编码app的完整词汇。</p><p id="82e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些示例消息值如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="7a9e" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">该应用程序</h1><p id="a9e7" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">现在我们需要将所有的特性组装到<code class="fe lv lw lx ly b">AppDomain</code> —简称:<code class="fe lv lw lx ly b">App</code>。</p><p id="6867" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">AppDomain</code>只是所有特性的列表，它唯一的任务是接收消息并将它们转发给每个特性。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="dfbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像特性一样，我们使用部分应用。</p><p id="6618" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在所有依赖项的后面加上一个<code class="fe lv lw lx ly b">output</code>。它通过调用具有所需依赖关系的创建函数来创建所有特征，并返回一个输入函数——<code class="fe lv lw lx ly b">AppDomain</code>对象。这个返回函数的主体只有一行，在这一行中，它遍历所有的特性，并用接收到的<code class="fe lv lw lx ly b">Message</code>调用它们。</p><p id="03bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，通过调用<code class="fe lv lw lx ly b">createAppDomain</code>，我们将创建一个全功能的系统，其中我们只有一个函数，每次取一个<code class="fe lv lw lx ly b">Message</code>值——最小的表面积。但是我们如何利用它呢？让我想想。</p><h1 id="b294" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">连接用户界面</h1><p id="b618" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">对于这个例子，我们将把<code class="fe lv lw lx ly b">AppDomain</code>连接到一个<code class="fe lv lw lx ly b">SwiftUI</code>接口。<br/>为此，我们创建了一个<code class="fe lv lw lx ly b">ViewState</code>类作为可观察对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5067" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它接受一个<code class="fe lv lw lx ly b">store</code>并订阅它的通知(第9行)。因此，<code class="fe lv lw lx ly b">store</code>的每一个变化都会导致<code class="fe lv lw lx ly b">process(appstate)</code>被调用，进而更新所有变量。</p><p id="77a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们已经具备了组装应用程序的所有条件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a2f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建一个存储，在<code class="fe lv lw lx ly b">appDomain</code>创建期间，它将作为一个依赖项传递给视图状态。<code class="fe lv lw lx ly b">createAppDomain</code>还带一个<code class="fe lv lw lx ly b">receivers</code>的数组，需要是或者有消息处理功能。我们用<code class="fe lv lw lx ly b">viewState</code> <code class="fe lv lw lx ly b">handle(msg:)</code>的方法来连接它。对于流经系统的每条消息，都将通知它。这可以用于处理不改变存储的消息——但是在我的例子中没有使用，因为那个方法是空的。</p><p id="2619" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个参数是<code class="fe lv lw lx ly b">roothandler</code>。它被定义为一个函数包装<code class="fe lv lw lx ly b">roothandler</code>。这就形成了一个循环:<code class="fe lv lw lx ly b">roothandler</code>成为起点，同时也是用于特性的输出。</p><p id="b4d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">ContentView</code>可能看起来像是使<code class="fe lv lw lx ly b">viewState</code>作为环境对象可用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4d44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，<code class="fe lv lw lx ly b">LightsCell</code>是一个更大的代码。我不是在这里向你灌输这一点，但是你会发现下面的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3b54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它调用<code class="fe lv lw lx ly b">roothandler</code>并显示一条消息来更改某些值。它可能是这样使用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="585f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同的值可以通过以下方式减少</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4eac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且由</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于完整的UI实现，请访问<a class="ae lu" href="https://gitlab.com/vikingosegundo/brighter-hue" rel="noopener ugc nofollow" target="_blank">我的存储库</a>。</p><h1 id="0808" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">UIKit呢？</h1><p id="8235" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">如果想配合UIKit使用Khipu，可以通过<code class="fe lv lw lx ly b">UINotifications</code>进行设置。一旦发生变化，立即发送通知。将当前状态添加为对象。实现一个基本视图控制器，该控制器知道如何从通知中提取状态，并调用一个方法来处理新状态并填充UI。如果需要，在子类中覆盖它。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="09ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经组装好了完整的应用程序，让我们来检查它的结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8bfb95638ca2daaf5c9dca919efea11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkOoeVnHhj_ZJDCBfl8Uig.png"/></div></div></figure><p id="446d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，它非常接近我之前提出的面向用户的应用程序的最小可能设计的内在设计。</p><p id="b59e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是相同的结构。从特性输出到<code class="fe lv lw lx ly b">appDomain</code>(<code class="fe lv lw lx ly b">roothandler</code>设置)只有一条捷径，允许特性间的通信，而不需要通过状态和UI路由。</p><p id="20c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Khipu确实是无样板代码的。</p><h1 id="bb6d" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">还有什么好说的？</h1><p id="086a" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">嗯，相当多。我可以谈以下几点:</p><ul class=""><li id="3bf6" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">测试和进行TDD的简单性，以及如何将<a class="ae lu" href="https://gitlab.com/vikingosegundo/everybody-loves-expresso/-/blob/main/ELPModelsSpecs/CoffeeTruckSpecs.swift" rel="noopener ugc nofollow" target="_blank">测试设计成类似于科学方法</a>。</li><li id="1d72" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们如何<a class="ae lu" href="https://gitlab.com/vikingosegundo/brighter-hue/-/blob/master/BrighterHue/Features/Lighting/createLightingFeature.swift#L54" rel="noopener ugc nofollow" target="_blank">写出不会对我们撒谎的文档，</a>因为它正在被编译器检查——如果代码改变，要求文档也要改变。</li><li id="e25f" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">这种部分应用程序、DSL接口模块和可变性的工具集在私有本地函数的范围内只需要少量——以及这如何构成一种新的范式——“声明性域范式”</li><li id="f082" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">这种范式是如何让像“<a class="ae lu" href="https://www.youtube.com/watch?v=fi1FsDW1QeY" rel="noopener ugc nofollow" target="_blank">基于能力的设计</a>”或“自我展示界面”这样的高级东西变得微不足道的。或者换出UI来执行“培养皿测试”——模拟几天用户交互的长时间运行的测试。</li></ul><p id="d87d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一些我在之前的文章中描述过，其他的目前只能在我的知识库中找到——但是会在我的书《声明式革命》中涉及</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="e349" class="oh nd it ly b gy oi oj l ok ol"><strong class="ly iu">Want to Connect?</strong></span><span id="b9ce" class="oh nd it ly b gy om oj l ok ol">I will discuss this and other aspects of declarative coding in my talk “Declarative Axiomatic and Provable Correct Systems in Swift” at the “<a class="ae lu" href="https://declarative.amsterdam/program" rel="noopener ugc nofollow" target="_blank">Declarative Amsterdam” conference</a> at the <a class="ae lu" href="http://www.cwi.nl" rel="noopener ugc nofollow" target="_blank">CWI</a> on Nov 8th, 2022. Please join!</span></pre></div></div>    
</body>
</html>