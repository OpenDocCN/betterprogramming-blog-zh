<html>
<head>
<title>How to Run TypeScript in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript运行TypeScript？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-run-typescript-in-javascript-1545e8a36518?source=collection_archive---------14-----------------------#2022-02-23">https://betterprogramming.pub/how-to-run-typescript-in-javascript-1545e8a36518?source=collection_archive---------14-----------------------#2022-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">听起来很有趣！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae0b2bbad00a3efa2d556158fde1412b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5IGlMfVl76ed_Ak"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuklanov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Avel Chuklanov </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="79a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很有意思的技术问题。虽然我们的常见需求并不要求我们在JavaScript中运行TypeScript，但在一些工程场景中可能是有用的，比如在Node.js环境中读取TypeScript配置文件等。所以请跟我来看看如何实现！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0454" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准备测试代码</h1><p id="d339" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里是<a class="ae ky" href="https://stackblitz.com/edit/node-nseqy7?file=test.ts" rel="noopener ugc nofollow" target="_blank">到我们准备运行的类型脚本文件的链接</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/44c095903bdd04b7a23ddabbd9c03b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3X7T_LLBmAfQ5wFX-uuDQ.png"/></div></div></figure><h1 id="9bac" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">第一部分</h1><p id="4522" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/ts-node" rel="noopener ugc nofollow" target="_blank"> ts-node </a>是一个可以直接在终端上执行TypeScript的工具。我们可以使用它提供的API来实现第一个版本。</p><p id="7ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">part1.js</code>的<a class="ae ky" href="https://stackblitz.com/edit/node-nseqy7?file=part1.js" rel="noopener ugc nofollow" target="_blank">代码链接</a>在这里，你可以打开它，直接在终端输入<code class="fe nf ng nh ni b">node part1.js</code>运行并查看其结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/e5ff2db935dd89022bf66632afb22d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCcy2c_kwE8tYhrrUVIgjA.png"/></div></div></figure><p id="5fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做得好，它工作并输出以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2a74c142c452267847e39793742540dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*OL03KisqP7bCbEcnim4hoQ.png"/></div></figure><p id="0312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在JavaScript中运行TypeScript的代码，得到在TypeScript中导出的对象，即任何用TypeScript编写的代码都可以在JavaScript中调用。</p><p id="9c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但实际上是<code class="fe nf ng nh ni b">ts-node</code>提供的名为<code class="fe nf ng nh ni b">register</code>的神奇API帮助我们完成了主要工作。那么它有什么魔力呢？</p><h1 id="c0b3" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">第二部分</h1><p id="4d04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以用调试来探究神奇的根源，如果你对调试不熟悉，可以按照<a class="ae ky" href="https://levelup.gitconnected.com/want-to-become-a-senior-frontend-developer-you-must-master-debugging-f577ee569687" rel="noopener ugc nofollow" target="_blank">的链接</a>去看我之前贴的调试教程系列，里面总结了很多有用的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c0241bb5ad4358fb72127e5bd3831cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*glNvtDojiN17BBr9VJOfSg.gif"/></div></div></figure><p id="20ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我在<code class="fe nf ng nh ni b">test.ts</code>文件中放了一个断点，这样你就可以看到它是如何在调用栈中被加载和执行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/33edb27210c3a35d18bcfc152424e197.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*G43IB0rT7qoTVh-CoS2nmg.png"/></div></figure><p id="bed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图是完整的调用栈。我们点击进入下图中函数的调用，可以看到<code class="fe nf ng nh ni b">Module._extensions[extension]</code>被注册为<code class="fe nf ng nh ni b">.ts</code>文件扩展名的调用函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b23414e17a62c48ba49675cc33758a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mnf76MU2pCnEHT02nDAdA.png"/></div></div></figure><p id="254e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以看到非常关键的功能<code class="fe nf ng nh ni b">registerExtension</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/cbfade3499f9f9835932d008f63741ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2JqrcYARpVNPb68LEoJ-Q.png"/></div></div></figure><p id="9593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nf ng nh ni b">registerExtension</code>可以称之为魔法的起源，为什么这么说？请跟我来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2d360c98e670c9d5652c75fe71b9d4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r5SbKHJUK3WfqRA-uP0ACg.gif"/></div></div></figure><p id="2207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次，我在<code class="fe nf ng nh ni b">register</code>函数上设置了断点。通过调试可以看到，它以<code class="fe nf ng nh ni b">.ts</code>为参数调用<code class="fe nf ng nh ni b">registerExtension</code>，在<code class="fe nf ng nh ni b">registerExtension</code>内部可以看到表达式<code class="fe nf ng nh ni b">require.extensions[ext]</code>，其效果等同于<code class="fe nf ng nh ni b">Module._extensions[extension]</code>。联系以上，我们可以得出结论，当传入文件扩展名为<code class="fe nf ng nh ni b">.ts</code>时，实际上相当于调用了这里的绑定函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0773e478727b5f86ac51dfda5afde4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ModpqbrmMM78u5fXzNGWmw.png"/></div></div></figure><p id="1338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以理解这个函数的逻辑就能揭示其中的神奇。通过链接上下文，我们可以编写一个简单的模仿版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/873ee761e338264789d43f08c3eb9c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OafoHQQ7YEkO0-0CkV_-nA.png"/></div></div></figure><p id="57dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackblitz.com/edit/node-nseqy7?file=part2.js" rel="noopener ugc nofollow" target="_blank">代码链接</a> <code class="fe nf ng nh ni b">part2.js</code>在这里，你可以打开它，直接在终端输入<code class="fe nf ng nh ni b">node part2.js</code>运行并查看其结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/aee1ab26c565feb8cb5da496d629899a.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*2Bn8Jg_iN9QuqCRpTbQY-w.png"/></div></div></figure><p id="5080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到它像预期的那样工作。在真实的生产环境中，我们可能更喜欢使用第1部分中的代码，因为它考虑了更多的边界条件，但这并不妨碍我们理解底层的原理，所以让我详细解释一下上面的代码。</p><p id="342a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我们了解到，在调用Node.js提供的原生API <code class="fe nf ng nh ni b">require</code>时，会依次调用<code class="fe nf ng nh ni b">Module.require</code>、<code class="fe nf ng nh ni b">Module._load</code>、<code class="fe nf ng nh ni b">Module.load</code>等方法。在<code class="fe nf ng nh ni b">Module.load</code>中，会根据文件的扩展名调用相应的方法，所以我们可以直接在<code class="fe nf ng nh ni b">require.extensions['.ts']</code>上绑定一个调用方法，这样当需要一个TS文件的时候，就会进入我们的方法。</p><p id="796a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来就是按照<code class="fe nf ng nh ni b">registerExtension</code>的逻辑。首先读取TS的文件内容并使用<code class="fe nf ng nh ni b">typescript</code>模块提供的<code class="fe nf ng nh ni b"><a class="ae ky" href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function" rel="noopener ugc nofollow" target="_blank">transpileModule</a></code>方法将TS代码编译成js代码，得到<code class="fe nf ng nh ni b">outputText</code>的JS代码串，最后使用Node.js提供的native API <code class="fe nf ng nh ni b">Module.prototype._compile</code>编译执行JS代码串。</p><p id="7405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，太酷了，不是吗？我们用JavaScript实现了运行TypeScript，在某些特定场景下非常有用，希望有帮助。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="fe56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。我是Zachary，我将继续输出与web开发相关的故事，如果你喜欢这样的故事，别忘了关注我。</p></div></div>    
</body>
</html>