<html>
<head>
<title>Clock-In/Out System Part 2: Basic Back End — AuthModule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第2部分:基本后端—认证模块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=collection_archive---------0-----------------------#2018-11-25">https://betterprogramming.pub/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=collection_archive---------0-----------------------#2018-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c73" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27028d592125269574905771e8218205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="d756" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><p id="35d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在第一部分中，(<a class="ae lv" href="https://carloscaballero.io/part-1-clock-in-out-system-diagram" rel="noopener ugc nofollow" target="_blank">打卡上班/下班系统第1部分:图表</a>)我描述了我们的打卡上班/下班系统的不同组件。在这篇文章中，我将使用<a class="ae lv" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>来描述基本的后端。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9324" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">了解目录结构</h1><p id="60b0" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">第一步是理解目录结构。要使用NestJS启动项目，请执行以下操作:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="cfdd" class="nk mj it ng b gy nl nm l nn no">$ git clone https://github.com/nestjs/typescript-starter.git server $ cd server $ npm install $ npm run start</span></pre><p id="e8ce" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">之后，我们需要在<code class="fe np nq nr ng b">src</code>目录中创建我们自己的模块结构，如图1所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/e9ee339cbf81bf6cc6e744f097bcb407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GqK5UyoKrtcTMre4.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">图一。</p></figure><p id="5e88" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此时，服务器正在端口<code class="fe np nq nr ng b">3000</code>上运行，使用动词<code class="fe np nq nr ng b">GET</code>的端点<code class="fe np nq nr ng b">http://localhost:3000/</code>正在工作。如果您导航到这个地址，您会得到如图2所示的<code class="fe np nq nr ng b">Hello World</code>消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a8784ee4d5a00d38da8f75ea53cc5f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*k2aQ_wzJv4RLrcoP.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">图二。</p></figure><h1 id="87a2" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">后端模块列表</h1><p id="85f6" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">下一步是定义我们后端所需的模块:</p><p id="eb9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">database module</strong>:<strong class="ks iu"/>该模块用于共享不同模块之间的数据库连接。</p><p id="d8b1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> AuthModule </strong> : <strong class="ks iu"> </strong>该模块用于在用户上下班打卡时在数据库中注册。服务<code class="fe np nq nr ng b">AuthService</code> <strong class="ks iu"> </strong>将负责在用户入住和退房时保存在数据库中。此模块不可访问，因为它是外部的。没有使用API进行通信的控制器。</p><p id="d002" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">用户模块</strong>:该模块用于管理用户信息。服务<strong class="ks iu"> </strong> <code class="fe np nq nr ng b">UserService</code> <strong class="ks iu"> </strong>提供了两个重要的方法:<code class="fe np nq nr ng b">getUsersWithoutKey</code> <strong class="ks iu"> </strong>和<strong class="ks iu"> </strong> <code class="fe np nq nr ng b">addUser</code>。这些方法用于了解用户是否拥有有效的id卡，以及向系统添加用户。</p><p id="88b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> AppModule </strong>:这个模块是主模块，会和前端进行通信。在此模块中，其他模块将被导入，因此这些其他模块的服务可以在此模块中使用。该模块中的主控制器具有以下端点:</p><ul class=""><li id="cd06" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu"> POST: /in: </strong>这个端点从<code class="fe np nq nr ng b">AuthService</code>调用方法<code class="fe np nq nr ng b">authIn</code>。</li><li id="c33b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu"> POST: /out: </strong>该端点从<code class="fe np nq nr ng b">AuthService</code>调用方法<code class="fe np nq nr ng b">authOut</code>。</li><li id="3158" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><strong class="ks iu"> GET: /users: </strong>该端点从<code class="fe np nq nr ng b">UsersService</code>调用方法<code class="fe np nq nr ng b">getUsersMustBeWorkingNow</code> <strong class="ks iu"> </strong>，并将信息与服务器的<code class="fe np nq nr ng b">timestamp</code> <strong class="ks iu"> </strong>结合。</li></ul><h1 id="7ba8" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">数据库模块</h1><p id="1634" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">模块数据库用于共享数据库连接。我们使用<a class="ae lv" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>作为ORM，它完美地集成在NestJS中。我们对<code class="fe np nq nr ng b">database.module</code>的定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oh"><img src="../Images/f1b106e902a401a1e9830707dcdacd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nl8aQN58SwaIxHQ3IQJ_-g.png"/></div></div></figure><p id="ac44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在提供者中，我们使用工厂来定义我们的<code class="fe np nq nr ng b">DbConnectionToken</code>。在我们的例子中，我们使用Postgres作为数据库。最有趣的部分是实体的定义，这是在TypeORM中自动检测到的。尽管NestJS包含一个特定的模块来管理TypeORM连接，但我更喜欢使用TypeORM库中的方法<code class="fe np nq nr ng b">createConnection</code>直接配置提供者。</p><p id="6c3c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此时，我们必须在节点中安装以下库:</p><p id="bc63" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b">npm i typeORM pg</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ca"><img src="../Images/70b3f3a2fb7d14dfa8ecd0c58455530c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nncmGY2WJ3sPeXaXrjGJw.png"/></div></div></figure><p id="1380" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步是在您的机器上安装一个数据库Postgres。但是我认为使用Docker是一个更好的选择，因为你可以得到一个干净的开发环境，在你部署的时候也是一样的。</p><p id="4b2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用端口5531的容器<code class="fe np nq nr ng b">docker-compose</code>如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oi"><img src="../Images/c4937284d87c3d1c82e56ea6b200e086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVFM0iV6dwkcSOcIZX2Ksg.png"/></div></div></figure><p id="c8c0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要启动系统数据库，只需运行命令<code class="fe np nq nr ng b">docker-compose up</code>。其他模块将使用此模块连接到数据库。</p><h1 id="6d28" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">授权模块</h1><p id="4c27" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我们实现的第二个模块是<code class="fe np nq nr ng b">AuthModule</code>。该模块的结构如图3所示。您可以注意到，有几个目录，如常量、d to和实体，它们用于将一个模块独立地组织为一个服务。想法是将模块构建为服务，因为任何一天你都可以构建微服务。然而，在这个项目中，所有模块之间都有关系，因为这个项目的架构非常复杂。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a75e1c25de5f6961ae4a6d58f94a7d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*xry_GvhDz7kzZKtg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">图3。</p></figure><p id="c514" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<code class="fe np nq nr ng b"><strong class="ks iu">auth.module</strong></code>的定义中你可以看到导入<code class="fe np nq nr ng b">DatabaseModule</code>和<code class="fe np nq nr ng b">UsersModule</code>。<code class="fe np nq nr ng b">DatabaseModule</code>用于连接数据库(如前所示),<code class="fe np nq nr ng b">UsersModule</code>用于检查<code class="fe np nq nr ng b">AuthModule</code>中的用户信息。服务<code class="fe np nq nr ng b">AuthService</code>被导出，因为未来的AppController将使用该服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ok"><img src="../Images/6fc8a0edcfbcde2631053869a9e2991f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjZy1roqvEdEfhrMZh4r6Q.png"/></div></div></figure><h1 id="cc8c" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">实体</h1><p id="c0ec" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">下一步是知道信息保存在数据库中。这是使用文件<code class="fe np nq nr ng b">user.entity</code>定义的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ol"><img src="../Images/a039e6c0bf4534d815c28506637e6748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAX9R7SUV8OmNyFATyozRg.png"/></div></div></figure><p id="5150" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类别<code class="fe np nq nr ng b">AuthEntity</code>中的字段如下:</p><p id="5b69" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那是UID的表格。该字段由TypeORM自动生成。</p><p id="c3fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b"><strong class="ks iu">reader</strong></code>:发送用户密钥的设备。在这个项目中，有两个阅读器:<code class="fe np nq nr ng b">Input</code>和<code class="fe np nq nr ng b">Output</code>。</p><p id="2386" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b"><strong class="ks iu">user</strong></code>:这就是<code class="fe np nq nr ng b">Auth</code>和<code class="fe np nq nr ng b">User</code>的关系。在TypeORM中，您可以使用decorator <code class="fe np nq nr ng b">@ManyToOne</code>为每个用户定义几个身份验证条目。该关系使用用户的字段键。在<code class="fe np nq nr ng b">User</code>实体中，需要用逆向装饰器(<code class="fe np nq nr ng b">@OneToMany</code>)定义字段键。在后面的文章中，我们将描述这个模块。</p><p id="f303" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b"><strong class="ks iu">timestamp</strong></code>:根据Unix时间戳，这是输入或输出完成的时刻。这非常重要，因为我们需要知道用户进出系统的准确时间。</p><p id="0a6f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，提供者文件导出两个存储库，以便快速访问数据库。使用的图案是<code class="fe np nq nr ng b">Repository</code>。您可以在任何服务或控制器中使用这些提供者的令牌(<code class="fe np nq nr ng b">AUTH_REPOSITORY_TOKEN</code>和<code class="fe np nq nr ng b">USER_REPOSITORY_TOKEN</code>)来注入它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi om"><img src="../Images/3d9ac2c16a53b85861750a39c14188a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1eQp2vAtQXDIqKBYAF6mA.png"/></div></div></figure><h1 id="f2eb" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">常数和dto</h1><p id="4239" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">现在我将展示我的代码中最简单但非常重要的部分:<code class="fe np nq nr ng b">constant</code>文件和<code class="fe np nq nr ng b">DTO</code>。当你想写干净的代码时,<code class="fe np nq nr ng b">constant</code>文件非常有用——在你的代码中不使用字符串或数字是个好习惯。<code class="fe np nq nr ng b">DTO</code>定义了客户端和服务器端之间交换的信息。‌</p><p id="6275" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b">auth.constant</code>文件只有对Arduino系统的STATUS_CODE_RESPONSE，Arduino系统将<em class="on"> 0 </em>理解为KO，将<em class="on"> 2 </em>理解为OK，还有几种力矩格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oo"><img src="../Images/019b65a4b6fe36356f15f2d59a50e0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CppqShOBJPuZe3FUkykO-w.png"/></div></div></figure><p id="1436" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面的<code class="fe np nq nr ng b">DTO</code>非常简单，因为它们只显示了一个输入(<code class="fe np nq nr ng b">AuthDto</code>)和一个输出(<code class="fe np nq nr ng b">AuthResponseDto</code>)的接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi op"><img src="../Images/633e7eac9c979f2d21f8e6e2954cd655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GyY0PREofo-ZIvs_8i6lA.png"/></div></div></figure><h1 id="c736" class="mi mj it bd mk ml oc mn mo mp od mr ms jz oe ka mu kc of kd mw kf og kg my mz bi translated">服务</h1><p id="b506" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated"><code class="fe np nq nr ng b">AuthService</code>应该有两个重要的方法，<code class="fe np nq nr ng b">authI<strong class="ks iu">n</strong></code> <strong class="ks iu"> </strong>和<strong class="ks iu"> </strong> <code class="fe np nq nr ng b">authOut</code>。</p><p id="a545" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b">authinIn</code>当用户在系统上打卡时，接收来自Arduino的信号并保存信息。该服务以一条欢迎消息作为响应。</p><p id="b2d9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b">authOut</code>当用户打卡离开系统时，接收来自Arduino的信号并保存信息。该服务以再见消息作为响应。</p><p id="de2f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些方法的代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oq"><img src="../Images/6525f43696dec8a86238afa59c409d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMRFH5Hm3YcC9Vre6nFgPA.png"/></div></div></figure><p id="57fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个类中，我注入了两个存储库(<code class="fe np nq nr ng b">authRepository</code>和<code class="fe np nq nr ng b">userRepository</code>)，它们用于与数据库通信。代码是干净的，因为我已经使用了简单的async/await和private方法(<code class="fe np nq nr ng b">saveTicketing</code> <strong class="ks iu">、</strong> <code class="fe np nq nr ng b">welcomeTeacher</code> <strong class="ks iu"> </strong>和<code class="fe np nq nr ng b">byeTeacher</code>)，所以方法<code class="fe np nq nr ng b">authIn</code>和<code class="fe np nq nr ng b">authOut</code> <strong class="ks iu"> </strong>在将来测试起来会很简单。两种方法的响应都是一个<code class="fe np nq nr ng b">AuthResponseDto</code>。</p><p id="876b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe np nq nr ng b">saveTicketing</code> <strong class="ks iu"> </strong>的私法也很简单。第一步是获取与键相关联的用户(<code class="fe np nq nr ng b">auth.key</code>来自Arduino)。之后，您可以保存身份验证信息:</p><ul class=""><li id="b489" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe np nq nr ng b">auth</code>中的<code class="fe np nq nr ng b">key</code>和<code class="fe np nq nr ng b">reader</code>。</li><li id="fb09" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe np nq nr ng b">user</code>来自数据库(<code class="fe np nq nr ng b">UserEntity</code>)。</li><li id="08c1" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">从库<code class="fe np nq nr ng b">momentJS</code>中计算出的<code class="fe np nq nr ng b">timestamp</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oi"><img src="../Images/d40f5c43f2d5c8018e1d6fbe9b25cf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6o3vC5cGHe8sFnJcUvFt8g.png"/></div></div></figure><p id="df5c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，在Arduino屏幕上向用户显示消息的两种方法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi or"><img src="../Images/66eda127b7d2fc2da1e9751374e95d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcKTE_XescVuTx0A9c7gJA.png"/></div></div></figure><p id="6ba6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里是<code class="fe np nq nr ng b">AuthService</code>的完整代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oq"><img src="../Images/0e656aedd6c719ba92f7926395a026e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9I7Y-LPm0fMLqBDNPo7kdw.png"/></div></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="6bcb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">‌In这一块，我已经解释了我的<code class="fe np nq nr ng b">AuthModule</code>，它非常简单，因为我在编码中使用了干净的代码。该模块用于保存打卡/下班信息。</p><p id="7891" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本系列的后续文章中，我将解释<code class="fe np nq nr ng b">UsersModule</code>和<code class="fe np nq nr ng b">AppModule</code>。</p><p id="c167" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GitHub项目是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/clock-in-out</a>。<br/>GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part2-basic-backend-auth" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 2-basic-back end-auth</a>。</p></div></div>    
</body>
</html>