<html>
<head>
<title>If Kotlin Runs on the JVM Just Like Java, Then How Does It Provide So Many Great Features?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果Kotlin像Java一样在JVM上运行，那么它是如何提供这么多优秀特性的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-runs-on-the-jvm-just-like-java-how-does-it-provide-so-many-great-features-b27ed269015b?source=collection_archive---------1-----------------------#2022-09-27">https://betterprogramming.pub/kotlin-runs-on-the-jvm-just-like-java-how-does-it-provide-so-many-great-features-b27ed269015b?source=collection_archive---------1-----------------------#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1490" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Kotlin生成的字节码以及它如何在JVM上运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6edda4092334cbe0bdb78ce585186604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLhpU3CI1koYvToQ0oe2NQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">支撑一棵树的手臂</p></figure><p id="35e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">着眼于基本面；当我们提到一种<strong class="la iu"/>JVM语言<strong class="la iu"/>时，我们到底指的是什么？Kotlin语言与此有什么关系？不是只有Java可以在JVM上运行吗？在这篇文章中，我想谈谈JVM是什么以及它是如何协同工作的。特别是，我将演示如何在JVM上执行除Java之外的其他语言。为此，我们将学习什么是JVM字节码，以及它如何使JVM语言成为可能。</p><p id="a60f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin编程语言提供了许多Java中没有的特性，比如适当的<em class="lu">函数类型</em>、<em class="lu">扩展函数、</em>或者通过<em class="lu">对象</em>声明的内置单例支持。Kotlin如何提供比原本打算在JVM上运行的语言更多的特性？我深入了解了Kotlin的工作原理以及JVM语言的真正含义。我们将看看Kotlin的字节码生成。如果你以前也想过这些事情，这篇文章应该会给黑暗带来一些光明🙂</p><h1 id="ceef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Java虚拟机</h1><p id="4d5c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">大多数人以前都听过Java虚拟机(JVM)这个术语。但实际上是什么呢？简单定义如下:<em class="lu">Java虚拟机是计算机用来运行Java字节码的。</em> <br/>当然，关于这个复杂的工具还有很多要学的，在<a class="ae ms" href="https://docs.oracle.com/javase/specs/jvms/se19/html/index.html" rel="noopener ugc nofollow" target="_blank"> Oracle的规范</a>中有更详细的描述。您可能已经知道，JVM是运行在各种操作系统上的抽象虚拟计算机。事实上，JVM是Java“平台无关”的原因，因为它充当了执行代码和操作系统之间的抽象。就像任何真正的计算机一样，JVM提供了一组定义好的指令，这些指令可以被程序使用，并在随后的过程中由JVM自己翻译成特定于机器的指令。</p><p id="9a90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如在<a class="ae ms" href="https://docs.oracle.com/javase/specs/jvms/se19/html/index.html" rel="noopener ugc nofollow" target="_blank"> JVM规范</a>中所描述的，Java虚拟机对编程语言Java一无所知。然而，它定义了二进制格式<code class="fe mt mu mv mw b">class</code>，这是一个包含要执行的机器指令(=字节码)的文件(除了一些更多的信息)。这是一个极其相关的问题，具有以下含义:</p><ol class=""><li id="31c0" class="mx my it la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">JVM不仅仅致力于将Java作为一种编程语言来运行。</li><li id="4650" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">您可以自由选择创建JVM程序的技术，只要您提供合适的a <code class="fe mt mu mv mw b">class</code>文件格式并遵守其非常严格的限制。</li><li id="36a0" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">不管它的来源是什么(读:编程语言)，任何Java字节码都可以与JVM上的其他Java字节码互操作。</li></ol><h1 id="ede3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建类文件</h1><p id="ff0b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">从人类可读的源代码创建类文件的过程就是编译器的工作。一个例子是JDK附带的Oracle Java编译器<code class="fe mt mu mv mw b">javac</code>，它将<code class="fe mt mu mv mw b">.java</code>文件编译成<code class="fe mt mu mv mw b">.class</code>文件。<br/>除了Java，在过去几年中出现了许多其他的<a class="ae ms" href="https://en.wikipedia.org/wiki/List_of_JVM_languages" rel="noopener ugc nofollow" target="_blank"> JVM语言</a>，它们都试图为开发人员提供一种替代的抽象来为JVM创建程序。其中一种语言是科特林语。</p><h1 id="46e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kotlin字节码生成——什么是Kotlin？</h1><p id="0de5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">正如官方常见问题中所说，“Kotlin产生Java兼容的字节码”。这意味着Kotlin编译器能够将所有精彩的Kotlin特性转化为JVM兼容的指令。幸运的是，我们可以使用IntelliJ IDEA提供的工具来观察这个复杂的过程。这些工具让我们检查由Kotlin编译器生成的字节码。现在，如果你不习惯的话，字节码不是特别易读。作为一种简化，IDEA还允许我们将字节码转换回Java指令，这将在下一节中讨论。</p><p id="b163" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看一些有趣的Kotlin特性，并了解它们转换成什么字节码！</p><h1 id="425e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">顶级功能</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="984b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在. kt文件中定义的这个简单的顶级函数可以用IntelliJ进行研究:<br/> <strong class="la iu">工具→ Kotlin →显示Kotlin字节码</strong>将在ide中打开一个新窗口，提供编译器为当前<code class="fe mt mu mv mw b">.kt</code>文件创建的字节码的实时预览。结果是下面的字节码。</p><pre class="kj kk kl km gt nn mw no np aw nq bi"><span id="b014" class="nr lw it mw b gy ns nt l nu nv">public final class FileKt {</span><span id="0eb6" class="nr lw it mw b gy nw nt l nu nv">// access flags 0x19<br/>  public final static foobar()V<br/>   L0<br/>    LINENUMBER 1 L0<br/>    RETURN<br/>   L1<br/>    MAXSTACK = 0<br/>    MAXLOCALS = 0</span><span id="75b1" class="nr lw it mw b gy nw nt l nu nv"><a class="ae ms" href="http://twitter.com/Lkotlin/Metadata" rel="noopener ugc nofollow" target="_blank">@Lkotlin/Metadata</a>;(...)<br/>  // compiled from: File.kt<br/>}</span></pre><p id="a40c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，没有多少人会喜欢阅读这种语法，这就是为什么我们也可以选择“反编译”这个选项。之后，IDEA展示了上面的字节码的Java表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="057d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，并且可能已经知道的，一个Kotlin顶级类被编译成一个带有静态函数的最终Java类。这种结构让我们想起了扩展函数意味着替换的概念:实用程序类，即最终类中静态函数的集合。在Kotlin中，你可以在任何文件的顶层声明这些东西。</p><p id="1270" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个更难的:</p><h1 id="9b2f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">类和扩展函数</strong></h1><p id="dd51" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在下一个例子中，我们看一个包含类型<code class="fe mt mu mv mw b">Int</code>的单个属性的类。除此之外，该文件还在这个新类上定义了一个扩展函数，它是在顶层定义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="af73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在查看相应的字节码时，我们在这里感兴趣的是什么？首先，我们应该看看这个类被编译成什么样子，因为我们使用了一个<em class="lu">主构造函数</em>和一个<em class="lu"> val </em>关键字。这两种东西在Java中都不存在，所以了解相应的Java代码应该很有趣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ab1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，这里没有真正的惊喜。该属性成为一个<code class="fe mt mu mv mw b">final</code>成员，并在该类的单个构造函数中赋值。在Kotlin中声明要简单得多，不是吗？</p><p id="166c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，扩展函数会发生什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9e20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">扩展函数本身被编译成一个静态函数，其<em class="lu"> receiver对象、</em> MyClass <em class="lu">、</em>成为该函数的一个参数。<br/>我们在示例中可以观察到的另一件事是使用了一个名为<code class="fe mt mu mv mw b">Intrinsics</code>的类。这个是Kotlin标准库的一部分，作为一个工具集来检查参数是否不是<code class="fe mt mu mv mw b">null</code>。让我们快速做一个实验，看看如果我们将原始扩展函数的参数类型改为<code class="fe mt mu mv mw b">String?</code>，然后以空安全的方式访问<code class="fe mt mu mv mw b">length</code>，会发生什么。这里我们跳过Kotlin代码，直接跳到Java表示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cecb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查<code class="fe mt mu mv mw b">value</code>已经没有必要了，因为我们已经告诉编译器<code class="fe mt mu mv mw b">null</code>是一个可以接受的指向。由于我们添加了可空性检查并应用了默认值，返回表达式变得更加复杂。太棒了。</p><p id="377d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个也是最后一个例子有点复杂。这是Kotlin和Java代码之间最大的区别:</p><h1 id="eea5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">科特林山脉</strong></h1><p id="346a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">下面的代码定义了一个函数，该函数包含一个简单的循环，用于将几个整数打印到控制台。然而，这里有一些有趣的事情:我们使用一个范围，或者更具体地说，级数，来生成我们想要迭代的数字序列。此外，该声明中还包含两个中缀函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0c04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在字节码中看这个应该更有趣。让我们看看结果如何。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3260" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，这里有很多代码。这是什么？尽管给定的Java代码非常容易阅读，但它看起来不像是循环遍历几个数字的常见方式。编译器解析级数的方式比简单的<code class="fe mt mu mv mw b">for</code>循环要复杂一些。这个例子表明，与您用Kotlin编写的原始简洁代码相比，最终的字节码可能非常庞大。有趣的学习，如果你问我！</p><h1 id="fa3a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="35ee" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">大多数时候你并不真正关心Kotlin编译器在幕后产生了什么。尽管如此，观察一个编译器做什么真的很有趣，也很有帮助。这样做也回答了我最初提出的Kotlin和JVM语言到底是什么的问题。最终，这些只是产生字节码的抽象。类文件，就像Java那样。编程语言本身可以是任意的，只要编译器产生可行的字节码。</p><p id="1e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，我们还看到，在某些情况下，编译后的Java代码比预期的更加冗长。这会影响性能吗？是的，的确，它确实有轻微的影响。如果你对更多考虑性能的“Kotlin → Java字节码”例子感兴趣，可以看看Dmitry Jemerov的这个<a class="ae ms" href="https://de.slideshare.net/intelliyole/kotlin-bytecode-generation-and-runtime-performance" rel="noopener ugc nofollow" target="_blank">演示</a>。公平地说，这是一个老资源，随着Kotlin编译器的每一个新版本，事情都会发生变化，因为最终，它只需要将Kotlin文件翻译成JVM理解的字节码。每一个新的JVM版本都是Kotlin编译器改进的潜在机会。</p></div></div>    
</body>
</html>