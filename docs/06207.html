<html>
<head>
<title>Iterate Faster With Automatic Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过自动代码审查加快迭代速度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/iterate-faster-with-automatic-code-review-2138731b55a6?source=collection_archive---------10-----------------------#2020-09-09">https://betterprogramming.pub/iterate-faster-with-automatic-code-review-2138731b55a6?source=collection_archive---------10-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="decb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让开发人员不必审查琐碎的拉取请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c0fa3a611dad168e120dd18add6ed25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfIW806-TgLzo1SjwpKK_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/tianhaoz95/approveman" rel="noopener ugc nofollow" target="_blank">通过GitHub批准人</a></p></figure><p id="6075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件开发中，代码评审对于维护代码质量非常重要。</p><p id="9b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助项目维护人员实现代码评审策略，GitHub提供了一种方便的方法，<a class="ae ky" href="https://docs.github.com/en/github/administering-a-repository/about-protected-branches" rel="noopener ugc nofollow" target="_blank"> <em class="lv">保护分支</em> </a> <em class="lv">，</em>在合并之前强制执行拉请求以满足某些评审策略。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7cd7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">实施代码审查策略的负面影响</h1><p id="5e15" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然受保护的分支听起来像是一个很好的计划，但在实践中，它们可能很烦人，因为不是所有的拉请求都需要人的注意。</p><p id="fbdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我想在markdown文件中更新我的联系信息，就没有必要让另一个开发人员来审核我的更改。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9ec4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">潜在的变通办法</h1><p id="b238" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有几个解决方法:</p><ul class=""><li id="7d02" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">将一个monorepo项目拆分为具有不同评审策略的子项目</li><li id="536f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">为不太重要的变更建立分支</li></ul><p id="d0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种我都试过。</p><p id="6715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法的问题是，存储库的数量增长很快，开发人员很快就会讨厌在存储库之间切换。此外，很难记录每个存储库的用途。</p><p id="2ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第二个选项，分支之间的同步需要大量的工作。</p><p id="51e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这两者来说，将不太严格的区域中的代码迁移到评审策略下的位置也是一项重要的工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8470" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建更好的解决方案</h1><p id="799f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在处理了一段时间的混乱之后，我决定是时候用一种系统的方法来解决这个问题了:</p><p id="88f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一个自动化的代码审查应用程序，让存储库所有者定义哪些拉请求是安全的/琐碎的，并自动批准它们，让受保护的分支方法处理其余的，那就太好了。</p><p id="4bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，应用程序可以检测到拉取请求只修改为我自己指定的区域下的文件——这可能是以我的GitHub用户名命名的目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7fc89e62abbc7783e175a9986882a3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyXJwN39oDM-jt36ZklGCg.png"/></div></div></figure><p id="156b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以自动批准，为其他开发人员节省一些时间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/793934f028320f7095ad2e5619cf269f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14gT74lkH-EWdNhjWX3ynw.png"/></div></div></figure><p id="1ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得不错！我们如何才能做到这一点？</p><p id="a60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于该应用程序需要通知拉请求活动，并需要与GitHub交互，这符合<a class="ae ky" href="https://developer.github.com/apps/building-github-apps/" rel="noopener ugc nofollow" target="_blank"> GitHub应用程序</a>的定义，我选择在GitHub应用程序基础架构的基础上构建<a class="ae ky" href="https://probot.github.io/" rel="noopener ugc nofollow" target="_blank"> Probot </a>(一个抽象GitHub应用程序API底层细节的框架)。</p><p id="c5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户在存储库的根目录下定义一个配置文件，该文件描述了确定拉请求是否安全/普通的规则。</p><p id="33f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次打开一个pull请求，应用程序都会收到一个通知，并从存储库中读取上面提到的配置文件。</p><p id="e539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果规则适用，应用程序应该留下批准审查。</p><h2 id="28a9" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">设计规则</h2><p id="35d0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了帮助开发人员同时工作，配置的第一稿支持插入用户名。</p><p id="0244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始听起来可能有点抽象，但是让我们用一个例子来解释一下。</p><p id="e439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，用户可以定义以下配置，以允许针对以用户的GitHub用户名命名的目录中的文件的拉请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="86ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果还是有点不清楚，我们在例子中插入一个真实的用户名。</p><p id="b0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我的GitHub账号<code class="fe oe of og oh b">tianhaoz95</code>为例，如果我打开一个pull请求来修改<code class="fe oe of og oh b">plaground/tianhaoz95/README.md</code>，上面的配置会自动被批准。</p><h2 id="83c8" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">实现应用程序</h2><p id="b273" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于完整的实现可能会变得复杂，所以我将在本文中只展示一个过于简化的版本。</p><p id="f929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需完整的源代码，请参阅资源库:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/tianhaoz95/approveman" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">天昊95/批准人</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">ApproveMan是一个GitHub应用程序，帮助批准安全更改的拉请求。为了维护存储库的健康…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="a745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。订阅拉取请求活动</strong></p><p id="2ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Probot是一个方便的框架，它将传入的webhook事件映射到处理函数，因此我们不需要做管道工作。</p><p id="8eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码将指示Probot订阅所有拉请求活动，并在检测到活动时运行处理函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ee6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果拉式请求符合标准，函数<code class="fe oe of og oh b">maybeApproveChange</code>发布一个批准审查。在步骤5中有关于这个函数的更多细节。</p><p id="b10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。从pull-request事件中获取已修改文件的列表</strong></p><p id="2465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub提供了一个方便的API来从pull请求中获取文件更改列表。我们可以使用以下代码访问API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="cf3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。从存储库中读取配置</strong></p><p id="24e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Probot的抽象，阅读标准GitHub配置文件(<code class="fe oe of og oh b">.github</code>目录中的文件)很容易。我们可以简单地调用Probot <code class="fe oe of og oh b">context</code>上的<code class="fe oe of og oh b">config</code>方法来获得解析后的<code class="fe oe of og oh b">yml</code>配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码读取<code class="fe oe of og oh b">.github/approveman.yml</code>中的内容，解析<code class="fe oe of og oh b">yaml</code>文件，并将其转换为JavaScript对象。</p><p id="c161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。将修改文件列表与配置进行比较</strong></p><p id="f91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保拉取请求是安全的，拉取请求中的所有文件都需要遵循至少一个规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong></p><ul class=""><li id="c918" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">第一个函数检查单个文件是否匹配单个规则</li><li id="42bb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">第二个函数检查单个文件是否匹配至少一个规则</li><li id="8672" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">第三个函数检查所有文件是否匹配至少一个规则</li></ul><p id="5d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。也许批准拉动请求</strong></p><p id="5d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证拉取请求是否安全后，下一步是批准它是否安全:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="acb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong></p><ul class=""><li id="12d4" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">第一个函数向GitHub API发送一个请求，在pull请求上添加一个批准</li><li id="1266" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">第二个函数是一个高级包装器，它使用了我们在步骤1-4中构建的所有东西。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bff9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">外卖食品</h1><p id="c44f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你也对困难的代码审查政策有疑问，这里有一个应用程序适合你！</p><p id="0c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在开源社区中遇到过一些开发人员，他们抱怨硬编码的代码审查政策降低了速度，或者为第一次贡献者设置了障碍。</p><p id="b5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你问了同样的问题，我开发的应用程序<a class="ae ky" href="https://github.com/marketplace/approveman" rel="noopener ugc nofollow" target="_blank"> ApproveMan </a>，可以帮助你提高开发效率。</p><p id="cbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序可从以下网址获得:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/marketplace/approveman" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">ApproveMan - GitHub市场</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">为了将代码签入受保护的分支，通常需要进行审查。然而，为了允许早期阶段的快速迭代…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><h2 id="754b" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">如果你有更多创造性的方法来配置自动代码审查，欢迎投稿！</h2><p id="657f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">用GitHub用户名定义安全拉取请求是我想到的第一个模式——但肯定不是唯一有用的模式。</p><p id="29aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何创造性的配置规则，ApproveMan是开源的，你的好主意是一个拉请求。</p><h2 id="a63b" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">如果您有关于如何简化开源开发的想法，可以把这看作是构建GitHub集成的教程</h2><p id="d770" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">代码审查不是我们可以改进工作流程的唯一地方。</p><p id="2793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些已经想象出更好的工作流的人，我希望这篇文章，作为一篇端到端的GitHub集成构建经验，可以帮助你开始。</p><p id="6ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>