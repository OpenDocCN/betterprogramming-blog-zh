<html>
<head>
<title>Using FileManager in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中使用FileManager</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-filemanager-in-swiftui-44bc0f33995e?source=collection_archive---------1-----------------------#2021-03-04">https://betterprogramming.pub/using-filemanager-in-swiftui-44bc0f33995e?source=collection_archive---------1-----------------------#2021-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="518f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索如何在SwiftUI中存储数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a57b80cf51a52776a53f5b140eff8092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhII2mztmkNA2qghB7MY-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="0483" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">我之前写过一篇文章解释了什么是</em> <code class="fe lv lw lx ly b"><em class="lu">FileManager</em></code> <em class="lu">以及如何与UIKit一起使用。我建议在阅读今天的文章之前先阅读一下:</em></p><div class="lz ma gp gr mb mc"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-started-with-the-filemanager-in-your-ios-app-acd81b171f7d"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">开始使用iOS应用程序中的FileManager</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">检查文件系统的内容，并对其进行更改</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">better编程. pub</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="d97d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将了解什么是<code class="fe lv lw lx ly b">FileManager</code>以及如何使用它。我们将学习如何在一个简单的SwiftUI项目中使用<code class="fe lv lw lx ly b">FileManager</code>。先说什么是<code class="fe lv lw lx ly b">FileManager</code>。</p><p id="c159" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">注:您可以在GitHub上</em> <a class="ae mr" href="https://github.com/Unobliging/FileManager-in-SwiftUI" rel="noopener ugc nofollow" target="_blank"> <em class="lu">下载本文的示例项目和来源</em> </a> <em class="lu">。</em></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="3727" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">什么是FileManager？</h1><p id="abdc" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated"><code class="fe lv lw lx ly b">FileManager</code>使我们能够创建和编辑JSON或plist文件类型的数据，并在我们的应用中使用这些数据。</p><p id="eb7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">FileManager</code>与核心数据非常相似，但FileManager比核心数据更容易理解。简而言之，虽然您可以用核心数据创建更复杂的数据结构，但是您可以用更快的方式在<code class="fe lv lw lx ly b">FileManager</code>中创建更简单的数据结构。因此，<code class="fe lv lw lx ly b">FileManager</code>非常适合小型独立应用程序。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="1e6c" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">如何在SwiftUI中使用FileManager</h1><p id="f60b" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">为了在<code class="fe lv lw lx ly b">FileManager</code>中存储和编辑数据，我们需要使用解码器和编码器。显然，所有的文件管理器基本上都使用解码器和编码器。</p><p id="4d72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，我们直接从<code class="fe lv lw lx ly b">Data</code>类型中存储<code class="fe lv lw lx ly b">FileManager</code>中的值。<code class="fe lv lw lx ly b">Data</code>类型可以被认为是最基本的数据类型，因为当您使用<code class="fe lv lw lx ly b">Data</code>类型存储数据时，您直接存储的是该数据的<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">1</code>等效类型。你知道你电脑里的所有数据基本上都是由0和1组成的。</p><p id="03c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上我们可以用<code class="fe lv lw lx ly b">FileManager</code>做两件事:解码和编码数据。例如，我们可以使用<code class="fe lv lw lx ly b">PropertyListDecoder</code>解码一个定制的对象数组:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="4bdb" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">let</strong> decoder = PropertyListDecoder()<br/><strong class="ly iu">let</strong> data = <strong class="ly iu">try</strong> Data(contentsOf: dataSourceURL)<br/><strong class="ly iu">let</strong> decodedNotes = <strong class="ly iu">try</strong>! decoder.decode([Note].<strong class="ly iu">self</strong>, from: data)</span></pre><p id="6758" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们可以使用<code class="fe lv lw lx ly b">PropertyListEncoder</code>对象向自定义对象数组添加一个自定义对象:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="81ae" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">let</strong> encoder = PropertyListEncoder()<br/><strong class="ly iu">let</strong> data = <strong class="ly iu">try</strong> encoder.encode(allNotes)<br/><strong class="ly iu">try</strong> data.write(to: dataSourceURL)</span></pre><p id="1c00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与UIKit不同，我们必须单独进行这些操作，因为Swift不允许我们在计算属性中使用属性包装器。我们将在开发示例项目时看到这一点。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9cba" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">在简单的SwiftUI项目中使用FileManager</h1><p id="e4f1" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">为了理解如何在SwiftUI中使用FileManager，我们将创建一个类似于我在本文中创建的项目。SwiftUI的工作方式与UIKit略有不同。这就是为什么我们需要在<code class="fe lv lw lx ly b">FileManager</code>类中做一些改变。</p><h2 id="d2a0" class="oa na it bd nb of og dn nf oh oi dp nj lh oj ok nl ll ol om nn lp on oo np op bi translated">创建Xcode项目</h2><p id="6fa6" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">让我们创建一个新的Xcode项目。当然，我们项目的界面必须是SwiftUI。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oq"><img src="../Images/63ffb145c5bfe894fbd36a5ed168a376.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0RtPIxUzzzNzp8iyjjm6oA.png"/></div></figure><p id="7615" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以给这个项目起任何你想要的名字。之后，剩下的唯一一件事就是开始做你的项目。</p><p id="b057" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在开发项目时，我给你的建议是把你的文件分成文件夹。在做这个项目时，你可以像我一样使用文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oq"><img src="../Images/fb30bd8fa492651af2dae730b764aa14.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QwZDmgVVkvGzMYGQEjqmCg.png"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="478f" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">构建数据模型</h1><p id="261a" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">在本文中，我们将创建一个笔记应用程序。因此，我们的数据模型应该表示一个单一的note对象。这个模型有三个属性:<code class="fe lv lw lx ly b">id</code>、<code class="fe lv lw lx ly b">title</code>、<code class="fe lv lw lx ly b">description</code>。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="9b1e" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">struct</strong> Note: Codable, Identifiable {<br/>    <br/>    // MARK: - Properties<br/>    <strong class="ly iu">var</strong> id = UUID()<br/>    <strong class="ly iu">let</strong> title: String<br/>    <strong class="ly iu">let</strong> description: String<br/>}</span></pre><p id="b9d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个数据模型中，我们使用了<code class="fe lv lw lx ly b">Codable</code>和<code class="fe lv lw lx ly b">Identifiable</code>协议。</p><blockquote class="or os ot"><p id="2cf4" class="ky kz lu la b lb lc ju ld le lf jx lg ou li lj lk ov lm ln lo ow lq lr ls lt im bi translated">" Codable是可编码和可解码协议的类型别名。当您将Codable用作类型或泛型约束时，它会匹配符合这两种协议的任何类型。— <a class="ae mr" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p><p id="c81b" class="ky kz lu la b lb lc ju ld le lf jx lg ou li lj lk ov lm ln lo ow lq lr ls lt im bi translated">使用可识别协议为类或值类型提供稳定的标识概念。例如，您可以定义一个用户类型，其id属性在您的应用程序和应用程序的数据库存储中保持稳定。您可以使用id属性来标识特定用户，即使其他数据字段发生了变化，如用户名。— <a class="ae mr" href="https://developer.apple.com/documentation/swift/identifiable" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="44d5" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">准备FileManager类</h1><p id="207c" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">现在我们的数据模型已经准备好了，我们可以开始创建我们的<code class="fe lv lw lx ly b">FileManager</code>类了。为此，让我们创建一个新的Swift文件，调用<code class="fe lv lw lx ly b">DataProvider</code>:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="bf49" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">class</strong> DataProvider: ObservableObject {<br/><br/>}</span></pre><p id="98b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，我们使用<code class="fe lv lw lx ly b">ObservableObject</code>协议进行数据传输。</p><blockquote class="ox"><p id="836e" class="oy oz it bd pa pb pc pd pe pf pg lt dk translated">"默认情况下，<code class="fe lv lw lx ly b">ObservableObject</code>合成一个<code class="fe lv lw lx ly b">objectWillChange</code>发布器，在其任何<code class="fe lv lw lx ly b">@Published</code>属性更改之前发出更改后的值。"— <a class="ae mr" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="7e77" class="pw-post-body-paragraph ky kz it la b lb ph ju ld le pi jx lg lh pj lj lk ll pk ln lo lp pl lr ls lt im bi translated">在我们的类中，<code class="fe lv lw lx ly b">@Published</code>属性将是<code class="fe lv lw lx ly b">Note</code>对象数组:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="c19f" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">class</strong> DataProvider: ObservableObject {<br/><br/>    // MARK: - Properties<br/>    @Published <strong class="ly iu">var</strong> allNotes = [Note]()<br/>}</span></pre><p id="88f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义一个名为<code class="fe lv lw lx ly b">shared</code>的值来调用自身外部的<code class="fe lv lw lx ly b">DataProvider</code>类:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="7055" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">class</strong> DataProvider: ObservableObject {<br/><br/>    // MARK: - Properties<br/>    <strong class="ly iu">static</strong> <strong class="ly iu">let</strong> shared = DataProvider()<br/>    @Published <strong class="ly iu">var</strong> allNotes = [Note]()<br/>}</span></pre><p id="9cd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用<code class="fe lv lw lx ly b">FileManager</code>存储数据，我们需要一个URL对象。我们为此定义了一个属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="7f69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我之前说过的，使用<code class="fe lv lw lx ly b">@Published</code>属性包装器的值不能是计算属性。这就是为什么我们必须为get和set数据操作使用两个额外的方法。</p><p id="a3f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，编写一个名为<code class="fe lv lw lx ly b">getAllNotes</code>的方法来取回我们之前保存的<code class="fe lv lw lx ly b">Note</code>数组。如果我们没有保存任何<code class="fe lv lw lx ly b">Note</code>对象，该方法必须返回一个空数组。这一点非常重要。否则，我们的应用程序会崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="8b09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在<code class="fe lv lw lx ly b">init</code>方法中使用<code class="fe lv lw lx ly b">getAllNotes</code>方法。否则，<code class="fe lv lw lx ly b">allNotes</code>元素将为空，我们的应用程序将崩溃。因此，在<code class="fe lv lw lx ly b">init</code>方法中定义了<code class="fe lv lw lx ly b">dataSourceURL</code>元素后，我们用<code class="fe lv lw lx ly b">getAllNotes</code>来均衡<code class="fe lv lw lx ly b">allNotes</code>元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="5f5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会问为什么它以这种方式把两个值等同起来。那是因为<code class="fe lv lw lx ly b">allNotes</code>的开头有<code class="fe lv lw lx ly b">_</code> <em class="lu"> </em>并且<code class="fe lv lw lx ly b">getAllNotes</code>方法正在转换为<code class="fe lv lw lx ly b">@Published</code>属性。</p><p id="9990" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以定义允许我们保存数据的方法。这个方法应该是私有的，因为我们希望这个方法在<code class="fe lv lw lx ly b">DataProvider</code>类之外。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="5e88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个新的<code class="fe lv lw lx ly b">Note</code>对象，编写下面的方法。如您所见，在向<code class="fe lv lw lx ly b">allNotes</code>插入一个新的<code class="fe lv lw lx ly b">Note</code>对象后，我们调用<code class="fe lv lw lx ly b">saveNotes</code>方法来保存更改:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="09de" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">func</strong> create(note: Note) {<br/>    allNotes.insert(note, at: 0)<br/>    saveNotes()<br/>}</span></pre><p id="6ed1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编写一个方法来替换先前定义的<code class="fe lv lw lx ly b">Note</code>对象。类似地，在做出更改后，我们调用<code class="fe lv lw lx ly b">saveNotes</code>方法:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="3913" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">func</strong> changeNote(note: Note, index: Int) {<br/>    allNotes[index] = note<br/>    saveNotes()<br/>}</span></pre><p id="4038" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编写一个新方法来删除一个<code class="fe lv lw lx ly b">Note</code>对象。要在SwiftUI中删除一个<code class="fe lv lw lx ly b">List</code>对象中的元素，我们需要该元素的<code class="fe lv lw lx ly b">offsets</code>信息。这就是为什么这个方法有一个<code class="fe lv lw lx ly b">offsets</code>参数:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="f0f2" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">func</strong> delete(_ offsets: IndexSet) {<br/>    allNotes.remove(atOffsets: offsets)<br/>    saveNotes()<br/>}</span></pre><p id="d507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，编写一个名为<code class="fe lv lw lx ly b">move</code>的方法来移动一个<code class="fe lv lw lx ly b">List</code>单元格。我们将创建的<code class="fe lv lw lx ly b">List</code>对象中的单元格的信息源将是<code class="fe lv lw lx ly b">allNotes</code>数组。因此，当我们改变一个单元格的位置时，我们需要改变该单元格的<code class="fe lv lw lx ly b">Note</code>对象的偏移量:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="fe87" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">func</strong> move(source: IndexSet, destination: Int) {<br/>    allNotes.move(fromOffsets: source, toOffset: destination)<br/>    saveNotes()<br/>}</span></pre><p id="cc2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用这种方法，我们完成了<code class="fe lv lw lx ly b">DataProvider</code>类！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="44f7" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">准备用户界面</h1><p id="c9e8" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">为了访问<code class="fe lv lw lx ly b">DataProvider</code>类中的属性和方法，让我们在主<code class="fe lv lw lx ly b">View</code>对象中使用下面的<code class="fe lv lw lx ly b">@ObservedObject</code>属性包装器定义一个元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="6b7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们基本上可以构建我们的主UI:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="a1f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使代码更加可靠，用我们在<code class="fe lv lw lx ly b">ForEach</code>对象中编写的对象创建一个自定义对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="2659" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们的主<code class="fe lv lw lx ly b">View</code>对象可读性更好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="fc49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们不能在应用程序中添加、编辑或删除新的<code class="fe lv lw lx ly b">Note</code>对象。因此，当您现在运行项目时，应用程序中没有任何功能。让我们开始创建要与之交互的UI元素。</p><p id="4202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建UI元素，我们需要创建两个变量:<code class="fe lv lw lx ly b">alertShowing</code>和<code class="fe lv lw lx ly b">editMode</code>。<code class="fe lv lw lx ly b">alertShowing</code>是一个<code class="fe lv lw lx ly b">Bool</code>类型值，如果是<code class="fe lv lw lx ly b">true</code>就可以出现<code class="fe lv lw lx ly b">Alert</code>对象。<code class="fe lv lw lx ly b">editMode</code>是一个<code class="fe lv lw lx ly b">EditMode</code>类型值，如果设置为<code class="fe lv lw lx ly b">.active</code>，<code class="fe lv lw lx ly b">List</code>对象的单元格是可编辑和可删除的。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="1dcf" class="oa na it ly b gy ob oc l od oe">// MARK: - Properties<br/>@ObservedObject <strong class="ly iu">var</strong> dataProvider: DataProvider<br/>@State <strong class="ly iu">private</strong> <strong class="ly iu">var</strong> alertShowing = <strong class="ly iu">false</strong><br/>@State <strong class="ly iu">private</strong> <strong class="ly iu">var</strong> editMode: EditMode = .inactive</span></pre><p id="4497" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们添加和编辑按钮的新对象将在<code class="fe lv lw lx ly b">NavigationView</code>对象中。我们使用<code class="fe lv lw lx ly b">navigationBarItems</code>修改器在<code class="fe lv lw lx ly b">NavigationView</code>中放置按钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="249c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编辑<code class="fe lv lw lx ly b">List</code>对象时激活添加按钮是不对的。这就是为什么我们将add按钮转换成一个名为<code class="fe lv lw lx ly b">AddButton</code>的自定义对象，当<code class="fe lv lw lx ly b">editMode</code>元素等于<code class="fe lv lw lx ly b">.active</code>时，它就变成了一个<code class="fe lv lw lx ly b">EmptyView</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="ecb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，<code class="fe lv lw lx ly b">navigationBarItems</code>修改器也变得相当小:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="3d8e" class="oa na it ly b gy ob oc l od oe">.navigationBarItems(<br/>    leading: EditButton(),<br/>    trailing: AddButton(editMode: $editMode, alertShowing: $alertShowing)<br/>)</span></pre><p id="d527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在<code class="fe lv lw lx ly b">List</code>对象的末尾编写<code class="fe lv lw lx ly b">environment</code>修饰符，我们可以在点击<code class="fe lv lw lx ly b">EditButton</code>时使<code class="fe lv lw lx ly b">List</code>对象可编辑:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="3018" class="oa na it ly b gy ob oc l od oe">.listStyle(InsetListStyle())<br/>.environment(\.editMode, $editMode)</span></pre><p id="881b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们需要使用<code class="fe lv lw lx ly b">onDelete</code>和<code class="fe lv lw lx ly b">onMove</code>修饰符，以便列表对象中的单元格可以被删除和编辑。这里，我们使用之前在<code class="fe lv lw lx ly b">perform</code>参数中编写的<code class="fe lv lw lx ly b">move</code>和<code class="fe lv lw lx ly b">delete</code>方法。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="1d3a" class="oa na it ly b gy ob oc l od oe">ForEach(dataProvider.allNotes) { note <strong class="ly iu">in</strong><br/>    NoteListCell(note: note)<br/>}<br/>.onDelete(perform: dataProvider.delete)<br/>.onMove(perform: dataProvider.move)</span></pre><p id="35f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们可以编辑和删除<code class="fe lv lw lx ly b">List</code>对象单元格，但不能添加新的<code class="fe lv lw lx ly b">Note</code>对象。这就是为什么我们的应用程序现在没有任何意义，因为没有附加<code class="fe lv lw lx ly b">Note</code>对象。如果我们创建UI元素来添加新的<code class="fe lv lw lx ly b">Note</code>对象，我们的应用就会变成我们想要的样子。</p><p id="ace1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用一个<code class="fe lv lw lx ly b">Alert</code>对象来添加一个新的<code class="fe lv lw lx ly b">Note</code>对象。这对你来说似乎很容易，但是SwiftUI仍然没有包含<code class="fe lv lw lx ly b">TextField</code>对象的<code class="fe lv lw lx ly b">Alert</code>对象。因此，我们需要用<code class="fe lv lw lx ly b">UIViewControllerRepresentable</code>创建自定义的<code class="fe lv lw lx ly b">Alert</code>对象。</p><p id="d277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要做的第一件事是创建一个新的<code class="fe lv lw lx ly b">UIViewController</code>，就像在UIKit中定义一个自定义的<code class="fe lv lw lx ly b">UIAlertViewController</code>。为此，您可以创建一个名为<code class="fe lv lw lx ly b">TextFieldAlertViewController</code>的Swift文件，并导入SwiftUI和Combine框架。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="5a12" class="oa na it ly b gy ob oc l od oe"><strong class="ly iu">import</strong> SwiftUI<br/><strong class="ly iu">import</strong> Combine</span></pre><p id="a100" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们可以创建<code class="fe lv lw lx ly b">TextFieldAlertViewController</code>类。我们下面写的代码将帮助我们创建<code class="fe lv lw lx ly b">UIAlertController</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="36ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个名为<code class="fe lv lw lx ly b">presentAlertController</code>的方法，并将该方法写入<code class="fe lv lw lx ly b">viewDidAppear</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="1b5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为我们将在主<code class="fe lv lw lx ly b">View</code>对象中使用的自定义<code class="fe lv lw lx ly b">Alert</code>对象，我们创建了一个名为<code class="fe lv lw lx ly b">TextFieldAlert</code>的自定义UI对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="b3c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用<code class="fe lv lw lx ly b">UIViewControllerRepresentable</code>协议在SwiftUI中使用定制UIKit元素。同样，我们将它与<code class="fe lv lw lx ly b">TextAlert</code>对象一起使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="1ccf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，创建一个名为<code class="fe lv lw lx ly b">TextFieldWrapper</code>的<code class="fe lv lw lx ly b">View</code>元素来定义当<code class="fe lv lw lx ly b">TextAlert</code>对象将会和不会显示在我们的主<code class="fe lv lw lx ly b">View</code>对象中时需要做什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="aedd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像使用<code class="fe lv lw lx ly b">alert</code>修改器一样，我们创建了一个名为<code class="fe lv lw lx ly b">textAlert</code>的修改器，以便在我们的应用中将<code class="fe lv lw lx ly b">TextAlert</code>对象用作<code class="fe lv lw lx ly b">Alert</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="6f12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以在应用程序中使用<code class="fe lv lw lx ly b">TextAlert</code>对象，使用<code class="fe lv lw lx ly b">textFieldAlert</code>修饰符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="a25a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的应用已经准备好了。现在我们可以测试它了！如您所见，SwiftUI允许我们自动执行许多操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oq"><img src="../Images/e72630d09ee0de923d55cdfe5a083882.png" data-original-src="https://miro.medium.com/v2/1*vBWYIlH9DmjKM-23rNF1rQ.gif"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="91c7" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">结论</h1><p id="58ce" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">虽然SwiftUI不支持很多东西，但是多亏了像<code class="fe lv lw lx ly b">UIViewControllerRepresentable</code>这样的工具，我们几乎可以用SwiftUI做任何事情。这就是为什么我认为每个人都可以只用SwiftUI开发自己的独立应用程序。</p><p id="f324" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读这篇文章。如果你有任何问题，请在评论区留言。</p><p id="7b5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的其他文章:</p><ul class=""><li id="6051" class="po pp it la b lb lc le lf lh pq ll pr lp ps lt pt pu pv pw bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/building-cross-platform-apps-with-swiftui-3fea88cdb0ae">使用SwiftUI构建跨平台应用</a></li><li id="3acd" class="po pp it la b lb px le py lh pz ll qa lp qb lt pt pu pv pw bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/build-a-textfield-for-numbers-in-swiftui-21030b58a41">在SwiftUI中为数字构建一个文本字段</a></li><li id="fd4c" class="po pp it la b lb px le py lh pz ll qa lp qb lt pt pu pv pw bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-firebase-in-swiftuis-new-application-lifecycle-c77a8a306d63">如何在SwiftUI的新应用生命周期中使用Firebase</a></li></ul></div></div>    
</body>
</html>