<html>
<head>
<title>React Hooks versus Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子和类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-hooks-vs-classes-add2676a32f2?source=collection_archive---------0-----------------------#2019-10-03">https://betterprogramming.pub/react-hooks-vs-classes-add2676a32f2?source=collection_archive---------0-----------------------#2019-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b41d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有什么区别，你应该在你的应用程序中使用哪个，为什么？</p><p id="02b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于React如今在开发人员中如此受欢迎，这篇博客旨在通过React 16.8发布的<code class="fe ko kp kq kr b">useState()</code>和<code class="fe ko kp kq kr b">useEffect()</code>的钩子API向您展示React钩子与类的优缺点。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/c44df93ed6027ffe1b75f306823623bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*HG6RtyHpHkiktHRG.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">问题</strong> : React没有提供比类组件更简单的有状态原语——Dan abra mov<em class="lf"/></p></figure><p id="6209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将简要讨论状态，然后我们将检查React中的<em class="lg">钩子</em>和<em class="lg">类</em>。最后，我们将看到<strong class="js iu"> React 16.8 </strong>中钩子的释放是如何解决以下痛点的:</p><p id="fb8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1 </strong>。<strong class="js iu">管理状态:</strong>重用多个组件之间的逻辑会导致<em class="lg">包装器地狱</em>或深度嵌套的组件。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/4c3dc012e9120c7b7f157a9d252517fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*ujsCshvXLCaHAnTT.png"/></div></figure><p id="a295" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2 </strong>。<strong class="js iu">副作用:</strong>生命周期方法中逻辑上不相关的混合会得到重复，并引起不必要的副作用。</p><p id="46f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3 </strong>。<strong class="js iu">优化:</strong>钩子可能会减少你的包的大小。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="a240" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">管理本地状态</h1><h2 id="c345" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated"><strong class="ak">React中的状态是什么？</strong></h2><p id="7da1" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">简单地说，状态就是一个包含所有键值对的对象。状态决定了组件的呈现和行为方式。</p><p id="97ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">状态允许您的组件是动态的和交互式的。</p><p id="47fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要把国家与<code class="fe ko kp kq kr b">props</code>混淆。状态是组件内部管理的内容，而<code class="fe ko kp kq kr b">props</code>是传递给组件的内容。</p><h2 id="5416" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated">React中的类如何管理本地状态</h2><p id="98d6" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">类组件来自ES6类，是管理本地状态的默认方法。它们还允许副作用通过生命周期方法发生。</p><p id="8966" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要访问和管理类中的状态，必须将<code class="fe ko kp kq kr b">this.state</code>初始化为<code class="fe ko kp kq kr b">constructor()</code>中的一个对象，将本地状态命名为一个键，并将其初始值设置为键值。</p><p id="3c35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">setState()</code>是更新类中状态的默认方法，这是导致组件重新呈现的原因。</p><p id="dad4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，建议每次想在钩子之前正确修改状态时调用<code class="fe ko kp kq kr b">setState()</code>。</p><p id="c789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个用类编写的带有递增按钮的计数器的简单示例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">本地状态设置为counter = 0，handleIncrement()作为回调传递给button</p></figure><p id="e1ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要设置一个类组件，你需要一些样板代码，不仅限于你的类中的常规<code class="fe ko kp kq kr b">constructor()</code>和扩展组件的<code class="fe ko kp kq kr b">super()</code>。</p><p id="b25b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，有必要在类组件中添加<code class="fe ko kp kq kr b">this</code>上下文，并将其绑定到第9行的<code class="fe ko kp kq kr b">constructor()</code>中。</p><p id="67e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于普通JavaScript中的隐式绑定，我们需要绑定<code class="fe ko kp kq kr b">this</code>。</p><p id="f28f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们像这样(<code class="fe ko kp kq kr b">&lt;button type=”button” onClick={this.handleIncrement}&gt;+&lt;/button&gt;</code>)传递事件处理函数引用时，我们失去了<code class="fe ko kp kq kr b">this</code>的上下文，因为<code class="fe ko kp kq kr b">handleIncrement()</code>变成了没有所有者对象的普通函数调用。</p><p id="9a61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，<code class="fe ko kp kq kr b">this</code>的值回到默认绑定，并指向全局对象，或者如果被调用的函数使用严格模式，则指向<code class="fe ko kp kq kr b">undefined</code>。</p><p id="09ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们需要将return语句包装在<code class="fe ko kp kq kr b">render()</code>函数中。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="0ecd" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">React钩子如何管理本地状态</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/89afae504108b3525325b68cb52a8f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*LC5KLKBBFD_6AN3V.png"/></div></figure><p id="474f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:钩子完全基于选择加入，并且100%向后兼容。这意味着您不必马上学习或使用钩子，并且在添加或重构您的类时不会有突破性的变化。</p><p id="e0af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">钩子允许你在不写类的情况下使用本地状态和其他React特性。</p><p id="8558" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">钩子是特殊的函数，它可以让你“钩住”功能组件内部的反应状态和生命周期特性。</p><p id="7258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">重要</strong>:内部反应无法跟踪乱序运行的钩子。因为钩子返回一个数组，所以它们被调用的顺序很重要。</p><p id="43f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">挂钩有两个规则:</p><ol class=""><li id="f1f6" class="nf ng it js b jt ju jx jy kb nh kf ni kj nj kn nk nl nm nn bi translated">只在顶层调用钩子——不要在任何逻辑中嵌套钩子。</li></ol><p id="6c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要这样做！</p><p id="7547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">if (bool) { const [counter, incrementCounter] = useState(0) }</code></p><p id="045a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.仅从React函数或自定义挂钩中调用挂钩。</p><p id="39a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于React组件在每次数据改变时都会被重新渲染，这意味着在每次渲染时必须以完全相同的顺序调用完全相同的钩子。如果我们把钩子放在条件or函数中，状态有时会被创建，而其他时候不会。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="1679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">useState()</code>是一个钩子，让你给函数组件添加一个反应状态。</p><p id="cb80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是同一个例子，但是没有使用类，而是使用了钩子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">本地状态是常量计数器= 0，</p></figure><p id="ab5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过导入和调用<code class="fe ko kp kq kr b">useState()</code>，它声明了一个“状态变量”<code class="fe ko kp kq kr b">counter</code>，其值是传递给<code class="fe ko kp kq kr b">useState()</code>的任何参数。在这种情况下，我们的状态变量<code class="fe ko kp kq kr b">counter</code>的值为零，如第4行中设置的。</p><p id="6b06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:<code class="fe ko kp kq kr b">useState()</code>的参数不限于对象，可以是原语，如数字、字符串、布尔值等。</p><p id="a07d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">useState()</code>只取一个自变量，初始状态。</p><p id="af71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">useState()</code>返回数组中的一对值，当前状态和更新它的函数。</p><p id="3160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，与类中的<code class="fe ko kp kq kr b">this.setState()</code>不同，更新当前状态总是<strong class="js iu">替换</strong>而不是合并它。</p><p id="b184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将数组分解成两个变量，我们可以使用更具声明性的方法，因为我们知道数组中返回的第一个值是当前状态，第二个值是更新状态的函数。(第4行)</p><p id="4da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是编程中的一个概念，叫做<a class="ae no" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="lg">耦合</em> </a>、<em class="lg"> </em>，通过将这两个值紧密分组，我们知道它们彼此紧密依赖。</p><p id="ad6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们当前的状态是<code class="fe ko kp kq kr b">count</code>的值，为0，我们的<code class="fe ko kp kq kr b">incrementCounter</code>是更新<code class="fe ko kp kq kr b">count</code>的函数。</p><p id="7827" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:<code class="fe ko kp kq kr b">incrementCounter()</code>需要包装在一个函数中，并作为回调传递到我们的按钮中。</p><p id="9f18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意每个变量是如何与其各自的值相关联的，我们的函数保持干燥和可重用。</p><p id="9ee2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，不再需要<code class="fe ko kp kq kr b">this</code>上下文，为我们节省了一些手指力量和时间。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="7fed" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是副作用？</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/4c49cfbd4acbd1012675dbca3a5cb038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*stil4UdeBWgGwZlw.png"/></div></figure><p id="06d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">副作用通常是影响正在执行的函数范围之外的任何东西，或者在React的上下文中，是修改其本地环境之外的状态的任何东西。</p><p id="78f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">常见的副作用包括获取数据、设置订阅以及手动更改React组件中的DOM。</p><p id="a64e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在React的例子中，有两种常见的副作用:不需要清理的和需要清理的。</p><p id="a0d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不需要清理的例子有网络请求、手动DOM突变和日志记录。这是因为我们运行它们，并立即忘记它们。</p><p id="bfca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想清理副作用，我们需要返回一个包含卸载逻辑的函数。</p><h2 id="f75b" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated"><strong class="ak">在React中使用类的副作用</strong></h2><p id="4ed2" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">手动DOM变异的类示例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">componentDidMount()在初始挂载时设置文档标题=计数器；componentDidUpdate()在初次装载后，每次更改计数器后更新文档标题。</p></figure><p id="09d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是React的生命周期方法在类中引入副作用的一个例子。如<code class="fe ko kp kq kr b">componentDidMount()</code>、<code class="fe ko kp kq kr b">componentDidUpdate()</code>、<code class="fe ko kp kq kr b">componentWillUnMount()</code>。</p><p id="b6f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，<code class="fe ko kp kq kr b">componentDidMount()</code>将文档的标题“装载”或设置为本地状态的当前计数。</p><p id="f49c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新一发生就调用<code class="fe ko kp kq kr b">componentDidUpdate()</code>。<code class="fe ko kp kq kr b">componentDidUpdate()</code>最常见的用例是更新DOM以响应属性或状态的变化。</p><p id="104f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想重置计数，我们还需要一个<code class="fe ko kp kq kr b">componentWillUnMount()</code>。</p><p id="d4df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个关于生命周期方法的更好的阅读:<a class="ae no" href="https://programmingwithmosh.com/javascript/react-lifecycle-methods/" rel="noopener ugc nofollow" target="_blank">React life cycle Methods——Mosh hame dani的深入探讨</a>。</p><h2 id="86ce" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated"><strong class="ak">使用React挂钩的副作用</strong></h2><p id="7018" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">带<code class="fe ko kp kq kr b">useEffect()</code>钩子的函数示例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">useEffect()接受回调</p></figure><p id="1ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">useEffect()</code>允许您在函数组件中使用副作用。</p><p id="2c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">告诉你的组件在每次渲染后做一些事情。</p><p id="c190" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React将记住传入的回调，并在DOM更新后调用它。</p><p id="569e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">useEffect()</code>被放在我们的函数组件中，因为我们想要访问我们的本地状态计数。</p><p id="ce33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，<code class="fe ko kp kq kr b">useEffect()</code>在每次渲染后运行。所以就像是一个<code class="fe ko kp kq kr b">componentDidMount()</code>、<code class="fe ko kp kq kr b">componentDidUpdate()</code>、<code class="fe ko kp kq kr b">componentWillUnMount()</code>三位一体。</p><p id="7b25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Fullstack代码学院为期三周的课程中，我们使用带有钩子的功能组件，通过<code class="fe ko kp kq kr b">useEffect()</code>在arcGIS中获取纽约开放数据和远程自定义数据库。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="a5f6" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">通过跳过效果优化性能</strong></h1><h2 id="c45d" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated"><strong class="ak">类例子</strong></h2><p id="fa56" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">每次渲染后清理和应用效果是一项繁重的任务，我们可能会遇到问题或错误。</p><p id="d0f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们想将<code class="fe ko kp kq kr b">document.title</code>限制为最大计数10:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9a27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">类</strong>组件中，我们可以通过在我们的<code class="fe ko kp kq kr b">componentDidUpdate()</code>函数中添加一个额外的条件并传入<code class="fe ko kp kq kr b">prevProps</code>和<code class="fe ko kp kq kr b">prevState</code>作为参数来解决这个问题。(第16–17行)</p><h2 id="1193" class="mm lp it bd lq mn mo dn lu mp mq dp ly kb mr ms mc kf mt mu mg kj mv mw mk mx bi translated"><strong class="ak">挂钩示例</strong></h2><p id="ee30" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">使用<strong class="js iu">钩子</strong>，我们可以简单地将第二个参数作为一个带有计数器的数组传递给<code class="fe ko kp kq kr b">useEffect()</code>，并在我们的<code class="fe ko kp kq kr b">useEffect()</code>中添加条件。</p><p id="0b01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递到数组中的任何内容都可以用来定义钩子所依赖的所有变量。如果其中一个变量更新，钩子将再次运行。</p><p id="39cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，如果您传递一个空数组，钩子在更新组件时根本不会运行，因为没有什么需要关注的。当您在循环中获取数据，并且只想在<code class="fe ko kp kq kr b">componentDidMount()</code>获取数据，从而停止循环时，这很有用。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nd ne l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">将[counter]传递给useEffect()的第二个参数—第10行</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="d31f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="9c6f" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">虽然hooks解决了我们在React中使用类时遇到的许多棘手问题，但是对于类来说还有其他的用例，比如如果您想要访问特定的生命周期方法。</p><p id="ff7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，本指南不是<strong class="js iu">也不是</strong>要说服你使用钩子或者完全重构你的类到钩子。</p><p id="090a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只是一个友好的提醒，还有其他的选择可以尝试！</p><p id="3a7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你真的有兴趣学习更多关于钩子的知识，试着将这些概念应用到你将来开始的新项目中。</p><p id="4118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下次见。编码快乐！— <em class="lg"> RL </em></p><p id="cdb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有兴趣学习更多关于钩子的知识，比如访问上下文API等等。，参见<a class="ae no" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">上下文API </a>。</p></div></div>    
</body>
</html>