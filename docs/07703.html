<html>
<head>
<title>How Database Indexing Actually Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库索引的实际工作方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-database-indexing-actually-works-ba6e19e75169?source=collection_archive---------2-----------------------#2021-02-11">https://betterprogramming.pub/how-database-indexing-actually-works-ba6e19e75169?source=collection_archive---------2-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c0d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个强大概念的简要概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc49a49e5e7997a0971d759e5eec6020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5W-wcIFl_nCyRkN5rFZUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@quasichiara?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Chiara F </a>在<a class="ae ky" href="https://unsplash.com/s/photos/bookmarks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="f73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库的特点是有组织地存储数据。存储对于数据的存放位置有特定的结构。每种数据库类型都有自己的数据存储格式。它们针对特定的用例进行了调整和优化。在下面的示例中，我们有一个包含汽车信息的数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a66e3ab677a89004bebda0f490e987c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQbTPX02130nYzsxvttQpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含汽车的数据库表示例</p></figure><p id="817d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来不错，很容易通过它导航。但你有没有问过自己，这些数据实际上是如何存储的？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="11bd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">内存储器</h1><p id="3b13" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">每个数据库都存储在一个应用了特定编码和格式的文件中。为了简单起见，让我们假设一个数据库由一个CSV文件支持。看起来是这样的:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="86cc" class="nf me it nb b gy ng nh l ni nj">ID,Brand,Model,Color,Price<br/>1,Ford,Focus,Grey,42000<br/>2,Toyota,Prius,White,40500<br/>3,BMW,M5,Red,60000<br/>4,Audi,A3,Black,38000<br/>5,Toyota,Camry,White,51500<br/>6,VW,Golf,Grey,32000</span></pre><p id="898b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很简单。只用六个条目进行查找不成问题。你能想象如果你有100，000个条目吗？浏览文件会变得非常慢。查询时间与文件大小成比例增加。当我们知道数据库会随着时间的推移而增长时，我们需要找到一个解决方案。</p><p id="6c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拯救指数来了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a874" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数据库索引</h1><p id="d66d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">数据库索引是一种数据结构，用于加速检索数据的操作。它看起来像什么？</p><p id="d3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要在<code class="fe nk nl nm nb b">ID 6</code>之前从我们的表中检索一辆汽车，直接跳到相应的行会更快，而不需要遍历其余的行。这是索引的主要思想。我们还需要保存指向相应条目的偏移量。</p><p id="7d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这一点的最简单的方法是在hash中为每个条目保留一个偏移量。键是我们要索引的列的值(在本例中，它是ID列)。哈希值是数据库文件中的偏移量。对于<code class="fe nk nl nm nb b">ID = 1</code>，偏移量为<code class="fe nk nl nm nb b">0</code>。对于<code class="fe nk nl nm nb b">ID = 2</code>，偏移量为<code class="fe nk nl nm nb b">24</code>。它可能看起来像这样:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="37ee" class="nf me it nb b gy ng nh l ni nj">Hash Index {1:0, 2:24, 3:51, 4:70, 5:92, 6:118}<br/></span><span id="5bc0" class="nf me it nb b gy nn nh l ni nj">1 =&gt; {0}         ---------&gt;   1,Ford,Focus,Grey,42000   <br/>2 =&gt; {24}        ---------&gt;   2,Toyota,Prius,White,40500<br/>3 =&gt; {51}        ---------&gt;   3,BMW,M5,Red,60000<br/>4 =&gt; {70}        ---------&gt;   4,Audi,A3,Black,38000<br/>5 =&gt; {92}        ---------&gt;   5,Toyota,Camry,White,51500<br/>6 =&gt; {118}       ---------&gt;   6,VW,Golf,Grey,32000</span></pre><p id="2fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加索引后，通过ID查询汽车将更快返回结果。检索请求转到散列索引，并获取相应ID的偏移量。然后，它开始从必要的条目处的偏移量读取数据库文件。</p><p id="211e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引是实现唯一性约束的适当方式。当您希望保证某一列中的值是唯一的时，就需要对该列建立索引。否则，每个插入操作都将卡在检查新数据是否已经存在上。</p><p id="c947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可能有多个索引。如果我们需要任何其他列的快速查询，我们也可以在其上添加一个索引。例如，我们可以添加一个颜色索引，并通过颜色查询快车。但是每个新的索引都会给数据库带来额外的成本。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4bde" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">指数成本</h1><p id="3ffa" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，每个索引散列都需要额外的内存。我们添加的索引越多，使用的内存就越多。记住只在经常查询的列上添加索引是很重要的。否则，索引每一列将消耗大量内存。</p><p id="1104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，对于快速读取操作，写入操作会稍微慢一些。每当我们向表中添加一个条目时，我们还必须在散列索引中创建一个条目。类似的情况也适用于更新或删除数据。这是我们必须处理的权衡。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0368" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">外卖食品</h1><ul class=""><li id="2288" class="no np it lb b lc mv lf mw li nq lm nr lq ns lu nt nu nv nw bi translated">数据库索引是提高读取查询的好方法。</li><li id="3b44" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">对于唯一性约束，对列进行索引是必要的。</li><li id="e18b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">随着每个新的索引，更多的内存将被消耗。</li><li id="6d43" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">添加索引会影响写入和更新操作。</li></ul><p id="e303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是简单散列索引的工作方式。使用数据库索引还有许多其他方法，比如排序字符串表或B树。它们使用更复杂的逻辑和优化的结构来实现更好的性能结果。</p><p id="14b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，保存偏移的想法保持不变。通过正确使用索引，您将能够在使用数据库时达到一个新的水平。</p></div></div>    
</body>
</html>