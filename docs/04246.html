<html>
<head>
<title>Custom Subscripts in Swift Explained With Code Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用代码示例解释Swift中的自定义下标</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-subscripts-in-swift-explained-with-code-examples-113ca73f1d90?source=collection_archive---------21-----------------------#2020-03-31">https://betterprogramming.pub/custom-subscripts-in-swift-explained-with-code-examples-113ca73f1d90?source=collection_archive---------21-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e6ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解关于静态下标、默认下标等的所有信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2267735c9a31cde533dde446ca1dd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnelLVX3IlMiIgNZyhuDVg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@davefrancis101?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴夫·弗朗西斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/fetch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中的自定义下标允许您编写集合或序列中元素的快捷方式，并且可以在类、结构和枚举中定义。您可以使用下标来设置和检索值，而无需公开某个实例的内部细节。</p><p id="c927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个实例可以定义多个下标，一个下标可以有多个输入参数。例如，您可能已经使用下标从数组或字典中获取元素。然而，你不太可能还定义了你自己的定制下标，尽管这些也非常有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是下标？</h1><p id="da09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下标定义集合、列表或序列的元素的快捷方式。它可以在类、结构和枚举中定义，以允许快速访问某种类型的元素。</p><p id="0414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整个标准Swift库中也经常使用它，例如，访问数组中的元素:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3ffa" class="ne md it na b gy nf ng l nh ni">var array = ["Antoine", "Jaap", "Lady"]<br/>print(array[0]) // Prints: Antoine</span></pre><p id="cdb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者从字典中访问元素:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="96c6" class="ne md it na b gy nf ng l nh ni">var agesDictionary = ["Antoine": 29, "Lady": 2, "Jaap": 1]<br/>print(agesDictionary["Antoine"]) // Prints: 29</span></pre><p id="8e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的下标也可用于添加新值:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="57f7" class="ne md it na b gy nf ng l nh ni">array[0] = "Henk"<br/>print(array[0]) // Prints: Henk<br/><br/>agesDictionary["Antoine"] = 30<br/>print(agesDictionary["Antoine"]) // Prints: 30</span></pre><p id="fda9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有这些下标，您可能会通过数组或字典上定义的方法来访问相同的内容。这些方法很容易让你的代码看起来不那么干净:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="98a2" class="ne md it na b gy nf ng l nh ni">array.set("Henk", forIndex: 0)<br/>agesDictionary.set(30, forKey: "Antoine")</span></pre><p id="e018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这些方法实际上并不存在，因为我们现在在Swift中有下标来做同样的事情。</p><p id="9f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把上面的例子作为一个改进，也是你可以看看你自己的代码的方式。每当您发现自己在编写类似的方法时，您可以考虑编写自己的自定义下标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5db8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建自定义下标</h1><p id="9c2c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以定义自定义下标，就像在类、结构或枚举中定义方法一样。在我们深入这个逻辑之前，我想介绍一个图像缓存实例，我们将用下标来改进它。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="64f4" class="ne md it na b gy nf ng l nh ni">final class ImageCache {<br/>    static let shared = ImageCache()<br/><br/>    private var imageStore: [URL: UIImage] = [:]<br/><br/>    func image(for url: URL) -&gt; UIImage? {<br/>        imageStore[url]<br/>    }<br/><br/>    func store(_ image: UIImage, for url: URL) {<br/>        imageStore[url] = image<br/>    }<br/>}</span></pre><p id="4295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe nj nk nl na b">ImageCache</code>类负责缓存给定URL的图像。我们有一个向缓存中添加图像的方法和一个从缓存中检索图像的方法。</p><p id="87b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本例，我们将存储SwiftLee徽标，以便稍后可以用下标检索它。如果您正在编写这些代码，您可能希望对自己的图像做同样的事情。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3660" class="ne md it na b gy nf ng l nh ni">let swiftLeeLogo = UIImage(named: "logo_256x256.jpg")!<br/>let swiftLeeURL = URL(string: "https://www.avanderlee.com/logo.png")!<br/>ImageCache.shared.store(swiftLeeLogo, for: swiftLeeURL)</span></pre><p id="6bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">在这个例子中，我们静态缓存一个自定义URL的图像。通常，您会基于使用</em> <code class="fe nj nk nl na b">URLSession</code> <em class="nm">处理的实际图像请求来实现这样的缓存，并保存响应图像。</em></p><p id="4fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经设置了我们的图像缓存，我们可以开始编写我们的第一个自定义下标。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fff2" class="ne md it na b gy nf ng l nh ni">extension ImageCache {<br/>    subscript(url: URL) -&gt; UIImage? {<br/>        imageStore[url]<br/>    }<br/>}</span></pre><p id="fc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来非常简单:</p><ul class=""><li id="07ce" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">它通过使用<code class="fe nj nk nl na b">subscript</code>方法名来定义自定义下标。</li><li id="ce6c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">下标接受一个URL作为输入。</li><li id="b2d2" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">结果将是一个图像，如果它存在的话。</li></ul><p id="6e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们基本上利用了之前定义的图像存储。这个图像存储是一个字典，它将URL作为键，将图像作为值。这提供了一种基于URL获取图像的简单方法。</p><p id="00f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以如下使用这个下标:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b254" class="ne md it na b gy nf ng l nh ni">let swiftLeeURL = URL(string: "https://www.avanderlee.com/logo.png")!<br/>let image = ImageCache.shared[swiftLeeURL]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2dea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">做一个读写下标</h1><p id="17ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面的下标示例只允许您检索值，并且可以被视为只读下标。通过添加<code class="fe nj nk nl na b">get</code>和<code class="fe nj nk nl na b">set</code>闭包，我们可以很容易地使这个下标可写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e440" class="ne md it na b gy nf ng l nh ni">extension ImageCache {<br/>    subscript(url: URL) -&gt; UIImage? {<br/>        get {<br/>            imageStore[url]<br/>        }<br/>        set {<br/>            imageStore[url] = newValue<br/>        }<br/>    }<br/>}</span></pre><p id="f3a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致我们现在可以通过使用下标来存储新图像:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4c91" class="ne md it na b gy nf ng l nh ni">let avatarImage = UIImage(named: "avatar.jpg")!<br/>let avatarURL = URL(string: "https://www.avanderlee.com/avatar.png")!<br/><br/>ImageCache.shared[avatarURL] = avatarImage</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e8e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义静态下标</h1><p id="833e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">静态下标允许您通过在静态类型上使用下标来编写快捷方式。这允许您公开更少的实例。</p><p id="96f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的图像缓存示例中，我们通过定义<code class="fe nj nk nl na b">shared</code>属性定义了一个共享实例。如果没有静态下标，我们必须总是通过共享属性来访问下标:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4622" class="ne md it na b gy nf ng l nh ni">ImageCache.shared[swiftLeeURL]</span></pre><p id="3f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也要求我们公开<code class="fe nj nk nl na b">shared</code>属性，尽管这可能不是一开始的本意。</p><p id="4f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过定义一个静态下标来解决这个问题，在这个下标中我们访问共享实例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0cb2" class="ne md it na b gy nf ng l nh ni">extension ImageCache {<br/>    static subscript(url: URL) -&gt; UIImage? {<br/>        get {<br/>            shared.imageStore[url]<br/>        }<br/>        set {<br/>            shared.imageStore[url] = newValue<br/>        }<br/>    }<br/>}</span></pre><p id="ad10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码几乎是一样的。事实上，我们唯一改变的是添加了static关键字，并通过<code class="fe nj nk nl na b">shared</code>属性访问了<code class="fe nj nk nl na b">imageStore</code>。</p><p id="5c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以将<code class="fe nj nk nl na b">shared</code>属性设为私有，并通过静态下标检索URL的图像:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bcd1" class="ne md it na b gy nf ng l nh ni">// Without the static subscript:<br/>let image = ImageCache.shared[swiftLeeURL]<br/>ImageCache.shared[swiftLeeURL] = newImage<br/><br/>// With the static subscript:<br/>let image = ImageCache[swiftLeeURL]<br/>ImageCache[swiftLeeURL] = newImage</span></pre><p id="c649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，并且允许我们尽可能少地暴露实现细节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向下标添加可选参数</h1><p id="c1fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下标中的可选参数允许您添加额外的功能。例如，我们可以只根据基本URL获取图像:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4558" class="ne md it na b gy nf ng l nh ni">extension ImageCache {<br/>    subscript(url: URL, useBaseURL: Bool = false) -&gt; UIImage? {<br/>        if useBaseURL {<br/>            return imageStore.first { (storedImage) -&gt; Bool in<br/>                storedImage.key.baseURL == url.baseURL<br/>            }?.value<br/>        } else {<br/>            return imageStore[url]<br/>        }<br/>    }<br/>}</span></pre><p id="bb71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">请注意，我们将此下标设为只读，因为我们不想让图像缓存的用户只为基本URL保存图像。最好为特定的URL保存一个图像。</em></p><p id="071b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以仅使用基本URL检索相同的已存储SwiftLee徽标:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2bbe" class="ne md it na b gy nf ng l nh ni">let image = ImageCache.shared[URL(string: "https://www.avanderlee.com")!, true]<br/><br/>// Passing false will try to find an image for the exact URL, which fails as we did not store an image for that URL.<br/>let nilImage = ImageCache.shared[URL(string: "https://www.avanderlee.com")!, false]</span></pre><p id="bd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是向自定义下标添加额外功能的好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d978" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="1d73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自定义下标是一种很好的方式，可以让您的代码更具可读性，同时披露更多的实现细节。下标可用于整个Swift库，例如数组和集合，并为您提供设置和检索值的快捷方式。您可以在结构、类和枚举上定义自定义下标。</p><p id="96c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>