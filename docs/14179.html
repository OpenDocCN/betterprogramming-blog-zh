<html>
<head>
<title>Solving Dogpile Effect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决狗堆效应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-dogpile-effect-9d869174d302?source=collection_archive---------9-----------------------#2022-11-14">https://betterprogramming.pub/solving-dogpile-effect-9d869174d302?source=collection_archive---------9-----------------------#2022-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1481" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在高容量情况下缓存</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b421389df4a4160c38248b1584af26dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RDbkGUsUcA0pzMjr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jneumeyer" rel="noopener ugc nofollow" target="_blank">朱迪·纽迈耶</a>在<a class="ae kv" href="https://unsplash.com/photos/ECjHeJtRznQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f751" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们之前讨论过缓存一致性，当时我们提到，如果我们正确地实现了旁读缓存，就有可能实现良好的一致性。为了进一步提高一致性，必须使用更复杂的解决方案，例如通过缓存写入或缓存后写入。</p><ul class=""><li id="995b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720" rel="noopener">缓存和数据库之间的一致性，第1部分</a></li><li id="5790" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3" rel="noopener">缓存和数据库之间的一致性，第2部分</a></li></ul><p id="b890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将讨论另一个常见的缓存场景，狗堆效应。</p><p id="6c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">狗桩效应意味着当系统处于高流量下时，无论何时缓存失效，无论是清理还是超时，都会产生巨大的影响。</p><p id="4bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如一个缓存条目同时被100个请求访问，一旦条目过期，100个请求就会直接命中后端系统，这对后端系统是一个严峻的挑战。</p><p id="d5de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们看看有什么方法可以处理狗堆效应。有以下三种常见的方法。</p><ol class=""><li id="9b04" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">预热缓存</li><li id="a3b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">延长缓存时间</li><li id="7a19" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">互锁</li></ol><p id="adea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三种选择各有利弊，事实上，它们已经被广泛使用。</p><blockquote class="mh mi mj"><p id="4263" class="kw kx mk ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated"><em class="iq">问题，你知道</em> Ruby on Rails <em class="iq">中的</em> <code class="fe mo mp mq mr b"><em class="iq">race_condition_ttl</em></code> <em class="iq">是哪个吗？</em></p></blockquote><h1 id="2382" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">预热缓存</h1><p id="70e4" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在讨论这种方法之前，让我们先来回顾一下旁读缓存的读取路径。</p><ol class=""><li id="b5ae" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">首先，所有读取请求都是从缓存中读取的。</li><li id="d368" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">如果缓存读取失败。</li><li id="79e7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">然后从数据库中读取，并写回缓存。</li></ol><p id="b7ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当缓存未命中时，会出现问题。</p><p id="cb26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当高容量系统下有大量读请求时，会导致大量的数据库访问。如果我们无论如何都可以保持缓存活动，难道不能解决狗堆效应吗？</p><p id="a19b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，该方法是用周期性更新所有高速缓存的后台线程来替换高速缓存TTL，例如，如果高速缓存TTL是5分钟，则每5分钟更新所有高速缓存，使得不再遇到高速缓存无效。</p><p id="b838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这种方法有其缺点。</p><ol class=""><li id="a01a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">如果应用于所有缓存条目，它的空间效率非常低。</li><li id="0ce3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">在某些极端情况下，缓存仍然会失效，比如由缓存本身触发的驱逐。</li></ol><p id="ed50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个简单而残酷的方法，但我不得不说它在某些情况下非常有效。如果我们有一个必须处理大量流量的关键缓存，并且更新的成本很高，那么保持缓存新鲜是最有效的方法。</p><p id="27ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要我们避免更新所有缓存条目，它就不会占用太多空间，也不太可能触发极限情况。</p><h1 id="f7fd" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">延长缓存时间</h1><p id="3c48" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">预热缓存可以在特定的关键缓存上很好地工作，但是如果根本没有定义关键缓存，那么预热的好处就不能有效地应用。</p><p id="5113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，第二种方法适用于一般用途。</p><p id="c54f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">读取缓存时，如果发现缓存超时，则稍微延长缓存时间并开始更新缓存。如果有并发读取请求，后面的读取请求将使用延长的时间读取缓存，以避免同时访问后端数据库。</p><p id="5fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设缓存TTL为5分钟，我们将每个缓存设置为一分钟的扩展时间，如下图甘特图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0102916fa94205f9087111686128d9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3PfOREet6DOBKdNoI7Ukg.png"/></div></div></figure><p id="539e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在时间间隔0–5，读取缓存将获得原始值。如果有人在时间间隔5–6期间读取，尽管缓存过期，但缓存将被扩展，因此原始值仍然可用。但同时，第一个在区间5–6读取的人必须负责更新缓存，所以在时间点6之后，缓存会更新为新值。</p><p id="8f31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一个序列图来表示这两个并发请求场景。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/25a76d23dea31361b6c128c0f2cc7ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*Ct1Gead4Mz060ScHgw-c3g.png"/></div></figure><p id="a6c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设缓存已经超时。当<code class="fe mo mp mq mr b">A</code>取值时，发现缓存已经超时，于是先将原始值写回缓存并执行常规的读操作从数据库中取值，最后将新值写回缓存。</p><p id="f848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe mo mp mq mr b">B</code>在读取的时候发现缓存并没有过期，因为缓存是扩展的，所以可以得到原来的值。</p><p id="29d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法，只有一个<code class="fe mo mp mq mr b">N</code>并发请求需要访问后端，其余的<code class="fe mo mp mq mr b">N - 1</code>请求仍然可以从缓存中获取值。</p><div class="nr ns gp gr nt nu"><a href="https://github.com/rails/rails/blob/e5f3d692030b41ed5ac671fedc9cc268b13ebd40/activesupport/lib/active_support/cache.rb#L849" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">位于e5f3d 692030 b41ed 5 AC 671 fedc 9 cc 268 b 13 EBD 40 rails/rails的rails/cache.rb</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><p id="7c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，<em class="mk"> Ruby on Rails </em>的<code class="fe mo mp mq mr b">race_condition_ttl</code>就是这个实现。上面链接中的855和856行是延长缓存时间的操作。</p><p id="4166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法看起来是处理高流量的有效方法，只需要一个访问后端的请求，对吗？</p><p id="af14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是，不，不尽然。</p><p id="9f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当面对高并发场景时，这显然是无用的。让我们继续用顺序图来描述这个问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/67e4b7ccde67e67f6ab926ff3ee33789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NfKSOns_sXAuXcgXr_Umw.png"/></div></div></figure><p id="a3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和之前一样的<code class="fe mo mp mq mr b">A</code>和<code class="fe mo mp mq mr b">B</code>，但是这次<code class="fe mo mp mq mr b">A</code>和<code class="fe mo mp mq mr b">B</code>发生的距离非常近。从时序图中可以看出，<code class="fe mo mp mq mr b">A</code>试图将原值写回缓存时，<code class="fe mo mp mq mr b">B</code>已经发生了，所以<code class="fe mo mp mq mr b">B</code>也觉得自己是第一个。</p><p id="7f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mo mp mq mr b">N</code>请求完全同时到达时，这样的实现仍然不能解决Dogpile效应。</p><h1 id="d9fb" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">互锁</h1><p id="9361" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">延长缓存时间似乎已经解决了大多数问题，但在高并发系统中仍然不够好。因此，我们需要一种方法来序列化高并发场景。之前，我们介绍了独占锁的概念。</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/redis-as-a-lock-are-you-sure-a870c9f22ad8"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">雷迪斯锁定了！你确定吗？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">你说的锁是专属锁还是壁垒？</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">better编程. pub</p></div></div><div class="od l"><div class="ok l of og oh od oi kp nu"/></div></div></a></div><p id="b7d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，我们试图通过排他锁来避免多个并发请求通过缓存。</p><p id="5407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在更新缓存之前，必须获得一个排他锁。只有那些可以获得锁的人才有资格更新缓存，即访问数据库，而其余没有获得锁的人必须等待以下两个条件之一。</p><ol class=""><li id="2c30" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">缓存是否已更新</li><li id="a9e9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">锁是否可以被获取</li></ol><p id="f0c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待获取锁还必须验证缓存是否已经更新，以进一步避免重复的数据库访问。</p><p id="8f0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这种方法有一个明显的缺点。使并发进程可序列化将显著降低并发性。此外，等待是额外的开销，不仅消耗资源，还会影响性能。</p><p id="758f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得一提的是，我们常说Redis不可靠，那么在这种场景下，是否有必要使用Redlock进一步提高可靠性？</p><p id="c3f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看情况。</p><p id="0477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，不会，即使Redis不够可靠，不能准确地使用一次，在这种情况下很少发生泄漏也不是问题。这种场景不需要很强的一致性，最多只需要对数据库进行几次访问。</p><h1 id="e9f5" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="3637" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">为了解决缓存的一个常见问题——狗堆效应，我们回顾了三种常见的方法。</p><p id="4981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预热缓存适用的场景是“关键缓存”。一旦我们可以缩小缓存的范围，那么保持它的新鲜对我们来说就是最直观最简单的方法。</p><p id="9f73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延长缓存时间是一种通用的方法，可以有效地处理各种高容量的情况。通过提供时间缓冲，允许缓存长时间服务，直到缓存被“某人”更新。</p><p id="fd14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">排他锁是一种高并发专门化方法。为了避免并发请求冲击后端系统，并发请求通过一个可序列化的机制被转化为顺序请求。</p><p id="b89a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三种方法各有各的优点和好处，但事实上，延长缓存时间和排他锁可以组合成一个整体解决方案。我将在下一篇文章中用代码解释其实现细节。</p><p id="4e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止吧。</p></div></div>    
</body>
</html>