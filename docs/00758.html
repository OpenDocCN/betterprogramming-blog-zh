<html>
<head>
<title>React.Memo vs Memoize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">做出反应。备忘录vs记忆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-memo-vs-memoize-71f85eb4e1a?source=collection_archive---------5-----------------------#2019-07-10">https://betterprogramming.pub/react-memo-vs-memoize-71f85eb4e1a?source=collection_archive---------5-----------------------#2019-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c25b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有什么区别，什么时候使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4c1837ff3c852d12b4beb1698ee4099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5xH1XNmeaDPzfRWt18HYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com/search/photos/memo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="15f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候快速探究一下记忆库(在我们的例子中是<a class="ae ky" href="https://github.com/alexreardon/memoize-one" rel="noopener ugc nofollow" target="_blank"> memoize-one </a>)和<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>提供的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">memo</a></code>函数之间的区别了。</p><p id="a8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，memoize-one在这个例子中是一个任意的库。我们可以选择任何记忆库，比如<a class="ae ky" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>、<a class="ae ky" href="https://lodash.com/docs/4.17.11#memoize" rel="noopener ugc nofollow" target="_blank"> lodash </a>或<a class="ae ky" href="https://ramdajs.com/docs/#memoizeWith" rel="noopener ugc nofollow" target="_blank"> ramda </a>。Memoize-one是一个很小的库，只存储最新的论点和结果。为了理解这一点，让我们跳到记忆是什么意思。</p><p id="8ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，<em class="lz">记忆</em>或<em class="lz">记忆</em>是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Optimization_(computer_science)" rel="noopener ugc nofollow" target="_blank">优化</a>技术，主要用于通过存储昂贵的<a class="ae ky" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">函数调用</a>的结果并在相同的输入再次出现时返回缓存的结果来加速<a class="ae ky" href="https://en.wikipedia.org/wiki/Computer_programs" rel="noopener ugc nofollow" target="_blank">计算机程序</a>。</p><p id="9902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将其分解为一个代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ef3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，这是一个有点武断的例子，因为这种计算非常便宜。但是想象一下，如果执行更加频繁，包括清理数据或映射属性——这个计算可能需要一些时间。如果我们的函数被记忆，我们可以识别出这些参数之前已经被传入，因此返回结果。</p><p id="f3a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们当前的示例重新运行该函数，让我们用memoize-one来尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行这段代码，它会打印出如下内容:</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="8932" class="mg mh it ly b gy mi mj l mk ml">add<br/>3<br/>3</span></pre><p id="cc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该是意料之中的。第一次调用add函数时，我们以前从未运行过它。所以我们像往常一样遍历函数，我们打印出字符串<code class="fe lv lw lx ly b">add</code>,然后打印结果。但是第二次，我们已经运行了函数，所以我们从来没有真正进入函数，也从来没有再次打印出<code class="fe lv lw lx ly b">add</code>字符串。</p><p id="a64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这指出了使用记忆功能时的一个基本规则。你应该只对纯函数使用记忆化。就我们的目的而言，我们的函数中不应该有副作用。给定一个函数的一组参数，我们应该总是期待相同的结果。</p><p id="f501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个不成立的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的结果看起来像:</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="da63" class="mg mh it ly b gy mi mj l mk ml">seAdd<br/>4<br/>4<br/>4</span></pre><p id="0e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在作用域函数之外使用了一个变量。这意味着这个函数不纯。最终的数字应该是5，但是由于输入是相同的，并且库假设这个函数是纯函数，所以它从不运行内部代码，并将原始的、<em class="lz">不正确的</em>结果返回给我们。</p><p id="a367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于纯函数的更深入的描述，<a class="ae ky" href="https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/" rel="noopener ugc nofollow" target="_blank">查看这篇伟大的文章</a>。</p><h1 id="602c" class="mm mh it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">备忘录呢？</h1><p id="7c8b" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">什么是反应备忘录？我们将特别关注<code class="fe lv lw lx ly b">memo </code>函数，它旨在包装一个功能组件。</p><p id="68bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个类似于前面函数的Add组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您希望在控制台中打印什么？我们提供了相同的道具，做了与memoize-one add函数相似的数学运算。嗯，结果是这样的:</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="297f" class="mg mh it ly b gy mi mj l mk ml">component rendered<br/>component rendered<br/>component rendered</span></pre><p id="4645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>您的可能有一个带圆圈的三，而不是单独的打印。</p><p id="b9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么它三次都运行组件，而每次的输入都是一样的？嗯，<code class="fe lv lw lx ly b">React.memo</code>确实试图做记忆化，但不是对组件生成，而是对组件实例。也就是说，对于一个给定的组件，如果有试图渲染同一个组件，但道具没有改变，我们反而会渲染出和上次一样的结果。</p><p id="8263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/e956ff4bfdd73846dd6c544d34f60601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UrkKxuMn-CmsudYoPhFOcQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每次单击都会触发父对象中的渲染</p></figure><p id="a6f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，尽管父组件被重新渲染，内部组件实际上从未重新渲染。这是因为它有相同的道具，所以它只是返回前面的结果。</p><h1 id="eb1f" class="mm mh it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结束语</h1><p id="e3a5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">因此，memoize-one(与大多数memoization库一样)用一组参数记住给定函数的结果，不管最后一次执行发生在哪里。另一方面，React.memo用于在试图重新渲染时记忆组件的单个事件，并且它将不能在它的实例之外工作。</p><p id="6fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束快速浏览之前，我想指出有一个新的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code>钩子，它的工作方式类似于memoize-one，目的是在功能组件的上下文中记忆给定的函数。事实上，它可以与React.memo结合使用，以记忆组件和任何内部函数。我们可以改天再深入探讨，但我希望这能消除一点困惑。</p><p id="1ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天这里使用的所有代码都可以在Github 上获得。</p><h1 id="95c1" class="mm mh it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">参考资料和进一步阅读</h1><p id="6c39" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usememo</a></p><p id="6026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/DennyScott/memo-vs-memoize" rel="noopener ugc nofollow" target="_blank">https://github.com/DennyScott/memo-vs-memoize</a></p><p id="6207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/what-is-a-pure-function-in-JavaScript-ACB 887375 dfe/</a></p><p id="a11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">https://github.com/reduxjs/reselect</a></p><p id="26e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://lodash.com/docs/4.17.11#memoize" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.11#memoize</a></p><p id="5c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://ramdajs.com/docs/#memoizeWith" rel="noopener ugc nofollow" target="_blank">https://ramdajs.com/docs/#memoizeWith</a></p><p id="fe02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html#reactmemo</a></p><p id="4754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/alexreardon/memoize-one" rel="noopener ugc nofollow" target="_blank">https://github.com/alexreardon/memoize-one</a></p></div></div>    
</body>
</html>