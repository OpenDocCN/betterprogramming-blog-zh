<html>
<head>
<title>Reducer in JavaScript: A Simple yet Powerful Array Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Reducer:一个简单而强大的数组方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reducer-in-javascript-a-simple-yet-powerful-array-method-108c74b4c888?source=collection_archive---------12-----------------------#2021-02-16">https://betterprogramming.pub/reducer-in-javascript-a-simple-yet-powerful-array-method-108c74b4c888?source=collection_archive---------12-----------------------#2021-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f1f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解这个基本JavaScript数组函数的来龙去脉</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/750431f5ccfb1bec004d3a47c9a3e79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKgPrABi1HogqCHyaU0VNw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="5cd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript的<code class="fe lu lv lw lx b">reducer</code>是开发人员最有用的数组方法之一。在ES5中引入，它有点类似于用于数组的<code class="fe lu lv lw lx b">for…each</code>和<code class="fe lu lv lw lx b">map</code>方法，但是在特定情况下改进了它们的性能和简单性。</p><p id="5cca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">reduce</code>方法执行我们为存储在数组中的每个元素提供的回调函数，并输出操作生成的最终值。这是一种迭代和处理存储在数组中的数据的更干净的方式。</p><p id="371f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，所有主流浏览器版本都支持它<a class="ae ly" href="https://caniuse.com/mdn-javascript_builtins_array_reduce" rel="noopener ugc nofollow" target="_blank">,并且从10.0版本开始，Node.js就可以使用它了。</a></p><p id="f5e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将探索<code class="fe lu lv lw lx b">reduce</code>方法。我们将介绍在不同的场景中，您应该如何以及何时使用<code class="fe lu lv lw lx b">reducer</code>。</p><p id="9608" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="768d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JavaScript减少方法参数</h1><p id="5fc8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><code class="fe lu lv lw lx b">reduce</code>方法接受两个参数:一个用作回调的数组的<code class="fe lu lv lw lx b">reducer</code>函数和一个可选的<code class="fe lu lv lw lx b">initialValue</code>参数。reducer函数有四个参数:<code class="fe lu lv lw lx b">accumulator</code>、<code class="fe lu lv lw lx b">currentValue</code>、<code class="fe lu lv lw lx b">currentIndex</code>和<code class="fe lu lv lw lx b">array</code>。</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="e9cc" class="nh mh it lx b gy ni nj l nk nl">arr.reduce(callback( accumulator, currentValue, [, index[, array]] )[, initialValue])</span></pre><p id="00b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是JavaScript数组<code class="fe lu lv lw lx b">reduce</code>方法的一个实例:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="e280" class="nh mh it lx b gy ni nj l nk nl">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; accumulator + currentValue);</span></pre><p id="a10a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe lu lv lw lx b">reduce</code>方法与下面的<code class="fe lu lv lw lx b">for…each</code>循环做同样的工作，但是代码行更少:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="7b2b" class="nh mh it lx b gy ni nj l nk nl">const array = [0, 1, 2, 3, 4];</span><span id="5a43" class="nh mh it lx b gy nm nj l nk nl">let total = 0<br/>array.forEach(num =&gt; {<br/>  total += num<br/>});</span></pre><p id="a5cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这些参数，<code class="fe lu lv lw lx b">reduce</code>方法是如何实现的？</p><p id="b714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由<code class="fe lu lv lw lx b">reducer</code>函数返回的值被分配给<code class="fe lu lv lw lx b">accumulator</code>变量。在数组项的每次迭代中，<code class="fe lu lv lw lx b">accumulator</code>的值被更新为返回的结果。迭代结束时，<code class="fe lu lv lw lx b">accumulator</code>的最终值作为<code class="fe lu lv lw lx b">reduce</code>函数的输出返回。</p><p id="881b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果传递了一个<code class="fe lu lv lw lx b">initialValue</code>参数，第一次执行<code class="fe lu lv lw lx b">reducer</code>函数时，<code class="fe lu lv lw lx b">accumulator</code>将等于<code class="fe lu lv lw lx b">initialValue</code>，<code class="fe lu lv lw lx b">currentValue</code>将等于数组中存储的第一个元素。如果没有通过<code class="fe lu lv lw lx b">initialValue</code>，则<code class="fe lu lv lw lx b">accumulator</code>将等于数组的第一个值，而<code class="fe lu lv lw lx b">currentValue</code>将等于第二个值。</p><p id="e14d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，让我们看看每次调用回调函数时，这些参数的值是如何变化的。这里，我们不传递一个<code class="fe lu lv lw lx b">initialValue</code>参数:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="a30b" class="nh mh it lx b gy ni nj l nk nl">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; accumulator + currentValue);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f86c9ca8379df8fd096cb0a6471f2c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPzOf5nklwMYylgUd2obBg.png"/></div></div></figure><p id="e2d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数的最终输出是<code class="fe lu lv lw lx b">10</code>。</p><p id="ecb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们看看当一个<code class="fe lu lv lw lx b">initialValue</code>被传递时它是如何工作的:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="1be3" class="nh mh it lx b gy ni nj l nk nl">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; accumulator + currentValue, 12);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/e68309acdf82b20c2cf1382279c763b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARzE5dU5oQy9RCGOE3m-Gg.png"/></div></div></figure><p id="6bcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数输出值<code class="fe lu lv lw lx b">22</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8787" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">何时使用减速器</h1><p id="c1ec" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><code class="fe lu lv lw lx b">reduce</code>方法提供了一种独特的方法来遍历数组中的项目并处理它们。那么在什么情况下我们可以从这种独特性中获益呢？</p><h2 id="7cb9" class="nh mh it bd mi np nq dn mm nr ns dp mq lh nt nu ms ll nv nw mu lp nx ny mw nz bi translated">计算数组中值的总和</h2><p id="03b4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">这类似于我们在前面的例子中所做的。唯一的区别是我们必须为<code class="fe lu lv lw lx b">initialValue</code>参数传递<code class="fe lu lv lw lx b">0</code>:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="f3fa" class="nh mh it lx b gy ni nj l nk nl">let total = [34, 12, 143, 13, 76].reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);</span></pre><h2 id="db46" class="nh mh it bd mi np nq dn mm nr ns dp mq lh nt nu ms ll nv nw mu lp nx ny mw nz bi translated">展平数组</h2><p id="d99f" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如果我们有一个数组的数组，我们可以使用<code class="fe lu lv lw lx b">reduce</code>方法将其展平，并创建一个没有嵌套数组的单个数组:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="8938" class="nh mh it lx b gy ni nj l nk nl">let array = [[0, 1], [2, 3], [4, 5], [5, 6]];</span><span id="bb56" class="nh mh it lx b gy nm nj l nk nl">let flattenedArray = array.reduce((accumulator, currentValue) =&gt; accumulator.concat(currentValue), []);</span></pre><p id="d044" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们传递一个空数组作为初始值，这样第一个数组中的项目就与它连接在一起，创建一个扁平的数组。</p><p id="6a4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果第一个数组有不止一层的嵌套数组，我们可以递归地调用<code class="fe lu lv lw lx b">reduce</code>函数来展平它们，然后将它们与最终的数组连接起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="690b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果回调函数接受的当前值是一个数组，正如使用<code class="fe lu lv lw lx b">isArray</code>方法验证的那样，我们递归调用它的<code class="fe lu lv lw lx b">flattenArray</code>函数。如果当前值不是一个数组，我们只需将该值与最终的扁平数组连接起来。</p><h2 id="1652" class="nh mh it bd mi np nq dn mm nr ns dp mq lh nt nu ms ll nv nw mu lp nx ny mw nz bi translated">按属性对对象数组进行分组</h2><p id="e1fc" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">让我们假设我们有一个国家对象数组。我们希望根据所在的洲对阵列中的每个国家进行分组。我们可以使用<code class="fe lu lv lw lx b">reduce</code>方法来完成这项任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="03ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在回调函数中，我们为不在<code class="fe lu lv lw lx b">groupedCountries</code>地图中的每个洲创建一个新键，并为其赋值一个空数组。然后，我们将每个国家对象推送到由它们各自的洲存储的数组中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8fd2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用reduce()代替filter()。地图()</h1><p id="8875" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在JavaScript中，我们使用<code class="fe lu lv lw lx b">filter</code>方法通过回调来过滤存储在数组中的项目。我们使用<code class="fe lu lv lw lx b">map</code>方法使用旧数组创建一个新数组，使用回调中传递的逻辑。有时我们不得不一个接一个地使用这两种方法来创建一个新的数组，其中包含我们使用某些条件过滤的结果。</p><p id="a793" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用JavaScript <code class="fe lu lv lw lx b">array reduce</code>方法来完成相同的任务，而不是使用两个数组方法。这将减少完成时间，因为现在您只需遍历数组一次，而不是两次。</p><p id="1cbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们以下面的场景为例，我们希望创建一个大于30的数字的平方根数组:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="ca12" class="nh mh it lx b gy ni nj l nk nl">let numbers = [3, 21, 34, 121, 553, 12, 53, 5, 42, 11];</span><span id="a74d" class="nh mh it lx b gy nm nj l nk nl">let newArray = numbers.filter(number =&gt; number &gt; 30).map(number =&gt; Math.sqrt(number));</span></pre><p id="a78c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">reduce</code>实现的相同场景如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b80e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在回调函数中，我们简单地检查数字是否大于30，并将它的平方根加到<code class="fe lu lv lw lx b">accumulator</code>数组中。你必须传递一个空数组作为初始值来得到这个结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a8b8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">构建您自己的减速器</h1><p id="0a92" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在本节中，我们将自己实现<code class="fe lu lv lw lx b">reducer</code>函数，看看它是如何工作的。这将让您更好地了解何时使用<code class="fe lu lv lw lx b">reducer</code>来优化程序性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="2e5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们检查是否在空或未定义的对象上调用了<code class="fe lu lv lw lx b">reduce</code>方法。然后我们检查传递的回调是否是一个函数。</p><p id="1c1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在初始类型检查之后，我们将传递的<code class="fe lu lv lw lx b">initialValue</code>分配给<code class="fe lu lv lw lx b">accumulator</code>。然后我们遍历数组，并为数组中的每一项调用回调函数。在执行结束时，我们必须返回<code class="fe lu lv lw lx b">accumulator</code>值。</p><p id="be22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用这个实现只是为了帮助你理解<code class="fe lu lv lw lx b">reduce</code>方法实际上是如何工作的。例如，您可以看到它使用了一个<code class="fe lu lv lw lx b">for</code>循环来遍历这个数组。</p><p id="0ed5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，请注意，您不应该在生产代码中使用这种实现。事实上，将方法原型化为JavaScript标准类型是一种糟糕的编码实践，您永远不应该沉迷于此。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="3350" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在本文中，我们讨论了最有用的JavaScript数组方法之一:<code class="fe lu lv lw lx b">reducer</code>。我们讨论了如何以及何时使用它，甚至从头开始构建了我们自己的<code class="fe lu lv lw lx b">reduce</code>方法。</p><p id="ec14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这些知识能帮助你在将来识别出可以通过使用<code class="fe lu lv lw lx b">reducer</code>解决的问题。其中一些用例与<code class="fe lu lv lw lx b"><a class="ae ly" href="https://livecodestream.dev/post/javascript-foreach-powered-array-for-loop/" rel="noopener ugc nofollow" target="_blank">forEach</a></code>、<code class="fe lu lv lw lx b">map</code>和<code class="fe lu lv lw lx b">filter</code>数组方法重叠，因此您应该知道如何选择可以使用<code class="fe lu lv lw lx b">reduce</code>方法最佳解决的情况。</p></div></div>    
</body>
</html>