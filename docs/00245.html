<html>
<head>
<title>Adding CVE Scanning to a CI/CD Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将CVE扫描添加到CI/CD管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-cve-scanning-to-a-ci-cd-pipeline-d0f5695a555a?source=collection_archive---------0-----------------------#2018-12-14">https://betterprogramming.pub/adding-cve-scanning-to-a-ci-cd-pipeline-d0f5695a555a?source=collection_archive---------0-----------------------#2018-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/e46aac6948a8653efe4143119f89fe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51hwpAU3rZpq0VN0YjAEVQ.jpeg"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">图片来源——【https://cve.mitre.org/ T2】</p></figure><h1 id="074e" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="de13" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Docker映像包含一个应用程序及其所有依赖项。因为它还包含操作系统的许多二进制文件和库，所以确保其根文件系统中不存在漏洞非常重要——至少没有关键或主要的漏洞。扫描CI/CD管道中的映像可以确保这一额外的安全级别。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c1ac" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">一个简单的项目</h1><p id="5650" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在之前的一篇文章中，我详细介绍了我如何使用<a class="mk ml ep" href="https://medium.com/u/68f5136d3254?source=post_page-----d0f5695a555a--------------------------------" rel="noopener" target="_blank"> GitLab </a>、<a class="ae kb" href="https://portainer.io" rel="noopener ugc nofollow" target="_blank"> Portainer </a>和<a class="ae kb" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>在一个非常简单的项目上建立CI/CD管道。</p><div class="mm mn gp gr mo mp"><a href="https://medium.com/lucjuggery/even-the-smallest-side-project-deserves-its-ci-cd-pipeline-281f80f39fdf" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">即使最小的次要项目也值得拥有CI/CD管道</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jv mp"/></div></div></a></div><p id="b5ac" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">该管道中定义了三个阶段:</p><ul class=""><li id="52a1" class="nj nk it lc b ld ne lh nf ll nl lp nm lt nn lx no np nq nr bi translated">第一个在Node.js代码上运行一些测试。</li><li id="f52d" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">第二个构建一个Docker映像，并在GitLab注册表中发布它。</li><li id="fd14" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">最后一个阶段使用Portainer的webhook特性在Docker Swarm上部署新映像。</li></ul><p id="f6a0" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">TK *entrails*在此过程中构建的Docker映像是基于Nginx 1.14的，并且在没有对其内部进行任何验证的情况下立即部署。这可能是危险的，所以让我们看看我们如何能改善这一点。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="743d" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">向流水线添加图像扫描阶段</h1><p id="d25c" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">有几种图像扫描解决方案；商业和开源。在本文中，我们将使用<a class="ae kb" href="https://github.com/coreos/clair" rel="noopener ugc nofollow" target="_blank">克莱尔</a>和<a class="ae kb" href="https://github.com/arminc/clair-scanner" rel="noopener ugc nofollow" target="_blank">克莱尔扫描仪</a>；两个开源工具。</p><p id="5773" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated"><a class="ae kb" href="https://docs.gitlab.com/ce/ci/examples/container_scanning.html" rel="noopener ugc nofollow" target="_blank">git lab的这份文件</a>提供了添加一个专用于图像扫描的附加平台的所有说明。它基本上运行一个Clair服务器，提供现有的CVEs，然后clair-scanner二进制检查在管道的前一阶段构建的图像的每一层。</p><p id="cf76" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">我已经将附加内容添加到项目的<code class="fe nx ny nz oa b"><a class="ae kb" href="https://gitlab.com/lucj/sophia.events/blob/master/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">.gitlab-ci.yml</a></code>文件中。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="79a6" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">注意:我只对文档中定义的阶段做了一些小的修改，所以它适合我的GitLab runner的版本(这在进行<code class="fe nx ny nz oa b">artifact</code>上传时是需要的)。</p><p id="5026" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">添加了这个新的阶段后，让我们通过运行一个新的管道来看看它是如何进行的。下面的截图显示了这个新的image_sanning阶段的部分输出。</p><figure class="ob oc od oe gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/d36b5a9c35d6303899fdac3c1f5e1616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvOMkTaaKR1H-PwAo6q4UA.png"/></div></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">GitLab管道的图像扫描阶段</p></figure><p id="4137" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">我们可以在顶部看到，图像的每一层都进行了分析。</p><p id="a80f" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">注:如果你想更多地了解一幅图像的内部，并以一种冷静的方式探索每一层，我强烈建议你看看<a class="ae kb" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank">潜水</a>。</p><div class="mm mn gp gr mo mp"><a href="https://github.com/wagoodman/dive" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">瓦格德曼/潜水</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">探索docker图像中每一层的工具。通过在…上创建帐户，为wagoodman/dive发展做出贡献</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="om l na nb nc my nd jv mp"/></div></div></a></div><figure class="ob oc od oe gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi on"><img src="../Images/6e9bf9925d43a99fc4b9659d52361c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYdXKMViSuEHlgrmGZAF4A.png"/></div></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">在CI/CD管道中构建的映像上运行dive</p></figure><p id="adc0" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">回到GitLab输出，我们可以看到检测到100个漏洞。太多了！他们危险吗？嗯，根据<em class="oo">严重性</em>栏中的一些条目判断，可能是严重/高。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7b41" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">我们有很多弱点…现在怎么办？</h1><p id="2324" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">嗯，除非你是一个安全人员，否则那些漏洞可能不会告诉你太多。尽管知道应用程序存在漏洞会引发很多问题:</p><ul class=""><li id="3b6d" class="nj nk it lc b ld ne lh nf ll nl lp nm lt nn lx no np nq nr bi translated">我现在运行这个应用程序安全吗？</li><li id="0cfa" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">哪些漏洞我可以忽略，哪些我要认真对待？</li><li id="645a" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">我的应用程序不是面向用户的，和那些简历放在一起应该是安全的，对吗？即使是对重要的人？</li><li id="934b" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">如果我忽略这些简历，我的老板会知道吗？</li><li id="02db" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">我可以做些简单的事情来降低潜在的风险吗？</li></ul><p id="4af2" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">在某些情况下，实际上有一些简单的步骤会有很大的帮助，我们将在下面看到。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="96ee" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">首先检查基础图像</h1><p id="0561" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我考虑的例子是一个简单的网站，发布了官方的<code class="fe nx ny nz oa b">nginx:1.14</code>图片——在我写这篇文章的时候最后一个稳定的版本。由于Dockerfile使用多阶段构建，所以最终的映像不包含许多用于构建web资产的不必要的Node.js内容。docker文件如下所示。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2b0d" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">多阶段构建已经是一个很好的起点，因为它有助于减少图像的攻击面。但是，最终的<code class="fe nx ny nz oa b">nginx:1.14</code>图像是基于<a class="ae kb" href="https://www.debian.org/" rel="noopener ugc nofollow" target="_blank"> Debian </a>的，所以让我们改变它，使用<code class="fe nx ny nz oa b">nginx:1.14-alpine</code>来代替。</p><p id="b581" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">注意:<a class="ae kb" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine Linux </a>是一个小型发行版，它专注于安全性，暴露的攻击面非常小。使用从Alpine构建的基础图像可能是一个好的举措——我们将对此进行验证。</p><p id="c7d0" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">我们的多阶段docker文件的第二部分现在替换为以下内容。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cf5f" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">让我们触发一个新的构建，看看它如何进行。</p><figure class="ob oc od oe gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi op"><img src="../Images/e9996351141e3430537b921464bda776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JI7S67nY5JforlNYRC0W6Q.png"/></div></div></figure><p id="b3b8" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">嗯，根据上面的截图，一切都很顺利。扫描阶段现在报告… 0个漏洞！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e8a9" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">更新:使用Aquasec Microscanner</h1><p id="6279" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">正如<a class="ae kb" href="https://twitter.com/lach_dev" rel="noopener ugc nofollow" target="_blank">ukasz Lach</a>在下面的Twitter feed中指出的，<a class="ae kb" href="https://www.aquasec.com/" rel="noopener ugc nofollow" target="_blank"> Aquasec </a>提供了自己的CVE扫描仪:<a class="ae kb" href="https://github.com/aquasecurity/microscanner" rel="noopener ugc nofollow" target="_blank"> Aqua Microscanner </a>，并且非常容易使用。谢谢你！</p><figure class="ob oc od oe gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c5a7a5dc2f3bb6780f99549a829c141a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WCSy0wv4uhLEOFOHAacNLQ.png"/></div></figure><p id="780d" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">Microscanner可以用不同的方式扫描图像:在图像创建过程中，或者在图像创建后。</p><h2 id="4b67" class="or kd it bd ke os ot dn ki ou ov dp km ll ow ox kq lp oy oz ku lt pa pb ky pc bi translated">构建图像时扫描</h2><p id="2b96" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">需要在Dockerfile中进行一些更改，以添加并运行microscanner二进制文件，这样它就可以分析已经构建的映像文件系统。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">更新了Dockerfile文件以添加扫描步骤</p></figure><p id="d018" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">该Dockerfile文件中的最后两条指令专用于扫描:</p><ul class=""><li id="5352" class="nj nk it lc b ld ne lh nf ll nl lp nm lt nn lx no np nq nr bi translated">构建指令中需要提供一个令牌(官方文档<a class="ae kb" href="https://github.com/aquasecurity/microscanner" rel="noopener ugc nofollow" target="_blank"> Aqua Microscanner </a>详细说明了如何获得这个令牌)。</li><li id="7312" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">microscanner二进制文件被下载并针对正在创建的映像的文件系统运行。</li></ul><p id="2608" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">这里使用了几个附加选项:</p><ul class=""><li id="b0ed" class="nj nk it lc b ld ne lh nf ll nl lp nm lt nn lx no np nq nr bi translated"><code class="fe nx ny nz oa b">--html</code>生成扫描的html报告</li><li id="f8a9" class="nj nk it lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated"><code class="fe nx ny nz oa b">--continue-on-failure</code>如果发现CVE，不会返回错误代码，也不会停止CI工具的管道</li></ul><h2 id="37fc" class="or kd it bd ke os ot dn ki ou ov dp km ll ow ox kq lp oy oz ku lt pa pb ky pc bi translated">图像建立后立即扫描</h2><p id="49be" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这可以通过添加专用于扫描的done文件来完成。下面提供了此Dockerfile文件的一个示例。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">Dockerfile.microscanner</p></figure><p id="cf8b" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated"><code class="fe nx ny nz oa b">FROM</code>指令指定将要扫描的图像的名称。接下来的两条指令与第一种方法中使用的指令相同(构建图像时扫描)。</p><p id="81a5" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">为了说明第二种方法，我们将在CI流程中添加以下步骤。</p><figure class="ob oc od oe gt ju"><div class="bz fp l di"><div class="of og l"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">微扫描器步骤。gitlab-ci.yaml</p></figure><blockquote class="pd pe pf"><p id="4e99" class="la lb oo lc b ld ne lf lg lh nf lj lk pg ng ln lo ph nh lr ls pi ni lv lw lx im bi translated"><strong class="lc iu">注意</strong>:在同一管道中进行多次图像扫描是没有意义的，这里的目的只是为了说明如何进行这一次扫描，这也有助于在扫描解决方案之间做出选择。</p></blockquote><p id="5746" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">然后我们可以触发一个新的图像构建，一旦图像构建完成，Clair和Microscanner都会扫描它。</p><figure class="ob oc od oe gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi pj"><img src="../Images/913cfa35076539a4eee2b00a0fec15fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSjgMOdz56Ki-UIIxl6cKw.png"/></div></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">克莱尔扫描仪的结果</p></figure><figure class="ob oc od oe gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi pk"><img src="../Images/4cd4541d27f26d91608bc99922999789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyQo2pFmv9GjCicyaSMP0A.png"/></div></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">Aqua Microscanner的结果</p></figure><blockquote class="pd pe pf"><p id="1232" class="la lb oo lc b ld ne lf lg lh nf lj lk pg ng ln lo ph nh lr ls pi ni lv lw lx im bi translated"><strong class="lc iu">注意</strong>:由于这个版本是在本文第一版发布几周后运行的，所以会发现一些以前没有的CVE。</p></blockquote><p id="d3d2" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">有趣的是:扫描的结果是不同的。克莱尔发现了4个CVE，而水微扫描器发现了5个。这说明CVE扫描器的工作方式并不完全相同，例如，它们可能不能在相同版本的CVE数据库上运行，并且可能不能同样好地工作。</p><p id="b38e" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">注意:为了更容易使用microscanner，我们可以使用Docker客户端插件管理器(CLIP)。</p><div class="mm mn gp gr mo mp"><a href="https://github.com/lukaszlach/clip" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">lukaszlach/clip</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">whale: Docker客户端插件管理器——构建新的插件，在Docker Hub上发布它们，或者从……</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="pl l na nb nc my nd jv mp"/></div></div></a></div><p id="d786" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">使用该工具，不再需要使用专用的docker文件进行扫描，因为安装microscan插件后，只需简单的"<em class="oo"> docker microscan" </em>命令即可触发该文件。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a3fb" class="kc kd it bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">摘要</h1><p id="2d47" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这篇短文说明了在现有的CI/CD管道中添加一个简单的图像扫描阶段并不复杂。这提供了额外的信息，例如图像包含的漏洞的数量和id。</p><p id="33d9" class="pw-post-body-paragraph la lb it lc b ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx im bi translated">根据这些信息，仍然很难知道如何处理它们，但是使用从Alpine构建的基础映像是增强应用程序安全性的第一步，不需要了解太多关于CVE的信息。</p></div></div>    
</body>
</html>