<html>
<head>
<title>An In-Depth Guide to Java Records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java记录的深入指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-16-introduces-a-new-language-feature-called-records-267f7ccd3778?source=collection_archive---------3-----------------------#2022-01-11">https://betterprogramming.pub/java-16-introduces-a-new-language-feature-called-records-267f7ccd3778?source=collection_archive---------3-----------------------#2022-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3613" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java 16引入了一个新的语言特性，叫做<strong class="ak">记录</strong>。记录已经是Java 14和15的一部分，但仍在预览版中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ba3deafa9be065de5281429e8b607d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*38TOrkgJXf_VHEUX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@shams_ad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shamsudeen Adedokun </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="d192" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是记录？</h1><p id="4455" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录是定义不可变数据类的一种新型声明。</p><p id="3d41" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它被用来代替类，并允许避免创建<code class="fe mp mq mr ms b">hashCode()</code>、<code class="fe mp mq mr ms b">equals()</code>、<code class="fe mp mq mr ms b">toString()</code>、getters和constructor的常规仪式。</p><p id="91ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于熟悉Scala的人来说——它类似于case类，对于熟悉Project Lombok的人来说，它非常类似于<code class="fe mp mq mr ms b">@Data</code>注释。它允许使用紧凑的语法来提高开发人员的生产力！</p><p id="5f4e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样一个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0326" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用记录语法变成一行程序:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="486b" class="mz kx iq ms b gy na nb l nc nd">record Person(int age, int height) {}</span></pre><p id="e63a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">而且是的，你不能避免结尾的花括号！</p><h1 id="9afc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">记录真的有必要吗？</h1><p id="8bbe" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于我们长期以来习惯于创建数据类，我们大多数人习惯于利用最喜欢的IDE的全部功能来创建所有这些类，即使如果您知道所有的快捷方式，这并不困难，但它会大大降低可读性。</p><p id="0a91" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">明显记录优势的总结:</p><ul class=""><li id="976a" class="ne nf iq lq b lr mk lu ml lx ng mb nh mf ni mj nj nk nl nm bi translated">自动生成的公共构造函数</li><li id="c89d" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">私有不可变(即<code class="fe mp mq mr ms b">final</code>)字段</li><li id="5a7c" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">自动生成的<code class="fe mp mq mr ms b">hashCode()</code>、<code class="fe mp mq mr ms b">equals()</code>和<code class="fe mp mq mr ms b">toString()</code></li><li id="c98e" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">自动生成的getter——对于上面的<code class="fe mp mq mr ms b">Person</code>类示例，相应地应该是<code class="fe mp mq mr ms b">age()</code>和<code class="fe mp mq mr ms b">height()</code>。</li></ul><p id="625e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尽管对任何现代IDE记录的完全支持似乎有点过时，但它们不仅大大增加了可读性，提高了开发人员的性能，而且更重要的是防止了添加新字段后的简单错误。对于IDE生成的方法，如<code class="fe mp mq mr ms b">hashCode()</code>、<code class="fe mp mq mr ms b">equals()</code>、<code class="fe mp mq mr ms b">toString()</code>，我们必须手动更改它们或重新生成它们，以便包含新的字段。这就成了一个大难题。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="52c5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在介绍了记录的基础知识之后，让我们来仔细看看更高级的用法。</p><h1 id="1b12" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">建造师</strong></h1><p id="818a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">默认情况下，记录带有一个初始化所有字段的构造函数，称为规范构造函数。自定义行为可以通过使用紧凑的构造函数传递给此构造函数，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="206c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，紧凑构造函数可用于验证字段——只能抛出<strong class="lq ir"> <em class="nz">未选中的</em> </strong>异常，而不能通过添加<code class="fe mp mq mr ms b">throws</code>声明来声明<strong class="lq ir"> <em class="nz">已选中的</em> </strong>异常。</p><p id="494c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也可以创建自定义构造函数，但是非规范构造函数总是必须委托给另一个构造函数。一个简单的例子如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9bd3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为Java要求调用<code class="fe mp mq mr ms b">this()</code>作为第一条语句，所以被覆盖的构造函数的用例非常有限——传递默认值就是其中之一。</p><p id="4a3e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请记住，紧凑构造函数只是一种语法糖，您仍然可以使用旧的方式为所有字段指定构造函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="de13" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我无法想象这种应用，但我想涵盖所有的目的，让事情变得非常清楚，什么是可能的，什么是不可能的:-)</p><h1 id="8348" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">hashCode()，<code class="fe mp mq mr ms b">equals()</code>和toString()</h1><p id="33da" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我在开始时已经提到，现在自动生成<code class="fe mp mq mr ms b">hashCode()</code>、<code class="fe mp mq mr ms b">equals()</code>和<code class="fe mp mq mr ms b">toString()</code>方法听起来没什么大不了的。使用IDE的全部功能应该会使这变得简单明了。</p><p id="bee0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，首先必须实现这三种方法有几个缺点:</p><ul class=""><li id="57d2" class="ne nf iq lq b lr mk lu ml lx ng mb nh mf ni mj nj nk nl nm bi translated">降低代码可读性——一个类的字段越多，方法就必须越长</li><li id="80bd" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">代码容易出错——很容易遗漏某个字段，尤其是在重构和向类中添加新字段时。如果方法没有重新生成，字段将会丢失，并且可能会引入一个bug。</li><li id="2f4b" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">代码审查很难——您曾经尝试过审查这些方法吗？你有没有一行一行地检查它们，确保没有遗漏任何一个字段？</li></ul><p id="080f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，这些方法可以被覆盖，并且可以提供自定义行为，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="e72d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">不变性</strong></h1><p id="d2d2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如本文开头提到的——记录中的所有字段都是<code class="fe mp mq mr ms b">final</code>,这意味着它们不能被修改。但是，可以在紧凑构造函数中修改字段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1121" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是你不能用<code class="fe mp mq mr ms b">this</code>来引用它们，下面的代码也不会被编译:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c2d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为记录一旦创建就不可改变，所以不能修改。</p><p id="5138" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">没有设置器，因为字段是最终的，所以不能创建设置器。</p><p id="1e1c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唯一的方法是创建一个新对象:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="9544" class="mz kx iq ms b gy na nb l nc nd">Person john = new Person(18, 178);<br/>Person jack = new Person(john.age(), 180);</span></pre><h1 id="9d3d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">实例方法和字段</strong></h1><p id="925f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录允许带有自定义行为的实例方法，我非常鼓励实现带有行为的类。</p><p id="f513" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">紧凑构造函数中的验证是自定义行为的一个示例。</p><p id="c108" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是，最好通过实现实例方法来表达行为，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="db43" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不允许记录定义之外的实例字段，以下代码将不起作用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d049" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有实例字段都必须在标题中指定为组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="6648" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">字段可见性</strong></h1><p id="dbde" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录有一个很大的缺点——每个字段都会创建一个公共getter。</p><p id="7ca7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这当然是有意义的，因为我们在构造函数中提供了它们，但是它使得记录在一定程度上集中于数据而不是行为。</p><p id="e6bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您没有将字段设为私有的选择，以下代码将无法编译:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="9e30" class="mz kx iq ms b gy na nb l nc nd">record Person(private int age, int height) {}</span></pre><p id="f6ac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了比较——在Scala case中，类允许指定自定义的访问修饰符。</p><h1 id="8794" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">序列化</strong></h1><p id="0f7c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录非常适合序列化和反序列化。放弃对<code class="fe mp mq mr ms b">serialVersionUUID</code> <em class="nz"> </em>的要求。</p><p id="279a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">需要注意的是，记录的序列化不同于普通的可序列化或可外部化的对象。</p><p id="43f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记录的序列化不能被定制，任何特定于类的<code class="fe mp mq mr ms b">writeObject</code>、<code class="fe mp mq mr ms b">readObject</code>、<code class="fe mp mq mr ms b">readObjectNoData</code>、<code class="fe mp mq mr ms b">writeExternal</code>和<code class="fe mp mq mr ms b">readExternal</code>方法在序列化和反序列化期间都将被忽略。</p><h1 id="d9df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">静态字段和方法</strong></h1><p id="08b7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">类似地，Java记录中的每个其他类都允许静态(类)方法和字段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="226c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">继承</strong></h1><p id="aa35" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录类是Java世界中的特殊公民。为了更好地理解它，让我们分析一下反汇编的<code class="fe mp mq mr ms b">Person.java</code> <em class="nz"> </em>代码:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="b192" class="mz kx iq ms b gy na nb l nc nd">record Person(int age, int height) {}</span></pre><p id="ba12" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">运行后:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="51c4" class="mz kx iq ms b gy na nb l nc nd">javap Person</span></pre><p id="0c93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您应该会看到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a856" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记录类是<code class="fe mp mq mr ms b">final</code>，所以它们不能被扩展。</p><p id="bbd5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记录也扩展了<code class="fe mp mq mr ms b">java.lang.Record</code>，因为Java不允许多重继承，所以它们不能扩展任何类或抽象类。</p><p id="110c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">实现接口是可能的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="8f92" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在之前的文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/6-things-i-didnt-know-about-java-17-dccd36abaa06">中对Java 17 </a>做了更深入的介绍。感谢阅读。</p></div></div>    
</body>
</html>