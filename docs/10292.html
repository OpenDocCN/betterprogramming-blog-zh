<html>
<head>
<title>Running Virtual Machines Under Vagrant on the New Mac M1 and M2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在新Mac电脑M1和M2上运行虚拟机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-virtual-machines-under-vagrant-on-a-mac-m1-aebc650bc12c?source=collection_archive---------1-----------------------#2021-12-22">https://betterprogramming.pub/managing-virtual-machines-under-vagrant-on-a-mac-m1-aebc650bc12c?source=collection_archive---------1-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2378" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当VirtualBox不再工作时，寻找一个工作的虚拟机替代</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e20556af05b8db55b511ea8dbcef108e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ndPA_jtJrnL17OO6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tma?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">天一马</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="1c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看到了这篇文章，你可能已经升级到一台崭新的Macbook Pro或运行新M1处理器的类似产品。</p><p id="f61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你按下“立即购买”按钮之前，可能没人会告诉你，你用<a class="ae ky" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">vagger</a>和<a class="ae ky" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> Virtualbox </a>精心打造的所有现有x86–64机器将不再运行！</p><h1 id="757a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么不管用？</h1><p id="b1c8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您的虚拟机不再运行的主要原因是VirtualBox在您的Mac上作为虚拟机管理程序运行，依赖底层处理器执行指令，而不是通过软件提供处理器仿真。</p><p id="2913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一点很重要，因为旧的英特尔版本的Mac能够直接在底层硬件上运行x86–64版本的您最喜爱的应用程序。新的M1是一个完全不同的芯片组(ARM ),由于VirtualBox不是一个CPU模拟器，它无法为你运行那些现有的镜像。</p><h1 id="dc50" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">远离VirtualBox</h1><p id="57bb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在2021年底深入研究这个话题后，我觉得可行的选择相对较少。</p><p id="20a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让机器重新运行的“最快”选择是迁移我的VirtualBox。vdi文件转换为开放格式，如. qcow2，并在真正的仿真器下运行，如<a class="ae ky" href="https://getutm.app/" rel="noopener ugc nofollow" target="_blank"> UTM </a>。</p><p id="2057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要以最小的改动快速启动虚拟机，这可能是您的最佳选择。这也可能是Windows VM的唯一真正选择，因为目前还没有可以合法购买并在ARM上运行的Windows商业版本。</p><p id="edba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他有用的文章讨论这个特殊的解决方案，但是在安装UTM之后，您可能正在寻找的命令是这样的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="71a5" class="mx lw it mt b gy my mz l na nb">qemu-img convert -f vdi -O qcow2 myvirtualbox.vdi myreplacementvm.qcow2</span></pre><p id="2a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以连接新的. qcow2磁盘并启动。</p><h2 id="1b7b" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">你为什么不这么做？</h2><p id="64bb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它很慢，比运行虚拟机管理程序慢得多。这是一个令人惊叹的工程，我真的很感谢那些建造它的人，但即使在我的32Gb内存的Macbook Pro上，模拟Windows的运行速度也非常慢。</p><p id="c2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说更重要的是，UTM没有流浪汉的支持。:(</p><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以回到绘图板…</p><h2 id="6732" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">Windows应用程序的补充说明</h2><p id="5307" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我的Windows虚拟机在那里只是为了运行一个不存在于Mac上的Windows应用程序，当Wine在Mac OS上放弃32位仿真后停止运行时，我切换到运行一个完整的虚拟机。</p><p id="1f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那时起，时间在流逝，Codeweavers的奇迹工作者有了一款名为<a class="ae ky" href="https://www.codeweavers.com/crossover/" rel="noopener ugc nofollow" target="_blank"> Crossover </a>的产品，可以在M1 Mac电脑上完美运行。</p><p id="86d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它显然仍然依赖于苹果自己的Rosetta 2，但我的Windows应用程序在我的本机Mac环境中运行迅速，完美无缺。如果你只需要运行一个Windows应用程序，这是你花的最划算的59美元。但是我跑题了..</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="57d1" class="lv lw it bd lx ly nu ma mb mc nv me mf jz nw ka mh kc nx kd mj kf ny kg ml mm bi translated">为流浪者获得支持</h1><p id="caa2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我遇到的最大障碍是让流浪者来支持我运行的虚拟机。我在guest CentOS VM下运行了许多开发环境，而Vagrant和VirtualBox的结合使得按需启动这些环境、共享机器以及让我的主机Mac不受每个项目的影响变得轻而易举。</p><p id="50cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转移到M1阻止了所有这些工作。</p><p id="aefd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然早期，我们看到其他虚拟化提供商，如VMWare和Parallels致力于将在M1上运行的x86仿真。在撰写本文时，它们仍处于早期开发阶段，或者缺乏您期望从VirtualBox获得的支持和功能，或者不被vagger作为提供者支持。</p><p id="51fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最关心的是速度，尤其是在UTM下运行Windows之后。仿真在可执行文件和主机操作系统之间增加了一个复杂的层，使用时可能会牺牲一些速度。</p><p id="fc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的使用情况，这对于您来说可能是可以忽略的或者可以接受的，但是正如您将进一步看到的，我个人在使用仿真时遇到了严重的性能问题。</p><h1 id="1e05" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍Docker</h1><p id="9be6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好了，我说了。</p><p id="5f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker是一个令人惊叹的产品，但它似乎确实与工程师有点爱恨交加的关系。对于这个项目，虽然这是一个不错的选择，特别是如果你按照我下面描述的方式配置它。</p><p id="2bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它当然不是完美的。它不像VirtualBox那样多功能(例如，为您提供主机可访问的虚拟网络)，它不是为在一个容器下运行整个操作系统而设计的，而且它比使用VirtualBox作为提供商更“复杂”。</p><p id="e6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我成功了。</p><h2 id="32f2" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">Docker作为x86–64仿真器</h2><p id="f9e6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您知道Docker将在Mac的M1上运行x86–64映像吗？通过<a class="ae ky" href="https://www.qemu.org/" rel="noopener ugc nofollow" target="_blank"> QEMU </a>的魔力，你可以启动基于Linux/x86–64的Docker容器，QEMU会模拟它。</p><p id="5921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地在docker文件中指定它，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0a97" class="mx lw it mt b gy my mz l na nb">FROM — platform=linux/x86–64 centos:latest</span></pre><p id="d33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很整洁，是吧？</p><p id="afa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，也不是。</p><p id="46f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它启动了，但随后所有的东西都会被模拟，包括您启动的子流程。</p><p id="79f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们启动时会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/05492c2669e1dbd6a92d0397f551fbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCNnPGcijX3DreZQJB4WoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">警告:请求的映像平台(linux/amd64)与检测到的主机平台(linux/arm64/v8)不匹配，并且没有请求特定的平台</p></figure><p id="4f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们登录时，查看已经启动的流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/6d04e4d99163cc344e53165632373403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dM9uNu2MKIYsgUpeoQuvPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在M1 (ARM)处理器上模拟运行x86_64进程的CentOS</p></figure><p id="9dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意每个子进程都运行在qemu-x86_64下？</p><p id="c274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很聪明，但也相对资源密集。</p><p id="3d2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，确实管用！请记住，我们正在arm64处理器上运行x86进程！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进一步发展这个模型，我安装了<code class="fe ob oc od mt b">nginx</code>和<code class="fe ob oc od mt b">php-fpm</code>来测试我的一个开发环境。我将在本文的后面解释我如何在一个容器上运行它们，但是这次试验中最重要的是执行速度。</p><p id="45bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个通常在200毫秒内启动的应用程序，每个PHP页面请求平均需要2秒钟才能启动和运行。</p><p id="028b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在隔离了网络和文件系统活动之后，很明显PHP脚本执行是主要的瓶颈。</p><p id="eb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我得出结论，如果可能的话，应该避免模仿。</p><h1 id="5a1e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">那么还有什么选择呢？</h1><p id="c1ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在这里的目标是能够找到一个可行的替代VirtualBox运行CentOS(或类似的),由我的M1 Mac上的流浪者管理。</p><p id="a8f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高速度，我需要运行原生ARM映像。</p><p id="3b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便起见，容器必须“感觉”像一个完整的虚拟机。</p><p id="b343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整性，我需要能够管理这一切下的流浪者。</p><p id="e82c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是在Docker下运行兼容操作系统的ARM Docker映像。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="0f0e" class="lv lw it bd lx ly nu ma mb mc nv me mf jz nw ka mh kc nx kd mj kf ny kg ml mm bi translated">Fedora来拯救</h1><p id="5ca1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我用Docker CentOS 8.5容器开始了项目的这一部分。如果不是因为我需要一个高于7.2的PHP支持版本，我可能会坚持使用它。</p><p id="a019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的依赖项已经就绪，您可以为您选择的<code class="fe ob oc od mt b">systemd</code>操作系统切换出以下内容。Fedora 35支持PHP 8.0，这对于我的开发项目来说是完美的。</p><h2 id="b03b" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">运行Docker单个容器</h2><p id="d409" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Docker被设计为运行多个容器，每个容器都运行自己单独的、谨慎的服务(例如，一个用于<code class="fe ob oc od mt b">nginx</code>，一个用于<code class="fe ob oc od mt b">php-fpm</code>等)。然而，正如我所说的，我希望它“感觉”像一个虚拟机。</p><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的解决方案是将Fedora 35作为一个单独的容器启动。</p><p id="2e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对大多数人来说，第一个“陷阱”是没有可用的systemd，因为你不希望同时运行多个服务。此外，需要来自主机的许可，这些许可具有安全性考虑(—特权模式)，并且很难或几乎不可能转移来宾停靠容器以有效运行。</p><p id="1ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有各种各样的方法可以解决这个问题，在以前的项目中，我使用了“主管”来启动多个流程。</p><p id="aa01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，为了保持“虚拟机”的氛围，这次我用最优秀的<a class="ae ky" href="https://github.com/gdraheim/docker-systemctl-replacement" rel="noopener ugc nofollow" target="_blank">https://github.com/gdraheim/docker-systemctl-replacement</a>替换了<code class="fe ob oc od mt b">/usr/bin/systemctl</code></p><p id="6102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会让你点击链接阅读文件，但第一段就说明了一切:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2e96" class="mx lw it mt b gy my mz l na nb">This script may be used to overwrite “/usr/bin/systemctl”.<br/>It will execute the systemctl commands without SystemD!</span></pre><p id="0f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是什么意思？这意味着你可以使用如下命令:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="966c" class="mx lw it mt b gy my mz l na nb">systemctl run nginx</span></pre><p id="1819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是同样重要的是，这意味着您可以将容器的引导过程(PID 1)替换为<code class="fe ob oc od mt b">systemd</code>。</p><p id="8391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的Docker文件中，您只需从上面的repo中复制相关文件，并使用它作为启动命令，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="89e9" class="mx lw it mt b gy my mz l na nb">RUN yum -y install python3<br/>COPY src/docker-systemctl-replacement/files/docker/systemctl3.py /usr/bin/systemctl<br/>RUN chmod 755 /usr/bin/systemctl</span></pre><p id="f526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您将源文件和回购文件放在一个名为<code class="fe ob oc od mt b">src</code>的目录中，它的作用是:</p><ul class=""><li id="d2e8" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">安装python3</li><li id="2a58" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">用<code class="fe ob oc od mt b">systemctl3.py</code>覆盖<code class="fe ob oc od mt b">systemctl</code>的容器副本</li><li id="f80e" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">使替换可执行</li></ul><p id="a1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在，在启动时，您有一个满的<code class="fe ob oc od mt b">systemd</code>容器在运行。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="ed03" class="lv lw it bd lx ly nu ma mb mc nv me mf jz nw ka mh kc nx kd mj kf ny kg ml mm bi translated">把所有的放在一起</h1><p id="4028" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">以下docker文件将启动一个“熟悉的”M1兼容的、ARM64版本的Fedora 35(或更高版本)。</p><h2 id="b2e8" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">重要说明</h2><p id="ac55" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我假设从这一点开始，你已经安装了Docker和vagger(自制软件是很好的选择):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8950" class="mx lw it mt b gy my mz l na nb">brew install --cask docker<br/>brew install vagrant</span></pre><p id="d29c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，创建一个名为<code class="fe ob oc od mt b">src</code>的子目录，并首先将<code class="fe ob oc od mt b">gdraheim/docker-systemctl-replacement</code>拉至该子目录:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="769b" class="mx lw it mt b gy my mz l na nb">mkdir src<br/>cd src<br/>git clone <a class="ae ky" href="https://github.com/gdraheim/docker-systemctl-replacement.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gdraheim/docker-systemctl-replacement.git</a><br/>cd ..</span></pre><p id="186f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后编辑docker文件，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="21f6" class="mx lw it mt b gy my mz l na nb">FROM fedora:latest<br/>ENV container docker</span><span id="7b83" class="mx lw it mt b gy os mz l na nb"># Perform a package update<br/>RUN dnf -y update</span><span id="dbf9" class="mx lw it mt b gy os mz l na nb"># Add some familiar utilities<br/>RUN dnf -y install procps htop grep findutils iputils iproute<br/><br/># Add sshd server so we can 'vagrant ssh' later<br/>RUN dnf -y install openssh-server openssh-clients passwd sudo; <br/>RUN mkdir /var/run/sshd<br/>RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ''<br/>RUN useradd --create-home -s /bin/bash vagrant<br/>RUN echo -e "vagrant\nvagrant" | (passwd --stdin vagrant)<br/>RUN echo 'vagrant ALL=(ALL) NOPASSWD: ALL' &gt; /etc/sudoers.d/vagrant<br/>RUN chmod 440 /etc/sudoers.d/vagrant<br/>RUN mkdir -p /home/vagrant/.ssh<br/>RUN chmod 700 /home/vagrant/.ssh<br/>ADD https://raw.githubusercontent.com/hashicorp/vagrant/master/keys/vagrant.pub /home/vagrant/.ssh/authorized_keys<br/>RUN chmod 600 /home/vagrant/.ssh/authorized_keys<br/>RUN chown -R vagrant:vagrant /home/vagrant/.ssh</span><span id="a5d3" class="mx lw it mt b gy os mz l na nb"># Allow public key authentication for 'vagrant ssh' in Fedora 35<br/>RUN sed -i 's/^#PubkeyAuthentication yes/PubkeyAuthentication yes/i' /etc/ssh/sshd_config<br/># This softens a crypto policy that prevents vagrant completing ssh setup<br/>RUN sed -i 's/^Include \/etc\/crypto-policies\/back-ends\/opensshserver.config/#Include \/etc\/crypto-policies\/back-ends\/opensshserver.config/i' /etc/ssh/sshd_config.d/50-redhat.conf</span><span id="05cd" class="mx lw it mt b gy os mz l na nb"># As the container isn't normally running systemd, /run/nologin needs to be removed to allow SSH<br/>RUN rm -rf /run/nologin</span><span id="6efe" class="mx lw it mt b gy os mz l na nb"># Let's install and enable nginx for fun - just to prove this works!<br/>RUN dnf -y install nginx<br/>RUN systemctl enable nginx</span><span id="3b3e" class="mx lw it mt b gy os mz l na nb"># Install the replacement systemctl command<br/>RUN yum -y install python3<br/>COPY src/docker-systemctl-replacement/files/docker/systemctl3.py /usr/bin/systemctl<br/>RUN chmod 755 /usr/bin/systemctl<br/><br/>CMD /usr/bin/systemctl</span></pre><p id="a6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们快速构建它并检查错误:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9dbc" class="mx lw it mt b gy my mz l na nb">docker build --rm -t mynewvm .</span></pre><p id="343e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设它是干净的，你现在可以在Docker下运行这个机器，但是让我们跳过前面的步骤，通过vagger启动它。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="3307" class="lv lw it bd lx ly nu ma mb mc nv me mf jz nw ka mh kc nx kd mj kf ny kg ml mm bi translated">将流浪者加入其中</h1><p id="2a0d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一点上，你应该有一个完整的Docker容器，但在未来，我们可以让流浪者为你构建和启动容器。</p><p id="d508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在docker文件所在的目录下，运行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6cc8" class="mx lw it mt b gy my mz l na nb">vagrant init</span></pre><p id="9626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在编辑这个流浪者文件，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ee1f" class="mx lw it mt b gy my mz l na nb">Vagrant.configure("2") do |config|<br/><br/>  config.vm.define "default",primary: true do |master|<br/>    config.vm.network "private_network", ip: "192.168.21.100"<br/>    config.vm.network "forwarded_port", id: "ssh", host: 2222, guest: 22<br/>    config.vm.network "forwarded_port", id: "nginx", host: 8080, guest: 80<br/>  end<br/><br/>  config.vm.provider "docker" do |d, override|<br/>    d.build_dir = "."<br/>    d.remains_running = true<br/>    d.has_ssh = true<br/>  end<br/><br/>end</span></pre><p id="99d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件只是一个简单的例子，但是它将:</p><ul class=""><li id="2b00" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">定义“默认”容器</li><li id="e091" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">添加一个容器IP 192 . 168 . 21 . 100</li><li id="b869" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">将主机端口2222映射到容器端口22，以便进行SSH访问</li><li id="26f5" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">将主机端口8080映射到容器端口80，用于HTTP访问(这包括一个nginx演示)</li><li id="2ed8" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">告诉vagger使用同一目录中的docker文件构建docker容器</li><li id="b744" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">容器应该保持运行</li><li id="1aca" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">那个流浪汉应该安装一个SSH密钥</li></ul><p id="4fd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b8a8" class="mx lw it mt b gy my mz l na nb">vagrant up</span></pre><p id="260b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一会儿，您的Docker容器(或虚拟VM！)应该发射成功。</p><p id="5c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在docker下查看:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ea0b" class="mx lw it mt b gy my mz l na nb">docker ps</span></pre><p id="8e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到命令提示符后，运行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7c75" class="mx lw it mt b gy my mz l na nb">vagrant ssh</span></pre><p id="b5ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使您登录到新启动的计算机。</p><p id="3908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速环顾四周，应该也能确认<code class="fe ob oc od mt b">nginx</code>已经启动并正在运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/264906c6f149e80cc2f3049160fc83cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AIlA8HbQMEvp0bdrwJLZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过ps -ax查看您在systemd下运行的流程</p></figure><p id="6db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从您的主机操作系统(您的计算机)中，您还应该能够获取端口8080上的默认<code class="fe ob oc od mt b">nginx</code>登录页面:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2d35" class="mx lw it mt b gy my mz l na nb"><a class="ae ky" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/4a126639caa2d0e6b512b3b8b3b62397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHeVd2KO9RSpQ50ry5kBjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">nginx在端口8080上运行端口转发</p></figure><p id="a490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！</p><p id="9b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以安装和添加额外的服务，并像往常一样在<code class="fe ob oc od mt b">systemd</code>下运行它们。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="b063" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">我希望这篇文章对你有用。我能要求你帮个忙作为回报吗？</h2><p id="b845" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您是否可以考虑跟随我，这样我就可以继续积极参与中型合作伙伴计划？</p><p id="15c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">灵媒现在需要100个追随者才能继续。我希望你能成为他们中的一员。</p><p id="94be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需点击“关注”按钮。</p><p id="1f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我不断在Medium上发表新文章的最好激励之一。</p><p id="d88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你，祝你好运！</p></div></div>    
</body>
</html>