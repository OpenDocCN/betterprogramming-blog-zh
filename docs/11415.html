<html>
<head>
<title>.NET Core 101 Unit tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。网络核心101单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/net-core-101-unit-tests-23daff2d5281?source=collection_archive---------5-----------------------#2022-03-17">https://betterprogramming.pub/net-core-101-unit-tests-23daff2d5281?source=collection_archive---------5-----------------------#2022-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建功能强大、可靠的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3968742ae22b264c56d63e98ffa1c560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j0mb0Mh4W5ZQnwEj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯科特·布雷克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="2874" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是单元测试？</h1><p id="be63" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">单元测试的基本思想是由Kent在Smalltalk中介绍的。单元测试是提高软件质量的最佳工具之一，通常在特定的测试框架中编写。</p><p id="f385" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简单地说，单元测试是一段代码调用另一段代码(单元)并检查输出是否与期望的结果匹配。</p><p id="2a45" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在最原始的定义中，一个单元是一个方法或者一个函数。今天，人们也谈到工作单位，即:</p><blockquote class="ms"><p id="64be" class="mt mu it bd mv mw mx my mz na nb mm dk translated">“[……]从调用系统中的公共方法到该系统的测试产生一个明显的结果之间发生的动作的总和。”</p><p id="258a" class="mt mu it bd mv mw mx my mz na nb mm dk translated">(第一章。“单元测试的基础——单元测试的艺术”。</p></blockquote><p id="2c9c" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">这意味着单个软件组件或方法被测试。应该只测试开发人员完全控制下的代码。然而，根据《单元测试的艺术:C#中的例子》一书的作者Roy Osherove的观点，人们不应该试图最小化被测工作单元的大小。如果你试图减少一个工作单元的大小，你是在假装对一个公共API的用户来说不是结果的事情。</p><h1 id="c3fa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">其他类型的测试</h1><p id="2e55" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了单元测试，还有许多其他的测试。在下文中，我想讨论以下标准测试:集成、功能和验收测试。</p><h2 id="bc4b" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak">集成测试</strong></h2><p id="4613" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与单元测试不同，集成测试不是自给自足的。它们通常在被测系统之外有额外的依赖项，比如数据库或文件系统。测试两个或多个软件组件的协作。集成测试也可能涉及基础设施问题。集成测试使用实际的依赖关系，而单元测试将工作单元与其依赖关系隔离开来。</p><h2 id="f3ba" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak">功能测试</strong></h2><p id="4f59" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">功能测试被认为是高级测试。将测试用户需求的功能；因此，系统也被认为是一个黑匣子。测试整个系统的部分功能。</p><h2 id="c7a3" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak">验收测试</strong></h2><p id="e0b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">验收测试也被认为是高级测试。它基于用户和业务规范。测试软件是否具有预期的商业价值。最后，他们检查是否满足业务和合同要求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a11ce60243ca7197d89fae1129aebe1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLH33TAwky69T3L_TQ2Qeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://learning.oreilly.com/videos/introducing-test-driven/9781788292092/" rel="noopener ugc nofollow" target="_blank">介绍C# </a>中的测试驱动开发，作者<a class="ae ky" href="https://learning.oreilly.com/search/?query=author%3A%22Nikola%20%C5%BDivkovi%C4%87%22&amp;sort=relevance&amp;highlight=true" rel="noopener ugc nofollow" target="_blank">Nikola ivkovi</a>(由Packt出版社出版)</p></figure><p id="64d5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的金字塔回答了理想情况下应该写哪些测试以及写多少。正如你所看到的，单元测试扮演了最重要的角色。这是因为它们编写起来简单快捷，执行速度最快。</p><p id="bb9a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下类型的测试更耗时，但仍不可忽略。</p><h2 id="52ac" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">自动化测试</h2><p id="f128" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦我们编写了测试来检查我们的代码，我们也可以以自动化的方式重复运行这些测试。手动测试的问题是它远不如单元测试有效。</p><p id="d58c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，要测试一个类(对于一个网页)的逻辑，必须启动应用程序，必须潜在地登录或注册它，必须导航到页面，然后必须测试和验证实现的更改。这个过程非常耗时。</p><p id="8cae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">自动化测试现在可以用来提高整个过程的效率。</p><p id="91c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，自动化测试可以是上面显示的任何测试类型。</p><h1 id="138f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">(自动化)测试的优势</h1><ul class=""><li id="4f13" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">您只需编写一次，就可以随心所欲地运行它们。</li><li id="4858" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">一旦编写完成，测试可以在任何时候运行，无论是手动触发还是自动触发。</li><li id="d6c3" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">自动化测试有助于我们在部署之前发现错误。</li><li id="2ff4" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">这些测试非常可靠和有效。</li><li id="398a" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">当发布我们的代码时，自动化测试给了我们信心。</li><li id="54ab" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">最重要的原因之一是，它允许我们重构，并确保功能仍然存在。</li></ul><h1 id="302d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">自动化测试的结构</h1><p id="4292" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当编写自动化测试时，一个典型的顺序已经被接受:安排、执行、断言。在编写单元测试时也会观察到这种结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/487ac3d571f896dbb1c2df3c4bf9bdb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*XZouNcMyXsX9aDg2EFBp5Q.png"/></div></figure><p id="5756" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一阶段是初始设置，比如创建对象实例和测试数据。在act阶段，代码的执行遵循这一点。在最后一个阶段，我们希望检查结果是否符合我们的预期结果。</p><h1 id="d103" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">测试框架。网络核心</h1><p id="59d9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有很多用于编写测试的测试框架。下面，我列出了一些微软文档中相应的页面以获取更多信息。</p><h2 id="0267" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak"> xUnit </strong></h2><ul class=""><li id="c45a" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">它是一个免费的开源单元测试工具。网。</li><li id="e063" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-testNUnit" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/core/testing/unit-testing-with-dot net-testNUnit</a></li></ul><h2 id="2069" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak">努尼特</strong></h2><ul class=""><li id="a224" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">面向所有人的单元测试框架。网络语言。</li><li id="97da" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/core/testing/unit-testing-with-nunit</a></li></ul><h2 id="b680" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak"> MSTest </strong></h2><ul class=""><li id="ae4a" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">微软测试框架。</li><li id="d1cf" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/core/testing/unit-testing-with-ms test</a></li></ul><h1 id="ae5a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">谁编写测试？</h1><p id="ad0f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个问题有一个简单的答案。每个软件开发人员都应该编写测试。测试软件的高质量和准确性必须是开发过程的一部分，就像技术需求咨询一样。</p><p id="338e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果一辆汽车或一架飞机被开发出来，也是一种产品形式，它也需要被测试。软件的开发者和请求者也应该对软件提出同样的要求。</p><h1 id="6b4e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">测试驱动开发</h1><p id="7847" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦你获得了关于结构良好的、可维护的和可靠的测试框架的知识，在某个时候，问题出现了:我们什么时候写测试？许多开发人员在软件编写之后编写测试，但是现在越来越多的人在代码产生之前编写测试。在生产代码之前编写测试的方法被称为测试优先或测试驱动开发。</p><h1 id="3dd8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用C#编写单元测试的示例</h1><p id="3de6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们从创建一个新的类库项目开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f69514212b6f84965ae97b6dd3990ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoCcsCXmzxV33i1rEyFNrw.png"/></div></div></figure><p id="a6ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于我们现在想要创建的这个示例，我们制作了一个将两个数字相加的计算器。为此，我们将现有的类重命名为calculator，并编写一个将两个数相加并返回结果的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="473a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，在重命名该类并编写一个加法函数之后，我们现在需要将我们的测试项目添加到解决方案中。在这个例子中，我们将使用微软提供的测试框架MSTest。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f5658d678dd2984f6704e538ba254145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUiutxIgwOswEUUNJbdRSw.png"/></div></div></figure><p id="ae84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在想重命名UnitTest1类。我们如下处理命名:要测试的类加上“应该”这同样适用于测试方法的名称。被测试方法的名字加上应该做这个或那个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6385" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Arrange中，我们首先初始化我们的关键测试数据和对象，正如你所看到的。</p><p id="72d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在在Act阶段执行该方法并保存结果。</p><p id="4fc9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们希望检查结果，看看它是否与我们在最后一步中的预期结果相匹配。</p><p id="1407" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在要运行这个测试，我们需要打开测试资源管理器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/211000627af396ec7c9127bc9f763d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*Mi2f9HQ58UVjYPxS1EC9JA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/95d38528c102068f68d0240a4c39fad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*iwHoiCmlTaCNvhGPPmZ-ag.png"/></div></figure><p id="f69e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行测试后，您应该看到它工作了。</p><p id="66e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要使测试失败，您可以在断言中更改预期结果；然后，测试将失败。</p><h1 id="1d55" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是模仿？</h1><p id="b7d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">细心的读者可能希望记住，单元测试不应该测试数据库、文件系统等依赖项。通过模仿，我们可以模仿一个类或接口的行为来隔离测试中的代码。我们希望确保被调用的其他代码不会导致测试中的代码失败。</p><h1 id="c66e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">编写模拟的示例</h1><p id="20d9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了演示模仿，让我们给计算器添加日志功能。即使这不完全有用，但基本概念是可以转移的。</p><p id="55df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们想在类库中创建一个接口<code class="fe op oq or os b">ILogCalc</code>和一个类<code class="fe op oq or os b">LogCalc</code>。通常，我们在生产应用程序中的第一件事是一个由类实现的接口。这有几个原因，但我现在不想深入探讨。但是我们必须使用接口，因为它允许我们模仿。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/6cd59c1c5ac2b747a98deae53a355f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*XFVk4XHPnBGOpdrh7fgGBg.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7d3f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些现在将通过calculator类中的构造函数进行初始化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1688" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，结构如上所示。我们有一个私有的字段变量，并通过构造函数初始化它。这个过程被称为依赖注入。</p><p id="b03f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个设置的好处是我们现在可以在测试中模拟接口。</p><p id="5d45" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在应该在计算器测试类中得到一个关于这个设置的错误，因为我们不能在没有参数的情况下初始化计算器。但是在我们的<code class="fe op oq or os b">Calculator</code>测试中，我们不希望依赖其他类和方法。</p><p id="f3db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要使用mocking，我们首先需要安装一个NuGet包。这叫最小起订量。在我们的测试项目中安装它。</p><p id="c40e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以做的是创建一个界面的模型。如下所示，我们可以通过构造函数将它传递给计算器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6e5e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们的<code class="fe op oq or os b">LogCalc</code> log函数没有返回值，所以传递模拟对象就足够了。</p><p id="a9a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，不管出于什么原因，如果我们的日志函数有一个返回值，比如True或False，说明日志记录是否有效，那么我们仍然需要调整。</p><p id="1551" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一下这个。这里，我们在接口和类中更改log函数的签名，并返回一个布尔值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c24b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以从我们的模拟中调用一个名为setup的函数，通过它我们可以模拟这个函数及其返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f541" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第16行，我们使用setup来模拟log方法。我们在这里通过<code class="fe op oq or os b">It.IsAny&lt;String&gt;()</code>说，我们接受任何字符串值，并且总是返回true。如果您现在通过测试进行调试，您应该看到log方法返回true。</p><h1 id="d346" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">单元测试时要考虑的事情</h1><ul class=""><li id="1f00" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">单元测试100%的代码覆盖率被认为是不现实的，也不是我们的目标。(也许极限编程除外)</li><li id="960b" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">良好的代码覆盖率已经达到了65–75%。</li><li id="9bf6" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">如果方法有多条路径，那么所有的路径都应该被测试(即使由于干净的代码这不是很好)。</li><li id="98b6" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">测试迫使我们写干净的代码。否则，它就不可测试。</li></ul><h1 id="6db9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="09bf" class="nu nv it lt b lu lv lx ly ma nw me nx mi ny mm nz oa ob oc bi translated">测试对于提高软件质量和减少错误至关重要。</li><li id="d3c5" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">测试是良好重构的基本要求。</li><li id="9df0" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">有不同的测试，例如单元测试、集成、功能和验收测试。</li><li id="7f13" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">测试的基本结构是安排、操作和断言。</li><li id="86dd" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">模仿用于在单元测试期间将方法从它们的依赖中释放出来。</li></ul></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt pb os pc pd aw pe bi"><span id="b1cc" class="nh la it os b gy pf pg l ph pi"><strong class="os iu">Want to Connect?</strong></span><span id="ba6d" class="nh la it os b gy pj pg l ph pi">You can contact me via my social media channels (<a class="ae ky" href="https://twitter.com/muench_justin" rel="noopener ugc nofollow" target="_blank">Twitter</a>,<a class="ae ky" href="https://www.linkedin.com/in/justin-m%C3%BCnch-0b1087133/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>).</span><span id="7579" class="nh la it os b gy pj pg l ph pi">All drawings were created with Draw.IO.</span></pre><h1 id="41a2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">来源</h1><div class="pk pl gp gr pm pn"><a href="https://docs.microsoft.com/en-us/dotnet/core/testing/" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">正在测试。网。网</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">本文介绍了测试的概念，并举例说明了如何使用不同种类的测试来验证…</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">docs.microsoft.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb ks pn"/></div></div></a></div><div class="pk pl gp gr pm pn"><a href="https://www.amazon.com/-/de/dp/1617290890/ref=sr_1_1?keywords=the+art+of+unit+testing+with+examples+in+c+%23&amp;qid=1647071159&amp;sprefix=The+Art+of+Unit+testing+%2Caps%2C197&amp;sr=8-1" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">单元测试的艺术:C#中的例子</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">单元测试的艺术:以Amazon.com的C#为例。*符合条件的优惠可享受免费*运输。的…</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">www.amazon.com</p></div></div><div class="pw l"><div class="qc l py pz qa pw qb ks pn"/></div></div></a></div><div class="pk pl gp gr pm pn"><a href="https://www.simform.com/blog/functional-vs-integration-testing/#section1" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">功能测试与集成测试:差异的详细指南</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">“在你的代码投入使用之前对其进行测试”已经成为一种现象，并且是挽救商业声誉和保持…</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">www.simform.com</p></div></div><div class="pw l"><div class="qd l py pz qa pw qb ks pn"/></div></div></a></div><div class="pk pl gp gr pm pn"><a href="https://spin.atomicobject.com/2017/08/07/intro-mocking-moq/" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">模拟单元测试介绍(使用Moq)</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">很容易忽略单元测试的重要性。编写测试可能会很乏味。它们必须不断更新，因为…</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">spin.atomicobject.com</p></div></div><div class="pw l"><div class="qe l py pz qa pw qb ks pn"/></div></div></a></div><p id="52b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">单元测试完全指南。NET Core (NUnit和xUnit)作者Bhrugen Patel(由Packt出版社出版)@<a class="ae ky" href="https://learning.oreilly.com/" rel="noopener ugc nofollow" target="_blank">https://learning.oreilly.com/</a></p></div></div>    
</body>
</html>