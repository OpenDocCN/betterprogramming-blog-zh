<html>
<head>
<title>How to Avoid Thread Explosions With Swift Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过快速并发避免线程爆炸</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-swift-concurrency-prevent-thread-explosions-40b3140d1b56?source=collection_archive---------7-----------------------#2022-11-08">https://betterprogramming.pub/how-does-swift-concurrency-prevent-thread-explosions-40b3140d1b56?source=collection_archive---------7-----------------------#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9625" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我发现的东西相当迷人！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22007c8333508e93013d2cb95a2407de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phYyxRz5iL_sca_lenZX3A.png"/></div></div></figure><p id="59e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几周前，我读了Wojciech Kulik的一篇文章，他谈到了Swift并发框架中的一些陷阱。在其中一节中，Wojciech简要地提到了线程爆炸，以及快速并发如何通过限制我们过度使用多于CPU内核的线程来防止它的发生。</p><p id="c736" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这让我很好奇……真的是这样吗？这在幕后是如何工作的？我们能设法欺骗系统来创建比CPU内核更多的线程吗？</p><p id="2c6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在本文中回答所有这些问题。所以事不宜迟，让我们直接开始吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="41d1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">理解线程爆炸💥</h1><p id="0516" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">那么，什么是线程爆炸呢？线程爆炸是指大量线程在系统中并发运行，最终导致性能问题和内存开销。</p><p id="b311" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于多少线程被认为是太多，没有明确的答案。作为一个通用基准，我们可以参考这个<a class="ae lq" href="https://developer.apple.com/videos/play/wwdc2021/10254/?time=514" rel="noopener ugc nofollow" target="_blank"> WWDC视频</a>中给出的例子，根据这个例子，一个系统运行的线程数是其CPU内核数的16倍，就被认为正在经历线程爆炸。</p><p id="b747" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Grand Central Dispatch (GCD)没有防止线程爆炸的内置机制，所以使用调度队列创建一个机制非常容易。考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="72f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦执行，上面的代码将产生总共150个线程，导致线程爆炸。这可以通过暂停执行并检查调试导航器来验证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5daec1263eceb4f0ea26adc49cc3d392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*aOKpL1V2F6DdMNIw"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">显示线程展开的调试导航器</p></figure><p id="5399" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然您已经了解了如何触发线程爆炸，让我们尝试使用Swift并发执行相同的代码，看看会发生什么。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="da55" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">并发管理线程的速度有多快</h1><p id="ed0f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">众所周知，Swift并发中有3个级别的任务优先级，主要是<code class="fe nc nd ne nf b">userInitiated</code>、<code class="fe nc nd ne nf b">utility</code>和<code class="fe nc nd ne nf b">background</code>，其中<code class="fe nc nd ne nf b">userInitiated</code>优先级最高，其次是<code class="fe nc nd ne nf b">utility</code>和<code class="fe nc nd ne nf b">background</code>优先级最低。因此，让我们继续相应地更新我们的<code class="fe nc nd ne nf b">HeavyWork</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次创建任务时，我们都会打印出创建时间。然后我们可以用它来想象场景背后发生的事情。</p><p id="535a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更新后的<code class="fe nc nd ne nf b">HeavyWork</code>类就绪后，让我们开始第一个测试。</p><h2 id="e683" class="ng lz it bd ma nh ni dn me nj nk dp mi ld nl nm mk lh nn no mm ll np nq mo nr bi translated">测试1:创建具有相同优先级的任务</h2><p id="eaf3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这个测试基本上与我们之前看到的调度队列示例相同，但是我们将使用Swift Concurrency中的<code class="fe nc nd ne nf b">Task</code>来创建一个线程，而不是使用GCD。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7b4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是从Xcode控制台捕获的日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1f4437a68fa8eec78451817519b02b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*kSlVac_rWSZq-33Z"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">快速并发，一次最多运行6个线程</p></figure><p id="7d6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的(从任务创建时间来看)，线程的创建在线程数达到6时停止，这与my6核iPhone 12的CPU核数完美匹配。只有在其中一个正在运行的任务完成执行后，任务的创建才会继续。因此，一次最多只能有6个线程同时运行。</p><blockquote class="ns nt nu"><p id="04cf" class="ku kv nv kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">注意:</p><p id="e9ad" class="ku kv nv kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">无论选择什么设备，iOS模拟器总是将最大线程数限制为1。因此，确保使用真实设备运行上述测试，以获得更准确的结果。</p></blockquote><p id="290d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更清楚地了解幕后到底发生了什么，让我们暂停执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4490167ff822f35368f1f7968bfd2bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*MUDeyE_1GvsnHPJv"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">在并发队列中运行的优先级为“用户启动”的任务</p></figure><p id="42cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">似乎我们刚才看到的一切都是由一个名为“<em class="nv">com . apple . root . user-initiated-QoS . cooperative</em>”的并发队列控制的。</p><p id="1399" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于上述观察，可以有把握地说，这就是Swift并发防止线程爆炸发生的方式:拥有一个专用的并发队列来限制线程的最大数量，使其不会超过CPU核心。</p><h2 id="c3b2" class="ng lz it bd ma nh ni dn me nj nk dp mi ld nl nm mk lh nn no mm ll np nq mo nr bi translated">测试2:一次从高到低创建任务</h2><p id="2ec9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在，让我们深入一点，向测试中添加不同优先级的任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们首先创建优先级最高的任务(<code class="fe nc nd ne nf b">userInitiated</code>)，然后是<code class="fe nc nd ne nf b">utility</code>和<code class="fe nc nd ne nf b">background</code>。根据我们之前的观察，我期望看到3个队列，每个队列中有6个线程并发运行，这意味着我们将看到总共产生18个线程。令人惊讶的是，事实并非如此。看看下面的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/4cc013054512d3e8bc709af22a70c68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sOKCseFwF4uZTFr9"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">从高到低优先级同时开始时的任务分配</p></figure><p id="b7f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，当高优先级队列(<code class="fe nc nd ne nf b">userInitiated</code>)饱和时，<code class="fe nc nd ne nf b">utility</code>和<code class="fe nc nd ne nf b">background</code>队列都将允许的最大线程数限制为1。换句话说，我们在这个测试中可以拥有的最大线程数是8。</p><p id="dc75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常有趣的发现！使高优先级队列饱和会以某种方式抑制其他低优先级队列产生更多线程。</p><p id="a36a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们颠倒优先级的顺序，会发生什么呢？让我们来了解一下！</p><h2 id="fd20" class="ng lz it bd ma nh ni dn me nj nk dp mi ld nl nm mk lh nn no mm ll np nq mo nr bi translated">测试3:一次创建从低到高优先级的任务</h2><p id="b75d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">首先，让我们更新执行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="90ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果来了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d60c8b22e2186f780d8aea58e8e33fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O6rUeoNaz2Xebi-n"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">从低到高优先级同时开始时的任务分配</p></figure><p id="7e26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到的结果和“测试2”一模一样。</p><p id="6f49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来系统足够聪明，即使我们先启动优先级最低的任务，它也会让优先级较高的任务先运行。最重要的是，系统仍然限制我们创建8个以上的并发线程，因此我们仍然不能为这个测试创建一个线程爆炸。干得好苹果！👍🏻</p><h2 id="bcd3" class="ng lz it bd ma nh ni dn me nj nk dp mi ld nl nm mk lh nn no mm ll np nq mo nr bi translated">测试4:从低到高优先级创建任务，中间有间隔</h2><p id="1ea3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在现实生活中，我们不太可能同时开始一堆不同优先级的任务。因此，让我们通过在每个for循环之间添加一个小的中断来创建一个更真实的条件。请注意，在这个测试中，我们仍然使用从低到高的顺序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4b90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到的结果很有趣。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e4927cefce2099b5a52c6dd171439d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DFfyNoxT698vGIYQ"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">从低到高优先级开始，中间有间隔时的任务分配</p></figure><p id="4bde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，在第二次中断后，所有3个队列都在运行多线程。似乎如果我们首先启动低优先级队列并让它运行一段时间，高优先级队列就不会抑制低优先级队列的性能。</p><p id="02eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经执行了几次这个测试，线程的最大数量可能会有一点变化，但它或多或少等于CPU内核的3倍。</p><p id="8a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这算不算线程爆炸？</p><p id="5bf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不这么认为，因为线程数是CPU内核数的3倍仍然比我前面提到的16倍的阈值要低。事实上，我认为苹果故意让这种情况发生，以便在执行性能和多线程开销之间取得更好的平衡。如果你有其他观点，请在<a class="ae lq" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我，我真的很想听听你的想法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="adf0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="c43b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Swift concurrency在防止线程爆炸方面做得非常好，但是我们不能否认这样一个事实，如果我们继续使<code class="fe nc nd ne nf b">userInitiated</code>队列饱和，它将会导致一个非常严重的瓶颈(我将很快深入探讨这个问题，敬请关注)。</p><p id="7152" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于我们在“测试4”中得到的结果，可以肯定地说，我们应该更经常地使用<code class="fe nc nd ne nf b">background</code>和<code class="fe nc nd ne nf b">utility</code>队列，并且只在必要的时候使用<code class="fe nc nd ne nf b">userInitiated</code>队列。</p><p id="432e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想尝试一下示例代码吗？给你！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="caac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您喜欢这篇文章，请务必访问我的网站，查看其他与Swift并发相关的文章。你也可以在<a class="ae lq" href="https://twitter.com/Lee_Kah_Seng" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，这样你就不会错过我即将发布的任何文章。</p><p id="ea04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>