<html>
<head>
<title>Dockerize Laravel-Vite + React Application in Your Development Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发环境中的Dockerize Laravel-Vite + React应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerize-laravel-vite-react-application-in-your-development-environment-a118aea4a02d?source=collection_archive---------1-----------------------#2022-10-04">https://betterprogramming.pub/dockerize-laravel-vite-react-application-in-your-development-environment-a118aea4a02d?source=collection_archive---------1-----------------------#2022-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用artisan命令、composer命令、npm命令、cron作业、队列、数据库和redis缓存容器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6677af96e79d7c33928c33a5a90a7c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6y0_b2FVRbWDvbdhfBZXQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(来源:<a class="ae kv" href="https://www.shutterstock.com/image-photo/nov-2-2019-san-francisco-ca-1557785567" rel="noopener ugc nofollow" target="_blank"> shutterstock </a>)</p></figure><h1 id="eb20" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="1711" class="lt kx iq lp b gy lu lv l lw lx"><a class="ae kv" href="#2b4b" rel="noopener ugc nofollow">1. Introduction</a><br/><a class="ae kv" href="#1ff9" rel="noopener ugc nofollow">2. Prerequisites for this guide</a><br/><a class="ae kv" href="#b38d" rel="noopener ugc nofollow">3. Set up git</a><br/><a class="ae kv" href="#c63f" rel="noopener ugc nofollow">4. Download and install docker and docker-compose</a><br/><a class="ae kv" href="#3d32" rel="noopener ugc nofollow">5. Clone laravel application and create root folders</a><br/><a class="ae kv" href="#9c2e" rel="noopener ugc nofollow">6. Create .env, .env.example and .gitignore files</a><br/><a class="ae kv" href="#5610" rel="noopener ugc nofollow">7. Docker compose yaml file</a><br/><a class="ae kv" href="#3f69" rel="noopener ugc nofollow">8. Main containers</a><br/><a class="ae kv" href="#633a" rel="noopener ugc nofollow">9. Utility containers</a><br/><a class="ae kv" href="#7de4" rel="noopener ugc nofollow">10. Configuring Vite asset bundler and InertiaJS</a><br/><a class="ae kv" href="#1aac" rel="noopener ugc nofollow">11. Starting your containers</a><br/><a class="ae kv" href="#da51" rel="noopener ugc nofollow">12. Pushing code to github</a><br/><a class="ae kv" href="#e157" rel="noopener ugc nofollow">13. Resources/Links</a><br/><a class="ae kv" href="#5123" rel="noopener ugc nofollow">14. Conclusion</a></span></pre><h1 id="2b4b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.介绍</h1><p id="03f7" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">本指南将向您展示如何使用Docker建立一个Laravel-React堆栈开发环境，并结合一些额外的实用程序容器来完善您的设置。</p><p id="b7ff" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">这种设置与操作系统无关，除了Docker和Docker Compose之外没有任何依赖关系。只要安装了Docker和Docker compose，就可以在所有主流操作系统上运行，比如微软的Windows、苹果的macOS、Linux。</p><p id="b86a" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">这个设置允许您根据自己的喜好混合和匹配服务的版本，只需编辑一两行即可。例如，您可以将PHP 7.4、8.0、8.1或8.2与Laravel 7、8或9结合使用。</p><p id="eb46" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们将容器化一个Laravel 9应用程序，并允许它与其他主/实用程序容器通信，形成一个完整的dockerized开发环境。</p><p id="44af" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">下表显示了我们将在Docker环境中运行的服务(容器)。我把它们分成两类(主容器和实用容器)。</p><ul class=""><li id="5355" class="mz na iq ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">主容器—启动后持续运行，除非停止，否则通常会在出现故障时重新启动。</li><li id="59d4" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">实用程序容器—这些容器运行命令来定制和优化整个应用程序。容器在运行命令后被销毁。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主要容器</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实用集装箱</p></figure><h1 id="1ff9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.本指南的先决条件</h1><ol class=""><li id="ffb7" class="mz na iq ma b mb mc me mf mh np ml nq mp nr mt ns nf ng nh bi translated">您应该意识到构建容器的必要性以及它们是如何工作的。</li><li id="53b9" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ns nf ng nh bi translated">需要熟悉ReactJS并了解Laravel的工作原理。</li></ol><p id="d9f8" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">现在让我们深入研究代码和docker命令。</p><h1 id="b38d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.设置Git</h1><p id="fc7a" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">要在命令行上使用Git，您需要在您的计算机上设置Git。您将使用Git来克隆Laravel 9应用程序。在本指南的最后，我将向您展示如何使用Git将整个设置代码推送到GitHub存储库。</p><p id="25a6" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">如果您的本地机器上没有配置Git，请按照本<a class="ae kv" href="https://docs.github.com/en/get-started/quickstart/set-up-git" rel="noopener ugc nofollow" target="_blank">教程</a>设置Git。</p><h1 id="c63f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.下载并安装Docker和docker-compose</h1><p id="5124" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">从<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">这里</a>下载并安装Docker。您可以使用Docker桌面客户端或Docker CLI客户端。从<a class="ae kv" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">这里</a>下载并安装docker-compose。</p><h1 id="3d32" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.克隆Laravel应用程序并创建根文件夹</h1><p id="bb96" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">转到您要在本地存储项目的文件夹，并在下面的列表中创建以下文件夹/子文件夹。你可以从<a class="ae kv" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Visual Studio IDE </a> (VS代码)中打开你的项目文件夹，然后创建你所有的文件夹和文件。</p><ul class=""><li id="cbdc" class="mz na iq ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">码头工人/日志</li><li id="e0cb" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">docker/mysql</li><li id="299d" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">docker/nginx</li></ul><p id="15d7" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们将使用docker/logs文件夹存储容器日志，docker/mysql存储mysql数据，docker/nginx用于nginx配置文件。如果没有设置这些文件夹，容器运行时生成的数据会在每次重启时被销毁。</p><p id="fbda" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">从项目文件夹的根目录，使用Git将Laravel存储库克隆到一个名为src的文件夹中。在VS代码中，切换终端并粘贴下面的命令。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6683" class="lt kx iq lp b gy lu lv l lw lx">git clone <a class="ae kv" href="https://github.com/laravel/laravel.git" rel="noopener ugc nofollow" target="_blank">https://github.com/laravel/laravel.git</a> src</span></pre><p id="7dfc" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><strong class="ma ir">注意</strong>:删除<code class="fe nt nu nv lp b">src</code>内的<code class="fe nt nu nv lp b">.github</code>和<code class="fe nt nu nv lp b">.git</code>文件夹。<code class="fe nt nu nv lp b">.github</code>包含laravel的默认GitHub动作，而<code class="fe nt nu nv lp b">.git</code>有Laravel的存储库细节。我们将从项目目录的根目录创建一个新的git存储库。我们还将在后面的教程中创建自定义GitHub动作。</p><h1 id="9c2e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.创造。环境、环境示例和。git忽略文件</h1><p id="46c5" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">将. env.example从<code class="fe nt nu nv lp b">src</code>文件夹复制到项目目录的根目录下。这个文件只是一个例子。环境文件。您可以对该文件进行版本控制。</p><p id="3974" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在同一目录中，创建一个. env文件。您的应用程序的配置变量将存储在这里。当作为一个团队在一个项目中工作时，这个文件对于不同的服务器和不同的开发人员可能有不同的值。因此，它不应该被版本化。</p><p id="1971" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">创建一个. gitignore文件，并添加以下代码:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="47ad" class="lt kx iq lp b gy lu lv l lw lx">.env<br/>docker/logs/*<br/>docker/mysql/*</span></pre><h1 id="5610" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">7.码头工人撰写YAML文件</h1><blockquote class="nw nx ny"><p id="423c" class="ly lz nz ma b mb mu jr md me mv ju mg oa mw mj mk ob mx mn mo oc my mr ms mt ij bi translated">Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。— <a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker撰写</a></p></blockquote><p id="594e" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们的<code class="fe nt nu nv lp b">docker-compose.yml</code>文件结构如下所示:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="b5fb" class="lt kx iq lp b gy lu lv l lw lx">version: '3'</span><span id="6758" class="lt kx iq lp b gy od lv l lw lx">networks:<br/>  laravel:</span><span id="c1e1" class="lt kx iq lp b gy od lv l lw lx">services:<br/>  ... services go here</span></pre><p id="1ff1" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><code class="fe nt nu nv lp b">version: '3'</code>指的是Docker编写版本。相比版本2，版本3是Swarm兼容的；因此，如果你以后决定使用Docker Swarm orchestrator，你不必做任何改变。</p><p id="f364" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在<code class="fe nt nu nv lp b">networks:</code>段下配置了一个名为<code class="fe nt nu nv lp b">laravel</code>的网络。加入此网络的容器将可被网络上的其他容器到达。它们也可以在与容器名称相同的主机名上被发现。</p><p id="1701" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><code class="fe nt nu nv lp b">services:</code>表示图像的实例，例如，数据库服务、Redis服务、PHP服务等。</p><p id="36f4" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在项目的根目录下创建一个<code class="fe nt nu nv lp b">docker-compose.yml</code>文件，并将以下代码放入其中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">docker-compose.yml文件</p></figure><p id="b983" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">不要担心这个文件中的细节；我们将在本指南的后面部分详细介绍它们。</p><p id="5b60" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">项目的文件夹结构现在如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/0c93837a4b06cfdb7d6c2d1bf5a210e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JBuX4OrgVGd5iMtwylXtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目文件夹-结构</p></figure><h1 id="3f69" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">8.主要容器</h1><h2 id="1614" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.1.NGINX服务</h2><p id="9acf" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">设置将作为web服务器本身的容器。它将接收来自最终用户的HTTP请求，并将它们发送到PHP容器，该容器将处理我们的Laravel代码。</p><p id="5f59" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">以下是NGINX服务代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nginx服务</p></figure><h2 id="7282" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">故障</h2><ul class=""><li id="fe30" class="mz na iq ma b mb mc me mf mh np ml nq mp nr mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">build </code> —定义Compose应用于构建Docker映像的配置选项。</li><li id="d2c2" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">context </code> —定义Nginx dockerfile文件的路径。</li><li id="5f5c" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">dockerfile </code> —这是用于创建Nginx映像的Dockerfile，从上下文解析而来。</li><li id="816a" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">args </code> —定义构建参数，即<code class="fe nt nu nv lp b">nginx.dockerfile</code> <code class="fe nt nu nv lp b">ARG</code>值，如下一节所示。</li><li id="013f" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">restart </code> —定义容器的重启策略。</li><li id="f8df" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">container_name </code> —定义容器名称。</li><li id="c839" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">ports</code> —将主机的端口映射到容器的端口。</li><li id="250c" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">volumes </code> —将项目目录内容挂载到容器<code class="fe nt nu nv lp b">/var/www/html</code>目录，并将<code class="fe nt nu nv lp b">.env</code>文件挂载到容器位置<code class="fe nt nu nv lp b">/var/www/html/.env</code>。在主机上进行的任何项目内容更改都会反映在容器中，反之亦然。</li><li id="aa1a" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">depends_on </code> —这定义了在构建此服务之前对另一个要运行的服务的依赖性。</li><li id="ac1b" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated"><code class="fe nt nu nv lp b">networks</code> —服务将直接与<code class="fe nt nu nv lp b">laravel</code>网络中的其他服务通信。</li></ul><h2 id="0709" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">nginx.dockerfile</h2><p id="aeaf" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">这个文件的上下文是项目的docker文件夹。下面是我们的<code class="fe nt nu nv lp b">nginx.dockerfile</code>文件。它基于<a class="ae kv" href="https://hub.docker.com/layers/library/nginx/stable-alpine/images/sha256-5bc90c961f2ef45c7ed6057e5c55e09d5f6b700a9d2e7e824c5e3709f329a61d?context=explore" rel="noopener ugc nofollow" target="_blank"> nginx:stable-alpine </a>图像，非常轻量级，大小只有~5MB。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nginx.dockerfile文件文件</p></figure><p id="90d7" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在上面的docker文件中，我们将<code class="fe nt nu nv lp b">default.conf</code>文件从项目的nginx目录复制到容器的目录中。它将覆盖默认的Nginx配置。</p><p id="a26c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">下面是我们的<code class="fe nt nu nv lp b">default.conf</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">default.conf文件</p></figure><p id="1d58" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">允许Nginx容器将请求传递给PHP FPM (FastCGI进程管理器)的配置是<code class="fe nt nu nv lp b">fastcgi_pass php:9000</code>。这些请求通过端口<code class="fe nt nu nv lp b">9000</code>传递给名为<code class="fe nt nu nv lp b">php </code>的容器。</p><h2 id="e31d" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.2.PHP服务</h2><p id="f014" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">与Apache web服务器不同，Nginx必须使用PHP-FPM作为单独的进程来处理PHP客户端请求。</p><p id="7cad" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">下面是PHP服务部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PHP服务</p></figure><h2 id="2bb4" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">故障</h2><p id="f347" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">这里我们使用一个名为<code class="fe nt nu nv lp b">php.dockerfile</code>的定制dockerfile文件。<code class="fe nt nu nv lp b">container_name</code>是<code class="fe nt nu nv lp b">php</code>，这个容器只能由其他容器通过端口<code class="fe nt nu nv lp b">9000</code>在内部访问。</p><h2 id="a845" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">php.dockerfile</h2><p id="4dad" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">这个文件的上下文也是项目的docker文件夹。下面是我们的<code class="fe nt nu nv lp b">php.dockerfile</code>文件。它是基于阿尔卑斯山的形象(它是轻量级的)<code class="fe nt nu nv lp b">php:8.1-fpm-alpine</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">php.dockerfile文件</p></figure><h2 id="e07a" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.3.Mysql服务</h2><p id="36cb" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">对于我们运行Mysql的数据库容器，我们将在我们的<code class="fe nt nu nv lp b">docker-compose.yml</code>文件中直接使用DockerHub的<a class="ae kv" href="https://hub.docker.com/_/mariadb" rel="noopener ugc nofollow" target="_blank"> MariaDB官方映像</a>。它是预先配置好的，并得到采用最佳实践的社区的支持。</p><p id="211b" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">它看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MySQL服务</p></figure><p id="e17a" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在这个服务中，我们必须定义环境变量:<code class="fe nt nu nv lp b">${DB_DATABASE}</code>、<code class="fe nt nu nv lp b">${DB_USERNAME}</code>和<code class="fe nt nu nv lp b">${DB_PASSWORD}</code>。它们是从我们之前创建的<code class="fe nt nu nv lp b">.env</code>文件中定义的。下面是一个示例<code class="fe nt nu nv lp b">.env</code>配置。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="0a70" class="lt kx iq lp b gy lu lv l lw lx">DB_CONNECTION=mysql<br/>DB_HOST=mysql<br/>DB_PORT=3306<br/>DB_DATABASE=laravel<br/>DB_USERNAME=laravel_user<br/>DB_PASSWORD=%6larav31</span></pre><p id="736d" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">通常，在Laravel中，<code class="fe nt nu nv lp b">DB_HOST</code>通常被配置为数据库IP地址，即<code class="fe nt nu nv lp b">DB_HOST=127.0.0.1</code>。然而，在这种情况下，我们将使用mysql服务名，即<code class="fe nt nu nv lp b">DB_HOST=mysql</code>。</p><p id="ca94" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">MySQL服务可以由内部的其他容器通过端口<code class="fe nt nu nv lp b">3306</code>访问，该端口已经在端口<code class="fe nt nu nv lp b">3307</code>暴露给主机。</p><p id="f6af" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">为了避免在容器重启时丢失数据库数据，卷<code class="fe nt nu nv lp b">./docker/mysql</code>被安装到容器内的<code class="fe nt nu nv lp b">/var/lib/mysql</code>。因此，Mysql数据将保存在主机的<code class="fe nt nu nv lp b">./docker/mysql</code>目录下。</p><h2 id="45fd" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.4.Redis服务</h2><p id="3dc9" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">我们将添加一个基于<code class="fe nt nu nv lp b">redis:alpine</code>图像的Redis服务来让Redis工作。该服务将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redis服务</p></figure><p id="e403" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们还需要更新我们的<code class="fe nt nu nv lp b">.env</code>文件来使用这个redis服务进行队列和会话管理。更新<code class="fe nt nu nv lp b">.env</code>文件的以下部分。我们使用我们的redis服务名作为Redis主机，<code class="fe nt nu nv lp b">REDIS_HOST=redis</code>。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="33ac" class="lt kx iq lp b gy lu lv l lw lx">QUEUE_CONNECTION=redis<br/>SESSION_DRIVER=redis</span><span id="9983" class="lt kx iq lp b gy od lv l lw lx">REDIS_HOST=redis<br/>REDIS_PASSWORD=null<br/>REDIS_PORT=6379</span></pre><h2 id="d68e" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.5.Cron就业服务</h2><p id="b25a" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">该服务将基于我们之前创建的<code class="fe nt nu nv lp b">php.dockerfile</code>。</p><p id="3251" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">以下是服务文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉勒韦尔-克朗服务公司</p></figure><p id="ef67" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们使用<code class="fe nt nu nv lp b">schedule:work</code>命令代替<code class="fe nt nu nv lp b">schedule:run</code>在前台运行，并每分钟调用一次调度程序。容器运行时执行<code class="fe nt nu nv lp b">entrypoint</code>命令。</p><h2 id="c9bb" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.6.队列服务</h2><p id="4719" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">这个服务也是基于<code class="fe nt nu nv lp b">php.dockerfile</code>。服务配置将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">排队服务</p></figure><p id="e93a" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">该服务的<code class="fe nt nu nv lp b">entrypoint</code>将运行Laravel命令<code class="fe nt nu nv lp b">php artisan queue:work</code>。这个命令运行Laravel的基本<a class="ae kv" href="https://laravel.com/docs/9.x/queues" rel="noopener ugc nofollow" target="_blank">队列服务</a>，它处理所有排队的作业。这是Laravel中处理队列的默认方式。也可以设置<a class="ae kv" href="https://laravel.com/docs/9.x/horizon" rel="noopener ugc nofollow" target="_blank">地平线</a>代替使用。</p><p id="b71c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">Horizon为您的Laravel支持的Redis队列提供了一个漂亮的仪表板和代码驱动的配置。当使用Horizon时，您将把入口点更新为<code class="fe nt nu nv lp b">entrypoint: ['php', '/var/www/html/artisan', 'horizon']</code>。</p><h2 id="d842" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.7.邮件猪服务</h2><p id="85cb" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated"><a class="ae kv" href="https://github.com/mailhog/MailHog" rel="noopener ugc nofollow" target="_blank"> Mailhog </a>是一个很好的工具，可以确认你的邮件在开发环境中是否像预期的那样工作。它有一个基于网络的用户界面，你可以在那里查看你的电子邮件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">邮件猪服务</p></figure><p id="2d32" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">此服务基于<code class="fe nt nu nv lp b">mailhog/mailhog:latest</code>图像。这不是一个官方的图像，但是Mailhog团队支持它，所以你可以放心。与官方图像不同，官方图像的图像存储库被指定为{repository}:{tag}。这里我们还必须标识用户，{user}/{repository}:{tag}。</p><p id="e912" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">默认情况下，Mailhog存储日志。这些对我们没有用，所以我们将把<code class="fe nt nu nv lp b">logging driver</code>设置为none。</p><p id="f65b" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">端口<code class="fe nt nu nv lp b">8025</code>用于连接用户界面仪表板，而端口<code class="fe nt nu nv lp b">1025</code>用于连接邮件服务器。您可以通过主机上的<code class="fe nt nu nv lp b"><a class="ae kv" href="http://localhost:8025" rel="noopener ugc nofollow" target="_blank">http://localhost:8025</a></code>访问仪表板。</p><h2 id="726a" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">8.8.PhpMyAdmin服务</h2><p id="0b83" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">PhpMyAdmin将为我们提供一个GUI来管理我们的数据库，而不必通过shell/终端来访问它。以下是其服务配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PhpMyAdmin服务</p></figure><p id="ad83" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">该服务基于<code class="fe nt nu nv lp b">phpmyadmin:5.2.0</code>，T5是预先配置的<a class="ae kv" href="https://hub.docker.com/_/phpmyadmin" rel="noopener ugc nofollow" target="_blank">官方码头形象</a>。</p><p id="cc4b" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">Compose将从我们的<code class="fe nt nu nv lp b">.env</code>文件中自动选择环境变量<code class="fe nt nu nv lp b">${DB_HOST}</code>、<code class="fe nt nu nv lp b">${DB_USERNAME}</code>、<code class="fe nt nu nv lp b">${DB_PASSWORD}</code>和<code class="fe nt nu nv lp b">${DB_PORT}</code>。该服务依赖于<code class="fe nt nu nv lp b">mysql</code>，因此数据库需要在启动我们的GUI之前运行。主机使用端口<code class="fe nt nu nv lp b">8888</code>连接到我们的接口。您可以通过<code class="fe nt nu nv lp b"><a class="ae kv" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank">http://localhost:8888</a></code>访问PhpMyAdmin仪表板。</p><h1 id="633a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">9.实用集装箱</h1><p id="ed25" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">当使用命令<code class="fe nt nu nv lp b">docker-compose up</code>启动docker容器时，<code class="fe nt nu nv lp b">docker-compose.yml</code>文件中的所有服务都将被启动。但是，您应该只在需要时运行实用工具容器。</p><p id="8a90" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">为了只启动主容器，我们使用命令<code class="fe nt nu nv lp b">docker-compose up build nginx</code>。这将确保只有<code class="fe nt nu nv lp b">nginx service</code>依赖的容器才会启动。这些是在<code class="fe nt nu nv lp b">nginx service</code>的<code class="fe nt nu nv lp b">depends_on</code>部分列出的容器。</p><p id="50af" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们还将使用<code class="fe nt nu nv lp b"><a class="ae kv" href="https://docs.docker.com/compose/profiles/" rel="noopener ugc nofollow" target="_blank">profiles</a></code>来锁定实用程序服务，以便它们仅在个人配置文件被激活或使用<code class="fe nt nu nv lp b">docker-compose run service_name</code>运行特定服务时才启动。</p><p id="e129" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">运行工具容器时，使用命令<code class="fe nt nu nv lp b">docker-compose run --rm</code>而不是<code class="fe nt nu nv lp b">docker-compose up</code>。服务/容器参数被附加在末尾。<code class="fe nt nu nv lp b">run</code>用于对服务运行一次性命令，而<code class="fe nt nu nv lp b">--rm</code>在运行命令后移除容器。如果需要连接到其他docker容器，使用<code class="fe nt nu nv lp b">--service-ports</code>选项。比如<code class="fe nt nu nv lp b">docker-compose run --rm --service-ports service_name argument</code>。</p><h2 id="66a4" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">9.1.迁移种子服务</h2><p id="126d" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">该服务运行迁移和种子程序。也是基于<code class="fe nt nu nv lp b">php.dockerfile</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">laravel-迁移-种子服务</p></figure><p id="9dc5" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">当容器启动时，该服务的入口点将依次运行命令<code class="fe nt nu nv lp b">php artisan migrate</code>和<code class="fe nt nu nv lp b">php artisan db:seed</code>。</p><h2 id="ce62" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行laravel-migrate-seed命令</h2><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="bec0" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm laravel-migrate-seed</span></pre><h2 id="e513" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">9.2.作曲家服务</h2><p id="afc7" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">Composer 是PHP的依赖管理器。Composer服务用于运行composer命令。它使用一个名为<code class="fe nt nu nv lp b">composer.dockerfile</code>的定制docker文件，其上下文是我们项目的docker文件夹。</p><p id="355c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">以下是服务配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作曲家服务</p></figure><h2 id="1268" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">composer.dockerfile</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">composer.dockerfile</p></figure><p id="8309" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">这个docker文件基于<a class="ae kv" href="https://hub.docker.com/_/composer" rel="noopener ugc nofollow" target="_blank"> composer:2 </a>映像，这是一个官方的预构建composer版本2 docker映像文件。</p><h2 id="bc6c" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行编写器命令</h2><p id="c416" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">使用命令<code class="fe nt nu nv lp b">docker-compose run --rm </code>启动编写器命令，并在末尾添加编写器参数。查看下表中的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编写器命令</p></figure><h2 id="80ec" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">9.3.工匠服务</h2><p id="a81e" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">该服务运行Laravel artisan命令。它基于<code class="fe nt nu nv lp b">php.dockerfile</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">工匠服务</p></figure><h2 id="50da" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行artisan命令</h2><p id="114f" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">像composer命令一样，artisan命令使用命令<code class="fe nt nu nv lp b">docker-compose run --rm </code>开始，并在末尾加上artisan参数。以下是一些例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">artisan命令</p></figure><h2 id="3e46" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">9.4.Npm服务</h2><p id="8103" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">我们将使用此服务来运行npm命令。是基于官方<a class="ae kv" href="https://hub.docker.com/layers/library/node/alpine/images/sha256-1cdf154f10cf19a7eac49b44bce405791e0dc972484ec4a9c3d18cb75938999e?context=explore" rel="noopener ugc nofollow" target="_blank">节点:阿尔卑斯</a> docker形象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">npm服务</p></figure><h2 id="ab1d" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行npm命令</h2><p id="871b" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">npm命令也是使用命令<code class="fe nt nu nv lp b">docker-compose run --rm </code>开始的，并在末尾加上NPM参数。然而，当运行<code class="fe nt nu nv lp b">npm run dev</code>时，需要在这个npm容器和PHP容器之间建立通信，以便进行热重装。因此，我们在命令中包含了<code class="fe nt nu nv lp b">--service-ports</code>选项。</p><p id="975f" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">npm命令的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">npm命令</p></figure><h1 id="7de4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">10.配置Vite资产捆绑器和惯性工具</h1><p id="5dba" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">从Laravel 9开始，通过引入前端资产捆绑器<a class="ae kv" href="https://vitejs.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="ma ir"> Vite </strong> </a>，开发者体验得到了改善。此前，Laravel使用<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>作为其默认的资产捆绑器。在本指南中，我们将使用Vite将ReactJS集成到Laravel中。</p><p id="cf72" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><a class="ae kv" href="http://inertiajs.com" rel="noopener ugc nofollow" target="_blank"> InertiaJS </a>将帮助我们在一个项目中包含React和Laravel堆栈。你可以把它看作是把我们的前端和后端栈粘在一起的胶水。通过在终端中键入以下命令来安装InertiaJS:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="827b" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm composer require inertiajs/inertia-laravel</span></pre><p id="dca9" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">让我们使用下面的artisan命令在我们的项目中安装惯性中间件:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="fcc1" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm artisan inertia: middleware</span></pre><p id="9a84" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">转到<code class="fe nt nu nv lp b">src/app/Http</code>目录，然后在<code class="fe nt nu nv lp b">Kernel.php</code>文件中，在<code class="fe nt nu nv lp b">$middlewareGroups[]</code>数组的<code class="fe nt nu nv lp b">web[]</code>数组中添加下面一行。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="eb6f" class="lt kx iq lp b gy lu lv l lw lx">'web' =&gt; [<br/>  // ...<br/>  \App\Http\Middleware\HandleInertiaRequests::class,<br/>],</span></pre><p id="6f79" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">当用JavaScript而不是blade渲染时，为了在前端识别我们的路线，我们将使用一个名为<a class="ae kv" href="https://github.com/tighten/ziggy" rel="noopener ugc nofollow" target="_blank"> ziggy </a>的特殊包。让我们使用composer安装它。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="239f" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm composer require tightenco/ziggy</span></pre><p id="0ed0" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">因为我们要创建一个单页面应用程序(SPA)，我们需要为我们的应用程序的UI设置一个<code class="fe nt nu nv lp b">blade</code>入口点。</p><p id="3c1c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">让我们创建一个新的刀片文件<code class="fe nt nu nv lp b">app.blade.php</code>。这将是我们的切入点。将以下代码放入文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="01a4" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><code class="fe nt nu nv lp b">@vite()</code>和<code class="fe nt nu nv lp b">@viteReactRefresh</code>告诉Laravel应用程序，Vite正在编译我们的资源(JS和CSS文件),我们将使用JSX作为我们的前端。CSS文件也可以通过添加行<code class="fe nt nu nv lp b">@vite('resources/css/app.css')</code>从这个文件中调用。然而，从<code class="fe nt nu nv lp b">resources/js/app.jsx</code>文件中调用它并在<code class="fe nt nu nv lp b">blade</code>中调用这个文件是理想的，如上图所示。</p><h2 id="2695" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">设置React前端</h2><p id="d651" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">我们将使用<code class="fe nt nu nv lp b">npm container</code>来安装我们的前端依赖项。</p><p id="dc94" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在您的终端上运行以下命令:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="5142" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm npm i react react-dom @inertiajs/inertia @inertiajs/inertia-react jsconfig.json @inertiajs/progress</span></pre><p id="40ed" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">上面的命令将安装React、react-dom、惯性前端依赖项、用于页面加载的惯性进度条和一个<code class="fe nt nu nv lp b">jsconfig.json</code>文件。</p><p id="1adb" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">接下来，我们将为React添加vite插件。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="061a" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm npm add @vitejs/plugin-react</span></pre><p id="6ab2" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">转到<code class="fe nt nu nv lp b">src/resources/js/app.js</code>文件，在<code class="fe nt nu nv lp b">import "./bootstrap"</code>语句下面添加以下脚本。然后将文件重命名为<code class="fe nt nu nv lp b">app.jsx</code>。正如你所看到的,<code class="fe nt nu nv lp b">app.css</code>从这个文件中被导入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f5b9" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">最后，我们需要告诉Vite我们正在使用React并指定我们的入口点文件。我们将把我们的配置放在<code class="fe nt nu nv lp b">src/vite.config.js</code>中，这是一个默认安装在Laravel 9中的文件。让我们来看看，修改并添加以下代码行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="638c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><code class="fe nt nu nv lp b">input: "resources/js/app.jsx",</code>行指定了我们的JSX入口点。<code class="fe nt nu nv lp b">server settings</code>指定<code class="fe nt nu nv lp b">npm container</code>地址和服务端口。如我们的docker文件所示，可以通过端口<code class="fe nt nu nv lp b">3000</code>访问<code class="fe nt nu nv lp b">npm container</code>。</p><h2 id="0460" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">创建欢迎页面和欢迎路线</h2><p id="f11d" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">现在让我们为欢迎页面创建路线。转到文件<code class="fe nt nu nv lp b">src/routes/web.php</code>并添加下面几行，让Laravel知道到我们欢迎页面的路径。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3505" class="lt kx iq lp b gy lu lv l lw lx">Route::get('/', function () {<br/>   return inertia('Welcome');<br/>}</span></pre><p id="6698" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">然后，我们将创建我们的前端欢迎页面。创建一个新文件夹<code class="fe nt nu nv lp b">Pages</code>并将一个<code class="fe nt nu nv lp b">Welcome.jsx</code>文件添加到<code class="fe nt nu nv lp b">src/resources/js/</code>目录中。将以下代码放入文件中。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="62ee" class="lt kx iq lp b gy lu lv l lw lx">export default function Welcome () {<br/>    return (<br/>        &lt;&gt;<br/>            &lt;div&gt;<!-- -->Hello Docker Multiverse!<!-- -->&lt;/div&gt;<br/>        &lt;/&gt;<br/>    );<br/>}</span></pre><h1 id="1aac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">11.启动您的容器</h1><h2 id="6ea3" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行迁移</h2><p id="daba" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">通过运行以下命令创建数据库表:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="89f6" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm laravel-migrate-seed</span></pre><p id="f528" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">它将创建在Laravel迁移文件中配置的默认数据库表。</p><h2 id="acc1" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">启动主容器</h2><p id="3ba3" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">要启动<code class="fe nt nu nv lp b">main containers</code>,请转到项目目录的根目录并运行以下命令:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3e8d" class="lt kx iq lp b gy lu lv l lw lx">docker-compose up --build nginx -d</span></pre><p id="198f" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">我们正在运行上面的命令，而不是仅仅运行<code class="fe nt nu nv lp b">docker-compose up --build -d</code>，因为我们只想启动<code class="fe nt nu nv lp b">main containers</code>。我们的<code class="fe nt nu nv lp b">nginx container</code>依赖于所有其他主要容器；因此，它将首先启动它们。</p><p id="30e9" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><code class="fe nt nu nv lp b">-d</code>参数以守护模式静默运行命令，而不在终端上输出日志。</p><p id="47ec" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">在docker映像构建之后，容器将一个接一个地上线。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/86b6f248d65cb305b605de00e673bfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRPYBrCr5dF0RzoiWwvTcA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">启动主容器</p></figure><p id="c57f" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">您可以通过在终端上运行命令<code class="fe nt nu nv lp b">docker ps</code>来检查正在运行的容器，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/c40590b7871dc18716cbec6ff628bc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUjBZ88ThB0vttCVVTntDA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行容器</p></figure><h2 id="41b7" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">Laravel应用程序配置</h2><p id="a564" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">通过运行以下命令，使用composer安装PHP软件包:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3bfe" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm composer install</span></pre><p id="d20c" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">让我们通过设置应用程序键并清除任何缓存的配置文件来结束我们的应用程序配置。我们可以通过运行以下命令来实现这一点。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="97dd" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm artisan key:generate<br/>docker-compose run --rm artisan optimize</span></pre><p id="3520" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">当artisan和composer容器启动时，我们的本地应用程序代码被装载到这些容器中。因此，运行上面的命令将会更新容器的代码和机器本地的代码，就像在本地运行命令一样。</p><h2 id="9cd5" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">运行React前端</h2><p id="e47a" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">我们将使用下面的命令在开发模式下运行React前端，并启用热重装。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="7482" class="lt kx iq lp b gy lu lv l lw lx">docker-compose run --rm  --service-ports npm run dev</span></pre><p id="b007" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><strong class="ma ir">注意</strong>:确保您更新了应用程序的<code class="fe nt nu nv lp b">.env</code>文件，以反映正确的<code class="fe nt nu nv lp b">APP_URL</code>。暴露的端口决定了我们的<code class="fe nt nu nv lp b">nginx service</code>中指定的URL。在我们的例子中，我们使用端口<code class="fe nt nu nv lp b">8000</code>。我们将把<code class="fe nt nu nv lp b">APP_URL</code>更新为<code class="fe nt nu nv lp b">APP_URL=http://localhost:8000</code>。</p><h2 id="aa2e" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">现在让我们来看看我们的应用程序:</h2><p id="a55e" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">在您的浏览器中插入以下任意URL。</p><p id="4d6a" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">应用—<a class="ae kv" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></p><p id="9411" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated">应该会呈现出<code class="fe nt nu nv lp b">src/resources/js/Pages/Welcome.jsx</code>页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/e17dfb85f0a7a69ea876c9aec52b4b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*M53UKOsyNz27OY77XgQdIA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">申请欢迎页面</p></figure><p id="faba" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><strong class="ma ir">麦猪</strong>——<code class="fe nt nu nv lp b"><a class="ae kv" href="http://localhost:8025/" rel="noopener ugc nofollow" target="_blank">http://localhost:8025</a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/3b9180f30980fd8401829a7eb60152bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oO4q1RJYYPIbZ4aDxDDIoA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">邮件猪页面</p></figure><p id="c4c5" class="pw-post-body-paragraph ly lz iq ma b mb mu jr md me mv ju mg mh mw mj mk ml mx mn mo mp my mr ms mt ij bi translated"><strong class="ma ir">PhpMyAdmin</strong>——<code class="fe nt nu nv lp b"><a class="ae kv" href="http://localhost:8888/" rel="noopener ugc nofollow" target="_blank">http://localhost:8888</a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/6d955a9023d0063c53f6edc552586e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t59x7UKotl3XB0U--3_DQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">phpMyAdmin页面</p></figure><h1 id="da51" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">12.将代码推送到GitHub</h1><p id="a20e" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">为了能够跟踪项目，我们将把它推送到GitHub。</p><h2 id="9de9" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">创建本地存储库</h2><ul class=""><li id="b32f" class="mz na iq ma b mb mc me mf mh np ml nq mp nr mt ne nf ng nh bi translated">进入我们项目的父目录。</li><li id="fbe7" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">类型<code class="fe nt nu nv lp b">git init</code>。</li><li id="3b08" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">键入<code class="fe nt nu nv lp b">git add .</code>添加所有相关文件。在<code class="fe nt nu nv lp b">.gitignore</code>中指定的文件将被忽略。</li><li id="0082" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">类型<code class="fe nt nu nv lp b">git commit -m “first commit”</code>。</li></ul><h2 id="f01d" class="lt kx iq bd ky of og dn lc oh oi dp lg mh oj ok li ml ol om lk mp on oo lm op bi translated">将存储库连接到GitHub</h2><ul class=""><li id="99ab" class="mz na iq ma b mb mc me mf mh np ml nq mp nr mt ne nf ng nh bi translated">去<a class="ae kv" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</li><li id="08ed" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">登录您的帐户。</li><li id="f5a3" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">点击右上角的<a class="ae kv" href="https://github.com/new" rel="noopener ugc nofollow" target="_blank">新建存储库</a>按钮，初始化一个空存储库。</li><li id="b09d" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">单击“创建存储库”按钮。</li><li id="6cd6" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">复制存储库的URL。</li><li id="6c87" class="mz na iq ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">在您的终端上，在项目目录的根目录下，键入下面的命令，并用您的URL替换存储库URL。</li></ul><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6c8e" class="lt kx iq lp b gy lu lv l lw lx">git remote add origin <a class="ae kv" href="https://github.com/elvinlari/test-we.git" rel="noopener ugc nofollow" target="_blank">https://github.com/</a><a class="ae kv" href="https://github.com/elvinlari/test-azk" rel="noopener ugc nofollow" target="_blank">username/</a>new_repo<a class="ae kv" href="https://github.com/elvinlari/test-we.git" rel="noopener ugc nofollow" target="_blank">.git</a><br/>git branch -M main<br/>git push -u origin main</span></pre><ul class=""><li id="547f" class="mz na iq ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">最后，您可以添加一个许可证文件和一个自述文件来描述项目。您可以直接从GitHub完成这项工作，也可以在本地创建文件并将更改推送到GitHub。</li></ul><h1 id="e157" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">13.资源/链接</h1><p id="95ed" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated"><a class="ae kv" href="https://github.com/elvinlari/laravel-vite-docker" rel="noopener ugc nofollow" target="_blank"> GitHub </a> —具有预配置Docker设置的Laravel 9 plus React项目。</p><h1 id="5123" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="4951" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg mh mi mj mk ml mm mn mo mp mq mr ms mt ij bi translated">我希望这是一个有用的指南。感谢您的阅读！</p></div></div>    
</body>
</html>