<html>
<head>
<title>A Deep Dive Into JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究JavaScript对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deeper-dive-into-javascript-objects-c18ce52869eb?source=collection_archive---------6-----------------------#2021-04-19">https://betterprogramming.pub/a-deeper-dive-into-javascript-objects-c18ce52869eb?source=collection_archive---------6-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9899" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索JavaScript中对象的细节</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbb43f20681401da279fba315ee31ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkeHODGG7N6fnBgRFUbJ6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="ed18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript对象是基础。花时间深入挖掘它们将会产生更干净和更有性能的代码。</p><p id="5777" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">注意:本文假设您了解对象的基本知识。如果您想快速复习对象，请查看由Arfat Salman </em>  <em class="lr">编写的</em><a class="ae ls" href="https://blog.bitsrc.io/the-chronicles-of-javascript-objects-2d6b9205cd66" rel="noopener ugc nofollow" target="_blank"><em class="lr">JavaScript对象编年史</em> </a> <em class="lr">。</em></p><p id="1a9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们开始吧！</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="bf42" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">议程</h1><ul class=""><li id="2d01" class="mu mv iq kx b ky mw lb mx le my li mz lm na lq nb nc nd ne bi translated"><a class="ae ls" href="#8a35" rel="noopener ugc nofollow">只读对象</a></li><li id="f741" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><a class="ae ls" href="#6b8a" rel="noopener ugc nofollow">浅vs深</a></li><li id="6dfc" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><a class="ae ls" href="#a453" rel="noopener ugc nofollow">作为图元的对象</a></li><li id="72b1" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><a class="ae ls" href="#b8cc" rel="noopener ugc nofollow">物体与地图</a></li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="8a35" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">只读对象</h1><p id="c48f" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">假设我们想要创建一个枚举来表示基本方向:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e749" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，现有属性/键可以更改，新属性可以添加到<code class="fe np nq nr ns b">DIRECTIONS</code>中。这在较大的代码库中可能是危险的，因为意外编辑枚举/只读对象的可能性会更大。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2a02" class="nx md iq ns b gy ny nz l oa ob">DIRECTIONS.NORTH = "south"; //nothing stopping this from happening</span></pre><p id="1130" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输入<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">Object.freeze</a></code>。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2ead" class="nx md iq ns b gy ny nz l oa ob">Object.freeze(DIRECTIONS);</span></pre><p id="7db3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">Object.freeze</code>取消了添加新属性和编辑/删除现有属性的功能。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="79c6" class="nx md iq ns b gy ny nz l oa ob">Object.freeze(DIRECTIONS);</span><span id="6fbc" class="nx md iq ns b gy oc nz l oa ob">/*The below either fail silently or a TypeError will be thrown*/<br/>DIRECTIONS.NORTH = "south";<br/>DIRECTIONS.UP = "up";<br/>del DIRECTIONS.SOUTH;</span></pre><p id="5b57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">Object.freeze</code>还限制改变对象单个属性的<a class="ae ls" href="https://javascript.info/property-descriptors" rel="noopener ugc nofollow" target="_blank">属性描述符</a>的能力。属性描述符类似于属性的“设置”。以下是它包含的四个字段:</p><ul class=""><li id="27c3" class="mu mv iq kx b ky kz lb lc le od li oe lm of lq nb nc nd ne bi translated"><code class="fe np nq nr ns b">value</code>:财产的实际。</li><li id="6ecf" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><code class="fe np nq nr ns b">enumerable</code>:确定在对象的属性上迭代/枚举时是否会出现一个属性。如果属性的<code class="fe np nq nr ns b">enumerable</code>是<code class="fe np nq nr ns b">true</code>，那么当我们用<code class="fe np nq nr ns b">for _ in</code>迭代一个对象时，它就会显示出来，并且会包含在<code class="fe np nq nr ns b">Object.keys()</code>中。</li><li id="431f" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><code class="fe np nq nr ns b">configurable</code>:确定是否可以从对象中删除属性，或者是否可以更改对象的属性描述符。</li><li id="c656" class="mu mv iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><code class="fe np nq nr ns b">writable</code> : <strong class="kx ir"> </strong>决定属性的值是否可以通过赋值来改变。</li></ul><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="4cf6" class="nx md iq ns b gy ny nz l oa ob">const obj = {'a': 1, 'b':2};<br/>console.log(Object.getOwnPropertyDescriptors(obj));<br/>/*<br/>Here is the output of the property descriptors of obj:<br/>{<br/>a: {value: 1, writable: true, enumerable: true, configurable: true},<br/>b: {value: 2, writable: true, enumerable: true, configurable: true}<br/>}<br/>*/</span></pre><p id="8cf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">Object.freeze</code>将保持<code class="fe np nq nr ns b">enumerable</code>不变，但会为对象中的属性设置<code class="fe np nq nr ns b">configurable</code>和<code class="fe np nq nr ns b">writable</code>为<code class="fe np nq nr ns b">false</code>。因此，我们不能再编辑属性描述符(我们不能再改变<code class="fe np nq nr ns b">writable</code>、<code class="fe np nq nr ns b">enumerable</code>或<code class="fe np nq nr ns b">configurable</code>)，也不能再改变属性的值。</p><p id="fd7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">注意:</em> <code class="fe np nq nr ns b"><em class="lr">Object.freeze</em></code> <em class="lr">只对顶级属性进行这些限制。</em></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7940" class="nx md iq ns b gy ny nz l oa ob">const o = {a: 0, b: {c: 5}};<br/>Object.freeze(o);</span><span id="875c" class="nx md iq ns b gy oc nz l oa ob">o.b.c = 10; // this is valid</span></pre><p id="0eec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些提到的限制对属性<code class="fe np nq nr ns b">a</code>和<code class="fe np nq nr ns b">b</code>有效，但对属性<code class="fe np nq nr ns b">c</code>无效。即使在冻结对象后，我们也可以编辑<code class="fe np nq nr ns b">c</code>的值。</p><p id="cb24" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能需要递归调用子对象上的<code class="fe np nq nr ns b">Object.freeze</code>来确保整个对象被冻结。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="6b8a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">浅层与深层</h1><p id="b031" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">与原语不同，JavaScript对象是通过引用传递的，引用是指向对象在内存中“驻留”位置的指针。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="ba45" class="nx md iq ns b gy ny nz l oa ob">const myPet = {<br/>  name: "Doggie",<br/>  type: "Dog"<br/>}</span></pre><p id="2648" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">myPet</code>存储分配给它的对象的引用——而不是对象本身。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="da45" class="nx md iq ns b gy ny nz l oa ob">const yourPet = myPet;<br/>yourPet.name = "Cattie";<br/>console.log(myPet);</span><span id="ee9f" class="nx md iq ns b gy oc nz l oa ob">/*<br/>Here is the output of myPet:<br/>{ name: 'Cattie', type: 'Dog' }<br/>*/</span></pre><p id="0d86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方式的分配会将引用<code class="fe np nq nr ns b">myPet</code>商店复制到<code class="fe np nq nr ns b">yourPet</code>。因此，<code class="fe np nq nr ns b">yourPet</code>和<code class="fe np nq nr ns b">myPet</code>仍然引用同一个对象。</p><p id="37fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，如果我在<code class="fe np nq nr ns b">yourPet</code>中编辑一个属性，这个编辑将会反映在<code class="fe np nq nr ns b">myPet</code>中，因为它们仍然引用同一个对象。</p><p id="f7cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们有两个变量存储对同一个对象的引用时，我们可以称它们为<em class="lr">浅</em>副本。</p><p id="fc45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，创建浅表副本的一种方式是通过赋值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="a42b" class="nx md iq ns b gy ny nz l oa ob">const obj = {"a": 0};<br/>const anotherObj = obj; // shallow copy</span></pre><p id="ed30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">Object.is</a></code>来测试浅相等。<code class="fe np nq nr ns b">Object.is</code>测试两个变量是否引用同一个对象。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="084d" class="nx md iq ns b gy ny nz l oa ob">const obj = {"a": 0};<br/>const anotherObj = obj;<br/>Object.is(obj, anotherObj); // returns true</span></pre><p id="10e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是等等！为什么下面返回<code class="fe np nq nr ns b">false</code>？</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="c32a" class="nx md iq ns b gy ny nz l oa ob">const histo1 = {"a": 0};<br/>const histo2 = {"a": 0};<br/>Object.is(histo1, histo2); // returns false</span></pre><p id="ce9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然<code class="fe np nq nr ns b">histo1</code>和<code class="fe np nq nr ns b">histo2</code>的对象内容相同，但这并不意味着<code class="fe np nq nr ns b">histo1</code>和<code class="fe np nq nr ns b">histo2</code>在内存中指向同一个对象。结果，<code class="fe np nq nr ns b">histo1</code>和<code class="fe np nq nr ns b">histo2</code>不是浅拷贝，因为它们的引用指向不同的对象，而这些对象恰好具有相同的内容。</p><p id="a808" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">histo1</code>和<code class="fe np nq nr ns b">histo2</code>是<em class="lr">深</em>副本。</p><p id="ba4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建深层副本有几个选项。</p><h2 id="817c" class="nx md iq bd me og oh dn mi oi oj dp mm le ok ol mo li om on mq lm oo op ms oq bi translated">使用JSON进行深度复制</h2><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="15c0" class="nx md iq ns b gy ny nz l oa ob">const me = {"name": "Ramki"};<br/>const you = JSON.parse(JSON.stringify(me));</span></pre><p id="71c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想法是使用<code class="fe np nq nr ns b">JSON.stringify</code>将对象转换为字符串，然后使用<code class="fe np nq nr ns b">JSON.parse</code>解析字符串以检索编码的对象。主要的限制是属性为函数的对象不能被正确复制，因为<code class="fe np nq nr ns b">JSON.stringify</code>不能编码函数(<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank">JSON.Stringify</a></code>)。</p><h2 id="12ae" class="nx md iq bd me og oh dn mi oi oj dp mm le ok ol mo li om on mq lm oo op ms oq bi translated">带Lodash的深层副本</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e622" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以从<a class="ae ls" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>导入<code class="fe np nq nr ns b"><a class="ae ls" href="https://www.tutorialspoint.com/lodash/lodash_clonedeep.htm" rel="noopener ugc nofollow" target="_blank">cloneDeep</a></code>。这是一种递归克隆传入对象属性的方法。返回的对象将是深层副本。主要的缺点是，我们必须安装一个外部库，增加应用程序的总大小，以便创建一个深层副本。</p><p id="3b81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在对象的值是JSON兼容的情况下，使用<code class="fe np nq nr ns b">JSON.stringify</code>方法可能更简单。否则，<code class="fe np nq nr ns b">lodash.cloneDeep</code>是最好的做法。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a453" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">作为原语的对象</h1><p id="5db5" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">虽然绑定到一个对象的变量存储了它的引用，但是仍然可以通过覆盖<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" rel="noopener ugc nofollow" target="_blank">Object.prototype.valueOf</a></code>来获得对象的原始值。</p><p id="a056" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">Object.prototype.valueOf</code>是返回对象原始值的函数。默认情况下，它返回对象本身，但可以被重写以返回其他内容。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="151a" class="nx md iq ns b gy ny nz l oa ob">const result = 1 + new Number(14);<br/>console.log(result);</span><span id="f183" class="nx md iq ns b gy oc nz l oa ob">// result: 15</span></pre><p id="c939" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank">Number</a></code>是数字的包装对象。有趣的是，当我们将一个原语(<code class="fe np nq nr ns b">1</code>)添加到一个对象(<code class="fe np nq nr ns b">new Number(14)</code>)时，我们最终仍然会得到正确的结果<code class="fe np nq nr ns b">15</code>。</p><p id="8914" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们将<code class="fe np nq nr ns b">1</code>添加到<code class="fe np nq nr ns b">new Number(14)</code>时，JavaScript会自动将<code class="fe np nq nr ns b">new Number(14)</code>转换为其原始值<code class="fe np nq nr ns b">14</code>。这个原始值是从<code class="fe np nq nr ns b">Number.prototype.valueOf()</code>中获取的，它被覆盖以提供<code class="fe np nq nr ns b">Number</code>对象存储的实际数值。</p><p id="f81f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看另一个例子:假设我们有一个<code class="fe np nq nr ns b">StringBuilder</code>对象来有效地连接字符串。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8991" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们想以如下方式使用它:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="42e7" class="nx md iq ns b gy ny nz l oa ob">const builder = new StringBuilder();<br/>builder.add("B");<br/>builder.add("C");</span><span id="65c3" class="nx md iq ns b gy oc nz l oa ob">const result = "A" + builder; <br/>//result: want it to be "ABC" but is "A[object Object]"</span></pre><p id="fc76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让<code class="fe np nq nr ns b">result</code>等于<code class="fe np nq nr ns b">“ABC”</code>，我们可以覆盖<code class="fe np nq nr ns b">StringBuilder.prototype.valueOf</code>来提供<code class="fe np nq nr ns b">builder.strings</code>的串联。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2742" class="nx md iq ns b gy ny nz l oa ob">StringBuilder.prototype.valueOf = function() {<br/>   return this.concat();<br/>}</span></pre><p id="547d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当一个<code class="fe np nq nr ns b">StringBuilder</code>对象被转换成一个原语，该原语将是我们添加到该对象中的所有字符串的串联。</p><p id="61eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以覆盖<code class="fe np nq nr ns b">Object.prototype.valueOf</code>来在对象被转换成原语时为它们提供定制的原语值。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="b8cc" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">对象与地图</h1><p id="6f33" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">虽然JavaScript提供了一个<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">Map</a></code>类，但是很多经常使用对象来映射键和值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">著名的二和问题的一个变种，使用物体作为地图</p></figure><p id="9b56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">twoSumCount</code>使用<code class="fe np nq nr ns b">Map</code>数据结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="21ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管它们的用法看起来相似，但还是有一些不同。</p><h2 id="6e8f" class="nx md iq bd me og oh dn mi oi oj dp mm le ok ol mo li om on mq lm oo op ms oq bi translated">键</h2><p id="0050" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">对象的键只能是字符串或<code class="fe np nq nr ns b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">Symbol</a></code>。</p><p id="52fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">等一下。在<code class="fe np nq nr ns b">twoSumCount</code>中我们不是只用数字作为键吗？</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="6de7" class="nx md iq ns b gy ny nz l oa ob">const obj = {};<br/>obj[1] = "Something";<br/>console.log(Object.keys(obj));</span><span id="f68d" class="nx md iq ns b gy oc nz l oa ob">//output: ["1"]</span></pre><p id="b850" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用的整数键会自动转换成字符串。如果我们想使用其他对象作为键，这可能会有问题。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="84d1" class="nx md iq ns b gy ny nz l oa ob">obj = {};<br/>obj[{}] = {};<br/>console.log(Object.keys(obj));</span><span id="abe3" class="nx md iq ns b gy oc nz l oa ob">//output: ['[object Object]']</span></pre><p id="43f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，有了<code class="fe np nq nr ns b">Map</code>，键的类型将不再局限于字符串或<code class="fe np nq nr ns b">Symbol</code>。我们可以有对象、函数、数字等等。作为钥匙。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="330b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，对象在实例化时可以有默认的键。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2ab8" class="nx md iq ns b gy ny nz l oa ob">const map = {};<br/>console.log(map['toString']); </span><span id="ff60" class="nx md iq ns b gy oc nz l oa ob">//output: [Function: toString]</span></pre><p id="29c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使我们的<code class="fe np nq nr ns b">obj</code>是空的，它仍然继承自<code class="fe np nq nr ns b">Object.prototype</code>。因此，初始化时<code class="fe np nq nr ns b">obj</code>中存在<code class="fe np nq nr ns b">toString</code>和<code class="fe np nq nr ns b">valueOf</code>等密钥。为了移除这些默认键，最好使用不从任何东西继承的对象。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b4c8" class="nx md iq ns b gy ny nz l oa ob">const map = Object.create(null);<br/>console.log(map['toString']);</span><span id="bc3d" class="nx md iq ns b gy oc nz l oa ob">//output: undefined</span></pre><p id="ee34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">Object.create(null)</code>确保在初始化时对象中没有来自原型继承的键，减少了键冲突的机会。</p><h2 id="fd44" class="nx md iq bd me og oh dn mi oi oj dp mm le ok ol mo li om on mq lm oo op ms oq bi translated">表演</h2><p id="5bff" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">根据<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a> , <code class="fe np nq nr ns b">Map</code>据说在频繁添加和删除的场景中比objects表现更好。尽管如此，我还是决定对对象和地图进行性能测试。</p><p id="dd7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">性能测试分为四个部分:添加、检索、枚举和删除键。钥匙的数量将是一百万。代码的REPL链接如下:</p><div class="or os gp gr ot ou"><a href="https://replit.com/@ramapitchala/KlutzyAlarmingLanservers" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">笨手笨脚杞人忧天</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">ramapitchala的Node.js repl</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">replit.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi kp ou"/></div></div></a></div><p id="aded" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">令人惊讶的是，我发现在REPL运行时，性能测试更喜欢对象而不是地图。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="bd34" class="nx md iq ns b gy ny nz l oa ob">Node Version: 12.22.1</span><span id="1b53" class="nx md iq ns b gy oc nz l oa ob">Map: Adding Keys: 676.662ms<br/>Map: Getting Keys: 437.161ms<br/>Map: Enumeration: 4580.738ms<br/>Map: Deleting Keys: 699.071ms<br/>=============================<br/>Object: Adding Keys: 135.423ms<br/>Object: Getting Keys: 92.645ms<br/>Object: Enumeration: 4123.763ms<br/>Object: Deleting Keys: 266.606ms</span></pre><p id="78bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是在Razor Stealth计算机上对节点版本14.16.0的结果:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b03a" class="nx md iq ns b gy ny nz l oa ob">Node Version: 14.16.0</span><span id="c819" class="nx md iq ns b gy oc nz l oa ob">Map: Adding Keys: 163.153ms <br/>Map: Getting Keys: 130.77ms <br/>Map: Enumeration: 53.908ms <br/>Map: Deleting Keys: 212.994ms <br/>============================= <br/>Object: Adding Keys: 28.134ms <br/>Object: Getting Keys: 9.936ms <br/>Object: Enumeration: 157.712ms <br/>Object: Deleting Keys: 61.353ms</span></pre><p id="bba5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我的基准测试，<code class="fe np nq nr ns b">Object</code>似乎在除了枚举之外的所有领域都击败了<code class="fe np nq nr ns b">Map</code>。基于此，在存储非字符串键时使用<code class="fe np nq nr ns b">Map</code>，否则使用对象将是最好的方法。</p><p id="669c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我觉得奇怪的是，在性能测试中，地图比对象慢。请让我知道，如果你有任何数据表明，否则。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7093" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="1f43" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">我希望您从这篇文章中学到了一些关于JavaScript对象的新知识。</p><p id="e4ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>