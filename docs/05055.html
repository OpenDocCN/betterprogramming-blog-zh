<html>
<head>
<title>When to Use Strong References Over Weak References in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中何时使用强引用而非弱引用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-strong-references-over-weak-references-in-swift-6238bf8e58bf?source=collection_archive---------15-----------------------#2020-06-03">https://betterprogramming.pub/when-to-use-strong-references-over-weak-references-in-swift-6238bf8e58bf?source=collection_archive---------15-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8de5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们避免过度使用<em class="kf">弱</em> <strong class="ak"> </strong>引用</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/8c00f782feb923637eff734d07bf6216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXB9cKf1SbT0tIsnMbn30w.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">希瑟·福特在<a class="ae kw" href="https://unsplash.com/s/photos/be-strong-coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="f457" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">概观</h1><p id="9f05" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">如果我们谈到内存泄漏，我们首先要检查的是保留周期。<strong class="lr ir"> </strong>为了避免这种情况我们声明<em class="ml"> </em>属性或者<em class="ml"> </em> <code class="fe mm mn mo mp b">self</code> <em class="ml"> </em>一个<em class="ml"/><code class="fe mm mn mo mp b">weak</code><em class="ml">。</em></p><p id="423a" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">因为声明<code class="fe mm mn mo mp b">weak</code>已经成为我们容易的逃避方式——有时我们开始声明<code class="fe mm mn mo mp b">weak</code>，即使没有保留循环发生。我们将讨论几个我们误解用例的场景。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="f642" class="kx ky iq bd kz la nc lc ld le nd lg lh jw ne jx lj jz nf ka ll kc ng kd ln lo bi translated"><strong class="ak">保持循环</strong></h1><p id="c9d1" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在开始之前，让我们了解一下什么是保留周期以及内存泄漏是如何发生的。</p><p id="f9e8" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">让我们通过一个例子来研究保留周期:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nh"><img src="../Images/bbd01114a5f4f4b22574b766ba0f8c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuP1KDVXIn_z7tzwQOU2sQ.png"/></div></div></figure><p id="0fe7" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">我们创建了两个类的对象，<code class="fe mm mn mo mp b">First</code>和<code class="fe mm mn mo mp b">Second</code>，并让它们持有彼此的引用，因此每个引用计数增加到<code class="fe mm mn mo mp b">2</code>。</p><p id="4878" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">当我们尝试释放内存时，<code class="fe mm mn mo mp b">deinit</code>没有被调用，因为没有删除所有的引用。我们现在可以发布了吗？不，因为它们不可访问，导致内存泄漏。</p><p id="dd14" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">所以内存泄漏是不可访问的内存，当我们无法释放对象时就会发生。</p><p id="1f65" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">我们通过手动处理释放来解决这个问题:</p><pre class="kh ki kj kk gt ni mp nj nk aw nl bi"><span id="68fa" class="nm ky iq mp b gy nn no l np nq">/// 1. By manual handling</span><span id="3ebc" class="nm ky iq mp b gy nr no l np nq">object1?.secondOne = nil<br/>object2?.firstOne = nil</span><span id="f15b" class="nm ky iq mp b gy nr no l np nq">object2 = nil<br/>object1 = nil</span></pre><p id="f071" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">并制作其中一个属性<code class="fe mm mn mo mp b">weak</code>:</p><pre class="kh ki kj kk gt ni mp nj nk aw nl bi"><span id="ff58" class="nm ky iq mp b gy nn no l np nq">weak var firstOne: First? // changing line 12</span><span id="78dd" class="nm ky iq mp b gy nr no l np nq">///// 2. By Weak approach</span><span id="6499" class="nm ky iq mp b gy nr no l np nq">object2 = nil<br/>object1 = nil</span></pre><p id="778f" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">很好—我们知道如何避免保留周期，但有时我们会误解它是否真的在发生。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="7e9d" class="kx ky iq bd kz la nc lc ld le nd lg lh jw ne jx lj jz nf ka ll kc ng kd ln lo bi translated">四种可以变强的情况</h1><h2 id="0f7e" class="nm ky iq bd kz ns nt dn ld nu nv dp lh ly nw nx lj mc ny nz ll mg oa ob ln oc bi translated">1.处理视图动画时。</h2><p id="77da" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">让我们来学习一下<code class="fe mm mn mo mp b">ViewAnimation</code>类:</p><pre class="kh ki kj kk gt ni mp nj nk aw nl bi"><span id="2ca8" class="nm ky iq mp b gy nn no l np nq">class ViewAnimation {</span><span id="5a9c" class="nm ky iq mp b gy nr no l np nq">func viewAnimate() {</span><span id="a026" class="nm ky iq mp b gy nr no l np nq">// weak self not required below<br/>UIView.animate(withDuration: 0.3) { [weak self] in<br/>    self?.doSometing()<br/>  }<br/>}</span><span id="f9ce" class="nm ky iq mp b gy nr no l np nq">func doSometing() {}</span><span id="793d" class="nm ky iq mp b gy nr no l np nq">}</span></pre><p id="f01e" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">这里您可能使用了<code class="fe mm mn mo mp b">weak self</code> <em class="ml"> </em>也可能没有，但是让我们来理解为什么没有内存泄漏。</p><p id="d5b6" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">这个闭包无疑强烈地捕捉到了<code class="fe mm mn mo mp b">self</code>，但是这些行是写在函数体内部的——类<code class="fe mm mn mo mp b">ViewAnimation</code>是<em class="ml">而不是</em>持有闭包<code class="fe mm mn mo mp b">strongly</code>。</p><p id="d971" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">一旦这个闭包被执行，<code class="fe mm mn mo mp b">ViewAnimation</code>将被释放，因为<code class="fe mm mn mo mp b">animate</code>函数将临时保存引用直到被执行。</p><h2 id="b0cc" class="nm ky iq bd kz ns nt dn ld nu nv dp lh ly nw nx lj mc ny nz ll mg oa ob ln oc bi translated">2.处理DispatchQueue时。</h2><p id="6f09" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">让我们给这个类添加另一个函数— <code class="fe mm mn mo mp b">ViewAnimation</code>:</p><pre class="kh ki kj kk gt ni mp nj nk aw nl bi"><span id="4abc" class="nm ky iq mp b gy nn no l np nq">func whenDispatchHappens() {</span><span id="58df" class="nm ky iq mp b gy nr no l np nq">DispatchQueue.main.asyncAfter(deadline: .now() + 20) { [weak self] in<br/>  self?.doSometing()<br/>  }<br/>}</span><span id="2aea" class="nm ky iq mp b gy nr no l np nq">func doSometing() {}</span></pre><p id="81cf" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">这类似于上面讨论的情况<code class="fe mm mn mo mp b">1</code>。<code class="fe mm mn mo mp b">DispatchQueue</code>范围是本地的，按职业没有据点<code class="fe mm mn mo mp b">ViewAnimation</code>。因此，在闭包之后，执行引用被释放——在本例中，是在<code class="fe mm mn mo mp b">20</code>秒之后。</p><p id="0297" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated"><strong class="lr ir"> <em class="ml">注:</em> </strong> <em class="ml">并非所有病例的局部范围都与病例</em><code class="fe mm mn mo mp b"><em class="ml">1</em></code><em class="ml"/><code class="fe mm mn mo mp b"><em class="ml">2</em></code><em class="ml">相同。</em> <code class="fe mm mn mo mp b"><em class="ml">NotificationCenter</em></code> <em class="ml">则相反，一旦执行就不会释放</em> <code class="fe mm mn mo mp b"><em class="ml">self</em></code> <em class="ml">。KVO类型的实现是不同的，不应该与这些例子混淆。</em></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h2 id="471f" class="nm ky iq bd kz ns nt dn ld nu nv dp lh ly nw nx lj mc ny nz ll mg oa ob ln oc bi translated">3.在处理授权时</h2><p id="c0e3" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">是的——不是所有的授权场景，但这里有一个我们安全行事的案例。</p><p id="c254" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">考虑一个常见的模型展示场景，其中点击一个按钮，<code class="fe mm mn mo mp b">PresentingViewController</code>试图展示一个<code class="fe mm mn mo mp b">NewViewController</code>。回到<code class="fe mm mn mo mp b">PresentingViewController</code>我们通常实现一个委托模式。让我们检查下面的示例代码:</p><pre class="kh ki kj kk gt ni mp nj nk aw nl bi"><span id="1d2b" class="nm ky iq mp b gy nn no l np nq">@IBAction func onTapOfShowCities(_ sender: Any) {</span><span id="1872" class="nm ky iq mp b gy nr no l np nq">guard let vc = UIStoryboard(name: "Main", bundle: nil)<br/>.instantiateViewController(identifier: "NewViewController") as? NewViewController else { return }</span><span id="185f" class="nm ky iq mp b gy nr no l np nq">// The below delegate property can declared strong<br/>vc.delegate = self</span><span id="d695" class="nm ky iq mp b gy nr no l np nq">self.present(vc, animated: true, completion: nil)</span><span id="3e64" class="nm ky iq mp b gy nr no l np nq">}</span></pre><p id="a5a4" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">这里，<code class="fe mm mn mo mp b">NewViewController</code>的委托属性不必是<code class="fe mm mn mo mp b"><em class="ml">weak</em></code> <em class="ml">。</em>没有保持周期，因为<code class="fe mm mn mo mp b">PresentingViewController</code>没有强有力地保持住<code class="fe mm mn mo mp b">NewViewController</code>，它的作用域是局部的。</p><p id="8f9b" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">行<code class="fe mm mn mo mp b">self.present(vc, animated: true, completion: nil)</code> —该引用由苹果公司内部管理，并在解散<code class="fe mm mn mo mp b">ViewController</code>时被移除。</p><h2 id="7561" class="nm ky iq bd kz ns nt dn ld nu nv dp lh ly nw nx lj mc ny nz ll mg oa ob ln oc bi translated">4.与IBOutlets打交道时</h2><p id="98b9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><code class="fe mm mn mo mp b">@IBOutlet weak var showCities: UIButton!</code></p><p id="fd55" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">你可能想知道，苹果的默认，<code class="fe mm mn mo mp b">IBOutlets</code>，在拖动和连接的时候是不是很弱。</p><p id="1e20" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">嗯，就像<code class="fe mm mn mo mp b">Show Blame</code>怎么变成了<code class="fe mm mn mo mp b">Author</code>(物换星移，感情受伤)。这正在考虑中，但可能需要一些时间来反映。</p><p id="0374" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">但是，<em class="ml">没有</em>涉及到<code class="fe mm mn mo mp b">IBOutlets</code>声明为强的。</p><p id="4602" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">让我们来研究下图:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/8afbb47747e906b725e45bb714fe4a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k3XBsCBVbOtuwVTAQaZCg.png"/></div></div></figure><p id="3bd4" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">Tt清楚地暗示了<code class="fe mm mn mo mp b">IBOutlet</code>在两个地方被提及，<code class="fe mm mn mo mp b">view</code>和<code class="fe mm mn mo mp b">ViewController</code>。但是他们没有形成一个依赖循环(又名保留循环)。</p><p id="085b" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">让我们来看看视图控制器的释放过程:</p><ul class=""><li id="cbcf" class="oe of iq lr b ls mq lv mr ly og mc oh mg oi mk oj ok ol om bi translated">首先<code class="fe mm mn mo mp b">View controller</code>将尝试解除分配它所有的<code class="fe mm mn mo mp b">subviews</code>和<code class="fe mm mn mo mp b">properties</code>。</li><li id="91be" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated"><code class="fe mm mn mo mp b">view</code>是要释放的——所以<code class="fe mm mn mo mp b">view</code>先释放<code class="fe mm mn mo mp b">IBOutlet</code>的一个引用。</li><li id="a0e0" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">现在，按照<code class="fe mm mn mo mp b">ViewControllers</code>解除分配过程，剩余的属性也被释放，从而释放<code class="fe mm mn mo mp b">IBOutlet.</code>的第二个引用</li></ul><p id="00f1" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">由于<code class="fe mm mn mo mp b">IBOutlet</code>没有保持住<code class="fe mm mn mo mp b">view</code>或<code class="fe mm mn mo mp b">ViewController</code>，保持循环将不会发生。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="e6bb" class="pw-post-body-paragraph lp lq iq lr b ls mq jr lu lv mr ju lx ly ms ma mb mc mt me mf mg mu mi mj mk ij bi translated">太好了——我希望我们消除了误会。虽然<code class="fe mm mn mo mp b">weak self</code>是一种安全措施，但我们应该清楚使用案例。</p><h1 id="c949" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">关于这一主题的进一步讨论</h1><ul class=""><li id="9777" class="oe of iq lr b ls lt lv lw ly os mc ot mg ou mk oj ok ol om bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc" rel="noopener ugc nofollow" target="_blank"> IBOutlets一样强</a></li><li id="67c0" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/41991467/where-does-the-weak-self-go" rel="noopener ugc nofollow" target="_blank">强自封闭调度队列</a></li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="40a2" class="kx ky iq bd kz la nc lc ld le nd lg lh jw ne jx lj jz nf ka ll kc ng kd ln lo bi translated">一些疯狂的实现</h1><div class="ov ow gp gr ox oy"><a href="https://medium.com/better-programming/building-a-custom-transitioning-for-viewcontroller-in-ios-13-cbf9b4de3d9b" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">在iOS 13+中为ViewController构建自定义过渡</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">让我们在应用程序中构建自定义过渡</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kq oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://medium.com/better-programming/building-an-animating-navigation-bar-in-ios-13-96355c6822ce" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">在Swift中构建一个动画UINavigationBar</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">超越默认的导航栏功能</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm kq oy"/></div></div></a></div></div></div>    
</body>
</html>