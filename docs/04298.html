<html>
<head>
<title>Flutter Apps, Hide Your Passwords</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扑应用，隐藏你的密码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hide-your-passwords-e9154bbb8db4?source=collection_archive---------9-----------------------#2020-04-03">https://betterprogramming.pub/hide-your-passwords-e9154bbb8db4?source=collection_archive---------9-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="214b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">不要在你的Flutter应用中存储密码——远程存储密码</em></h2></div><p id="553b" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在本文中，我将回顾我编写的实用程序类<code class="fe lf lg lh li b">RemoteConfig</code>，用于访问提供给所有Firebase项目的远程配置云服务。<code class="fe lf lg lh li b">RemoteConfig</code> <em class="lj"> i </em>是一个与插件<code class="fe lf lg lh li b"><a class="ae lk" href="https://pub.dev/packages/firebase_remote_config" rel="noopener ugc nofollow" target="_blank">firebase_remote_config</a></code>协同工作的包装类，该插件反过来使用<a class="ae lk" href="https://firebase.google.com/products/remote-config/" rel="noopener ugc nofollow" target="_blank"> Firebase远程配置API </a>与远程配置云服务进行通信。当然，您可以保留这个实用程序类的副本，因为它被存储为一个要点:<code class="fe lf lg lh li b"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart" rel="noopener ugc nofollow" target="_blank">remote_config.dart</a></code>。正如您从我过去的文章中所知道的，我通常用一个实际的或众所周知的例子来演示如何使用这样一个类。在本文中，我将用一个有点争议的例子来尝试这样的演示Flutter应用程序密码的远程存储。</p><p id="4037" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">众所周知，现在手机应用程序的一个常见功能是在用户登录时使用脸书、谷歌或Twitter来验证用户身份。碰巧的是，用于使用twitter登录的流行插件<a class="ae lk" href="https://pub.dev/packages/flutter_twitter" rel="noopener ugc nofollow" target="_blank"> flutter_twitter </a>要求您提供一个公钥和一个字符串形式的秘密令牌。然而，这一事实带来了潜在的危险。下面是这个插件的截图，突出显示了两个必需的字符串。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://github.com/roughike/flutter_twitter_login/blob/c7ee95184dc1e8fbcdd1c19fef9b695a3afd84b4/lib/flutter_twitter_login.dart#L6"><div class="gh gi ll"><img src="../Images/f2fadebceb5899543a1dbddbe6778178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lW6kYmYXBm9pBp1UVs8iZw.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://github.com/roughike/flutter_twitter_login/blob/c7ee95184dc1e8fbcdd1c19fef9b695a3afd84b4/lib/flutter_twitter_login.dart#L6" rel="noopener ugc nofollow" target="_blank">flutter _ Twitter _ log in . dart</a></p></figure><p id="68f9" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当你把你的应用程序发布到产品中时，毫无疑问它会被下载，并且它的代码会被搜索到每一个<code class="fe lf lg lh li b">String</code>出现的地方。坏人会寻找密码，这是不可避免的。当你发布你的应用程序时，关键是你要使用<a class="ae lk" href="https://flutter.dev/docs/deployment/obfuscate" rel="noopener ugc nofollow" target="_blank">混淆</a>，这样许多函数名和变量名就变成了不可读的术语——所有这些都是为了让你的代码很难破译。混淆工具也会执行一些<code class="fe lf lg lh li b">String</code>文字的转换，但是最好不要在你的Flutter应用中存储敏感的字符串。换句话说，当你的Flutter应用程序启动时，最好远程获取你的秘密令牌甚至你的公钥。一种方法是使用Firebase的远程配置服务。</p><h1 id="87e1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">仅限截图。点击查看要点。</h1><p id="c672" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">和往常一样，我更喜欢用截图而不是gists来展示我的文章中的代码。我发现它们更容易使用，也更容易阅读。然而，你可以点击它们来查看gist或Github中的代码。讽刺的是，这篇关于移动开发的文章，在电脑上看比在手机上看更好。此外，我们大多在电脑上编程；我们的手机上没有。暂时如此。</p><p id="f274" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们开始吧。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/8571bbebc81a11df7a3bb569d28934f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4Y1130dIMGnVQO-Xo-wYA.png"/></div></div></figure><h1 id="c744" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">远程登录</h1><p id="962d" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">下面是一个特定Firebase项目的远程配置屏幕截图。传统上，远程配置用于存储服务器端默认值，以控制应用程序的行为和外观，尽管谷歌不建议这样做，但另一个选择是在那里存储更敏感的信息。两个这样的值在下面的截图中间用红色箭头突出显示。在这个例子中，Twitter登录的公钥和秘密令牌存储在远程配置云服务中，并使用字段值<code class="fe lf lg lh li b">com</code>和<code class="fe lf lg lh li b">andrioussolutions</code>进行检索，而不是存储在Flutter应用程序中。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/96b7cbe8bf34a65e9e72ecacdb7c9a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xhjm-Wq2ibkMx21qow9YA.png"/></div></div></figure><p id="6649" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下面的例程是我正在进行的项目之一的截图。它调用插件<code class="fe lf lg lh li b"><a class="ae lk" href="https://pub.dev/packages/flutter_twitter" rel="noopener ugc nofollow" target="_blank">flutter_twitter</a></code>，但不是在访问项目的远程配置并提供两个必需的字符串值之前。你可以看到我没有在代码中以字符串的形式提供太多的信息。相反，这个例程提取应用程序的包名，并使用前两部分<code class="fe lf lg lh li b">com</code>和<code class="fe lf lg lh li b">andrioussolutions</code>来检索这些特定的远程配置值。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi na"><img src="../Images/d737b0838351dd8e9caaf5e62573eebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pKaf03pu1kw1w2cMSCMHog.png"/></div></div></figure><p id="70c1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">注意，上面第一个红色箭头突出显示的是带有句点的单独字符串。不可否认，将该字符串赋给全局变量或类属性会更好。你看，坏人总是在你的代码中寻找单引号和双引号(或者他们混淆的等价物)。目前，它在被使用的同一个例程中被发现，我不应该把它放在那里。我是说，为什么要让他们更容易？</p><p id="584a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我在这个实用程序类中做的另一件事是在这个过程中引入加密。函数<code class="fe lf lg lh li b">getStringed()</code>将会引起特别的兴趣。它从远程配置返回字符串值，但不是在解密检索到的值之前。正如您可以在下面的屏幕截图中看到的那样，这个函数是为公钥和秘密令牌而调用的。因此，回到上面那个特定Firebase项目的远程配置屏幕截图，那里存储的值实际上是公钥和秘密令牌的加密版本。再说一次，为什么要让他们更容易呢？</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nb"><img src="../Images/af3b18161b0969d5906fd7daa6c71e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlndJA85qhbFo-9VKEx-pA.png"/></div></div></figure><p id="ddee" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">瞥一眼类库<code class="fe lf lg lh li b">RemoteConfig</code>，我们可以看到该函数调用其常规的<code class="fe lf lg lh li b">getString()</code>函数，用于从Firebase的远程配置中检索字符串值，但随后它将该值传递给一个名为<code class="fe lf lg lh li b">de()</code>的异步函数。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L117"><div class="gh gi nc"><img src="../Images/f9e10afc7675637034d7a828507a2fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYtV6zwGkxsWfsoL8HZOSw.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L117" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure><p id="09a9" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这是函数<code class="fe lf lg lh li b"><strong class="kl iu">decrypt()</strong></code>的缩写形式，该函数调用另一个函数来执行实际的解密。这些功能的屏幕截图如下所示。再次强调，不建议你将如此敏感的信息存储在谷歌的云服务中，但是如果你必须这样做，加密将会降低风险——哪怕只是一点点。将这些值存储在您自己的远程平台中是一个更好的选择，但这是另一个故事了。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L39"><div class="gh gi nd"><img src="../Images/8f088d3e0049ef9552fc1525cb098098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lxLAfg9jav6M8c0ylp1bg.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L39" rel="noopener ugc nofollow" target="_blank"> string_encryption.dart </a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="4b1e" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">远程配置程序</h1><p id="ec18" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">让我们浏览一下在库文件<code class="fe lf lg lh li b"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart" rel="noopener ugc nofollow" target="_blank">remote_config.dart</a></code>中找到的<code class="fe lf lg lh li b">RemoteConfig</code>类，并解释它的作用。下面有一个截图显示了这门课的开始。同样，它与知道如何与Firebase的远程配置对话的插件一起工作，在下面的截图中，你可以看到它是以前缀<code class="fe lf lg lh li b">r</code>导入的。但是，请注意，它也从插件文件中导出特定的类。这就是为什么当使用库例程时，你不需要导入插件文件，你只需要导入这个文件:</p><p id="a619" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lf lg lh li b">import remote_config.dart</code></p><p id="e03f" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">而不是:</p><p id="3c4d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lf lg lh li b">import package:firebase_remote_config/firebase_remote_config.dart</code></p><p id="169f" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lf lg lh li b">import remote_config.dart</code></p><p id="e8b9" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在构造函数中还要注意的是，如果参数被赋值为null，我会显式地测试这些参数。对于普通大众使用的这样一个实用程序类，空值可能会被意外或以其他方式传入。此外，被包含的插件使用的命名参数<code class="fe lf lg lh li b">defaults</code>和<code class="fe lf lg lh li b">expiration</code> <em class="lj"> </em>确保被赋予有效值。最后，该类不将参数值存储在实例变量中。这些值被传递给私有变量。它们不需要作为公共类属性再次被访问。这是一种安全预防措施——这种实用程序类的另一个特征。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L1"><div class="gh gi nc"><img src="../Images/c850b1ae7c5aa043cc26d0bbc94f0269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-A4jDBFvKSpYKI0N-5iJ_A.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L1" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure><p id="cb81" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下一段代码列出了这个例程中使用的私有变量和getters。值得注意的是，getter、<code class="fe lf lg lh li b">instance</code>、<em class="lj">、</em>是对<code class="fe lf lg lh li b">RemoteConfig</code>插件本身的引用。你可能不需要它，但它是一种选择。如果你看过我过去的文章，你就知道我喜欢期权！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="http://remote_config.dart"><div class="gh gi nq"><img src="../Images/dc11dbb0cca26137de4a643870e5e268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMhEbbU-zh_gWN2QZ1ow5A.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L26" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="02ca" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">初始化你的遥控器</h1><p id="2d49" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">下一段代码是<code class="fe lf lg lh li b">init()</code>函数。我决定在这个例程中有一个单独的<code class="fe lf lg lh li b">init()</code>函数，以提醒任何使用这个类的开发人员，不仅要调用<code class="fe lf lg lh li b">init()</code>函数来初始化，还要调用相应的<code class="fe lf lg lh li b">dispose()</code>函数来“清理”在下面的<code class="fe lf lg lh li b">init()</code>函数的截图中，你可以看到远程配置插件实际上是在这里初始化的。此外，传递给例程的任何默认值都会被分配给插件。最后，在那里调用插件的<code class="fe lf lg lh li b">fetch()</code>函数来‘获取’存储在<code class="fe lf lg lh li b">RemoteConfig</code>中的参数值。</p><p id="c0e8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您会注意到在<code class="fe lf lg lh li b">init()</code>函数中也设计了一个加密密钥。如果这个键没有被显式地传递给这个函数，那么你的应用程序的包名将被用来在<code class="fe lf lg lh li b">RemoteConfig</code>中查找一个可能的键——sneaky！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L44"><div class="gh gi nd"><img src="../Images/3f74e5dd5d33e1c2c2ed64921be7d4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlvzeiHGflYRoG90Py9Qjw.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L44" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure><p id="2cfa" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">进一步注意:<code class="fe lf lg lh li b">init()</code>函数中的整个操作都包含在一个try-catch语句中，任何异常都会被记录下来。任何这样的实用程序类都应该记录所有的异常。最后，如果一切顺利，将返回布尔值true。</p><p id="d44f" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下一段代码将反映插件本身的属性和功能。同样，作为一个公共使用的实用程序类，您必须确保该例程被正确使用。在这种情况下，<code class="fe lf lg lh li b">init()</code>函数必须在您可以做任何其他事情之前被调用，这就是您在下面看到的一系列<code class="fe lf lg lh li b">assert()</code>函数的用途。如果开发人员忘记调用<code class="fe lf lg lh li b">init()</code>函数，如果他们试图进一步处理这个例程，他们就会知道。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="http://remote_config.dart"><div class="gh gi nb"><img src="../Images/618012211a81d2999d5aac47e4628857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FY68wJFkvmfNiAeGuXpA0Q.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L83" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure><p id="1c2d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">接下来的代码是你最常使用的。您将提供适当的键值，并使用以下函数从Firebase的远程配置中检索参数值。这里有<code class="fe lf lg lh li b">getStringed()</code>功能。和往常一样，如果解密出现异常，它会被记录在这个实用程序类中。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L106"><div class="gh gi nq"><img src="../Images/4d23af12abfc6e28bc9271aeb233c740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjOZHxwKhcjJk2wkhd_OAw.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L106" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure><p id="3b9b" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下面剩余的代码继续反映插件本身可用的功能。你甚至可以添加监听器来引入函数，每当一个<code class="fe lf lg lh li b">RemoteConfig</code>值在应用程序执行过程中可能改变时，这些函数就会触发。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L137"><div class="gh gi nr"><img src="../Images/c60119ef8ff0627a7e391e25a0e5e2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOVcXYnnzlPcPeE6S0l43w.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L137" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="e66e" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">远程错误</h1><p id="332e" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">最后，在这个<code class="fe lf lg lh li b">RemoteConfig</code>包装器类中，有记录任何异常的代码。如果出现问题，有两个getters，您可以在应用程序中使用它们来测试包装类是否以任何方式失败。例如，如果<code class="fe lf lg lh li b">_remoteConfig.hasError</code>或<code class="fe lf lg lh li b">_remoteConfig.inError</code>被设置为真，则存在异常。</p><p id="010b" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">正如你现在所知道的，在整个类中，伴随着每个try-catch语句，函数<code class="fe lf lg lh li b">getError()</code>被调用来记录任何异常。那么，您的应用程序也可以不带参数地调用<code class="fe lf lg lh li b">getError()</code>来检索已经发生的实际异常并相应地采取行动。不错！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L162"><div class="gh gi ns"><img src="../Images/62068f89f32992a09efc43d0db207155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Bkt-k2yDbQuvMq05mckgQ.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart-L162" rel="noopener ugc nofollow" target="_blank"> remote_config.dart </a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="4481" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">解密加密的</h1><p id="a758" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">像远程配置程序一样，我需要一个加密程序。碰巧的是，<code class="fe lf lg lh li b">getStringed()</code>函数需要解密<code class="fe lf lg lh li b">RemoteConfig</code>值的方法。当然，使用您最喜欢的IDE和断点，您必须首先加密这些值，并首先将它们存储在那里。<code class="fe lf lg lh li b">StringCrypt</code>类为您完成所有这些工作，如下所示。它使用类<code class="fe lf lg lh li b"><a class="ae lk" href="https://github.com/sroddy/flutter_string_encryption/blob/1fa478d59842931f5959e288880c384077d52bb7/lib/flutter_string_encryption.dart#L31" rel="noopener ugc nofollow" target="_blank">PlatformStringCryptor</a>()</code>与另一个流行的插件<code class="fe lf lg lh li b"><a class="ae lk" href="https://pub.dev/packages/flutter_string_encryption" rel="noopener ugc nofollow" target="_blank">flutter_string_encryption.dart</a></code>一起工作。</p><p id="0044" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">同样，像<code class="fe lf lg lh li b">RemoteConfig</code>例程一样，这个类不将它的三个参数存储在类属性中，而是将它们放入私有变量中。你也可以看到它的插件是在构造函数中初始化的。最后，您可以提供一个密码和<code class="fe lf lg lh li b">salt</code>来生成密钥，而不是显式地为插件提供一个密钥参数。生成加密需要这样的密钥。</p><p id="0fd1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lf lg lh li b">salt</code>参数是一个附加字符串，在生成加密和解密的密钥时伴随着密码。这是一个额外的安全措施，以防密码被泄露——如果坏人想要访问它，还需要一个组件。这意味着它必须存放在远离密码的地方。事实上，这个想法是密码不存储在任何地方——它由用户记忆，并在你的Flutter应用程序启动时输入。反正那是后话了。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L1"><div class="gh gi nd"><img src="../Images/d0694e827c0d5351d164d43ff2d13be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PsI4ShvqOpxSlHeXnZFxA.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L1" rel="noopener ugc nofollow" target="_blank"> string_encryption.dart </a></p></figure><p id="f937" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下面，你现在看到了由<code class="fe lf lg lh li b">RemoteConfig</code>类使用的<code class="fe lf lg lh li b">decrypt</code>例程。此外，您可以看到一些函数，例如，您可以使用这些函数首先生成一个密钥，然后存储在<code class="fe lf lg lh li b">RemoteConfig</code>上。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L39"><div class="gh gi nt"><img src="../Images/1bfd0d333d9c099d275c6ce42e6c4aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cETD0Dd-eyNjcXz4O9WoDQ.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L39" rel="noopener ugc nofollow" target="_blank"> string_encryption.dart </a></p></figure><p id="42ef" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">私有函数<code class="fe lf lg lh li b">_keyFromPassword()</code>非常简单明了。如果提供了密码和salt，它会在构造函数中调用back up，并为私有变量<code class="fe lf lg lh li b">_key</code>分配一个密钥。</p><p id="fc83" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后，你会发现在这个类的最后一段代码。同样，这样一个实用程序类应该捕获所有异常，并保存它，以便开发人员可以选择检索并相应地采取行动。下面列出了该代码。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L66"><div class="gh gi nd"><img src="../Images/d28da1bf6c68405c208313978c2351a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hC9x2TBWitqZzOEy541QEQ.png"/></div></a><p class="lt lu gj gh gi lv lw bd b be z dk translated"><a class="ae lk" href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart-L66" rel="noopener ugc nofollow" target="_blank"> string_encryption.dart </a></p></figure><p id="d905" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个实用程序类<code class="fe lf lg lh li b"><a class="ae lk" href="https://gist.github.com/Andrious/51ab198ad6128b55a70d6b1bc32f8136#file-remote_config-dart" rel="noopener ugc nofollow" target="_blank">RemoteConfig</a></code>是出于需要而编写的——我需要使用Firebase的远程配置服务。我已经将这个类和<code class="fe lf lg lh li b"><a class="ae lk" href="https://gist.github.com/Andrious/428ebe7374c1f617d631c5802c87751a#file-string_encryption-dart" rel="noopener ugc nofollow" target="_blank">StringCrypt</a></code>类提供给我们羽翼未丰的Flutter社区使用、更改和增强。希望你能分享任何改变。当然，我用来存储密码的例子可能不会阻止最坚定的攻击者，但这比在你的Flutter应用程序中存储这样的密码要好。没有吗？</p><p id="f1d8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">干杯！</p></div></div>    
</body>
</html>