<html>
<head>
<title>What’s New in TypeScript 4.3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.3有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-3-72f74289e765?source=collection_archive---------4-----------------------#2021-05-26">https://betterprogramming.pub/whats-new-in-typescript-4-3-72f74289e765?source=collection_archive---------4-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypeScript的惊人增量升级</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa079f3cc87ef974fa7ac54de952690d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6WnoJqejwdYyu_6S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript 4.3于5月26日发布🎉。发布的顶级功能有哪些？它们会提高我们的生产率吗？是否应该立即更新？</p><p id="bf2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将经历所有最令人兴奋的。以下是总结:</p><ul class=""><li id="1d78" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">import</code>报表助手</li><li id="5e4b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">属性上的独立写入类型</li><li id="8982" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">重写方法</li><li id="792c" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">模板字符串类型改进</li><li id="9c3d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">ECMAScript <code class="fe me mf mg mh b">#private</code>类元素</li><li id="fb6b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">条件句中缺少<code class="fe me mf mg mh b">await</code>的错误</li><li id="6464" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">静态索引签名</li><li id="da17" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">改进了对知名符号的支持</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6329" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">导入报表助手</h1><p id="6e22" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这个版本中最酷的特性之一实际上将会内置到您的编辑器中:支持<code class="fe me mf mg mh b">import</code>语句。</p><p id="c74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当使用<code class="fe me mf mg mh b">import</code>语法时，TypeScript将为您提供一个导入候选项的列表。当您选择一个时，<code class="fe me mf mg mh b">import</code>语句将自动为您生成。</p><p id="2131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/70310a38670546ca201d3444f302d2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2NRy4uwVEKHoYDMUQ5oFDg.gif"/></div></div></figure><p id="9de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入自动完成一直是个难题。问题是在ES导入中，导入的实体在导入位置之前。如果导入语法颠倒过来，对开发人员来说会更容易:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="d9ff" class="nw mv it mh b gy nx ny l nz oa">// an example of a more intuitive import statement</span><span id="0b43" class="nw mv it mh b gy ob ny l nz oa">from 'react' import { useState }</span></pre><p id="ac54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些<code class="fe me mf mg mh b">VS Code</code>插件对此有所帮助，但没有什么像内置功能一样。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a59f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">属性上的独立写入类型</h1><p id="1edf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您经常使用TypeScript的公共访问器，您很可能会看到这个错误:<code class="fe me mf mg mh b">'get' and 'set' accessors must have the same type</code>。当<code class="fe me mf mg mh b">get</code>和<code class="fe me mf mg mh b">set</code>公共访问器没有完全相同的类型时，就会发生这种情况。</p><p id="d942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用以前的版本来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">升级到TypeScript 4.3后，此代码无需任何更改即可运行。</p><p id="7e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更好地控制如何定义我们的getters和setters以及它们的签名方法，这总是很棒的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="66dc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">重写方法</h1><p id="7029" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在这个版本中，增加了一个众所周知的关于OOP的关键字:<code class="fe me mf mg mh b">override</code>。以前，显式重写父方法是不可能的。它必须以一种含蓄的方式完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="71a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面的例子，不清楚这是开发人员有意为之的行为还是一个错误。例如，如果我们从我们的<code class="fe me mf mg mh b">Foo</code>对象中移除<code class="fe me mf mg mh b">bar</code>方法会发生什么？没什么。代码仍然有效。这是开发商的意图吗？看编译器很难知道。</p><p id="b343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在4.3中，增加了一个新的旗帜:<code class="fe me mf mg mh b">--noImplicitOverride</code>。这将使上面的代码失败，并出现以下错误:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="e39f" class="nw mv it mh b gy nx ny l nz oa">This member must have an 'override' modifier because it overrides a member in the base class 'Foo'</span></pre><p id="d367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将防止任何隐式覆盖。你可以向编译器暗示你的编码意图。</p><p id="699b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用标志<code class="fe me mf mg mh b">--noImplicitOverride</code>意味着创建覆盖方法的唯一方式是使用新添加的<code class="fe me mf mg mh b">override</code>关键字。</p><p id="fed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们从<code class="fe me mf mg mh b">Foo</code>类中移除<code class="fe me mf mg mh b">bar</code>方法，我们将面临以下错误:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="4bfb" class="nw mv it mh b gy nx ny l nz oa">This member cannot have an 'override' modifier because it is not declared in the base class 'Foo'</span></pre><p id="08d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为感觉上我们更能控制方向盘。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6be1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">模板字符串类型改进</h1><p id="cb77" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">模板文字类型是在4.1中引入的。从那以后，每个TypeScript版本都包含了一些改进。</p><p id="f84e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用与string组合的模板类型时，TypeScript现在将尝试将这些类型推断为模板类型。</p><p id="39f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这同样适用于类型推断。让我们比较一下以前版本和新版本的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于TypeScript试图将这些字符串推断为模板类型，所以一切正常。TypeScript现在可以更好地理解模板类型，所以我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f60f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">改进的#private类访问器</h1><p id="c6fb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">从3.8版本开始，<code class="fe me mf mg mh b">private</code>访问器就是TypeScript中的一个特性。</p><p id="7979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括一下:</p><blockquote class="oe of og"><p id="0988" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">"默认情况下，类属性是公共的，可以在类外检查或修改。然而<a class="ae ky" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank">有一个阶段3提议</a>允许使用散列前缀<code class="fe me mf mg mh b">#</code>定义私有类字段。</p><p id="84d7" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi">…</p><p id="8f4f" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">私有字段可以在类构造函数上从类声明本身内部访问。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="2265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，直到现在，有些事情你还不能做:</p><ul class=""><li id="3afc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用<code class="fe me mf mg mh b">private</code>修饰符声明一个方法。</li><li id="4986" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">用<code class="fe me mf mg mh b">private</code>修饰符声明一个getter。</li><li id="09f7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">用<code class="fe me mf mg mh b">private</code>修饰符声明一个静态属性。</li></ul><p id="98ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个新版本，以上所有都成为可能。这个特性现在几乎完全符合ECMAScript <code class="fe me mf mg mh b">private</code>修饰符的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c827" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">条件中缺少await的错误</h1><p id="353d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">从现在开始，当启用<code class="fe me mf mg mh b">strictNullChecks</code>配置时，TypeScript在断言一个承诺时会给出一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那个条件总是<code class="fe me mf mg mh b">true</code>，所以编译器要求你改变<code class="fe me mf mg mh b">if</code>语句。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="62a4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">静态索引签名</h1><p id="b3e9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">索引签名是我们习惯直观使用的东西。它以隐式而不是显式的方式声明属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="388d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要符合索引签名，就可以声明显式变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经了解了什么是索引签名，那么在这个新版本中有什么变化呢？变化其实很简单:<code class="fe me mf mg mh b">static</code>值现在支持索引签名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在4.3之前，将显示消息<code class="fe me mf mg mh b">'static' modifier cannot appear on an index signature.</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3fed" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">改进了对知名符号的支持</h1><p id="a07e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">添加了对众所周知的TypeScript符号的支持。那些是什么？内置在TypeScript中的<code class="fe me mf mg mh b">Symbol.*</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b18b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">最后的想法</h1><p id="5d51" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是另一个很好的版本，包含了许多小的、有用的东西。很高兴看到模板文字功能越来越成熟。</p><p id="5eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展望未来，我很期待看到<code class="fe me mf mg mh b">Generalized index signatures</code>是否能进入下一个版本。他们已经计划了几个版本，但从未实现。这是什么特点？简而言之，它是在一个类型上定义多个类型键的能力:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="1329" class="nw mv it mh b gy nx ny l nz oa">interface PropertyMap {<br/>  [x: string | number | symbol]: string;<br/>}</span></pre><p id="d50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们得到以下错误消息:</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="2a51" class="nw mv it mh b gy nx ny l nz oa">An index signature parameter type must be either 'string' or 'number'</span></pre><p id="358e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以在GitHub 上跟进PR <a class="ae ky" href="https://github.com/microsoft/TypeScript/pull/26797" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="bd84" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">相关文章</strong></h1><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/top-5-typescript-features-you-should-master-2358db9ab3d5"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">您应该掌握的五大打字稿功能</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用这些必须知道的特性来提高您的打字稿知识</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">better编程. pub</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">TypeScript:映射类型的简明介绍</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">学习构建自己的一套TypeScript工具</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">better编程. pub</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>