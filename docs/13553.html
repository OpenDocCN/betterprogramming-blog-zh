<html>
<head>
<title>Build a Simple URL Shortener API Using Nestjs, MongoDB, and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nestjs、MongoDB和Docker构建一个简单的URL Shortener API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-nestjs-mongodb-and-docker-to-create-an-url-shortener-a826e461145f?source=collection_archive---------16-----------------------#2022-09-06">https://betterprogramming.pub/use-nestjs-mongodb-and-docker-to-create-an-url-shortener-a826e461145f?source=collection_archive---------16-----------------------#2022-09-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f72c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用NestJS、Docker、MongoDB实现一个简单的URL shortener，并使用Traefik将其部署到启用SSL的生产环境中。还包括Docker Swarm设置。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/edba01af5a638a1e2f545cab24dc6ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AniTD2jj4Tk-5z2ZlUxp7g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.freepik.com/free-vector/man-woman-with-chains-background_1086772.htm#query=chain&amp;from_query=small%20chain&amp;position=30&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">free pik上的Vectorarte </a>图像</p></figure><p id="3b40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本教程将涵盖用NestJs和MongoDB构建一个简单的URL shortener API的所有工作。此外，我将展示如何使用Docker将其部署到(Docker和Docker Swarm)生产环境中。</p><p id="af8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">源代码发布在GitHub上，可以免费使用:</p><div class="lw lx gq gs ly lz"><a href="https://github.com/paulknulst/paulsshortener" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">GitHub-paulknulst/paulsshortener</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">一个渐进式Node.js框架，用于构建高效且可伸缩的服务器端应用程序。嵌套框架类型脚本…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><h1 id="0202" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">创建NestJS项目</h1><p id="cd91" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">首先，创建一个NestJS项目，作为URL缩短器的基线。为此，您需要在您的系统上安装<a class="ae kz" href="https://github.com/nestjs/nest-cli" rel="noopener ugc nofollow" target="_blank"> Nest-CLI </a>，这可以通过以下方式完成:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="e4de" class="nq mp iu nm b gz nr ns l nt nu">$ npm install -g <a class="ae kz" href="http://twitter.com/nestjs/cli" rel="noopener ugc nofollow" target="_blank">@nestjs/cli</a></span></pre><p id="cd05" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后切换到项目文件夹，使用Nest-CLI通过执行以下命令创建一个新的NestJS项目:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="cdc7" class="nq mp iu nm b gz nr ns l nt nu">$ nest new paulsshortener</span></pre><p id="11f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个过程中，您将被询问您想要使用哪个包管理器。将使用本教程<code class="fe nv nw nx nm b">npm</code>。</p></div><div class="ab cl ny nz hy oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="in io ip iq ir"><p id="a21d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您可以在"<em class="of">观察模式</em>"中启动NestJS项目，通过执行以下命令，立即看到您将在本教程中做出的所有更改:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="ddc2" class="nq mp iu nm b gz nr ns l nt nu">$ npm run start:dev</span></pre><p id="0073" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了测试一切是否正确启动，点击<a class="ae kz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，这将在浏览器中显示“Hello World”。</p><p id="4a1d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在项目中打开AppService ( <code class="fe nv nw nx nm b">/src/app.service.ts</code>)并将<code class="fe nv nw nx nm b">return 'Hello World!';</code>更改为<code class="fe nv nw nx nm b">return 'This will be your URL shortener';</code>。重新加载http://localhost:3000后，将会看到更新后的响应。</p><h1 id="5702" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">设置MongoDB数据库</h1><p id="c512" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">为了简单起见，本教程将使用MongoDB。为了避免设置正确版本、替换旧安装等麻烦，您应该使用Docker来部署它。将这个最小合成文件保存到您的项目根目录中，并将其命名为<code class="fe nv nw nx nm b">docker-compose.local.yml</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="d0d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你不熟悉Docker Compose并且不想用它来建立一个MongoDB，你可以看看官方的MongoDB文档<a class="ae kz" href="https://www.mongodb.com/docs/manual/installation/" rel="noopener ugc nofollow" target="_blank">来学习如何在你的机器上安装它。请记住，在本教程的后面部分，Docker还用于部署这个URL shortener！</a></p><p id="91df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，要部署MongoDB，在终端中切换到您的项目根目录并执行:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="525b" class="nq mp iu nm b gz nr ns l nt nu">$ docker-compose -f docker-compose.local.yml up -d</span></pre><p id="c7b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">之后，您已经成功地设置了MongoDB和您的机器，并可以开始使用它了。</p><h1 id="c48c" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">将您的NestJS项目连接到MongoDB</h1><p id="30eb" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">要将项目连接到MongoDB，您应该使用Mongoose，它是最流行的MongoDB对象建模工具。首先将所需的依赖项安装到项目中:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="2ad2" class="nq mp iu nm b gz nr ns l nt nu">$ npm i @nestjs/mongoose mongoose</span></pre><p id="b1e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦安装了依赖项，就可以通过编辑如下所示的<code class="fe nv nw nx nm b">AppModule</code> ( <code class="fe nv nw nx nm b">/src/app.module.ts</code>)将Mongoose模块导入到项目中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="00b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在将自动建立连接，您可以创建将用于处理数据库的模式。</p><p id="2285" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在使用Nest-CLI在您的NestJS项目中创建一个新模块，它将处理与URL相关的所有事情:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="a958" class="nq mp iu nm b gz nr ns l nt nu">$ nest g res url</span></pre><p id="7c3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个例程会问两个你应该回答的问题。</p><ul class=""><li id="1abb" class="oi oj iu lc b ld le lg lh lj ok ln ol lr om lv on oo op oq bi translated">你使用什么传输层？<strong class="lc iv"> - &gt; REST API </strong></li><li id="3fcf" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated">您想生成CRUD入口点吗？<strong class="lc iv"> - &gt;否</strong></li></ul><p id="bef9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">切换到新生成的<code class="fe nv nw nx nm b">url</code>文件夹，创建新的文件夹模式，并添加文件<code class="fe nv nw nx nm b">url.schema.ts</code>。然后创建一个类(<code class="fe nv nw nx nm b">Url</code>)向文件中添加两个属性(<code class="fe nv nw nx nm b">url</code>，<code class="fe nv nw nx nm b">shortenedUrl</code>)。另外，添加文档和模式的导出。您的文件应该如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="5cbe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">打开<code class="fe nv nw nx nm b">url.module.ts</code>，添加两个新的导入，并修改<code class="fe nv nw nx nm b">@Module</code>注释:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><h1 id="57e5" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">实现URL链接缩短功能</h1><p id="ef91" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">要缩小URL，您将使用CRC32哈希算法，该算法必须添加到项目中才能使用:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="ab50" class="nq mp iu nm b gz nr ns l nt nu">$ npm install crc-32 --save</span></pre><p id="1320" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">打开<code class="fe nv nw nx nm b">UrlService</code> ( <code class="fe nv nw nx nm b">/src/url/url.service.ts</code>)，用以下代码片段替换文件内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="8ba4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个代码片段包含三个重要的函数:</p><ul class=""><li id="c19a" class="oi oj iu lc b ld le lg lh lj ok ln ol lr om lv on oo op oq bi translated"><code class="fe nv nw nx nm b">shrink</code>:使用CRC32算法将给定的URL转换成8个字符的字符串。然后只返回8个字符的字符串。</li><li id="f1da" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><code class="fe nv nw nx nm b">create</code>:使用shrink函数创建一个8字符的字符串，并将一个新的<code class="fe nv nw nx nm b">UrlSchema</code>文档保存到MongoDB中</li><li id="31f3" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><code class="fe nv nw nx nm b">find</code>:从MongoDB中检索保存的URL。</li></ul><h1 id="e232" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">向NestJS API添加路线</h1><p id="3933" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">要在客户机中使用URL shortener，我们需要创建三个REST端点/函数。</p><ul class=""><li id="f4e1" class="oi oj iu lc b ld le lg lh lj ok ln ol lr om lv on oo op oq bi translated"><code class="fe nv nw nx nm b">GET /shrink</code>:使用Http Get方法创建一个新的简短URL。path参数包含未缩写的URL。这可以在任何浏览器中完成。</li><li id="9cc8" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><code class="fe nv nw nx nm b">POST /shrink</code> <strong class="lc iv"> : </strong>使用Http Post方法创建一个新的简短URL。正文包含未缩写的URL。你需要一个API或者邮差来使用这个。</li><li id="0a61" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><code class="fe nv nw nx nm b">GET /s</code> <strong class="lc iv"> : </strong>以8个字符的字符串作为路径参数，返回不缩写的URL。最后会自动转发到不短的网址。</li></ul><p id="a20a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您使用NestJS时，您可以通过向URL模块中的<code class="fe nv nw nx nm b">UrlController</code> ( <code class="fe nv nw nx nm b">url.controller.ts</code>)添加三个新函数并使用<code class="fe nv nw nx nm b">@Get</code>和<code class="fe nv nw nx nm b">@Post</code>对其进行注释来轻松实现这些端点。打开<code class="fe nv nw nx nm b">UrlController</code>，将内容替换为:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="877a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个代码片段中，创建了两个新的GET资源(<code class="fe nv nw nx nm b">/shrink/</code>和<code class="fe nv nw nx nm b">/s/</code>)和一个从<code class="fe nv nw nx nm b">UrlService</code>调用先前创建的函数的POST资源。此外，类上方的注释从<code class="fe nv nw nx nm b">@Controller('url')</code>更改为<code class="fe nv nw nx nm b">@Controller('')</code>，以进一步缩小结果URL。</p><h1 id="092c" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">测试URL缩写程序</h1><p id="de16" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">要测试功能，您可以简单地使用您的浏览器，因为我们已经将这两个资源实现为GET调用。</p><p id="15f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请记住，当您使用GET提供URL作为路径参数时，您必须对URL进行编码！这意味着像这样的URL:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="9638" class="nq mp iu nm b gz nr ns l nt nu">https://www.paulsblog.dev/manage-time-more-efficiently-with-the-pomodoro-technique/</span></pre><p id="dfa4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">会变成这样:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="e47e" class="nq mp iu nm b gz nr ns l nt nu">https%3A%2F%2Fwww.paulsblog.dev%2Fmanage-time-more-efficiently-with-the-pomodoro-technique%2F</span></pre><p id="182f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了这些信息，您可以通过在我们的浏览器中打开以下URL来创建一个缩短的URL:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="b251" class="nq mp iu nm b gz nr ns l nt nu"><a class="ae kz" href="http://localhost:3000/shrink/https%3A%2F%2Fwww.knulst.de%2Fmanage-time-more-efficiently-with-the-pomodoro-technique%2F" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/shrink/https%3A%2F%2Fwww.paulsblog.dev%2Fmanage-time-more-efficiently-with-the-pomodoro-technique%2F</a></span></pre><p id="efa3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过这个GET调用，您的API将返回8个字符的字符串:<strong class="lc iv"> -5f1a8349 </strong>(在您的项目中应该是相同的)</p><p id="b97f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将这个字符串附加到GET /s/ call中，通过打开:<a class="ae kz" href="http://localhost:3000/s/-5f1a8349" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/s/-5f1a 8349</a>来接收URL的非缩写版本</p><p id="cfea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">浏览器中的结果将是之前提供的URL的简化版本。</strong></p><h1 id="dfb5" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">实现转发到未缩短的URL</h1><p id="63a4" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">现在，您已经开发了一个可以在CRC-32算法的帮助下缩短URL的API，您应该启用该功能来转发请求并自动打开它在数据库中找到的URL。</p><p id="bad5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用NestJS，这真的很容易，因为您只需要在UrlController ( <code class="fe nv nw nx nm b">src/url/url.controller.ts</code>)中调整unshrink函数。将先前创建的函数更改为以下实现:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><h1 id="4288" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">用Docker部署URL Shortener</h1><p id="1be6" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">让我们假设您想要在Docker环境中部署URL shortener，并且必须开发一个可以用来完成这项工作的合成文件。</p><p id="9f32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一步是创建一个新的Compose文件(<code class="fe nv nw nx nm b">docker-compose.prod.yml</code>)，并将之前创建的MongoDB文件中的内容复制到其中。然后添加一个名为backend的新服务，它将用于在Docker环境中安装、编译和运行NestJS项目。</p><p id="2dec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于您开发了一个定制软件，DockerHub上不会有合适的映像，您必须从头创建一个。因为该项目基于在NodeJS环境中工作的NestJS，所以您可以创建一个新的Dockerfile并使用最新版本的node作为基本映像。然后简单地复制源代码，安装，构建和运行项目。以下Dockerfile文件就足够了，应该在项目根目录下创建:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="2fb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个docker文件现在可以用作合成文件中后端服务的映像。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="d4b9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不幸的是，运行这个合成文件将不起作用，因为我们项目中链接的URL是硬编码的，不会自动调整。此外，AppModule ( <code class="fe nv nw nx nm b">app.module.ts</code>)中的DB主机名和端口是静态的。</p><p id="3456" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要解决这些问题，您必须在AppModule ( <code class="fe nv nw nx nm b">app.module.ts</code>)和UrlService ( <code class="fe nv nw nx nm b">url.service.ts</code>)中添加和更改一些东西。具体来说，添加三个新变量来保存数据库端口、数据库URL和结果服务的基本URL。</p><p id="0bea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">切换到AppModule ( <code class="fe nv nw nx nm b">app.module.ts</code>)并将这两个变量添加到类定义之上:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="ae21" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，更改模块导入中的Mongoose部分，以正确使用这些变量:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="9c59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后打开UrlService ( <code class="fe nv nw nx nm b">url.service.ts</code>)并在类定义上方添加<code class="fe nv nw nx nm b">baseurl</code>变量:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="3f45" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，更改create函数，使用新引入的基本变量返回完整的缩短URL。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure></div><div class="ab cl ny nz hy oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="in io ip iq ir"><p id="a5de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您已经应用了这些更改，您应该通过添加可用的环境变量并根据您的需要调整它们来调整您的合成文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="cc29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，在您的本地主机上部署它:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="e3c9" class="nq mp iu nm b gz nr ns l nt nu">$ docker-compose up -d --build</span></pre><p id="0c5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的URL缩写程序现已正确安装，可以在您的本地环境中使用。</p><h1 id="a02e" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用Traefik部署到生产环境</h1><p id="38f9" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">现在您已经有了一个可以部署到任何地方的Docker服务，您可以使用它在使用Traefik的生产环境中部署它。为此，您将编辑合成文件，添加所有与Traefik相关的关键字(标签、网络)，并根据需要进行调整。</p><p id="aece" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您不熟悉使用Traefik部署Docker服务，我可以推荐以下教程，其中涵盖了在单台服务器上的基本安装和使用Docker Swarm的服务器集群安装:</p><ul class=""><li id="f5d8" class="oi oj iu lc b ld le lg lh lj ok ln ol lr om lv on oo op oq bi translated"><a class="ae kz" href="https://levelup.gitconnected.com/how-to-setup-traefik-v2-with-automatic-lets-encrypt-certificate-resolver-83de0ed0f542" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">如何用自动加密证书解析器设置Traefik v2</strong></a></li><li id="0f49" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/deploy-any-ssl-secured-website-with-docker-and-traefik-27fbeb1343d3"> <strong class="lc iv">使用Docker和Traefik </strong> </a>部署任何SSL安全网站</li><li id="405f" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><a class="ae kz" href="https://levelup.gitconnected.com/docker-swarm-in-a-nutshell-ed2a9c42cd7c" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">设置Docker Swarm(用于Traefik) </strong> </a></li><li id="04dd" class="oi oj iu lc b ld or lg os lj ot ln ou lr ov lv on oo op oq bi translated"><a class="ae kz" href="https://levelup.gitconnected.com/the-most-important-services-everyone-should-deploy-in-a-docker-swarm-8e120b5a66#529f" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">在Docker群上安装Traefik</strong></a></li></ul><p id="cd9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要使用Traefik部署您的URL shortener，请调整标签部分。以下部分将展示并解释如何在单个服务器设置中实现这一点，此外还将提供Docker Swarm配置供下载:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="fcda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在使用Compose成功部署这个服务之前，您必须调整主机:使用您自己的<code class="fe nv nw nx nm b">BASE_URL</code>并更新<code class="fe nv nw nx nm b">traefik</code>配置(对我来说，它是<a class="ae kz" href="https://at0m.de" rel="noopener ugc nofollow" target="_blank"> at0m.de </a>)。更改这两个值后，使用以下命令部署它:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="61d4" class="nq mp iu nm b gz nr ns l nt nu">$ docker-compose -f docker-compose.prod.yml up -d</span></pre></div><div class="ab cl ny nz hy oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="in io ip iq ir"><p id="4466" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Docker Swarm你可以使用<a class="ae kz" href="https://raw.githubusercontent.com/paulknulst/paulsshortener/master/docker-compose.prod-swarm.yml" rel="noopener ugc nofollow" target="_blank">这个组合文件</a>。但是，您必须为MongoDB服务调整<code class="fe nv nw nx nm b">BASE_URL</code>和放置约束。然后构建，将映像推送到我们的注册表，并将其部署到您的Docker Swarm上:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="202c" class="nq mp iu nm b gz nr ns l nt nu">$ docker-compose -f docker-compose.prod-swarm.yml build<br/>$ docker-compose -f docker-compose.prod-swarm.yml push<br/>$ docker stack deploy -c docker-compose.prod-swarm.yml paulsshortener</span></pre><h1 id="6551" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">实时版本的附加调整</h1><p id="0a6b" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">因为你在你的服务器上公开部署了它，你应该按照下面的方法添加速率限制:<a class="ae kz" href="https://docs.nestjs.com/security/rate-limiting" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/security/rate-limiting</a>。</p><h1 id="5b55" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">TL；博士:</h1><p id="3608" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">在项目中安装所需的包:</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="67a4" class="nq mp iu nm b gz nr ns l nt nu">$ npm i --save @nestjs/throttler</span></pre><p id="8961" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在AppModule ( <code class="fe nv nw nx nm b">app.module.ts</code>)中扩展imports-array:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="1a64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，将<code class="fe nv nw nx nm b">ThrottlerGuard</code>添加到providers数组中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="b9b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe nv nw nx nm b">SkipThrottle</code>注释添加到<code class="fe nv nw nx nm b">UrlController</code> ( <code class="fe nv nw nx nm b">url.controller.ts</code>)内的Get /s/ endpoint，以忽略对该特定调用的速率限制:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="og oh l"/></div></figure><h1 id="1fcf" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">结束语</h1><p id="b6fd" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">我希望你喜欢阅读我的教程，并且现在能够在Docker容器中创建、构建和部署你的URL shortener网站。</p><p id="5c47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请记住，这是一个非常基本的例子，没有任何错误处理，也没有URL检查。但是，本教程应该是开发您的版本的起点。</p><p id="bbcb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你喜欢读这篇文章，考虑在评论区发表你的宝贵意见。我很想听到你对这个网址缩写的反馈。此外，如果您对实现自己的版本有任何疑问，请在下面记下。如果可能的话，我试着回答他们。此外，与您的朋友和同事分享这篇文章，向他们展示如何使用NestJs、MongoDB和Docker来创建自己的URL缩短器。</p><pre class="kk kl km kn gu nl nm nn no aw np bi"><span id="73d8" class="nq mp iu nm b gz nr ns l nt nu">Feel free to connect with me on <a class="ae kz" href="https://www.knulst.de" rel="noopener ugc nofollow" target="_blank">my personal Blog</a>, <a class="ae kz" href="https://www.linkedin.com/in/paulknulst/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, and <a class="ae kz" href="https://twitter.com/paulknulst" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div><div class="ab cl ny nz hy oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="in io ip iq ir"><p id="0954" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="of">本文最初发表于我的博客</em><a class="ae kz" href="https://www.paulsblog.dev/use-nestjs-mongodb-and-docker-to-create-an-url-shortener/" rel="noopener ugc nofollow" target="_blank"><em class="of">https://www . paulsblog . dev/use-nestjs-MongoDB-and-docker-to-create-an-URL-short ener/</em></a></p></div></div>    
</body>
</html>