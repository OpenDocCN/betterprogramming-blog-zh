<html>
<head>
<title>How to Convert JavaScript Classes to React’s useReducer Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将JavaScript类转换成React的useReducer钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-convert-javascript-classes-to-reacts-usereducer-hook-575769b0c7e9?source=collection_archive---------8-----------------------#2020-06-22">https://betterprogramming.pub/how-to-convert-javascript-classes-to-reacts-usereducer-hook-575769b0c7e9?source=collection_archive---------8-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d65c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在React应用程序中应用函数式编程的案例研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f933424309c21235950da48ee99e0efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N0UlIk8WwOslr5Fb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯科特·沃尔什在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="6ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程是一种基于“对象”概念的编程范式，对象被定义为类。命令式编程使用语句来改变程序的状态。</p><p id="1ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程是另一种编程范例，通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数被视为一等公民(即，它们可以被赋给变量，作为参数传递，并从其他函数返回)。强烈建议编写纯函数，避免共享状态、可变数据和副作用。</p><p id="6c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着React、Angular和Vue等大型库和框架的出现，函数式编程对前端web开发社区变得越来越有吸引力。React是函数式编程的大力提倡者。在2018年5月推出hooks之后，仅仅用React组件的功能来编写整个应用程序已经成为可能。</p><p id="79b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经有面向对象的编程代码，或者您可能熟悉面向对象的编程。你现在如何用一种功能性的方式来构造东西？</p><p id="9c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将提供一个例子来展示如何将类转换成React的<code class="fe lv lw lx ly b">useReducer</code>钩子。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a53f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">面向对象的方法</strong></h1><p id="8b0f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们使用<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a> ( <code class="fe lv lw lx ly b">npx create-react-app my-app</code>)设置了一个工作环境，并将<code class="fe lv lw lx ly b">src/App.css</code>更改为以下内容以获得最小样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d83b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript 2015 (ES 6)引入了<code class="fe lv lw lx ly b">class</code>，这是JavaScript现有的基于原型的继承之上的语法糖。类可以定义为类表达式或类声明，类似于函数。</p><p id="d6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/Cat.js</code>中声明了一个类<code class="fe lv lw lx ly b">Cat</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类有状态(即成员变量)的初始值，它们是<code class="fe lv lw lx ly b">name</code>(第7行)、<code class="fe lv lw lx ly b">isHappy</code>(第2行)、<code class="fe lv lw lx ly b">isHungry</code>(第3行)和<code class="fe lv lw lx ly b">isTired</code>(第4行)。它使用一个<code class="fe lv lw lx ly b">constructor</code>实例化<code class="fe lv lw lx ly b">name</code>(第6-8行)。</p><p id="0f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子说明了初始化类状态的两个地方:类体和构造函数。</p><p id="fae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Cat</code>类还实现了行为(即成员函数，也称为方法)，它们是<code class="fe lv lw lx ly b">play</code>(第10-14行)、<code class="fe lv lw lx ly b">sleep</code>(第16-18行)、<code class="fe lv lw lx ly b">bathe</code>(第20-22行)和<code class="fe lv lw lx ly b">eat</code>(第24-27行)。<code class="fe lv lw lx ly b">getStatus</code>(第29-36行)是另一种描述状态的方法。</p><p id="2001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第39行，用<code class="fe lv lw lx ly b">new</code>操作符实例化了一个<code class="fe lv lw lx ly b">cat</code>实例。此实例已导出供使用。</p><p id="f0a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义一个接口来表达这个类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/89b6ba3bf5b879a60bbebe470511288b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9c39X8dfzK9NUEfClmVoSw.png"/></div></div></figure><p id="f179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四个按钮调用四个成员函数，显示<code class="fe lv lw lx ly b">getStatus</code>值来展示类状态。</p><p id="bd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修订后的<code class="fe lv lw lx ly b">src/App.js</code>中使用了<code class="fe lv lw lx ly b">cat</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="e3c5" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">在第2行，导入了<code class="fe lv lw lx ly b">cat</code>实例。</li><li id="1af4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第9-16行定义了<code class="fe lv lw lx ly b">Play</code>按钮。点击该按钮时，调用<code class="fe lv lw lx ly b">cat.play</code>并更新显示字符串。</li><li id="5f79" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第17-24行定义了<code class="fe lv lw lx ly b">Sleep</code>按钮。点击该按钮时，调用<code class="fe lv lw lx ly b">cat.sleep</code>并更新显示字符串。</li><li id="7723" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第25-32行定义了<code class="fe lv lw lx ly b">Bathe</code>按钮。点击该按钮时，调用<code class="fe lv lw lx ly b">cat.bathe</code>并更新显示字符串。</li><li id="3aa6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第33-40行定义了<code class="fe lv lw lx ly b">Eat</code>按钮。点击该按钮时，调用<code class="fe lv lw lx ly b">cat.eat</code>并更新显示字符串。</li><li id="e6cb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第41行显示了<code class="fe lv lw lx ly b">cat.getStatus()</code>的值。</li></ul><p id="6c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序是可行的，只是它没有采用函数式方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0e92" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">功能方法</h1><p id="e016" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">useReducer</code>是一个内置的钩子，更适合管理包含多个子值的状态对象。它非常适合定义一个类。</p><p id="120e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useReducer</code>的使用方法如下:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="99c0" class="ny mh it ly b gy nz oa l ob oc">const [state, dispatch] = useReducer(reducer, initialArg, init?);</span></pre><p id="3ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左侧，它被分解为两个项目:</p><ul class=""><li id="7133" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">state</code>:可以装东西的对象，相当于一个类的成员变量。</li><li id="a7c6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">dispatch</code>:可以处理状态变化的方法，相当于一个类的成员函数。<code class="fe lv lw lx ly b">dispatch</code>函数的引用是稳定的，不会在重新渲染时改变。因此，从<code class="fe lv lw lx ly b">useEffect</code>或<code class="fe lv lw lx ly b">useCallback</code>依赖列表中省略是安全的。</li></ul><p id="08ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在右边，它有三个属性:</p><ul class=""><li id="41bc" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">reducer</code>:具有<code class="fe lv lw lx ly b">(state, action) =&gt; newState</code>类型的函数。它有两个参数——当前状态和用户执行的操作。然后，它根据所调度的动作有条件地返回一个新状态。</li><li id="0803" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">initialArg</code>:减速器的初始状态。</li><li id="58c3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">init?</code>:初始化可选功能。如果提供，初始状态将被设置为<code class="fe lv lw lx ly b">init(initialArg)</code>。否则，直接应用<code class="fe lv lw lx ly b">initialArg</code>。</li></ul><p id="ece6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义一个缩减器之前，我们声明了与<code class="fe lv lw lx ly b">src/catActions.js</code>中<code class="fe lv lw lx ly b">Cat</code>的成员函数相似的<code class="fe lv lw lx ly b">actions</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="64ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后这些动作被<code class="fe lv lw lx ly b">src/catReducer.js</code>中的减速器使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fa02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将成员变量声明转换为默认状态(第3-7行)。有一个状态初始化器，<code class="fe lv lw lx ly b">initConfig</code>(第9-12行)，它将<code class="fe lv lw lx ly b">defaultState</code>与<code class="fe lv lw lx ly b">useReducer</code>的初始状态(<code class="fe lv lw lx ly b">name: “Tom”</code>)结合起来。</p><p id="810f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变状态的成员函数被转换成reducer函数中的动作处理(第14-47行)。重要的是状态是不可变的。ECMAScript 2015的<code class="fe lv lw lx ly b">spread</code>操作符提供了一种简单的方法。如果返回具有相同引用的状态，React将退出，而不渲染子级或点火效果。</p><p id="87c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用<code class="fe lv lw lx ly b">catReducer</code>的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useReducer</code>用于第7行。<code class="fe lv lw lx ly b">constructor</code>参数<code class="fe lv lw lx ly b">name</code>在此初始化。</p><p id="e095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第9-17行的<code class="fe lv lw lx ly b">getStatus</code>成员函数被转换为<code class="fe lv lw lx ly b">status</code>。<code class="fe lv lw lx ly b">useMemo</code>记忆数值，直到<code class="fe lv lw lx ly b">state</code>改变。这是一种优化，以避免每次渲染时重新计算。</p><p id="49af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当每个按钮被点击时，它调用<code class="fe lv lw lx ly b">dispatch</code>函数，而不是调用成员函数。</p><p id="23f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。现在我们的<code class="fe lv lw lx ly b">Cat</code>例子以函数的方式工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e986" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于派遣的更多信息</h1><p id="6b28" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可能对<code class="fe lv lw lx ly b">dispatch</code>功能有疑问。类成员函数可以接受参数。如何在<code class="fe lv lw lx ly b">dispatch</code>函数中完成同样的事情？</p><p id="dd8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的简单示例中，<code class="fe lv lw lx ly b">type</code>用于缩减器有条件地转换状态:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="5459" class="ny mh it ly b gy nz oa l ob oc">dispatch({ type: actions.play });</span></pre><p id="84a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选地，我们可以传入一个有效负载作为动作的参数。有效载荷可以被称为<code class="fe lv lw lx ly b">payload</code>或任何其他名称。需要多少有效载荷就有多少。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="27c6" class="ny mh it ly b gy nz oa l ob oc">dispatch({ type: actions.play, payload: { color: 'black' }, id: 5, isSunday: true, random: 'Today is a beautiful day' });</span></pre><p id="8963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe lv lw lx ly b">dispatch</code>除了<code class="fe lv lw lx ly b">type</code>之外，还有<code class="fe lv lw lx ly b">payload</code>、<code class="fe lv lw lx ly b">id</code>、<code class="fe lv lw lx ly b">isSunday</code>、<code class="fe lv lw lx ly b">random</code>等称呼。</p><p id="45e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的断点处，我们可以看到<code class="fe lv lw lx ly b">catReducer</code>接收所有的参数来构建它的逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a14dbbba5dcbb5bef3b2fceb3ef43d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zfJxJwloDcUk9p4lp26mA.png"/></div></div></figure><p id="7c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">payload</code>是异步操作的结果呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么应该调用<code class="fe lv lw lx ly b">dispatch</code>作为异步操作的结果。这样，我们将副作用保留在reducer之外，以确保它是一个纯函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="321f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子显示异步操作最初将<code class="fe lv lw lx ly b">isLoading</code>设置为<code class="fe lv lw lx ly b">true</code>(第2行)。当调用成功时，调度<code class="fe lv lw lx ly b">result</code>进行处理(第4行)。当调用失败时，调度<code class="fe lv lw lx ly b">error</code>进行错误处理(第5行)。最后<code class="fe lv lw lx ly b">isLoading</code>设置为<code class="fe lv lw lx ly b">false</code>(第6行)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f1d1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于州的更多信息</h1><p id="7b83" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们希望创建一个新的界面，能够更改猫的名字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/411bbcb500a7257ff575fa9804add81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1QdlyV2QHz2xnCgOrk-qA.png"/></div></div></figure><p id="6321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">src/catActions.js</code>中需要一个新的名称更改动作(第6行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新动作在<code class="fe lv lw lx ly b">src/catReducer.js</code>中处理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第46-51行添加了<code class="fe lv lw lx ly b">actions.changeName</code>的案例，以处理名称更改。</p><p id="cc10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是修改后的<code class="fe lv lw lx ly b">src/App.js</code>使用<code class="fe lv lw lx ly b">catReducer</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="35a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第20-28行定义了输入元素。当值发生变化时，它会将动作<code class="fe lv lw lx ly b">changeName</code>与<code class="fe lv lw lx ly b">name</code>的负载一起发送出去。</p><p id="aea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这和预期的一样有效。</p><p id="0029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以把猫的属性分解成两种状态。<code class="fe lv lw lx ly b">catReducer</code>、<code class="fe lv lw lx ly b">isHappy</code>、<code class="fe lv lw lx ly b">isHungry</code>、<code class="fe lv lw lx ly b">isTired</code>处于一种状态。<code class="fe lv lw lx ly b">name</code>处于自己的状态。这样，我们就不需要有新的动作了(<code class="fe lv lw lx ly b">changeName</code>)。</p><p id="9d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化仅出现在<code class="fe lv lw lx ly b">src/App.js</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="373e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7行，<code class="fe lv lw lx ly b">name</code>由<code class="fe lv lw lx ly b">useState</code>管理。第21行定义了管理猫的名字的输入元素。第17行的<code class="fe lv lw lx ly b">useMemo</code>依赖列表需要有<code class="fe lv lw lx ly b">name</code>。</p><p id="d7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，猫的其他财产仍然由<code class="fe lv lw lx ly b">useReducer</code>管理。</p><p id="9ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法似乎更简单。状态可以根据用例进行不同的设计。<code class="fe lv lw lx ly b">useState</code>适用于简单状态，<code class="fe lv lw lx ly b">useReducer</code>适用于多值状态。</p><p id="f9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个状态被管理时，避免共享状态是很重要的，共享状态是在多个函数或多个数据结构之间共享的状态。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b0c8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="8aa8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经展示了一个如何使用<code class="fe lv lw lx ly b">useReducer</code>的例子。重要的是reducer函数是一个纯函数，并且reducer函数生成的状态是不可变的。</p><p id="5df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useReducer</code>等同于<code class="fe lv lw lx ly b">useState</code>，因为它作用于特定组件及其所有后代。</p><p id="d8cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过上下文传递<code class="fe lv lw lx ly b">dispatch</code>函数:<code class="fe lv lw lx ly b">const ParentDispatch = React.createContext(null)</code>。</p><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将孩子包裹在上下文中:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="34ec" class="ny mh it ly b gy nz oa l ob oc">&lt;ParentDispatch.Provider value={dispatch}&gt;<br/>  &lt;Child someProps={someProps} /&gt;<br/>&lt;/ParentDispatch.Provider&gt;</span></pre><p id="6ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么任何子组件都可以通过调用<code class="fe lv lw lx ly b">useContext</code> : <code class="fe lv lw lx ly b">const dispatch = useContext(ParentDispatch)</code>来访问<code class="fe lv lw lx ly b">dispatch</code>函数。</p><p id="a1ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的React项目中，<code class="fe lv lw lx ly b">useReducer</code>运行良好。我们对100%的函数式编程很满意。</p><p id="1d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>