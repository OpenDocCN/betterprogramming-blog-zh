<html>
<head>
<title>Easy Reproducible Development Environments with Nix and direnv</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nix和direnv的简单可重复开发环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/easily-reproducible-development-environments-with-nix-and-direnv-e8753f456110?source=collection_archive---------5-----------------------#2020-01-22">https://betterprogramming.pub/easily-reproducible-development-environments-with-nix-and-direnv-e8753f456110?source=collection_archive---------5-----------------------#2020-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自动(重新)加载开发环境，不会污染操作系统，也不需要虚拟机或容器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec18ae6a682f32872049feab906ece0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FHeJVvLAM31Xmcn_bjXqQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@vantorin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼基塔·万托林</a>在<a class="ae kv" href="https://unsplash.com/s/photos/development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b9d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获得一个有效的开发环境通常不是一件容易的事情。我记得在一些项目中，新开发人员(包括我)要花两三天时间才能在他们的开发计算机上把所有东西都处理好。</p><p id="5e2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>在那个领域非常有用，但是它们只能帮你到这里。它们适用于运行依赖项，而不必担心构建依赖项。</p><p id="59c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以在一个容器中运行您的应用程序运行的数据库，然后使用它。有些人通过将代码源作为一个卷安装在容器中来运行应用程序本身。</p><p id="a178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它解决了必须安装库和工具的问题，但这并不像听起来那么简单。比如你的文本编辑器呢？你能让林挺在里面无痛工作吗？</p><p id="54e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了手动和容易出错之外，在本地安装所有东西的问题是，你最终会在你的计算机上有一大堆程序和库。</p><p id="ce2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在几个项目上工作，当其中一些项目使用同一事物的不同版本或者冲突的系统时，情况会变得更糟。</p><p id="2e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果能够在本地安装一个开发环境(没有容器或虚拟机)而不影响操作系统，那不是很好吗？</p><p id="535c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://nixos.org/nix/about.html" rel="noopener ugc nofollow" target="_blank"> Nix </a>解决了这个问题。所有派生都安装在Nix store中，这个目录包含构建派生的结果。你可以把一个派生看作是如何构建一个程序或者一个库的方法。也就是说，没有什么会污染你的<code class="fe ls lt lu lv b">/usr/local/bin</code>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="803f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Nix的(非常)快速概述</h1><p id="ed22" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">很难对尼克斯进行分类。在网站上，它被描述为“纯功能的包管理器”。然而，它也可以被认为是一种编程语言、一种配置工具和一种构建工具。</p><p id="c7a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，Nix表达式是用纯函数式编程语言编写的程序，可以返回一个或一组导数。</p><p id="ec2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">派生是描述如何获得所有依赖关系和构建工件(如可执行文件或库)的数据结构。Nix然后可以构建这些派生并将结果存储在Nix存储中，实际上是在<code class="fe ls lt lu lv b">/nix/store</code>中。</p><p id="be47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nix的一个关键方面是构建是<em class="na">可复制的</em>。这意味着，给定一些推导，不管你在什么计算机上或者什么时候尝试构建它，它都会产生相同的结果(除了一些出于实际原因的例外)。</p><p id="2c64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免构建已经构建好的东西，Nix存储中的路径以结构<code class="fe ls lt lu lv b">hash-name-version</code>命名，其中<code class="fe ls lt lu lv b">hash</code>是派生的散列。这样，如果再次需要一个派生，Nix将会看到它已经在Nix存储中，而不会重新构建它。</p><p id="30ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，Nix缓存也有助于防止重复工作。如果已经在一台远程机器上构建了一个派生，该机器与您的计算机共享它的Nix存储作为缓存，Nix将简单地下载它，而不是在本地构建派生。</p><p id="088e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nix可以用来构建任何东西:你的项目的依赖项，你的项目本身，还有Docker容器和带有NixOS的整个Linux系统。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ac4d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Nixpkgs</h1><p id="5558" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">Nixpkgs 是一个巨大的Nix表达式资源，有很多很多通用程序和库的派生。根据它的自述文件，在撰写本文时，它已经有超过40，000个包。</p><p id="084b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还有一堆帮助函数和方法来为不同的编程语言和框架建立依赖关系。值得一提的有<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>，Node，Java，Python，<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>，以及<a class="ae kv" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="548a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">nix-shell</h1><p id="d708" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">nix-shell</code>是一个命令行工具，用于在基于某些派生的环境中启动交互式shell。</p><p id="2805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，它会在当前目录中寻找一个应该返回一个派生的<code class="fe ls lt lu lv b">shell.nix</code>或<code class="fe ls lt lu lv b">default.nix</code>。然后，它将再现派生的构建将在其中运行的环境，即所有依赖项都可用的环境。</p><p id="c92e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时使用<code class="fe ls lt lu lv b">nix-shell</code>快速进入一些程序的外壳也很方便。这可以通过<code class="fe ls lt lu lv b">-p</code>选项实现。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="76ed" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">没有direnv的开发环境</h1><p id="fe35" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们需要一个名为<code class="fe ls lt lu lv b">shell.nix</code>的文件放在项目的根目录下，这样我们就可以调用<code class="fe ls lt lu lv b">nix-shell</code>并拥有所有可用的依赖项和开发工具。然而，为了保持有序，所有的Nix代码都将放在一个目录<code class="fe ls lt lu lv b">nix/</code>中。</p><p id="9e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用太担心没有完全理解Nix代码。这里的目标是演示如何使用Nix创建一个开发环境，而不是教您Nix本身。</p><p id="2c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习更多关于语言本身的知识，这本手册的<a class="ae kv" href="https://nixos.org/nix/manual/#chap-writing-nix-expressions" rel="noopener ugc nofollow" target="_blank">部分</a>就是你开始学习的全部。</p><p id="a056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还想修复Nixpkgs的版本，以便开发环境完全可再现。<code class="fe ls lt lu lv b">nix/sources.nix</code>将包含这样的外部引用。</p><p id="d5ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe ls lt lu lv b">e4d0e33f36491a0e08a3b1a15db13366d7d0785f</code>是我们想要从中获取派生的提交的散列。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="28fd" class="nh me iq lv b gy ni nj l nk nl">{<br/>  nixpkgs = builtins.fetchGit {<br/>    url = "https://github.com/NixOS/nixpkgs.git";<br/>    rev = "e4d0e33f36491a0e08a3b1a15db13366d7d0785f";<br/>  };<br/>}</span></pre><p id="6ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们的项目是一个用Haskell编写的小可执行文件，通过调用<code class="fe ls lt lu lv b">cowsay</code>打印环境变量<code class="fe ls lt lu lv b">PORT</code>的值和一个随机数。</p><p id="a0fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不太花哨，但它仍然需要一个开发环境，在那里我们可以编译Haskell程序，所以我们需要一个编译器，库<code class="fe ls lt lu lv b">random</code>和<code class="fe ls lt lu lv b">process</code>，以及程序<code class="fe ls lt lu lv b">cowsay</code>。</p><p id="90af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">nix/shell.nix</code>中，我们现在可以在函数<code class="fe ls lt lu lv b">pkgs.mkShell</code>的帮助下为环境创建派生。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="715b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，<code class="fe ls lt lu lv b">mkShell</code>采用了一个属性集(相当于JavaScript中的一个对象或者Python中的一个字典)。<code class="fe ls lt lu lv b">buildInputs</code>是依赖关系列表。例如，你可以在那里添加<code class="fe ls lt lu lv b">pkgs.docker-compose</code>或<code class="fe ls lt lu lv b">pkgs.nodejs-12_x</code>。</p><p id="35ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">未使用的键如<code class="fe ls lt lu lv b">PORT</code>按原样添加到环境变量中。不要太担心<code class="fe ls lt lu lv b">ghcWithPackages</code>,因为这是Haskell特有的将库和编译器结合在一起的方式。</p><p id="940d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从根目录调用没有任何参数的命令<code class="fe ls lt lu lv b">nix-shell</code>很方便，所以我们需要一个文件<code class="fe ls lt lu lv b">shell.nix</code>放在根目录下。简直就是进口<code class="fe ls lt lu lv b">nix/shell.nix</code>。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="58cd" class="nh me iq lv b gy ni nj l nk nl">import nix/shell.nix</span></pre><p id="2fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，这里是我们的小程序的代码，用于演示目的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="787a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe ls lt lu lv b">nix-shell</code>后，我们可以编译并运行如下程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0846" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用direnv自动(重新)加载</h1><p id="e862" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">直接使用<code class="fe ls lt lu lv b">nix-shell</code>的问题在于，每次您更改环境的规范时，您都需要退出并重新加载shell。此外，它会覆盖提示。</p><p id="bba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许更重要的是，如果shell当前不是活动的，那么就没有垃圾收集根，即<code class="fe ls lt lu lv b">/nix/var/nix/gcroots</code>中的一个符号链接。这就是Nix如何跟踪Nix存储中哪些路径被使用，哪些路径可以被删除。</p><p id="38b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着运行<code class="fe ls lt lu lv b">nix-collect-garbage</code>会删除开发环境所需的所有路径，因此需要您在下次运行<code class="fe ls lt lu lv b">nix-shell</code>时重新构建或重新下载依赖项，因为Nix不知道您还需要它。</p><p id="c385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://direnv.net/" rel="noopener ugc nofollow" target="_blank"> Direnv </a>可以用来解决这些问题。它寻找一个文件<code class="fe ls lt lu lv b">.envrc</code>，并在进入目录时加载环境。退出目录会卸载环境。它不是一个Nix工具，但是它有一个名为<code class="fe ls lt lu lv b">use_nix</code>的函数，可以用<code class="fe ls lt lu lv b">nix-shell</code>加载/卸载Nix环境。</p><p id="cf26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们给我们的虚拟项目添加一个文件<code class="fe ls lt lu lv b">.envrc</code>。这里没有列出<code class="fe ls lt lu lv b">direnv/use_nix.sh</code>的内容，但是你可以在<a class="ae kv" href="https://github.com/thoferon/nix-direnv/blob/master/direnv/use_nix.sh" rel="noopener ugc nofollow" target="_blank">演示库</a>中查看。<code class="fe ls lt lu lv b">use_nix</code>的代码来自<a class="ae kv" href="https://github.com/direnv/direnv/wiki/Nix" rel="noopener ugc nofollow" target="_blank"> direnv关于Nix </a>的Wiki页面。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="0225" class="nh me iq lv b gy ni nj l nk nl">#!/usr/bin/env bash</span><span id="d08f" class="nh me iq lv b gy nm nj l nk nl">. direnv/use_nix.sh</span><span id="377e" class="nh me iq lv b gy nm nj l nk nl">use_nix -s shell.nix \<br/>  -w nix/sources.nix \<br/>  -w nix/shell.nix</span></pre><p id="a73a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选项<code class="fe ls lt lu lv b">-w </code>告诉direnv当其中一个文件改变时重新加载环境。第一次你必须调用<code class="fe ls lt lu lv b">direnv allow</code>来告诉direnv可以运行这个特定的<code class="fe ls lt lu lv b">.envrc</code>。</p><p id="216e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！这个项目现在唯一需要的先决条件是Nix和direnv，而direnv甚至不是绝对必要的。</p><p id="760c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会污染开发人员的计算机，因为Nix没有在通常的目录中安装任何东西，例如<code class="fe ls lt lu lv b">/usr/local/bin</code>，并且每个人都在运行完全相同的环境，因为Nixpkgs的版本是固定在<code class="fe ls lt lu lv b">nix/sources.nix</code>中的(不要忘记不时地更新它)。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="fa33" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">支持VS代码</h1><p id="dd2b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">VS代码对Nix和direnv都有扩展，尽管在这种情况下你只需要对direnv的扩展<a class="ae kv" href="https://github.com/rubymaniac/vscode-direnv" rel="noopener ugc nofollow" target="_blank">。在打开的对话框(<code class="fe ls lt lu lv b">ctrl+p</code>)中输入<code class="fe ls lt lu lv b">ext install direnv</code>即可快速安装。</a></p><p id="289b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一些扩展需要Nix环境中的一些工具，可能需要重新加载编辑器，但除此之外，我对它的体验相当顺利。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="cdba" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="8a9d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">同时使用这两个工具让我管理依赖关系变得简单多了。再也不需要花两天时间进行长时间的准备工作，甚至可以开始一个项目。</p><p id="93e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nix有一个陡峭的学习曲线，但是在不太了解语言和工具内部的情况下，用它可以完成很多事情。</p><p id="4efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它不需要很长时间就能工作，所以试试吧！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="4f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这样的故事，可以考虑成为<a class="ae kv" href="https://tomferon.medium.com/membership" rel="noopener">的会员，或者</a>或者<a class="ae kv" href="https://tomferon.medium.com/subscribe" rel="noopener">订阅</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="90f8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">进一步阅读</h1><ul class=""><li id="9f1c" class="nn no iq ky b kz mv lc mw lf np lj nq ln nr lr ns nt nu nv bi translated">包含本文代码的<a class="ae kv" href="https://github.com/thoferon/nix-direnv" rel="noopener ugc nofollow" target="_blank">库</a>。</li><li id="4d2d" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">对接器</a>和<a class="ae kv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">对接器组成</a>。</li><li id="69c8" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><a class="ae kv" href="https://nixos.org/nix/manual/" rel="noopener ugc nofollow" target="_blank"> Nix手册</a>及其关于<a class="ae kv" href="https://nixos.org/nix/manual/#chap-writing-nix-expressions" rel="noopener ugc nofollow" target="_blank">编写Nix表达式的章节</a>。</li><li id="57d4" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><a class="ae kv" href="https://nixos.org/nixos/manual/" rel="noopener ugc nofollow" target="_blank"> NixOS手册</a>。</li><li id="6226" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">Nixpkgs手册。</li><li id="9a6b" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><a class="ae kv" href="https://direnv.net/" rel="noopener ugc nofollow" target="_blank"> direnv </a></li><li id="690e" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">direnv关于Nix的Wiki页面。</li><li id="c898" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><a class="ae kv" href="https://github.com/rubymaniac/vscode-direnv" rel="noopener ugc nofollow" target="_blank"> vscode-direnv </a>，direnv的VS代码扩展。</li></ul></div></div>    
</body>
</html>