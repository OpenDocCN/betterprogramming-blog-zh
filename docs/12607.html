<html>
<head>
<title>15 Best Practices for SQL Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL优化的15个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/15-best-practices-for-sql-optimization-956759626321?source=collection_archive---------2-----------------------#2022-06-16">https://betterprogramming.pub/15-best-practices-for-sql-optimization-956759626321?source=collection_archive---------2-----------------------#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d4dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升SQL的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7849ebd7fc93a666e5a90411b98375a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vrUH-LYiJrEHv9Z4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ka_idris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kam Idris </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL优化是大家关心的热点话题。无论是面试还是工作，都有可能遇到。</p><p id="db14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一天你负责的一个在线接口出现了性能问题，你需要对它进行优化。那么你的第一个想法很可能是优化SQL语句，因为它的转换成本比代码小得多。</p><p id="d35e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何优化SQL语句呢？</p><p id="9472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我就来分享一些SQL优化的小技巧，希望对你有帮助。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a0d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 1。避免使用</strong> <code class="fe mu mv mw mx b"><strong class="ak">select *</strong></code> <strong class="ak">。</strong></h1><p id="4cdd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">很多时候，我们在写SQL语句的时候，为了方便，喜欢直接用<code class="fe mu mv mw mx b">select *</code>一次性找出表中所有列的数据。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="612e" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>select * from user where id = 1;</span></pre><p id="a9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际的业务场景中，也许我们真的只需要使用其中的一两列。我查了很多数据，没有，浪费数据库资源，比如内存或者CPU。</p><p id="8371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在通过网络IO传输数据的过程中，数据传输时间也会增加。</p><p id="ac58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个最重要的问题是:<code class="fe mu mv mw mx b">select *</code>不会使用覆盖索引，并且会有大量的返回表操作，导致查询SQL性能低下。</p><p id="a388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何优化呢？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="deb6" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>select name, age from user where id = 1;</span></pre><p id="f84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询SQL语句时，只检查需要使用的列，多余的列根本不需要签出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0338" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 2。将</strong> <code class="fe mu mv mw mx b"><strong class="ak">union" </strong></code> <strong class="ak">替换为</strong> <code class="fe mu mv mw mx b"><strong class="ak">union all"</strong></code> <strong class="ak">。</strong></h1><p id="35ca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们都知道在SQL语句中使用union关键字后，可以获得重新排序后的数据。</p><p id="b0bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用union all关键字，可以获得所有数据，包括重复数据。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="6b70" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>(select * from user where id=1) <br/>union <br/>(select * from user where id=2);</span></pre><p id="73d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新排序的过程需要遍历、排序和比较，比较耗时，消耗更多的CPU资源。</p><p id="a9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果可以用union all，尽量不要用union。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9b54" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>(select * from user where id=1) <br/>union all<br/>(select * from user where id=2);</span></pre><p id="d654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非有一些特殊的场景，比如<code class="fe mu mv mw mx b">union all</code>之后，结果集中出现重复数据，业务场景不允许出现重复数据，那么可以使用<code class="fe mu mv mw mx b">union</code>。</p><h1 id="2ff6" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 3。小桌子带动大桌子。</strong></h1><p id="4624" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">小表驱动大表，即小表的数据集驱动大表的数据集。</p><p id="d5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有两个表，order和user，<code class="fe mu mv mw mx b">order</code>表有10000条数据，<code class="fe mu mv mw mx b">user</code>表有100条数据。</p><p id="77f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，如果您想查看所有有效用户的订单列表。</p><p id="c634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过使用<code class="fe mu mv mw mx b">in</code>关键字来实现:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="6757" class="nh md it mx b gy ni nj l nk nl">select * from order<br/>where user_id in (select id from user where status=1)</span></pre><p id="1589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以通过使用<code class="fe mu mv mw mx b">exists</code>关键字来实现:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="26da" class="nh md it mx b gy ni nj l nk nl">select * from order<br/>where exists (select 1 from user where order.user_id = user.id and status=1)</span></pre><p id="efb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面提到的业务场景中，使用In关键字来实现业务需求更加合适。</p><p id="76bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？</p><p id="706c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe mu mv mw mx b">in</code>一个关键字包含在SQL语句中，它将首先执行子查询语句<code class="fe mu mv mw mx b">in</code>，然后执行outside in语句。如果数据量<code class="fe mu mv mw mx b">in</code>小，作为条件查询速度更快。</p><p id="edf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果SQL语句包含<code class="fe mu mv mw mx b">exists</code>关键字，它首先执行<code class="fe mu mv mw mx b">exists</code>左边的语句(主查询语句)。</p><p id="4d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后用它作为条件匹配右边的语句。如果匹配，就可以查询数据了。如果不匹配，则过滤掉数据。</p><p id="6f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个需求中，<code class="fe mu mv mw mx b">order</code>表有10000条数据，<code class="fe mu mv mw mx b">user</code>表有100条数据。</p><p id="a8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">order</code>是大桌子，<code class="fe mu mv mw mx b">user</code>是小桌子。</p><p id="9c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mu mv mw mx b">order</code>在左边，最好使用<code class="fe mu mv mw mx b">in</code>关键字。</p><p id="e5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:</p><ul class=""><li id="5c61" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe mu mv mw mx b">in</code>适用于左边的大桌子和右边的小桌子。</li><li id="5829" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe mu mv mw mx b">exists</code>适用于左边的小桌子和右边的大桌子。</li></ul><h1 id="3309" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 4。批量操作。</strong></h1><p id="7368" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果业务处理后有一批数据需要插入怎么办？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="64e5" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>for (Order order: list) {<br/>   orderMapper.insert(order);<br/>}</span></pre><p id="eb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在循环中逐个插入数据。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="a3d2" class="nh md it mx b gy ni nj l nk nl">insert into order(id,code,user_id) <br/>values(123,'001',100);</span></pre><p id="d441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作需要对数据库进行多次请求，才能完成这批数据的插入。</p><p id="b504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是众所周知，在我们的代码中，每次远程请求数据库，都会消耗一定的性能。</p><p id="4de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而如果我们的代码需要多次请求数据库来完成这个业务功能，必然会消耗更多的性能。</p><p id="81e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确的做法是提供一个批量插入数据的方法。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="0860" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>orderMapper.insertBatch(list);</span><span id="30b9" class="nh md it mx b gy of nj l nk nl"># insert into order(id,code,user_id) <br/># values(123,'001',100),(124,'002',100),(125,'003',101);</span></pre><p id="f480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样你只需要远程请求数据库一次，SQL性能就会提高。数据越多，提升越大。</p><p id="7747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但需要注意的是，不建议一次批量操作太多数据。如果数据太多，数据库响应会非常慢。</p><p id="376c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据超过500，则分多批处理。</p><h1 id="c0b1" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 5。使用限制。</strong></h1><p id="3f2f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时候，我们需要查询一些数据的第一项，比如:查询一个用户下的第一笔订单，想看看他第一笔订单的时间。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="2fb6" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>select id, create_date <br/> from order <br/>where user_id=123 <br/>order by create_date asc;</span></pre><p id="6115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据用户id查询订单，按订单时间排序，先找出用户的所有订单数据，得到一个订单集。</p><p id="37b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在代码中，获取第一个元素的数据，也就是第一个订单的数据，得到第一个订单的时间。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="4c0b" class="nh md it mx b gy ni nj l nk nl">List&lt;Order&gt; list = orderMapper.getOrderList();<br/>Order order = list.get(0);</span></pre><p id="da49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方式虽然在功能上没有问题，但是效率非常低。它需要先查询所有的数据，有点浪费资源。</p><p id="9583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何优化呢？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="5370" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>select id, create_date <br/> from order <br/>where user_id=123 <br/>order by create_date asc <br/>limit 1;</span></pre><p id="3e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用limit 1仅返回用户订购时间最短的数据。</p><p id="fcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，在删除或修改数据时，为了防止误操作，导致删除或修改无关数据，也可以在SQL语句的末尾加上<code class="fe mu mv mw mx b">limit</code>。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="dc32" class="nh md it mx b gy ni nj l nk nl">update order set status=0,edit_time=now(3) <br/>where id&gt;=100 and id&lt;200 limit 100;</span></pre><p id="ade1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样即使误操作比如id错了也不会影响太多数据。</p><h1 id="c19b" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 6。不要在</strong> <code class="fe mu mv mw mx b"><strong class="ak">in</strong></code> <strong class="ak">关键字中使用太多的值。</strong></h1><p id="e7c6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于批量查询界面，我们通常使用in关键字过滤掉数据。比如我想通过一些指定的id批量查询用户信息。</p><p id="d47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL语句如下所示:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="d650" class="nh md it mx b gy ni nj l nk nl">select id,name from category<br/>where id in (1,2,3...100000000);</span></pre><p id="87f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不加任何限制，查询语句可能一次查询很多数据，很容易造成接口超时。</p><p id="aaa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们该怎么办？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9b65" class="nh md it mx b gy ni nj l nk nl">select id,name from category<br/>where id in (1,2,3...100)<br/>limit 500;</span></pre><p id="8aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用SQL中的limit来限制数据。</p><p id="0c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们更多的是给业务代码添加限制。伪代码如下:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="f131" class="nh md it mx b gy ni nj l nk nl">public List&lt;Category&gt; getCategory(List&lt;Long&gt; ids) {<br/>   if(CollectionUtils.isEmpty(ids)) {<br/>      return null;<br/>   }<br/>   if(ids.size() &gt; 500) {<br/>      throw new BusinessException("too many")<br/>   }<br/>   return mapper.getCategoryList(ids);<br/>}</span></pre><p id="b7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种解决方案是:如果ids中的记录超过500条，可以使用多线程来批量查询数据。每批只检查500条记录，最后将查询到的数据汇总返回。</p><p id="e176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过这只是权宜之计，不适合id太多的场景。因为id太多，即使能快速检测到数据，如果返回的数据量太大，网络传输非常耗费性能，接口性能也好不了多少。</p><h1 id="466c" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 7。增量查询。</strong></h1><p id="6436" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，我们需要通过远程接口查询数据，然后将其同步到另一个数据库。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="c8ec" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>select * from user;</span></pre><p id="d6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果直接获取所有数据，那么就同步。虽然这样很方便，但是带来了一个非常大的问题，就是如果数据量很大，查询性能会很差。</p><p id="d26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们该怎么办？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="846f" class="nh md it mx b gy ni nj l nk nl">select * from user <br/>where id&gt;#{lastId} and create_time &gt;= #{lastCreateTime} <br/>limit 100;</span></pre><p id="b0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按id和时间升序排列，每次只同步一批数据，这批数据只有100条记录。每次同步完成后，保存100条数据中最大的id和时间，以便在同步下一批数据时使用。</p><p id="4e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种增量查询方式可以提高单次查询的效率。</p><h1 id="6d95" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 8。高效分页。</strong></h1><p id="a62f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时候在列表页面查询数据时，为了避免一次返回太多数据，影响界面性能，我们一般会对查询界面进行分页。</p><p id="c333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL中分页常用的<code class="fe mu mv mw mx b">limit</code>关键字:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="67cc" class="nh md it mx b gy ni nj l nk nl">select id,name,age <br/>from user limit 10,20;</span></pre><p id="534c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果表中的数据量很小，使用limit关键字进行分页没有问题。但是如果表中有大量的数据，就会出现性能问题。</p><p id="1f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，分页参数现在变成了:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="dab5" class="nh md it mx b gy ni nj l nk nl">select id,name,age <br/>from user limit 1000000,20;</span></pre><p id="a2b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL会找到1，000，020条数据，然后丢弃前1，000，000条数据，只检查后20条数据，很浪费资源。</p><p id="0c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何对这些海量数据进行分页呢？</p><p id="6b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优化SQL:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="2e72" class="nh md it mx b gy ni nj l nk nl">select id,name,age <br/>from user where id &gt; 1000000 limit 20;</span></pre><p id="58ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先找到上次分页的最大id，然后使用id上的索引进行查询。但是，在这个方案中，要求id是连续有序的。</p><p id="b7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用<code class="fe mu mv mw mx b">between</code>来优化分页。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="009b" class="nh md it mx b gy ni nj l nk nl">select id,name,age <br/>from user where id between 1000000 and 1000020;</span></pre><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，between应该在唯一索引上分页，否则会出现每页大小不一致的情况。</p><h1 id="0142" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 9。用连接查询替换子查询。</strong></h1><p id="4b1f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果需要在MySQL中查询两个以上表的数据，一般有两种实现方法:子查询和连接查询。</p><p id="991b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询的示例如下:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="e9ad" class="nh md it mx b gy ni nj l nk nl">select * from order<br/>where user_id in (select id from user where status=1)</span></pre><p id="a3b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询语句可以通过in关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序首先运行嵌套的最内层语句，然后运行外层语句。</p><p id="0f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询语句的优点是，如果涉及的表数量很少，它就简单且结构化。</p><p id="1074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但缺点是MySQL执行子查询时，需要创建临时表。在查询完成后，需要删除这些临时表，这有一些额外的性能消耗。</p><p id="3ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时可以改成连接查询。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="1dcd" class="nh md it mx b gy ni nj l nk nl">select o.* from order o<br/>inner join user u on o.user_id = u.id<br/>where u.status=1</span></pre><h1 id="ab59" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 10。连接表不应太多。</strong></h1><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="63da" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>select a.name,b.name.c.name,d.name<br/>from a <br/>inner join b on a.id = b.a_id<br/>inner join c on c.b_id = b.id<br/>inner join d on d.c_id = c.id<br/>inner join e on e.d_id = d.id<br/>inner join f on f.e_id = e.id<br/>inner join g on g.f_id = f.id</span></pre><p id="9cc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mu mv mw mx b">join</code>太多，MySQL在选择索引时会非常复杂，很容易选错索引。</p><p id="dc63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而如果没有命中，嵌套循环join就是从两个表中读取一行数据进行两两比较，复杂度为<strong class="lb iu"> n </strong>。</p><p id="af5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以要尽量控制连接表的数量。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="866e" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>select a.name,b.name.c.name,a.d_name <br/>from a <br/>inner join b on a.id = b.a_id<br/>inner join c on c.b_id = b.id</span></pre><p id="71e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在业务场景的实现中需要查询其他表中的数据，可以在a、b、c表中有冗余的特殊字段，例如表a中冗余的d_name字段来保存要查询的数据。</p><p id="bce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我之前见过一些ERP系统。并发量不大，但业务相对复杂。它需要连接十几个表来查询数据。</p><p id="9821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，连接表的数量应根据系统的实际情况来确定。不能一概而论。越少越好。</p><h1 id="e24c" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 11。内部联接注释。</strong></h1><p id="f406" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当涉及到多个表的查询时，我们通常使用join关键字。</p><p id="e93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常用的连接是<code class="fe mu mv mw mx b">left join</code>和<code class="fe mu mv mw mx b">inner join</code>。</p><ul class=""><li id="8067" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe mu mv mw mx b">left join</code>:求两个表的交集加上左表的剩余数据。</li><li id="e83e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe mu mv mw mx b">inner join</code>:查找两个表格交集的数据。</li></ul><p id="393f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mu mv mw mx b">inner join</code>的例子如下:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="85c1" class="nh md it mx b gy ni nj l nk nl">select o.id,o.code,u.name <br/>from order o <br/>inner join user u on o.user_id = u.id<br/>where u.status=1;</span></pre><p id="fb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用<code class="fe mu mv mw mx b">inner join</code>关联两个表，MySQL会自动选择两个表中的小表来驱动大表，所以在性能上不会有太多问题。</p><p id="f1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mu mv mw mx b">left join</code>的例子如下:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="2c09" class="nh md it mx b gy ni nj l nk nl">select o.id,o.code,u.name <br/>from order o <br/>left join user u on o.user_id = u.id<br/>where u.status=1;</span></pre><p id="bd31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个表使用<code class="fe mu mv mw mx b">left join</code>关联，默认情况下MySQL将使用left join关键字驱动右边的表。如果左表中有大量数据，就会出现性能问题。</p><p id="94ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，使用<code class="fe mu mv mw mx b">left join</code>查询时，左边用小表，右边用大表。如果能使用<code class="fe mu mv mw mx b">inner join</code>，尽量少用<code class="fe mu mv mw mx b">left join</code>。</p><h1 id="7876" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 12。限制索引的数量。</strong></h1><p id="8d00" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">众所周知，索引可以显著提高查询SQL的性能，但是索引的数量并不是越多越好。</p><p id="77a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为当表中增加新数据时，需要同时为其创建索引，索引需要额外的存储空间和一定的性能消耗。</p><p id="8bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个表中的索引数应尽可能控制在<strong class="lb iu"> 5 </strong>以内，单个索引中的字段数不应超过<strong class="lb iu"> 5 </strong>。</p><p id="9df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL用来保存索引的B+树的结构，B+树索引需要在插入、更新和删除操作中进行更新。如果索引太多，会消耗很多额外的性能。</p><p id="d472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，问题是，如果表中的索引太多，超过5个怎么办？</p><p id="921e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题需要辩证看待。如果你的系统并发低，表中数据量不太多，其实5个以上都可以，只要不超过太多。</p><p id="3641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于一些高并发系统，一定要遵守单个表上不超过5个索引的限制。</p><p id="9ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，高并发系统如何优化索引的数量呢？</p><p id="c4cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以建立联合索引，不要建立单一索引，可以删除无用的单一索引。</p><p id="1d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将一些查询功能迁移到其他类型的数据库，如Elastic Seach、HBase等。，只需要在业务表中建立几个关键索引。</p><h1 id="df9a" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 13。选择适当的字段类型。</strong></h1><p id="26f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe mu mv mw mx b">char</code>表示固定的字符串类型，该类型字段的存储空间是固定的，会浪费存储空间。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="f519" class="nh md it mx b gy ni nj l nk nl">alter table order <br/>add column code char(20) NOT NULL;</span></pre><p id="281c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">varchar</code>表示一种变长字符串类型，这种类型的字段存储空间会根据实际数据的长度进行调整，不会浪费存储空间。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9ce5" class="nh md it mx b gy ni nj l nk nl">alter table order <br/>add column code varchar(20) NOT NULL;</span></pre><p id="6555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是固定长度的字段，比如用户的手机号，一般是11位，可以定义为长度为11字节的char类型。</p><p id="893e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但如果是企业名称字段，如果定义为<code class="fe mu mv mw mx b">char</code>类型，就有问题了。</p><p id="df78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果长度定义太长，比如定义为200字节，实际企业长度只有50字节，就会浪费150字节的存储空间。</p><p id="4bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果长度定义太短，比如定义为50字节，但实际企业名称有100字节，就不会存储，会抛出异常。</p><p id="0933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，建议将企业名称改为<code class="fe mu mv mw mx b">varchar</code>类型。变长字段的存储空间较小，可以节省存储空间，对于查询来说，在相对较小的字段中搜索效率明显更高。</p><p id="887b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们选择字段类型时，我们应该遵循以下原则:</p><p id="13e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以使用数字类型，就不需要字符串，因为字符处理起来往往比数字慢。</p><p id="7bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽可能使用小类型，比如用<code class="fe mu mv mw mx b">bit</code>存储布尔值，<code class="fe mu mv mw mx b">tinyint</code>存储枚举值等。</p><p id="24da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">固定长度的字符串字段，类型为<code class="fe mu mv mw mx b">char</code>。</p><p id="39a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型为<code class="fe mu mv mw mx b">varchar</code>的可变长度字符串字段。</p><p id="6fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">decimal</code>用于金额字段，避免精度损失的问题。</p><h1 id="6120" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 14。</strong>提高效率<code class="fe mu mv mw mx b"><strong class="ak">group by</strong></code></h1><p id="49e6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们有许多业务场景需要使用<code class="fe mu mv mw mx b">group by</code>关键字。它的主要功能是去重复和分组。</p><p id="ff07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常与<code class="fe mu mv mw mx b">having</code>配合使用，意思是将数据分组，然后按照一定的条件进行过滤。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="ec9b" class="nh md it mx b gy ni nj l nk nl"># incorrect example<br/>select user_id,user_name from order<br/>group by user_id<br/>having user_id &lt;= 200;</span></pre><p id="d00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种书写方法性能很差。它首先根据用户id对所有订单进行分组，然后过滤用户id大于或等于200的用户。</p><p id="07ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分组是一个比较耗时的操作，为什么不先缩小数据再分组呢？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="c84c" class="nh md it mx b gy ni nj l nk nl"># correct example<br/>select user_id,user_name from order<br/>where user_id &lt;= 200<br/>group by user_id</span></pre><p id="d31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分组前使用where条件过滤掉冗余数据，这样分组时效率会更高。</p><p id="e2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实这是一种思路，并不局限于<code class="fe mu mv mw mx b">group by</code>的优化。在我们的SQL语句做一些耗时的操作之前，尽可能的缩小数据范围，这样可以提高SQL的整体性能。</p><h1 id="6137" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated"><strong class="ak"> 15。索引优化。</strong></h1><p id="6e6b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在SQL优化中，有一个非常重要的内容:<strong class="lb iu">索引优化</strong>。</p><p id="4ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多情况下，使用索引和不使用索引时，SQL语句的执行效率差别很大。所以索引优化是SQL优化的首选。</p><p id="8daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引优化的第一步是检查SQL语句是否被索引。</p><p id="76b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何检查SQL是否去了索引呢？</p><p id="02e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用<code class="fe mu mv mw mx b">explain</code>命令来查看MySQL的执行计划。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="832f" class="nh md it mx b gy ni nj l nk nl">explain select * from `order` where code='002';</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/248d4c12c278e01dc776226f4ef5e136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXeOjTYldlZzwgn8caOhQQ.png"/></div></div></figure><p id="1e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会单独写一篇博客来解释具体的详细参数。</p><p id="fdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是索引失败的一些常见原因:</p><ul class=""><li id="81a4" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">不满足最左前缀原则。</li><li id="799f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">范围索引列没有放在最后。</li><li id="1b22" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">已用<code class="fe mu mv mw mx b">select *</code>。</li><li id="737c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">有对索引列的计算。</li><li id="37e7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">索引列上有函数。</li><li id="ade8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">不带引号的字符串类型。</li><li id="94e5" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">用过的<code class="fe mu mv mw mx b">like %</code>。</li><li id="9e4d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">错误使用<code class="fe mu mv mw mx b">is null</code>。</li><li id="480c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">错误使用<code class="fe mu mv mw mx b">or</code>。</li></ul><p id="9fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不是以上原因，还需要进一步调查其他原因。</p><p id="d4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你有没有遇到过这样的情况:明明是同一个SQL，只是输入参数不一样。有时候指数a走，有时候指数b？</p><p id="350d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，有时候MySQL会选错索引。</p><p id="81c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有必要，可以使用<code class="fe mu mv mw mx b">force index</code>强制查询SQL转到某个索引。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="424b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oh">感谢您阅读本文。</em></p><p id="c3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oh">敬请期待更多。</em></p></div></div>    
</body>
</html>