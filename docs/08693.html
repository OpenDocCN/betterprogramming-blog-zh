<html>
<head>
<title>Demystifying Java Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘Java Lambda表达式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-java-lambda-expressions-d122b4b23b70?source=collection_archive---------4-----------------------#2021-06-01">https://betterprogramming.pub/demystifying-java-lambda-expressions-d122b4b23b70?source=collection_archive---------4-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c296" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">凭空变出功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20240af0e8e4a21019c08be7c4a6f704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKbNefOZMcHC3B-KMsy9kw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/cocoparisienne-127419/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=739165" rel="noopener ugc nofollow" target="_blank"> Anja提供🤗#伸出援手#团结#保持健康🙏</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=739165" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="e161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我好像花了很多时间解释Java函数式编程。真的，这里没有魔法。您将函数传递给函数以适应它们的行为。你为什么要这么做？如果你正在使用面向对象的开发，你已经在做了，但是是以一种非常可控的方式。Java的多态性是通过保存一个可以用子类替换的函数列表来实现的。那么该类的其他函数可能会调用一个被覆盖的函数，因此即使外部函数本身没有被覆盖，它的行为也会改变。</p><p id="31e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个多态的例子，并把它转换成lambda表达式的函数。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="be72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是非常经典的面向对象，一个<code class="fe lx ly lz ma b">Dog</code>和<code class="fe lx ly lz ma b">Cat</code>类型实现了一个<code class="fe lx ly lz ma b">Pet</code>类型。听起来熟悉吗？在这个极其简单的例子中，如果你打扰了你的宠物，它会做什么？一只狗叫，一只猫喵喵。</p><p id="2410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你也想要一条蛇呢？你必须创建一个新的类。如果你想要一千种类型呢？每一个都有很多样板文件。如果<code class="fe lx ly lz ma b">Pet</code>接口只有一个方法，Java可以像对待函数一样对待它。我将把<code class="fe lx ly lz ma b">disturb</code>方法移出<code class="fe lx ly lz ma b">Pet</code>接口(它可能一开始就不属于那里，因为它不是宠物的属性)。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是这个奇怪的语法<code class="fe lx ly lz ma b">() -&gt; something</code>，让一些人陷入了困境。但它所做的只是定义一个不带参数的函数，并返回一些东西。由于<code class="fe lx ly lz ma b">Pet</code>接口只有一个方法，这就是你如何调用你创建的函数。从技术上来说，它实现了覆盖<code class="fe lx ly lz ma b">vocalize</code>函数的类型<code class="fe lx ly lz ma b">Pet</code>。但是为了我们讨论的目的，它是一个可以传递给另一个函数的函数。</p><p id="eaf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以进一步减少这种情况，因为可以用“提供”发声的<code class="fe lx ly lz ma b">Supplier</code>接口来代替<code class="fe lx ly lz ma b">Pet</code>接口。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lx ly lz ma b">java.util.function</code>包中提供了<code class="fe lx ly lz ma b">Supplier</code>类型，因为它是如此常见的函数类型。</p><p id="aa61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些lambda函数让我们看起来像是在凭空创造一个函数。但是在幕后，我们用单个方法实现一个接口，并提供单个方法的实现。</p><p id="dcaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看另一个常见的函数，<code class="fe lx ly lz ma b">Consumer</code>。一个<code class="fe lx ly lz ma b">Consumer</code>函数以一个值作为参数，不返回任何东西，基本上就是消耗值。如果您曾经使用过列表或流的<code class="fe lx ly lz ma b">forEach</code>方法，那么您就使用了<code class="fe lx ly lz ma b">Consumer</code>。我们将把你的宠物的所有叫声收集到一个列表中，然后调用每一个。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b84c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你添加一只鸟到你的动物园，你只需要添加<code class="fe lx ly lz ma b">() -&gt; “chirp”</code>到列表中。请注意，我没有在<code class="fe lx ly lz ma b">v -&gt; disturbPet(v)</code> lambda中的v周围加上括号。对于单参数lambdas，括号是可选的。</p><p id="4b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我的例子很做作。我只想从多态函数走到lambda函数。你什么时候会真正使用lambda表达式？有几个例子非常常见，值得一读。这些被用作流库的一部分。</p><p id="4dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个不那么做作的例子，我将获得一个文件列表，删除不以点开头的文件，并获得文件的名称和大小。第一项工作是从当前目录中获取文件数组，并将其转换成<code class="fe lx ly lz ma b">Stream</code>类型。我们可以用<code class="fe lx ly lz ma b">File</code>类型做到这一点:</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="20b2" class="mf mg it ma b gy mh mi l mj mk">File dir = new File(".");<br/>Stream s = Arrays.<em class="ml">stream</em>(dir.listFiles());</span></pre><p id="a0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于目录是一个文件，我们可以用<code class="fe lx ly lz ma b">File</code>类型对它进行操作。我们也知道。是一个目录，所以我们可以在上面调用<code class="fe lx ly lz ma b">listFiles</code>。但是它返回一个数组，所以要使用streams来操作它，我们必须使用<code class="fe lx ly lz ma b">Arrays.stream</code>函数将数组转换成<code class="fe lx ly lz ma b">Stream</code>。</p><p id="c194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们删除以点开始的文件，将<code class="fe lx ly lz ma b">File</code>类型转换为带有名称和大小的字符串，按字母顺序排序，并记录下来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">采用lambda表达式的两个新函数是<code class="fe lx ly lz ma b">filter</code>和<code class="fe lx ly lz ma b">map</code>。<code class="fe lx ly lz ma b">filter</code>函数采用一个<code class="fe lx ly lz ma b">Predicate</code>类型，<code class="fe lx ly lz ma b">map</code>函数采用一个(不要笑)<code class="fe lx ly lz ma b">Function</code>函数，这两个函数都是<code class="fe lx ly lz ma b">java.util.function</code>包的一部分。两者都提供了非常常见的操作，你可以对一个对象进行操作，<code class="fe lx ly lz ma b">Predicate</code>测试对象的某些方面，并<code class="fe lx ly lz ma b">Function</code>将它从一个东西转换成另一个东西。两者都将一个对象作为参数，但是<code class="fe lx ly lz ma b">Predicate</code>返回一个布尔值，而<code class="fe lx ly lz ma b">Function</code>返回另一个对象。</p><p id="42e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我还检查了该项是一个文件。我们应该如何处理目录？如果我们递归进入目录怎么样？你会如何处理流呢？有一种特殊类型的映射将内部流(子目录)添加到外部流中。那到底是什么意思？看一下这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="799f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，如果所讨论的文件是一个目录，那么在<code class="fe lx ly lz ma b">flatMap</code>方法中使用的lambda将会递归，如果不是，那么将会返回文件本身。<code class="fe lx ly lz ma b">flatMap</code>的lambda必须返回某个东西的<code class="fe lx ly lz ma b">Stream</code>。所以在单个文件的情况下，我们必须用<code class="fe lx ly lz ma b">Stream.of()</code>包装它，以匹配递归调用<code class="fe lx ly lz ma b">getFiles()</code>的返回类型。还要注意，lambda包含在花括号中，所以如果希望它返回某个东西，它必须有一个return语句。</p><p id="aa87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用这个<code class="fe lx ly lz ma b">getFiles</code>函数，我们可以将它添加到main方法中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须通过一些机制来获得没有完整路径的文件名的相对路径。但是，嘿，这很有效。</p><p id="1429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以函数为参数的函数通常称为<em class="ml">高阶函数</em>。我们见过几个高阶函数:<code class="fe lx ly lz ma b">forEach</code>、<code class="fe lx ly lz ma b">filter</code>、<code class="fe lx ly lz ma b">map</code>、<code class="fe lx ly lz ma b">flatMap</code>。每一种都以抽象的方式代表了一种非常常见的对象操作方式，通过参数和返回值来区分。我们使用lambdas来提供要执行的明确操作。通过这种方式，我们可以对对象序列进行链式操作，以获得想要的结果。</p><p id="a291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这已经揭开了lambda函数的神秘面纱。我想当我第一次被介绍给它的时候，这个名字本身就很吓人。当然，这是借用了阿隆佐·邱奇的lambda微积分，但那是另一个故事了。现在，您需要知道的是，函数可以通过简单的语法凭空变出来。</p></div></div>    
</body>
</html>