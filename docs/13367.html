<html>
<head>
<title>Deploying to Multiple OSs With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go部署到多个操作系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploying-to-multiple-oss-with-go-d87fc1681720?source=collection_archive---------3-----------------------#2022-08-21">https://betterprogramming.pub/deploying-to-multiple-oss-with-go-d87fc1681720?source=collection_archive---------3-----------------------#2022-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="548a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Go build标签的快速概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e27d8b6cb3305b00cd476fbbcb24e7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UO9dY_-8xxmRh7E8"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@angelekamp" rel="noopener ugc nofollow" target="_blank">安格尔·坎普</a>通过unsplash提供</p></figure><p id="6637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在编写Go库时遇到的一个常见问题是管理多平台支持。我构建的第一批库具有糟糕的跨平台兼容性。然而，这是一些错误代码的结果。例如，我用<code class="fe ls lt lu lv b">+</code>操作符连接文件路径字符串。这导致一些功能无法正常工作。不过，我还是设法解决了这个问题。我导入了已经支持多种操作系统环境的包<code class="fe ls lt lu lv b">file/filepath</code>来纠正这个问题。在这篇文章中，我将尝试编写一个库。这个库将检查是否安装了某个程序。我选择这个问题是因为基于Windows和Unix的操作系统将程序放在不同的文件位置。</p><h1 id="bcd3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">图书馆</h1><p id="ea7b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了构建这个库，我将从测试驱动开发(TDD)中借用一些原则。考虑到这一点，我将从编写单元测试开始。该单元测试将验证函数是否返回正确的操作系统名称。稍后我将实现我正在测试的实际功能。测试将定义功能的需求，我将更新功能，直到测试通过。下面是测试的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面定义的文件的第一行是一个构建标记。我可以通过构建标签来命令<code class="fe ls lt lu lv b">go test</code>执行某些测试。这很有用，因为这个测试不会用命令<code class="fe ls lt lu lv b">go test</code>自动运行。例如，Windows测试在Unix计算机上肯定会失败。我将执行以下命令来运行上面的测试:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="cacf" class="mz lx iq lv b gy na nb l nc nd">go test --tags=unix_test</span></pre><p id="3528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试将会失败，因为我还没有定义函数<code class="fe ls lt lu lv b">FindExe</code>。首先，我将定义该函数的Unix版本。下面是执行此操作的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件的第一行是构建标记。当目标操作系统是Linux或MacOS时，它将编译这个文件。该函数将返回2个字符串。一个是我正在寻找的程序的路径，另一个是操作系统名。在这种情况下，操作系统名称始终是<code class="fe ls lt lu lv b">Unix</code>。本着TDD的精神，是时候运行我的测试了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/12e24be02b390de745248e78a1fe5b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AYB-ElRvsYVMeA3R.gif"/></div></div></figure><p id="7e72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然Unix功能已经工作，是时候添加Windows支持了。我先写个测试。测试文件将有构建标签<code class="fe ls lt lu lv b">windows_test</code>。下面是这个测试的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c9ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了需求，我将继续定义函数<code class="fe ls lt lu lv b">FindExe</code>的Windows实现。这个文件将有一个build标记来指定Windows作为它的构建目标。下面是执行此操作的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="07ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件的第一行将告诉编译器只在目标操作系统是windows时进行编译。这就是我在编写的包中避免重复函数名的方法。返回的文件路径与Unix实现有很大不同。这就是为什么build标签是有用的，如果没有它，我将不得不给我的函数以OS为中心的名字，或者在一些‘if’语句中插入。现在，是时候用适当的构建标记运行Windows测试了:</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="bdf3" class="mz lx iq lv b gy na nb l nc nd">go test --tags=windows_test</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/d7f04ccfb2f8bb1475bc3d7a735acf76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YD7eYgUnWaxdoCCl.gif"/></div></div></figure><p id="fd6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不出所料，该命令将会失败。测试使用的是unix实现<code class="fe ls lt lu lv b">FindExe</code>，它将返回Unix作为操作系统名称。</p><h1 id="8b36" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="3201" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">回到2016年，我试图建立一个围棋框架。该库的第一个版本对Windows的支持很差/甚至没有。我以为会有更多的Linux开发人员使用Go进行开发。我错了，因为在框架中加入Windows支持后，我看到下载量增加了。直到今天，该框架的大多数用户运行Windows。以下图表说明了这些数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/123390cce149e41dfe46dceb9a6c5d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7L9L2jlwEDYXS-KyzaLyg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://packagecontrol.io/packages/Gopher%20sauce%20syntax%20and%20static%20completions" rel="noopener ugc nofollow" target="_blank">https://package control . io/packages/Gopher % 20 sauce % 20 syntax % 20 and % 20 static % 20 completions</a></p></figure><p id="193d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他方法可以在没有构建标签的情况下实现跨平台支持。Go标准库有为多种操作系统设计的包。一个例子是包<code class="fe ls lt lu lv b">file/filepath</code>。它有一个叫Join的功能。该函数使用正确的路径分隔符连接一组路径部分。</p><p id="f96d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在下面这篇文章中找到这个库的链接。</p><h1 id="6105" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">附加链接</h1><div class="ng nh gp gr ni nj"><a href="https://github.com/cheikhshift/medium_examples/tree/main/multi-os" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">medium _ examples/主cheikhshift上的多操作系统/medium_examples</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">中型文章的代码示例。在GitHub上创建一个帐户，为cheikhshift/medium_examples开发做贡献。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://www.digitalocean.com/community/tutorials/building-go-applications-for-different-operating-systems-and-architectures" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">为不同的操作系统和架构构建Go应用程序|数字海洋</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">在软件开发中，重要的是要考虑操作系统和底层处理器架构…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.digitalocean.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div></div></div>    
</body>
</html>