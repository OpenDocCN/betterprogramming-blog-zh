<html>
<head>
<title>Better Swift Testing With Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入带来更好的快速测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-swift-testing-with-dependency-injection-8423acefa051?source=collection_archive---------10-----------------------#2020-08-12">https://betterprogramming.pub/better-swift-testing-with-dependency-injection-8423acefa051?source=collection_archive---------10-----------------------#2020-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进您的单元测试并提高可维护性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/767a35a8ed4f9a327328ce9159f7c48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VyUFCicrEoVWAsIO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="4b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试Swift代码最困难的事情之一是开始。一个新的应用程序的空白画布可能会令人生畏，并且很容易推迟编写测试，直到你完成了一些代码。</p><p id="c204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“当我写了一些代码后，我会去做，这样我就知道这个应用程序的架构会是什么样子。这将使我以后更容易添加测试。”</p><p id="0cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这通常会导致这样一种情况，您已经编写了大量的代码，突然开始编写测试变得更加困难，因为您的代码实际上已经变得不可测试了。这并不是因为你是一个糟糕的程序员——代码只是没有考虑到可测试性。</p><p id="e318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将看到<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>如何帮助你预先构建你的应用并解决你的一些测试问题。它甚至会帮助你以后进行重构。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a3d8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">依赖注入简介</h1><p id="7c69" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">依赖注入(DI)的主要思想是，它是一种技术，其中某个对象(例如视图控制器)可以通过某种配置方法或属性接收它所依赖的对象(例如视图模型)。它的伟大之处在于，它不依赖于任何特定的软件架构(MVC或MVVM)，也不需要任何第三方框架来应用它(即使这样的框架确实存在)。它实际上是一个非常基本的设计模式，但是它给了你很大的灵活性。</p><p id="a3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，有三种方法可以注入依赖项:</p><ol class=""><li id="dbd0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">通过自定义初始化器——如果您完全控制对象的初始化(自定义类、结构等),这是一个很好的选择。)，但如果您不这样做，则不是一个选项(例如视图控制器)。</li><li id="9ccc" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">通过属性—只需创建一个允许您设置依赖关系的公共可访问属性。很好也很简单，但是如果您不希望其他人可以访问这个依赖项，就不要这样做。</li><li id="cc3e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">通过配置方法—允许您轻松设置依赖关系，还允许您对外界隐藏依赖关系。如果您想确保其他代码不直接访问您的依赖项，这是一个很好的方法。</li></ol><p id="07b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个或多或少是相等的，但是提供稍微不同的(不)优势。我们将使用一些将web服务注入视图模型的示例代码来探索DI。</p><h2 id="fb63" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">没有依赖注入</h2><p id="df77" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们正在构建一个视图模型，该模型需要获取一个图书作者列表以显示在我们的应用程序中。代码可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们在视图模型和获取作者的实际服务之间做了很好的分离，但这里有一个问题:我们不能孤立地测试我们的视图模型，因为它调用服务，而且没有办法阻止这种情况发生。理想情况下，我们希望分别测试视图模型和服务。如果我们按原样测试视图模型，我们会测试太多，如果我们想重构或替换我们的服务，将来会很困难。</p><h2 id="86fd" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">使用依赖注入</h2><p id="fed4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将通过添加注入服务和更改服务的选项来解决这个问题，这样就可以很容易地将它交换到不同的服务(用于测试目的)。因为我们对这个定制类有完全的控制权，所以我们将选择基于初始化器的方法。结果看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="24b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的关键要点是:</p><ol class=""><li id="b4c4" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">我们已经创建了一个我们的服务应该遵守的协议。这确保我们有一个合适的合同来描述服务应该是什么样子。我们已经确保让我们的(现有的)web服务实现这个协议。</li><li id="bf9e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">我们已经改变了我们的视图模型，通过一个定制的初始化器来接受一个符合这个协议<em class="ny"> </em>的对象。这将被设置为<code class="fe nz oa ob oc b">service</code>属性。</li><li id="4273" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">我们通过使用默认参数来提供默认服务。当对象在没有自定义服务对象的情况下初始化时，这为我们提供了一个合理的默认值。</li></ol><p id="e24c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些，我们可以开始测试我们的代码了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="89db" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">测试视图模型</h1><p id="4ca7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我们已经完全分离了视图模型和服务，我们可以单独测试视图模型了。为此，我们构建了一个假的服务对象(符合我们刚刚创建的协议),并在测试期间注入它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fb06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这是一个非常琐碎的例子，但是关键的要点仍然存在:通过提供一种配置对象依赖关系的方法，而不是将它们限制在硬编码的依赖关系中，您可以使您的代码更容易测试<em class="ny">和</em>维护。</p><p id="3752" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您希望在某个时候从磁盘或核心数据中获取一个<code class="fe nz oa ob oc b">Authors</code>列表，您可以简单地编写一个新的服务，使其符合<code class="fe nz oa ob oc b">AuthorServiceProtocol</code>，并在适当的位置交换它。视图模型不需要知道这方面的任何事情，视图模型的所有测试将继续工作，就像什么都没有改变一样。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f481" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">概括起来</h1><p id="6829" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">依赖注入可能是一个很难理解的概念——不是因为它本身很难，而是因为框架声称可以促进这一点。他们试图提供一种非常僵化、集中和结构化的方法来做到这一点，这常常导致令人困惑的样板文件和一种压倒性的“对抗系统”的感觉。</p><p id="ebc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文展示了从DI开始的一种非常简单(也很常见)的方法，并展示了使用它的好处——如果不是为了测试目的，那么是为了可维护性。DI并不强迫你为你的应用使用某种架构，也不要求你使用MVC、MVVM、Clean或者任何其他流行的架构。它仅仅是一种设计模式，可以帮助您将代码分解成定义良好的片段，每个片段都有自己的职责。</p></div></div>    
</body>
</html>