<html>
<head>
<title>A Look at JavaScript Scopes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript作用域一览</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-javascript-scopes-acb0f5e9cd77?source=collection_archive---------14-----------------------#2022-01-20">https://betterprogramming.pub/a-look-at-javascript-scopes-acb0f5e9cd77?source=collection_archive---------14-----------------------#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="474a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解作用域在不同场景中的工作方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8eb68240b28978a9d7ae99f533d0c306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1SVDwFytlXkwNbCqN2mYw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">深度观察镜</p></figure><p id="5734" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">程序员需要知道变量的范围，才能知道从哪里可以访问函数。简而言之，作用域是我们可以访问变量或函数的地方。</p><p id="86a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本博客的内容:</p><ul class=""><li id="d091" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">范围链和嵌套范围</li><li id="8e7f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">块范围与函数范围</li><li id="f88c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">变量的生命周期</li></ul><p id="5f92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解作用域的工作机制，您需要知道词法作用域是如何工作的。在之前的博客中，我解释了<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/scope-closure-lexical-scope-9a18d0579d66"> <strong class="kx ir"> <em class="mg">词法范围</em> </strong> </a> <strong class="kx ir"> <em class="mg"> </em> </strong>和<em class="mg"> </em> <a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/a-look-at-javascript-closures-6de9b9ac4f8b"> <strong class="kx ir"> <em class="mg">闭包</em> </strong> <em class="mg">的机制。</em>T19】</a></p><h2 id="1238" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">范围链和嵌套范围</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eeb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的示例代码中有3个作用域。这里的三个范围相互交织在一起。交错作用域被称为<strong class="kx ir">嵌套作用域</strong>。如果我们从内向外数这些范围。</p><ol class=""><li id="4ed1" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nc lx ly lz bi translated">它从第4行的arrow函数开始，以第6行的第一个花括号结束。</li><li id="ce3f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nc lx ly lz bi translated">它从第3行的getBiggerNumbers函数开始，一直到第9行的花括号。</li><li id="6d19" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nc lx ly lz bi translated">所有剩余字段都包括在此范围内。此外，这个作用域被专门命名为全局作用域。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7c466ef38ad86f545233e9a90752fdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*SVUgzoLPLPVOgOz6zBH4ww.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">嵌套作用域</p></figure><p id="4044" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它是为了更好地理解上述视觉范围。粉色区域代表1.scope，绿色区域代表2 . scope。蓝色区域是全球范围。相互之间有嵌套作用域关系的作用域称为<strong class="kx ir">作用域链</strong>。因为这里有3个嵌套的作用域，所以这个例子也是一个作用域链的例子。</p><h2 id="ae0b" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">块范围与函数范围</h2><p id="99ca" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">根据维基百科，函数作用域可以定义为“当一个函数内声明的变量的作用域没有扩展到该函数之外时，这被称为<strong class="kx ir">函数作用域</strong>”。块作用域定义为“一个名称绑定的作用域是一个块，称为<strong class="kx ir">块作用域</strong>”。让我们通过例子来更好地理解这些定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="96c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你在上面看到的代码片段是一个函数作用域的例子。如果你是一个曾经使用块作用域的程序员，你可能认为这段代码会有问题。因为第8行中的变量名没有定义，并且错误消息应该已经发出，因为它试图在第8行被访问。但是功能范围不是这样工作的。当编译这个代码片段时，词法范围在函数的顶部定义了一个未定义的变量名。因此，变量名是可访问的。另外，将这个变量移动到函数顶部的过程，词法作用域所做的，叫做<strong class="kx ir">提升</strong>。现在，让我们用块范围编写同样的代码，看看会得到什么结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6cd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您所看到的，这是变量定义中let和const关键字比var关键字更受欢迎的主要原因之一。因为let和const块被定义为作用域，所以它们将可能出现的错误减到最小。</p><h2 id="823f" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">变量的生命周期</h2><p id="02bc" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">我们将研究一个已定义的变量在相同的作用域中用相同的名字再次定义时的行为，或者在定义变量之前是否要读取它的值。词法作用域提供了访问变量的方式和时间。</p><h2 id="5d3a" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">功能提升:</h2><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f336" class="mh mi iq nk b gy no np l nq nr">sum(1 + 3); // 4</span><span id="8aa5" class="mh mi iq nk b gy ns np l nq nr">function sum(a, b){<br/>	console.log(a+b);<br/>}</span></pre><p id="1cee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然代码片段中的sum函数是在定义之前执行的，但是没有错误。为什么？词法作用域将定义的sum函数放在编译时所在作用域的顶部。因此，当调用sum函数时，它可以正确无误地运行。这个移动过程叫做<strong class="kx ir">吊装</strong>。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8d2e" class="mh mi iq nk b gy no np l nq nr">sum(1 + 3); // TypeError: sum is not a function</span><span id="d0f9" class="mh mi iq nk b gy ns np l nq nr">var sum = function sum(a, b){<br/>	console.log(a+b);<br/>}</span></pre><p id="ff0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这段代码中可以看出，已经抛出了一个错误。该错误作为TypeError返回:sum不是函数。这里，Javascript没有返回任何没有定义sum函数的内容。这个错误告诉我们找到了变量Sum，但是它的引用不是一个函数。如果Javascript无法访问变量名sum，它将返回错误ReferenceError: sum未定义。此处定义的sum函数的值未定义。</p><h2 id="a23c" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">可变提升:</h2><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="b2b4" class="mh mi iq nk b gy no np l nq nr">console.log(name); // undefined<br/>name = 'Caner';<br/>console.log(name); // Caner<br/>var name = "Karaman"<br/>console.log(name); // Karaman</span></pre><p id="b4dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然打印到控制台第一行的变量名以前没有定义，但是在写入控制台时不会抛出任何错误。同样，在这里，词法作用域在作用域的顶部将变量“name”定义为未定义。因此，第一行中的console.log(name)返回undefined，而不是给出错误。由于name变量是在词法作用域的帮助下在作用域的顶部定义的，所以可以在第二行中为name变量赋值，而不需要任何关键字。因此，第3行的console.log(name)返回了' Caner '。同样的过程在第4和第5行继续。</p><p id="1662" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解，让我们看一下编译后的相同代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="25e4" class="mh mi iq nk b gy no np l nq nr">var name;<br/>console.log(name); // undefined<br/>name = 'Caner';<br/>console.log(name); // Caner<br/>name = "Karaman"<br/>console.log(name); // Karaman</span></pre><p id="85be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，词法作用域已经将var变量移到了作用域的顶部。因此，不会遇到任何错误。</p></div></div>    
</body>
</html>