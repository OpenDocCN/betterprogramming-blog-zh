<html>
<head>
<title>Search for Anything in Your Rails 6 Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails 6应用程序中搜索任何内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/search-for-anything-in-your-rails-6-application-d1eff22c108c?source=collection_archive---------14-----------------------#2020-01-07">https://betterprogramming.pub/search-for-anything-in-your-rails-6-application-d1eff22c108c?source=collection_archive---------14-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Rails活动记录备忘单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d386a52c577b0545044c3e0b48109f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OBXkDRjih3z9J8uuWCXtw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔希·卡拉布雷斯在<a class="ae ky" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建用户喜爱的应用程序的关键很简单——它必须运行良好，速度必须很快。</p><p id="2c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Rails 5+时，确保小规模应用程序的速度是微不足道的。使用活动记录很容易从小型数据库中检索出一个对象。但是，当记录数量增长到成千上万时，应用程序如何处理伸缩呢？</p><p id="3113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是——Ruby作为一种编程语言非常慢。然而，SQL查询非常快。active recording通过让开发人员用Ruby查询数据库来执行SQL搜索，弥补了这一缺陷。</p><p id="d886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">活动记录是使Rails成为如此强大的框架的原因之一，因为它允许开发人员在不编写SQL的情况下编写SQL。这是Rails魔力的一部分，非常棒。</p><p id="9b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到您开始查看活动记录文档，并感觉自己又回到了起点。</p><p id="28fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我做过的每一次Ruby on Rails编码面试中，第一个问题总是关于活动记录。活动记录是使Rails成为如此强大的框架的原因之一，因为它允许开发人员在不编写SQL的情况下编写SQL。</p><p id="cbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，下面是它是如何发生的:</p><ul class=""><li id="ef8a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Rails将活动记录请求转换成等价的SQL查询。</li><li id="8c29" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">SQL查询从数据库中检索相应的结果。</li><li id="8690" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Rails实例化了相应模型的等价Ruby对象。</li><li id="1575" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">应用程序运行任何相关的回调，如<code class="fe mj mk ml mm b">after_find</code>或<code class="fe mj mk ml mm b">after_initialize</code>。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f0b5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">一个简单的起点是在数据库中找到一条记录</h1><h2 id="729c" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">find()或find_by()</h2><p id="f608" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">因为ID是主键，<code class="fe mj mk ml mm b">find</code>方法将总是返回一条记录，如果该记录不存在，它将返回nil。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="0d7f" class="nm mv it mm b gy oh oi l oj ok">#returns the product with the id of 3<br/>Product.find(3)</span><span id="6877" class="nm mv it mm b gy ol oi l oj ok">#SQL query<br/>SELECT * FROM products WHERE (products.id = 3) LIMIT 1</span></pre><p id="66e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查找多条记录，可以传递一个id数组。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="c9e5" class="nm mv it mm b gy oh oi l oj ok">#returns an array of products containing IDs 1,3, and 5<br/>Product.find([1,3,5])</span><span id="f949" class="nm mv it mm b gy ol oi l oj ok">#SQL query<br/>SELECT * FROM products WHERE (products.id IN (1,3,5))</span></pre><p id="7635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">find_by</code>有点复杂。它允许您使用任何属性搜索记录，并将返回数据库中第一个匹配的记录。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="993c" class="nm mv it mm b gy oh oi l oj ok">#finds the first product matching the name Awesome Product<br/>Product.find_by(name: "Awesome Product")</span><span id="1697" class="nm mv it mm b gy ol oi l oj ok">#finds the first product matching the author Maria <br/>Product.find_by(author: "Maria")</span><span id="ef56" class="nm mv it mm b gy ol oi l oj ok">#finds the first product matching the name and author criteria<br/>Product.find_by(name: "Awesome Product", author: "Maria")</span></pre><p id="0f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe mj mk ml mm b">find</code>方法不同，如果没有找到匹配的记录，<code class="fe mj mk ml mm b">find_by</code>将<em class="om">而不是</em>返回nil，这是一个更安全的选择，可以避免遇到异常错误。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="818f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何查找多条记录</h1><h2 id="37d6" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">在哪里</h2><p id="348a" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe mj mk ml mm b">where</code>方法是一个很好的起点。它返回符合条件的记录数组。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="1ce7" class="nm mv it mm b gy oh oi l oj ok">Product.where(archived: true)</span><span id="2ce3" class="nm mv it mm b gy ol oi l oj ok">OR </span><span id="a541" class="nm mv it mm b gy ol oi l oj ok">Product.where('archived' =&gt; true)</span><span id="232f" class="nm mv it mm b gy ol oi l oj ok">#SQL query <br/>SELECT * FROM products WHERE (products.archived = true)</span></pre><p id="8d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对来自params的查询使用<code class="fe mj mk ml mm b">where</code>方法时需要小心，因为它经常是SQL注入的目标。您必须对字符串进行转义以避免这种类型的攻击。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="5200" class="nm mv it mm b gy oh oi l oj ok">DON'T DO THIS<br/>Book.where(<em class="om">"author = #{params[:author]}"</em>)</span><span id="104c" class="nm mv it mm b gy ol oi l oj ok">DO THIS<br/>Book.where("author = ?", params[:author])</span></pre><h2 id="f5ae" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">哪里没有</h2><p id="2b60" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">为了得到与<code class="fe mj mk ml mm b">where</code>搜索相反的结果，使用<code class="fe mj mk ml mm b">where.not</code>方法从数据库中选择<em class="om">不</em>匹配给定标准的对象。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="52fb" class="nm mv it mm b gy oh oi l oj ok">Product.where.not(archived: true)</span><span id="048c" class="nm mv it mm b gy ol oi l oj ok">OR</span><span id="a67a" class="nm mv it mm b gy ol oi l oj ok">Product.where.not('archived' =&gt; true)</span><span id="e1fc" class="nm mv it mm b gy ol oi l oj ok">#SQL query <br/>SELECT * FROM products WHERE (products.archived != true)</span></pre><p id="6100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以在上面的语句中使用<code class="fe mj mk ml mm b">false</code>来得到相反的结果，但是对于更复杂的查询，<code class="fe mj mk ml mm b">where.not</code>是一个巧妙的技巧。</p><h2 id="448b" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">在多个表格中搜索</h2><p id="88a3" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">如果多个表通过<code class="fe mj mk ml mm b">has_many</code> / <code class="fe mj mk ml mm b">belongs_to</code>关联连接，则使用<code class="fe mj mk ml mm b">where</code>查询来搜索它们。</p><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当使用<code class="fe mj mk ml mm b">joins</code>语句时，它指的是关联的表名，而不是模型名。在父关联中搜索时使用此选项。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="5a7c" class="nm mv it mm b gy oh oi l oj ok">Book.where(author: params[:author])</span><span id="6f6d" class="nm mv it mm b gy ol oi l oj ok">Author.joins(<strong class="mm iu">:books</strong>).where(books: { author: params[:author]})</span></pre><h2 id="d9e2" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">避免N+1次查询</h2><p id="d566" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">当搜索多个记录时，Rails很容易在每次SQL执行时添加越来越多的查询。通过预先加载关联来避免n+1陷阱。</p><pre class="kj kk kl km gt od mm oe of aw og bi"><span id="28ea" class="nm mv it mm b gy oh oi l oj ok">Book.includes(:comments).where(comments: { visible: true })</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="494c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">就是这样！</h1><p id="29fe" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">这些是在Rails应用程序中进行搜索的基础。活动记录的速度快如闪电，但它所能做的仍然有限。</p><p id="b994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我推荐用<a class="ae ky" href="https://github.com/Casecommons/pg_search" rel="noopener ugc nofollow" target="_blank"> pg_search </a>这样的宝石。Rails中的过滤功能更多，包括限制、排序、分组等。如果你将来想写一篇关于它的文章，请告诉我！</p></div></div>    
</body>
</html>