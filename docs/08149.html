<html>
<head>
<title>How Java Interfaces Are Different From Abstract Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java接口与抽象类有何不同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-java-interfaces-are-different-from-abstract-classes-33fce6fc6d76?source=collection_archive---------8-----------------------#2021-03-31">https://betterprogramming.pub/how-java-interfaces-are-different-from-abstract-classes-33fce6fc6d76?source=collection_archive---------8-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="817b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解相似之处以及何时使用什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/036a6fa8bdba161b88d63a55cb4d32a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paMS4tfmUWgvZOQ4-KUkhA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5090067" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/xresch-7410129/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5090067" rel="noopener ugc nofollow" target="_blank"> xresch </a>。</p></figure><p id="b7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管接口和抽象类乍一看有许多相似之处——特别是在引入了<code class="fe lv lw lx ly b">default</code>方法之后——但它们有不同的用例和功能。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="9f48" class="mk ml it ly b gy mm mn l mo mp"><strong class="ly iu">TABLE OF CONTENTS</strong></span><span id="2cc1" class="mk ml it ly b gy mq mn l mo mp"><a class="ae ky" href="#5e41" rel="noopener ugc nofollow">Interfaces</a><br/><a class="ae ky" href="#4266" rel="noopener ugc nofollow">Abstract Classes</a><br/><a class="ae ky" href="#55aa" rel="noopener ugc nofollow">Interface or Abstract Class?</a><br/><a class="ae ky" href="#27d5" rel="noopener ugc nofollow">Why not use both?</a><br/><a class="ae ky" href="#a6b3" rel="noopener ugc nofollow">Behavioral Contract vs. Shared Logic</a></span></pre><p id="41d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">注意:假设使用Java 8，但是如果适当的话，使用Java 10特性</em> <a class="ae ky" href="https://developer.oracle.com/java/jdk-10-local-variable-type-inference.html" rel="noopener ugc nofollow" target="_blank"> <em class="mr">局部变量类型推断</em> </a> <em class="mr">来增加可读性。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5e41" class="ms ml it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">接口</h1><p id="b174" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果一个类实现了一个接口，它就是一个它的实例如何与它周围的世界交互的行为契约。通常，存在方法签名，但是空的“标记”接口也是可能的。</p><p id="de1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个简单的闹钟，只有一个闹钟:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bc33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何实现<code class="fe lv lw lx ly b">AlarmClock</code> <em class="mr">的类型都必须</em>实现符合接口的方法。</p><h2 id="3c1e" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">默认方法</h2><p id="3c3b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Java 8通过引入<code class="fe lv lw lx ly b">default</code>方法改进了接口，允许我们提供一个不能被覆盖的方法的默认实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体的实现不再需要提供暂停逻辑，但仍然可以选择覆盖一个或两个暂停方法。</p><h2 id="ad40" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">静态方法</h2><p id="e264" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Java 8还引入了<code class="fe lv lw lx ly b">static</code>接口方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">default</code>方法一样，<code class="fe lv lw lx ly b">static</code>方法通过在一个地方聚集相关的方法/逻辑来提供更多的内聚性，而不需要像<code class="fe lv lw lx ly b">AlarmTimeCalculator</code>这样的辅助对象。但是与<code class="fe lv lw lx ly b">default</code>方法不同，我们不能覆盖<code class="fe lv lw lx ly b">static</code>方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4266" class="ms ml it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">抽象类</h1><p id="b77e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">abstract class</code>是一种特殊的不可实例化的类，它可以被部分实现。它们被设计成由另一个类来完成。通过将方法签名定义为<code class="fe lv lw lx ly b">abstract</code>，必须省略方法体，就像在<code class="fe lv lw lx ly b">interface</code>中一样。</p><p id="e3bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以轻松复制我们的<code class="fe lv lw lx ly b">AlarmClock</code>接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="be80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与接口相比，抽象类最显著的优势是能够使用状态和提供构造函数。</p><h2 id="f57b" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">状态</h2><p id="b3e5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">像任何其他类一样，我们可以定义一个内部状态，从而包含比使用<code class="fe lv lw lx ly b">default</code>方法更多的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="98d4" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">构造器</h2><p id="c340" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们也可以在<code class="fe lv lw lx ly b">abstract class</code>中声明构造函数。是否声明构造函数以及声明什么类型的构造函数会直接影响我们在任何子类型中调用它们的方式。</p><ul class=""><li id="0de7" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">无构造函数:没有任何显式构造函数，我们不必在任何子类型中调用<code class="fe lv lw lx ly b">no argument</code>默认构造函数。</li><li id="3dd8" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">默认构造函数:<strong class="lb iu"> </strong>如果<code class="fe lv lw lx ly b">no argument</code>默认存在于<code class="fe lv lw lx ly b">abstract class</code>中，仍然不需要在任何继承类型中显式调用它。电话将在“幕后”进行例如，我们的<code class="fe lv lw lx ly b">AlarmClock</code>可以使用一个<code class="fe lv lw lx ly b">Optional&lt;LocalTime&gt;</code>并在构造函数中初始化它:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="2fbf" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">参数化构造函数:<strong class="lb iu"> </strong>与“普通”类之间的继承一样，默认<code class="fe lv lw lx ly b">no-arg</code>构造函数的存在依赖于参数化构造函数的存在。如果一个参数化的构造函数存在，但是没有一个显式默认的<code class="fe lv lw lx ly b">no-arg</code>构造函数，任何继承类型<em class="mr">必须</em>在它自己的构造函数中调用一个<code class="fe lv lw lx ly b">super</code>构造函数。</li></ul><p id="8c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想在构造函数中设置小睡持续时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体的实现现在需要一个显式的构造函数调用<code class="fe lv lw lx ly b">super</code>来让编译器高兴。它可以是默认的<code class="fe lv lw lx ly b">no-arg</code>构造函数，也可以是参数化的构造函数。如果基类型中存在多个构造函数，调用其中任何一个都可以:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="55aa" class="ms ml it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">接口还是抽象类？</h1><p id="0f99" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">尽管两者都提供了一组重叠的功能，但它们的预期用途和应用是不同的。</p><h2 id="06a5" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">(多)遗传</h2><p id="a318" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">与其他语言不同，Java不支持多重继承。一个类只能<em class="mr">扩展</em>一个单独的其他类，比如<code class="fe lv lw lx ly b">LongSnoozeClock</code>。</p><p id="d1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，接口不会屈服于这种限制。一个类可以<em class="mr">实现</em>多个接口，一个接口可以<em class="mr">扩展</em>多个接口。</p><p id="483f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的<code class="fe lv lw lx ly b">default</code>方法都会被继承，导致一个问题:如果多个接口实现同一个方法怎么办？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有显式的<code class="fe lv lw lx ly b">@Override</code>，编译器将不知道调用哪个默认方法实现，所以我们被迫覆盖它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="67fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们仍然可以通过利用<code class="fe lv lw lx ly b">&lt;type&gt;.super</code>来依赖默认实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="19fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是扩展<code class="fe lv lw lx ly b">Foo</code>接口来聚合<code class="fe lv lw lx ly b">Bar</code>的逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="59ba" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">可见性修改器</h2><p id="d956" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在一个<code class="fe lv lw lx ly b">interface</code>中，一切都是隐式的<code class="fe lv lw lx ly b">public</code>，只允许<code class="fe lv lw lx ly b">static</code>方法为<code class="fe lv lw lx ly b">private</code>。在缺乏状态的情况下，这种限制是有意义的。<code class="fe lv lw lx ly b">default</code>方法使用的公共逻辑可以安全地重构为<code class="fe lv lw lx ly b">private static</code>方法，以对实现者隐藏。</p><p id="a5e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果没有<code class="fe lv lw lx ly b">protected</code>，一个接口永远不能只提供一个方法给它的直接实现者，而这个方法对所有其他类型都不可用。</p><p id="0ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一可用的可见性限制是基于类型的。如果接口声明本身没有被声明为公共的，那么它只能在包级别上使用。</p><p id="ac88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象类是<em class="mr">类</em>，所以它们可以利用所有的可见性修饰符。当被继承时，它们遵循相同的规则:被重写的方法必须至少具有相同的可见性，但是可以选择增加可见性。</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="5605" class="mk ml it ly b gy mm mn l mo mp"><strong class="ly iu">Visibility increments</strong></span><span id="ebd1" class="mk ml it ly b gy mq mn l mo mp">(none=package) -&gt; protected -&gt; public</span></pre><h2 id="cb2b" class="mk ml it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">展开性</h2><p id="4a57" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在引入接口<code class="fe lv lw lx ly b">default</code>方法之前，抽象类是确保可扩展性的首选方式。</p><p id="5d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们向一个接口添加一个新方法，它的所有实现者都被迫实现它，很可能会破坏大量代码。另一方面，抽象类可以很容易地添加非抽象方法，所有相关类型都可以。</p><p id="2762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">default</code>方法，我们最终可以在不破坏现有类型的情况下，通过添加新方法来改进接口。实际上，JDK 8用<code class="fe lv lw lx ly b">default</code>方法实现了很多额外的特性，比如<code class="fe lv lw lx ly b">java.util.Collection#stream()</code>。</p><p id="9d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使没有默认逻辑，抛出一个<code class="fe lv lw lx ly b">UnsupportedOperationException</code>也比破坏每个相关类型要好。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="27d5" class="ms ml it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">为什么不两个都用？</h1><p id="f78a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以一前一后地使用它们，而不是使用接口或抽象类。接口可以描述类型的公共契约，抽象基类提供了实现它的起点。这对<a class="ae ky" href="https://en.wikipedia.org/wiki/Service_locator_pattern" rel="noopener ugc nofollow" target="_blank">服务定位器模式</a>特别有用。</p><p id="00c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的公司对我们的数据访问对象使用了这种组合。一个<code class="fe lv lw lx ly b">DAO</code>接口描述了如何访问数据，一个<code class="fe lv lw lx ly b">HibernateDAO</code>抽象类提供了用Hibernate访问数据的基本功能。</p><p id="b251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简化的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个实际的<code class="fe lv lw lx ly b">DAO</code>服务接口现在可以只扩展<code class="fe lv lw lx ly b">DAO</code>，它的具体实现可以扩展<code class="fe lv lw lx ly b">HibernateDAO</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="98a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于接口和抽象类的这种结合，我们获得了多种优势:</p><ul class=""><li id="af26" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><code class="fe lv lw lx ly b">DAO</code>是任何道必须履行的最低契约。</li><li id="a62b" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe lv lw lx ly b">HibernateDAO</code>提供了任何具体的基于Hibernate的<code class="fe lv lw lx ly b">DAO</code>可能需要的最基本的功能。</li><li id="e179" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">标准的Dao，比如<code class="fe lv lw lx ly b">BeanDAO</code>，以及它们的具体实现，只需要很少的额外代码。</li><li id="5f62" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">嘲笑测试也更简单。就像<code class="fe lv lw lx ly b">HibernateDAO</code>一样，我们可以创建一个名为<code class="fe lv lw lx ly b">MockDAO</code>的共享抽象类。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a6b3" class="ms ml it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">行为契约与共享逻辑</h1><p id="0534" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">决定使用哪一种的最好方法是认识到它们的最初目的是什么。</p><p id="f6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口基本上是描述类型能力的行为契约。其自身及其实现者的多重继承允许广泛的使用，从简单的标记接口到要遵循的合同包。添加<code class="fe lv lw lx ly b">default</code>方法甚至允许我们向所有实现者提供逻辑，并使可扩展性成为可能。</p><p id="f079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象类不仅仅是契约。它们是部分实现的类型，有时甚至根本不提供任何实现。这允许由继承者完成共享逻辑和实现细节的基类的创建。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt mg ly op bn oq or bi"><span id="58d7" class="os ml it ly b be ot ou l mo mp"><strong class="ly iu">You like my ramblings about Java?<br/>Check out my upcoming book!<br/></strong><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="1827" class="ms ml it bd mt mu ov mw mx my ow na nb jz ox ka nd kc oy kd nf kf oz kg nh ni bi translated">资源</h1><ul class=""><li id="994d" class="ob oc it lb b lc nj lf nk li pa lm pb lq pc lu og oh oi oj bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html" rel="noopener ugc nofollow" target="_blank">什么是接口？</a>(甲骨文)</li><li id="111b" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" rel="noopener ugc nofollow" target="_blank">抽象方法和类</a>(甲骨文)</li><li id="5010" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html" rel="noopener ugc nofollow" target="_blank">接口</a> (Java语言规范)</li><li id="175d" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1.1" rel="noopener ugc nofollow" target="_blank">抽象类</a> (Java语言规范)</li></ul><div class="pd pe gp gr pf pg"><a href="https://medium.com/@benweidig/java-8-interfaces-default-methods-for-backwards-compatibility-2767a6a70947" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Java 8接口:向后兼容的默认方法</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">确保向后兼容性并编写更少的代码</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div></div></div>    
</body>
</html>