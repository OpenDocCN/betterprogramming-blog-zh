<html>
<head>
<title>Use Julia For Awesome Data Science Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Julia用于出色的数据科学项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-julia-for-awesome-data-projects-71d39c345aa9?source=collection_archive---------5-----------------------#2021-10-19">https://betterprogramming.pub/use-julia-for-awesome-data-projects-71d39c345aa9?source=collection_archive---------5-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Julia能提供什么，以及它在Python面前表现如何</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/609645fe767dcf1545c7ceabd067302a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Z7PvH-FQNKD3ZQWpF3ftQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="21aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为维护多功能工具箱和跟上公司技术进步的一部分，我们有时会开始尝试新技术，其中可能也包括编程语言。</p><p id="5d84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://julialang.org/" rel="noopener ugc nofollow" target="_blank"> Julia(编程语言)</a>从0.6版本开始，我就一直关注它，但我从未觉得它已经完全成熟。大约三年前，在2018年8月，当我读到Julia 1.0已经推出，并且“准备好生产”这句话向我发出信号，这一时刻终于到来时，我感到非常兴奋。</p><h1 id="d7d1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">那么，朱莉娅是什么？</strong></h1><p id="bd4e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有很多关于Julia的信息，但只言片语——Julia是一种现代、开源、高性能、动态类型的语言，用于数据科学、机器学习、科学计算等领域，于2012年在麻省理工学院创建。它是一种利基编程语言，社区相当小(与Python等相比)，但它正在快速成长。</p><blockquote class="mp mq mr"><p id="6e5b" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">超过700所大学和研究机构以及Aviva、BlackRock、Capital One和网飞等公司都在使用它。</p></blockquote><p id="24d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果网飞正在使用它，你是否也应该看看它？</p><p id="f690" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Julia的创造者心中有一个独特的目标——将R和Python等定量环境的功能与Java和C++等生产编程语言的速度结合起来，这是一个真正雄心勃勃的努力。</p><h1 id="5ad5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么要用？</h1><p id="cfb7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">尽管Julia在我们的技术堆栈中所占的份额很小，但它的影响却非常重大。它主要用于数据工程项目，其中计算的规模和速度是主要因素。</p><p id="0224" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然有许多现成的基准，但我将在Julia和Python之间进行一个简短的比较来展示这一点:</p><p id="8ece" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们比较一个简单的<em class="ms">排序</em>函数，下面的示例代码演示了如何使用这两种语言对一个包含1百万到2百万整数的数组进行排序(并计时)。</p><p id="74ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="12b5" class="nb lt iq mx b gy nc nd l ne nf">import timeit<br/><br/>num_runs = 100<br/><br/>SETUP = """<br/>import random as rd<br/><br/>data = rd.sample(range(1, 2000000), 1000000)<br/>"""<br/><br/>STMT = """<br/>sorted(data)<br/>"""<br/><br/>timeit.Timer(STMT, setup=SETUP).timeit(number=num_runs) / num_runs</span></pre><p id="604b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在朱莉娅中，事情是这样简单地完成的:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5beb" class="nb lt iq mx b gy nc nd l ne nf">using BenchmarkTools</span><span id="465c" class="nb lt iq mx b gy ng nd l ne nf">@benchmark sort(data) setup=(data=rand(1:2000000, 1000000))</span></pre><h1 id="ebb9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Python和Julia的性能比较</h1><p id="d441" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">看到语法上的相似之处了吗？嗯，基本上就到此为止了。</p><p id="e534" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Julia平均在<code class="fe nh ni nj mx b">67.355ms</code>完成排序，而Python平均需要<code class="fe nh ni nj mx b">754.512ms</code>(在2018款MacBook Pro 15上运行)。茱莉亚展示了一场大胜，在这里快了一个数量级。</p><p id="32b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但也许一个简单的函数并不那么令人印象深刻。让我们来看一个更复杂且极其相关的数据<code class="fe nh ni nj mx b">split-apply-combine</code>功能的例子(更广为人知的是map-reduce)。</p><p id="b3c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们创建一个有两百万行和两列(<em class="ms"> A </em>和<em class="ms"> B </em>)的<code class="fe nh ni nj mx b">DataFrame</code> <em class="ms"> </em>，由一个从1到3百万的随机整数和两个随机字母的字符串组成。然后按列<em class="ms"> B </em>将其拆分，并应用<code class="fe nh ni nj mx b">max(A) / count(rows)</code>的计算。</p><p id="5770" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Python中:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d97f" class="nb lt iq mx b gy nc nd l ne nf">import timeit</span><span id="eeab" class="nb lt iq mx b gy ng nd l ne nf">num_runs = 10<br/><br/>SETUP = """<br/>import pandas as pd<br/>import random as rd<br/>import string as s<br/><br/>letters = [''.join(rd.sample(s.ascii_uppercase, 2)) for i in range(0,2000000)]<br/><br/>def split_apply_combine(r):<br/>    return pd.DataFrame(dict(A=rd.sample(range(1, 3000000), 2000000), B=r)). \<br/>        groupby(by=['B']). \<br/>        apply(lambda x: max(x['A']) / len(x))<br/>"""<br/><br/>STMT = """<br/>    split_apply_combine(letters)<br/>"""<br/><br/>timeit.Timer(STMT, setup=SETUP).timeit(number=num_runs) / num_runs</span></pre><p id="ddc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在朱莉娅:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3af8" class="nb lt iq mx b gy nc nd l ne nf">using BenchmarkTools, DataFrames, Random</span><span id="eb5d" class="nb lt iq mx b gy ng nd l ne nf">split_apply_combine(r) = <br/>  DataFrame(A=rand(1:3000000, 2000000), B=r) |&gt; <br/>  dataframe -&gt; by(dataframe, :B, sdf -&gt; max(sdf.A...)/nrow(sdf))</span><span id="0a09" class="nb lt iq mx b gy ng nd l ne nf">@benchmark split_apply_combine(r) setup=(r=map(x -&gt; randstring("ABCDEFGHIJKLMNOPQRSTUVWXYZ", 2), 1:2000000))</span></pre><p id="9dd5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们比较一下这两种解决方案的性能。</p><p id="5a5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Julia平均在<code class="fe nh ni nj mx b">702.348ms</code>完成这个任务，而Python平均在<code class="fe nh ni nj mx b">4,180.999ms</code> (4.18秒)完成，虽然没有上一个例子中的差别大，但这仍然是一个相当大的进步。</p><p id="0630" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个毫不费力的添加，比如在Julia函数中提供类型，减少了大约120ms的运行时间，并使Julia接近更好的数量级。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5c76" class="nb lt iq mx b gy nc nd l ne nf">split_apply_combine(r::Vector{String})::DataFrame = <br/>  DataFrame(A=rand(1:3000000, 2000000), B=r) |&gt; <br/>  dataframe -&gt; by(dataframe, :B, sdf -&gt; max(sdf.A...)/nrow(sdf))</span></pre><p id="9f59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Python确实有办法变得更快，像提供了一个<code class="fe nh ni nj mx b">jit</code>装饰器的<code class="fe nh ni nj mx b"><a class="ae lr" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">Numba</a></code>这样的包可能会使它非常接近Julia的性能，但是Python的强大带来了一个很大的警告(许多代码约束)。</p><h1 id="db07" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结果</h1><p id="3d9b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">总的来说，当在一些密集的任务中从Python到Julia重写和替换相同的功能时(有严格的SLA)，我看到了运行时的巨大改进。我必须承认，我没有在分析代码效率上投入时间，纯粹按现在的样子，我经历了大约三倍的改进，轻微的多处理增加甚至进一步改进了它。</p><p id="d71a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些听起来都很不错，对吧？但是如何让Julia投入生产并部署它呢？让我们在<a class="ae lr" href="https://www.naturalint.com/" rel="noopener ugc nofollow" target="_blank">自然智能</a>中深入了解一下我们的环境。</p><h1 id="9823" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">朱莉娅提供了什么？</h1><p id="7431" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Julia完全是功能性的，代码被组织在包中。每个包就像OOP语言中的一个类，有自己的方法。</p><p id="0787" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Julia在其核心支持多分派，因此以后扩展这些方法通常是一种令人愉快的体验。尽管没有必要，我总是添加类型来减少编译器的工作量(和推理时间)并巩固程序。不用说，我认为任何一个程序员都会在这种语言中找到自己真正喜欢的东西。</p><h1 id="3825" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们如何组织我们的朱莉娅代码？</h1><p id="6d84" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在我们的代码库中有两种包:</p><ol class=""><li id="b9d2" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">跨多个项目使用的基础设施/公用设施包</li><li id="2630" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">利用不同方法并完成特定任务的专用和定制解决方案包</li></ol><p id="5d06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个包都有自己的依赖管理器(<code class="fe nh ni nj mx b">Pkg</code>)，使用起来非常简单。您可以在包级别添加、删除、升级、降级和固定依赖版本。最好的部分是，一个项目有两个包，需要相同的依赖项，尽管版本不同，将获得两次编译的依赖项，每个包都有基本版本。</p><p id="0d87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个包都有自己的测试，因为我们使用TeamCity作为CI/CD平台，所以我扩展了基本的<code class="fe nh ni nj mx b">@test</code>和<code class="fe nh ni nj mx b">@test_throws</code>宏来额外发送所需格式的消息。因此，TeamCity将显示通过和失败的测试数量。</p><p id="3904" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">包也可能有一个<em class="ms">构建</em>脚本，可以在编译之前做一些事情，比如检索一些外部依赖和工件或者计算并保存一个工件。非常简单。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="a1fa" class="nb lt iq mx b gy nc nd l ne nf">[PackageName]<br/>|<br/>├── Project.toml               &lt;&lt; metadata and direct dependencies<br/>├── Manifest.toml              &lt;&lt; the whole dependencies tree<br/>├── src                        &lt;&lt; all Julia source code inside<br/>|   └── [PackageName.jl]       &lt;&lt; main package file (gateway)<br/>├── test                       &lt;&lt; package tests inside<br/>|   └── runtests.jl            &lt;&lt; main tests file (gateway)<br/>├── deps                       &lt;&lt; external dependencies inside<br/>|   └── build.jl               &lt;&lt; external dependencies build script <br/>|                 <br/>└── [Additional Folders/Files] &lt;&lt; additional folders, like `docs`</span></pre><h1 id="7673" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">环境设置—如何开始？</h1><p id="6580" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在编写一行代码之前，需要完成几个步骤。</p><ol class=""><li id="3177" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">Julia需要知道项目驻留在哪里——类似于Python中的<code class="fe nh ni nj mx b">PYTHONPATH</code>,但不幸的是不太方便。变量<code class="fe nh ni nj mx b">LOAD_PATH</code>(或环境变量<code class="fe nh ni nj mx b">JULIA_LOAD_PATH</code>)必须用每个包的路径填充。</li><li id="5187" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">Julia可以通过一个简单的命令启动多个worker，例如<code class="fe nh ni nj mx b">julia -p 4</code>(除了master之外还有4个worker，每个worker都使用你的机器的一个内核)，但是为了在它们上面运行代码，每个worker都必须有可用的<code class="fe nh ni nj mx b">LOAD_PATH</code>。</li><li id="85df" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><code class="fe nh ni nj mx b">ENV</code>变量<code class="fe nh ni nj mx b">JULIA_PROJECT</code>必须声明，让Julia知道初始项目路径。</li></ol><p id="d1e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，Julia尊重一个<code class="fe nh ni nj mx b">startup.jl</code>文件，它在启动时就被执行。我发现它非常有用，并从我的<code class="fe nh ni nj mx b">.zshrc</code>中准备了以下命令，因此整个过程将是自动的:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9dea" class="nb lt iq mx b gy nc nd l ne nf">cd /Users/daniel.giterman<br/>mkdir -p .julia/config \<br/> &amp;&amp; rm -f .julia/config/startup.jl \<br/> &amp;&amp; export JULIA_PROJECT=julia \ <br/> &amp;&amp; echo "using Revise, OhMyREPL, Distributed" &gt;&gt; .julia/config/startup.jl \<br/> &amp;&amp; echo "@everywhere include(\".julia/julia_env_variables.jl\")" &gt;&gt; .julia/config/startup.jl \<br/> &amp;&amp; for pkg in julia/*/; do echo "@everywhere push!(LOAD_PATH, \"$pkg\")" &gt;&gt; .julia/config/startup.jl; done</span></pre><p id="4d4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们跑过上面的街区:</p><ol class=""><li id="ba04" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">创建<code class="fe nh ni nj mx b">startup.jl</code>所在的路径(以防不存在)。</li><li id="e291" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">清理干净(每次都是从头开始)。</li><li id="640c" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">导出环境变量<code class="fe nh ni nj mx b">JULIA_PROJECT</code>(主要用于使用 s的<em class="ms"/></li><li id="6fa7" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">将执行以下操作的代码写入<code class="fe nh ni nj mx b">startup.jl</code>:</li></ol><ul class=""><li id="3658" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq ny nq nr ns bi translated">在主进程上加载一些有用的包，比如<code class="fe nh ni nj mx b">Revise</code>(让我们不必在修改包的源代码后重新编译)。</li><li id="c7a5" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq ny nq nr ns bi translated">在所有可用的工人上加载项目相关的环境变量文件。</li><li id="6d05" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq ny nq nr ns bi translated">迭代项目包，并将它们逐个添加到所有可用工人的<code class="fe nh ni nj mx b">LOAD_PATH</code>中。</li></ul><p id="a060" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您现在已经准备好开始在Julia中发展了！</p><p id="5f79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您应该不会再有丢失环境变量的问题了；任何新的包都将自动添加到<code class="fe nh ni nj mx b">LOAD_PATH</code>中，使用多处理变得完美无缝。</p><h1 id="e00b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署漏斗</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2bab628ecc79213f3a8011c3bfd2636f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdPiyd70YB2A6dDav1iHBA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2ad5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一步:</strong>将开发好的Julia源代码推送到Git仓库。</p><p id="228b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤2: </strong> TeamCity在Git中的VCS变更事件上触发Julia build配置。此步骤通过以下方式构建Julia Docker图像:</p><ul class=""><li id="0552" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq ny nq nr ns bi translated">下载并安装<a class="ae lr" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">茱莉亚</a>。</li><li id="3bff" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq ny nq nr ns bi translated">准备Julia环境(<code class="fe nh ni nj mx b">startup.jl</code>文件),类似于我之前展示的，但是没有ENV变量文件，因为它是后来从外部注入的(气流),也没有像<code class="fe nh ni nj mx b">Revise</code>这样的开发辅助包(我们这里不需要它们)。</li><li id="32be" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq ny nq nr ns bi translated">通过执行下面的Julia代码片段准备好所有的包:</li></ul><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c5fc" class="nb lt iq mx b gy nc nd l ne nf">julia -e 'using Pkg; \<br/>          @show LOAD_PATH; \<br/>          pkg_lps = filter(x -&gt; occursin(r"julia/", x), LOAD_PATH); \<br/>          foreach(package -&gt; begin \<br/>                               Pkg.activate(package); \<br/>                               Pkg.resolve(); \<br/>                               Pkg.instantiate(); \<br/>                               Pkg.build(); \<br/>                               Pkg.precompile(); \<br/>                          end, pkg_lps)'</span></pre><p id="5508" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，<code class="fe nh ni nj mx b">LOAD_PATH</code>通常包含像<code class="fe nh ni nj mx b">@</code>和<code class="fe nh ni nj mx b">@v#.#</code>这样的值，如果没有提供项目文件，这些值会让Julia知道在哪里寻找项目文件。因此我过滤掉它们，只留下通过<code class="fe nh ni nj mx b">startup.jl</code>添加的包。</p><p id="13cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于列表中的每个包，请执行以下操作:</p><ol class=""><li id="0a1d" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated"><strong class="kx ir">激活</strong> —切换到打包环境。</li><li id="f795" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx ir"> Resolve </strong> —对齐所有依赖版本(当在一个包中更新另一个包所依赖的依赖时，必须在该包的<code class="fe nh ni nj mx b">Manifest.jl</code>中更新)。</li><li id="21c9" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx ir">实例化</strong>——获取所有依赖项的源代码。</li><li id="3e94" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx ir">构建</strong> —如果存在，执行<code class="fe nh ni nj mx b">build.jl</code>脚本。</li><li id="c370" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx ir">预编译</strong> — Julia的JIT编译器将编译的结果部分缓存到一个文件中(<code class="fe nh ni nj mx b">~/.julia/compiled</code>目录中的<code class="fe nh ni nj mx b">.ji</code>文件)，以减轻使用包时的负担。</li></ol><ul class=""><li id="8e99" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq ny nq nr ns bi translated">从Docker容器内部对每个包运行测试。</li></ul><p id="eb65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个过程的结尾是一个大约1GB的基于Debian的映像，它包括Julia环境，有100多个依赖包和几个我们的项目。考虑到里面的东西，这是我们堆栈中迄今为止最小的图像。</p><p id="0d75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第三步:</strong>只有在所有相关测试都成功之后，Julia Docker映像才会被推送到DockerHub，然后部署到我们在所有环境中的所有相关服务器(例如群管理器)上。</p><p id="3f75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第四步:</strong> Julia任务由Airflow调度，在Docker Swarm/K8s集群上规模化运行。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h1 id="5b4f" class="ls lt iq bd lu lv oh lx ly lz oi mb mc jw oj jx me jz ok ka mg kc ol kd mi mj bi translated">摘要</h1><p id="d36e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Julia确实是一种圆滑的编程语言。个人感觉很“轻巧”；它不会让你被概念和工具淹没，但它提供了无限的开发可能性，以及备受赞赏的极简主义(和速度！).</p><p id="45fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的设置相当简单，没有外部依赖性，并且有一个简单的部署选项(如上所述)。</p><p id="5317" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，没有多少程序员熟悉这种语言，坦率地说，更少的人有兴趣或时间去钻研它。虽然通常与Python相比，Julia仍然缺乏全面的包库，其社区也小得多。只是派对来的太晚了。因此，有些人可能会认为不值得投资，因为改编和重写大量遗留代码会消耗太多的资源和时间。这可能完全是一个交易破坏者。</p><p id="dbb1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">朱莉娅在某些地方可以被认为是外国人。然而，考虑到它已经提供的一切，我认为它最终受欢迎的增长只是一个时间问题。</p><p id="447c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很幸运能成为一个拥有多语言环境的团队的一员。我们的编程工具箱相当丰富，对于每项任务，我们都尝试匹配合适的工具。因此，在某些情况下，朱莉娅提供了一个优雅而准确的解决方案。</p></div></div>    
</body>
</html>