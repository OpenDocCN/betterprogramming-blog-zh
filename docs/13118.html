<html>
<head>
<title>Image Processing in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的图像处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-pictures-and-fun-2486d9f1cc29?source=collection_archive---------1-----------------------#2022-07-31">https://betterprogramming.pub/golang-pictures-and-fun-2486d9f1cc29?source=collection_archive---------1-----------------------#2022-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Golang，图片和乐趣</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d43510050edfcc0f3e7a1b648b68573e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ogoyqsk7tLXxjqPp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@mylene1708?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的米琳·特雷莫耶</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f0a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我想和你们一起写一个小项目，它通过其他图像绘制图像，创建一个马赛克。当然，我们将使用Golang来实现这一点(当然，因为它时尚、新潮、快速)。</p><p id="7adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的任务听起来像这样:</p><blockquote class="ls lt lu"><p id="09a6" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">你需要得到一个图像，然后用一个小图像从这个图像中画出每个像素，所以要得到一个由数百个小图像组成的“马赛克”。</p></blockquote><p id="df70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会用我的头像做源图(比我多，lol)。作为马赛克的一部分，来自WoW的图标(因为有相当多的图标来完成调色板)。结果，我们应该得到这样的东西:</p><div class="kg kh ki kj gt ab cb"><figure class="lz kk ma mb mc md me paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/8d723ff8108c7b6083d3105a47a9527c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*S6zP1zKXLgr2H18f7JHN_g.jpeg"/></div></figure><figure class="lz kk mf mb mc md me paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/69f8de28b0572be1deb5833b0c05e4ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kUkkkAOtuzJIgb6x7NU6fQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk mg di mh mi translated">正如你所看到的，即使是WoW中的图标(有几千个)也不足以覆盖整个色谱。但是我们不需要，我们只是玩玩而已:d。</p></figure></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/d40f806574cd5b210a2319c6908252ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnge4U0f3Ht4WBi_qCzWHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">接近时的结果</p></figure><p id="413b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们走吧！</p><p id="984b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，首先我们用构建器的模板创建<code class="fe mk ml mm mn b">main.go</code>。</p><h1 id="ba1b" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">我们开始吧</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要我们的图标，我们将使用它来布局马赛克。正如我上面所说，这里我们将重点关注来自魔兽世界游戏 <strong class="ky ir">的<a class="ae kv" href="https://github.com/AcidWeb/Clean-Icons-Mechagnome-Edition/releases/tag/9.2.5.43971" rel="noopener ugc nofollow" target="_blank">图标。你绝对可以使用任何图像，只要它们是正方形的，并且有很多。</a></strong></p><p id="f184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们已经下载了我们的图标，把它们放在某个地方，但我们需要知道所有的图片，我们将用来建立我们的形象。为此，我们将编写一个函数来遍历包含图片的目录树，并返回图片路径的平面列表。</p><p id="1402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加<code class="fe mk ml mm mn b">getPartsPaths</code>函数，并在我们的收集器中固定图标的路径和大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fc36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷，我们可以收集我们的马赛克元素！</p><p id="ce2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要开始挑选图像，我们需要快速访问这些图片的基色，也就是说，当我们在源图像中发现蓝色时，我们需要快速找到与蓝色最相似的图片，并快速完成。要做到这一点，我们需要为我们的图标制作一个地图，其中关键是颜色，图像本身就是值。</p><p id="7e47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们写一些函数:</p><ul class=""><li id="9234" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><strong class="ky ir"> loadImage </strong> —将我们的图像从磁盘加载到内存中，以便快速访问</li><li id="6188" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><strong class="ky ir">calculatemodalaveragecolor</strong>—将获取图像的基本颜色</li><li id="a422" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><strong class="ky ir"> getPartsMap </strong> —将返回我们的地图和图像</li></ul><h1 id="09cd" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">loadImage</h1><p id="ec48" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">因为我们的图标是TGA格式的，而内置的Golang库不知道如何使用这种格式，所以我们需要安装github.com/ftrvxmtrx/tga包。</p><blockquote class="ls lt lu"><p id="3a5c" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">去找github.com/ftrvxmtrx/tga</p></blockquote><p id="82fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这将有利于我们确保我们的图像将有1和相同的大小，为此我们将使用github.com/nfnt/resize包。</p><blockquote class="ls lt lu"><p id="3f88" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">去找github.com/nfnt/resize</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="70ad" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">calculatemodalaveragecolor</strong></h1><p id="650f" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">接下来，我们实现<code class="fe mk ml mm mn b">calculateModalAverageColour</code>，它将计算图像的平均颜色，并返回RGB模型中像素的颜色值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="68a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我们只是计算了每个像素的每个RGB参数的平均值，这不是一个精确的模型，但对我们来说已经足够了。</p><p id="1878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们结合上面写的内容，实现getPartsMap函数，该函数将返回完成的图像映射。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设上传图像时出错，那么让我们跳过出错的部分。</p><p id="0f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到我们的主构建函数，添加地图的获取。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="05cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好像一切都准备好了，可以开始用鲜花布置形象了，但是等等，牛仔，时间还早；)</p><p id="7198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的地图是不够的，因为它没有覆盖图像的整个调色板。我们需要了解哪种颜色(哪个图标)最适合我们。</p><p id="1d3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要在地图中实现一个搜索功能，计算RGB点之间的<a class="ae kv" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>，并返回最近的部分。</p><p id="3bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们实现了<code class="fe mk ml mm mn b">getClosestPart</code>函数，它将我们的地图和从源图像中读取的像素作为输入。</p><p id="1bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一定要提前确保map size &gt; 0，否则你会在nil指针上得到一个恐慌。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，我们有机会得到最接近我们像素的图像，剩下的只是创建一个新的图像，通过原来的一个和布局我们的马赛克，前进！</p><p id="3b6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加最后一部分，我们的“建立”功能，它打开源图像img.jpg(你可以使用其他内置的解码器，例如PNG)并创建res.png。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ddf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们有意将我们的图像缩小到300×300像素，否则它会非常大，因为在我们的例子中它的大小会增加60×60倍！</p><p id="01fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这些，我们程序的完整清单如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已！</p><p id="a6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个程序可以优化，但可以是你的作业！</p><p id="2c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为优化，您可以:</p><ul class=""><li id="d3b6" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">不要在程序开始时重新计算地图，让它延迟加载。也就是说，在JSON中编写颜色和文件路径，根据需要沿着JSON中的路径加载图像。</li><li id="2e36" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">使图像映射并行加载。</li><li id="4018" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">平行通过所有像素。</li></ul><p id="31af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在本文中已经介绍过:</p><ul class=""><li id="45d0" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">如何在Golang中使用文件</li><li id="852b" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">使用Golang中的内置类型:切片、地图和创建自定义类型。</li><li id="4087" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">如何在Golang中处理图像</li><li id="fbc0" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">科学感动！具体来说，求<a class="ae kv" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧氏距离的算法。</a></li></ul></div></div>    
</body>
</html>