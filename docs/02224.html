<html>
<head>
<title>SwiftUI Sign In With Apple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI登录Apple</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-sign-in-with-apple-c1e70ccb2a71?source=collection_archive---------8-----------------------#2019-11-14">https://betterprogramming.pub/swiftui-sign-in-with-apple-c1e70ccb2a71?source=collection_archive---------8-----------------------#2019-11-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0a92" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用户隐私、易用性和跨平台支持</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d1ef974287cbe82e035c2e9bf1168ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf_4uJsViifsME6ROWEJ0Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Pic演职员表:<a class="ae kz" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="6545" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在WWDC 2019期间，苹果推出了Apple Sign in，允许开发者在他们的应用程序中设置快速安全的登录。这对于简化登录体验是有意义的，因为从App Store下载的应用程序也需要Apple ID认证。</p><p id="913f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">自从SwiftUI第一次亮相以来，它已经震撼了iOS开发社区。多亏了它的状态驱动框架，它可以让我们写“做什么”而不是“怎么做”。</p><p id="3f1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Apple登录不仅可以通过不跟踪用户的敏感信息来确保隐私，还可以通过iCloud keychain在所有设备之间无缝同步来为用户提供统一性。</p><p id="605d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是的，它在Android和Windows设备上提供浏览器支持，也可以通过Apple JS登录。此外，它通过结合设备上的机器学习来检测欺诈(知道用户是否真实)，从而提高了安全性。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="02b6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">隐藏我的电子邮件地址</h1><p id="7b26" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">登录apple时，您可以选择在应用程序中隐藏您的电子邮件。</p><p id="fc04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，苹果会创建一个随机但真实且经过验证的电子邮件地址，发送到你真实的电子邮件地址。尽管您可以选择停止接收来自中继地址的电子邮件。这种经过验证的电子邮件地址功能对用户和开发人员来说是双赢的。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6d31" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我们的目标</h1><ul class=""><li id="495a" class="na nb iu lc b ld mv lg mw lj nc ln nd lr ne lv nf ng nh ni bi translated">在基于SwiftUI的应用程序中集成登录和Apple</li><li id="54e4" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">设置授权流和存储用户凭证</li><li id="8aa8" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">处理授权变更</li></ul><p id="4686" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">先决条件:需要一个Apple开发人员帐户才能使用Apple功能登录。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f457" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">启用使用Apple功能登录</h1><p id="7247" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">首先，您需要从<em class="no">目标|功能</em>面板启用使用Apple功能登录，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj np"><img src="../Images/ffd585f0c71d846f83ef502c916e5729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0atXKcbGtdjPGni7tnwVbQ.png"/></div></figure><p id="e2c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将创建一个授权文件，其中包含使用Apple登录，访问级别设置为默认。现在我们准备在SwiftUI应用程序中添加按钮。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="49cd" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">将登录与苹果按钮集成在一起</h1><p id="8e5f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">要用Apple button添加签到，需要<code class="fe nq nr ns nt b">import AuthenticationServices</code>。以下代码向SwiftUI视图添加了一个<code class="fe nq nr ns nt b">ASAuthorizationAppleIDButton</code>:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="c574" class="ny me iu nt b gz nz oa l ob oc">struct ContentView: View {</span><span id="7d00" class="ny me iu nt b gz od oa l ob oc">var body: some View {</span><span id="7208" class="ny me iu nt b gz od oa l ob oc">SignInWithAppleView()<br/>            .frame(width: 200, height: 50)<br/>    }<br/>}</span><span id="88fb" class="ny me iu nt b gz od oa l ob oc">struct SignInWithAppleView: UIViewRepresentable {</span><span id="ae3a" class="ny me iu nt b gz od oa l ob oc">func makeUIView(context: Context) -&gt; ASAuthorizationAppleIDButton {<br/>        ASAuthorizationAppleIDButton()<br/>    }<br/>    <br/>    func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {<br/>    }<br/>}</span></pre><p id="6748" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI目前不提供苹果<code class="fe nq nr ns nt b">View</code>的登录，所以我们使用了一个<code class="fe nq nr ns nt b">UIViewRepresentable</code>子类来包装UIView中的按钮。</p><p id="aa8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Apple允许我们通过以下方式定制按钮颜色、圆角半径和文本，以适应我们的应用程序设计:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/9370431ea98c74759c460ac7b4ddec8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*mnzLuJpJeA96CzgferS2jA.png"/></div></figure><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="3498" class="ny me iu nt b gz nz oa l ob oc">let button = ASAuthorizationAppleIDButton(authorizationButtonType: .signUp, authorizationButtonStyle: .whiteOutline)</span><span id="6071" class="ny me iu nt b gz od oa l ob oc">button.cornerRadius = 10</span></pre><p id="0bba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以设置按钮类型为<code class="fe nq nr ns nt b">continue</code>、<code class="fe nq nr ns nt b">signUp</code>、<code class="fe nq nr ns nt b">signIn</code>，样式为<code class="fe nq nr ns nt b">white</code>、<code class="fe nq nr ns nt b">black</code>或<code class="fe nq nr ns nt b">whiteOutline</code>。</p><p id="fb52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们的按钮已经设置好了，是时候配置它了。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1623" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">操作按钮选择器</h1><p id="6b11" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们可以在SwiftUI视图或UIKit视图中设置按钮上的tap功能。我们将采用后者，如下面的代码片段所示:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="5334" class="ny me iu nt b gz nz oa l ob oc">struct SignInWithAppleView: UIViewRepresentable {<br/>    <br/>    <a class="ae kz" href="http://twitter.com/Binding" rel="noopener ugc nofollow" target="_blank">@Binding</a> var name : String<br/>    <br/>    func makeCoordinator() -&gt; Coordinator {<br/>        return Coordinator(self)<br/>    }<br/>    <br/>    func makeUIView(context: Context) -&gt; ASAuthorizationAppleIDButton {<br/>        let button = ASAuthorizationAppleIDButton(authorizationButtonType: .signIn, authorizationButtonStyle: .black)<br/>        <br/>        button.addTarget(context.coordinator, action:  #selector(Coordinator.didTapButton), for: .touchUpInside)<br/>        return button<br/>    }<br/>    <br/>    func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {<br/>    <br/>    }<br/>}</span></pre><p id="11f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们已经设置了一个绑定属性包装器<code class="fe nq nr ns nt b">name</code>，它将在授权完成后更新SwiftUI时发挥关键作用。现在，只要把这个记下来。</p><p id="975f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将在我们的<code class="fe nq nr ns nt b">Coordinator</code>类中的按钮tap上设置授权流！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="043c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">显示授权对话框</h1><p id="8917" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">要显示授权对话框，我们需要使用<code class="fe nq nr ns nt b">ASAuthorizationAppleIDProvider</code>创建一个<code class="fe nq nr ns nt b">request</code>,并将其输入到<code class="fe nq nr ns nt b">ASAuthorizationController </code>,如下所示:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="03ec" class="ny me iu nt b gz nz oa l ob oc">@objc func didTapButton() {</span><span id="ed72" class="ny me iu nt b gz od oa l ob oc">let appleIDProvider = ASAuthorizationAppleIDProvider()<br/>let request = appleIDProvider.createRequest()<br/>request.requestedScopes = [.fullName, .email]</span><span id="8f81" class="ny me iu nt b gz od oa l ob oc">let authorizationController = ASAuthorizationController(authorizationRequests: [request])</span><span id="3186" class="ny me iu nt b gz od oa l ob oc">authorizationController.presentationContextProvider = self<br/>authorizationController.delegate = self<br/>authorizationController.performRequests()</span><span id="cde5" class="ny me iu nt b gz od oa l ob oc">}</span></pre><p id="e81c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要在我们的<code class="fe nq nr ns nt b">Coordinator</code>类中实现以下两个协议:</p><ul class=""><li id="ecc9" class="na nb iu lc b ld le lg lh lj of ln og lr oh lv nf ng nh ni bi translated"><code class="fe nq nr ns nt b">ASAuthorizationControllerPresentationContextProviding</code></li><li id="8680" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><code class="fe nq nr ns nt b">ASAuthorizationControllerDelegate</code></li></ul><p id="6ab1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">前者用于在屏幕上显示授权对话框，后者根据用户的动作处理授权结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/b766bbc1c46474349f8787a5d94159ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*30JpIrAHMFX9NO5a97YW8A.jpeg"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">选择隐藏我的电子邮件会将第二封电子邮件添加到邮件列表中，以便将邮件转发到您的主电子邮件。</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8c7b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">授权后处理用户的凭证</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div></figure><p id="8911" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，一旦用户的授权完成，就会触发<code class="fe nq nr ns nt b">didCompleteWithAuthorization</code>。它在<code class="fe nq nr ns nt b">credential</code>参数中返回用户名、标识符和用户的电子邮件地址。</p><p id="5bc3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，Keychain用于保存凭证，但是为了本文的简单起见，我们将使用<code class="fe nq nr ns nt b">UserDefaults</code>。</p><p id="d6ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了更新SwiftUI <code class="fe nq nr ns nt b">ContentView</code>，我们将用用户名设置<code class="fe nq nr ns nt b">Binding</code>实例<code class="fe nq nr ns nt b">parent.name</code>。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="daa1" class="ny me iu nt b gz nz oa l ob oc">struct ContentView: View {<br/>    <br/>    <a class="ae kz" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank">@State</a> var name : String = ""<br/>    <a class="ae kz" href="http://twitter.com/EnvironmentObject" rel="noopener ugc nofollow" target="_blank">@EnvironmentObject</a> var authorizationStatus: UserSettings<br/>    <br/>    var body: some View {</span><span id="731f" class="ny me iu nt b gz od oa l ob oc">         VStack{<br/>            if self.name.isEmpty{<br/>                SignInWithAppleView(name: $name)<br/>                .frame(width: 200, height: 50)<br/>            }<br/>            else{<br/>                Text("Welcome\n\(self.name)")<br/>                    .font(.headline)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="a813" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，基于状态<code class="fe nq nr ns nt b">name</code>，我们更新了文本并删除了使用Apple按钮登录，因为我们的授权已经完成。我想我知道你现在在想什么…为什么要声明一个环境对象？</p><p id="cc86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nq nr ns nt b">EnvironmentObject</code>是动态视图属性。类似于<code class="fe nq nr ns nt b">ObjectBinding</code>(外部属性)和<code class="fe nq nr ns nt b">States</code>(内部属性)，除了环境对象允许将可绑定对象传递给视图，而无需显式传递完整的对象。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="af96" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">处理授权变更</h1><p id="e2a8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在我们的例子中，我们需要<code class="fe nq nr ns nt b">EnvironmentObject</code>来处理授权变更和检查已经认证的用户。</p><p id="cb91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，在您的<code class="fe nq nr ns nt b">ContentView.swift</code>文件中添加一个<code class="fe nq nr ns nt b">UserSetting</code>类:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="2976" class="ny me iu nt b gz nz oa l ob oc">class UserSettings: ObservableObject {</span><span id="c2aa" class="ny me iu nt b gz od oa l ob oc">// 1 = Authorized, -1 = Revoked<br/>@Published var authorization: Int = 0</span><span id="6237" class="ny me iu nt b gz od oa l ob oc">}</span></pre><p id="e21f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将在<code class="fe nq nr ns nt b">SceneDelegate</code>类中检查任何预先存在的用户或授权更改(用户可以从<em class="no">设置| Apple ID |密码和安全</em>中撤销登录苹果),并相应地更新环境对象。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oj ok l"/></div></figure><p id="fef3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面这段代码中的下面一行更新了我们之前看到的<code class="fe nq nr ns nt b">ContentView</code>的<code class="fe nq nr ns nt b">EnvironmentObject</code>:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="3125" class="ny me iu nt b gz nz oa l ob oc">window.rootViewController = UIHostingController(rootView: contentView.environmentObject(settings))</span></pre><p id="d6e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，我们可以根据<code class="fe nq nr ns nt b">EnvironmentObject</code>中显示的最新授权状态，选择显示或隐藏Apple按钮登录。</p><p id="4500" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我们构建的SwiftUI应用程序的屏幕截图:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/d1ed6ad6d354367c8be2cfc8a890e052.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*-tzEu3KGsUaumVvzGZD55A.gif"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5529" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">下一步是什么</h1><p id="df12" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在本文中，我们混合了SwiftUI状态驱动框架和使用Apple授权流登录。目前，一旦您登录并尝试再次登录，凭据实例将不会再次获取用户名和电子邮件。</p><p id="cf23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下一部分中，我们将把Keychain加入进来，看看它如何帮助检索已经存在的用户的信息。</p><p id="d61f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。我希望你喜欢读它。</p></div></div>    
</body>
</html>