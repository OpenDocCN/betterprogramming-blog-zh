<html>
<head>
<title>How to Bulk Create and Update the Right Way in Golang (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang中正确地批量创建和更新(第一部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-bulk-create-and-update-the-right-way-in-golang-part-i-e15a8e5585d1?source=collection_archive---------0-----------------------#2020-03-21">https://betterprogramming.pub/how-to-bulk-create-and-update-the-right-way-in-golang-part-i-e15a8e5585d1?source=collection_archive---------0-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不同的基准方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a82f360fa227ffbfd128f86b1bf9adfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVrmgWpgvu1AY_wNx50vhA.png"/></div></div></figure><p id="559a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近走出了我的舒适区Python，开始着手我公司目前正在进行的Golang项目。</p><p id="3325" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我写这篇文章的原因是，我想分享我在Golang中创建和更新多个记录到<a class="ae lq" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>时所面临的经历，而我目前使用的ORM库(<a class="ae lq" href="https://gorm.io/" rel="noopener ugc nofollow" target="_blank"> GORM </a>)还不支持批量创建和更新操作。</p><p id="59bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将研究上述操作的不同方法，并对它们进行基准测试。那么，我们开始吧。</p><p id="f177" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我需要创建一个包含所有源代码的新项目文件夹:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="7e6c" class="lw lx it ls b gy ly lz l ma mb">mkdir go-bulk-create &amp;&amp; cd go-bulk-create</span></pre><p id="21e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我用<code class="fe mc md me ls b">go</code>模块初始化一个新的Go项目:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="2a0a" class="lw lx it ls b gy ly lz l ma mb">go mod init github.com/TrinhTrungDung/go-bulk-create</span></pre><p id="722b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将需要使用<code class="fe mc md me ls b">gorm</code>依赖项，安装如下:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b760" class="lw lx it ls b gy ly lz l ma mb">go get -u github.com/jinzhu/gorm</span></pre><p id="326f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我使用Docker Compose在我的本地机器容器中创建了一个新的隔离的PostgreSQL数据库实例，名为<code class="fe mc md me ls b">test.db</code>:</p><ul class=""><li id="acc7" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">在当前目录下创建一个新文件<code class="fe mc md me ls b">docker-compose.yml</code>。</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="527a" class="lw lx it ls b gy ly lz l ma mb">touch docker-compose.yml</span></pre><ul class=""><li id="9121" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">文件的内容应该如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="3ae0" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">运行<code class="fe mc md me ls b">docker-compose</code>文件来创建一个新的数据库:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4b50" class="lw lx it ls b gy ly lz l ma mb">docker-compose up -d</span></pre><p id="dc18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了一个新的数据库，我们创建一个新文件来尝试我所说的所有方法:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="f752" class="lw lx it ls b gy ly lz l ma mb">touch main.go</span></pre><ul class=""><li id="3d88" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">我们需要首先成功连接到我们的数据库。<code class="fe mc md me ls b">main.go</code>的内容将是:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="0b98" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">我们创建一个名为<code class="fe mc md me ls b">User</code>的样本表，并将其迁移到数据库中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="327f" class="mx lx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">标杆管理</h1><p id="1e5c" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">让我们首先创建测试文件:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="98d6" class="lw lx it ls b gy ly lz l ma mb">touch main_test.go</span></pre><p id="1ae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该文件包含如下一些帮助函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5b74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们需要的所有实用程序，让我们对每种方法进行基准测试。</p><h2 id="f2d4" class="lw lx it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated"><strong class="ak"> 1。使用GORM </strong>插入多条记录</h2><ul class=""><li id="73d2" class="mf mg it kw b kx no la np ld oe lh of ll og lp mk ml mm mn bi translated">我们将下面的ORM批量创建基准测试函数添加到<code class="fe mc md me ls b">main_test.go</code>文件中:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="1c17" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">运行以下命令获得速度和内存性能基准:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="08d8" class="lw lx it ls b gy ly lz l ma mb">go test -benchmem -run=^$ github.com/TrinhTrungDung/go-bulk-create -bench BenchmarkOrmCreate</span></pre><ul class=""><li id="a426" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">测试结果:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d962a70b1521ab1af8040af414151c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5jLR0XGlSDIpySi2m0DxQ.png"/></div></div><p class="oi oj gj gh gi ok ol bd b be z dk translated">ORM批量创建的测试结果</p></figure><p id="82c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到该函数在一秒钟内运行(默认情况下)，它以大约5.5毫秒/迭代的速率创建240条记录，每次迭代分配大约9000 B，每次迭代分配105个不同的内存。</p><p id="5f74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于更大的系统来说相当糟糕…</p><h2 id="0d3e" class="lw lx it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated"><strong class="ak"> 2。使用Insert语句</strong>插入多条记录</h2><ul class=""><li id="e9bd" class="mf mg it kw b kx no la np ld oe lh of ll og lp mk ml mm mn bi translated">我们使用<code class="fe mc md me ls b">INSERT</code>语句向<code class="fe mc md me ls b">main_test.go</code>文件添加另一个批量创建函数:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="3b59" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">使用以下命令运行测试功能:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="abcd" class="lw lx it ls b gy ly lz l ma mb">go test -benchmem -run=^$ github.com/TrinhTrungDung/go-bulk-create -bench BenchmarkCreate</span></pre><ul class=""><li id="982f" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">测试结果:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/cd7161b9189f306ae6a103010fad543c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s24TLy1WqM_NIyUXI0j5mw.png"/></div></div><p class="oi oj gj gh gi ok ol bd b be z dk translated">测试基准出现错误</p></figure><p id="af69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么？您一定想知道，在对上述函数进行基准测试时，为什么会出现这样的错误。</p><p id="43c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们阅读控制台中的错误，我们会注意到PostgreSQL支持的最大参数数是65535。每次迭代，我们都会追加两个参数(名称、密码),因此最大迭代次数必须小于或等于65535/2 = 32767。</p><p id="c602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，您可以看到在速度和内存方面的显著改进。在一秒钟内，它生成大约150000条记录，每次迭代花费我们8354纳秒，比第一种方法快600多倍！</p><p id="ea96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，在每次迭代的字节数和内存分配数方面，它减少了大约10倍。嗯，这是一个巨大的改进，但是如果我们在现实世界中实现这种方法，就不能保证数据的一致性。</p><h2 id="8665" class="lw lx it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated"><strong class="ak"> 3。使用批处理大小为</strong>的Insert语句插入多条记录</h2><p id="11ec" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">让我们看看这种方法是否是对第二种方法的拯救。</p><ul class=""><li id="9de1" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">首先，添加一个新的批量创建函数，就像在<code class="fe mc md me ls b">main_test.go</code>文件中的<code class="fe mc md me ls b">BenchmarkCreate</code>函数一样。但是，我们将实例列表分成多个小块，批量大小为500，如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="b4de" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">使用以下命令运行测试功能:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d03a" class="lw lx it ls b gy ly lz l ma mb">go test -benchmem -run=^$ github.com/TrinhTrungDung/go-bulk-create -bench BenchmarkBulkCreate</span></pre><ul class=""><li id="62bf" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">测试结果:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c06f014530ba627988dafc6944a93169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xezHysmC9AKGD-oO-YvaEQ.png"/></div></div></figure><p id="aea5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，它的性能可能比第二种方法差一点，但现在它保证了插入新记录时的一致性，这是您必须首先考虑的最重要的事情。</p><p id="50c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您应该有一些类似这样的问题:“当我们动态调整批量大小或插入更多列时会发生什么？”我们到了最后一种方法。</p><h2 id="9766" class="lw lx it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated"><strong class="ak"> 4。使用具有动态批处理大小的Insert语句插入多条记录</strong></h2><ul class=""><li id="d0b2" class="mf mg it kw b kx no la np ld oe lh of ll og lp mk ml mm mn bi translated">首先，我们重构<code class="fe mc md me ls b">benchmarkBulkCreate</code>函数来接受另一个名为<code class="fe mc md me ls b">size</code>的参数:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="8d3e" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">我们现在分别用1、100、500和1000的大小对<code class="fe mc md me ls b">benchmarkBulkCreate</code>函数进行基准测试。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="9076" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">通过运行以下命令，使用不同的批处理大小测试基准:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9893" class="lw lx it ls b gy ly lz l ma mb">go test -benchmem -run=^$ github.com/TrinhTrungDung/go-bulk-create -bench BenchmarkBulkCreateSize</span></pre><ul class=""><li id="cc8d" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">测试结果:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/551fd21e98425af11adfbaa342528642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DO7pClXtDxWtqaGkCXK3jg.png"/></div></div><p class="oi oj gj gh gi ok ol bd b be z dk translated">不同批量的基准测试</p></figure><p id="016d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当批量大于100时，我们每秒创建的记录数或创建速度没有区别。它也适用于每次迭代分配的字节数和内存分配。</p><p id="844d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如果改变插入参数的数量会发生什么。要做到这一点，我们只需将助手函数更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="42bd" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">测试结果:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/566fa67a5cabeb67d28fca6ae6195b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxEePeOQBSlOPYM0nHNuYg.png"/></div></div><p class="oi oj gj gh gi ok ol bd b be z dk translated">使用不同批量和附加参数进行基准测试</p></figure><p id="9e43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，在比较不同批量的统计数据时，添加更多的参数似乎没有什么不同。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4cf5" class="mx lx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="5d31" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">我个人默认选择批处理大小为500的<code class="fe mc md me ls b">INSERT</code>语句，因为它对于所有用例都是稳定的。在下一部分中，我将对批量更新进行基准测试。</p><ul class=""><li id="3377" class="mf mg it kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">这是<a class="ae lq" href="https://github.com/TrinhTrungDung/go-bulk-create" rel="noopener ugc nofollow" target="_blank">样本项目</a>。</li></ul><p id="18e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有更好的解决方法，请在评论区分享给我。</p></div></div>    
</body>
</html>