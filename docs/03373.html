<html>
<head>
<title>How Does TypeScript Know Which Types Are Compatible With Each Other?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript如何知道哪些类型相互兼容？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-typescript-know-which-types-are-compatible-with-each-other-enums-and-more-2f4171e41ca0?source=collection_archive---------15-----------------------#2020-02-05">https://betterprogramming.pub/how-does-typescript-know-which-types-are-compatible-with-each-other-enums-and-more-2f4171e41ca0?source=collection_archive---------15-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c44" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看看如何确定类、枚举和泛型具有兼容的类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35aebebd30efec1ab46228f643e9db3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P-C4lkwveVNX0jtl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Safar Safarov </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="de36" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">枚举和更多</h1><p id="e7b5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">与JavaScript相比，<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>的优势在于我们可以用它来注释变量、函数和其他实体的数据类型。这让我们可以在文本编辑器中自动完成，并且为构建应用程序增加了一个编译步骤。因此，编译时检查可以捕获更多的错误，如“未定义的错误”和“意外的数据类型”，否则这些错误会在运行时被捕获。</p><p id="c2d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为此，TypeScript根据实体的结构和其他方面(如参数数量、每个参数的类型等)检查不同变量是否具有相同的类型。在本文中，我们将继续研究TypeScript如何确定哪些数据类型是相互兼容的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="316a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">确定兼容的函数参数类型</h1><p id="e8f1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当将值作为参数传递给函数时，如果源参数可赋值给目标参数，或者反之，则参数赋值将成功。这涉及到在编译时不能确定的动作，但仍然是允许的。这意味着我们可以传入比参数指定的类型更特殊的参数，以保持与JavaScript的兼容性。例如，我们可以在下面的代码中做一些事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f55a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在上面的代码中，我们传入了一个类型为<code class="fe nb nc nd ne b">Employee</code>的变量，它比类型为<code class="fe nb nc nd ne b">Person</code>的<code class="fe nb nc nd ne b">person</code>参数有更多的属性。这意味着，像在JavaScript中一样，我们可以选择忽略传递给函数的对象的属性。当然，<code class="fe nb nc nd ne b">employeeCode</code>属性不能在<code class="fe nb nc nd ne b">fn</code>函数中访问，所以如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="92fe" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们会得到错误消息:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b4e4" class="nj lh it ne b gy nk nl l nm nn">Property 'employeeCode' does not exist on type 'Person'.(2339)</span></pre><p id="31d3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了禁止这种行为，我们可以在编译代码时启用<code class="fe nb nc nd ne b">strictFunctionTypes</code>标志。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="27ed" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">可选参数和Rest参数</h1><p id="2d10" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在TypeScript中，为了进行函数参数类型兼容性检查，可选参数和必需参数可以互换。无论是源类型的额外参数，还是没有源类型的相应参数的目标类型的可选参数，都不是错误。例如，允许使用以下代码:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="af72" class="nj lh it ne b gy nk nl l nm nn">const runLater = (callbackFn: (...args: any[]) =&gt; void) =&gt; 0;<br/>runLater((a, b) =&gt; { });<br/>runLater((a, b, c) =&gt; { });</span></pre><p id="c31f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们可以将任何函数作为回调函数传入，因为我们使用了rest操作来指定我们可以在回调函数中传入任意数量的参数，并将其传递给<code class="fe nb nc nd ne b">runLater</code>函数。带有rest参数的函数被视为具有无限个参数。这是可以的，因为不向函数传递任何东西与在JavaScript中传递<code class="fe nb nc nd ne b">undefined</code>是一样的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c3cf" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">重载函数</h1><p id="928e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在同名函数有多个签名的情况下，函数重载必须具有与至少一个签名匹配的参数，TypeScript才能接受有效的函数调用。例如，如果我们有以下函数重载:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="4f3c" class="nj lh it ne b gy nk nl l nm nn">function fn(a: { b: number, c: string, d: boolean }): number<br/>function fn(a: { b: number, c: string }): number<br/>function fn(a: any): number {<br/>  return a.b;<br/>};</span></pre><p id="6f11" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后我们必须调用<code class="fe nb nc nd ne b">fn</code>函数，为第一个参数传入一个数字，为第二个参数传入一个字符串:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e24d" class="nj lh it ne b gy nk nl l nm nn">fn({ b: 1, c: 'a' });</span></pre><p id="a886" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">TypeScript将检查每个签名，以查看我们作为参数传入的对象的属性结构是否与任何重载匹配。如果不匹配，我们有以下内容:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="8642" class="nj lh it ne b gy nk nl l nm nn">fn({ b: 1 });</span></pre><p id="3d08" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后我们得到以下错误消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/387b9caa9ec6cb7d31b4eaabd644064e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zp65J64nHpXtIeHd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emmamatthews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Emma Matthews数字内容制作</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="40fc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">枚举</h1><p id="fe27" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在TypeScript中，枚举被认为与数字兼容，反之亦然。但是，不同枚举类型的枚举值被认为是不兼容的。例如，如果我们有:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="2ef7" class="nj lh it ne b gy nk nl l nm nn">enum Fruit { Orange, Apple };<br/>enum Bird { Chicken, Duck, Goose };</span><span id="51f3" class="nj lh it ne b gy np nl l nm nn">let fruit = Fruit.Orange;<br/>fruit = Bird.Chicken;</span></pre><p id="d3c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后在最后一行，我们会得到错误消息:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="2940" class="nj lh it ne b gy nk nl l nm nn">Type 'Bird.Chicken' is not assignable to type 'Fruit'.(2322)</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f184" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">班级</h1><p id="1d5c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">类的类型兼容性类似于对象文字类型。但是，只检查每个类的实例成员的兼容性。静态成员在类型兼容性检查中被忽略。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f7a0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那么代码将被TypeScript编译器接受，因为<code class="fe nb nc nd ne b">animal</code>和<code class="fe nb nc nd ne b">person</code>被认为是具有兼容类型的变量。当TypeScript编译器检查类型兼容性时，类似于<code class="fe nb nc nd ne b">constructor</code>和<code class="fe nb nc nd ne b">getNumPersons</code>方法的静态成员将被忽略。</p><p id="c2af" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当私有和受保护成员包含在一个类中时，在类型兼容性检查期间会对它们进行检查。例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3456" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那么TypeScript将拒绝代码，并显示以下错误:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c90b" class="nj lh it ne b gy nk nl l nm nn">Property 'age' is missing in type 'Person' but required in type 'Animal'.(2741)</span><span id="f9e9" class="nj lh it ne b gy np nl l nm nn">input.ts(3, 11): 'age' is declared here.</span></pre><p id="14a8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果两个类的私有成员都是从同一个源派生的，TypeScript将只接受代码。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dedd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，当我们试图编译代码时，TypeScript编译器将接受它，因为私有成员<code class="fe nb nc nd ne b">age</code>在<code class="fe nb nc nd ne b">Animal</code>类中，而<code class="fe nb nc nd ne b">Dog</code>和<code class="fe nb nc nd ne b">Cat</code>类是它的子类。这也适用于受保护的成员。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5d75" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">无商标消费品</h1><p id="e046" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">泛型的类型兼容性检查也是从其结构中派生出来的。例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="59a6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那么它们是兼容的，因为<code class="fe nb nc nd ne b">x</code>和<code class="fe nb nc nd ne b">y</code>都是<code class="fe nb nc nd ne b">Person</code>类型，我们没有在接口的任何成员中引用泛型类型标记。然而，如果我们在<code class="fe nb nc nd ne b">Person</code>接口中引用一个成员，正如我们在下面的代码中所做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="edca" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那么我们传递给<code class="fe nb nc nd ne b">&lt;&gt;</code>的类型确实很重要，因为我们用它来确定<code class="fe nb nc nd ne b">age</code>的类型。如果我们尝试编译上面的代码，我们会得到错误:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="6fc9" class="nj lh it ne b gy nk nl l nm nn">Type 'Person&lt;string&gt;' is not assignable to type 'Person&lt;number&gt;'.</span><span id="b71c" class="nj lh it ne b gy np nl l nm nn">Type 'string' is not assignable to type 'number'.(2322)</span></pre><p id="8878" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了使它们被认为是兼容的类型，我们传入的类型必须在两个变量声明中相同，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="50b6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="ebf7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在TypeScript代码中，我们可以传入比参数指定的类型更特殊的类型的参数，以保持与JavaScript的兼容性。</p><p id="3c30" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于具有重载的函数，我们传入的参数必须与函数重载中声明的参数类型相匹配。对于类，在确定两个类是否属于兼容类型时，只考虑实例成员。这适用于公共成员。对于私有和受保护的成员，它们必须从同一个超类派生，这样两个类才能被确定为具有兼容的类型。枚举与数字兼容，反之亦然，但是来自两个不同枚举的枚举值互不兼容。通过遵循与对象、函数和类相同的规则，泛型被认为是相互兼容的。与任何其他代码一样，传递给泛型的类型将被视为类型兼容。</p></div></div>    
</body>
</html>