<html>
<head>
<title>What is Component-Oriented Programming (COP)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是面向组件编程(COP)？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-component-oriented-programming-cop-10b32ae1fa1c?source=collection_archive---------1-----------------------#2019-09-13">https://betterprogramming.pub/what-is-component-oriented-programming-cop-10b32ae1fa1c?source=collection_archive---------1-----------------------#2019-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7776" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向组件编程是新的面向对象编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25b725696d9114e1b7bd19b074157957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LTnhw1i-rbFrT3_R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danielkorpai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·科尔派</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="ee63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了所有最新的前端框架——比如React、Angular和Vue——我们看到一个很酷的新范式正在崛起。它被称为面向组件的编程，它就是像乐高积木一样将可重用的组件拼接在一起。</p><p id="69d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其核心，面向组件的架构信奉不要重复你自己(干)的教条。重复代码是浪费时间和效率。我们花在重复自己身上的时间越少，我们构建应用程序的速度就越快。作为软件工程师，我们有时会设定最后期限，利用任何优势在满足我们的上司方面都是至关重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">面向组件的编程是什么样子的</h1><p id="bcb2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你知道任何现代前端框架，比如React、Angular或Vue，你可能已经知道基于组件的架构是什么样子了。下面是一个<code class="fe mz na nb nc b">Header</code>组件的基本例子:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f399" class="nh md it nc b gy ni nj l nk nl">import React from 'react';<br/>import { Logo, ProfileImage, BurgerMenu, HeaderWrapper } from 'components';<br/><br/>const Header = () =&gt; (<br/>  &lt;HeaderWrapper&gt;<br/>    &lt;Logo&gt;&lt;/Logo&gt;<br/>    &lt;ProfileImage&gt;&lt;/ProfileImage&gt;<br/>    &lt;BurgerMenu&gt;&lt;/BurgerMenu&gt;<br/>  &lt;/HeaderWrapper&gt;<br/>)<br/><br/>export default Header;</span></pre><p id="52f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们正在导入组件、合成并像砌砖一样铺设它们，以修改应用程序的一部分——在本例中为标题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="144f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">面向组件编程解决的问题</h1><p id="a4f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">COP <em class="nm"> </em>是一个强大的概念，因为它让我们隔离和封装逻辑。我们的文件越小，就越容易维护——就这么简单。脸书有一个很好的理由去创新和修复他们著名的通知错误。</p><p id="08cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到大约2014年至2015年，通知会不断指示您有新通知，但当您点击红色通知铃时，它不会显示任何新通知。这在互联网上引发了愤怒。错误的原因是不可维护的，大量的文件和杂乱的PHP代码。我不是想抨击PHP。我认为这很实用，也是让事情起步的好方法。用任何语言都有可能写出意大利面条式的代码——在这种情况下，可怜的罪魁祸首恰好是PHP。</p><p id="6d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发明React是为了解决这个特殊的通知问题，这个库的诞生标志着一个新时代的开始。那个时代被称为面向组件编程(COP)。</p><p id="273c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对未来的预测是完全的本地web组件。到目前为止，每个框架都有自己的工具、组件、库等生态系统。虽然重用开源代码很方便，但不酷的是每个生态系统都把自己锁在了一个泡泡里。如果你知道React，你只能使用React版本的代码。你不能用有棱角的工具来搭配Vue或Svelte。原生Web组件API将改变这一切。</p><p id="5b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想如果我们能在所有图书馆之间共享的可能性。</p><p id="1e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">证据A:有人写了一个很棒的动画库，它可以作为库与所有框架兼容，只要它是用JavaScript写的，或者被编译成JavaScript。这正是原生Web组件API的目标:所有库共享代码的统一方式。如果你想了解更多关于Web组件API的知识，请阅读这篇文章。</p><div class="nn no gp gr np nq"><a href="https://medium.com/better-programming/web-components-api-in-a-nutshell-c409127d563a" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">简而言之，Web组件API</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">本机Web组件API的内容和原因</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><h1 id="a100" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">Web组件API</h1><p id="1c72" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很快，我们将为所有JavaScript库和框架提供一个统一的API来共享代码。您只需编写一次代码，就可以在任何地方重复使用。Web组件API让我们完成所有这些工作。这是一个使用Web组件API的简单按钮的外观:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0990" class="nh md it nc b gy ni nj l nk nl">class WebComponentButton extends HTMLElement {<br/><br/>  constructor() {<br/>    super()<br/>    this.addEventListener('click', () =&gt; {<br/>      console.log('click')<br/>    })<br/>  }<br/> <br/>}</span></pre><p id="023f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web组件是一段简单的基于类的继承代码。注意我们是如何扩展按钮来继承<code class="fe mz na nb nc b">HTMLElement</code>类的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2151f531c8e932d5fc1daa09b92b5673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBEVt6rSt9GP6RcuO2kpWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">html element—<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/html element</a></p></figure><p id="74b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你很好奇，想了解更多关于web组件的知识，请查阅Mozilla文档。Mozilla在web组件方面写得很好。</p><div class="nn no gp gr np nq"><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">Web组件</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">作为开发人员，我们都知道尽可能多地重用代码是一个好主意。传统上不是这样的…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">developer.mozilla.org</p></div></div><div class="nz l"><div class="ol l ob oc od nz oe ks nq"/></div></div></a></div><p id="b72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次当您考虑解决一个问题时，尝试用基于组件的架构思维和解决方案来处理它。随着复杂性的增加，基于组件的架构确实大放异彩。挑战越大，你就越应该把它分成小块。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d02f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对Web组件API的浏览器支持</h1><p id="ea34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">API正在获得关注和支持。请记住，这是一项相对实验性的技术，没有人知道它将在何时以及如何被标准化，但是了解最新、最酷的编程相关技术总是好的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/636620d36931c5fc12ba4c8286b66798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thlgof55Qp3lX7Lb3Lt9XQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://caniuse.com/#search=web%20components" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/#search=web%20components</a></p></figure><p id="ff7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要担心，你还不需要学习另一种API或技术。JavaScript人口统计的情况变化很快，但是用更方便的工具来扩展您的工具箱并没有坏处。</p><p id="6b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是JavaScript新手，想学习这门语言，我建议你从阅读书籍和构建东西开始。从《<a class="ae ky" href="https://amzn.to/2LOkzjj" rel="noopener ugc nofollow" target="_blank"> <em class="nm">一个更聪明的学习JavaScript的方法</em> </a>》和<a class="ae ky" href="https://medium.com/better-programming/the-secret-to-being-a-top-developer-is-building-things-heres-a-list-of-fun-apps-to-build-aac61ac0736c" rel="noopener">这本书开始吧，这里有一个要构建的有趣应用的列表</a>。</p><p id="53ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，保持敬畏。编码快乐！</p></div></div>    
</body>
</html>