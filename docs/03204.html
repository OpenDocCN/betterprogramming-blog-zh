<html>
<head>
<title>4 Ways to Replace “Any” in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">替换TypeScript中“Any”的4种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-ways-to-replace-any-in-typescript-5470b8d8357d?source=collection_archive---------5-----------------------#2020-01-28">https://betterprogramming.pub/4-ways-to-replace-any-in-typescript-5470b8d8357d?source=collection_archive---------5-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9046" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">替换any关键字以受益于强类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bf33f7f5a9a88a2fe3a3ed94c70b537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IAmeG0xAQnORsQig"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yogidan2012?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·莱维斯·佩鲁西</a>在<a class="ae ky" href="https://unsplash.com/s/photos/confusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="ec1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适应TypeScript可能需要一段时间，尤其是如果您来自弱类型背景，比如JavaScript。</p><p id="1690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在寻找灵活性的时候，一个简单的方法就是选择退出斗争，使用<code class="fe lv lw lx ly b">any</code> <em class="lz"> </em>关键词。有时，也许它实际上可能是(几乎)正确的选择，但通常情况下，可以避免使用<code class="fe lv lw lx ly b">any</code>关键字，用更合适的类型来代替。</p><p id="ff19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标应该始终是在编译时生成错误，而不是让它们在运行时发生。使用TypeScript，我们可以遵从<a class="ae ky" href="https://medium.com/@christian.ppl/introduction-to-the-fail-fast-principle-in-software-development-865ccab28979" rel="noopener">快速失效原则</a>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e20c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">联合类型</strong></h1><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您遇到的最基本的用例之一是，当您编写一个接受多种类型的函数时，它会诱使您使用任何一种类型。</p><p id="18fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，您正在编写一个设置元素宽度的函数。您希望这个宽度要么作为一个以单位结尾的字符串(例如px)提供，要么您的函数可以接受一个数字。</p><p id="f2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为你的函数接受的参数类型是多种类型中的一种，你可能会错误地使用<code class="fe lv lw lx ly b">any</code>，它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/0b096180bd7a6d058adfeb90b86b7768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hptm1UAPgILn1bCRUbO0A.png"/></div></div></figure><p id="fd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这对我们的类型安全没有帮助，<em class="lz">任何</em>东西都可以传递给函数。</p><p id="85b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是工会类型来救援！</p><p id="b187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用竖线，我们可以组合不同的类型，在我们的<code class="fe lv lw lx ly b">typeof</code>检查(类型保护)之后，TypeScript自动检测到我们现在分别在处理一个字符串或一个数字。这也给我们带来了自动完成和其他智能感知特性的好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a4dc9ad21e5d9e8c2ddbd21f28f423bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_jhooRBSowkwgRa0lOk0A.png"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2738" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">处理数组</strong></h1><p id="9a2e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">考虑下面的函数，它接受一个数组并将每一项映射到它的长度。数组中的元素可以是字符串或其他数组，但是数字会在运行时导致错误，因为它们没有长度属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/21a18ec39631a13b6ed582e16b12a125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*5nIJXD3RmGMeK0gEBWDaTg.png"/></div></figure><p id="c432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何改进这个例子，摆脱<code class="fe lv lw lx ly b">any</code>类型呢？我们唯一的标准是我们的<code class="fe lv lw lx ly b">array</code>参数是一个包含长度属性元素的数组。</p><p id="9f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的对象可以有其他属性，但是Typescript只允许我们检查对象的一部分。我们只要求<code class="fe lv lw lx ly b">array</code>是一个列表，但是每个条目至少包含一个number类型的长度属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ebe956cf0546629b3bb19c9c50fd20f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*7Vb-M0xKXQNIGpxwkaMHdA.png"/></div></figure><p id="d130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这立即使我们的代码不仅更健壮，而且更清晰。</p><p id="d040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果开发人员阅读了我们的代码或者想要使用我们的函数，他们将能够理解数组的元素必须是包含长度属性的类型。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0ad6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">使用泛型</strong></h1><p id="8d32" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">但是，如果我们有一个函数，它接受任何类型的元素数组，并将它们包装到一个包含它们在数组中的索引的对象中，那会怎么样呢？使用<code class="fe lv lw lx ly b">any</code>，它可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/67d14b2d257c81c936db376966f30629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjOIwVv9j6i9EpWwwSatVg.png"/></div></div></figure><p id="9dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，问题变得很明显:因为我们正在使用<code class="fe lv lw lx ly b">any</code>，在调用函数之后，我们丢失了输入信息。</p><p id="9506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这一次，我们真的不在乎我们的函数收到了什么，而是不想返回<code class="fe lv lw lx ly b">any</code>。使用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">类型脚本泛型</a>我们可以克服这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/df6cfe75e6857f54f4125e41a799d707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*jE0sLu6GNVuLGJLGqAxtgg.png"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e99c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">未知笼罩何</strong></h1><p id="102d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您发现自己处于上述提示不适合您的用例的情况，您仍然不应该使用<code class="fe lv lw lx ly b">any</code>！类型<code class="fe lv lw lx ly b">unknown</code>及其好处经常被忽视。</p><p id="c6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">any</code>的问题在于它允许我们做任何我们想做的操作。<code class="fe lv lw lx ly b">unknown</code>是类型安全的对应物，它强制开发人员在使用前添加检查(类型保护)或强制转换变量。</p><p id="3ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些典型的检查包括<code class="fe lv lw lx ly b">instanceof</code>和<code class="fe lv lw lx ly b">typeof</code>操作符。处理<code class="fe lv lw lx ly b">unknown</code>或union类型的另一种优雅的方式是利用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" rel="noopener ugc nofollow" target="_blank">用户定义的类型保护</a>，这在本文中没有进一步讨论。</p><p id="a260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，下面的代码在编译时会给你一个错误，但是只有当你使用<code class="fe lv lw lx ly b">unknown</code>而不是<code class="fe lv lw lx ly b">any</code>时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/6a6134a0c11e8da93a5c9fb78492d893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiY1wlwqFZdt0KTFRwPDNA.png"/></div></div></figure><p id="8a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章能让你在以后的项目中摆脱<code class="fe lv lw lx ly b">any</code>类型，享受更多的类型安全。感谢阅读！</p><p id="4ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的例子都可以在这个<a class="ae ky" href="https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZwKZQKIBtUFtVhQDqMAJlABYAUA7mZQFyICGYAngJSIDeAUIgMQxgiKlDYAHVHBF1yFRAF5liAETIoAJxhgA5qsQAyQ4jmUAdAVLISlKqokAPVRy59BHxAHoviUnEQsOF0YCH5BAF9wgVQsNCERMUlpWXoFZUU1MBBcACNUTRceaM8fPwCgkLCPKI9Y+PdPAUpNOBpEMFR2jE1WzXsASSwcXWYsFk1dHIIoRE1UCFQYADdUUhcAbhKoqN4yjEdFiVgEJiGRsYmp-EI5haXV0hZZzXBYfF40TBwb4jSqbgoOD4ADyuQAVgsoEx1MDUAA1MYgVAGCIcLa8UCQE5IL7YPAzEjyAAqyVItDSTA02j0iAAPh0cvlNG4SsJROIpDJTGklCp1FodPojCYzBRLGBrLZqA5nK5ik0BGV-IFgqFtiV6qgEhzktyxXzMqpsnkCkVGk1lRU1dVIpq4tqLZ4Wm0Ol1ED0+oNhqhRuNmJNprd5osVmtNhrdvtDqhjvAwGcfX6rkGXvcw09mLMIMCJDAcIh3qhPuh8b8iZRSVJyYDkHCwZDoDC6-hEVhkaj0bxMeBoPHELhmBJiXAyzMADIEXR2AOaZhsJisNgAbQAuhwmCbmWuFYJ5lAQJokLP5+ZBxIqNrFAA+RCocw4PSULu7c8jseESdP6jL1SUGDIKoAA0ag0HAmgANbIAAhKo65bG+o4-BOU52L+-6ASBqhgZBMHAYgy4AMwgQArCBADsq7wbwiEflAX7Tj+f4UAB+GqBAc7IBQqCYWoWaIAASgAqgAcsSAwALIYLBpHUT22L9rRyGfqhFBVmsVAnguPCBKpm5MgUiARGuG6Mqamg7k6+6HsevSnuel5KLe96PoxL7dkpBIqd+6nkuhLG8dh4FQbB1Geb8DGVmSVD+axWE4SF+FEaRFFUV2ZTqYgADkW4FFlQjIB0cCzMwyDIDAuhgMwuQFlAASctqWWAq5jBmcyGxGVlNFDu+yn0apvkxcxcVqBxpXcYF-EAMIghJAAKAzjhgiDiVJMmICRcnyX2CB3mA2gQBQ0oDJKqCOJpdnaUuJlMICOikGd+nmSByxIqgi7sEZlklNZR4THObBnkOVCXiB91nVwN6iICr3tu9d5g6djhGa4Wy7DmYAaHcyAgFgsyZAQB1HTAlAnQ952-txbBsZQBQovFFBZoVIASHBXYY3WOAPsEVDzDjePLgADKu5iw8i5hgMVBwAbAegSegFBwOSqPeL4AAicA8UVswFH0zyIDmuB5rVMD4NB3ZYjtSCE6ExOk0jvkADzEteF0A0wxI3Tp4OOE9zIvW9Htfauu4CL9tkA0DF6g0ISOQ7eAKIGL8OoIj5Mo+5vAc2m-NQAATEoe1E8dDvRZTqDU1htPzGxNCM1AzOs9RZRza0UiaOI2WS5gjgy0K8uUEr+X+Fr3d3r3WO7Q12XUkKWXmFnCCcy5PN87j+dCyLycS1LE+y7oA+K8r6JAA" rel="noopener ugc nofollow" target="_blank"> TypeScript Playground </a>中找到。</p></div></div>    
</body>
</html>