<html>
<head>
<title>Derivatives of Regular Expressions Explained Using Pac-Man</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pac-Man解释正则表达式的导数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-take-the-derivative-of-a-regular-expression-explained-2e7cea15028d?source=collection_archive---------7-----------------------#2022-09-19">https://betterprogramming.pub/how-to-take-the-derivative-of-a-regular-expression-explained-2e7cea15028d?source=collection_archive---------7-----------------------#2022-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="602a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释函数正则表达式匹配算法的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3279bccf72c2ed1945f2fb5783a9a6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*gvfrjSzIvn4qtiUm3m0UeA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片|吃豆人的幽灵和樱桃</p></figure><p id="2c39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">吃红樱桃让你有吃蓝鬼的能力。导数可以用来创建正则表达式匹配算法的想法几乎同样荒谬。让我解释一下这个算法是如何工作的，以及它与吃豆人的关系。</p><p id="19f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1964年，Brzozowski发表了第一篇关于正则表达式导数的论文。这是迄今为止我最喜欢的算法之一。使用正则表达式的导数，我们可以实现一个算法来进行正则表达式匹配。这个算法非常:</p><ul class=""><li id="993d" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">简单的</li><li id="95d9" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">功能的</li><li id="cb00" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">使用您自己的运营商可以轻松扩展</li></ul><p id="1c38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这也是向您介绍其他函数概念的好方法，比如记忆化、智能构造函数、懒惰和不动点。它甚至可以扩展到处理上下文无关的语法、树和一般列表的匹配。</p><p id="2290" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示如何仅使用两个纯函数和一些Pac-Man类比，用正则表达式匹配字符串。如果您愿意，您可以观看以下视频，而不是阅读文章，因为它涵盖了相同的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="74b3" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">正则表达式概述</h1><p id="90d1" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">首先，让我们快速回顾一下正则表达式，以确保我们在同一页上。表达式<code class="fe nb nc nd ne b">a(a|b)*</code>匹配以<code class="fe nb nc nd ne b">a</code>开头的字符串，后面是任意数量的<code class="fe nb nc nd ne b">a</code>和<code class="fe nb nc nd ne b">b</code></p><ul class=""><li id="b235" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">字符串<code class="fe nb nc nd ne b">ab</code>将匹配<code class="fe nb nc nd ne b">a(a|b)*</code>。我们将用可食用的蓝色幽灵来表示这一点。</li><li id="2f83" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">字符串<code class="fe nb nc nd ne b">aabbba</code>也匹配<code class="fe nb nc nd ne b">a(a|b)*</code>，因为它以<code class="fe nb nc nd ne b">a</code>开始，后面跟着几个<code class="fe nb nc nd ne b">a</code>和<code class="fe nb nc nd ne b">b</code>。</li><li id="168a" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">接下来，字符串<code class="fe nb nc nd ne b">ac</code>与<code class="fe nb nc nd ne b">a(a|b)*</code>不匹配，因为正则表达式与任何<code class="fe nb nc nd ne b">c</code>都不匹配，而我们的正则表达式不进行任何子字符串匹配。我们将用追逐吃豆人的红色幽灵来表示这一点。</li><li id="6c5e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">最后，字符串<code class="fe nb nc nd ne b">ba</code>也与<code class="fe nb nc nd ne b">a(a|b)*</code>不匹配，因为它不是以<code class="fe nb nc nd ne b">a</code>开头的。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0aa75dcc171056de49dac497794cdb4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*8KciDeiFnWPHBI9fmnJcnA.png"/></div></figure><p id="99a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们快速回顾一下算法。</p><h1 id="e714" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">算法概述</h1><p id="68cc" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">在深入研究细节之前，让我们先了解一下这个算法是如何工作的。我设计了一个奇怪的吃豆人游戏，在这个游戏中，如果你按照与正则表达式相匹配的顺序吃水果，你就只能吃到鬼魂。我们的Pac-Man代表regex <code class="fe nb nc nd ne b">aba*</code>。它有以下一串水果可以吃:一个苹果，然后是一个香蕉，然后是一个苹果:<code class="fe nb nc nd ne b">aba</code>。</p><ol class=""><li id="b9c4" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated">当我们开始的时候，幽灵在追我们，我们剩下来匹配的正则表达式是<code class="fe nb nc nd ne b">aba*</code>。</li><li id="ac85" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">我们吃第一个苹果，我们现在剩下来匹配的正则表达式是<code class="fe nb nc nd ne b">ba*</code>。鬼魂仍然在追我们，因为我们到目前为止吃的水果，苹果，与正则表达式不匹配。</li><li id="1acb" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">接下来，我们吃香蕉。我们剩下要匹配的正则表达式是<code class="fe nb nc nd ne b">a*</code>。现在鬼魂开始逃跑，因为从技术上来说，<code class="fe nb nc nd ne b">ab</code>已经和<code class="fe nb nc nd ne b">aba*</code>匹配了。</li><li id="025d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">我们可以尝试吃掉幽灵或者再吃一个苹果，在这种情况下，我们剩下来匹配的正则表达式仍然是<code class="fe nb nc nd ne b">a*</code>。由于<code class="fe nb nc nd ne b">aba</code>也匹配正则表达式<code class="fe nb nc nd ne b">aba*</code>，幽灵仍然在逃跑。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/321c7a9d8f5983792989492bf569575c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QSSBeM2FyvxO4AgPT4o6Nw.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Pac-Main吃苹果、香蕉和另一个苹果的动画</p></figure><p id="5e16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分析一下这里发生了什么。吃水果的吃豆人代表了导数函数。这意味着<code class="fe nb nc nd ne b">aba*</code>相对于<code class="fe nb nc nd ne b">a</code>的导数是<code class="fe nb nc nd ne b">ba*</code>。导数函数接受一个正则表达式和一个字符，并返回剩下要匹配的正则表达式。吃完苹果剩下来配的正则表达式是<code class="fe nb nc nd ne b">ba*</code>。这也意味着<code class="fe nb nc nd ne b">ba*</code>相对于<code class="fe nb nc nd ne b">b</code>的导数是<code class="fe nb nc nd ne b">a*</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/6882cd3359bb48f859447a7839f8247f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blLxr_eBkdD5JWR9-YsEwA.png"/></div></div></figure><p id="8db8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里还有一个功能在起作用。该函数检查幽灵是否正在追逐Pac-Man，或者Pac-Man是否已经匹配正则表达式并正在追逐幽灵。这个函数称为可空函数；它检查剩下要匹配的正则表达式是否与空字符串匹配。它可以这样做，因为如果剩下的正则表达式匹配空字符串，它吃的水果一定已经足够满足正则表达式了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/88e2bfdb04ed5df758fddc86ed3067e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUpDbR_QN2YqRo-kym7ahQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">可空:匹配空字符串</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/d824d750f18c2d278153335a04c7bc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyVrEdryAkFX5BybNaTgyg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">不可为空:与空字符串不匹配</p></figure><h1 id="1d35" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">导数匹配算法</h1><p id="c31b" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">这意味着我们只需要两个函数来编写导数匹配算法:</p><ol class=""><li id="c13c" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated">导数函数</li><li id="1add" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">可空函数</li></ol><p id="0dc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们有了这些，我们可以循环输入字符串，吃掉所有的水果，并检查结果正则表达式是否与空字符串匹配。这里我们有两个实现。</p><p id="6491" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个在Golang，面向命令式程序员:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn md l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Golang中的导数匹配算法</p></figure><p id="9a80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Haskell中的另一个面向函数式程序员:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn md l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Haskell中的导数匹配算法</p></figure><p id="dcf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两个函数是等价的，只是用不同的编程风格编写。在Haskell代码中，<code class="fe nb nc nd ne b">foldl</code>在其他语言中也称为fold left或reduce，为您完成for循环的工作。还有，在Haskell中，我们不需要逗号来给函数传递参数；由于函数应用是函数式编程语言中最常见的操作，所以我们使用空格来分隔参数。</p><p id="e014" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们更深入地研究如何实现可空函数和导数函数。</p><h1 id="73a5" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">吃豆人起源故事题外话</h1><p id="236f" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">但在我们开始之前，我不知道你是否想过吃豆人起源的故事。我认为吃豆人没有掉进核废料桶，所以吃豆人获得了吃鬼的能力。逻辑就简单多了。</p><p id="7107" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">吃豆人是水果！当吃豆人吃其他水果时，吃豆人就是食人者。所以，如果你被鬼魂追赶，你必须吃些人肉，而鬼魂应该，至少暂时，开始逃离你。现在，我自己还没有尝试过，但是这个逻辑似乎是合理的。</p><p id="86a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就解释了为什么僵尸总是在追人类。正如大卫·爱登堡曾经说过的:</p><blockquote class="no np nq"><p id="82f3" class="kr ks nr kt b ku kv jr kw kx ky ju kz ns lb lc ld nt lf lg lh nu lj lk ll lm ij bi translated">“追赶我们的僵尸，他们自己也在被我们看不见的鬼魂追赶。僵尸吃了我们的一些人肉后，你会看到他们表现出对着空气大口大口的奇怪行为，这是僵尸在吃之前追赶它的鬼魂。”</p></blockquote><h1 id="43d0" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">基本运算符</h1><p id="4dd2" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">可空函数和导数函数的实现要求我们首先定义正则表达式中可用的基本操作符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/4bd4ae7649ebd10c79ebb2f329b32edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vH1VHNT1ilPmAAqdn4tWzQ.png"/></div></div></figure><p id="cba6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以把正则表达式想象成描述一组字符串。</p><ul class=""><li id="74e0" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">这意味着空集表示不匹配任何字符串的运算符。</li><li id="a95e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">空字符串表示只匹配空字符串的单个字符串的单例集。</li><li id="20da" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">该字符还表示只匹配单个字符<code class="fe nb nc nd ne b">a</code>的单例集。</li><li id="eb1c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">然后，我们可以使用运算符来组合这些基本正则表达式，例如:<code class="fe nb nc nd ne b">or</code>、<code class="fe nb nc nd ne b">concatenation</code>和<code class="fe nb nc nd ne b">Kleene star</code>，其中<code class="fe nb nc nd ne b">r</code>和<code class="fe nb nc nd ne b">s</code>表示我们要组合的两个正则表达式。</li></ul><p id="ab15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经定义了正则表达式数据类型，我们可以看看如何实现使用该数据类型作为输入的两个函数。</p><h1 id="5bb5" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">可空函数</h1><p id="2c09" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">我们可以从可空函数开始。让我们看一些例子，找出这些正则表达式中的哪一个与空字符串匹配，以深入了解这个函数是如何实现的。</p><ul class=""><li id="5768" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">a*</code>匹配空字符串，因为零或更多包括零。</li><li id="8c37" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">(a*|b)</code>匹配空字符串，因为or的左侧匹配空字符串。</li><li id="b0df" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">ab</code>不匹配空字符串，因为它只匹配字符串<code class="fe nb nc nd ne b">ab</code></li><li id="3504" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">ab*</code>也不匹配空字符串，因为<code class="fe nb nc nd ne b">ab*</code>需要一个以<code class="fe nb nc nd ne b">a</code>开头的字符串</li><li id="0ae5" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">(a|b)</code>不匹配空字符串，因为<code class="fe nb nc nd ne b">or</code>的左右两边都不匹配空字符串。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9af2454ab4780c985e3a72f86f535ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*OB1dd3cBtsouF4ggHpG7_A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">可空的例子</p></figure><p id="cb1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这些例子能让我们深入了解如何定义可空函数。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="f8a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是可空函数的实现。左边表示传入函数的值，右边表示在这种情况下函数的实现。红鬼代表假，蓝鬼代表真:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oe"><img src="../Images/29bf8399a16c952b03f2225f6e48eb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-8ql0fflVpEfi-dFL1VNg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">可空函数的实现</p></figure><ul class=""><li id="5171" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">空集不匹配空字符串，因为它不匹配任何字符串。</li><li id="6ecb" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">空字符串匹配空字符串，因为它只匹配空字符串。</li><li id="50dc" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">字符<code class="fe nb nc nd ne b">a</code>不匹配空字符串，因为它只匹配字符<code class="fe nb nc nd ne b">a</code>。</li><li id="ccc6" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">如果我们有一个逻辑<code class="fe nb nc nd ne b">or</code>，我们必须检查两边。如果任何一个匹配空字符串，那么逻辑<code class="fe nb nc nd ne b">or</code>匹配空字符串。</li><li id="7373" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">对于匹配空字符串的两个正则表达式的<code class="fe nb nc nd ne b">concatenation</code>,它们都必须匹配空字符串。</li><li id="a9d7" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">最后，如果我们有某个东西的<code class="fe nb nc nd ne b">zero or more</code>，那么它包括零，这意味着它总是匹配空字符串。</li></ul><p id="e518" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们通过函数运行一个例子。给定正则表达式<code class="fe nb nc nd ne b">(b | a*)</code>。</p><ol class=""><li id="9629" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated">我们的顶级操作符是<code class="fe nb nc nd ne b">or</code>，这意味着我们必须检查左右两边的可空性:<code class="fe nb nc nd ne b">b</code>和<code class="fe nb nc nd ne b">a*</code>。</li><li id="0f55" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">我们检查并看到左边的字符<code class="fe nb nc nd ne b">b</code>不可空:<code class="fe nb nc nd ne b">false</code>。</li><li id="918e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">然后我们检查并看到右边的<code class="fe nb nc nd ne b">a*</code>是可空的:<code class="fe nb nc nd ne b">true</code>。</li><li id="412a" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated">现在我们得到了<code class="fe nb nc nd ne b">false</code>和<code class="fe nb nc nd ne b">true</code>，我们可以<code class="fe nb nc nd ne b">or</code>它们来得到<code class="fe nb nc nd ne b">true</code>。</li></ol><p id="2ff8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以表达式<code class="fe nb nc nd ne b">(b|a*)</code>是可空的。这是有意义的，因为它将匹配空字符串。在我们继续学习导数函数之前，让我们再做一些练习:</p><h2 id="4104" class="of mf iq bd mg og oh dn mk oi oj dp mo la ok ol mq le om on ms li oo op mu oq bi translated">无效练习</h2><p id="ddea" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">尝试遍历实现并检查以下正则表达式是否可为空。你可以点击它们来检查你的答案:</p><ol class=""><li id="7a82" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/7594432f1d08e321ba9546520dc62bab" rel="noopener ugc nofollow" target="_blank">答</a></li><li id="4a13" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/5d1e049e99fff677ceee75ae19c1c723" rel="noopener ugc nofollow" target="_blank"> a*(b*|∅) </a></li><li id="204b" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/7f276c1d21cf8413263bd504512e3d09" rel="noopener ugc nofollow" target="_blank"> εa </a></li><li id="e900" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/b2d75d4211bfe1d15818939d4267cc0c" rel="noopener ugc nofollow" target="_blank"> ∅* </a></li><li id="3875" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/4584ac57670d425b223436b8ddfdc85a" rel="noopener ugc nofollow" target="_blank"> (∅|b)*(abc|ε) </a></li></ol><h1 id="46af" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">导数函数</h1><p id="f0c4" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">在我们看函数的实现之前，让我们看一下导数的例子。这里我们将对几个正则表达式求导，都是关于字符<code class="fe nb nc nd ne b">a</code>:</p><ul class=""><li id="9b07" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">a*</code>吃了一个<code class="fe nb nc nd ne b">a</code> pple之后剩下来匹配的正则表达式还是<code class="fe nb nc nd ne b">a*</code>。</li><li id="d877" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">ab*</code>相对于<code class="fe nb nc nd ne b">a</code>的导数是<code class="fe nb nc nd ne b">b*</code>，因为我们已经匹配了前缀<code class="fe nb nc nd ne b">a</code>。</li><li id="e46b" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">(a|b)b</code>相对于<code class="fe nb nc nd ne b">a</code>的导数为<code class="fe nb nc nd ne b">b</code>。</li><li id="83c9" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">b|(a*b)</code>相对于<code class="fe nb nc nd ne b">a</code>的导数为<code class="fe nb nc nd ne b">a*b</code>。左边的<code class="fe nb nc nd ne b">b</code>不匹配，所以我们可以扔掉它，而<code class="fe nb nc nd ne b">a</code>被右边的<code class="fe nb nc nd ne b">zero or more</code> <code class="fe nb nc nd ne b">a</code>消耗掉了。</li><li id="5f0f" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">接下来，我们有<code class="fe nb nc nd ne b">ab*</code>，这个稍微有点棘手。它吃完苹果后，剩下来匹配的正则表达式是<code class="fe nb nc nd ne b">b(ab)*</code>。由于我们只匹配了<code class="fe nb nc nd ne b">a</code>，我们期望至少再看到一个<code class="fe nb nc nd ne b">b</code>。</li></ul><p id="3d58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这些例子能给我们一些关于如何定义导函数的直觉。我们需要定义一个导数函数，它接受一个正则表达式，匹配一个字符，并返回一个新的正则表达式。这里我们定义了关于字符<code class="fe nb nc nd ne b">a</code>的导函数。左侧表示函数的输入，右侧表示函数的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi or"><img src="../Images/3cb32fd9b0421701ac01766e9c4aa775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diyoj9GJOSiSgskTtAidog.png"/></div></div></figure><ul class=""><li id="a5a9" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">空集的导数总是空集。因为空集不匹配任何内容，所以无法恢复。</li><li id="1c65" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">关于任何字符的空字符串的导数是空集。它并不期望匹配一个字符。它将只匹配空字符串。</li><li id="eaa8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">单个字符对一个相似字符(在本例中是<code class="fe nb nc nd ne b">a</code> pple)的派生是一个空字符串，因为在它匹配了自己之后，剩下要匹配的就是空字符串了。</li><li id="4a06" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">一个字符相对于不相等的另一个字符的导数，在这种情况下，<code class="fe nb nc nd ne b">b</code> anana，是空集，因为我们没有匹配特定的字符。</li><li id="3289" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">一个<code class="fe nb nc nd ne b">or</code>表达式的导数就是导数的<code class="fe nb nc nd ne b">or</code>。它只是把问题推给了它的孩子。</li><li id="cc7a" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">concat</code>表达式的导数要考虑是否可以跳过第一个表达式。只有当第一个表达式匹配空字符串并且可为空时，它才能跳过第一个表达式。所以我们要做的第一件事就是检查这个。让我们考虑这样一种情况，当表达式<code class="fe nb nc nd ne b">r</code>不可为空时，它不能跳过第一个表达式。那么导数就是第一个表达式<code class="fe nb nc nd ne b">concatenated</code>对第二个表达式<code class="fe nb nc nd ne b">s</code>的导数。如果我们可以跳过第一个正则表达式，我们必须考虑另一个表达式，它只是第二个表达式的衍生物。然后我们可以<code class="fe nb nc nd ne b">or</code>跳过<code class="fe nb nc nd ne b">r</code>和不跳过<code class="fe nb nc nd ne b">r</code>这两个选项，并返回结果。</li><li id="95b9" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">最后，我们有<code class="fe nb nc nd ne b">star</code>操作符。它匹配一个表达式零次或多次。因为我们被传递一个字符，这不是零的情况。所以我们不得不考虑<code class="fe nb nc nd ne b">one or more</code>的情况。这意味着我们必须对<code class="fe nb nc nd ne b">star</code>中的表达式求导，然后再用<code class="fe nb nc nd ne b">zero or more</code>表达式对<code class="fe nb nc nd ne b">concatenate</code>求导。</li></ul><p id="4643" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，我们可以将导数函数与可空函数结合起来，创建一个正则表达式匹配函数。完全掌握<code class="fe nb nc nd ne b">concatenation</code>和<code class="fe nb nc nd ne b">zero or more</code>规则需要一段时间。所以，我们来做一些例子。</p><h2 id="9d61" class="of mf iq bd mg og oh dn mk oi oj dp mo la ok ol mq le om on ms li oo op mu oq bi translated">衍生实例1</h2><p id="c719" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">让我们对<code class="fe nb nc nd ne b">(ab)*</code>相对于<code class="fe nb nc nd ne b">a</code>求导。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/cbd11a2c91a2f2bf748143d55505e0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv0GwVV-SWSUUrzmefP4Jw.png"/></div></div></figure><p id="7218" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd ne b">(ab)*</code>是一个<code class="fe nb nc nd ne b">zero or more</code>表达式，所以我们看一下<code class="fe nb nc nd ne b">zero or more</code>规则。我们看到这需要对<code class="fe nb nc nd ne b">star</code>中的表达式求导。</p><p id="06b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是<code class="fe nb nc nd ne b">a</code>和<code class="fe nb nc nd ne b">b</code>的<code class="fe nb nc nd ne b">concatenation</code>。所以我们检查左侧是否可空，字符<code class="fe nb nc nd ne b">a</code>不可空。这意味着我们不能跳过它。我们必须对<code class="fe nb nc nd ne b">a</code>相对于<code class="fe nb nc nd ne b">a</code>求导。但那是空字符串，所以如果我们用右边的空字符串<code class="fe nb nc nd ne b">concatenate</code>，也就是<code class="fe nb nc nd ne b">b</code>，我们得到<code class="fe nb nc nd ne b">b</code>。</p><p id="10e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们递归回到<code class="fe nb nc nd ne b">zero or more</code>，记住我们对<code class="fe nb nc nd ne b">ab</code>相对于<code class="fe nb nc nd ne b">a</code>求导，得到一个<code class="fe nb nc nd ne b">b</code>。现在我们可以把它和<code class="fe nb nc nd ne b">(ab)*</code>连接起来，得到<code class="fe nb nc nd ne b">b(ab)*</code>。</p><h2 id="267d" class="of mf iq bd mg og oh dn mk oi oj dp mo la ok ol mq le om on ms li oo op mu oq bi translated">衍生实例2</h2><p id="de7f" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">让我们对<code class="fe nb nc nd ne b">b</code>求导<code class="fe nb nc nd ne b">(a*ba)</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/e72d67df227aa93c6562fc5fadb4dcf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mteM5uFycQn2JuN6V2iTzg.png"/></div></div></figure><ul class=""><li id="85f3" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><code class="fe nb nc nd ne b">a*</code>与<code class="fe nb nc nd ne b">ba</code>连接在一起，所以我们来看看连接规则。</li><li id="ce01" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">我们检查左边的<code class="fe nb nc nd ne b">a*</code>是否可以为空，它确实可以为空。这意味着我们可以跳过它，也意味着我们必须创建两个导数的<code class="fe nb nc nd ne b">or</code>。</li><li id="01a5" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">左侧最终不匹配，因为<code class="fe nb nc nd ne b">a*</code>与<code class="fe nb nc nd ne b">b</code>不匹配。</li><li id="e93e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">幸运的是，我们还有一个选择<code class="fe nb nc nd ne b">ba</code>。<code class="fe nb nc nd ne b">ba</code>相对于<code class="fe nb nc nd ne b">b</code>的导数是和<code class="fe nb nc nd ne b">a</code>。</li></ul><p id="eff8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我们最后只有一个<code class="fe nb nc nd ne b">a</code>。</p><p id="f91d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里跳过了一些细节。把它当作一个练习，通过自己遍历函数来检查我的工作。</p><h2 id="dbc7" class="of mf iq bd mg og oh dn mk oi oj dp mo la ok ol mq le om on ms li oo op mu oq bi translated">衍生练习</h2><p id="1517" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">尝试遍历实现并检查以下正则表达式相对于<code class="fe nb nc nd ne b">b</code>的导数。你可以点击它们来检查你的答案:</p><ol class=""><li id="0235" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/05dd4dfa34726e8eb8870c931a322cf1" rel="noopener ugc nofollow" target="_blank"> εb </a></li><li id="d87f" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/ce715c85161ee9d149553a9cf2411860" rel="noopener ugc nofollow" target="_blank"> b*(b|c) </a></li><li id="22ee" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/ca6659f9babc8f9d656fe26d5ec764a2" rel="noopener ugc nofollow" target="_blank"> a*(b|c) </a></li><li id="b55e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/91c97349868b7dcdf85593e79db49691" rel="noopener ugc nofollow" target="_blank"> bεb </a></li><li id="bae1" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm ng lu lv lw bi translated"><a class="ae ln" href="https://gist.github.com/awalterschulze/0c23d9cc5a1174b923e5f55e388075d9" rel="noopener ugc nofollow" target="_blank"> ∅*b </a></li></ol><h1 id="7b6f" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="3fd5" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">我希望你现在明白为什么吃红樱桃会让你有能力吃蓝幽灵，以及如何使用导数算法实现一个正则表达式匹配器。</p><p id="0801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经在这里介绍了基本的工作算法，但是有很多方法可以通过很小的调整使这个算法变得更好。在这篇文章中，我们欺骗和掩饰了简化规则，使用它们而没有解释它们，如果你完成练习，这将变得特别明显。我们也没有讨论如何使用记忆化来构建一个高效的自动机。</p><p id="00da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以轻松地扩展该算法，以包括新的运算符，如，<code class="fe nb nc nd ne b">not</code>，<code class="fe nb nc nd ne b">interleave</code>，甚至支持上下文无关的语法。我将在下一篇文章中讨论其中的一些话题。</p><p id="49af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同时，我希望看到你用自己最熟悉的编程语言实现这个算法。请在评论中给我发一个链接。</p><h1 id="58c0" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">谢谢你</h1><ul class=""><li id="18b2" class="lo lp iq kt b ku mw kx mx la os le ot li ou lm lt lu lv lw bi translated">Brink van der Merwe 花时间向我解释这个算法。</li></ul><h1 id="eac7" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">参考</h1><ul class=""><li id="285b" class="lo lp iq kt b ku mw kx mx la os le ot li ou lm lt lu lv lw bi translated">“正则表达式的衍生物”美国计算机学会杂志(JACM)11.4(1964):481–494。</li><li id="b019" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/regularexpression-derivatives-reexamined/E5734B86DEB96C61C69E5CF3C4FB0AFA" rel="noopener ugc nofollow" target="_blank">欧文斯、斯科特、约翰·雷皮和亚伦·图伦。"正则表达式衍生工具重新检查."《函数编程杂志》19.2(2009):173–190。</a></li></ul></div></div>    
</body>
</html>