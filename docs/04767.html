<html>
<head>
<title>How to Create Custom Publishers in Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Combine中创建自定义发布者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-custom-publishers-in-combine-if-you-really-need-them-5bfab31b4ade?source=collection_archive---------6-----------------------#2020-05-07">https://betterprogramming.pub/how-to-create-custom-publishers-in-combine-if-you-really-need-them-5bfab31b4ade?source=collection_archive---------6-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b358" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你真的需要它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/98e406be25442d8d04955546bd202f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ThXiuh4_6pmSpn-vQ8llg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ninjason?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jason Leung </a>在<a class="ae kv" href="https://unsplash.com/s/photos/newspaper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在联合学习路径中看到的，发布者和订阅者相互合作，创建了一个强大的工具来交换应用程序内部的信息。</p><p id="393b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许框架提供的发布者对于你的工作来说已经足够了，但是定制发布者呢？有没有可能创建自定义的，如果有，怎么做？</p><p id="8b80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，它是，而且它并不像乍看起来那样复杂。首先，为了创建一个工作流，我们需要三样东西:</p><ol class=""><li id="fd04" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">出版者</li><li id="b3be" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">签署</li><li id="3a54" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">订户</li></ol><p id="1764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Combine，你看到的主要是发布者和订阅者——但是真正神奇的交流是通过<strong class="ky ir">订阅</strong>实现的。</p><p id="692c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，发布者创建了一个包含所有必需数据的订阅，并将其提供给订阅者。</p><p id="c87b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦订阅者接收到订阅并且实体之间的真实通信被创建，订阅就开始其引擎随时间处理值。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="16f3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">认购机制</strong></h1><p id="18d8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们看看这三个组件是如何工作的，以及它们之间是如何相互作用的。这将简化我们对定制发布者的理解，因为我们将清楚为了使异步通信工作需要什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/2b1e9820e38295cc00e1b9f9dc694f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADIAgZcK6xNNORagY-OHpw.png"/></div></div></figure><ol class=""><li id="ef94" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">订阅者订阅发布者。这通常通过<code class="fe nl nm nn no b">sink()</code>方法来完成，该方法允许程序员管理完成和发布者接收的值。</li><li id="51b8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">发布者创建订阅并将其传递给订阅者。订户通过<code class="fe nl nm nn no b">receive(subscription:)</code>方法接收订阅。</li><li id="6084" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">既然订阅者拥有订阅，并且它和发布者之间已经签订了合同，那么它可以向发布者请求值。这是通过调用<code class="fe nl nm nn no b">request(_:)</code>发送它想要的值的数量来完成的。</li><li id="5f4e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">订阅接收需求并开始处理信息和发出值。使用订户的<code class="fe nl nm nn no b">receive(_:) </code>方法逐个发送这些值，直到达到最大需求。</li><li id="c005" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">订阅者从订阅中接收值，作为响应，它发送一个新的<code class="fe nl nm nn no b">Demand</code>。注意，所发送的<code class="fe nl nm nn no b">Demand</code>在先前已经发送的请求的基础上增加了它想要接收的值的数量，因为所请求的值的数量可以增加或保持不变，但永远不会减少。</li><li id="e269" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一旦<code class="fe nl nm nn no b">Subscription</code>接收到<code class="fe nl nm nn no b">Demand</code>，它将再次开始整个处理过程，并发出值，直到满足需求。无限重复步骤4、5和6。</li></ol><p id="6b42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能已经注意到的，整个交流非常简单，一旦理解，实现定制发布者是一项可行的任务。</p><p id="7ddc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，实现发布者协议本身是不必要的，同样的目标可以通过其他方式实现:</p><ol class=""><li id="2d80" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">你可以使用一个<code class="fe nl nm nn no b">PassthroughSubject</code>，例如<code class="fe nl nm nn no b">Subject</code>的子类，通过调用它的<code class="fe nl nm nn no b"> send(_:)</code>方法来发布值</li><li id="983f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每当你更新主题的值时，使用一个<code class="fe nl nm nn no b">CurrentValueSubject</code>来发布。实际上，<code class="fe nl nm nn no b">CurrentValueSubject</code>是一个主题，它包装了一个值，并在值改变时发布一个新元素。</li><li id="9987" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在属性上使用<code class="fe nl nm nn no b">@Published</code>注释，以便属性获得一个发布者，该发布者在属性值改变时发出一个事件。这种方法在SwiftUI中被大量使用。</li></ol><p id="95bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要一个定制的publisher来满足您的需求，最简单的方法是创建一个Publisher名称空间的扩展。</p><p id="b238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试一试。</p><p id="2747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想要创建一个新的操作符，因为标准的操作符没有实现您需要的功能。举一个更具体的例子，假设您想要<a class="ae kv" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sample.swift" rel="noopener ugc nofollow" target="_blank">从RxSwift </a>中重新创建一个操作符，这是您可能知道的另一个Swift声明性框架。</p><p id="1ac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">操作符所做的是:获取两个发布者，合并它们，删除重复的，并发出输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最复杂的是方法签名，但是不要担心，它比你想象的要简单。首先，它返回一个<code class="fe nl nm nn no b">AnyPublisher</code>，其输出和失败类型与您正在处理的当前发布者相同。</p><p id="c545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示:使用AnyPublisher作为返回类型是一个很好的选择，因为当链接操作符时，很容易使签名变得复杂。</strong></p><p id="a4f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，因为必须比较两个发布者的输出，所以输出必须采用等价的协议。注意通用用法是如何应用的。我们想让它通用化；否则，运营商就失去了与任何类型的发行商合作的通用性。</p><p id="4239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数的主体很简单:我们将发布者与另一个作为参数传递的发布者组合起来，然后调用另外两个基本操作符:<code class="fe nl nm nn no b">removeDuplicates</code>和<code class="fe nl nm nn no b">map. eraseToAnyPublisher(_:)</code>方法允许操作符被转换为前面推荐的<code class="fe nl nm nn no b">AnyPublisher</code>。</p><p id="e405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看到这有多容易了吗？那么一个全新的出版商呢？</p><p id="ffbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让这个例子更清楚，如果你熟悉来自<code class="fe nl nm nn no b">URLSession</code>类的<code class="fe nl nm nn no b">dataTaskPublisher()</code>，我们将尝试重新创建同样的行为，创建一个新的发布者和一个新的订阅。</p><p id="5df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，您可以创建一个新的发布者，而不是一个新的订阅者，但是问题可能会出现，因为您失去了处理订阅者需求的能力，这使得联合生态系统的实现变得棘手。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9011" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">订阅</strong></h1><p id="ffc6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们从创建订阅开始，扩展<code class="fe nl nm nn no b">Publishers</code>枚举。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在订阅机制中看到的，订阅对象从<code class="fe nl nm nn no b">Publisher</code>传递到<code class="fe nl nm nn no b">Subscriber</code>等等。这个场景使类，而不是结构，更适合我们的需要，因为我们想通过引用传递它，而不是制作副本。</p><p id="f55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类签名中，我们根据标准<code class="fe nl nm nn no b">URLSession</code>方法返回的内容，指定<code class="fe nl nm nn no b">Input</code>类型为<code class="fe nl nm nn no b">Data</code>，指定失败为<code class="fe nl nm nn no b">Error</code>。</p><p id="59d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个<code class="fe nl nm nn no b">URLRequest</code>来处理(我们也可以使用一个URL并进行不同的实现)和一个订阅者，我们向其传递数据和收到的错误。</p><p id="b1dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个属性都是通过构造函数初始化的。当然，订阅者必须是可选的，因为，正如您可以想象的，它可以附加到订阅，也可以不附加，这取决于程序的当前状态。</p><p id="cc2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我们还需要cancel方法将订阅者置为零。</p><p id="49e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nl nm nn no b">sendRequest</code>中，奇迹发生了。我们在<code class="fe nl nm nn no b">URLSession</code>对象上调用普通的<code class="fe nl nm nn no b">dataTask</code>方法，并使用map函数将它绑定到订阅者。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4771" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">发布者</strong></h1><p id="2af7" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在是时候创建一个发布者了。出版商基本上是一个结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们采用了发布者协议之后，我们必须定义输出和失败，在我们的例子中是数据和错误。</p><p id="3497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义初始化器用于实例化URLRequest对象，该对象携带关于要联系的服务器和配置的信息。</p><p id="deec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">receive(subscriber:)</code>方法是<code class="fe nl nm nn no b">Publisher</code>的核心。首先，在签名中，我们必须检查失败和输出类型，以确保<code class="fe nl nm nn no b">Subscriber</code>符合<code class="fe nl nm nn no b">Publisher</code>类型。然后创建一个新的订阅并传递给订阅者，使订阅机制工作！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="150f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，为了确保订阅者能够从<code class="fe nl nm nn no b">DataPublisher</code>接收值，我们应该创建一个返回<code class="fe nl nm nn no b">DataPublisher</code>的方法，这样我们就可以应用例如<code class="fe nl nm nn no b">sink()</code>方法并对发布者发出的数据执行操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的用法可以是这样的。</p><p id="c514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然您已经了解了订阅机制的工作原理以及如何实现自定义发布器，那么您就可以用iOS生态系统中的其他组件来测试它了！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="0475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看本文中使用的所有代码，请访问以下页面:</p><p id="15f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/LoZimmero/CombinedTutorials/tree/master/CustomOperator.playground" rel="noopener ugc nofollow" target="_blank">custom operator . playground</a></p><p id="c709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/LoZimmero/CombinedTutorials/tree/master/CustomPublisher.playground" rel="noopener ugc nofollow" target="_blank">custom publisher . playground</a></p><p id="9486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想探索其他主题，请访问我们在GitHub上的资源库:</p><div class="nr ns gp gr nt nu"><a href="https://github.com/LoZimmero/CombinedTutorials" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">LoZimmero/联合教程</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在GitHub上创建一个帐户，为LoZimmero/CombinedTutorials的发展做出贡献。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div></div></div>    
</body>
</html>