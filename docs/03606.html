<html>
<head>
<title>An Introduction to Message Queues With RabbitMQ and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ和Python消息队列简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-message-queue-with-rabbitmq-python-639e397cb668?source=collection_archive---------0-----------------------#2020-02-21">https://betterprogramming.pub/introduction-to-message-queue-with-rabbitmq-python-639e397cb668?source=collection_archive---------0-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写您的第一个事件驱动工人</h2></div><p id="74cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章最初发表在我的个人博客上。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/fb2d6e118cfc94fef87da4dd44890769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vTSHfiykCX7c7g55"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@halgatewood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">首先，什么是消息队列？</h1><p id="9b85" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">消息队列(MQ)是编程和软件开发中的一个基本概念。在分布式系统中，消息队列是系统的主干。消息队列允许系统中服务/应用程序之间的进程间通信(例如，服务A可以与服务B对话)。</p><p id="f38b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MQ术语中，发出消息<strong class="kk iu"> <em class="mz"> </em> </strong>的服务被称为<em class="mz">生产者</em> <strong class="kk iu"> </strong>工作者，而监听消息并对消息做出反应的服务被称为<em class="mz">消费者</em> <strong class="kk iu"> </strong>工作者。这就是服务之间的通信方式。</p><p id="dcd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以根据生产者和消费者的工作量来增加或减少他们的数量。例如，您可能有两个生产者在两个虚拟机上运行，十个消费者在10个虚拟机上运行CPU密集型任务。您还可以在白天增加工作线程的数量，在晚上关闭工作线程(前提是您的应用程序流量是昼夜模式)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a4b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">想象一个没有消息队列的世界</h1><p id="76b7" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如果没有消息队列，您的系统将同步运行。尽管同步编程很容易实现，但对于最终用户体验来说并不方便。让我们举一个注册在线服务的例子。一旦你完成填写你的详细资料，并按下“注册”按钮，系统将向你发送一封电子邮件，并为你创建一个数据库行。假设你输入了一个错误的，无法到达的电子邮件地址。系统将在大约十秒钟后重试向您发送激活电子邮件。作为新用户，在你被重定向到下一页之前，你必须等待至少十秒钟，让系统完成发送电子邮件的尝试。这不是很糟糕的用户体验吗？等待对于一个web应用来说是非常重要的！</p><p id="0533" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的理想场景是:你按下“注册”<em class="mz"> </em>按钮，你被重定向到主页，你等待激活邮件到达你的收件箱。在这种情况下，您不必等待系统成功向您发送电子邮件。这是因为有一个邮件工作者正在使用MQ消息，等待向您发送电子邮件。作为新用户，在被重定向到下一个页面之前，您不必等待很长时间(10秒是一段很长的时间)。大家都很开心。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用类比理解消息队列</h1><p id="1476" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">当我第一次处理消息队列并且不知道它们是什么的时候，我的前团队经理<a class="ae le" href="https://www.linkedin.com/in/sianlerk/" rel="noopener ugc nofollow" target="_blank"> Sian Lerk </a>用这个绝妙的类比向我解释了这个概念。想象一下，你正在通过当地的邮政服务给你的母亲寄一封信。你要这么做:</p><ol class=""><li id="6f92" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">写这封信。</li><li id="d2bc" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">去最近的邮箱把信寄出去。</li><li id="3918" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">邮局人员将根据邮政编码对信件进行分类。</li><li id="cd39" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">邮递员会把信送给你妈妈。</li><li id="9e86" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">邮局证实这封信已成功投递。</li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/4671f4f8505be1b3edf6bf1553a88651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpBzyVJCyWIz4DR5OFHgbQ.png"/></div></div></figure><p id="ecb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来很自然，对吧？现在让我们看看消息队列(特别是RabbitMQ)是如何工作的:</p><ol class=""><li id="78e4" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">发布者工作人员构造消息(通常以JSON格式)。</li><li id="6b58" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">发布者工作器将消息发布到MQ交换。</li><li id="5568" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">MQ broker将根据预定义的路由规则将消息路由到指定的队列。</li><li id="66a1" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">该消息由消费者工作者消费和处理。</li><li id="a347" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">消费者通过消息队列确认消息已成功传递。</li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi np"><img src="../Images/c74977458583f38ba949d4bc3e7fba66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hx9Wy4bmu4Tp_jQniApZQw.png"/></div></div></figure><p id="bf2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，生产者工作人员会向消息代理发布一条JSON消息，如下所示:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="c90a" class="nv md it nr b gy nw nx l ny nz">{"action": "delete_user", "userId": "john_doe"}</span></pre><p id="2698" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">消费者将使用该消息并执行如下操作:</p><ul class=""><li id="5596" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld oa ng nh ni bi translated">删除数据库中的用户数据</li><li id="637a" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">从S3对象存储中删除他们的资产</li><li id="c160" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">向用户发送告别电子邮件</li><li id="d014" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">多得多…</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f37b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RabbitMQ简介</h1><p id="dfe5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">RabbitMQ是由Pivotal Software开发的一个开源消息代理，它提供了我们在上一节中看到的内容。它使用AMQP进行服务间的通信。你可以在维基百科上阅读更多关于RabbitMQ <a class="ae le" href="https://en.wikipedia.org/wiki/RabbitMQ" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="2e57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">市场上有许多RabbitMQ的替代品。开源解决方案包括ActiveMQ、ZeroMQ、Redis、NATS和KubeMQ。还有由主要云提供商提供的托管消息队列解决方案:托管AWS MQ服务以及专有队列解决方案，如AWS SQS和GCP发布/订阅。</p><h2 id="81fd" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">这个什么时候有用？</h2><p id="cd0d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">消息队列的好处如下:</p><ul class=""><li id="04a7" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld oa ng nh ni bi translated"><strong class="kk iu">消息可以按正确的顺序传递。</strong>这对于一个实体的状态改变来说是很棒的。例如，用户错误地将他的生日列为7月17日。然后同一个用户更新他的生日为7月18日。如果消息没有以正确的顺序到达，您的应用程序可能会认为最终值是7月17日，而不是7月18日。这对一致性非常重要。</li><li id="2055" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated"><strong class="kk iu">如果消费者此刻不在，数据可以被持久化。这一点很重要，这样您就不会在停机期间丢失任何数据和状态变化。假设您的消费者工作人员有停机时间，并且消息没有被消费。RabbitMQ服务器将保留该消息，直到它被使用或达到其最大队列长度。</strong></li><li id="f1be" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated"><strong class="kk iu">系统分布式</strong>。您的系统没有单点故障(SPOF ),并且能够根据其负载进行伸缩。然而，保持RabbitMQ服务器的健康是非常重要的。否则，您可能会丢失数据和状态更改。</li></ul><h2 id="7f1d" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">等等，阿帕奇卡夫卡呢？</h2><p id="7414" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">相比RabbitMQ，我个人对Apache Kafka的体验很少。据我所知，卡夫卡和RabbitMQ最显著的区别是:</p><ul class=""><li id="77cc" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld oa ng nh ni bi translated">RabbitMQ中的消息可以基于路由规则进行路由，而Kafka中的生产者和消费者可以发布和订阅主题。卡夫卡中没有消息路由的概念。</li><li id="8c64" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">RabbitMQ中的消息保证以有序的顺序传递，而Kafka中的消息不能保证以有序的顺序传递——特别是因为它的数据分区。</li><li id="a92f" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">RabbitMQ是一个基于推的代理，RabbitMQ服务器将消息推送给它的消费者。另一方面，Kafka是一个基于拉的工人，消费者总是从服务器拉新消息。</li></ul><p id="000e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多信息，请参考Eran Stiller写的这篇优秀的文章。</p><p id="e12b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，卡夫卡和RabbitMQ都是为了解决不同的问题而构建的。您应该能够区分哪一个最适合您的用例。明智地选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="94fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在Docker中设置RabbitMQ</h1><p id="ea53" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Docker是让你接触新软件的最快方式。下面是让RabbitMQ 3运行管理UI并暴露端口5672和15672的命令:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="0b23" class="nv md it nr b gy nw nx l ny nz">$ docker run -d --hostname my-rabbit -p 15672:15672 -p 5672:5672 --name rabbit-server -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</span></pre><p id="21ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在在浏览器中打开<code class="fe om on oo nr b">localhost:15672</code>。用户名是<code class="fe om on oo nr b">user</code>，密码是<code class="fe om on oo nr b">password</code>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/d23ed767004f080d4e374ac2a43daad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Oa5sEvLI5KRS2lyLAxob3w.gif"/></div></div></figure><h2 id="2f18" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">创建交换和队列</h2><p id="8216" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">让我们创建一个交换:</p><ul class=""><li id="ab3c" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld oa ng nh ni bi translated">名称:<code class="fe om on oo nr b">my_exchange</code></li><li id="7755" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">类型:默认</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/4f0599af310230646227ae40e1faa27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*10OEb58oKdkXKSF2MLyluQ.gif"/></div></div></figure><p id="519d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们创建一个队列和队列绑定:</p><ul class=""><li id="dbcb" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld oa ng nh ni bi translated">姓名:<code class="fe om on oo nr b">my_app</code></li><li id="ca77" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">类型:经典</li><li id="92fc" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld oa ng nh ni bi translated">绑定:From: <code class="fe om on oo nr b">my_exchange</code>，路由键:<code class="fe om on oo nr b">test</code></li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/16c3b5a68a16fc9c1f4cf6ccc3a18eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*52CHg0ALSZWOSo4HBfVC1g.gif"/></div></div></figure><p id="04c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查一下我们的交换和队列是否真的在工作。我们将向exchange发布一条消息，并检查队列中是否有该消息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/13e169990ed21cc77d29508700cabcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*e1qB6dYfQKGcB5BmEODGxg.gif"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e142" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建Python生产者工人</h1><h2 id="0b9b" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">步骤1:创建一个Python虚拟环境</h2><p id="e4a5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">每次开始一个新项目时，总是建议创建一个新的Python环境。在本教程中，我一直使用Python 3.7.3。</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="0c1d" class="nv md it nr b gy nw nx l ny nz"># Create our working directory<br/>$ mkdir rabbitmq-python<br/>$ cd rabbitmq-python</span><span id="3c6a" class="nv md it nr b gy oq nx l ny nz"># Create a virtual environment<br/>$ python3 -m venv .</span><span id="80fe" class="nv md it nr b gy oq nx l ny nz"># Activate virtual environment<br/>$ source bin/activate</span><span id="8f68" class="nv md it nr b gy oq nx l ny nz"># Install python-pika package<br/>$ pip install pika</span></pre><h2 id="d869" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">第二步:实际代码</h2><p id="2c1f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">将下面的代码作为<code class="fe om on oo nr b">producer.py</code>保存在您的目录中。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="ead9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码的第六行显示了如何建立到RabbitMQ服务器的连接。我在这里使用了一个<code class="fe om on oo nr b">BlockingConnection</code>适配器，它建立了到RabbitMQ服务器的同步连接。您可以使用一个<code class="fe om on oo nr b">SelectConnection</code>适配器作为异步连接，但是您需要小心处理Python中出现的异步问题(我说的是<a class="ae le" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank"> GIL </a>)。在GitHub 上阅读更多关于适配器<a class="ae le" href="https://github.com/pika/pika#pika-provides-the-following-adapters" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="90f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第九行代码展示了如何使用<code class="fe om on oo nr b">'Test!'</code>的<code class="fe om on oo nr b">test</code>路由键和消息体向<code class="fe om on oo nr b">my_exchange</code> RabbitMQ交换发布消息。</p><h2 id="1ad4" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">步骤3:测试您的Python脚本</h2><p id="4f04" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">运行脚本并观察队列。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/310dcab69df8791af0ecb2d6d1216e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tAVxcXwrclsrfFQTDPFNUg.gif"/></div></div></figure><h2 id="a009" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">敞开心扉的话语</h2><p id="26a4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">这段代码很好地演示了如何将消息发布到RabbitMQ交换中。实际上，您可以将Flask用作应用程序的API服务器，并在它接收到HTTP请求时发布消息。现实就是这样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1086" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建Python消费者工作器</h1><p id="8e80" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">现在我们让我们的生产者工人。该消息将一直保留在队列中，直到一个消费者工作者使用了该队列。这是我们的Python代码的样子:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bb85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第8行，我定义了回调函数，每当消费者从RabbitMQ队列接收到新的MQ消息时，都会调用这个函数。这是你写消费者应该做什么操作的地方。在本教程中，消费者工作者只是打印出它收到的消息。但实际上，工人应该在这里做所有的大量操作(例如，调整图像大小、发送注册电子邮件、执行AI/ML操作、编码视频、启动EC2实例等。).这完全取决于你的想象力。</p><p id="68a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我设置了<code class="fe om on oo nr b">auto_ack=True</code>，这意味着一旦消息被消费，它将立即确认该消息。或者，您可以在程序执行完与所使用的消息相关的流程后，手动确认该消息。一旦消息被确认，RabbitMQ服务器将使消息出列并删除它。</p><h2 id="208d" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">让我们测试脚本</h2><p id="7a1b" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">再次运行脚本，观察队列被消耗的情况。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/4b5b762877fbd43b82cf78560d0f1ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9Xpbt_FCmSm1FC17APfRww.gif"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ecd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">干得好！</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ot"><img src="../Images/38a2281e61020ad90751afc7b563b044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pl2Kel4sb7NIqTc0"/></div></div></figure><p id="840a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，你已经使用RabbitMQ构建了一个分布式系统。我希望这篇教程能让你大开眼界，有所启发。我相信，把这个MQ概念和你现有的技能结合起来，你可以做更多的事情。</p><h2 id="3cd7" class="nv md it bd me ob oc dn mi od oe dp mm kr of og mo kv oh oi mq kz oj ok ms ol bi translated">下一步是什么？</h2><p id="43d4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如果您希望了解更多关于消息队列和RabbitMQ的知识，我建议尝试不同类型的交换和队列、身份验证、以异步方式运行MQ生产者和消费者工作者等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">警告:消息队列警告</h1><p id="4feb" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">老实说，消息队列不是一个容易操作和维护的系统。尤其是在集群和故障转移方面，它们需要系统管理员的大量关注。如果你正在从事一个单独的项目或一个开发团队，我个人建议使用由主要云提供商提供的托管服务来减轻痛苦，直到你足够大(在团队规模和容量规模上)能够在内部处理它们。</p></div></div>    
</body>
</html>