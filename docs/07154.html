<html>
<head>
<title>Learn Solidity: Smart Contract Creation and Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:智能契约创建和继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-smart-contract-creation-and-inheritance-8424adac3570?source=collection_archive---------6-----------------------#2020-12-11">https://betterprogramming.pub/learn-solidity-smart-contract-creation-and-inheritance-8424adac3570?source=collection_archive---------6-----------------------#2020-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5657" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从合同中创建合同</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0b65d00dbb7466ae499ae86cbc2e05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APJJANbsCFL34Zsynf9Nkg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@akson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Akson </a>在<a class="ae kv" href="https://unsplash.com/s/photos/communication?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎阅读“学习可靠性”系列的另一篇文章。在<a class="ae kv" href="https://medium.com/better-programming/learn-solidity-functions-ddd8ea24c00d" rel="noopener">上一篇文章</a>中，我们看到了如何使用函数，并应用我们目前所学的一切来构建一个多签名钱包。</p><p id="bb1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将了解如何从另一个契约中创建一个契约，以及如何定义抽象契约和接口。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c6e6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">合同创建</h1><p id="21e8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">契约可以通过以太坊交易来创建，也可以在Solidity契约中使用<code class="fe mw mx my mz b">new</code>关键字来创建，它会部署该契约的一个新实例并返回其地址。</p><p id="c5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过检查Solidity文档中给出的例子来更仔细地看看这实际上是如何工作的。我创建了<code class="fe mw mx my mz b">name</code>变量<code class="fe mw mx my mz b">public</code>，这样我们就可以检查它的值，并创建一个事件来读取<code class="fe mw mx my mz b">createToken</code>函数的返回值(我们将有另一篇文章讨论事件):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我将使用<a class="ae kv" href="https://www.trufflesuite.com/docs/truffle/overview" rel="noopener ugc nofollow" target="_blank"> Tuffle框架</a>——您可以通过遵循他们制作的<a class="ae kv" href="https://www.trufflesuite.com/docs/truffle/quickstart" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>来了解它。</p><p id="82fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将创建一个新项目，并通过执行以下命令来初始化它:</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="62c5" class="ng ma iq mz b gy nh ni l nj nk">&gt; mkdir token<br/>&gt; cd token<br/>&gt; truffle init</span></pre><p id="32f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开项目，更新<code class="fe mw mx my mz b">truffle-config.js</code>文件以使用网络IP和端口，您将在那里部署合同和您正在使用的Solidity编译器版本。在我的例子中，我使用<a class="ae kv" href="https://www.trufflesuite.com/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>来运行网络。</p><p id="04e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以在<code class="fe mw mx my mz b">contracts</code>文件夹中创建我们的合同。复制并粘贴代码后，您需要在<code class="fe mw mx my mz b">migrations</code>文件夹中创建一个迁移文件来部署<code class="fe mw mx my mz b">TokenCreator</code>契约。命名为<code class="fe mw mx my mz b">2_deploy_token.js</code>，复制粘贴以下代码。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="99a8" class="ng ma iq mz b gy nh ni l nj nk">const TokenCreator = artifacts.require("TokenCreator");</span><span id="e4ad" class="ng ma iq mz b gy nl ni l nj nk">module.exports = function (deployer) {<br/>     deployer.deploy(TokenCreator);<br/>};</span></pre><p id="5c7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回到命令行，键入<code class="fe mw mx my mz b">truffle console</code>启动Truffle控制台——在这里您可以编译和部署合同:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/18390ce4a228accfd3f68c7af4ba6be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duJ08vsWBuZ8Ya5Oqt3QpA.png"/></div></div></figure><p id="9cc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在要做的是检索已经部署的<code class="fe mw mx my mz b">TokenCreator</code>的实例。然后，我们将调用<code class="fe mw mx my mz b">createToken</code>函数两次，并保存每个新创建合同的地址。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/03a5c46f1b4223d7296b4afd5476d50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQHufHtXJs_HiWBCHmDRgA.png"/></div></div></figure><p id="a06a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用的是Ganache，您可以看到两个事务代表一个添加到事务列表中的契约调用，其中数据字段被设置为函数选择器的四个字节，参数被传递。如果你想知道到底发生了什么，这些合同是如何产生的，请继续关注我。</p><p id="3305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所知，合同只是另一种类型的帐户，所以当我们调用<code class="fe mw mx my mz b">createToken</code>函数时，真正发生的是状态数据库被更新，以包括新创建的帐户，其中每个帐户存储的四个变量(<code class="fe mw mx my mz b">nonce</code>、<code class="fe mw mx my mz b">balance</code>、<code class="fe mw mx my mz b">storage_root</code>、<code class="fe mw mx my mz b">code_hash</code>)被正确初始化。</p><p id="6941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在回到Truffle控制台，您可以检查每个事务的日志以获得每个合同的地址，然后您可以调用名称getter来验证它们确实是两个独立的实体。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/e360339ec6056bc582f32eb6b9702127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfS45epDZvShehnMlABiCQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ff7238c2dd43e5c74b709377efe16e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*-Y7F7V8lCLd5-WSI95BlRg.png"/></div></figure><p id="7ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多关于web3.js的信息可以在<a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2c44" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">构造函数声明</h1><p id="0e88" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">合同的构造函数在合同创建时被调用，并且不与合同代码的其余部分一起存储在区块链上。<br/>构造函数是可选的。只允许一个构造函数，这意味着不支持重载。</p><p id="117d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">constructor</code>关键字声明一个构造函数:</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="0516" class="ng ma iq mz b gy nh ni l nj nk">contract A {<br/>     uint a;<br/>     bool b;</span><span id="5f93" class="ng ma iq mz b gy nl ni l nj nk">   constructor(uint _a, bool _b){<br/>        a = _a;<br/>        b = _b;<br/>   }<br/>   ...<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6c90" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">抽象合同</h1><p id="21a9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当至少有一个功能没有实现时，契约需要标记为<code class="fe mw mx my mz b">abstract</code>。即使所有功能都已实现，合同也可能标记为<code class="fe mw mx my mz b">abstract</code>。</p><p id="6936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过对契约使用<code class="fe mw mx my mz b">abstract</code>关键字来完成，未实现的函数应该使用<code class="fe mw mx my mz b">virtual</code>关键字来允许多态性。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="7022" class="ng ma iq mz b gy nh ni l nj nk">abstract contract A {<br/>    function f() public pure virtual;<br/>}</span></pre><p id="d8f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象契约不能直接实例化，即使所有的功能都实现了。它们可以作为基础契约，定义由其他契约继承的特定行为。实现的函数应该有<code class="fe mw mx my mz b">override</code>关键字。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="57e5" class="ng ma iq mz b gy nh ni l nj nk">abstract contract A {<br/>    function f() public pure virtual;<br/>}</span><span id="569c" class="ng ma iq mz b gy nl ni l nj nk">abstract contract B is A {<br/>    function f() public pure override {<br/>       //function body<br/>    }<br/>}</span></pre><p id="aa72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个派生契约没有实现所有未实现的功能，它也需要被标记为<code class="fe mw mx my mz b">abstract</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8039" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">接口</h1><p id="463a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接口类似于抽象契约，但是它们不能实现任何功能。还有进一步的限制:</p><ul class=""><li id="c004" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">它们不能从其他契约继承，但是可以从其他接口继承</li><li id="bd6c" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">所有声明的函数都必须是外部的</li><li id="4be9" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">他们不能声明构造函数</li><li id="1c69" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">他们不能声明状态变量</li></ul><p id="35fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用关键字<code class="fe mw mx my mz b">interface</code>声明接口。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="77e4" class="ng ma iq mz b gy nh ni l nj nk">interface A {<br/>    function f() external pure;<br/>} </span></pre><p id="afd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口中声明的所有函数都是隐式的<code class="fe mw mx my mz b">virtual</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="40b6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="bc09" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">本文到此为止。在接下来的文章中，我们将深入探讨智能合约的开发。敬请关注。</p></div></div>    
</body>
</html>