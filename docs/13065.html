<html>
<head>
<title>Error Handling Methods for Asynchronous Code in Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Express.js中异步代码的错误处理方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-error-handling-methods-for-asynchronous-code-in-express-js-72feb82d4f2?source=collection_archive---------4-----------------------#2022-07-25">https://betterprogramming.pub/two-error-handling-methods-for-asynchronous-code-in-express-js-72feb82d4f2?source=collection_archive---------4-----------------------#2022-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b510" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从一开始就培养这项重要的技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1b021efa10afa4b1b8d626ff0bf99c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8flu802zsCLektqWnKJRw.jpeg"/></div></div></figure><p id="4e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">错误处理是软件开发中最重要的部分之一，然而它经常得不到应有的重视，尤其是对于新开发人员来说。因此，在使用Express.js时，我们将看到两种不同的错误处理方法，这是最流行的JavaScript服务器端框架。</p><p id="0c0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Express.js默认负责同步代码的错误处理，所以我们将只讨论异步代码，例如，如果我们调用这个使用同步处理函数的路由。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="541f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express的默认内置错误处理程序会处理错误，我们的应用程序会继续运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/a99b521cdb3c5b0e116bc5701ebad07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cN6gpY8JNeGKfO-MRUGFdg.jpeg"/></div></div></figure><p id="391a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们使用async/await处理函数运行相同的路由，我们会得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="e264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序崩溃并退出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lt"><img src="../Images/d620b8bc6e0ff878a195cc4c26c83a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eESoR-zUO9pYfGhNyjc82A.jpeg"/></div></div></figure><p id="c691" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们开始吧。</p><h1 id="2cc7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用中间件功能的错误处理</h1><p id="2a36" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">Express.js中的中间件函数是在服务器收到请求之后、响应发送到客户机之前执行的函数。它们是从上到下顺序触发的，通过用<code class="fe mr ms mt mu b"> next()</code>函数相互调用，它们按照这个顺序移动。</p><p id="efea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果我们在路由的底部创建一个中间件，它可以作为我们处理所有错误的点，只要一有错误发生就调用它。</p><p id="62f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们创建这个中间件，并把它放在我们路线的底部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="53d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将最后一个例子改为包含一个try/catch块，然后在出现错误时调用该中间件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7d96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们运行这条路线，我们会收到错误处理程序中间件发送的消息，我们的应用程序会继续运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/57014139a602d966c67bc936272805c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SAGksLbCb9k449YSqQWmg.jpeg"/></div></div></figure><p id="37dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以定制发送到错误处理程序的错误对象，方法是在使用<code class="fe mr ms mt mu b">next()</code>函数发送之前修改它。例如，如果我们想要生成状态代码，我们可以根据错误的来源做出相应的更改。我们可以先截取错误，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="e6e3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用包装函数的错误处理</h1><p id="697e" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">当使用前面的方法来处理我们的错误时，有一个不便之处，那就是必须在我们所有的路由上使用try/catch块。因此，在这个方法中，我们可以通过创建一个包含try/catch块的包装函数来避免这种情况，并在其中调用我们赋予它的处理函数。然后，我们将所有的路由处理程序封装在这个函数中，这样我们只需尝试/捕捉一次，就有了一个集中的地方来处理我们的错误。</p><p id="9367" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们创建我们的包装函数，并命名为<code class="fe mr ms mt mu b">handleCall</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="2943" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，包装器函数返回将被传递给路由的处理程序，在它内部，我们调用包含我们的逻辑的实际处理程序。</p><p id="2b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以现在我们的应用程序看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="dc34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，我们将处理函数包装在<code class="fe mr ms mt mu b">handleCall</code>中，我们不需要使用任何try/catch块。我们还像前面的例子一样发送了一个定制的错误对象。现在，如果我们调用该路由，我们将收到与之前方法相同的响应，我们的应用程序也将继续运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/57014139a602d966c67bc936272805c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SAGksLbCb9k449YSqQWmg.jpeg"/></div></div></figure><p id="a2ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。我们探索了两种方法，可以用异步代码处理Express.js上的错误，您可以选择自己更喜欢的方法。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="3ed7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章对你有帮助。如果你有任何进一步的问题，请在评论区留下，我会尽力回答。</p></div></div>    
</body>
</html>