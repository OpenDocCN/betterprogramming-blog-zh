<html>
<head>
<title>How to Automate Dependency Updates in Your Software Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在您的软件项目中自动化依赖项更新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-automate-dependency-updates-in-your-software-projects-8cf609e092b?source=collection_archive---------4-----------------------#2020-06-02">https://betterprogramming.pub/how-to-automate-dependency-updates-in-your-software-projects-8cf609e092b?source=collection_archive---------4-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afe8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">保持您的依赖关系安全并自动更新</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35227ddf0b652d79c17c0a701ac9e435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IRUVvicQnh9BjvhK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡·布拉沃在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="44b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于许多开发人员来说，依赖项更新相当无聊。然而，这个话题往往被忽视和搁置。更新的范围可能从小的错误修复到安全漏洞修复，甚至是新功能。</p><p id="e808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种工具可用，我们将研究以下工具:</p><ul class=""><li id="8c44" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://dependabot.com/" rel="noopener ugc nofollow" target="_blank">dependent bot</a>:仅适用于GitHub项目。2019年被GitHub收购。</li><li id="7b49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> Snyk </a>:可用于GitHub、GitLab、Bitbucket和Azure Repos。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d266" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">易用性</h1><p id="cf65" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">所有这些产品都以相似的方式工作。通常，您有一个文件(在JavaScript项目中，您有一个<a class="ae ky" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>)，您在其中声明了项目使用的依赖项。一旦有了新版本的依赖项，该工具就会检测到并创建一个简单的拉请求。pull请求包含一些关于更新的依赖项的信息，比如changelog。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f709c12a43bc1e0b57df8fc0ff93aed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rxiXA9CgqE4yfpHIclJmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将date-fns库更新到Snyk创建的最新版本的拉请求</p></figure><p id="af8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能正在使用持续集成来构建、测试和发布您的软件。理想情况下，自动拉取请求是自动构建和测试的，因此您可以验证更新没有破坏任何东西。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9f72" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">有效期</h1><p id="4a39" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当谈到有效性时，我的意思是，工具是否正确地更新了依赖关系？这包括几件事:</p><ul class=""><li id="bee4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果有<a class="ae ky" href="https://docs.npmjs.com/configuring-npm/package-lock-json.html" rel="noopener ugc nofollow" target="_blank"> package-lock.json </a>，那么它应该作为依赖项更新的一部分进行更新，以确保其他开发人员和持续集成平台(如GitLab或Jenkins)在安装依赖项时使用正确的依赖项版本。</li><li id="6e5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您的工具应该支持<a class="ae ky" href="https://flaviocopes.com/npm-peer-dependencies/" rel="noopener ugc nofollow" target="_blank">对等依赖性</a>以防止依赖性更新中断。翻新目前不支持此功能。</li></ul><p id="a778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:假设你有一个使用Angular 8的Angular项目，其中包括一些特定于Angular的第三方库，如<a class="ae ky" href="https://github.com/ngx-translate/core" rel="noopener ugc nofollow" target="_blank"> ngx-translate </a>。这个库的新版本已经发布，它只能在最新的Angular版本上工作。您的工具创建了一个拉取请求，您合并了它，因为它看起来不错。构建甚至测试可能不会检测到新引入的问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d800" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">定价</h1><p id="44f2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">上面提到的所有工具都至少有一个有限的免费版本，使您能够很好地了解产品。对于开源项目，它们甚至大部分是免费的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="21ab" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">平台支持</h1><p id="3417" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Dependabot只适用于GitHub，而Snyk也支持GitLab和Bitbucket。因为有些项目可能不是开源的，所以您选择的工具也应该支持私有存储库。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="71c4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">语言支持</h1><p id="d1e8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">所有这些流行的工具都支持最常用的编程语言。这包括JavaScript、C#、Python、Java和PHP等语言。一些不太常用的语言，比如Erlang，可能并不是所有的工具都支持。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="086e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">配置和可扩展性</h1><p id="e707" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">配置允许您根据需要定制行为。让我们来看看一些有趣的配置选项:</p><ul class=""><li id="3da8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">自动合并拉取请求，从而减少所需的人工干预。</li><li id="9d9c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Git选项:分支名称、提交消息、拉请求模板等。长什么样？</li><li id="6e4a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分配审阅者以自动提取请求。</li><li id="ab84" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更新策略:依赖关系应该如何更新？当前版本为1.0.1的依赖项是否应该更新到2.0.0？</li><li id="deeb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安排在一周或一月的某个时间进行相关性更新。您可能希望限制持续集成平台不要消耗太多时间(例如，对于私有存储库，<a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>为免费用户提供2000分钟)。</li></ul><p id="87dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个配置示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3119" class="nt mr it np b gy nu nv l nw nx">{<br/> "extends": [<br/>  "config:base"<br/> ],<br/> "packageRules": [<br/>  {<br/>   "packageNames": [<br/>    "angular"<br/>   ],<br/>   "rangeStrategy": "bump"<br/>  }<br/> ],<br/> "rangeStrategy": "replace"<br/>}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6f2e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">npm审计</h1><p id="f72a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我想提一下另一种替代方案，它不需要更多的工具或软件。在NPM版本6中引入，<code class="fe ny nz oa np b">npm audit</code>是一个命令，用于扫描你的项目的漏洞，并自动安装任何兼容的更新到易受攻击的依赖项。这就提出了一个问题，你是否还需要一个像Snyk这样的基于SaaS的专用解决方案。</p><p id="5e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一方面，如果你使用的是NPM v6或更高版本，<code class="fe ny nz oa np b">npm audit</code>是免费的。除了Snyk这样的SaaS，你还可以使用<code class="fe ny nz oa np b">npm audit</code>。</p><p id="94ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，上面提到的工具对自动化这个繁琐的过程帮助很大。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="91ff" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="5002" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">感谢阅读。如您所见，有几个选项可供选择。所有这些都是有效的选择，因为它们通过自动化繁琐的步骤使更新依赖关系变得更容易并且更不容易出错。</p><p id="fd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何更新你的依赖关系？请在评论中告诉我。</p></div></div>    
</body>
</html>