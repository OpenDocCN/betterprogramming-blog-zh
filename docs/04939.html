<html>
<head>
<title>Istio Service Mesh on Multi-Cluster Kubernetes Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多集群Kubernetes环境下的Istio服务网格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/istio-service-mesh-on-multi-cluster-kubernetes-environment-518094cdcdc4?source=collection_archive---------4-----------------------#2020-05-25">https://betterprogramming.pub/istio-service-mesh-on-multi-cluster-kubernetes-environment-518094cdcdc4?source=collection_archive---------4-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6756" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在单个服务网格中管理多个Kubernetes集群上运行的微服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66a2162784daa6f47e1f3b125c04697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xpbg9kPSIOv-flCUChv5xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤姆·陈在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您为一个典型的企业工作，有多个团队一起工作，交付组成单个应用程序的独立软件。您的团队遵循微服务架构，并拥有由多个Kubernetes集群组成的广泛基础设施。</p><p id="6f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于微服务分布在多个集群中，您需要设计一个解决方案来集中管理所有微服务。幸运的是，您正在使用Istio，提供这个解决方案只是另一个配置更改。</p><p id="f3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Istio这样的服务网格技术可以帮助您安全地发现和连接分布在多个集群和环境中的微服务。本文是“<a class="ae ky" href="https://medium.com/better-programming/how-to-authorize-non-kubernetes-clients-with-istio-on-your-k8s-cluster-8a90fe95b137" rel="noopener">如何在您的K8s集群</a>上使用Istio授权非Kubernetes客户”的后续文章今天我们来讨论如何使用Istio管理多个Kubernetes集群中托管的微服务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d046" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">体系结构</h1><p id="7405" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Istio通过以下组件提供跨集群服务发现:</p><ul class=""><li id="2da3" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Istio核心DNS:每个Istio控制平面都有一个核心DNS。Istio使用它来发现在全局范围上定义的服务。例如，如果集群1上托管的微服务需要连接到集群2上托管的另一个微服务，您需要在Istio核心DNS上为集群2上运行的微服务创建一个全局条目。</li><li id="01d1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">根CA:由于Istio需要运行在不同集群上的服务之间的mTLS连接，您需要使用一个共享的根CA来为两个集群生成中间CA证书。这在不同集群上运行的微服务之间建立了信任，因为中间证书共享同一个根CA。</li><li id="e563" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Istio入口网关:集群间通信通过入口网关进行，服务之间没有直接连接。因此，您需要确保入口网关是可发现的，并且所有集群都可以连接到它。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/187b8c0fb47ed77d93b6289e1d0a2e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*AJMMpOukN4b5cbS8i1Kpww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集群间通信</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e06" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务发现</h1><p id="11a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Istio使用以下步骤来促进服务发现:</p><ol class=""><li id="8387" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu no nf ng nh bi translated">所有集群上都有相同的控制平面，以提高高可用性。</li><li id="e229" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu no nf ng nh bi translated">Kube DNS被连接到Istio核心DNS以提供全球服务发现。</li><li id="de29" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu no nf ng nh bi translated">用户通过Istio核心DNS中的ServiceEntries以name.namespace.global格式定义到远程服务的路由</li><li id="c1a5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu no nf ng nh bi translated">源边车使用全局核心DNS条目将流量路由到目标Istio入口网关。</li><li id="888d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu no nf ng nh bi translated">目标Istio入口网关将流量路由到正确的微服务pod。</li></ol><h1 id="5845" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">先决条件</h1><p id="c13a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文假设您对Kubernetes和Istio的工作原理有基本的了解。关于Istio的介绍，请查看“<a class="ae ky" href="https://medium.com/better-programming/how-to-manage-microservices-on-kubernetes-with-istio-c25e97a60a59" rel="noopener">如何使用Istio </a>管理Kubernetes上的微服务。”要跟随动手演示，请确保:</p><ul class=""><li id="7682" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">您至少有两个运行版本1.14、1.15或1.16的Kubernetes集群。</li><li id="b33f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您拥有在集群中安装和配置Istio的权限。</li><li id="2181" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您在两个Kubernetes集群上都拥有集群管理权限。</li><li id="23d0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">入口网关可通过网络负载平衡器或类似配置到达其他集群。平面网络不是必需的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Istio</h1><p id="14b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在两个集群上，使用以下命令安装Istio 1.6.1:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="d138" class="nz md it nv b gy oa ob l oc od">curl -L <a class="ae ky" href="https://istio.io/downloadIstio" rel="noopener ugc nofollow" target="_blank">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.6.1 sh -<br/>cd istio-1.6.1<br/>export PATH=$PWD/bin:$PATH</span></pre><p id="de14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们需要使用共享根证书生成的中间证书来引导我们的Istio服务网格，所以使用中间证书创建一个秘密。</p><p id="3759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个示例，让我们使用提供的示例证书。但是，我不建议您在生产中使用这些工具，因为它们很容易获得并且广为人知。最好使用您组织的根CA来生成中间CA证书。</p><p id="e6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在两个集群上运行以下命令以使用示例证书。如果您正在使用您的证书，请替换适用的文件路径。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="868d" class="nz md it nv b gy oa ob l oc od">kubectl create namespace istio-system<br/>kubectl create secret generic cacerts -n istio-system \<br/>    --from-file=samples/certs/ca-cert.pem \<br/>    --from-file=samples/certs/ca-key.pem \<br/>    --from-file=samples/certs/root-cert.pem \<br/>    --from-file=samples/certs/cert-chain.pem</span><span id="6e54" class="nz md it nv b gy oe ob l oc od">secret/cacerts created</span></pre><p id="2c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们需要为多集群设置安装Istio，所以在两个集群上使用提供的Istio多集群网关清单文件。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="476e" class="nz md it nv b gy oa ob l oc od">$ istioctl manifest apply -f install/kubernetes/operator/examples/multicluster/values-istio-multicluster-gateways.yaml<br/>- Applying manifest for component Base...<br/>✔ Finished applying manifest for component Base.<br/>- Applying manifest for component Pilot...<br/>✔ Finished applying manifest for component Pilot.<br/>  Waiting for resources to become ready...<br/>- Applying manifest for component AddonComponents...<br/>- Applying manifest for component IngressGateways...<br/>- Applying manifest for component EgressGateways...<br/>✔ Finished applying manifest for component EgressGateways.<br/>✔ Finished applying manifest for component IngressGateways.<br/>✔ Finished applying manifest for component AddonComponents.</span><span id="7382" class="nz md it nv b gy oe ob l oc od">✔ Installation complete</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf4b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">配置Kube DNS</h1><p id="6b9e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一步是将Kube DNS的DNS解析联合到Istio核心DNS。让我们通过为<code class="fe of og oh nv b">kube-dns</code>定义一个<code class="fe of og oh nv b">ConfigMap</code>来配置一个存根域。在两个集群上应用以下清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8f7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置上下文</h1><p id="d864" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们需要为不同的活动连接两个集群，所以获取上下文并将它们存储在环境变量中是有意义的。这样，我们可以在我们选择的集群中运行<code class="fe of og oh nv b">kubectl</code>命令，只需在<code class="fe of og oh nv b">kubectl</code>命令中包含上下文即可。</p><p id="3ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取上下文:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="2425" class="nz md it nv b gy oa ob l oc od">$ kubectl config get-contexts<br/>CURRENT   NAME        CLUSTER     AUTHINFO      NAMESPACE<br/>          cluster-1   cluster-1   cluster-1<br/>*         cluster-2   cluster-2   cluster-2</span></pre><p id="b8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置环境变量以使用上下文:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="2984" class="nz md it nv b gy oa ob l oc od">$ export CTX_CLUSTER1=$(kubectl config view -o jsonpath='{.contexts[0].name}')<br/>$ export CTX_CLUSTER2=$(kubectl config view -o jsonpath='{.contexts[1].name}')<br/>$ echo CTX_CLUSTER1 = ${CTX_CLUSTER1}, CTX_CLUSTER2 = ${CTX_CLUSTER2}<br/>CTX_CLUSTER1 = cluster-1, CTX_CLUSTER2 = cluster-2</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5115" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署示例微服务</h1><p id="691c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从在cluster-1的<code class="fe of og oh nv b">foo</code>命名空间上部署睡眠微服务开始:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bfd7" class="nz md it nv b gy oa ob l oc od">$ kubectl create --context=$CTX_CLUSTER1 namespace foo<br/>namespace/foo created<br/>$ kubectl label --context=$CTX_CLUSTER1 namespace foo istio-injection=enabled<br/>namespace/foo labeled<br/>$ kubectl apply --context=$CTX_CLUSTER1 -n foo -f samples/sleep/sleep.yaml<br/>serviceaccount/sleep created<br/>service/sleep created<br/>deployment.apps/sleep created<br/>$ export SLEEP_POD=$(kubectl get --context=$CTX_CLUSTER1 -n foo pod -l app=sleep -o jsonpath={.items..metadata.name})</span></pre><p id="53e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在bar名称空间上的cluster-2上部署<code class="fe of og oh nv b">httpbin</code>微服务:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="a55e" class="nz md it nv b gy oa ob l oc od">$ kubectl create --context=$CTX_CLUSTER2 namespace bar<br/>namespace/bar created<br/>$ kubectl label --context=$CTX_CLUSTER2 namespace bar istio-injection=enabled<br/>namespace/bar labeled<br/>$ kubectl apply --context=$CTX_CLUSTER2 -n bar -f samples/httpbin/httpbin.yaml<br/>serviceaccount/httpbin created<br/>service/httpbin created<br/>deployment.apps/httpbin created</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1058" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建服务条目</h1><p id="6fca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我们需要在Istio核心DNS上创建一个服务条目，以便我们可以从cluster-1中发现cluster-2上的服务。由于所有通信都通过入口网关进行，因此导出cluster-2入口网关地址。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bfef" class="nz md it nv b gy oa ob l oc od">export CLUSTER2_GW_ADDR=$(kubectl get --context=$CTX_CLUSTER2 svc --selector=app=istio-ingressgateway \<br/>    -n istio-system -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')</span></pre><p id="ba93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让集群1上的服务发现集群2上的<code class="fe of og oh nv b">httpbin</code>,我们需要为集群1上的<code class="fe of og oh nv b">httpbin.bar.global</code>创建一个<code class="fe of og oh nv b">ServiceEntry</code>。这确保了如果cluster-1中的服务到达端点<code class="fe of og oh nv b">httpbin.bar.global</code>，cluster-1上的Istio核心DNS可以到达cluster-2入口网关。下面这个<code class="fe of og oh nv b">yaml</code>:</p><ul class=""><li id="fec9" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在“主机”部分定义服务域名。</li><li id="e551" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">位置是<code class="fe of og oh nv b">MESH_INTERNAL</code>，因为我们需要将其他服务视为同一个服务网格的一部分。</li><li id="8a8a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">它公开端口8000上的服务。</li><li id="4638" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们需要为此服务提供一个唯一的IP地址。IP地址不必是可路由的，您可以使用240.0.0.0/16范围内的任何地址。</li><li id="b04d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们在端点地址部分定义了cluster-2入口网关地址，以便请求可以路由到它。端口15443是入口网关的SNI感知特使代理端口，用于在目标集群服务的pod之间路由流量。</li></ul><p id="7791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用<code class="fe of og oh nv b">yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3253" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试服务</h1><p id="2115" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们从sleep微服务生成一些流量，看看它是否能到达运行在cluster-2上的<code class="fe of og oh nv b">httpbin</code>微服务。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="2260" class="nz md it nv b gy oa ob l oc od">$ kubectl exec --context=$CTX_CLUSTER1 $SLEEP_POD -n foo -c sleep -- curl -I httpbin.bar.global:8000/headers<br/>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0HTTP/1.1 200 OK<br/>  0   519    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0<br/>server: envoy<br/>date: Sat, 16 May 2020 23:03:22 GMT<br/>content-type: application/json<br/>content-length: 519<br/>access-control-allow-origin: *<br/>access-control-allow-credentials: true<br/>x-envoy-upstream-service-time: 37</span></pre><p id="db2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了成功的回应！恭喜，我们已经使用Istio成功配置了多个Kubernetes集群之间的服务发现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c3a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a875" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p><p id="816e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在多个集群上运行的高可用性Istio服务网格配置的演示。您还可以拥有共享的控制平面配置，但不建议在生产中使用，如果您因停机而失去一个集群，您也将失去对正在运行的集群的控制。</p></div></div>    
</body>
</html>