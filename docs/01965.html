<html>
<head>
<title>Greedy Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贪婪算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/greedy-algorithms-79d0ed19aef9?source=collection_archive---------6-----------------------#2019-10-27">https://betterprogramming.pub/greedy-algorithms-79d0ed19aef9?source=collection_archive---------6-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="78dc" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"># 100天代码的第38天</h2><div class=""/><div class=""><h2 id="395f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习和优化算法——第3部分</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5041a9bf9d48233516374fad1d0b1ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ypdsl3zK6X_gdjJKxA34tg.png"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="080a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">嘿，很高兴看到你对这个话题感兴趣。我们将从简单到复杂的问题陈述，并按照贪婪的方法来解决它们，因此它们被称为<em class="mb">贪婪算法</em>。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0352" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">1.最大数问题</h1><p id="1659" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">问题陈述:给你一组数字，你必须找出通过重新排列这些数字可以得到的最大数字。</p><p id="3f26" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">你会怎么做？</p><p id="3800" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">你可以简单地以递减的方式重新排列数字，因此你会得到最大的数字。</p><p id="5e69" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们创建一个算法来做同样的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/b9ef709a0df9b9e3cabb8ff9f3c89a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn86CIg_vJlrUMNHKNGQSg.png"/></div></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9bd7" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">2.最低加油量</h1><p id="ec95" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">问题陈述:你的汽车加满油可以行驶x公里，你必须从a到达B，你必须以最少的加油次数到达目的地。</p><p id="b4e4" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你想这样做，你有三个选择。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nh"><img src="../Images/52e38e3a4988451480c4a4385955ffce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wD1UATZwQKfark85_uHXGQ.png"/></div></div></figure><p id="01cb" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第二个似乎是最好的，而不是冒险在我们的燃料将耗尽的地方找到一个加油站。</p><p id="da3c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们看看算法，我们开始我们的旅程，并前往最远的加油站，我们可以做到这一点。</p><p id="a862" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后，从那里，我们再次重复上述过程，并达到尽可能最远的加油站。我们重复这个过程，直到我们到达目的地。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/9a85ed10ccd9eb69ba68afcd50df75e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA_evsE2jJhrb4DZ1hviHg.png"/></div></div></figure><p id="8b69" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意到这里发生了什么吗？</p><ul class=""><li id="c7cd" class="nj nk it lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">我们首先做出一个贪婪的选择(到达尽可能远的加油站)。</li><li id="3e7b" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">这样，我们把问题简化成子问题。(把我们的旅程分成多个加油站。)</li><li id="ce7e" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">然后，我们在给定的时间内迭代子问题(到达可能最远的加油站)。</li></ul><h2 id="610f" class="nx mk it bd ml ny nz dn mp oa ob dp mt lo oc od mv ls oe of mx lw og oh mz iz bi translated"><strong class="ak">实现算法</strong></h2><p id="a641" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">为了便于理解，我已经初始化了变量的值，并且我已经尽可能地保持代码的可读性，因为我关心你。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oi le l"/></div></figure><p id="1f86" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你看到两个嵌套的循环，你会发现理论上的复杂度是O(n)。有趣的是，结果是O(n) <strong class="lh jd"> <em class="mb"> </em> </strong>正如我们可以看到的，我们不会一遍又一遍地迭代和计算所有的子数组。</p><p id="7c73" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当我们在嵌套循环中迭代数组时，一旦我们打破它，我们从那里继续外部循环，因此两个循环一起在一次迭代中线性地覆盖整个数组，因此是O(n)。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="411c" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">对贪婪方法的观察</h1><p id="a5bd" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">正如我们所看到的，我们将问题分解成<em class="mb">个更小的类似子问题</em>并解决它们，直到整个问题得到解决。我们分析问题并提出一些安全策略。</p><p id="a263" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们的策略不安全，就像上面例子中的“旅行直到我们耗尽燃料”，我们的算法将失败，因此，在最初的分析之后，想出一个<em class="mb">被证明安全的</em>移动是必不可少的，否则你将会失败而一事无成。</p><p id="6110" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们挑选一些更复杂的问题来更好地理解贪婪算法。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6436" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">3.学生分组问题</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/246ab93b1844a9d11e2e9d437f7f5c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pc18v-j57nhlUpUN1SMXLA.png"/></div></div></figure><p id="5e58" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">问题陈述:你有一个大厅，里面坐满了不同年龄的孩子和不同的老师。</p><ul class=""><li id="6ccf" class="nj nk it lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">你必须把这些孩子/学生分成一组，其中任何两个学生的年龄差最大为1。</li><li id="1c22" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">你的老师数量也是有限的，因此，你应该组建尽可能少的小组。</li><li id="f11f" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">然后，您将分配一名教师到一个小组进行教学。</li></ul><h2 id="4d86" class="nx mk it bd ml ny nz dn mp oa ob dp mt lo oc od mv ls oe of mx lw og oh mz iz bi translated">简单的解决方案</h2><ul class=""><li id="b7d8" class="nj nk it lh b li nb ll nc lo ok ls ol lw om ma no np nq nr bi translated">你创建一个由所有可能的学生组合组成的小组。</li><li id="05a3" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">迭代每个组，看看最大年龄和最小年龄之间的差是否为1，否则我们丢弃该组。</li><li id="eeed" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">这种方法将采取2^n运算，因此，我们的算法是非常缓慢的0(2^n).</li></ul><h2 id="3cba" class="nx mk it bd ml ny nz dn mp oa ob dp mt lo oc od mv ls oe of mx lw og oh mz iz bi translated">贪婪的方法</h2><ul class=""><li id="19c6" class="nj nk it lh b li nb ll nc lo ok ls ol lw om ma no np nq nr bi translated">在数组0(nLogn)中从最小到最大对年龄进行排序。</li><li id="4540" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">遍历数组，对每个元素加+1来构建范围。</li><li id="35b1" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">然后，迭代下一个元素，看看哪些数字落在这个范围内。把他们分成一组。</li><li id="5bd0" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">然后，从最后一组数字0(n)向右移动到下一个数字。</li><li id="8322" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">重复这个过程。</li></ul><p id="c76b" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">因此，类似于前面的最小加油量问题，如果年龄以排序的方式给出，我们发现了一个O(n)的方法，否则，如果你包括排序的数字，它是一个O(nlogn ),这仍然是一个比O(2^n大的改进，这是一个巨大的差异。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3c45" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">4.分数背包</h1><p id="8a3e" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">想象一下，你必须计划一次长途旅行，而你有一个背包来装你需要携带的多种物品。</p><p id="816c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">由于你的背包容量有限，你决定携带不同数量的不同所需物品，但最终目标是最大限度地增加你从装满的背包中摄入的热量。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/fc24731cc80c6af31568986a42535940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYmssOoWvV0eHHd4Dh7MUg.png"/></div></div></figure><p id="99f3" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这又是一个最大化问题，我们试图找出能给我们带来最大价值的食物组合。</p><p id="97ec" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们假设Q代表体重，而V代表食物的价值，以卡路里的摄入量来表示。</p><ul class=""><li id="b8b7" class="nj nk it lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">我们重复以下步骤，直到我们的背包装满。</li><li id="fe13" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们可以通过将重量除以价值，即V/W，找出最有价值的水果。</li><li id="3cbc" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">用这个最有价值的产品(MVP)装满背包。</li><li id="86ba" class="nj nk it lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们可以将该产品部分或全部装入背包。如果我们能够完全填满，并且仍然有空间存放其他物品，那么找出下一个最佳MVP，并重复这些步骤。</li></ul><p id="64d7" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">理论上，我们已经找到了一个可行的解决方案，并且有一个将问题分解成小问题的重复过程，因此，我们有了一个贪婪算法。</p><h2 id="ed26" class="nx mk it bd ml ny nz dn mp oa ob dp mt lo oc od mv ls oe of mx lw og oh mz iz bi translated">实现算法</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oi le l"/></div></figure><p id="9d43" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">该算法的时间复杂度为O(n)，因为在<code class="fe oo op oq or b">indexOfMaxValue</code>和<code class="fe oo op oq or b">findMVPs</code>中有一个<code class="fe oo op oq or b">while</code>循环和一个<code class="fe oo op oq or b">for</code>循环。</p><p id="190c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们能对此进行优化吗？耶！</p><p id="397a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以按价值/重量比的降序排列这些项目。这将花费O(N log N)来对项目进行排序，然后我们可以简单地以降序选择项目，直到背包装满，因此，我们的解决方案为O(N log N)。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4a14" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">结论</h1><p id="2b80" class="pw-post-body-paragraph lf lg it lh b li nb kd lk ll nc kg ln lo nd lq lr ls ne lu lv lw nf ly lz ma im bi translated">今天，我们学习了如何使用贪婪的方法将问题分解成相似的子问题，从而帮助你提出更有效的解决方案，而不是简单的暴力方法。</p><p id="e8e2" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">希望你觉得这篇文章有价值，内容丰富。感谢阅读。</p></div></div>    
</body>
</html>