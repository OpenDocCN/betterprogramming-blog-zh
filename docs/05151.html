<html>
<head>
<title>Create a Team Roster with Node.js, React, and Google Sheets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js、React和Google Sheets创建团队花名册</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-a-team-roster-with-node-react-and-google-sheets-305b9f9ebbb1?source=collection_archive---------9-----------------------#2020-06-15">https://betterprogramming.pub/make-a-team-roster-with-node-react-and-google-sheets-305b9f9ebbb1?source=collection_archive---------9-----------------------#2020-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松创建和更新您团队的页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/180ff47f083b872aefd1e20dad7d8dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gsQj_uzvzHkHaBPlm5OHNg.png"/></div></figure><p id="4332" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">没有开发人员喜欢做管理工作。他们宁愿发展。</p><p id="b546" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑到这一点，我将向您展示如何通过使用Google Sheets API，Node制作一个简单的团队花名册来避免重复的人事变动。JS、Express和React.JS。</p><h1 id="9cc2" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated"><strong class="ak">但是为什么呢？</strong></h1><p id="10d4" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">大多数开发人员都是非常了不起的人。不轻易发怒，乐于助人，是每个人最好的朋友——那就是我们。但是如果有一件事让我们恼火的话，那就是不得不做多余的工作。在这些疯狂的请求中，最主要的是对原本应该保持静态的内容进行更新。</p><p id="ea60" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为事实是，我们<em class="mg">知道</em>这个信息在别的地方。无所事事，坐在word文档或电子表格中，而它应该为我们填充网站信息。这就是我们发明CMSs的原因。改变它可能是我们的工作，但它不应该是。</p><p id="9ac1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，即使你没有在你的项目中使用CMS，也很有可能有人在使用Google Drive来保持秩序。也很有可能有人，比如说你的项目经理，也在使用Google Sheets来跟踪事情。一个看似合理的用例是一个包含姓名、角色、电子邮件等的团队花名册。</p><p id="76c2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">简单地查询花名册，以填充球队花名册页面，而不是在阵容发生变化时自己更新它，这不是很好吗？这将为开发人员腾出时间，并消除他们和总理之间沟通不畅的风险，以及两组信息而不是单一来源的事实之间可能存在的差异。</p><p id="b0a0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的朋友们，这正是我们要做的。</p><p id="2e38" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文的最后，我们将有一个简单的、本地运行的web应用程序，显示我们团队的成员，信息来自Google Sheets上的电子表格。</p><p id="527a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在GitHub <a class="ae mh" href="https://github.com/timmalstead/teamRoster" rel="noopener ugc nofollow" target="_blank">找到完成的代码</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/51aa72c60241e2615ac79f043792e023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgF0L0A7gil_EixTVacwOw.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">我希望你的团队和我的一样甜蜜</p></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="cb4e" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">1-准备和安装</h1><p id="64e6" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">重要的事情先来。创建一个新文件夹，在终端中导航到该文件夹，输入<code class="fe nd ne nf ng b">npm init -y</code>创建一个新的<code class="fe nd ne nf ng b">Node</code>项目。</p><p id="e9a6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，在您的终端中输入<code class="fe nd ne nf ng b">touch index.js .env</code>来创建我们的主JavaScript文件和一个环境变量<code class="fe nd ne nf ng b">.env</code>来保存我们的敏感信息。如果你决定分享到GitHub或类似的网站，不要忘记在你的<code class="fe nd ne nf ng b">.gitignore</code>中包含<code class="fe nd ne nf ng b">.env</code>文件。</p><p id="7a70" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在开始真正的编码之前，让我们先做一些快速安装。输入<code class="fe nd ne nf ng b">npm i express googleapis dotenv</code>安装以下内容:</p><ul class=""><li id="1b2b" class="nh ni iq kp b kq kr kt ku kw nj la nk le nl li nm nn no np bi translated"><strong class="kp ir"> Express </strong>:在Node中创建服务器和API的轻量级、非个性化框架。</li><li id="e19c" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated"><strong class="kp ir">Google APIs</strong>:用于访问Google API的节点包，包括我们将要使用的表单和Oauth服务。</li><li id="becb" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated"><strong class="kp ir">Dotenv</strong>:<code class="fe nd ne nf ng b">dotenv</code>包是在节点中配置和使用环境变量的常用选项。这将允许我们在代码中使用这些敏感信息，但在共享时仍然保持匿名。</li></ul><p id="e7fa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之后，在你选择的编辑器中打开它(我喜欢VSCode ),开始使用它！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="aa01" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">2-准备Express服务器</h1><p id="4c6e" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们将在<code class="fe nd ne nf ng b">index.js</code>中创建一个本地运行的quick Express服务器，以确保一切正常运行。</p><p id="8072" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在您的<code class="fe nd ne nf ng b">.env</code>文件中，创建一个名为<code class="fe nd ne nf ng b">PORT</code>的变量，并将其设置为您想要的任何本地端口。对于这个演示，我用了8000。</p><p id="bbce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将这段代码复制到您的<code class="fe nd ne nf ng b">index.js</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">索引. js</p></figure><p id="dd3b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们来分解一下我们正在做的事情:</p><ul class=""><li id="56e4" class="nh ni iq kp b kq kr kt ku kw nj la nk le nl li nm nn no np bi translated">在第一行，我们调用express包用于我们的节点项目。</li><li id="ffca" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">在第二行，我们正在设置要使用的<code class="fe nd ne nf ng b">dotenv</code>包。这将允许我们访问<code class="fe nd ne nf ng b">process.env</code>,其中包含我们稍后将使用的所有敏感信息。</li><li id="6898" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">在第三行，我们将一个变量设置为<code class="fe nd ne nf ng b">p</code>来访问<code class="fe nd ne nf ng b">process.env</code>，这样我们就不必在每次需要访问的时候都输入这个变量。相信我，以后会节省时间的。</li></ul><p id="8a90" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们有一个简单的<code class="fe nd ne nf ng b">get</code>路线。这个函数调用将是我们今天的大部分工作。当您导航到<code class="fe nd ne nf ng b"><a class="ae mh" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a>api/data/</code>或您设置服务器运行的任何端口时，可以访问它。现在我们只想确保一切正常，所以我只是使用<code class="fe nd ne nf ng b">response</code>参数发回一段简单的文本。</p><p id="684b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，我们设置了一个listen函数，将我们的<code class="fe nd ne nf ng b">PORT</code>变量作为第一个参数，将在服务器监听时执行的回调函数作为第二个参数。同样，这给了我们一个机会来测试我们的<code class="fe nd ne nf ng b">.env</code>变量，并确保一切正常工作。</p><p id="340a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在您的终端中键入<code class="fe nd ne nf ng b">node index.js</code>，几秒钟后您应该会看到<code class="fe nd ne nf ng b">console.log</code>消息。然后，在浏览器中导航到适当的本地主机端口。您应该看到您输入的文本作为<code class="fe nd ne nf ng b">response.send</code>的参数。</p><p id="ed09" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">祝贺您——您已经用11行代码创建了一个工作服务器！尽管它还没有做很多事情。别担心，我们将在下一步中解决这个问题。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="7572" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">3-设置谷歌表API和花名册表</h1><p id="847e" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">你可以在这里找到我将要使用的信息。你可以随意把它复制到你自己的硬盘上，或者使用你自己的数据。我还在GitHub的<a class="ae mh" href="https://github.com/timmalstead/teamRoster" rel="noopener ugc nofollow" target="_blank"> repo </a>中的CSV中包含了这些数据。</p><p id="f50b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">复制工作表或创建一个新工作表，并将其命名为<code class="fe nd ne nf ng b">TeamRoster</code>。从顶部的导航栏复制工作表ID。这是在<code class="fe nd ne nf ng b"><a class="ae mh" href="https://docs.google.com/spreadsheets/d/" rel="noopener ugc nofollow" target="_blank">https://docs.google.com/spreadsheets/d</a>/</code>和正斜杠之间找到的URL的一部分，它将是一个长哈希，类似于<code class="fe nd ne nf ng b">1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms</code>。将这个ID放在名为SPREADSHEET_ID的<code class="fe nd ne nf ng b">.env</code>文件中。</p><p id="a3bb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">进入<a class="ae mh" href="https://developers.google.com/sheets/api/quickstart/nodejs" rel="noopener ugc nofollow" target="_blank"> Google的Sheet API节点Quickstart </a>页面，点击蓝色的“启用Google Sheets API”按钮(你可能需要设置一个账户，它应该会启动一个名为Quickstart的项目)。当询问如何配置您的0auth客户端时，选择“Web服务器”并输入您的本地主机URL。下载<code class="fe nd ne nf ng b">credentials.json</code>并把它放在你的项目的根文件夹中。将以下值从<code class="fe nd ne nf ng b">credentials.json </code>复制到您的<code class="fe nd ne nf ng b">.env</code>文件中——标准的命名约定是使用spinning _ SNAKE _ CASE，不带引号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">这就是你的。env文件应该关注这一点</p></figure><p id="1cf3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建一个名为<code class="fe nd ne nf ng b">authorize.js</code>的文件，并复制以下代码。这是在Google的Node Quickstart文件的第三步中找到的代码的修改版本。</p><p id="2bbc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我还没能让他们的代码按原样工作。以下是有效的方法。我猜这些错误是由于API或NPM包的更新导致的，而文档中没有相应的更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">呃，有很多试镜。</p></figure><p id="6bd6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在您的终端中输入<code class="fe nd ne nf ng b">node authorize.js</code>开始授权过程。之后，应该会出现一个提示，上面写着<code class="fe nd ne nf ng b">Authorize this app by visiting this url.</code>单击它并转到授权屏幕。它应该提示您授权此应用程序访问您的工作表信息。不要担心警告告诉你应用程序还没有被批准——你相信自己，不是吗？</p><p id="d31d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之后，它会把你送回你的重定向URL，在URL窗口的端口上附加一个巨大的查询字符串。获取代码信息，它将位于<code class="fe nd ne nf ng b"><a class="ae mh" href="http://localhost:8000/?code=" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/?code=</a></code>和以<code class="fe nd ne nf ng b">&amp;</code>字符开头的查询字符串的另一部分之间。你猜对了，这段代码将是另一个长散列。获取代码并将其输入到终端的readline提示符中。如果一切顺利，它应该会返回一个姓名和专业的列表。</p><p id="a1ce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">恭喜，您已经将Node应用程序配置为从您的Google Sheets帐户中读取。</p><h1 id="491e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">4-从你自己的谷歌表单中获取信息</h1><p id="085f" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">现在，你可能会说:“哎呀，蒂姆，与层叠式回调搏斗很有趣，但我希望我在实际规划路线时不必做太多”。你是对的，你<em class="mg">不应该</em>通过回调地狱来访问你的数据。上面代码的不透明性是我决定写这篇文章的主要原因之一。有更简单的方法来完成上一步中所做的事情，我们将会这样做。自然，我说的是<code class="fe nd ne nf ng b">async</code>和<code class="fe nd ne nf ng b">await</code>。</p><p id="b150" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nd ne nf ng b">async</code>和<code class="fe nd ne nf ng b">await</code>是2017年引入JavaScript的句法糖。简单地说，它们允许我们编写看起来像同步代码的异步代码。他们是伟大的T21。</p><p id="5724" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">完成最后一步后，您的目录中应该有一个<code class="fe nd ne nf ng b">token.json</code>文件。将<code class="fe nd ne nf ng b">"refresh_token"</code>值复制到您的<code class="fe nd ne nf ng b">.env</code>文件中。然后将您的<code class="fe nd ne nf ng b">index.js</code>更改为以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="21f1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那么，我们做了什么？</p><ul class=""><li id="0204" class="nh ni iq kp b kq kr kt ku kw nj la nk le nl li nm nn no np bi translated">我们为Google的API包添加了一个导入。</li><li id="6ee7" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们将<code class="fe nd ne nf ng b">get</code>路由的回调函数改为<code class="fe nd ne nf ng b">async</code>。这告诉程序，在这个函数中的某个点，我们将调用一个以<code class="fe nd ne nf ng b">await</code>开头的操作，在这个操作完成之前，不应该发生任何事情。</li><li id="5bad" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们使用<code class="fe nd ne nf ng b">Oauth</code>创建了一个新的auth对象，并设置了它的安全凭证。</li><li id="6304" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们使用那个<code class="fe nd ne nf ng b">Oauth</code>对象来授权一个新的<code class="fe nd ne nf ng b">Sheets</code>对象。</li><li id="58d1" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们用sheets对象建立了一个异步请求，使用了<code class="fe nd ne nf ng b">await</code>关键字。这个请求的参数是一个对象，包含电子表格的惟一id和一个布尔值，表明我们需要网格数据。网格数据是电子表格中实际包含的数据。</li><li id="2845" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们将从<code class="fe nd ne nf ng b">Sheet</code> s请求的<code class="fe nd ne nf ng b">JSON</code>对象发送给客户端。</li></ul><p id="b176" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">太好了！继续启动您的服务器并导航至<code class="fe nd ne nf ng b"><a class="ae mh" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a>api/data/</code>。</p><p id="f023" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我应该提到，在测试我的API时，我使用了一个名为<a class="ae mh" href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh?hl=en-US" rel="noopener ugc nofollow" target="_blank"> JSON Viewer </a>的Chrome插件。它很简单，有一个干净的布局，并提供语法突出。我经常发现它比Postman或类似的API测试工具更容易、更快捷，尤其是对于简单的<code class="fe nd ne nf ng b">get</code>请求。或者，从版本53开始，Firefox默认启用JSON查看。不过我不喜欢Firefox浏览器的布局，所以我不经常使用它。</p><p id="bf8b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/784dd28ae9f1c79ae453c54c63cb1f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VNEJ88f55lAqZ60UCKcYQ.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">6542行！？</p></figure><p id="0c81" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于八列九行的文本来说，这是一个很大的数据量。不过请记住，这包括<em class="mg">电子表格<em class="mg">中的所有</em>数据和</em>与电子表格相关联的所有<em class="mg">数据。这包括元数据和样式信息。那些东西加起来很快。</em></p><p id="ce73" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">肯定有什么办法能让我们把它剪下来吧？首先，不要叫我雪莉。第二，<em class="mg">我们当然可以！这正是我们下一步要做的。</em></p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="6dba" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">5.减少你的信息</h1><p id="1061" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">您可能已经注意到，被发回的JSON对象是一团乱麻。让我们深入了解这些数据的结构。</p><p id="15bc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建一个名为<code class="fe nd ne nf ng b">teamData</code>的变量来保存我们将从嵌套的JSON中提取的数据。</p><p id="8466" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，在<code class="fe nd ne nf ng b">rosterSheet</code>的六个顶级属性中，我们现在唯一感兴趣的是<code class="fe nd ne nf ng b">data</code>，而在<code class="fe nd ne nf ng b">data</code>中我们唯一感兴趣的是<code class="fe nd ne nf ng b">sheets</code>。这是一个数组，用于保存大型电子表格中每个工作表的数据。如果你从我这里复制信息，你应该只有一个表可以选择，所以继续前进，通过括号符号访问它。</p><p id="2a2c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">到目前为止，我们应该有<code class="fe nd ne nf ng b">const teamData = rosterSheet.data.sheets[0]</code>。</p><p id="7a5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe nd ne nf ng b">sheets[0]</code>中，我们有<em class="mg">另一个</em>数组，名为<code class="fe nd ne nf ng b">data.</code>，和上一个数组一样，它应该只有一个条目，所以用<code class="fe nd ne nf ng b">.data[0].</code>访问它。最后，我们还有一个属性要访问，<code class="fe nd ne nf ng b">.rowData.</code>这样，我们最终得到了相关的数据，我们将发送给客户端:</p><p id="6a0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nd ne nf ng b">const teamData = rosterSheet.data.sheets[0].data[0].rowdata</code>。</p><p id="f5c1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nd ne nf ng b">rowData</code>本身是一个数组，表中每行有一个条目，包含我们需要的单元格值，以及一大堆我们不需要的东西。将以下代码复制到索引中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="35b3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们在第一行之后获取每一行，如果团队成员的状态是活动的，则将包含团队成员所有属性的对象推入一个数组，如果属性丢失，则为“None”。这种排序的额外好处是过滤掉空行。</p><p id="5a55" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我认为这是为什么使用<code class="fe nd ne nf ng b">Sheets</code>对于像这个花名册这样的小数据集是一个好的解决方案，但是对于大数据集却不是。如您所见，由于Google构建数据的方式，我们必须根据数据在数组中的索引来定位数据。这不是最佳选择，很容易搞砸。我的建议是使用<code class="fe nd ne nf ng b">Sheets</code>,只要你正在处理的电子表格的规模仍然很容易处理。如果不是，那就另想办法。</p><p id="c607" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们减少了数据之后，我们将在一个JSON对象中把它发送给客户机，从我们最初的<code class="fe nd ne nf ng b">teamRoster</code>对象借用<code class="fe nd ne nf ng b">status</code>和<code class="fe nd ne nf ng b">statusText</code>。</p><p id="8f5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果一切顺利，当您启动服务器并在浏览器中导航到<code class="fe nd ne nf ng b">/api/data/</code>时，您应该会看到类似这样的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/329666f29ad5e6c40d7362148b1570d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3At7ZsTbIzGuOpeDmmNJ6w.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">这还差不多</p></figure><p id="ed13" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">太棒了。我们成功地向Sheets发出了一个安全请求，将它发送到我们的Express服务器，从中提取我们需要的数据并发送给客户端。</p><p id="1c6e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们真正完成我们的服务器之前，我们将在我们的路由中添加一些JSON备份和错误处理。首先，让我们建立我们的前端，让我们有一些好看的东西。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="aaaf" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">6.设置React</h1><p id="8792" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><code class="fe nd ne nf ng b">create-react-app</code>是React的开发者脸书提供的一个神奇的工具，它可以让你在几分钟内启动并运行一个实用的React应用。虽然这不能代替理解<em class="mg">如何从零开始引导一个React项目，但它将非常适合我们这个项目的目的。通过在终端中输入<code class="fe nd ne nf ng b">npm i -g create-react-app</code>进行全局安装。</em></p><p id="f3a6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">完成后，转到项目的根目录，在终端中输入以下内容:<code class="fe nd ne nf ng b">npx create-react-app client</code>。这将在名为client的文件夹中安装最新版本的<code class="fe nd ne nf ng b">create-react-app</code>的实例。我写这篇文章时注意到的一件很酷的事情是，CRA现在知道如果你在一个已经有git的环境中，不需要安装git。进步！</p><p id="e864" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这可能需要一点时间，但是一旦完成，你的项目中应该有两个<code class="fe nd ne nf ng b">package.json</code>文件——一个用于Express服务器，一个用于React客户端。打开它们，我们将对它们做两个微小的改变，当我们运行完整的程序时，这些改变将会产生巨大的影响。</p><p id="d0ad" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在根目录下的文件中，将以下代码插入<code class="fe nd ne nf ng b">"scripts"</code>:</p><p id="0d7e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nd ne nf ng b">"start": "node index.js -ignore './client' "</code></p><p id="9ac0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将确保从一个终端运行我们的服务器不会干扰在另一个终端上运行我们的客户机。</p><p id="9d5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在客户端目录下的文件中，在<code class="fe nd ne nf ng b">"private"</code>下方插入以下代码:</p><p id="6bd5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nd ne nf ng b">"proxy": "http://localhost:8000"</code></p><p id="ca0e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将允许我们轻松地调用与客户端同时运行的服务器。</p><p id="ff17" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后将下面的代码复制到<code class="fe nd ne nf ng b">client/src</code>文件夹中的<code class="fe nd ne nf ng b">App</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0c31" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的应用程序中，组件一安装好，我们就在我们的<code class="fe nd ne nf ng b">useEffect</code>钩子中进行调用。它将对我们的Express服务器的<code class="fe nd ne nf ng b">get</code>路由进行<code class="fe nd ne nf ng b">async</code>调用，并读取返回的JSON数据。如果全部解析成功，它会将数组设置为状态。一旦数组被设置成状态，组件返回将<code class="fe nd ne nf ng b">map</code>通过数据并为数组中的每一项呈现一个团队成员。</p><p id="5a56" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在你的根目录和客户端目录中启动<code class="fe nd ne nf ng b">npm start</code>，让奇迹发生。如果一切顺利，您应该会看到类似这样的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/9f7726852d9297f01c308e1ff238011c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NvUQJa3AxQFVbNMWseROg.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">梦之队</p></figure><p id="2afe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你做到了！</p><p id="6727" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">去吧，稍微摆弄一下。当您在电子表格中进行更改时，它应该会在您刷新页面时反映在应用程序上。只要保持命名一致，就应该是金色的。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="6f6c" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">7.添加错误处理和备份</h1><p id="9074" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">作为有思想的开发人员，我们设置一些错误处理和备份怎么样？</p><p id="c24d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将根目录中的<code class="fe nd ne nf ng b">index.js</code>文件改为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0a9a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们来分解我们的变化:</p><ul class=""><li id="a26d" class="nh ni iq kp b kq kr kt ku kw nj la nk le nl li nm nn no np bi translated">我们导入了内置的<code class="fe nd ne nf ng b">Node</code>包<code class="fe nd ne nf ng b">fs</code>代表“文件服务”。这是一个在<code class="fe nd ne nf ng b">Node</code>中创建、读取和修改文件的有用方法的集合。</li><li id="fdab" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们添加了一个变量来表示JSON文件的路径和标题，我们将用它来备份我们的请求数据。</li><li id="f649" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们把路线包在了<code class="fe nd ne nf ng b">try</code>和<code class="fe nd ne nf ng b">catch</code>街区。这些允许我们定义我们想要尝试的行为，以及在抛出错误时要遵循的行为。</li><li id="3b8b" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">在第一个<code class="fe nd ne nf ng b">try</code>块的末尾，我们使用<code class="fe nd ne nf ng b">fs</code>方法<code class="fe nd ne nf ng b">writeFileSync</code>在本地服务器上备份一份JSON。</li><li id="443a" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">在我们的第一个<code class="fe nd ne nf ng b">catch</code>块中，我们定义了两个变量来帮助定义对客户端的JSON响应。</li><li id="90cd" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">我们定义了另一组<code class="fe nd ne nf ng b">try</code>和<code class="fe nd ne nf ng b">catch</code>模块<em class="mg">来进一步定义我们的响应。</em></li><li id="f302" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">在我们的第二个<code class="fe nd ne nf ng b">try</code>块中，我们访问了用<code class="fe nd ne nf ng b">fs.writeFileSync</code>和对应的<code class="fe nd ne nf ng b">fs.readFileSync</code>写的最后一个成功的JSON备份。这将作为故障保险发送给客户端。</li><li id="63ac" class="nh ni iq kp b kq nq kt nr kw ns la nt le nu li nm nn no np bi translated">如果<em class="mg">失败，我们用第二个<code class="fe nd ne nf ng b">catch</code>块将两个错误的信息发送回客户端。</em></li></ul></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="85cc" class="lj lk iq bd ll lm my lo lp lq mz ls lt jw na jx lv jz nb ka lx kc nc kd lz ma bi translated">最后的想法</h1><p id="6736" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">就是这样！您设置了一个Express服务器，使用Google对其进行授权，进入您的电子表格，将数据带回Express，对其进行排序和简化，将其发送到您的React客户端，并在您的Express服务器中设置错误处理和备份。</p><p id="0b22" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">希望本教程已经足够清楚地分解了我们所做的事情，给你一些在你自己的项目中使用的想法。我很期待看到你做的东西！</p><p id="5549" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请让我知道你是否喜欢这篇文章——我可能会写更多。也许是带有<a class="ae mh" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>的东西？你怎么想呢?</p></div></div>    
</body>
</html>