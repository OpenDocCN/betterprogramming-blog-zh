<html>
<head>
<title>Simple API in Go with Fiber (2022)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">光纤Go中的简单API(2022)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-api-in-go-with-fiber-1449198e0237?source=collection_archive---------1-----------------------#2022-04-05">https://betterprogramming.pub/simple-api-in-go-with-fiber-1449198e0237?source=collection_archive---------1-----------------------#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Fiber、Postgres和GORM在Go中构建一个简单的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/001a746dadbbdce7bfff989d790a37e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jh2FKUh4fvlD-y0_9ec1WQ.png"/></div></div></figure><p id="b5df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据StackOverflow开发人员调查和TIOBE指数，Go(或Golang)近年来越来越受欢迎，尤其是在后端开发人员和从事基础设施自动化的DevOps团队中。这个理由足够写一个简单的教程介绍你去了。</p><p id="65d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是值得学习的，所以在本文中，我想向您展示一个简单的指南，告诉您如何使用Fiber和GORM在Go中开发一个可扩展但简单的CRUD API。为了简单起见，我们不使用Docker。</p><h1 id="dbc0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是纤维？</h1><p id="a55b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Fiber是一个受Express启发的web框架，构建在Fasthttp之上，fast http是Go最快的HTTP引擎。旨在通过零内存分配和性能来简化快速开发。因此，如果你来自NodeJS背景，Fibe可能是一个很好的选择。</p><h1 id="df5e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">我们要建造什么？</h1><p id="52b9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这个项目将会非常经典。我们将构建一个简单的基于CRUD的API。因此，我们将拥有不同的创建、读取、更新和删除端点。</p><h1 id="b1fe" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">先决条件</h1><p id="00cf" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">你需要对围棋有一个基本的了解。我会选择<a class="ae lq" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>作为我的代码编辑器。你可以用你喜欢的任何东西。但是请记住，您将在本文中看到一次命令<code class="fe mo mp mq mr b">code .</code>。这是一个特定于VSCode (Visual Studio Code)的命令，用于打开VSCode中的当前目录。</p><p id="1cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要安装这些:</p><ul class=""><li id="026d" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated">在本地机器上安装<a class="ae lq" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank"> Go </a></li><li id="8b35" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">在本地机器上安装<a class="ae lq" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> Postgres </a></li></ul><p id="fd5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两者的任何最新版本都可以。但是，我的Go版本是1.18，PostgreSQL是14版。</p><h1 id="718a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建数据库</h1><p id="3856" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们需要创建一个Postgres数据库。我知道，每个人都有不同的处理方式，有些人使用GUI，但我们将使用我们的终端。同样，您需要在您的机器上安装Postgres。如果您安装了Postgres，以下四个命令将在Linux、Mac和Windows机器上运行。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="1f80" class="nk ls it mr b gy nl nm l nn no">$ psql postgres<br/>$ CREATE DATABASE go_fiber_api;<br/>$ \l<br/>$ \q</span></pre><ul class=""><li id="c0cd" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated"><code class="fe mo mp mq mr b">psql postgres</code>使用用户<code class="fe mo mp mq mr b">postgres</code>打开<code class="fe mo mp mq mr b">psql</code> CLI</li><li id="fa8e" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><code class="fe mo mp mq mr b">CREATE DATABASE go_fiber_api;</code>创建我们需要的数据库</li><li id="2c9d" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><code class="fe mo mp mq mr b">\l</code>列出所有数据库</li><li id="cbe2" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">CLI退出</li></ul><p id="ad65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们成功地执行了所有四个命令之后，我的终端看起来应该是这样的。如我们所见，数据库<code class="fe mo mp mq mr b">go_fiber_api</code>被创建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/56567344c9b4112ac8b8d96c6ec5c237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhzT7v431D6eHY2CcoB9xA.png"/></div></div></figure><h1 id="46b0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">项目设置</h1><p id="acf5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们将启动我们的项目并安装我们需要的模块。</p><blockquote class="nq nr ns"><p id="6d54" class="ku kv nt kw b kx ky ju kz la lb jx lc nu le lf lg nv li lj lk nw lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it">小心:</em> </strong> <em class="it">用你的Github用户名替换你的_用户名。</em></p></blockquote><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="a550" class="nk ls it mr b gy nl nm l nn no">$ mkdir go-fiber-api<br/>$ cd go-fiber-api<br/>$ code .<br/>$ go mod init github.com/YOUR_USERNAME/go-fiber-api</span></pre><p id="68f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们安装Fiber、GORM和Viper。我们使用Viper来管理环境变量。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="0dce" class="nk ls it mr b gy nl nm l nn no">$ go get github.com/spf13/viper<br/>$ go get github.com/gofiber/fiber/v2<br/>$ go get gorm.io/gorm<br/>$ go get gorm.io/driver/postgres</span></pre><p id="8bbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们继续最后的项目结构。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="6979" class="nk ls it mr b gy nl nm l nn no">$ mkdir -p cmd pkg/books pkg/common/db pkg/common/config/envs pkg/common/models</span></pre><p id="bc2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，让我们添加一些文件。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="563b" class="nk ls it mr b gy nl nm l nn no">$ touch Makefile cmd/main.go pkg/books/add_book.go pkg/books/controller.go pkg/books/delete_book.go pkg/books/get_book.go pkg/books/get_books.go pkg/books/update_book.go pkg/common/db/db.go pkg/common/config/envs/.env pkg/common/models/book.go pkg/common/config/config.go</span></pre><p id="f774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在创建我们的项目后，文件结构应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6db799fa44dce8e369e3019a59c7fb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWK_1dOkm4Y7jYqSgk2G4A.png"/></div></div></figure><p id="4e63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，该编码了。</p><h1 id="7ee3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">环境变量</h1><p id="aef1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们需要添加一些环境变量来存储我们将要监听的应用程序端口和数据库的URL。请记住，用您的数据库数据替换<code class="fe mo mp mq mr b">DB_USER</code>、<code class="fe mo mp mq mr b">DB_PASSWORD</code>、<code class="fe mo mp mq mr b">DB_HOST</code>和<code class="fe mo mp mq mr b">DB_PORT</code>。</p><p id="a770" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/common/envs/.env</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b891" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，它在我的本地机器上会是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="24b8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">配置</h1><p id="bca6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/common/config/config.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="2a35" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">书籍模型</h1><p id="61c4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这里，我们将创建图书模型/实体。<code class="fe mo mp mq mr b">gorm.Model</code>会为我们添加<code class="fe mo mp mq mr b">ID</code>、<code class="fe mo mp mq mr b">CreatedAt</code>、<code class="fe mo mp mq mr b">UpdatedAt</code>、<code class="fe mo mp mq mr b">DeletedAt</code>等属性。</p><p id="1b87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们添加了3个字符串属性。最后的<code class="fe mo mp mq mr b">json</code>标签为GORM提供了Postgres数据库中每一列名称的信息。</p><p id="0217" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/common/models/book.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="f0fd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据库初始化</h1><p id="acf4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">书模型做好了。现在，我们配置GORM并自动迁移我们刚刚创建的模型。只要我们运行这个应用程序，这个<code class="fe mo mp mq mr b">AutoMigrate</code>函数就会为我们创建<code class="fe mo mp mq mr b">books</code>表。</p><p id="dcca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/common/db/db.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="39e9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">主文件</h1><p id="12f5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这是我们的引导文件。我们会在这里做很多事情。</p><ul class=""><li id="7f77" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated">初始化Viper来处理我们的环境变量</li><li id="aca4" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">基于GORM的数据库初始化</li><li id="5c1f" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">添加简单的“/”路线</li><li id="016c" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">启动应用程序</li></ul><p id="dcee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们稍后将再次更改该文件。</p><p id="7aed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">cmd/main.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们测试我们项目的当前版本。通常，应用程序会在调试模式下运行，所以我们会得到一些警告，忽略它们。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="41ea" class="nk ls it mr b gy nl nm l nn no">$ go run cmd/main</span></pre><p id="e839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制台内部的输出。最后一行很重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/641d2c7132ec174b897b07abe2ae7ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGDEXYhBw6rFcljqrrnIfA.png"/></div></div></figure><p id="1094" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们访问<a class="ae lq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/24768b5a286ed0cfa0995838b405c28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3kEs6FAzG_CYWpHiiWWfg.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">在浏览器中打开应用程序</p></figure><p id="7e98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了。我们可以看到我们的应用程序的端口。这意味着一切都按预期运行。</p><h1 id="68aa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">图书管理员</h1><p id="e4af" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">太好了，一切正常。我们将替换这个输出，所以不要担心。现在，让我们为我们的图书API添加一些处理程序。</p><h2 id="3600" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">控制器</h2><p id="b85b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">图书处理程序/路径将基于所谓的<a class="ae lq" href="https://go.dev/tour/methods/4" rel="noopener ugc nofollow" target="_blank">指针接收器</a>，为此，我们定义了它的结构。这个结构稍后将接收数据库信息，因此每当我们调用图书处理程序/路由时，我们都可以访问GORM。我们稍后将再次更改该文件。</p><p id="e3fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/books/controller.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="1263" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">添加图书处理程序</h2><p id="afea" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">所以这个文件很有意思。导入之后，我们为请求体定义一个结构。在第16行你可以看到我们在上一步定义的<strong class="kw iu">指针接收器</strong>。在第31行你可以看到，我们使用了这个<strong class="kw iu">指针接收器</strong>，它的变量名就是简单的<code class="fe mo mp mq mr b">h</code>。</p><p id="8468" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他一切都很简单。我们获取请求体，声明一个新的book变量，将请求体与这个book变量合并，并创建一个新的数据库条目。然后，我们用图书信息创建一个响应。</p><p id="6fee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe mo mp mq mr b">pkg/books/add_book.go</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="c70f" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">获取书籍处理程序</h2><p id="3169" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这条路线上，我们将返回数据库中的所有书籍。这种方法现在工作得很快，但是一旦有更大的数据需要处理，最好使用分页方法。</p><p id="aa81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/books/get_books.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="f967" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">获取图书处理程序</h2><p id="9836" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这里，我们只根据从参数中获得的ID来响应一本书。</p><p id="2936" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们添加代码到<code class="fe mo mp mq mr b">pkg/books/get_book.go</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="c785" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">更新图书处理程序</h2><p id="c666" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果我们添加一本书，我们也应该有更新已创建书籍的选项。这条路线类似于我们之前编码的<code class="fe mo mp mq mr b">AddBook</code>路线。</p><p id="dc1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/books/update_book.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="21f0" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">删除图书处理程序</h2><p id="c278" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这是我们在本文中的最后一条路线。这里，我们根据ID删除一本书，但前提是数据库中存在所需的条目。我们只用一个HTTP状态码来响应。</p><p id="3e1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们给<code class="fe mo mp mq mr b">pkg/books/delete_book.go</code>添加代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="05e7" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">控制器(再次)</h2><p id="4e95" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">路线完成了。现在我们需要再次修改控制器文件。这一次，我们创建了一个名为<code class="fe mo mp mq mr b">RegisterRoutes</code>的函数，它很好地解释了它的作用，对吗？</p><p id="58d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你记得听筒指针吗？这里我们得到了路由/处理程序的接收指针。</p><p id="0b67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将文件<code class="fe mo mp mq mr b">pkg/books/controller.go</code>从:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bfa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">收件人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="f381" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">主文件(再次)</h2><p id="b85f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">此外，我们必须再次修改我们的主文件。之前，我们只是初始化数据库。但是这一次，我们得到了它的返回并注册了我们的路由/处理程序。</p><p id="d573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将文件<code class="fe mo mp mq mr b">cmd/main.go</code>从:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7c73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">收件人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="3cb0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">生成文件</h1><p id="109d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这是可选的。这里我们可以设置一些脚本来简化命令。例如，我们定义一个<code class="fe mo mp mq mr b">server</code>脚本来运行应用程序。因此，我们不是由<code class="fe mo mp mq mr b">go run cmd/main</code>来运行应用程序，而是由<code class="fe mo mp mq mr b">make server</code>来运行它。这个例子并不好，因为实际的命令非常短，但是想象一下，您将不得不处理更长的命令。</p><p id="a4e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将代码添加到根目录下的<code class="fe mo mp mq mr b">Makefile</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="ce2f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">运行应用程序</h1><p id="41cc" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">一切都搞定了！不再编码了。现在，让我们运行应用程序。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="4f31" class="nk ls it mr b gy nl nm l nn no">$ make server</span></pre><p id="29f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="eb60" class="nk ls it mr b gy nl nm l nn no">$ go run cmd/main.go</span></pre><p id="05a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出应该是这样的。除了警告之外，我们可以看到，我们的路由已经确定，应用程序在端口3000上运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/49ddaa1902534f9a12a27eea3d0adc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctgDQGyf37DmJGmtmgpVBA.png"/></div></div></figure><h1 id="d4f7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试端点</h1><p id="db04" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，我们可以测试刚刚创建的两条路由。我们可以测试它，通过使用软件如<a class="ae lq" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>、<a class="ae lq" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>，或者我们简单地运行CURL命令。</p><h2 id="d4dc" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">帖子:添加新书</h2><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="dc14" class="nk ls it mr b gy nl nm l nn no">$ curl --request POST \<br/>  --url http://localhost:3000/books<em class="nt"> \<br/>  </em>--header 'Content-Type: application/json' \<br/>  --data '{<br/>    "title": "Book A",<br/>    "author": "Kevin Vogel",<br/>    "description": "Some cool description"<br/>  }'</span></pre><h2 id="eacc" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">获取:获取所有书籍</h2><p id="6e98" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">别忘了，您也可以在浏览器中运行get命令。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="8915" class="nk ls it mr b gy nl nm l nn no">$ curl --request GET --url http://localhost:3000/books</span></pre><h2 id="3377" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">获取:通过ID获取图书</h2><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="4586" class="nk ls it mr b gy nl nm l nn no">$ curl --request GET --url http://localhost:3000/books/1</span></pre><h2 id="a03f" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">PUT:按ID更新图书</h2><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="1bfe" class="nk ls it mr b gy nl nm l nn no">$ curl --request PUT \<br/>  --url http://localhost:3000/books/1 \<br/>  --header 'Content-Type: application/json' \<br/>  --data '{<br/> "title": "Updated Book Name",<br/> "author": "Kevin Vogel",<br/> "description": "Updated description"<br/>}'</span></pre><h2 id="7648" class="nk ls it bd lt of og dn lx oh oi dp mb ld oj ok md lh ol om mf ll on oo mh op bi translated">删除:按ID删除图书</h2><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="3e3a" class="nk ls it mr b gy nl nm l nn no">$ curl --request DELETE --url http://localhost:3000/books/1</span></pre><p id="e450" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们完了！太好了。别忘了，我已经把这个项目上传到了<a class="ae lq" href="https://github.com/hellokvn/go-fiber-api" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="5689" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读这篇关于如何在Go with Fiber中构建一个可扩展但简单的API的文章。我希望，你能学到新的东西。如果你有问题，请告诉我。</p><p id="ed6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div></div>    
</body>
</html>