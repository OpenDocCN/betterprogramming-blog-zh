<html>
<head>
<title>Cross-Database Associations in Sequelize ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sequelize ORM中的跨数据库关联</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cross-database-associations-in-sequelize-orm-2be18091a918?source=collection_archive---------1-----------------------#2019-06-11">https://betterprogramming.pub/cross-database-associations-in-sequelize-orm-2be18091a918?source=collection_archive---------1-----------------------#2019-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7628" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果可能的话，不要创建两个或更多单独的查询</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d155e1ee44a57008fef4d7a5dafc9b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94E0ASvXAAvvUeSOto9vSg.png"/></div></div></figure><p id="40b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经使用<a class="ae ln" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank">序列</a>很多年了，它对我来说是一个很好的工具。我使用<a class="ae ln" href="http://docs.sequelizejs.com/manual/scopes.html" rel="noopener ugc nofollow" target="_blank">范围</a>和<a class="ae ln" href="http://docs.sequelizejs.com/manual/associations.html" rel="noopener ugc nofollow" target="_blank">关联</a>实现了大量非常大且复杂的查询。</p><p id="a0bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在某种程度上，我认为我几乎成为了这方面的专家，能够做任何需要做的事情，除了一件事——跨数据库连接。</p><p id="19cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，这是一场巨大的斗争，因为一些应用程序使用多个数据库，并且需要一些查询来从其中几个数据库获取相关数据。有很多关于堆栈溢出和GitHub问题的主题，但是没有一个有具体的步骤来实现它。</p><p id="e01c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很长一段时间，我不得不手动编写查询，用<code class="fe lo lp lq lr b">sequelize.query</code>执行它们。</p><p id="ccd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它对我来说工作得很好，尤其是将它们与<a class="ae ln" href="http://docs.sequelizejs.com/manual/hooks.html" rel="noopener ugc nofollow" target="_blank">模型挂钩</a>结合起来，但是它总是困扰着我，当可以使用一个查询时，我不得不进行两个或更多单独的查询。</p><p id="1293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一些代码。比方说，我们有两个数据库:一个包含用户和订单，另一个包含产品。用户可以有多个订单，订单可以有多个产品:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="aef2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模型定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ebbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建两个顺序数据库连接实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d158" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并成立了一些协会:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f30b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以使用自动生成的模型方法来创建和查看属于特定订单的产品:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c191" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果我们试图使用<code class="fe lo lp lq lr b">include</code> <strong class="kt ir"> </strong>选项，我们将会遇到以下错误</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="014b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续解决这个问题。</p><p id="a5ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您需要做的第一件事是手动调整Sequelize数据库连接实例，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，将模式名称添加到产品型号选项中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="61f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，您需要手动更新关联范围，因为默认的关联仍然会尝试点击<code class="fe lo lp lq lr b">users_and_orders</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2fd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答对了。现在，您可以使用不同数据库中的表创建多个复杂的查询。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="7b87" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">更深的嵌套</strong></h1><p id="99ca" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如果您想进行更深层次的嵌套，请确保使用文字字符串表示，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c615" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">黑客快乐！</p></div></div>    
</body>
</html>