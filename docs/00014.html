<html>
<head>
<title>Modern Approach of JavaScript Bundling With Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript与Webpack捆绑的现代方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-approach-of-javascript-bundling-with-webpack-3b7b3e5f4e7?source=collection_archive---------0-----------------------#2017-02-13">https://betterprogramming.pub/modern-approach-of-javascript-bundling-with-webpack-3b7b3e5f4e7?source=collection_archive---------0-----------------------#2017-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9f67de4bf12f882f6203cdec615fbaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQYcOLLvLlO97_2BR_i1Wg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">布林教区在<a class="ae kf" href="https://unsplash.com/search/photos/pebbles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="087d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名前端开发人员，我曾在各种电子商务网站上工作过。一开始，我使用单独的脚本标签包含了每个JavaScript文件。但是在经历了一些关于前端性能的惨痛教训后，我开始合并并最小化网站的脚本。还采用从CDN服务器引用供应商和框架脚本作为惯例。</p><p id="f3e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我必须承认，在一段时间内，这种方法效果很好。但是，当我从纯粹的前端开发人员转型为全栈式开发人员，并学习C#和PHP后端开发的优点时——特别是如何将依赖关系包含在后端代码中——我开始更多地面对这种方法的缺点。我特别不喜欢的一点是幕后的魔术。当您在标记中包含一些库——jQuery作为单独<script>——然后编写一些网站的JavasScript代码时，根据jQuery API，代码中不包含jQuery。它只是自动工作&lt;em class="le"&gt;&lt;/em&gt;。&lt;/root&gt;</script></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="3684" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">过时的方式</h1><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/9de317978aa1a7ac400883693eded064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnZNevbx5aFnWktUaloQKg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">一种过时的JavaScript文件包含方法</p></figure><p id="d738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图展示了<em class="le">自动特效</em>的效果。但正如我们所知，这并不神奇。这是我们用来引用使我们的网站工作所必需的依赖关系的方法。</p><p id="a196" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，这种方法有两个主要缺陷。首先，全局名称空间被许多全局变量污染了。从第三方库开始，如jQuery、Angular、Lodash和其他第三方插件，到我们自己的实用程序、助手和服务脚本，因为它们是全局添加的。在这里，加载和执行的顺序很重要。</p><p id="e016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，我们对主脚本隐藏了依赖关系。我们必须假设之前已经加载了必要的脚本，并且我们可以安全地使用它们的API。有时，我们必须切换上下文以确保这些脚本包含在内并可供我们使用，或者我们在标记文件中添加额外的脚本。最后，要查看应用程序、网站或视图是否正常工作，我们必须启动它，并验证所有内容都正确加载和运行。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="d852" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">更现代的方法</h1><p id="3778" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">随着web应用和现代前端框架的兴起，JavaScript开发过程最终开始转变。我们已经看到我们开发代码的方式发生了巨大的变化。其中一个过程，静态文件捆绑，展示了其中的一些变化。</p><p id="3708" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用服务器端技术完成的任务将从后端框架中移除。我们现在使用基于现代前端技术的工具。例如，可以使用微软捆绑所有项目的JavaScript。AspNet版本5之前的AspNet.Optimization包</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="8a2b" class="mz ln it mv b gy na nb l nc nd">// App_Start\BundleConfig.cs<br/>public static void RegisterBundles(BundleCollection bundles)<br/>{<br/>  bundles.Add(new ScriptBundle("~/Scripts/scripts.js").Include(<br/>    "~/Scripts/lib/jquery-3.1.1.js",<br/>    "~/Scripts/lib/timepicker/jquery.timepicker.js",<br/>    "~/Scripts/lib/jquery.datetimepicker.js",<br/>    "~/Scripts/textExtensions.js",<br/>    "~/Scripts/numberExtensions.js",<br/>    "~/Scripts/app.js"));<br/>}</span><span id="218d" class="mz ln it mv b gy ne nb l nc nd">&lt;!-- And then you just render the bundle in _Layout.cshtml --&gt;<br/>  @Scripts.Render(“~/Scripts/scripts.js”)<br/>&lt;/body&gt;</span></pre><p id="bcb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在ASP.NET 5中使用来自Microsoft . aspnet . MVC . tag helpers的<environment>标签做同样的事情</environment></p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="9c1a" class="mz ln it mv b gy na nb l nc nd">&lt;!-- _Layout.cshtml --&gt;<br/>&lt;environment names="Development"&gt;<br/>    &lt;script src="~/Scripts/lib/jquery-3.1.1.js"&gt;&lt;/script&gt;<br/>    &lt;script src="~/Scripts/lib/timepicker/jquery.timepicker.js"&gt;&lt;/script&gt;<br/>    &lt;script src="~/Scripts/lib/jquery.datetimepicker.js"&gt;&lt;/script&gt;<br/>    &lt;script src="~/Scripts/textExtensions.js"&gt;&lt;/script&gt;<br/>    &lt;script src="~/Scripts/numberExtensions.js"&gt;&lt;/script&gt;<br/>    &lt;script src="~/Scripts/app.js"&gt;&lt;/script&gt;<br/>&lt;/environment&gt;<br/>&lt;environment names="Staging,Production"&gt;<br/>    &lt;script src="~/Scripts/scripts.js" asp-append-version="true"&gt;&lt;/script&gt;<br/>&lt;/environment&gt;</span></pre><p id="2cb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们可以看到一个特定的后端框架如何处理捆绑。但是最终，所有可以用JavaScript完成的事情都会用JavaScript来完成。因为已经有很多工具可以实现这一点，所以让我们来看看其中的一个——web pack。这是目前非常流行的工具之一。</p><h2 id="bc71" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">网络包</h2><figure class="ml mm mn mo gt ju gh gi paragraph-image"><a href="https://webpack.js.org/"><div class="gh gi nq"><img src="../Images/be4827e1f61016f7428f1d7fbf058602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*aYF1YvVwfqQeWFq18oD5dw.jpeg"/></div></a><p class="kb kc gj gh gi kd ke bd b be z dk translated">用于脚本捆绑和更多信息的Webpack网站</p></figure><p id="1966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Webpack是一个现代的静态文件捆绑工具。在JavaScript文件捆绑的情况下，它有助于消除我们的标记中对排序的&lt;脚本&gt;标签的隐式依赖。我们没有包含许多单独的脚本，而是包含了使用相同&lt;脚本&gt;标签的单个或几个包。</p><p id="c065" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们应该首先创建这些包。为了创建包，我们需要配置Webpack。当然，Webpack应该安装在机器上——例如通过命令<code class="fe nr ns nt mv b">npm install webpack --save-dev</code>。</p><p id="88ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最起码，Webpack需要的只是一个入口点和输出。然后，只需执行以下命令就可以调用它:</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="7e2a" class="mz ln it mv b gy na nb l nc nd">./node_modules/.bin/webpack app/entry.js dist/output.js</span></pre><p id="0caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，Webpack将加载entry.js，并在其中查找<code class="fe nr ns nt mv b">import</code>或<code class="fe nr ns nt mv b">require</code>关键字，以确定它是否应该加载更多的依赖项。如果找到依赖项，它将递归地加载它们，并将它们包含在输出文件中。</p><h2 id="f08d" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">JavaScript模块</h2><p id="8e18" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">如前一节所述，脚本文件可以包含由<code class="fe nr ns nt mv b">import</code>或<code class="fe nr ns nt mv b">require</code>引用的依赖项。</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="d4ae" class="mz ln it mv b gy na nb l nc nd">// CommonJS<br/>require ('lodash')<br/>console.log(_);</span><span id="e032" class="mz ln it mv b gy ne nb l nc nd">// ECMA6<br/>import 'lodash'<br/>console.log(_);<br/>// Notice currently you need to transpile ECMA6 import using for example Babel to make it run in browsers</span></pre><p id="793c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这类似于在。NET框架，方法是使用:</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="afd1" class="mz ln it mv b gy na nb l nc nd">using Microsoft.AspNetCore.Authorization;<br/>using Microsoft.AspNetCore.Identity;</span></pre><p id="91c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者像Symfony 2框架一样:</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="d1e5" class="mz ln it mv b gy na nb l nc nd"><strong class="mv iu">use </strong>Symfony\Component\HttpFoundation\Request;<br/><strong class="mv iu">use </strong>Symfony\Component\HttpFoundation\Response;</span></pre><p id="5c3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是为了指出一个事实，即人们可以使用JavaScript文件中引用依赖项的特性。使用默认的Webpack配置，它将捆绑一个与当前浏览器不兼容的输出脚本。正如注释中提到的，我们需要处理包含导入或需求的脚本文件。这可以使用Babel JavaScript transformer来完成，它的任务是将ECMA6中编写的JavaScript翻译成ECMA5 JavaScript。你可以在<a class="ae kf" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> Mozzila开发者网络</a>网站上找到更多关于JavaScript <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">导入</a>和<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" rel="noopener ugc nofollow" target="_blank">导出</a>的信息。</p><h2 id="c875" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">以Webpack的方式捆绑JavaScript</h2><p id="6e40" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">通过提供条目文件和输出路径，您可以使用CLI命令捆绑您的JavaScript。Webpack将自动解析来自<code class="fe nr ns nt mv b">import</code>和<code class="fe nr ns nt mv b">require</code>的所有依赖项，并将它们与您的应用程序脚本捆绑成一个输出。</p><p id="0f2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这只是它能做到的最低限度。为了扩展功能，我们可以创建一个Webpack配置文件，并配置bundler在处理JavaScript时执行的各种任务。</p><h2 id="7ae6" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">配置</h2><p id="a3fb" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">首先，我们需要创建一个<code class="fe nr ns nt mv b">webpack.config.js</code>文件，并需要来自node_modules的Webpack。</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="4727" class="mz ln it mv b gy na nb l nc nd">// <!-- -->webpack.config.js<br/>var webpack = require('webpack');</span><span id="3d01" class="mz ln it mv b gy ne nb l nc nd">module.exports = {<br/><strong class="mv iu">    entry: {<br/>        entry: __dirname + '/entry.js'<br/>    },<br/>    output: {<br/>        filename: '[name].bundle.js'<br/>    }</strong><br/>}</span></pre><p id="ff7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们已经提供了<strong class="ki iu">条目</strong>文件作为<code class="fe nr ns nt mv b">entry.js</code>，并在执行Webpack的当前目录的路径前加上前缀。还提供了放置捆绑JavaScript内容的<strong class="ki iu">输出</strong>路径。注意文件的<code class="fe nr ns nt mv b">[name]</code>前缀。这将指示Webpack以<code class="fe nr ns nt mv b">.bundle.js</code>结尾连接条目文件名。现在通过执行CLI命令，</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="c4af" class="mz ln it mv b gy na nb l nc nd">./node_modules/.bin/webpack</span></pre><p id="16b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将在当前模块的目录下创建一个<code class="fe nr ns nt mv b">entry.bundle.js</code>文件。</p><h2 id="e67b" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">装载机</h2><p id="660c" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">正如我之前写的，如果你在脚本中使用<code class="fe nr ns nt mv b"><strong class="ki iu">import</strong></code>引用JavaScript依赖，你必须使用Babel将它从ECMA6转换到ECMA5。Webpack可以通过利用其加载器特性来动态完成这项工作。为了让它工作，我们必须首先安装必要的节点模块<code class="fe nr ns nt mv b"><strong class="ki iu">npm install babel-core babel-loader babel-preset-es2015</strong></code>并用模块部分更新webpack.config.js。</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="fa77" class="mz ln it mv b gy na nb l nc nd">// webpack.config.js<br/>var webpack = require('webpack')</span><span id="fde5" class="mz ln it mv b gy ne nb l nc nd">module.exports = {<br/>    entry: {<br/>        entry: __dirname + '/entry.js'<br/>    },<br/>    output: {<br/>        filename: '[name].bundle.js'<br/>    },<br/><strong class="mv iu">    module: {<br/>        loaders: [<br/>            {<br/>                test: /\.js$/,<br/>                loader: 'babel-loader',<br/>                exclude: /node_modules/,<br/>                query: {<br/>                    presets: ['es2015']<br/>                }<br/>            }<br/>        ]<br/>    },</strong><br/>}</span></pre><p id="31cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本模块部分，我们可以设置许多在处理时应用于JavaScript的加载器。请注意，我们已经将其设置为所有文件都以*结尾。js，不包括node_modules，应该通过babel-loader来处理。因此，它将生成ECMA5兼容代码作为其输出。因此，现在，例如，如果我们在entry.js中添加对helloWorld.js的依赖，Webpack将能够生成工作代码。</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="baf2" class="mz ln it mv b gy na nb l nc nd">// helloWorld.js<br/>export const helloWorld = 'Hello world from imported JS!';</span><span id="ee96" class="mz ln it mv b gy ne nb l nc nd">// entry.js<br/>import {helloWorld} from './helloWorld'</span><span id="df25" class="mz ln it mv b gy ne nb l nc nd">console.log(helloWorld); // Will print 'Hello world from imported JS!' in browser's console</span></pre><h2 id="07c6" class="mz ln it bd lo nf ng dn ls nh ni dp lw kr nj nk ma kv nl nm me kz nn no mi np bi translated">插件</h2><p id="ced1" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">所以我们已经看到<strong class="ki iu">条目</strong>、<strong class="ki iu">输出、</strong>和<strong class="ki iu">模块</strong>配置在运行。但是还有一个关于基本配置的部分值得一看——它的插件。简单地说，插件对于捆绑的JavaScript就像加载器对于单个JavaScript依赖一样。插件允许我们在捆绑包上执行各种任务。例如，将重复的代码块提取到单独的文件中，或者修改输出。</p><pre class="ml mm mn mo gt mu mv mw mx aw my bi"><span id="331e" class="mz ln it mv b gy na nb l nc nd">// webpack.config.js<br/>var webpack = require('webpack')</span><span id="c287" class="mz ln it mv b gy ne nb l nc nd">module.exports = {<br/>    entry: {<br/>        entry: __dirname + '/entry.js'<br/>    },<br/>    output: {<br/>        filename: '[name].bundle.js'<br/>    },<br/>    module: {<br/>        loaders: [<br/>            {<br/>                test: /\.js$/,<br/>                loader: 'babel-loader',<br/>                exclude: /node_modules/,<br/>                query: {<br/>                    presets: ['es2015']<br/>                }<br/>            }<br/>        ]<br/>    },<br/><strong class="mv iu">    plugins: [<br/>        new webpack.optimize.UglifyJsPlugin()<br/>    ]</strong><br/>}</span></pre><p id="e4a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，我们在Webpack配置中增加了一个新的部分<code class="fe nr ns nt mv b">plugins</code>。它可以包含许多要在捆绑的JavaScript上执行的插件。就其本身而言，Webpack提供了一个有用的<a class="ae kf" href="https://webpack.js.org/plugins/" rel="noopener ugc nofollow" target="_blank">插件列表</a>。但是，您也可以根据自己的具体要求构建自己的定制列表。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="350b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="37c4" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">这篇文章提供了一个简短的介绍和如何开始使用网络包的例子。从而改进JavaScript开发过程，并获得对脚本所依赖的依赖关系的更多控制。在您离开之前，这里有一个关于切换到Webpack的优点和缺点的简短总结。</p><p id="b9a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Cons: </strong></p><ul class=""><li id="dcc8" class="nu nv it ki b kj kk kn ko kr nw kv nx kz ny ld nz oa ob oc bi translated">当一个功能已经存在于框架中时，需要安装一个额外的工具</li><li id="ad3c" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">开发人员必须定义配置中的所有入口点，每个页面或视图一个入口点</li><li id="5346" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">对于应用程序和第三方插件，JavaScript必须是模块化的</li></ul><p id="6344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">优势:</strong></p><ul class=""><li id="8da7" class="nu nv it ki b kj kk kn ko kr nw kv nx kz ny ld nz oa ob oc bi translated">对依赖关系的更多控制，因为视图只导入功能所需的脚本</li><li id="dd77" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">现代JavaScript的使用— ES6特性</li><li id="d693" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">Webpack可以在编译时分析JavaScript的内容，从而为优化提供更多信息</li><li id="6885" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">引用类类似于在C#或PHP中进行引用</li></ul><p id="7c01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你会发现这很有用，如果你已经注意到了一些缺点，不要犹豫，让我知道。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="2fb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你的阅读！如果您有任何意见，我将非常感谢您在意见部分的反馈。祝你玩得开心！</p></div></div>    
</body>
</html>