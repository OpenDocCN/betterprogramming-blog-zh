<html>
<head>
<title>Dynamically Convert Plain Objects Into TypeScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将普通对象动态转换为TypeScript类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamically-convert-plain-objects-into-typescript-classes-adcc788e0bcc?source=collection_archive---------3-----------------------#2020-07-22">https://betterprogramming.pub/dynamically-convert-plain-objects-into-typescript-classes-adcc788e0bcc?source=collection_archive---------3-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8191" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用reflect-metadata将普通对象动态转换为具有自定义数据类型的类型检查类</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/14c6ef8deae18c0d4d2cc8b2411d4812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*z98j8c22BvFo0tnEuX6yTA.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ricardo Gomez Angel </a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="043a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">处理普通对象(或JSON.parse的结果)是web开发的基本部分。为了让开发体验变得可以忍受，我们经常将普通对象塑造成可预测的东西，包括将它们的值转换成比原始类型更强大的东西。</p><p id="d180" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以采取几种方法。一个是工厂函数，它要求您定义转换函数，外加一个带有类型定义的接口。另一个是类，它们在功能和类型上是独立的。我想为后者提供一个理由，因为如今课堂不太受欢迎。</p><p id="5ac3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将探索如何将普通对象嵌入到类中，同时允许我们在处理自定义数据类型和提供附加功能(getter/setter/methods)时需要的灵活性。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3608" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">简单的解决方案</h1><p id="04f1" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">首先，我们将定义一个普通类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="affa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以这样使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8eeb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是我们想要更多。我们希望能够在运行时根据传入的值动态地构造这些类，而不必通过每个类的构造函数来设置每个属性。</p><p id="102f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一种替代方法是以编程方式将值分配给有效负载中的每个属性。这种情况的常见模式如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ac40" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这非常简单:我们调用<code class="fe mu mv mw mx b">this.hasOwnProperty</code>来确保我们只为属于这个类的属性设置值。</p><p id="3153" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这很好，但只有当我们希望我们的类只包含基本类型时，它才会有用。除此之外，我们需要在每个类中重复相同的构造函数。</p><p id="b6b6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看一个更实际的类定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="08eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这更接近于我们在典型应用中的情况。自定义数据类型，比如我们自己的<code class="fe mu mv mw mx b">Address</code>类、<a class="ae kr" href="https://moment.github.io/luxon/docs/class/src/datetime.js~DateTime.html" rel="noopener ugc nofollow" target="_blank"> Luxon的</a> <code class="fe mu mv mw mx b"><a class="ae kr" href="https://moment.github.io/luxon/docs/class/src/datetime.js~DateTime.html" rel="noopener ugc nofollow" target="_blank">DateTime</a></code>，或者<a class="ae kr" href="https://mikemcl.github.io/decimal.js/" rel="noopener ugc nofollow" target="_blank"> decimal.js' </a> <code class="fe mu mv mw mx b"><a class="ae kr" href="https://mikemcl.github.io/decimal.js/" rel="noopener ugc nofollow" target="_blank">Decimal</a></code>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="405d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">JavaScript类型问题</h1><p id="62e1" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">在JavaScript中，目前还没有本地的方法来找出什么是类型属性并在运行时实例化它们——原因是类型在JavaScript中并不真正存在。TypeScript类型是开发乐趣的语法糖。</p><p id="abc8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">JavaScript中用于运行时类型检查的工具有:</p><ol class=""><li id="bd32" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated"><code class="fe mu mv mw mx b">typeof</code>，只对原始类型有效</li><li id="34bf" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated"><code class="fe mu mv mw mx b">instanceof</code>，这只有在您已经知道要检查的类或构造函数的情况下才有用</li></ol></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="697f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">让位于反射-元数据</h1><p id="9a1d" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">反射是Java和C#等传统OOP语言以及Go、Python和Lua等语言的常用工具。简而言之，它是一个提供的API，允许您在运行时检查一个类或属性，并获取其类型。这允许您从中创建新的实例。</p><p id="699c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">JavaScript中的<a class="ae kr" href="https://github.com/rbuckton/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> reflect-metadata </a>提议还不是<a class="ae kr" href="https://prop-tc39.now.sh" rel="noopener ugc nofollow" target="_blank"> TC39 </a>的一部分，但它是由负责在C#中实现反射的人编写的，所以可以肯定地说它最终会实现。</p><p id="ffed" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">尽管reflect-metadata是实验性的，但它已经被Angular 2大量使用了很多年。Angular依赖于它的依赖注入机制，即在运行时需要时创建和传递资源。</p><p id="f110" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它就像一个键值存储，只能驻留在类或类属性中。我们可以获取它，并使用它来自动填充类型元数据或管理我们自己的自定义元数据，以便我们可以实现我们所有的目标和梦想。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="65e1" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">让我们编写一个更动态的方法</h1><p id="aacf" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">安装后:<br/>T2】</p><p id="c04b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">并将其导入到我们文件的开头:<br/> <code class="fe mu mv mw mx b">import 'reflect-metadata'</code></p><p id="7084" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们需要确保我们的<code class="fe mu mv mw mx b">tsconfig.json</code> <strong class="ku ir"> </strong>包含以下内容:</p><pre class="kg kh ki kj gt nm mx nn no aw np bi"><span id="f430" class="nq lw iq mx b gy nr ns l nt nu">"compilerOptions": {<br/>    "experimentalDecorators": true,<br/>    "emitDecoratorMetadata": true<br/>}</span></pre><p id="8706" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这将允许我们使用decorators来触发reflect-metadata，从而在我们的装饰属性中自动填充<code class="fe mu mv mw mx b">design:type</code>元数据键。</p><p id="e251" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们还需要一些类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4541" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">构造函数:</strong>用于表示构造函数或类，我们可以在其上调用<code class="fe mu mv mw mx b">new</code> <br/> <strong class="ku ir">可索引:</strong>用于定义可索引的类或对象，您可以在其上执行<code class="fe mu mv mw mx b">object[key]</code> <strong class="ku ir"> <br/> DeepPartial: </strong>用于允许我们指定对象或类的部分表示，因为提供的<code class="fe mu mv mw mx b">Partial</code> TypeScript实用程序只对一个深度级别有效</p><p id="6e90" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在轮到装修工人了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3bac" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Primed: </strong>它没有主体，但是将用于触发<code class="fe mu mv mw mx b">Reflect.metadata</code>被添加到被修饰的属性上，因为reflect-metadata只自动填充被修饰的属性的<code class="fe mu mv mw mx b">design:type</code>元数据。<br/> <strong class="ku ir"> Model: </strong>它将用于覆盖修饰类的构造函数，这样我们就可以隐式地调用我们的自定义初始化方法。</p><p id="6672" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将创建一个<code class="fe mu mv mw mx b">Base</code>类，负责初始化我们的属性，在需要时创建新的实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d303" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您会注意到我们添加了一个不同的方法来初始化我们的实例，并且我们的构造函数是空的。</p><p id="7e58" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为我们想从B中初始化A，这样我们就不必将构造函数复制到每个类中。如果A扩展了B，并且A包含具有默认值的属性，则不能从B的构造函数中设置A的属性，因为它们将被A的默认值覆盖:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b358" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是为什么我们有一个<code class="fe mu mv mw mx b">init</code>方法。我们要确保在设置属性之前完全初始化。</p><p id="6fe0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所以在<code class="fe mu mv mw mx b">init</code>方法中，我们调用:<br/> <code class="fe mu mv mw mx b">Reflect.getMetadata('design:type', this, key)</code>来获取为实例中的键自动填充的元数据，它将包含与分配给修饰属性的类型相关联的值。如果它存在，我们用<code class="fe mu mv mw mx b">new</code>创建一个新的实例，将值传递给它。</p><p id="fc03" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用我们前面的例子，这些类现在看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9e30" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个有点小问题。如果尝试执行以下操作，我们会得到一个类型错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eaab" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为我们想要将一个字符串传递到我们的<code class="fe mu mv mw mx b">dob</code>字段中，将一个数字传递到我们的<code class="fe mu mv mw mx b">netWorth</code>字段中，而我们的<code class="fe mu mv mw mx b">Person</code>类分别期待一个<code class="fe mu mv mw mx b">DateTime</code>和一个<code class="fe mu mv mw mx b">Decimal</code>。我们所能做的是修改我们的<code class="fe mu mv mw mx b">Base</code>类来接受一个可选的第二类型，我们可以用它在它和目标类的类型之间创建一个新的联合类型。</p><p id="4ef4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是它看起来的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e5f8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以这样使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="4557" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">处理数组和其他自定义类型</h1><p id="dad0" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">我们就快成功了，但仍有几个问题:</p><ol class=""><li id="8bfa" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated">reflect-metadata没有正确填充数组上的<code class="fe mu mv mw mx b">design:type</code>。它将它们设置为<code class="fe mu mv mw mx b">Array</code>而不是预期的类型。</li><li id="6747" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">并不是所有的自定义数据类型都会被相同地创建/初始化。对于Luxon的<code class="fe mu mv mw mx b">DateTime</code>，我们想用<code class="fe mu mv mw mx b">DateTime.fromISO</code>来初始化它。我们也希望其他类型的灵活性。</li></ol><p id="0a68" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了解决这些问题，我们需要能够定制我们在需要时指定什么类型的方式，为此，我们将引入一个新的元数据键。</p><p id="d9c8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将允许<code class="fe mu mv mw mx b">Primed</code> decorator接受一个可选参数，这个参数将是一个类或函数。然后我们用<code class="fe mu mv mw mx b">Reflect.defineMetadata</code>将它保存到<code class="fe mu mv mw mx b">CONSTRUCTOR_META</code>键中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8f99" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了处理Luxon的<code class="fe mu mv mw mx b">DateTime</code> <strong class="ku ir"> </strong>和其他可能以不同方式创建的自定义类型，我们将检查它们并通过一个新的私有函数<code class="fe mu mv mw mx b">parseValue</code>手动初始化它们。</p><p id="3b6a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了处理数组，我们将检查<code class="fe mu mv mw mx b">design:type</code>元数据，以了解我们是否需要迭代。</p><p id="5c3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将在<code class="fe mu mv mw mx b">CONSTRUCTOR_META</code>下获取新的元数据，这将优先于<code class="fe mu mv mw mx b">design:type</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3c97" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后，在使地址成为数组之后，这将是我们的类定义和用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="b506" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">包裹</h1><p id="564f" class="pw-post-body-paragraph ks kt iq ku b kv mn jr kx ky mo ju la lb mp ld le lf mq lh li lj mr ll lm ln ij bi translated">可以肯定地说，使用工厂函数，您可以省去初始设置，但代价是必须重复设置。您需要创建一个工厂函数和一个带有类型定义的接口。</p><p id="8f78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以两者都做，或者(在克服了一些障碍之后)你可以只上一门课。</p><p id="dc69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在这个<a class="ae kr" href="https://codesandbox.io/s/primed-model-v8txy?file=/src/index.ts" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>里玩代码。</p><p id="d392" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当使用reflect-metadata自动填充类型元数据时，有几个注意事项:它不处理自引用或循环引用。</p><p id="72c7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我实际上做了一个简单的包，<a class="ae kr" href="https://www.npmjs.com/package/primed-model" rel="noopener ugc nofollow" target="_blank"> primed-model </a>，它解决了这些问题，提供了概述的装饰器和基类。它还提供了一个<code class="fe mu mv mw mx b">clone</code>方法，用于防止传递类实例时的副作用。有兴趣就去看看吧！</p><p id="92a1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你想看一个不同的，服用类固醇的人来完成这个任务，你也可以看看<a class="ae kr" href="https://www.npmjs.com/package/class-transformer" rel="noopener ugc nofollow" target="_blank">级变形金刚</a>。</p><p id="d724" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们给班级一些爱！</p><p id="0288" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">就这些，感谢阅读。</p></div></div>    
</body>
</html>