<html>
<head>
<title>Implement the Repository Pattern in Python Using SQLAlchemy as a Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQLAlchemy作为后端，在Python中实现存储库模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-the-repository-pattern-in-python-using-sqlalchemy-as-a-backend-9f04c89fdf11?source=collection_archive---------7-----------------------#2022-11-16">https://betterprogramming.pub/implementing-the-repository-pattern-in-python-using-sqlalchemy-as-a-backend-9f04c89fdf11?source=collection_archive---------7-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ed0e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中的领域驱动设计</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c90aabd1a778c22816dcb88a002e0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ac2rxrBDrSAOrDFQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@coltonsturgeon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的科尔顿鲟鱼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><blockquote class="kw kx ky"><p id="d5c3" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文是关于用Python实现领域驱动设计战术模式的系列文章的一部分。这里的目标是建立一个web应用程序，允许卖家列出待售物品，买家对他们愿意购买的物品出价(又名易贝克隆)——关于该项目的更多信息可以在这里找到<a class="ae kv" href="https://dddinpython.com/index.php/2021/06/30/my-first-ddd-project/" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="ea1b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在<a class="ae kv" href="https://dddinpython.com/index.php/2022/09/23/implementing-the-repository-pattern/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我们实现了一个简单的基于文件的存储库，它使用了<code class="fe lz ma mb mc b">pickle</code>模块。由于我们没有使用数据库，所以我们不必创建表和列，所有的域模型都直接从内存序列化为字节流(反之亦然)。这种方法可以引入存储库的概念，但是在生产系统中，我们需要一些数据库来存储应用程序状态。</p><p id="5b11" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">顺便提一下，我上次写道，存储库用于加载和保存实体。存储库使用集合(实体的组合)，但是为了简单起见，我坚持使用实体。</p><p id="9c22" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这次我们将使用<a class="ae kv" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQL炼金术</a>作为实体的持久化机制。我们将保留原来的接口，但是所有的实现细节都将封装在<code class="fe lz ma mb mc b">SqlAlchemyListingRepository</code>中。让我们从修改后的<code class="fe lz ma mb mc b">ListingRepository</code>接口开始，它额外支持添加、删除和持久化<code class="fe lz ma mb mc b">Listing</code>域实体:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="7908" class="mh mi iq mc b be mj mk l ml mm"># somewhere in the domain layer<br/><br/>class ListingRepository(metaclass=abc.ABCMeta):<br/>    """An interface to listing repository"""<br/><br/>    @abc.abstractmethod<br/>    def add(self, entity: Listing):<br/>        """Adds new entity to a repository"""<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def remove(self, entity: Listing):<br/>        """Removes existing entity from a repository"""<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def get_by_id(id: ListingId) -&gt; Listing:<br/>        """Retrieves entity by its identity"""<br/>        raise NotImplementedError()<br/><br/>    def __getitem__(self, index) -&gt; Listing:<br/>        return self.get_by_id(index)</span></pre><p id="1ee2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在领域驱动的设计中，存储库的目标是封装访问领域对象所需的逻辑。因此，存储库的接口是域层的一部分，而该接口的实际实现属于基础设施层。因此，域代码保持干净——它与任何技术问题隔离开来，并且是数据库不可知的。</p><h1 id="69f0" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">一点理论</h1><p id="04f3" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">在我们开始实施SQL Alchemy存储库之前，我想介绍和讨论一些概念:</p><h2 id="fdf0" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">1.ORM模型≠域对象</h2><p id="5d2f" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">实体是<a class="ae kv" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank"> Python类</a>——这并不奇怪。它们包含属性:基本类型、值对象、枚举、对其他实体的引用以及以上所有内容的集合。在内存中，这形成了嵌套字段的图形结构。提醒一下，这是我们的<code class="fe lz ma mb mc b">Listing</code>实体的样子(此时，我们不关心逻辑):</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="ffe4" class="mh mi iq mc b be mj mk l ml mm">@dataclass<br/>class Listing(Entity):<br/>    id: int<br/>    name: str<br/>    min_price: Money<br/>    ....</span></pre><p id="0dfb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">另一方面，数据库组织数据是平面的，无格式的。Python类和关系数据模型不能一起工作，ORM的引入就是为了解决这个问题。然而，由于模型属性和表列之间的<a class="ae kv" href="https://docs.sqlalchemy.org/en/14/orm/tutorial.html#declarea-mapping" rel="noopener ugc nofollow" target="_blank">映射</a>，ORM模型仍然与数据库和特定的ORM实现紧密耦合:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="d3a9" class="mh mi iq mc b be mj mk l ml mm">class ListingModel(ModelBase):<br/>    __tablename__ = "listing"<br/>    id = Column(Integer, primary_key=True)<br/>    name = Column(String)<br/>    min_price__amount = Column(Integer)<br/>    min_price__currency = Column(String(3))</span></pre><p id="c391" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这引发了两个问题:</p><p id="b4cd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">1.ORM模型不应该用在领域层。与领域对象相比，ORM模型更难测试(它们需要一个数据库存在)。此外，我们希望业务层保持干净，不依赖于底层存储机制。<code class="fe lz ma mb mc b">ListingModel</code>与SQL Alchemy紧密耦合，在业务层有这样的依赖是不可行的。然而，在某些情况下使用SQLA模型仍然很好，例如，如果我们做不需要业务逻辑的基本CRUD操作。</p><p id="b6dd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2.没有简单的方法将多字段值对象(即由<code class="fe lz ma mb mc b">amount</code>和<code class="fe lz ma mb mc b">currency</code>组成的<code class="fe lz ma mb mc b">min_price</code>T3)分配给模型中的多个列。理论上，我们可以为值对象添加一些getters和setters:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="1dcc" class="mh mi iq mc b be mj mk l ml mm">class ListingModel(ModelBase):<br/>    ...<br/>    min_price__amount = Column(Integer)<br/>    min_price__currency = Column(String(3))<br/><br/>    def get_min_price(self) -&gt; Money:<br/>        return Money(self.min_price__amount, self.min_price__currency)<br/><br/>    def set_min_price(self, value: Money):<br/>        self.min_price__amount = value.amount<br/>        self.min_price__currency = value.currency</span></pre><p id="6326" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">…但是这与值对象不可变的想法相矛盾(您仍然可以更改逻辑上属于值对象的模型的单个属性)。</p><p id="2b5c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了克服这些问题，我们需要一种在业务层之间传输数据的机制——数据映射器。</p><h2 id="0382" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">2.数据映射器</h2><p id="543f" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">我们已经知道我们不想在领域层使用模型。模型是SQL Alchemy特有的，由列、外键、关系等组成。我们不希望任何基础设施细节泄露到域中。我们仍然可以使用模型来查询数据(因为可以通过repos之外的渠道查询数据库)，但这超出了本文的范围。</p><p id="6be8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要做的是:<br/> -当从repo中读取数据时，将模型映射到实体(即<code class="fe lz ma mb mc b">get_by_id(…)</code>调用返回一个域实体)，<br/> -当将要保存任何数据更改时，将实体映射到模型。</p><p id="b501" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这可以通过两种方式实现:</p><p id="c113" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">1.我们可以使用SQL炼金术<a class="ae kv" href="https://docs.sqlalchemy.org/en/20/orm/mapping_styles.html#imperative-mapping" rel="noopener ugc nofollow" target="_blank">命令式映射</a>将数据从SQL表映射到纯Python类。<a class="ae kv" href="https://www.cosmicpython.com/book/chapter_02_repository.html#_inverting_the_dependency_orm_depends_on_model" rel="noopener ugc nofollow" target="_blank">宇宙Python </a>遵循这种方法。在这里，模型的所有属性都通过<code class="fe lz ma mb mc b">mapper_registry.map_imperatively()</code>自动地从/到域对象进行转换。然而，这种技术仅限于只包含基本类型的模型。如果我们的领域模型有多属性值对象，我们需要一个更复杂的方法。</p><p id="6072" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2.我们可以实现我们自己的数据映射器，在我们的领域模型之间进行转换。为了进行映射，我们需要两个函数:<code class="fe lz ma mb mc b">XYZ_model_to_entity</code>和<code class="fe lz ma mb mc b">XYZ_entity_to_model</code>。存储库将使用数据映射器来完成所有的翻译。这是我们在实施<code class="fe lz ma mb mc b">SqlAlchemyListingRepository</code>时将要采取的方法。</p><h2 id="0602" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">3.身份地图</h2><p id="0958" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">存储库模式中的一个基本元素是<a class="ae kv" href="https://en.wikipedia.org/wiki/Identity_map_pattern" rel="noopener ugc nofollow" target="_blank">身份映射</a>，它通过提供特定于上下文的内存缓存来防止在单个事务期间从数据库中重复检索相同的对象数据，从而提高性能。这里有另一个定义:</p><blockquote class="kw kx ky"><p id="39c4" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">身份映射记录了在单个业务事务中从数据库中读取的所有对象。每当您想要一个对象时，您首先检查身份映射以查看您是否已经拥有它。<br/> —马丁·福勒</p></blockquote><p id="dbc0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这非常简单:当我们查询实体的存储库时，我们将首先检查身份映射。如果实体已经存在于地图中，存储库将返回对缓存对象的引用。否则，我们将从数据库中读取模型，用数据映射器转换它，将它存储在身份映射中，并返回一个引用。在保存实体时，我们将使用数据映射器将其转换为模型实例，然后使用内置的SQL Alchemy会话机制持久化它。</p><h1 id="f96d" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">存储库模式实现</h1><p id="6222" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">现在我们知道了存储库的构建块是什么，让我们看看实现SQL Alchemy清单存储库所需的所有部分。</p><h2 id="00ea" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">域对象</h2><p id="3772" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">这是我们的领域模型的数据部分。为了清楚起见，所有的逻辑都从域对象中删除了。</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="bedf" class="mh mi iq mc b be mj mk l ml mm">from uuid import UUID<br/>from dataclasses import dataclass<br/><br/># some type aliases<br/>ListingId = UUID<br/>BidderId = UUID<br/><br/>@dataclass<br/>class Money:<br/>    """A value object that represents money"""<br/>    amount: int<br/>    currency: str<br/><br/>@dataclass<br/>class Bid:<br/>    """A value object that represents a bid placed on a listing by a buyer"""<br/>    bidder_id: BidderId<br/>    price: Money<br/><br/>@dataclass<br/>class Listing(Entity):<br/>    """An entity that represents a listing with an ask price and all the bids already placed on this item"""<br/>    id: int<br/>    name: str<br/>    min_price: Money<br/>    bids: List[Bid] = field(default_factory=list)</span></pre><p id="af3d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里有一些有趣的事情需要注意。一个<code class="fe lz ma mb mc b">Listing</code>由一些原语类型(即<code class="fe lz ma mb mc b">id</code>、<code class="fe lz ma mb mc b">name</code>)、一个单值对象(<code class="fe lz ma mb mc b">min_price</code>)和一个值对象列表(<code class="fe lz ma mb mc b">bids</code>)组成。出于某种未公开的原因，让我们假设我们有意使用一个列表，这样我们就可以保持出价的顺序(否则，我们可以使用一个无序的<code class="fe lz ma mb mc b">set</code>)。</p><h2 id="2579" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">数据模型</h2><p id="8279" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">上述域对象反映为数据库模型，如下所示:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="f2fc" class="mh mi iq mc b be mj mk l ml mm">import uuid<br/>from infrastructure.sqlalchemy_common import Base, Column, UUID, String, Integer, ForeignKey, relationship<br/><br/>UniqueIdentifer = UUID(as_uuid=True)<br/><br/>class BidModel(Base):<br/>    """ Stores Bid value object"""<br/>    __tablename__ = "bid"<br/>    # composite primary key<br/>    listing_id = Column(UniqueIdentifier,<br/>                        ForeignKey("listing.id"),<br/>                        primary_key=True)<br/><br/>    # since bids are stored in an ordered collection (list), an index column is required<br/>    idx = Column(Integer, primary_key=True)<br/><br/>    bidder_id = Column(UniqueIdentifier)<br/>    price__amount = Column(Integer)<br/>    price__currency = Column(String(3))<br/><br/>    # parent relationship<br/>    listing = relationship("ListingModel", back_populates="bids")<br/><br/>class ListingModel(Base):<br/>    __tablename__ = "listing"<br/><br/>    id = Column(UniqueIdentifier, primary_key=True, default=uuid.uuid4)<br/>    name = Column(String(30))<br/><br/>    min_price__amount = Column(Integer)<br/>    min_price__currency = Column(String(3))<br/><br/>    bids = relationship("BidModel",<br/>                        order_by="BidModel.idx.asc()",<br/>                        cascade="save-update, merge, delete, delete-orphan")</span></pre><p id="cedc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如你所见，我们没有单独的桌子；这些作为原始字段存储在相应的模型中(即<code class="fe lz ma mb mc b">price__amount</code>、<code class="fe lz ma mb mc b">price__currency</code>和<code class="fe lz ma mb mc b">min_price__amount</code>、<code class="fe lz ma mb mc b">min_price__currency</code>)。然而，我们将<code class="fe lz ma mb mc b">bids</code>存储在单独的<code class="fe lz ma mb mc b">BidModel</code>中，因为<code class="fe lz ma mb mc b">ListingModel</code>和<code class="fe lz ma mb mc b">BidModel</code>之间存在一对多的关系。</p><p id="b64a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">此外，出价按<code class="fe lz ma mb mc b">idx</code>字段排序，以保持<code class="fe lz ma mb mc b">Listing.bids</code>列表中元素的顺序，并且设置了一个<code class="fe lz ma mb mc b">cascade</code>选项，以在从列表中移除<code class="fe lz ma mb mc b">Bid</code>值对象时保持<code class="fe lz ma mb mc b">Listing.bids</code>和表格行同步。另外，请注意，它使用由<code class="fe lz ma mb mc b">listing_id</code>和<code class="fe lz ma mb mc b">idx</code>组成的复合主键，因为它足以在数据库级别识别一个出价。</p><h2 id="4b67" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">数据映射器</h2><p id="363d" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">数据映射器的逻辑并不奇特——只是从一种类型到另一种类型的相当乏味的映射。需要注意的一个有趣的小细节是打包/解包值对象。</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="cc58" class="mh mi iq mc b be mj mk l ml mm">from infrastructure.models import ListingModel, BidModel<br/>from domain.entities import Listing<br/>from domain.value_objects import Money, Bid<br/><br/>def listing_model_to_entity(instance: ListingModel) -&gt; Listing:<br/>    def map_bid_to_value_object(bid: BidModel) -&gt; Bid:<br/>        return Bid(<br/>            bidder_id=bid.bidder_id, <br/>            price=Money(amount=bid.price__amount, currency=bid.price__currency)<br/>        )<br/><br/>    return Listing(<br/>        id=instance.id,<br/>        name=instance.name,<br/>        min_price=Money(amount=instance.min_price__amount, currency=instance.min_price__currency),<br/>        bids=[map_bid_to_value_object(bid) for bid in instance.bids]<br/>    )<br/><br/>def listing_entity_to_model(listing: Listing, existing=None) -&gt; ListingModel:<br/>    def map_bid_to_model(idx: int, bid: Bid) -&gt; BidModel:<br/>        return BidModel(bidder_id=bid.bidder_id, price__amount=bid.price.amount, price__currency=bid.price.currency, idx=idx)<br/><br/>    return ListingModel(<br/>        id=listing.id,<br/>        name=listing.name,<br/>        min_price__amount=listing.min_price.amount,<br/>        min_price__currency=listing.min_price.currency,<br/>        bids=[map_bid_to_model(idx, bid) for idx, bid in enumerate(listing.bids)]</span></pre><h2 id="3012" class="nj mi iq bd mo nk nl dn ms nm nn dp mw lw no np my lx nq nr na ly ns nt nc nu bi translated">列表存储库</h2><p id="8fe4" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">最后，让我们看看存储库的实现:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="5ca4" class="mh mi iq mc b be mj mk l ml mm">from sqlalchemy.orm import Session<br/>from domain.repositories import ListingRepository<br/>from domain.entities import Listing<br/>from infrastructure.models import ListingModel<br/>from infrastructure.data_mappers import listing_model_to_entity, listing_entity_to_model<br/><br/># a sentinel value for keeping track of entities removed from the repository<br/>REMOVED = object()<br/><br/>class SqlAlchemyListingRepository(ListingRepository):<br/>    """SqlAlchemy implementation of ListingRepository"""<br/><br/>    def __init__(self, session: Session, identity_map=None):<br/>        self.session = session<br/>        self._identity_map = identity_map or dict()<br/><br/>    def add(self, entity: Listing):<br/>        self._identity_map[entity.id] = entity<br/>        instance = listing_entity_to_model(entity)<br/>        self.session.add(instance)<br/><br/>    def remove(self, entity: Listing):<br/>        self._check_not_removed(entity)<br/>        self._identity_map[entity.id] = REMOVED<br/>        listing_model = self.session.query(ListingModel).get(entity.id)<br/>        self.session.delete(listing_model)<br/><br/>    def get_by_id(self, id):<br/>        instance = self.session.query(ListingModel).get(id)<br/>        return self._get_entity(instance, listing_model_to_entity)<br/><br/>    def get_by_name(self, name):<br/>        instance = self.session.query(ListingModel).filter_by(name=name).one()<br/>        return self._get_entity(instance, listing_model_to_entity)<br/><br/>    def _get_entity(self, instance, mapper_func):<br/>        if instance is None:<br/>            return None<br/>        entity = listing_model_to_entity(instance)<br/>        self._check_not_removed(entity)<br/><br/>        if entity.id in self._identity_map:<br/>            return self._identity_map[entity.id]<br/><br/>        self._identity_map[entity.id] = entity<br/>        return entity<br/><br/>    def __getitem__(self, key):<br/>        return self.get_by_id(key)<br/><br/>    def _check_not_removed(self, entity):<br/>        assert self._identity_map.get(entity.id, None) is not REMOVED, f"Entity {entity.id} already removed"<br/><br/>    def persist(self, entity: Listing):<br/>        self._check_not_removed(entity)<br/>        assert entity.id in self._identity_map, "Cannon persist entity which is unknown to the repo. Did you forget to call repo.add() for this entity?"<br/>        instance = listing_entity_to_model(entity)<br/>        merged = self.session.merge(instance)<br/>        self.session.add(merged)<br/><br/>    def persist_all(self):<br/>        for entity in self._identity_map:<br/>            if entity is not REMOVED:<br/>                self.persist(entity)</span></pre><p id="8a76" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里有几件事值得注意:</p><ul class=""><li id="dbf4" class="nv nw iq lc b ld le lg lh lw nx lx ny ly nz lv oa ob oc od bi translated">我们正在通过<code class="fe lz ma mb mc b">__init__</code>传递SQL炼金术<code class="fe lz ma mb mc b">Session</code>和身份映射实例。每个业务事务应该有一个会话和一个身份映射。</li><li id="0e2b" class="nv nw iq lc b ld oe lg of lw og lx oh ly oi lv oa ob oc od bi translated">当向存储库添加一个新实体时，我们将实体存储在身份映射中，并将相应的模型存储在SQL Alchemy会话中。</li><li id="aba2" class="nv nw iq lc b ld oe lg of lw og lx oh ly oi lv oa ob oc od bi translated">当实体状态被改变时<br/>——为了保持对实体所做的改变，使用<code class="fe lz ma mb mc b">persist()</code>或<code class="fe lz ma mb mc b">persist_all()</code>方法。当一个实体被持久化时，它的状态使用<code class="fe lz ma mb mc b">listing_entity_to_model</code>数据映射器被转换回模型。<br/> - <code class="fe lz ma mb mc b">persist()</code>变更和<code class="fe lz ma mb mc b">commit()</code>会话不是存储库的责任，这也是我们的目的。协调对数据库的写入应该由一个工作单元来处理。<br/> -这个存储库实现在内存消耗方面并不理想(实际上，我们在这里使用了两个身份映射:一个由回购协议使用，另一个是SQLA会话的一部分)，但是我认为它对于我们的目的来说已经足够好了。</li></ul><h1 id="35d6" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">使用案例</h1><p id="591f" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">这就是我们如何通过<code class="fe lz ma mb mc b">publish_listing_use_case</code> <strong class="lc ir"> </strong>函数发布清单:</p><pre class="kg kh ki kj gt md mc me bn mf mg bi"><span id="db90" class="mh mi iq mc b be mj mk l ml mm">engine = create_engine("sqlite+pysqlite:///:memory:",<br/>                       echo=True,<br/>                       future=True)<br/>Base.metadata.create_all(engine)<br/><br/>def publish_listing_use_case(listing_id: ListingId, repository: ListingRepository):<br/>    listing = repository.get_by_id(listing_id)<br/>    listing.publish()<br/><br/>def execute_publish_listing_via_unit_of_work():<br/>    identity_map = []<br/>    with Session(engine) as session:<br/>        repository = SqlAlchemyListingRepository(session, identity_map)<br/>        publish_listing_use_case(listing_id=..., repository=repository)<br/>        repository.persist_all()<br/><br/>execute_publish_listing_via_unit_of_work()</span></pre><p id="e31a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如我们所看到的，存储库没有将实体状态显式保存在数据库中。所有繁重的工作都由负责创建会话、实例化存储库、调用用例函数和保存所有结果的<code class="fe lz ma mb mc b">execute_publish_listing_via_unit_of_work</code>函数来处理。通常，这是一个<a class="ae kv" href="https://martinfowler.com/eaaCatalog/unitOfWork.html" rel="noopener ugc nofollow" target="_blank">工作单元</a>的职责。</p><h1 id="4628" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">结论</h1><p id="f774" class="pw-post-body-paragraph kz la iq lc b ld ne jr lf lg nf ju li lw ng ll lm lx nh lp lq ly ni lt lu lv ij bi translated">正如我们所看到的，实现存储库模式需要做大量的工作。我们必须为我们的域对象定义一个数据模型，配置这两者之间的映射，然后实现存储库。我们还需要一些逻辑来保持模型实例和实体的同步，这样，如果实体发生变化，它将自动保存在数据库中。另一层抽象无疑意味着更多的工作。那么，这一切值得吗？我们应该什么时候使用它？有什么好处？</p><p id="cc67" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">首先，如果我们打算通过执行业务逻辑来改变实体的状态，我们应该使用存储库模式。如果我们只想查询数据(即搜索、排序、过滤)并将其显示在屏幕上，这将是大材小用。</p><p id="63ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">关于好处:我们得到了关注点的分离——业务层不需要知道数据源，也不需要跟踪变化。存储库是可互换的——从长远的角度来看，代码更容易测试和维护。</p><p id="0094" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi">***</p><p id="906b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">本文最初发表于</em><a class="ae kv" href="https://dddinpython.com/index.php/2022/11/09/implementing-the-repository-pattern-using-sqlalchemy/" rel="noopener ugc nofollow" target="_blank"><em class="lb">DDD Python中的</em> </a></p></div></div>    
</body>
</html>