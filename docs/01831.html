<html>
<head>
<title>Refactoring: Guard Clauses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构:保护子句</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactoring-guard-clauses-2ceeaa1a9da?source=collection_archive---------1-----------------------#2019-10-16">https://betterprogramming.pub/refactoring-guard-clauses-2ceeaa1a9da?source=collection_archive---------1-----------------------#2019-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f402" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为更好的开发人员的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0aad5ea0c9a943c3fa2ed4ee40ca4d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rayZeE3FPi2EBU-5YiDlXA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kutanural?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kutan Ural </a>在<a class="ae ky" href="https://unsplash.com/s/photos/guard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><blockquote class="kz la lb"><p id="6ef2" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="it">“在计算机编程中，一个保护是一个布尔表达式，如果程序要在所讨论的分支中继续执行，它的值必须为真。无论使用哪种编程语言，保护代码或保护子句都是完整性检查的前提条件，用于避免执行过程中的错误。”— </em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Guard_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="it">百科</em> </a></p></blockquote><p id="3685" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">未应用保护子句技术的代码中出现的主要问题如下:</p><ol class=""><li id="18e6" class="mc md it lf b lg lh lj lk lz me ma mf mb mg ly mh mi mj mk bi translated">过度缩进—过度使用控件结构(如果是嵌套的),意味着有很高的缩进级别，这使得代码阅读很困难。</li><li id="4e52" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">if-else之间的关系——当if-else之间有大量独立的代码片段(它们在概念上彼此相关)时，有必要通过在不同部分之间跳转来执行代码读取。</li><li id="c8c2" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">脑力劳动——源代码中不同跳转的结果导致在代码生成中产生额外的劳动。</li></ol></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7d33" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">实际应用</h1><p id="f17f" class="pw-post-body-paragraph lc ld it lf b lg np ju li lj nq jx ll lz nr lo lp ma ns ls lt mb nt lw lx ly im bi translated">保护条款的实际应用是以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b9a8c25be0dfc3eebbee3a6ed5613711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jfQmfM_lW27cTH9f.png"/></div></div></figure><p id="2050" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在这种情况下，大多数时候，您必须颠倒逻辑以避免使用保留字<code class="fe nv nw nx ny b">else</code>。前面的代码将重写如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/43d51f73607fb9d0b71b4d2a4ad8ffd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AptlYmD9CXaTuxTv.png"/></div></div></figure><p id="99d0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，导致退出该方法的特定情况将被放置在该方法的开始处，并且以避免继续通过该方法的令人满意的流程的方式充当守卫。</p><p id="c57a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过这种方式，该方法易于阅读，因为特定的情况在相同的开始，并且令人满意的流量使用的情况是该方法的主体。</p><p id="fb5f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">有反对保护条款的人指出，在每种方法中应该只有一个出口点，使用这种技术，我们可以找到几个出口点。它不应该与无处不在的回归和不受控制的方法相混淆，这将使我们付出更大的精神努力。但是所有的返回都是明确控制的，因为它们将在保护装置中或在方法的结尾被发现。</p><p id="7fc6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下面我们将看到更复杂的保护条款的例子，其中代码的阅读和理解得到了很大的提高。</p><p id="606a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">假设您必须创建一个方法来计算健康保险的成本，其中用户ID作为一个参数被接收。</p><p id="caeb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">数据库中的搜索是使用这个ID来检索用户的。如果用户不存在，将抛出一个名为<code class="fe nv nw nx ny b">UserNotFoundException</code>的异常。如果用户存在于系统中，下一步是验证用户的健康保险是否对应于对该算法有效的保险之一:Allianz或AXA。如果保险无效，必须返回一个名为<code class="fe nv nw nx ny b">UserInsuranceNotFoundException</code>的异常。最后，这个算法只对西班牙国籍的用户有效。因此，您应该再次检查用户是否是西班牙人，以执行保险计算或返回一个名为<code class="fe nv nw nx ny b">UserIsNotSpanishException</code>的异常</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4b0e4ce67615276debca7a173ec6d8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZI3YwBsGmMac7883.png"/></div></div></figure><p id="249a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如您所见，代码有许多级别的缩进。下面显示了先前算法的相同版本，但是应用了保护子句技术。这种技术使得代码更具可读性。注意，已经应用了三个保护子句，允许生成不干扰算法结果的替代路径(抛出异常)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b37c071a7fb3112750f153f14fc184aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PdzQNx7EEIhMHPnw.png"/></div></div></figure><p id="7e27" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">一些必须解决的问题:</p><ol class=""><li id="c75a" class="mc md it lf b lg lh lj lk lz me ma mf mb mg ly mh mi mj mk bi translated">为什么没有<code class="fe nv nw nx ny b">if-else if</code>的案例？</li><li id="d8e5" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">别想了！如果你的代码需要像<code class="fe nv nw nx ny b">else if</code>这样的案例，那是因为你打破了单一责任的原则，代码做出了更高层次的决策，这些决策应该使用技术进行重构，比如划分为子方法或设计模式，比如命令或策略。</li><li id="42a7" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">负面条件不太好理解。</li><li id="e97c" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">为此，我们有另一种重构技术，称为<em class="le">提取方法</em>，它包括将代码提取到函数中，以便重用或阅读理解。在下面的示例中，我们修改了前面的示例，以创建允许更好地阅读和理解代码的方法。</li></ol><p id="3806" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在使用子句保护时，条件的逻辑通常是颠倒的，并且根据条件的复杂性，理解该条件中所评估的内容是相当复杂的。</p><p id="35bc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这就是为什么在小函数中提取条件的逻辑是一种好的做法，这样可以提高代码的可读性(当然，也可以发现其中的错误)，因为评估条件的责任被委托给了特定的函数。</p><p id="d67e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于我们的医疗保险示例，我们可以生成以下方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0e1ae684d8366f4b9d436fe7590cac74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vboskSM6A5FVLXK7.png"/></div></div></figure><p id="ba95" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">没有必要创建一个函数来检查用户是否存在，因为只检查用户是否不同于null或undefined就足够了。因此，生成的代码如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/02ced8147d02eb59c7a2ceddf2e7cc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sy3P135YA096zFIs.png"/></div></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="81f1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">摘要和资源</h1><p id="d3bb" class="pw-post-body-paragraph lc ld it lf b lg np ju li lj nq jx ll lz nr lo lp ma ns ls lt mb nt lw lx ly im bi translated">有许多提高代码质量的实践。在应用重构技术时，要学习的最重要的事情是，它们应该集中在两点上，主要是:</p><ol class=""><li id="b884" class="mc md it lf b lg lh lj lk lz me ma mf mb mg ly mh mi mj mk bi translated">解耦代码——这允许在整个软件项目中不会引起大的连锁变化的小变化。</li><li id="e12d" class="mc md it lf b lg ml lj mm lz mn ma mo mb mp ly mh mi mj mk bi translated">可读性——非常重要的一点是，开发人员要明白，他们工作的大部分时间都是基于阅读代码，而且很可能是其他开发人员编写的代码。开发人员不花时间理解基本逻辑是非常有益的，因为它不容易阅读。</li></ol><p id="7d37" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">重构从最基本的点开始，从简单的<em class="le"> if </em>，到架构模式。关注我们软件开发的所有方面是很重要的。</p><p id="89a2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">【Refactoring.com<br/>T2<a class="ae ky" href="https://en.wikipedia.org/wiki/Guard_(computer_science)" rel="noopener ugc nofollow" target="_blank">卫士—维基百科</a></p></div></div>    
</body>
</html>