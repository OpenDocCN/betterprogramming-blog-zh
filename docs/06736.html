<html>
<head>
<title>An Animated, Self-Sorting Pie Chart in SwiftUI 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 2.0中的一个动画的、自动排序的饼图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-animated-self-sorting-pie-chart-in-swiftui-2-0-24db465f9413?source=collection_archive---------8-----------------------#2020-10-29">https://betterprogramming.pub/an-animated-self-sorting-pie-chart-in-swiftui-2-0-24db465f9413?source=collection_archive---------8-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9618" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我的图表系列的第4部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bc3b43a36efec43bc2657714dee3465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0FHSM4Cgg2teo6MpKahkGA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个自动排序、自动上色的动画饼图</p></figure><p id="53f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我想构建一个动画的、自动着色的饼图，其中包含一个可视化排序。换句话说，我想构建条形图比赛的饼图版本，这在第3部分中已经介绍过了。</p><div class="lu lv gp gr lw lx"><a href="https://medium.com/better-programming/linking-animations-together-to-build-bar-charts-in-swiftui-6a51e3c9bb94" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">在SwiftUI中将动画链接在一起以构建条形图</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">SwiftUI 2中的条形图</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><div class="lu lv gp gr lw lx"><a href="https://medium.com/better-programming/animating-your-bar-chart-with-combine-messages-d703c4266273" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">用组合消息制作条形图动画</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">“在SwiftUI中将动画链接在一起以构建条形图”的第2部分</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="mm l mi mj mk mg ml ks lx"/></div></div></a></div><div class="lu lv gp gr lw lx"><a href="https://medium.com/better-programming/a-bar-chart-race-using-swiftui-2-0-ef84dc68b678" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">使用SwiftUI 2.0的条形图竞赛</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">我的图表系列的第3部分</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="mn l mi mj mk mg ml ks lx"/></div></div></a></div><p id="f0b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在为了节省时间，让我们从前面提到的文章中吸取一些教训。我将使用一个<code class="fe mo mp mq mr b">observedObject</code>来存储变化数据集的记录和我为它绘制的着色函数。我还想使用一些我为该结构开发的其他实用函数。</p><p id="f7fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在要画一个饼图，你需要一些比萨饼块，或者用数学术语来说是<em class="ms">弧线</em>。在SwiftUI中，您有一个专用的视图类型来构建这些。这个视图被称为<code class="fe mo mp mq mr b">Shape</code>，这里显示的几行代码说明了语法。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="b369" class="mx my it mr b gy mz na l nb nc"><strong class="mr iu">struct</strong> PieSlice: <strong class="mr iu">Shape</strong> {<br/><strong class="mr iu">func</strong> path(in rect: CGRect) -&gt; Path {<br/>  <strong class="mr iu">var</strong> arc = Path()<br/>  arc.<strong class="mr iu">addArc</strong>(center: CGPoint(x: rect.midX, y: rect.midY), radius: radius, startAngle: .degrees(startAngle), endAngle: .degrees(endAngle), clockwise: false)<br/>  arc.<strong class="mr iu">addLine</strong>(to: CGPoint(x: rect.midX, y: rect.midY))<br/>  arc.<strong class="mr iu">closeSubpath</strong>()<br/>  <strong class="mr iu">return</strong> arc<br/>}</span></pre><p id="90a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与我不久前在这篇关于3D绘图的文章<a class="ae nd" href="https://medium.com/better-programming/how-to-draw-in-3d-with-swiftui-7989cfcd35fc" rel="noopener">中提到的<code class="fe mo mp mq mr b">rotate</code>命令不同，<code class="fe mo mp mq mr b">addArc</code>原语有时会让人有点困惑。因为参数是相互关联的，所以很混乱。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/23b2e0b68d133a67791f0dacbd7e324e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHJ68N7fbDfE80wKX9BRfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合成图像:' startAngle' &gt; 'endAngle' +逆时针或' startAngle' &lt; 'endAngle' +逆时针</p></figure><p id="e786" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建弧的代码调用如下所示。我不是故意创造一个吃豆人——这是<code class="fe mo mp mq mr b">addArc</code>的默认行为。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="f1bb" class="mx my it mr b gy mz na l nb nc">PieSlice(startAngle: 60, endAngle: 0, radius: 100)<br/>  .fill(Color.yellow)<br/>  .frame(width: 64, height: 64)</span></pre><p id="3c3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有几个重要的注意事项。画画的起点在吃豆人嘴巴的顶端。如果方向不是顺时针，并且开始角度大于结束角度，您将得到您在左边看到的结果。如果我们改变方向，你会看到右边显示的结果。这是一个会让你困惑的重要特性——请注意。想想吃豆人，你就知道了。</p><p id="20d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，所以一个饼图包含了许多切片。这个数字取决于元素的数量，这意味着我们需要对我们的数字做一些数学运算，使它们成比例地适合360度，一个完整的圆，也就是我们的馅饼。为此，我们需要将所需的角度预填充到我们的结构中。结构本身现在看起来像这样:</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="4482" class="mx my it mr b gy mz na l nb nc"><strong class="mr iu">struct</strong> Chart: <strong class="mr iu">Identifiable</strong> {<br/>  <strong class="mr iu">var</strong> id = <strong class="mr iu">UUID</strong>()<br/>  <strong class="mr iu">var</strong> text: <strong class="mr iu">String</strong><br/>  <strong class="mr iu">var</strong> numbers: <strong class="mr iu">Int</strong><br/>  <strong class="mr iu">var</strong> position: <strong class="mr iu">Int</strong><br/>  <strong class="mr iu">var</strong> color: <strong class="mr iu">Color</strong><br/>  <strong class="mr iu">var</strong> ba: <strong class="mr iu">Double // </strong>begin angle<br/>  <strong class="mr iu">var</strong> ea: <strong class="mr iu">Double // </strong>end angle<strong class="mr iu"><br/>  var </strong>ta<strong class="mr iu">: Double // </strong>text angle<strong class="mr iu"><br/></strong>}</span></pre><p id="7d3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我添加了一些额外的字段，即角度值<code class="fe mo mp mq mr b">ba</code>、<code class="fe mo mp mq mr b">ea</code>和<code class="fe mo mp mq mr b">ta</code>。我们将提前从<code class="fe mo mp mq mr b">number</code>字段计算它们。我提前计算它们，因为如果我在绘制图表时这样做，会导致它在我计算每个切片的值时一次又一次地重新绘制。</p><p id="c9bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还使用原始值来显示原则图像中饼图切片的高度。这些数字需要呈现它们相对于彼此的值，不像我在这里展示的条形图<a class="ae nd" href="https://medium.com/better-programming/linking-animations-together-to-build-bar-charts-in-swiftui-6a51e3c9bb94" rel="noopener"/>。这是我用来计算<code class="fe mo mp mq mr b">ba</code>、<code class="fe mo mp mq mr b">ea</code>和<code class="fe mo mp mq mr b">ta</code>角度的函数。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="c073" class="mx my it mr b gy mz na l nb nc"><strong class="mr iu">func</strong> percent(text: String) -&gt; <strong class="mr iu">Double</strong> {<br/>  <strong class="mr iu">if</strong> <strong class="mr iu">let</strong> i = slices.<strong class="mr iu">firstIndex</strong>(<strong class="mr iu">where</strong>: { $0.text == text }) {<br/>    <strong class="mr iu">let</strong> calc = ((<strong class="mr iu">Double</strong>(slices[i].numbers) / sumUp()) * 360)<br/>    <strong class="mr iu">return</strong> calc<br/>  }<br/>  <strong class="mr iu">return</strong> 0<br/>}</span></pre><p id="2f30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数本身也引用了这个代码片段。<code class="fe mo mp mq mr b">observableObject</code>类中的两个函数都使用前面定义的结构。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="046f" class="mx my it mr b gy mz na l nb nc"><strong class="mr iu">func</strong> sumUp() -&gt; <strong class="mr iu">Double</strong> {<br/>  <strong class="mr iu">var</strong> slicesCount = 0<br/>  <strong class="mr iu">for</strong> index <strong class="mr iu">in</strong> 0..&lt;slices.<strong class="mr iu">count</strong> {<br/>  slicesCount = slicesCount + slices[index].numbers<br/>  }<br/>  <strong class="mr iu">return</strong> <strong class="mr iu">Double</strong>(slicesCount)<br/>}</span></pre><p id="84fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我调用我创建的名为<code class="fe mo mp mq mr b">random</code>的函数来更新我的结构中的值，然后用这个函数重新调整饼图切片。(注:这个我发现了一个bug。请继续阅读。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a5b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在绘制饼图的各个部分时，我还为每个部分添加了边框和标签。我们都很好——除了当一个切片发生变化时，我需要重新绘制至少三个切片，以使事情符合在一起。理论上，我可能需要更多的改变。</p><p id="f644" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用简单的方法解决了这个问题，最后把它们都画了出来。最终的结果是你在这里看到的颤动的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c568ed4e9f280c1f105f7242037ed367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SeF9ux1gVAZA8E8C4U-s4w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有动画值的自动着色饼图</p></figure><p id="c25f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是可以的。我认为总的来说我更喜欢条形图，在上面我可以重画单个的条形。看起来没那么紧张了。</p><p id="80f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我用来构建你在本文顶部看到的图表的代码。它基本上和我用来创建上面那个颤抖的代码一样，只是做了一些小的修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI 2.0饼图绘制代码</p></figure><p id="0c7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结构背后的代码在这里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管理pie结构的Swift代码</p></figure><p id="f02a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让我想到了这篇文章的结尾。</p><p id="b2c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保持冷静，继续编码。</p></div></div>    
</body>
</html>