<html>
<head>
<title>Xcode and the Power of LLDB: Real-Time Application Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xcode和LLDB的威力:实时应用程序管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/xcode-and-the-power-of-lldb-real-time-application-management-642875529fce?source=collection_archive---------10-----------------------#2020-10-06">https://betterprogramming.pub/xcode-and-the-power-of-lldb-real-time-application-management-642875529fce?source=collection_archive---------10-----------------------#2020-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7885" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类固醇上的iOS调试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bc48f88b39fcf48b3529e5ca4fe39df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AyrfFF_ItIt5PDxC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@asoggetti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> asoggetti </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="c71c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">LLDB</h1><p id="ad4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">LLDB是一个高性能调试器，是下一代GNU调试器。<br/>包含一套库，比如Clang表达式解析器，LLVM反汇编器。</p><p id="ace2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">LLDB是macOS、iPadOS、iOS、tvOS和watchOS上的系统调试器。它还可以用于Objective-C和架构的Swift开发:x86_64。i386，ARM和AArch64，以及macOS上Xcode中的默认调试器。它支持在桌面、模拟器和设备上进行调试。LLDB可以通过模块<code class="fe ms mt mu mv b">lldb</code>从Python中导入，并且可以用于与您的环境连接的脚本。</p><p id="7276" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，使用LLDB，您可以通过命令行或脚本运行特殊的命令和表达式，使用应用程序的实时模式获取信息或设置值。以正确的方式使用这个工具，您可以提高您的开发知识和速度，了解内存使用情况，找出您的值的字节大小，等等。</p><p id="e6bc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，让我们突出一些我认为有用的基本命令。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="d962" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">命令</h1><blockquote class="ni"><p id="2560" class="nj nk it bd nl nm nn no np nq nr mm dk translated">如果我在Xcode中已经有了一个很好的GUI，为什么还要通过终端使用任何命令并了解LLDB API？T13】</p></blockquote><p id="29c7" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated"><em class="ny">了解API的主要原因是——有了这些知识，你将知道它提供了什么功能，你可以在其上构建什么，你将能够更快地做出反应，不依赖于UI中未实现的功能，并了解应用程序的内部部分、内存、寄存器等。</em></p><h2 id="16ad" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">过程</h2><p id="d9fd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ms mt mu mv b">process status</code> —显示所选线程和调用堆栈中当前帧中应用程序的当前调试状态。对于报告自动化，通过Python脚本发送会很有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8796081710124dae50db0b7af84a99f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L74ubRAUAsiri_GYiuY3zw.png"/></div></div></figure><h1 id="b0be" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">调用栈</h1><p id="5772" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在执行代码期间，调用栈被创建，并包含栈帧:函数参数、函数的局部变量以及调用结束时返回的地址。</p><p id="4e5d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在调用堆栈中导航以检查您可以使用的应用程序流，并在以下位置找到更多详细信息:</p><h2 id="5a70" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">线</h2><p id="2f5b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在XCode中，您可以在调试导航器的左侧面板中找到GUI，CMD+7。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/69be03880bf091988e52e349e95b9fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*dl1LIRL618llGC7BGC3FKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Xcode调试导航器线程</p></figure><p id="7985" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">thread backtrace</code> —给出当前线程的堆栈帧列表。<br/>如果你想从所有线程中获取列表——分别运行<code class="fe ms mt mu mv b">thread backtrace all</code>和<code class="fe ms mt mu mv b">thread backtrace unique</code>来查看按唯一调用栈分组的列表。</p><p id="28ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要在线程间导航，使用<code class="fe ms mt mu mv b">thread select</code>命令，命令中包含到达堆栈帧所需的线程数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/4e6f05e0a0290a670e5302c01bda8e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtoNjAXjNFqCnW5GVWixXw.png"/></div></div></figure><p id="58b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">thread list</code> —获取包含信息的所有线程列表，并查看星号(*)内的选定线程</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d19bc980fcb980b224baf112dffb5fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTxyoJpP5D9bmp6KCJb50Q.png"/></div></div></figure><p id="11a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">thread return</code> —在框架中存根函数的返回值。编写命令:<code class="fe ms mt mu mv b">thread return false</code>，用于模拟需要的行为。但是只能用标量类型返回。命令的执行需要一些时间。</p><h2 id="4bbc" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">基本框架</h2><p id="dc03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该命令提供了选择和检查当前线程堆栈帧的可能性。</p><p id="11fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">frame variable</code>，简称<code class="fe ms mt mu mv b">frame var</code>，或简称<code class="fe ms mt mu mv b">v</code>，使用它从当前堆栈帧中检索一个值的描述信息，如果提供的话，使用调试信息和内存。否则，它会给出关于该帧的详细信息。</p><p id="9d5a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">命令接受有用的标志，这些标志提供了关于值的有用信息。因此，如果您需要检查该值，请确保您将它放置在适当的框架中，其中存在access变量。您可以使用<code class="fe ms mt mu mv b">frame info</code>查看当前帧的信息。</p><p id="8a27" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，如果我们想检查已经初始化并存在于内存中的值<code class="fe ms mt mu mv b">thing</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f273d148f22ab93eff2334209d1ce8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hoJKNMPI2XDVgY-ZwgbfA.png"/></div></div></figure><p id="1bbc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用特定的标志，您可以获得关于该值的适当输出信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1807927de0c77d6cd71734555e74deee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to8sLC0Bd3NmkDXZO4QleQ.png"/></div></div></figure><p id="b261" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能已经注意到，输出中没有<code class="fe ms mt mu mv b">chance</code>变量。这是因为<code class="fe ms mt mu mv b">chance</code>是计算变量，只能通过表达式— <em class="ny">进行计算，下一段</em>将详细介绍。</p><h2 id="f28e" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated"><strong class="ak">导航</strong></h2><p id="4fd5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您需要在堆栈帧之间移动，<code class="fe ms mt mu mv b">lldb</code>有命令<code class="fe ms mt mu mv b">up</code>和<code class="fe ms mt mu mv b">down</code>，它们可以接受偏移量的参数，因此，如果您在最顶端，并且想要移动到实际的层—编写<code class="fe ms mt mu mv b">down 10000</code>(它将到达计算偏移量或层的边缘)</p><p id="c60e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基于这些命令，我们在Xcode中已经有了图形用户界面(GUI ),比如在线程、帧之间切换、评估值、查看CPU/内存/磁盘/网络报告等。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="6485" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，关于调试环境的通用信息已经描述完毕，让我们看看实际上我们能做些什么。</p><h2 id="4b09" class="nz la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">表示</h2><p id="4e36" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ms mt mu mv b">expression</code>类似于<code class="fe ms mt mu mv b">print</code> —通过编译器评估表达式，因此如果你想要改变值、释放对象、执行函数或计算属性，这是正确的工具。值得注意的是，编写没有值的<code class="fe ms mt mu mv b">expression</code>——打开一个shell来逐行编写表达式，完成后立即执行。</p><p id="be6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除了<code class="fe ms mt mu mv b">expression/print</code>，您还可以使用<code class="fe ms mt mu mv b">po</code>——如果您的值实现了<code class="fe ms mt mu mv b">CustomStringConvertible</code>协议，它将评估对象并调用<code class="fe ms mt mu mv b">description</code>计算属性。<code class="fe ms mt mu mv b">po</code> —与<code class="fe ms mt mu mv b">e -O --</code>相同。如果在调试过程中更改值是清楚的，那么让我们来看看更实际的东西，以获得更快的开发体验，比如动态更改应用程序。</p><h1 id="2f74" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">实时更新视图</h1><p id="2229" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">默认情况下，LLDB评估Objective-C中的表达式，因此为了方便起见，通过:<code class="fe ms mt mu mv b">settings set target.language swift</code>为其设置默认语言。</p><p id="846e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于使用<code class="fe ms mt mu mv b">UIKit</code>的视图，首先导入框架，我们可以创建一个对值的引用并进行所需的操作。</p><p id="6212" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在代码中，它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d81ff2b6fbb6d6765c4cf867671cb573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gngiCwIjkJlLSx2ExeBl6Q.png"/></div></div></figure><p id="6ba2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们使用一级函数<code class="fe ms mt mu mv b">unsafeBitCast</code>，它返回给定实例的位，解释为具有指定的类型。我们需要内存地址和类型来解释。在我的例子中，这是一个“视图控制器”，我的框架当前在它上面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/e12aac567a9b30b12d78c0d5a15ef172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W56WV72_cE_HfYiSxS_wSg.png"/></div></div></figure><p id="a15f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以我们换一下<code class="fe ms mt mu mv b">frame</code>和<code class="fe ms mt mu mv b">backgroundColor</code>。</p><p id="9bb4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ny">记住，你的视图必须出现在渲染树中，所以把断点放在</em> <code class="fe ms mt mu mv b"><em class="ny">viewDidAppear</em></code> <em class="ny">或之后，其他情况。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/87d53f29b8b825df65e085668436d3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKofyp7QMjNtxt-mHMtmew.png"/></div></div></figure><p id="281b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重画渲染树，你在模拟器中的屏幕被更新！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="692e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">值得注意的是，调试器在Xcode 12中得到了改进，更多信息，您可以在这里阅读:</p><div class="or os gp gr ot ou"><a href="https://medium.com/better-programming/whats-new-in-xcode-12-0-6202528b8f9b" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">Xcode 12.0有什么新功能？</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">Swift 5.3、适用于iOS/iPadOS/tvOS 14、watchOS 7和macOS Big Sur的SDK</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="9f43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用所描述的技术，您可以极大地提高开发速度，并模拟不同情况下所需的应用程序流，而无需重新编译。</p><p id="d4d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您有任何建议或问题，请留下回复。感谢阅读！</p></div></div>    
</body>
</html>