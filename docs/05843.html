<html>
<head>
<title>Force-Updating Your Apps Should Be Industry Standard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强制更新你的应用程序应该是行业标准</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/force-update-your-apps-74de57523650?source=collection_archive---------4-----------------------#2020-08-11">https://betterprogramming.pub/force-update-your-apps-74de57523650?source=collection_archive---------4-----------------------#2020-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9008" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及为什么不这样做是一种痛苦</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2699ba9bd3ec1ad3971f306935471901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeCP5gESbEU-JsuGUQaJnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1672346" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>在<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1672346" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片。</p></figure><p id="a84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名后端和应用程序开发人员，我见过几个需要修复应用程序或后端的软件错误。在某些情况下，解决问题最干净的方法是更新应用程序。但由于我们没有办法强制更新我们的应用程序，我不得不在后端代码的端点上进行修复。这从来都不是最佳的，并且随着时间的推移会严重降低代码库的质量。</p><p id="7913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我必须第二次修复同一个端点，因为修复的应用程序版本有另一个bug，该怎么办？我不能总是在补丁上打上补丁，然后希望下一个接触代码的开发者知道所有这些<code class="fe ls lt lu lv b">if-elses</code>和检查是关于什么的。此外，创建越来越多标有“v1”、“v2”、“vN”的端点对我来说也不合适。它扩大了可用的端点数量和我们代码库中的代码行——这一切只是因为我必须确保旧应用程序仍然可以在我的后端正常工作。</p><p id="6d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该如何在这样一个丑陋补丁的丛林中实现一个新特性，并且感觉就像同一端点的200个不同版本？如果出现新问题，我应该调试哪个端点？</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/63c62235056418b37bccf3efa850bf2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXExJXyl2hwJqctG_n-STw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae kv" href="https://pixabay.com/users/mohamed_hassan-5229782/" rel="noopener ugc nofollow" target="_blank"> mohamed_hassan </a>拍摄。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="43de" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">梦想</h1><p id="71cc" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">从开发者的角度来看，每当我认为通过保留应用程序的当前版本无法实现问题的干净解决方案时，我都会强制更新我的应用程序。我可以强制修补应用程序，并在后端以干净的方式修复错误，不需要违反架构或在端点逻辑中流行<code class="fe ls lt lu lv b">if-else</code>。</p><p id="6050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这对用户来说意味着什么呢？强制更新是否过于侵扰？</p><p id="0ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我看来，要看情况。</p><ul class=""><li id="32fd" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">如果你推出了一个应用程序更新，修复了之前“看起来不漂亮”的布局问题，那么我会说，这足以让用户意识到更新，但没有重要到迫使用户下载更新。</li><li id="1d88" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">如果问题属于“由于ID混淆，用户订购了错误的产品”类别，那么尽快强制更新该应用程序。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/d9b1916952b269a9d2f0306d74cf032a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH6ylQu9Pxu4lhM1r2lLWg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://pixabay.com/users/fancycrave1-1115284/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=820275" rel="noopener ugc nofollow" target="_blank"> fancycrave1 </a>在<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=820275" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的照片。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2dbc" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">实现示例</h1><p id="74e6" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">既然我们已经知道了什么时候强制更新，什么时候只通知用户更新，让我们看看<em class="nq">如何在后端和应用程序上实现这样的机制。</em></p><p id="3126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让应用程序知道有更新，我们必须在后端有一个端点来返回最新的兼容应用程序版本号。应用程序在调用任何其他端点之前，总是必须在启动或唤醒时调用此端点。</p><p id="cf81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是来自我们假设的版本控制端点的一个可能的示例响应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="63a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面的例子中看到的，当我们的iOS应用程序调用这个端点时，它将读取<code class="fe ls lt lu lv b">min</code>版本<code class="fe ls lt lu lv b">1.0.0</code>和<code class="fe ls lt lu lv b">max</code>版本<code class="fe ls lt lu lv b">1.1.0</code>。然后，它会将应用程序的本地版本与从我们后端接收的<code class="fe ls lt lu lv b">min</code>和<code class="fe ls lt lu lv b">max</code>版本进行比较。</p><p id="be28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理将始终遵循以下情况之一:</p><ul class=""><li id="e840" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">local version == max version</code> →没有可用的更新，不需要任何操作。</li><li id="4cd4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">local version &lt; max version &amp;&amp; local version &gt; min version</code> →我们可以在应用程序中向用户显示一个<em class="nq">可取消的</em>弹出窗口，通知他们可以下载更新，但不必下载。</li><li id="fefa" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe ls lt lu lv b">local version &lt; min version</code> →应用程序<em class="nq">与后端</em>不兼容，必须强制更新。我们将向用户显示一个模态的、不可撤销的弹出窗口，解释他们必须更新应用程序才能使用它。</li></ul><p id="f925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq">注意:Android应用程序的逻辑是相似的。</em></p><h2 id="7434" class="nt mf iq bd mg nu nv dn mk nw nx dp mo lf ny nz mq lj oa ob ms ln oc od mu oe bi translated">应用程序用户界面示例</h2><p id="2cdf" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">有更新可供下载，用户可以选择使用当前应用程序或从App Store更新它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://github.com/NextFaze/ionic-manup"><div class="gh gi of"><img src="../Images/5b990f1de88d01390ec68f4ccd5fc8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*pUpq8Djysu9Dk_wpTh9V2A.png"/></div></a></figure><p id="9e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有更新可供下载。用户必须更新应用程序，并且不能再使用当前安装的版本。我们强制更新应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://github.com/NextFaze/ionic-manup"><div class="gh gi of"><img src="../Images/e0b4f8c9059c0c56387263c475fe936c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*6wQkTKdDbIsOo7XvB3eG3w.png"/></div></a></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/a9c19bf8042d1055098424f7f9e686e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1kVyI5XkEEgMD9Rsjqwpg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=690192" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=690192" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的免费照片</a>拍摄。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="52e4" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="bcc2" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当我从用户的角度来看这个特性时，总是被告知有新的更新可用是很烦人的。作为用户，我有时甚至没有使用应用程序的选择，并将被迫更新。</p><p id="0f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个应用发行商，我必须小心不要让我的用户不知所措。强制更新经常只会惹恼我的用户，可能会让他们不再使用我的应用。我希望我的用户对我的应用程序有良好的体验，并经常使用它。因此，应该避免在用户每次启动应用程序时用更新弹出窗口打断他们。要减少弹出窗口的数量，只显示一次可选更新的弹出窗口。允许用户跳过一个版本。</p><p id="ab6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种方法来保持应用程序中的代码库和后端的整洁是非常棒的。它节省时间和金钱，减少开发人员的挫折感，并使支持应用程序更容易。这也是我个人认为所有app都应该有这个机制的原因。更好的是，苹果和谷歌应该为我们提供一个内置的机制，让开发者和应用程序用户更容易地完成整个过程。</p></div></div>    
</body>
</html>