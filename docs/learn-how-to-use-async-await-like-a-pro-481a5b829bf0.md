# 如何像专业人士一样在 JavaScript 中使用 Async/Await

> 原文：<https://betterprogramming.pub/learn-how-to-use-async-await-like-a-pro-481a5b829bf0>

## 深入了解 JavaScript 的强大工具

![](img/17ccedf59e3814891b75ecbdf8fa0d33.png)

来自[佩克斯](https://www.pexels.com/photo/person-encoding-in-laptop-574071/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)的[卢卡斯](https://www.pexels.com/@goumbik?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)的照片

在每个程序员的一生中，总有一天他们需要知道如何处理异步代码。

第一次理解如何处理异步代码可能有点令人生畏。幸运的是，我在这里解释这一切是如何工作的，这样当这种情况出现时，你可以更好地准备。

但是首先，我们应该知道同步代码和异步代码的区别。

# 什么是异步代码？

异步被定义为在不同时间发生的两个或多个事件。通过下面的例子，我们可以更好地理解这一点:

在上面的例子中，我们可以清楚地看到我们的代码按照我们期望的顺序执行。我们称之为同步代码。

我们写的很多东西都被认为是同步的，但是当我们试图在执行其他行之前延迟其中一行时会发生什么呢？

等等…我们的产出怎么了？

如您所见，我们的输出有点杂乱无章，没有任何意义。实际上，我们的代码应该同时执行，并等待超时结束后再继续，但事实并非如此。

发生的情况是，超时函数与其余代码同时被调用，但直到 500 毫秒后才触发我们的内部日志，给我们错误的输出。

这一行代码的执行时间与其他代码不同。我们称之为异步。

那么我们如何解决这个问题呢？

为了解决这个问题，我们需要一种方法来停止其余代码的执行，直到我们的超时函数完成。幸运的是，JavaScript 给了我们这样做的工具。

# 承诺

我知道你可能在想什么…不，我不是在说尼禄 2011 年的歌…我是在说 JavaScript 的承诺。

承诺可以想象成一个[回调函数](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function) **。像回调函数一样，promise 在返回值之前等待我们的内部代码完成。**

这里的区别是，一旦我们的异步代码完成，我们的承诺返回一个状态，允许我们使用`then()`和`catch()`等方法采取进一步的行动。

*旁注:*在本文中，我不会深入研究承诺，但我只想让您理解基本概念，因为它们在以后会很重要。

看看下面的例子。如您所见，我们的输出再次恢复正常:

但这是怎么发生的呢？

正如我前面提到的，承诺允许我们在执行其余部分之前等待异步代码完成。在这个例子中，您可以看到我们已经将超时函数包装在一个承诺中，以修复这个问题。

一旦我们的超时函数完成，我们就解析我们的承诺，并告诉我们的代码可以继续进一步执行。在我们的承诺成功之后，我们使用`then()` 来执行剩余的同步代码，就像之前一样。

假设我们的承诺没有实现，反而被拒绝了。我们的产量会有什么变化？

我们可以看到，如果我们的承诺被拒绝，就会调用`catch()`方法，在我们的例子中，它会记录一条错误消息并退出剩余的代码。当这种情况发生时，我们不需要记录错误。

有条件地，我们可以说，“如果我们的承诺被拒绝，那么继续我们的代码”，而不是在失败时停止。

引入承诺可以使处理异步代码变得容易得多，但是我们开始链接的承诺越多，我们的代码就变得越复杂，可读性就越差。

如果这不是最好的解决方案，那么什么是呢？

# 输入异步/等待

通过利用 JavaScript 的 async/await 关键字，我们可以使我们的代码更加完美，可读性更好。让我们看看在前面的例子中使用 async/await 时会发生什么:

这看起来好多了！

如果我们看一下上面的例子，我们可以看到我们的输出仍然和以前一样。以这种方式编写代码可以让我们避免承诺链，同时保持可读性。

这是通过从前面获取相同的异步代码来实现的，除了这次我们在函数前面添加了`await`关键字，并存储我们得到的承诺的结果。

当我们运行我们的代码时，我们的主函数将等待我们的`async_func` 解析，然后执行我们代码的剩余部分。

我们还将剩余的同步代码包装在一个名为`main()`的函数中，并使用了`async`关键字。正如承诺有规则一样，我们也必须遵循 async/await 的规则，这样才能工作。

规则规定，如果我们想要使用`await` 关键字，那么它必须包含在`async`函数中。这就是通知我们的函数的内容，它说:“我应该期待内部的异步代码”。

现在，假设我们想在上面的例子中添加另一段异步代码。会发生什么？

注意，在这个例子中，我们添加了另一个异步代码块，我们的输出仍然是我们期望的顺序。

如果仔细观察，您会发现第二个异步函数被设置为在第一个函数之前 30 毫秒运行。那么为什么没有呢？

在同步情况下，第二个函数确实会在第一个函数之前被调用，我们会得到错误的输出。

由于我们使用的是 async/await，我们的代码在第一个函数处停止，等待 530ms 来解析。然后继续执行第二个函数，并在被解析之前等待 500 毫秒，这就是 async/await 的强大之处。

让我们看一个使用 async/await 的更实际的例子:

在这个例子中，我们模拟了一个对后端的调用，并检索了一个字符列表，我们需要用它来检查冒名顶替者。

在我们的 main 函数中，我们等待使用关键字`await`解析我们的承诺，这反过来会给出我们所请求的字符列表。

然后，我们使用 reduce 方法获得每个字符的计数，并存储找到它们的索引以及它们的名称。

完成之后，我们过滤掉我们的`counts`对象中任何计数为 1 的字符，然后将其映射到我们的`imposters`数组。

然后我们显示`imposters`的列表，并揭示它们在我们的角色数据中的位置。

如果我们在这个实际的例子中没有使用`async/await`,我们将会面临导致错误代码的错误。

并不是所有的异步代码都会提醒我们一个值得注意的问题，所以了解这些情况会在哪里出现并以最好的方式处理它们是一个很好的实践。

# 结论

好了，你知道了。试图弄清楚如何处理异步代码肯定是一个挑战，尤其是第一次看到它。您接触异步代码越多，就越能更好地处理这种情况。

希望这能让你对 async/await 的工作原理有所了解，在你知道之前，你很快就会成为一名 JavaScript 专家。

感谢您的阅读。