<html>
<head>
<title>Do You Use the Most Crucial Principle of Object-Oriented Design?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你使用了面向对象设计的最重要的原则吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/do-you-use-the-most-crucial-principle-of-object-oriented-design-9045dbd1321e?source=collection_archive---------15-----------------------#2020-03-17">https://betterprogramming.pub/do-you-use-the-most-crucial-principle-of-object-oriented-design-9045dbd1321e?source=collection_archive---------15-----------------------#2020-03-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2913" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">开合原理在起作用</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/71a3847f3335f8d4fd277d038ad38e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eT11VV5ZfLF3rW5tYQaNSg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/s/photos/open-closed-open?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kz" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</p></figure><p id="b32e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">面向对象设计最重要的原则是开闭原则(OCP)。</p><p id="cdf4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我花了一段时间才理解了OCP。我发现“模块应该既开放又封闭”这个矛盾很模糊。</p><p id="bd4b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到我读了马丁·福勒的《重构:改进现有代码的设计》之后，这一切才开始变得有意义。</p><p id="33f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我将阐述我对OCP的观点。我将使用两个真实的例子——一个来自以前的项目，另一个来自GitHub上的开源项目。</p><p id="d3ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我将分享一些启发式方法来检测可以使用OCP改进的源代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9db6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">OCP的定义</h1><p id="d3fd" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">一点历史:</p><p id="468a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">OCP是Bertrand Meyer在1988年他的书<a class="ae kz" href="https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction" rel="noopener ugc nofollow" target="_blank">“面向对象软件构造”中描述的五个原则之一</a>这五个软件构造原则描述了如何使用面向对象的概念创建模块化系统。</p><p id="c144" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在书中，伯特兰把OCP描述为:</p><blockquote class="na nb nc"><p id="e848" class="la lb nd lc b ld le jv lf lg lh jy li ne lk ll lm nf lo lp lq ng ls lt lu lv in bi translated">模块应该是开放的和封闭的。<br/>如果一个模块仍可用于扩展，则称其为开放的。<br/>如果一个模块可供其他模块使用，则该模块被认为是关闭的。</p></blockquote><p id="ff14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2000年，Robert C. Martin在《设计原则和设计模式》中描述了这一原则:</p><blockquote class="na nb nc"><p id="06a2" class="la lb nd lc b ld le jv lf lg lh jy li ne lk ll lm nf lo lp lq ng ls lt lu lv in bi translated">“我们希望能够改变模块的功能，而不改变模块的源代码。”</p></blockquote><p id="920d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">后来，Michael Feathers从Robert C. Martin的“设计原则和设计模式”中提出了代表五个重要原则的缩写词SOLID。这增加了原则的普及。</p><p id="412a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实线中的O代表开闭原理</p><h2 id="238e" class="nh me iu bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">OCP背后的原因是什么？</h2><p id="2afe" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">OCP和其他面向对象设计原则背后有一个问题:</p><p id="e7db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们如何设计一个系统，使得向应用程序代码库添加新功能变得容易？</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0c2b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">OCP是什么意思？</h1><p id="56b5" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">OCP声明我们应该能够在不改变源代码的情况下改变一个模块的功能。</p><p id="fd6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这听起来不奇怪吗？如何在不改变源代码的情况下改变模块的行为？这恰恰是我第一次学习这个原理时的挣扎。</p><h2 id="6397" class="nh me iu bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">对扩展开放，但对修改关闭</h2><p id="40d0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果我们看看另一种解释，OCP开始变得更有意义了:“一个模块应该为了扩展而<em class="nd">打开</em>，为了改变而<em class="nd">关闭【T11”。”</em></p><p id="a296" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们可以添加新的东西——但不能改变现有的源代码。</p><p id="0dd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们开始有所进展了。因此，我可以添加一个类，但不能更改现有的类。</p><p id="dae6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么，我们如何设计一个在添加新类时改变其行为的应用程序呢？有一个简单的答案:</p><p id="fccf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用继承和多态。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e655" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第一个例子:物联网传感器测量</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/51f732e249780a0067b16fa0149f8733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH-5KGaOWmcoDMRTdEAxng.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">利用物联网技术测量温室温度。作者照片。</p></figure><p id="2bf2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看一个例子。我们有一个物联网解决方案，可以从不同类型的传感器读取测量值。这些传感器测量温度、湿度、二氧化碳和压力。</p><p id="5404" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在应用程序可以使用测量值之前，它必须转换该值。</p><p id="c370" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每种类型的传感器的转换是不同的。有些直接返回正确的值，有些使用线性转换，还有一些使用更复杂的转换。</p><h2 id="8d77" class="nh me iu bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">不遵循OCP的转换</h2><p id="524d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">下面的模块显示了一个用于转换值的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将传感器测量值从总值转换为净值</p></figure><p id="03d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该函数接受传感器类型和总值。根据<code class="fe nw nx ny nz b">sensorType</code>，该函数执行特定的转换。</p><p id="a0d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前该功能支持三种类型的传感器:<code class="fe nw nx ny nz b">PT500</code>、<code class="fe nw nx ny nz b">ERH</code>和<code class="fe nw nx ny nz b">CLIMAPREC</code>。如果我们必须支持一种新的传感器，我们必须通过向交换机添加新的外壳来改变它。</p><p id="6d93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们做这个改变时，我们可能会在现有的转换中引入错误。在修改现有代码时引入错误是OCP试图阻止的。</p><p id="0ebc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，这个模块<em class="nd">没有</em>遵循OCP。不是关闭修改的。</p><p id="2bba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们如何改变这个转换函数，使其适用于OCP？</p><h2 id="aa2a" class="nh me iu bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">使用OCP进行转换</h2><p id="5ad3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们引入了多个传感器类别，而不是单一的转换功能。每个传感器类别负责特定传感器类型的转换。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">pt500-sensor.js，一个用于从pt500温度传感器转换总值的类</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">clima-sensor.js，用于转换提斯降水传感器的总值的类</p></figure><p id="b09b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">执行实际转换的函数使用一组传感器类型。传感器构建器模块创建此集合。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">sensorbuilder.js，用于构建传感器字典的模块</p></figure><p id="d128" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nw nx ny nz b">MeasurementConverter</code>使用给定的<code class="fe nw nx ny nz b">sensorType</code>作为检索正确的<code class="fe nw nx ny nz b">sensor</code>类的密钥。</p><p id="13c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在这个检索到的<code class="fe nw nx ny nz b">sensor</code>类上调用<code class="fe nw nx ny nz b">convert</code>函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">measurementConverter.js，执行实际转换的模块</p></figure><p id="d734" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们必须支持一个新的传感器类型，我们为这个特定的传感器添加一个新的类，并实现convert函数。</p><p id="bb96" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们添加了一个新的类，而不是改变现有的代码。我们没有将错误引入现有代码的风险。</p><p id="5a8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是OCP在行动。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ace2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">第二个例子:Fastify注册路由</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/e9549a596e54f5713a54628d6c0e7244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4chyoXWTBSc6--53-jeVw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Node.js的快速低开销web框架</p></figure><p id="5573" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您是否注意到在前面的示例中，我仍然必须更改填充传感器字典的源代码？如果严格来说，也不是完全的开合。如果我还想删除这个更改，我必须从文件系统中加载传感器。</p><p id="c239" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/israeleriston/fastify-register-routes" rel="noopener ugc nofollow" target="_blank"> Fastify Register Routes </a>是由Israelériston创建的Fastify插件，它从指定路径加载路线，并将其注册到Fastify。</p><p id="6a6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看看以色列是如何实现这一功能的很有意思。下面我们可以看到部分源代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从文件系统加载路由文件并需要它们</p></figure><p id="dee9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第8行，他从一个特定的目录中检索所有可用的路由文件。然后在第9行，他使用<code class="fe nw nx ny nz b">.map</code>对每个文件调用<code class="fe nw nx ny nz b">require</code>。这将产生一个具有路由功能的数组。</p><p id="8a83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后他为每条满载的路线呼叫<code class="fe nw nx ny nz b">registerRoutes</code>。这将向Fastify注册每条路由。</p><pre class="kk kl km kn gu ob nz oc od aw oe bi"><span id="756b" class="nh me iu nz b gz of og l oh oi">const routes = loadRoutesByPath(dirname, options);<br/>routes.forEach(route =&gt; registerRoutes(server, route));</span></pre><p id="9c55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果是，您可以通过添加一个定义路由的JavaScript文件来将路由添加到API中。所以没有必要改变现有的源代码。</p><p id="7681" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是OCP的又一个美丽例子。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="39ce" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">如何识别可以改进的源代码</h1><p id="60b9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">那么，如何利用OCP来识别解决方案中可以改进的地方呢？</p><p id="6f3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在Martin Fowler的《重构:改进现有代码的设计》一书中找到了一些技巧。顺便说一句，这是一本极好的书。</p><h2 id="b40b" class="nh me iu bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated"><strong class="ak">用多态替换条件</strong></h2><p id="3f9f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">书中所做的重构之一是用多态替换条件。在以下情况下，您可以应用此重构:</p><blockquote class="na nb nc"><p id="a49b" class="la lb nd lc b ld le jv lf lg lh jy li ne lk ll lm nf lo lp lq ng ls lt lu lv in bi translated">"你有一个根据对象类型选择不同行为的条件."</p></blockquote><p id="3429" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这正是前面传感器示例的情况。根据传感器的类型，我使用不同的转换函数。更具体地说:如果您的源代码中有一个使用类型代码的开关，这可能是需要改进的地方。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">带有类型代码的开关—使用OCP的可能位置</p></figure><p id="2008" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您的源代码包含基于类型代码的if-else-if结构，而不是开关，这可能也是一个需要改进的地方。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">基于类型代码的if-else-if结构——使用OCP的另一个可能位置</p></figure><p id="2500" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以每当你在源代码中看到一个变化，我希望你能想想OCP。你能通过继承和多态来改进设计吗？</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e3d2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="11df" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">OCP是面向对象设计最重要的原则之一。如果您正确使用它，它会使您的源代码更加模块化和易于维护。</p><p id="13b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两个真实世界的例子展示了如何使用OCP。第一种方法使用OCP将总测量值转换为净值。在第二个例子中，Fastify插件使用OCP来添加路线。</p><p id="f461" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，每当你在源代码中看到开关或if-else-if结构时，我希望你问自己一个问题。这个问题是:“我可以应用OCP来改进源代码的设计吗？”</p><p id="09df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>