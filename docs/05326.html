<html>
<head>
<title>When to Not Use Lists in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中何时不使用列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-not-to-use-lists-in-python-5-alternatives-to-consider-11121a6ec33?source=collection_archive---------1-----------------------#2020-06-30">https://betterprogramming.pub/when-not-to-use-lists-in-python-5-alternatives-to-consider-11121a6ec33?source=collection_archive---------1-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们探索五种选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34d6b86a7c2eaa5eeb2326d224ab881e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5UQ9HHBA-h6YdhD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@coopery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·诺哈西</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="99e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，最流行的容器数据类型可能是<code class="fe lv lw lx ly b">list</code>。它非常灵活，可以在我们项目的任何地方使用，保存各种类型的数据:整数、字符串和自定义类实例。此外，它是可变的，这允许我们根据需要添加或删除项目。由于这些原因，一些程序员倾向于过度使用列表，而不考虑可行的替代方案。</p><p id="b54c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想强调五个场景，在这些场景中，有比列表更好的选项值得考虑。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="774b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.数据不变性和哈希——元组</h1><p id="7327" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们并不总是需要我们的数据容器来改变。有时候，我们实际上根本不希望我们的数据容器发生变化。在这种情况下，我们需要一个不可变的数据容器来保存我们的数据。假设用户为我们构建的应用程序选择了四位数字作为他/她的安全代码。理论上，我们可以使用list对象来存储这些数字。然而，不希望的事情可能会发生——代码可能会被意外更改。考虑下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表的可变性</p></figure><p id="b39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，这两个列表被认为是相同的，因此用户可以解锁受保护的信息。然而，如果我们只改变保存的代码中的一个数字，两个列表就变得不相等，用户就失去了对安全信息的访问。所以，我们希望保存的代码是不可变的。</p><p id="2c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们应该考虑使用元组。众所周知，元组在Python中是不可变的对象，这意味着它们的值在被创建后就不能被更改。下面通过使用元组显示了替代实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">元组的不变性</p></figure><p id="b66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，保存的代码现在使用一个元组存储。试图更改其中一个数字导致了<code class="fe lv lw lx ly b">TypeError</code>，这阻止了代码的任何意外更改。此外，作为数据安全的一种简单实现，tuple对象可以在Python中直接散列。通过将代码存储在一个元组对象中，我们可以有一个哈希值来表示代码，这使得黑客更难破解应用程序。看一看简化的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">散列能力:列表与元组</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a6b4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.成员检查—集合</h1><p id="0888" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">根据特定应用程序的业务需求，您经常需要检查数据容器是否有您正在寻找的特定项。当然，列表具有所需的内置方法，允许您评估成员资格。如下所示，我们可以简单地使用<code class="fe lv lw lx ly b">in</code>关键字来执行检查，这将返回一个布尔值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成员资格检查</p></figure><p id="9c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您的应用程序需要频繁的成员检查，您应该考虑使用集合而不是列表。集合是Python中另一种重要的内置容器数据类型。集合的独特之处在于<em class="nf">集合</em>中的所有元素都必须是唯一且可散列的。之所以强制执行哈希能力要求，是因为在内部，Python将集合实现为哈希表。使用散列表作为实现机制的最大好处之一是，对于特定的项目，有一个分摊的或恒定的查找时间。</p><p id="c523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做一个简单的比较，展示当容器有数百万条记录时，集合的表现如何优于列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成员资格检查:列表与集合</p></figure><p id="1d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，随着<code class="fe lv lw lx ly b">list</code>中元素数量的增加，成员资格检查的时间线性增加。相比之下，使用<code class="fe lv lw lx ly b">set</code>进行会员资格检查的时间几乎保持不变，更重要的是，所需时间比使用<code class="fe lv lw lx ly b">list</code>短得多。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="55e6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.价值检索—词典</h1><p id="6436" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与上面讨论的<code class="fe lv lw lx ly b">set</code>类似，另一个导入内置数据类型<code class="fe lv lw lx ly b">dict</code>要求它的键是可散列的。</p><p id="6322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">键的可散列性意味着存储在<code class="fe lv lw lx ly b">dict</code>中的数据涉及哈希表的实现——事实就是如此。像其他主流语言(如Java、Swift、Kotlin)一样，Python使用哈希表来操作字典。然而，与集合不同，字典存储键-值对，可散列键的需求是构建哈希表的基础。</p><p id="6a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用哈希机制，检索特定键值对所需的时间是常数，时间复杂度为<code class="fe lv lw lx ly b">O(1) </code>——使用<a class="ae ky" href="https://medium.com/swlh/time-complexity-of-algorithms-big-o-notation-explained-in-plain-english-e12a11dc4a4f" rel="noopener"> Big-O符号</a>。这个<code class="fe lv lw lx ly b">O(1)</code>时间复杂度意味着无论<code class="fe lv lw lx ly b">dict</code>有多少个元素，检索一个特定项目的时间总是保持在相同的数量级。我们可以在下面看到一个快速对比:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">值检索:列表与字典</p></figure><p id="18d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要存储一组学生的分数。使用列表，我们将有一个列表存储学生ID号，另一个列表存储相应位置的分数。为了找出一个特定学生的分数，我将首先找出该学生的指数，并使用该指数来获得分数。相比之下，使用字典，我们将只存储所有这些以学生ID号作为键的<code class="fe lv lw lx ly b">student_id-score</code>对。如上所示，在这两种方法中，当记录数较高时，字典比列表方法表现得更好。</p><p id="4d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有一点需要注意，因为字典存储键值对，所以您的数据模型应该有有意义的信息来标识值。此外，字典中的键必须是唯一的，尽管值可以相同。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="801e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.先进先出—德克</h1><p id="b676" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，我们需要频繁地在序列的末尾添加和删除项目。这就要求物品的操作遵循先进先出的顺序。换句话说，将首先处理添加的第一个项目。使用列表，我们可以通过使用<code class="fe lv lw lx ly b">pop(0)</code>函数来实现这个需求。然而，这个动作的执行是耗时的，因为列表的项目必须移位，这是一个<code class="fe lv lw lx ly b">O(n)</code>操作。</p><p id="a54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，<code class="fe lv lw lx ly b">deque</code>数据类型是一个双端队列，设计用于从两端快速插入和移除。为了执行FIFO操作，Python将能够直接删除队列开头的项，而不需要移动所有的项。意味着这个FIFO操作很快。我们来看看下面的对比:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">先进先出:列表与德克</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="21c6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.大量列表数据—数组</h1><p id="d596" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Python已经逐渐广泛用于数据科学领域的数据处理、分析和建模。这种日益流行的一个主要原因是各种开源软件包的发展。重要的是，他们已经开发了用于大规模数据集的定制类。因此，我们应该考虑专门为这些计算相关的工作设计的替代方案，而不是使用列表。</p><p id="7784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您需要处理大量的数字数据，您应该考虑使用<code class="fe lv lw lx ly b">NumPy</code>数组，这是在<code class="fe lv lw lx ly b">NumPy</code>包中实现的核心数据类型。如果您需要处理具有混合数据类型(例如字符串、日期、数字)的结构化数据，您应该考虑使用<code class="fe lv lw lx ly b">Pandas DataFrame</code>，这是在<code class="fe lv lw lx ly b">Pandas</code>包中实现的核心数据类型之一。如果你做机器学习，你肯定需要查一下<code class="fe lv lw lx ly b">tensors</code>，这是各大机器学习框架中最重要的数据类型，比如<code class="fe lv lw lx ly b">TensorFlow</code>和<code class="fe lv lw lx ly b">PyTorch</code>。</p><p id="903f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互联网上有许多教程，对这些数据结构的详细讨论超出了本文的范围。我的观点是，如果你处理大量的数据记录，你肯定应该研究这些替代方案——它们在较低的级别有特殊的实现，这些实现是为了优化大量的操作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="658a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="c3ac" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们回顾了Python中列表的五种替代方案。</p><p id="b8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不应该将自己局限于使用列表，因为Python及其相关包已经为我们提供了其他数据结构，这些数据结构为我们的特定业务需求提供了最佳解决方案。</p><p id="44ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是保持开放的心态，确保你完全了解你的选择。</p></div></div>    
</body>
</html>