# 用依赖注入解耦你的代码

> 原文：<https://betterprogramming.pub/decouple-your-code-with-dependency-injection-d893ae9edcf8>

## 不需要第三方框架

![](img/57b706b64eedbb47c99e0160aa965e7b.png)

[Icons8 团队](https://unsplash.com/@icons8?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/ingredients?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

没有多少组件是独立存在的，不依赖于其他组件。我们可以通过利用*依赖注入* (DI)来改进[关注点分离](https://en.wikipedia.org/wiki/Separation_of_concerns)，而不是创建紧密耦合的组件。

本文将向您介绍依赖注入的核心概念，不需要第三方框架。所有代码示例都将使用 Java，但是一般原则也适用于任何其他语言。

# 示例:数据处理器

为了更好地形象化如何使用依赖注入*、*，我们从一个简单的类型开始:

`DataProcessor`有两个依赖项:`DbManager`和`Calculator`。在我们的类型中直接创建它们有几个明显的缺点:

*   构造函数调用可能会崩溃。
*   构造函数签名可能会改变。
*   紧密绑定到显式实现类型。

是时候改进了！

# 依赖注入

《敏捷开发的艺术》 ，[的作者 James Shore 说得很好](https://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html):

> *“依赖注入是一个 5 美分概念的 25 美元术语。”*

这个概念实际上非常简单:给一个组件完成它的工作所需的所有东西。

一般来说，这意味着通过从外部提供组件的依赖关系来解耦组件，而不是直接创建组件，这样会产生粘连。

我们可以通过不同的方式为实例提供必要的依赖关系:

*   构造函数注入
*   资产注入
*   方法注入

## 构造函数注入

构造函数，或基于初始值设定项的依赖注入，意味着在实例初始化期间提供所有必需的依赖项，作为构造函数参数:

由于这个简单的改变，我们可以抵消大部分最初的缺点:

*   容易替换:`DbManager`和`Calculator`不再被绑定到具体的实现，现在可以模拟单元测试。
*   已经初始化并且“准备就绪”:我们不需要担心依赖项所需的任何子依赖项(例如，数据库文件名、有效数字)，或者它们可能在初始化期间崩溃。
*   强制性要求:调用者确切地知道创建一个`DataProcessor`需要什么。
*   不变性:依赖仍然是最终的。

尽管构造函数注入是许多 DI 框架的首选方式，但它也有明显的缺点。最重要的一点是，所有的依赖项都必须在初始化时提供。

有时，我们自己不初始化一个组件，或者我们不能在那时提供所有的依赖。或者我们需要使用另一个构造函数。而且依赖关系一旦设定，就无法更改。

但是我们可以通过使用其他注射类型之一来缓解这些问题。

## 资产注入

有时我们无法访问类型的实际初始化，只有一个已经初始化的实例。或者在初始化时并不明确知道所需的依赖关系，而这在以后会知道。

在这些情况下，我们可以使用*属性注入*，而不是依赖于构造函数:

不再需要构造函数，我们可以在初始化后随时提供依赖关系。但是这种注射方式也有缺点:*可变性*。

我们的`DataProcessor`在初始化后不再保证“准备就绪”。能够随意改变依赖关系可能会给我们带来更多的灵活性，但也带来了更多运行时检查的缺点。

我们现在必须处理访问依赖项时出现`NullPointerException`的可能性。

## 方法注入

即使我们用构造函数注入和/或属性注入来解耦依赖，通过这样做，我们仍然只有一个选择。如果我们在某些情况下需要另一个`Calculator`怎么办？

我们不想为第二个`Calculator`添加额外的属性或构造函数参数，因为将来可能需要第三个。并且每次在我们调用`calc(...)`之前改变属性也是不可行的，并且很可能导致错误使用错误的属性。

更好的方法是用它的依赖项参数化方法调用本身:

现在`calc(...)`的调用者负责提供一个合适的`Calculator`实例，`DataProcessor`与之完全解耦。

通过混合不同类型的注入，甚至可以获得更大的灵活性，并提供默认的`Calculator`:

呼叫者*可以*提供不同类型的`Calculator`，但是*不必*。我们仍然有一个解耦的、准备就绪的`DataProcessor`，能够适应特定的场景。

# 选择哪种注射方式？

每种依赖注入都有自己的优点，没有“正确的方法”。这完全取决于你的实际要求和环境。

## 构造函数注入

构造函数注入是我的最爱，也是 DI 框架的首选。

它清楚地告诉我们创建一个特定组件所需的所有依赖项，并且它们不是可选的。这些依赖关系在整个组件中都是必需的。

## 资产注入

属性注入更好地匹配可选参数，如侦听器或委托。或者如果我们不能在初始化时提供依赖关系。

其他一些语言，比如 Swift，大量使用带有属性的[委托模式](https://en.wikipedia.org/wiki/Delegation_pattern)。因此，使用它将使我们的代码为其他开发人员所熟悉。

## 方法注入

如果每个调用的依赖可能不相同，那么方法注入是一个完美的匹配。这将进一步解耦组件，因为现在，只有方法本身具有依赖性，而不是整个组件。

记住这不是非此即彼的问题。我们可以在合适的地方自由混合不同的类型。

# 控制容器的倒置

我们可以用依赖注入的这些简单实现来覆盖很多用例。这是一个很好的解耦工具，但是我们实际上仍然需要在某些时候创建依赖关系。

但是随着我们的应用程序和代码库的增长，我们可能需要一个更完整的解决方案来简化创建和组装过程。

*控制反转* (IoC)是[控制流](https://en.wikipedia.org/wiki/Control_flow)的抽象原理。依赖注入是其更具体的实现之一。

IoC 容器是一种特殊的对象，它知道如何实例化和配置其他对象，包括为你做依赖注入。

有些容器可以通过反射来检测关系，有些则需要手动配置。有些是基于运行时的，有些是在编译时生成所有需要的代码。

比较所有不同的选项超出了本文的范围，但是让我们看一个小例子来更好地理解这个概念。

## 例如:匕首 2

[Dagger](https://dagger.dev/) 是一个轻量级的编译时依赖注入框架。我们需要创建一个`Module`，它知道如何构建我们的依赖关系，稍后只需添加一个`@Inject`注释就可以注入它:

`@Singleton`确保只创建一个依赖实例。

为了被注入依赖项，我们只需将`@Inject`添加到构造函数、字段或方法中:

这些只是绝对的基础知识，乍一看可能并不令人印象深刻。但是 IoC 容器和框架不仅允许我们分离组件，还允许我们最大化依赖创建的灵活性。

由于所提供的高级特性，创建过程变得更加可配置，并支持使用依赖项的新方法。

## 高级功能

不同种类的 IoC 容器和底层语言之间的特性差异很大，比如:

*   代理模式和延迟加载。
*   生命周期范围(例如，单例与每个线程一个)。
*   自动布线。
*   单个类型的多个实现。
*   循环依赖。

这些特性是 IoC 容器的真正力量。你可能认为像“循环依赖”这样的特性不是一个好主意。你是对的。

但是，如果由于遗留代码或者过去不可改变的糟糕设计决策，我们确实需要这种奇怪的代码结构，我们现在有能力这样做。

# 结论

我们应该针对抽象来设计我们的代码，比如接口，而不是具体的实现，以减少粘连。

我们的代码需要的唯一信息必须在接口中可用，我们不能对实际的实现做任何假设。

> 一个人应该依赖抽象，而不是具体。
> —罗伯特·c·马丁(2000)，设计原则和设计模式

依赖注入是一个很好的方法，通过解耦我们的组件来做到这一点。它允许我们编写更干净、更简洁、更易于维护和重构的代码。

选择三种依赖注入类型中的哪一种取决于环境和需求，但是我们也可以混合使用这些类型来最大化收益。

IoC 容器可以通过简化组件创建过程来提供另一种便利的布局，有时几乎是以一种神奇的方式。

我们应该到处使用它吗？当然不是。

就像其他模式和概念一样，我们应该在适当的时候应用它们，而不仅仅是因为我们可以。

永远不要把自己局限在单一的做事方式上。也许[工厂模式](https://en.wikipedia.org/wiki/Factory_method_pattern)或者甚至广为厌恶的[单例模式](https://en.wikipedia.org/wiki/Singleton_pattern)对你的需求来说可能是更好的解决方案。

# 资源

*   [控制容器的倒置和依赖注入模式](https://www.martinfowler.com/articles/injection.html)(马丁·福勒)
*   [依赖倒置原则](https://en.wikipedia.org/wiki/Dependency_inversion_principle)(维基百科)
*   [控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)(维基百科)

# 国际奥委会集装箱

## Java 语言(一种计算机语言，尤用于创建网站)

*   [匕首](https://dagger.dev/)
*   [弹簧](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-introduction)
*   [挂毯](https://tapestry.apache.org/ioc.html)

## 科特林

*   [锦鲤](https://insert-koin.io/)

## 迅速发生的

*   [倾斜](https://github.com/AliSoftware/Dip)
*   斯温杰特

## C#

*   [自动飞行控制](https://autofac.org/)
*   [温莎城堡](http://www.castleproject.org/projects/windsor/)