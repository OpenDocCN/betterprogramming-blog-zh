<html>
<head>
<title>Understanding Browser Networking and Optimizing Requests for HTTP/1.1 and HTTP/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解浏览器网络并优化HTTP/1.1和HTTP/2的请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-browser-networking-and-how-to-optimize-the-requests-for-http-1-1-and-http-2-f6371f0af650?source=collection_archive---------0-----------------------#2019-07-20">https://betterprogramming.pub/understanding-browser-networking-and-how-to-optimize-the-requests-for-http-1-1-and-http-2-f6371f0af650?source=collection_archive---------0-----------------------#2019-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a3f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文不是提供优化web应用程序的网络性能所需的待办事项列表，而是旨在提供对浏览器如何管理HTTP请求的更深入的理解。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="8fa3" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">传输控制协议</h1><p id="cd3b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">TCP和IP是构成所谓的互联网协议套件<a class="ae ly" href="https://en.wikipedia.org/wiki/Internet_protocol_suite" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a>的协议。它们是其他更高层协议的基础，如IMAP、HTTP、HTTPS、SSH或TLS。</p><p id="65b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，这是非常复杂的，所以我将把每个角色简化到本文的范围内。</p><h2 id="2bbe" class="ma kw it bd kx mb mc dn lb md me dp lf kb mf mg lj kf mh mi ln kj mj mk lr ml bi translated">互联网协议(Internet Protocol)</h2><p id="e6d3" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">IP的作用是寻址和识别主机(通过<a class="ae ly" href="https://en.wikipedia.org/wiki/IP_address" rel="noopener ugc nofollow" target="_blank"> IP寻址</a>)，<br/>并通过将数据包转发到离目的地更近的下一个网络路由器(不同的数据包可以有不同的路由)将数据包路由到最终目的地。</p><h2 id="29f3" class="ma kw it bd kx mb mc dn lb md me dp lf kb mf mg lj kf mh mi ln kj mj mk lr ml bi translated">传输控制协议（Transmission Control Protocol）</h2><p id="4be4" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">TCP最重要的作用是与主机建立连接。</p><p id="d141" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还确保数据包按顺序到达，因为IP可能通过不同的路由发送数据包，并且可能以不同于发送顺序的顺序到达。</p><p id="3d63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还处理丢失和重复的数据包，并防止主机因数据过多而使彼此或底层网络不堪重负(<a class="ae ly" href="https://en.wikipedia.org/wiki/TCP_congestion_control" rel="noopener ugc nofollow" target="_blank"> TCP拥塞控制</a>)。</p><p id="f409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">冒着让你们中的一些人厌烦的风险，我认为提醒我们自己数据是通过TCP成块传输的是很重要的。</p><p id="ae17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发送方和接收方首先协商这些数据块有多大。</p><p id="03e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，根据网络条件，随着数据流进行调整，以便块具有最佳大小。足够大以便数据快速传输，但又足够小以便网络能够处理。</p><p id="74c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发送方将通过发送大小为x的初始(相对较小的)块开始。</p><p id="f923" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在发送下一条消息之前，它将等待来自服务器的ACK响应，以确认接收者确实收到了数据。</p><p id="11d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，它将尝试发送两倍多的数据。如果运行正常，并在超时前再次收到ACK，它将再次加倍数量，以此类推。</p><p id="0025" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果请求超时，或者数据包丢失，或者它收到网络或接收器无法处理这么多数据的其他信号，它将减少数据量，并可能稍后再次尝试增加数据量。关于这一点的更多信息，请参见本文。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="bde5" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">HTTPS</h1><p id="2608" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">HTTPS是HTTP的扩展。它本质上是安全的HTTP(纯文本)。</p><p id="1bac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除此之外，它还通过加密数据来提供安全的网络通信。为了实现这一点，它依赖于它下面(和TCP上面)的另一个协议，称为TLS。</p><p id="1b86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLS过去被称为SSL，所以你会看到两个名字都被使用。</p><p id="82bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图将帮助您更好地理解哪些协议依赖于哪些协议(底部的<em class="lz">物理层</em>和<em class="lz">数据链路层</em>不在本文讨论范围之内)。</p><p id="00f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然从理论上讲，HTTPS不是必需的，但现在它几乎是必须的，浏览器供应商在每个版本中都采取措施鼓励它的使用。</p><p id="0abd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本帖中的视频很好地解释了为什么需要HTTPS。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8b078c9796bf48dafa53c9de03dfe7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*1jjM73Yn8Sfjzr-7_M1x8w.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">TCP / IP堆栈(<a class="ae ly" href="https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="74f1" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">浏览器网络请求的步骤</h1><p id="a6d7" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">了解了基础知识之后，让我们看看当我们通过AJAX调用或简单地单击一个链接从浏览器进行HTTP/HTTPS调用时，实际上会发生什么。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="ca71" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">DNS查找</h1><p id="0b7b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">假设我们打电话到medium.com，浏览器首先需要将域名<em class="lz">medium.com</em>转换成IP地址。</p><p id="b553" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程被称为<em class="lz"> DNS查找，</em>，在最坏的情况下，浏览器将不得不接触服务器来获取IP。</p><p id="ae64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对每个请求都这样做会使事情变得非常慢，但由于这些IP不会经常改变，它们被缓存在不同的级别:浏览器本身、操作系统、家中的路由器等。因此，并非每次都执行完整的网络往返。</p><p id="f069" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器做了更多的事情来避免让用户等待DNS查找来解析，例如，可能会在下载后预先解析页面中的所有链接，这样，当用户单击链接时，IP地址就已经知道了。</p><p id="e37d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的两个截图显示了两次完全相同的请求的时间，一个接一个。</p><p id="836f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次DNS查找花费了203毫秒，第二次由于缓存而花费了0毫秒。请记住，每个域都会发生这种情况。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/8cb90990f3acaba4795e1ea1bf62eca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlngkaepWLjRXaQl7XX9_w.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Chrome请求计时标签显示对未缓存域名的请求。</p></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/1668ef9440bd7441d9bccffd855a0ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSIX6yTOovNjw9jJIbqUDg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">相同的请求不需要第二次DNS查找，因为它被缓存了。</p></figure><p id="dcab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么你看的每一本关于浏览器网络优化的书和文章都建议你减少这些查找。有大量的资源讨论如何避免DNS查找，我在这里不做介绍，但是其中一些非常明显:</p><ul class=""><li id="c707" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">向尽可能少的域名发出请求。</li><li id="372f" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">通过后台调用进行DNS预取(尽管如果管理不当可能会导致大量无用的调用，而浏览器可能已经为您做了)。</li><li id="d41f" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">使用带有IP地址的URL，而不是域名。没有域名，没有DNS查找，但你需要一个静态IP。此外，如果您使用CDNs，这实际上是不可行的，并且您会丢失这些请求的cookie，因为cookie是按域名存储的。</li></ul></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="570a" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">TCP三次握手</h1><p id="9af3" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">既然有了IP地址，浏览器将通过一个称为TCP三次握手的过程与主机建立TCP连接。</p><p id="2267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这发生在任何实际数据交换之前，它由客户端发送的SYN数据包、服务器的SYN-ACK响应和客户端发送的ACK数据包组成。</p><p id="ff63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有在ACK数据包之后，客户端才能发送实际数据，这意味着，对于每个TCP连接，在浏览器能够通过网络实际发送任何数据之前，需要进行一次完整的网络往返。</p><p id="517b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TCP握手也是客户端和服务器通告它们各自的接收窗口(RWND)的时间，接收窗口基本上是它们在ACK包之间的线路上可以拥有的数据量。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="a3ba" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">TLS握手</h1><p id="cfb5" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">如前所述，这一步理论上是可选的，但在实践中，它实际上是必需的，而且您可能已经使用了。</p><p id="2c05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在客户端和主机之间建立安全隧道，必须在双方同意协议版本、选择密码套件和其他一些事情的情况下进行TLS握手。</p><p id="24d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图显示了TCP和TLS握手的往返过程。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/429d1f5bf9a7ea5e90e6fe608b7a5da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*7ATiMj0PwewzpZUysluevg.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">TLS握手(<a class="ae ly" href="https://hpbn.co/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以<a class="ae ly" href="https://hpbn.co/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank">阅读更多关于这个</a>的内容，但是要记住的是，这需要两次到服务器的往返，通过使用<a class="ae ly" href="https://hpbn.co/transport-layer-security-tls/#enable-tls-false-start" rel="noopener ugc nofollow" target="_blank"> TLS错误启动</a>和<a class="ae ly" href="https://hpbn.co/transport-layer-security-tls/#enable-tls-false-start" rel="noopener ugc nofollow" target="_blank"> TLS会话恢复</a>将之前建立的连接减少到一次。</p><p id="7dcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，在交换任何数据之前，每个TCP连接至少需要两次网络往返。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="c383" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">HTTP请求</h1><p id="e4e0" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">浏览器然后构造HTTP请求，该请求需要通过TCP连接发送到服务器。</p><p id="764e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这包括一个消息行(如<code class="fe ns nt nu nv b">GET /images/logo.png HTTP/1.1</code>)、标题列表(如<code class="fe ns nt nu nv b">Accept-Language: en</code>)和一个可选的消息体，即实际数据。</p><p id="dac6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我假设您已经熟悉HTTP，但是请记住，数据将通过TCP以各种大小的块发送，这一点很重要，如上面的TCP/IP部分所述。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="73d1" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">来自服务器的HTTP响应</h1><p id="7646" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">服务器监听相关端口(HTTP的80和HTTPS的443)，接收请求，并根据web服务器配置适当地转发请求(例如<a class="ae ly" href="https://httpd.apache.org/docs/current/vhosts/" rel="noopener ugc nofollow" target="_blank"> Apache虚拟主机</a>)。</p><p id="3130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以是磁盘上的静态文件，比如<code class="fe ns nt nu nv b">/images/logo.png</code>或<code class="fe ns nt nu nv b">/index.html</code>，在这种情况下，资源将作为响应被发送回来。</p><p id="a14b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以是类似于<code class="fe ns nt nu nv b">/users/123/status</code>的东西，一个web框架，比如<a class="ae ly" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>或者<a class="ae ly" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>，配置成分别用一个Java或者<a class="ae ly" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>类来处理。</p><p id="aedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，该类将计算一个响应，该响应将被发送回客户端。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="267c" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">浏览器处理HTTP响应</h1><p id="a0f7" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">根据内容类型和各种其他HTTP头，浏览器将决定如何处理响应。</p><p id="811d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果它是一个HTML页面，它将在屏幕上呈现它，并在找到对HTML本身中的其他资源(JS脚本、CSS文件等)的引用时发出其他请求。).</p><p id="f7f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果是PDF文件，它可能会在不同的标签中打开它，或者提示用户将内容存储为PDF文件。</p><p id="7d3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以从浏览器的开发人员工具的网络计时部分检查上述每个步骤的计时。</p><p id="6040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是Chrome定时标签的截图。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nw"><img src="../Images/74717e131e7cb92da25437915d001fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TZ_NFszQmbmSUBF9JfItw.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Chrome请求计时标签(关于Chrome中计时视图的更多信息<a class="ae ly" href="https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="2192" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">多个请求</h1><p id="63d1" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我希望你已经做到了这一步，但是，记住这只是一个请求。</p><p id="e046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了缓存域的DNS查找和先前建立的连接的TLS握手中的第二次往返之外，所有其他事情都发生在每个TCP连接上。浏览器将如何处理这个问题？</p><p id="9346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这取决于使用的HTTP版本，或者更准确地说，是HTTP/1.1还是HTTP/2(也称为h2)，这几乎是唯一的真正选择。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="ebb1" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">HTTP/1.1</h1><p id="5eb5" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">一种极端的做法是为每个请求打开一个TCP连接。现在应该很清楚，这不是一个好主意。</p><p id="93a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于两个请求，它可能会给出好的结果，但是对于100个请求呢？TCP和TLS握手100次显然不是最优的，更不用说浏览器需要分配多少内存来管理这些请求了。所以这个选项是不可能的。</p><p id="e735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个极端是滥用<em class="lz">连接重用</em>，它将只建立一个TCP连接(每个主机)并为每个HTTP请求重用它以避免多次握手。</p><p id="fba9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过“connection <code class="fe ns nt nu nv b">keep-alive</code> header”实现，这是HTTP/1.1中的默认设置，它将指示浏览器暂时保持底层TCP连接打开，以便它可以在将来的HTTP请求中重用。</p><p id="7671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有一个问题:请求需要在客户机上以先进先出的顺序进行处理，这意味着首先需要调度第一个到达的请求，只有在前一个请求的完整响应被完全接收后，才能调度队列中的下一个请求。</p><p id="3b90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于浏览器中(几乎)同时触发的多个请求(A，B，…，Z)，这意味着浏览器发送请求A，并将其余的请求排队。</p><p id="b7db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过了一会儿，A的响应来了，请求B可以发送了。当对B的响应到来时，它发送下一个，以此类推。</p><p id="e1f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有点长，但请耐心等待。我保证这是值得的。</p><p id="bb9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不难意识到，这也不会给多个请求带来好的结果，但是HTTP/1.1还有另一个特性，叫做<a class="ae ly" href="https://en.wikipedia.org/wiki/HTTP_pipelining" rel="noopener ugc nofollow" target="_blank"> HTTP管道</a>。</p><p id="3d52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它允许客户端一个接一个地发送多个请求，而不必在发送下一个请求之前等待完整的响应。</p><p id="d785" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务器甚至可以在多个线程上并行处理这些请求，但是必须按照请求传入的顺序发送回响应。</p><p id="9f50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这基本上意味着，如果有十个请求进来，第十个请求先被处理，浏览器就不能把它发送回去。它必须等待前九个请求完成处理，发送它们的响应，然后才发送第十个请求。</p><p id="f938" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种场景被称为<a class="ae ly" href="https://en.wikipedia.org/wiki/HTTP_pipelining" rel="noopener ugc nofollow" target="_blank">队列头阻塞</a>，很难得到正确的结果(如果第一个请求挂起了怎么办？)，更不用说内存成本了。</p><p id="b592" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个原因以及其他问题，HTTP管道不是真正可行的，除非，也许，您在浏览器之外，并且您可以完全控制实际的套接字。</p><p id="2f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以回到浏览器如何处理多个HTTP/1.1请求，浏览器供应商最终(大部分)完全避免了HTTP管道，并在同一TCP连接上的客户端排队HTTP请求和并行的多个连接之间找到了一个中间点。</p><p id="efed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着浏览器通常会为每台主机打开固定数量的并行TCP连接。当然，这个数字会因浏览器而异，但我相信现在6是很常见的。</p><p id="fe46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您有七个请求，它将为前六个请求打开六个并行TCP连接，并将第七个请求排队，当它获得其中一个请求的第一个响应时，它将为第七个请求重用该TCP连接。</p><p id="0d91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，它可能会选择让它们打开一段时间，以防更多的HTTP调用进入，并最终关闭它们以释放内存。</p><p id="c3b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你和我一样，你会想亲眼看看这些。</p><p id="33a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是同时触发的七个请求(实际上是七次相同的请求)的Chrome开发者工具网络标签的截图。</p><p id="28ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Connection ID列显示了六个不同的ID，六个TCP并行连接各有一个。</p><p id="4d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在瀑布列中，您将看到列表中的最后一个请求是如何首先获得响应的，而在它之前一直停滞不前的那个请求(灰色)会立即重用被释放的TCP连接，它们共享相同的连接ID。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nx"><img src="../Images/9df31c65d55599d18b57051392e1fa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aemWW3NGBuvb2GyWHpwq7w.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Chrome中7个HTTP/1.1请求的定时截图</p></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="d8cf" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">HTTP/2(或h2)</h1><p id="e009" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">如果您完整地阅读了前一部分，您的耐心已经得到了回报，因为现在很容易理解HTTP/2的一个关键特性。</p><p id="6725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端可以发送多个HTTP请求，就像在HTTP/1.1中一样，但是服务器需要按照获得请求的顺序发送响应的约束已经没有了。</p><p id="4d23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，客户机可以间隔1毫秒发送100个请求，服务器可以按照它选择的任何顺序立即响应先处理的请求，HTTP/2会将每个响应映射到原始请求。</p><p id="6fde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个特性叫做<em class="lz">多路复用</em>，你可能已经听说过了。</p><p id="1fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，如果浏览器检测到支持HTTP/2，它们如何处理多个HTTP请求呢？你猜对了，一般来说，他们只在每个主机上打开一个TCP连接，所有的数据都通过这个连接流动(当然，当他们打开更多的时候，可能会有边缘情况)。</p><p id="4883" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是七个请求的时间截图，但是这次是通过HTTP/2。</p><p id="c7ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，它们的连接ID都是相同的，这表明使用了相同的底层TCP连接。另外，请注意瀑布，没有停顿，所有的请求都是一个接一个地立即发送的。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nx"><img src="../Images/7c18be6e6a9cbca30922f4d4a6ff940b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwA5XiyrTxDWwi-UjbYA_g.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Chrome中七个HTTP/2请求的定时截图</p></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="e561" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="70a4" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">那么，您实际上可以做些什么来最小化web应用程序中的延迟呢？</p><p id="3109" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会在网上找到很多清单，但这显然要视情况而定。一个主要的决定因素是你是否已经在使用HTTP/2。</p><p id="78ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看您会在这样的清单上找到的常见项目:</p><ol class=""><li id="c8b5" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ny nj nk nl bi translated">连接重用。</li><li id="fbd5" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">Sprite图像并捆绑JS和CSS资源，以便您发出更少的HTTP请求(以增加它们通过并行TCP连接被接收的可能性)。</li><li id="9b42" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">域分片——如果您仍然无法将请求保持在最低限度，请为您的资源使用多个域(以增加通过并行TCP连接接收请求的可能性)。</li><li id="955a" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">考虑HTTP管道。</li><li id="8d20" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">资源内联。</li><li id="d056" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated"><a class="ae ly" href="https://www.npmjs.com/package/vulcanize" rel="noopener ugc nofollow" target="_blank">硫化</a>。</li><li id="a0a8" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">减少DNS查找。</li><li id="2313" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">缓存。</li><li id="66d5" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">Gzip所有资产。</li><li id="2fac" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">使用一个<a class="ae ly" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank">内容传送网络</a>。</li><li id="2e57" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">不要使用重定向。</li><li id="1444" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ny nj nk nl bi translated">增加TCP的初始拥塞窗口。</li></ol><p id="378a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你现在以一种全新的视角来看待这个列表，并且理解每一项背后的原因。</p><p id="43bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的一点是，在HTTP/1.1中，第1项到第6项基本上是绕过行首阻塞的方法，而在HTTP/2中它们变得完全没有必要。</p><p id="b552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">剩下的都是“常青树”，在HTTP/2时代依然适用。</p><p id="648b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第7点现在应该很明显了，你可以回顾一下上面关于DNS查找的部分。</p><p id="d519" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数字8，9，10不需要太多解释。</p><p id="2fd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第11，我们在这里并没有真正讨论这个问题，但是应该避免重定向，因为它们需要一次额外的网络往返。</p><p id="0427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第12个问题已经在TCP / IP部分讨论过了，请随时复习。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="1925" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">参考</h1><ul class=""><li id="e45f" class="nd ne it js b jt lt jx lu kb nz kf oa kj ob kn ni nj nk nl bi translated">伊利亚·格里戈利克所著的《高性能浏览器网络<a class="ae ly" href="https://hpbn.co/" rel="noopener ugc nofollow" target="_blank"><em class="lz">一书(方便的话<a class="ae ly" href="https://hpbn.co/" rel="noopener ugc nofollow" target="_blank">可以在网上免费获得</a>)。</em></a></li><li id="7372" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae ly" href="https://www.youtube.com/watch?v=r5oT_2ndjms&amp;t=2s" rel="noopener ugc nofollow" target="_blank">这段YouTube视频</a></li></ul></div></div>    
</body>
</html>