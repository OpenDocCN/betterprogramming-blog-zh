<html>
<head>
<title>What’s New in TypeScript 3.9?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.9有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-3-9-70e3d2eabe26?source=collection_archive---------5-----------------------#2020-05-26">https://betterprogramming.pub/whats-new-in-typescript-3-9-70e3d2eabe26?source=collection_archive---------5-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cfd0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">刚刚上线的所有内容的概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e80e2c9b95b4a88196f0724a3164709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b69tQHlar0EXAv39HKsgTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@corinnekutz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Corinne Kutz </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="144b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript刚刚在5月12日发布了今年的第二个版本。是3.9版本，现在是稳定版。在本文中，我将指出TypeScript 3.9的一些令人兴奋的新特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eff6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe mu mv mw mx b">@ts-expect-error</code></h1><p id="2972" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们举一个例子，我们定义了一个函数，它将两个字符串作为参数。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="1474" class="nh md it mx b gy ni nj l nk nl">printName(firstName: string, lastName: string) { <br/>    console.log(firstName);<br/><strong class="mx iu">    </strong>console.log(lastName);<br/>    assert(typeof firstName === "string");   <br/>    assert(typeof lastName === "string");<br/>}</span></pre><p id="cf33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当TypeScript用户误用这个函数时，会得到一个有用的红色波浪线和一个错误消息，JavaScript用户会得到一个断言错误。但是如果我们编写一个单元测试来检查这个功能，会发生什么呢？</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="1568" class="nh md it mx b gy ni nj l nk nl">expect(() =&gt; { <br/>   printName(1234, 5678); <br/>}).toThrow();</span></pre><p id="c988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的测试是用TS编写的，它会抛出如下错误:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9a06" class="nh md it mx b gy ni nj l nk nl">printName(1234, 5678);<br/>// ~~~ <br/>// error: Type ‘number’ is not assignable to type ‘string’.</span></pre><p id="87a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对此的解决方案，TypeScript版本带来了一个新特性:<code class="fe mu mv mw mx b">// @ts-expect-error</code>注释。如果我们将此注释作为前缀放在代码行之前，TypeScript不会报告错误。但是如果没有错误，TypeScript会通知我们的代码中有一个不必要的注释，就像这样:<code class="fe mu mv mw mx b">Unused '@ts-expect-error' directive</code>。</p><p id="0202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mu mv mw mx b">//@ts-expect-error</code>注释的另一个用途是我们可以将它用作抑制注释。<code class="fe mu mv mw mx b">// @ts-ignore</code>是一个现有的注释，用作抑制注释——这两个注释的主要区别是<code class="fe mu mv mw mx b">// @ts-ignore</code>将通知下面的行是否没有错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed72" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">速度改进</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/7ed9eac63732e4cb905d346d056c4140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6LoGdsn6xLXdu2Rl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="ff44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于早期版本的TypeScript，有很多关于Material-UI等包的编译和编辑速度的抱怨。</p><p id="6b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在新版本中，TypeScript开发团队通过优化几个涉及大型联合、交集、条件类型和映射类型的病态案例解决了这个问题，并将Material-UI编译的时间减少了40%。此外，他们还致力于像Visual Studio代码这样的编辑器的文件重命名功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dde2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JavaScript中的CommonJS自动导入</h1><p id="d3ab" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以前，无论文件类型如何，TypeScript总是期望ECMAScript样式的导入。但是大多数开发人员在编写JavaScript文件时使用CommonJS风格的<code class="fe mu mv mw mx b">require();</code> <em class="nn"> </em>导入，而不是ECMAScript风格的模块。</p><p id="9dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript样式:<code class="fe mu mv mw mx b"><strong class="lb iu">import</strong> * <strong class="lb iu">as</strong> fs <strong class="lb iu">from</strong> "fs";</code></p><p id="1231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常见风格:<code class="fe mu mv mw mx b"><strong class="lb iu">const</strong> fs = require("fs");</code></p><p id="3b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最新版本中，TypeScript现在会自动检测您正在使用的导入类型，以保持文件的样式整洁。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b53e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">推理和<code class="fe mu mv mw mx b">Promise.all</code>的改进</h1><p id="7f26" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在3.7版本中，TypeScript对像<code class="fe mu mv mw mx b">Promise.all</code>和<code class="fe mu mv mw mx b">Promise.race</code>这样的函数声明进行了更新。但是这个更新有一些复杂之处，因为它在用<code class="fe mu mv mw mx b">null</code>或<code class="fe mu mv mw mx b">undefined</code>混合值时导致了回归。下面给出一个例子。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="7cf9" class="nh md it mx b gy ni nj l nk nl">interface Bird{ <br/>   fly(): void <br/>} <br/>interface Fish{ <br/>   singKissFromARose(): void <br/>} </span><span id="bb39" class="nh md it mx b gy no nj l nk nl">async function animalBehaviours(birdBehaviour: Promise&lt;Bird&gt;,     fishBehaviour: Promise&lt;Fish| undefined&gt;) { <br/>   let [bird, fish] = await Promise.all([birdBehaviour,    fishBehaviour]); <br/>   bird.fly();<br/>   // ~~~~ <br/>   // Object is possibly ‘undefined’. <br/>}</span></pre><p id="2bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe mu mv mw mx b">fishBehaviour</code> <strong class="lb iu"> <em class="nn"> </em> </strong>是包含<code class="fe mu mv mw mx b">undefined</code>的一个，但不知何故影响了<code class="fe mu mv mw mx b">birdBehaviour</code> <em class="nn"> </em>也包含<code class="fe mu mv mw mx b">undefined</code>。因此，这个问题在3.9版的TypeScript中也得到解决。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="998e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码操作保留新行</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/3ce39e07f66382104693175bc4b112de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eAJT01XxXK0PLh0w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员喜欢在独立的功能代码行之间保留新行，但早期的TypeScript代码重构并不保留新行。它几乎删除了代码行之间的所有空白行。在最新的版本中，TypeScript已经解决了这个问题，现在TypeScript代码重构在运行重构后保留了代码中的新行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="32b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缺失返回表达式的快速修复</h1><p id="c410" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时我们可能会忘记在函数结束时返回函数的值。因此TypeScript现在提供了一个快速解决方案来添加缺失的<code class="fe mu mv mw mx b">return</code>语句。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1110" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">条件表达式中未调用的函数检查</h1><p id="f1f5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在3.7版本之后，TypeScript在<code class="fe mu mv mw mx b">if</code>条件中检查未调用的函数检查并报告错误。在3.9版本中，这种错误检查还进一步扩展到了三元条件语句。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bbe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">额外的小改动</h1><p id="f095" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">除了这些变化，还有一些小的变化，如:</p><ul class=""><li id="41ba" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe mu mv mw mx b">}</code>和<code class="fe mu mv mw mx b">&gt;</code>现在是无效的JSX文本字符</li><li id="bd40" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe mu mv mw mx b">export *</code>被保留下来</li><li id="8ca0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">Getters和setters不再是可枚举的</li><li id="f9d7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">扩展<code class="fe mu mv mw mx b">any</code> <strong class="lb iu"> <em class="nn"> </em> </strong>的类型参数不再充当<code class="fe mu mv mw mx b">any</code></li><li id="036c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">更多<code class="fe mu mv mw mx b">libdom.d.ts</code>改进</li></ul><p id="ae15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，这些是我们在最新发布的TypeScript中可以看到的变化。因此，如果你是一个打字爱好者，保持与新的<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-9" rel="noopener ugc nofollow" target="_blank">更新</a>同步总是好的，这可以使你的编码生活更容易。</p></div></div>    
</body>
</html>