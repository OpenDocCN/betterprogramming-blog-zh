<html>
<head>
<title>What’s New in Swift 5.1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.1的新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swift-5-1-4c6aefb24006?source=collection_archive---------2-----------------------#2019-09-25">https://betterprogramming.pub/whats-new-in-swift-5-1-4c6aefb24006?source=collection_archive---------2-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有了Xcode 11，苹果让Swift疲于奔命。让我们看看新的关键特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/828c98ca3e64ff82866a68d4cd2a7e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TBfaJKuXfZsjmnXp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pemmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Przemyslaw Marczynski </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9月20日，苹果发布了全新的Xcode 11，主要支持新的iOS 13。与往常一样，新的iPhones已经推出，苹果发布了其IDE的新版本，包含对其开发语言Swift 5.1新版本的支持。</p><p id="9399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使不是主要版本，Swift 5.1也集成了新的语言功能和改进的模块稳定性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9bbc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">新的“自我”(是的，大写的“S”)</h1><p id="ab22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用面向对象技术的静态方法时，在Swift中引用类名是很常见的。在Swift的早期版本中，可以通过显式引用或在使用对象实例时使用<code class="fe mz na nb nc b">self.dynamicType</code>来引用类名。</p><p id="382c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在子类化过程中，<code class="fe mz na nb nc b">self.dynamicType</code>变得更有意思来引用在<em class="nd">的那段</em>代码中想要的类型。新的<code class="fe mz na nb nc b">Self</code>基本上是旧的<code class="fe mz na nb nc b">self.dynamicType</code>的替代品，旧的<code class="fe mz na nb nc b">self.dynamicType</code>仍然受支持并且运行良好。</p><p id="bff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么现在你可以简单地使用<code class="fe mz na nb nc b">Self</code>关键字来引用类名:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="aa90" class="ni md it nc b gy nj nk l nl nm">class MediumAuthor {<br/> static func sayHello() {<br/>    print(“Hello guys!”)<br/> }</span><span id="5d91" class="ni md it nc b gy nn nk l nl nm"> func newMethod() {<br/>  <strong class="nc iu">Self</strong>.sayHello()<br/>  <em class="nd">// equals to MediumAuthor.sayHello()</em><br/> }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="305c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成员式初始值设定项中的合成默认值</h1><p id="d874" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这将非常感谢。当您在Swift 5中使用structs并且需要为未赋值的属性设置默认值时，您需要为其定义一个自定义的init方法，该方法根据参数值在属性上设置这些值。</p><p id="8929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 5.1中，这种实现是自动的，老派开发人员会说属性会自动合成它们的默认值。因此，不用init方法实现，您只需给它们分配一个自定义值，如下所示:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="26cc" class="ni md it nc b gy nj nk l nl nm">struct MediumAuthor {<br/>  let name : String<br/>  var articles = 0<br/>}</span><span id="1816" class="ni md it nc b gy nn nk l nl nm">let theAuthor = Author(name: "Ivano Di <em class="nd">Gese")</em></span><span id="7195" class="ni md it nc b gy nn nk l nl nm"><em class="nd">// there's no need of implementing init() setting the articles default value</em></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b182" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不透明的返回类型</h1><p id="8b4f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个特性将允许开发人员更好地理解继承和子类化，用一个简化的机制来处理类型。</p><p id="1d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift开发人员经常使用泛型来支持动态类型，这可能很乏味，因为它迫使您使用反射来理解托管对象的类型，并在编码时导致开销。</p><p id="a0af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 5.1中，我们最好使用不透明的返回类型，它告诉编译器一个方法将返回一个泛型类的可能实现之一。</p><p id="07f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比使用泛型好得多，因为Swift compile“将知道”并理解该方法将返回哪种对象，这取决于它在该点的具体实现。</p><p id="8d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么现在可以使用下面的语法:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="61b6" class="ni md it nc b gy nj nk l nl nm">func getAnimal() -&gt; some Animal {</span><span id="e294" class="ni md it nc b gy nn nk l nl nm">   return Dog() // or Cat(), or Elephant() or whatever</span><span id="9e73" class="ni md it nc b gy nn nk l nl nm">}</span></pre><p id="fa23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们不能只使用<code class="fe mz na nb nc b">-&gt; Animal</code>符号。这取决于您如何使用<code class="fe mz na nb nc b">Self</code>并在类中实现方法，因为在某些情况下它可能会产生编译错误。</p><p id="01c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在比较对象时，如果您使用<code class="fe mz na nb nc b">some</code>关键字，Swift将正确处理该类型，而不是抛出一个错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1166" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态访问的静态和类下标</h1><p id="5416" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于Swift开发人员广泛使用订阅，Apple已经改进了其实现，简化了访问类成员、枚举属性等的语法。</p><p id="2198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 5中，您可以创建<code class="fe mz na nb nc b">get()</code>和<code class="fe mz na nb nc b">set()</code>方法来访问对象属性列表中的特定值，并且您可以使用静态属性来使方法与类相关，而不是与实例相关。</p><p id="c330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 5.1中，您可以更好地创建一个<code class="fe mz na nb nc b">subscript()</code>方法来下标一个对象并返回所需的值:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="9e56" class="ni md it nc b gy nj nk l nl nm">public class MyJson {<br/> private static var json = [String: String]()<br/> <br/> <strong class="nc iu">public static subscript(keyName: String) -&gt; String? {<br/> <br/>   get {<br/>     return json[keyName]<br/>   }<br/>   set {<br/>     json[keyName] = newValue<br/>   }<br/> }</strong><br/>}</span><span id="b652" class="ni md it nc b gy nn nk l nl nm">MyJson[“author”] = “Ivano”<br/>print(MyJson[“author”] ?? “Unknown author”)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2036" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单表达式函数的隐式返回</h1><p id="2f13" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift 5中，只要闭包的使用除了返回值之外没有其他事情可做，仍然允许省略<code class="fe mz na nb nc b">return</code>关键字。</p><p id="7090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类似于JavaScript行为，当你使用箭头函数并省略return关键字时，通常指的是<code class="fe mz na nb nc b">map()</code>、<code class="fe mz na nb nc b">reduce()</code>和类似的实现。</p><p id="8c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么在Swift 5中，只需使用赋值右侧的<code class="fe mz na nb nc b">map()</code>或<code class="fe mz na nb nc b">reduce()</code>函数就可以轻松地给<code class="fe mz na nb nc b">let</code>变量赋值，而无需专门使用<code class="fe mz na nb nc b">return</code>关键字。</p><p id="fdca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 5.1中，这一点得到了改进，现在您可以这样做，甚至在自定义函数和方法中。</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="f45c" class="ni md it nc b gy nj nk l nl nm">func multiply() -&gt; Int {<br/> reduce(0) { $1.isMultiple(of: 2) ? $0 + $1 : $0 }<br/>}</span><span id="a43d" class="ni md it nc b gy nn nk l nl nm">func decrement(myNumber : Int) -&gt; Int {<br/> myNumber - 1 <em class="nd">// no need of "return"!</em><br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d7c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有序集合差分</h1><p id="c412" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最终有可能用简化的方法得到有序集合之间的区别。</p><p id="17d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员经常使用集合和数组，因为它们像<code class="fe mz na nb nc b">UITableViews</code>和<code class="fe mz na nb nc b">UICollectionViews</code>对象的数据源一样频繁使用，这就是为什么这是一个真正受欢迎的新特性。</p><p id="c876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的<code class="fe mz na nb nc b">difference(from:)</code>方法计算可以引用到两个目标集合的差异，甚至让您能够在其上循环并评估它们。</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="7b4f" class="ni md it nc b gy nj nk l nl nm">let myFirst = [10, 20, 30]<br/>let mySecond = [10, 40, 50]</span><span id="df45" class="ni md it nc b gy nn nk l nl nm">let differences = mySecond.difference(from: myFirst)</span><span id="b0e6" class="ni md it nc b gy nn nk l nl nm"><em class="nd">// differences will contain references to evaluate removing and inserting actions to have arrays containing same values</em></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a3fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论和其他改进</h1><p id="d8be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Swift 5.1扩展了Swift 5的稳定性，提高了模块的编译时间。</p><p id="e66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模块稳定性还使用基于文本的模块接口文件，该文件描述了二进制框架的API，允许使用不同版本的编译器用代码编译它。</p><p id="c5e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/apple/swift-syntax" rel="noopener ugc nofollow" target="_blank"> SwiftSyntax </a>也已更新，在访问语法树和使用内部数据时会更快。</p><p id="fda8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇简短的文章中，我介绍了Swift更新，但没有介绍Xcode 11更新，Xcode 11更新嵌入在同一个macOS更新中。</p><p id="7bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode 11有几个改进，包括SwiftUI支持和一些新的外观和感觉功能。更新Xcode和进入新的Swift语言更新肯定会提高你的专业iOS开发者技能。</p></div></div>    
</body>
</html>