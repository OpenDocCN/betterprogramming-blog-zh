# 在 C++中使用单例的 3 个技巧

> 原文：<https://betterprogramming.pub/3-tips-for-using-singletons-in-c-c6822dc42649>

## 封装逻辑、延迟和动态初始化以及有序动态初始化

![](img/277229008b6ac6260923a1b6cdc1ffa5.png)

费德里科·贝卡里在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

几乎在任何编程语言中，单件都有广泛的用途。在 C++中，单例允许封装程序中全局存在的逻辑。单例的唯一实例可以在任何地方访问，而不是在函数调用中传递堆分配的对象。然而，当使用单例时，小心初始化顺序问题是很重要的。根据期望的行为，单例也可以在运行时的不同点构造。本文将详细介绍这些技巧以及如何最好地使用单件。

# 什么是独生子女？

首先，让我们定义一下什么是单例。单例对象是一个程序中只有一个实例的对象。通常，它不能被析构，并且一旦被构造，就一直存在到程序结束。

C++语言不直接支持单例，但必须使用初始化行为的基本保证来实现。

让我们取一个简单的结构，`foobar`，把它做成一个 singleton。然后，该示例将演示:

这里，`foobar`是一个成员为`value`的单例结构。`foobar`的`instance()`方法返回结构的单个实例。`instance()`方法中的`static foobar base;`使用延迟初始化。

从 C++11 开始，标准保证函数中的`static`对象只在第一次调用函数时被初始化，而不是像大多数其他静态存储对象那样在`main()`被调用之前。

不仅如此，还保证了初始化只发生一次。但是为了仔细检查这个声明，让我们来测试一下。取两个线程，让它们多次检索单例实例，并确认构造函数只为一个线程运行一次。

运行该测试时，应该会显示如下内容:

```
Main Thread:  0x105bf3dc0Constructed by: 0x700007865000
```

其中主线程 id 不同于构造单例的线程。这表明单例构造实际上被推迟到子线程第一次调用`instance()`的时候。

# 封装逻辑

单例允许对全局访问模式进行分组和封装，没有它们是很难做到的。

全局访问模式的一个例子是共享队列，其中程序的多个部分可以将一个对象(如作业)入队或出队。理想情况下，这样的队列应该是线程安全的，并使用互斥体。使用前面解释的单例模式，下面是作业队列的样子

首先，这个单例使用 r 值引用，而不是 l 值引用。作业被移动到队列中，而不是复制到队列中。

移动的行为不仅有助于避免不必要的复制，它还形成了这样一种观点，即一个作业应该只在队列中或不在队列中，决不能同时处于两种状态。

无论何时何地调用`JobQueue::instance()->enqueue(Job&&)`，作业队列的全局大小都会增加。对`JobQueue::instance()->dequeue()`的任何后续调用总是反映入队调用的最后状态。队列的初始化及其线程安全完全封装在单例中。

# 延迟和动态初始化

就`static`数据变量和成员而言，有两种主要的初始化类型。延迟初始化就是我们前面描述的，给定的变量将在第一次被访问时被初始化。

动态初始化非常不同，因为它是无序的。这意味着变量初始化的时间点是不确定的。我们所能知道的是，在调用`main()`之前，它将被初始化。

一种认为动态初始化的布尔值是不确定的，它不知道是否已经被初始化为`false`，或者还没有被初始化。下面是 [C++参考文献](https://en.cppreference.com/w/cpp/language/initialization)提到的内容:

> *无序动态初始化*，仅适用于【静态/线程本地】类模板[静态数据成员](https://en.cppreference.com/w/cpp/language/static)和[变量模板](https://en.cppreference.com/w/cpp/language/variable_template)(从 C++14 开始)非[显式专门化](https://en.cppreference.com/w/cpp/language/template_specialization)。这种静态变量的初始化相对于所有其他动态初始化是不确定排序的，除非程序在变量初始化之前启动了一个线程，在这种情况下，它的初始化是不排序的(从 C++17 开始)。这种线程局部变量的初始化相对于所有其他动态初始化是无序的

动态初始化的最大问题是缺乏顺序会带来使用未初始化变量的风险。当一个动态初始化的`static`变量依赖于另一个动态初始化的`static`变量时，就会发生这种情况。

因为两者都将在`main()`之前的某个时间点被构建，所以不能保证程序员想要构建它们的顺序就是实际使用的顺序。这是一个存在风险的设计模式的例子:

在上面的例子中，每个`Member`实例依赖于被构造和初始化的`regr_manager`的可用性。由于不能保证这种顺序，这种设计可能会遇到静态初始化排序错误。

因此，这里的解决方案是将`Registrar`的使用转换为延迟初始化的单例。这将确保对于任何`Member`，总是有可用的`Registrar`实例。

# 有序动态初始化

动态初始化的定义有一个重要的例外。你可能已经注意到用`Registrar`和`Member`对象编译和运行程序不会遇到问题。

在编译过程中，当`static`数据成员之间的关系包含在单个翻译单元中时，就会发生这种异常。如果该条件为真，那么动态初始化就会发生，但只是按照这些变量在语法上出现的顺序。[具体来说](https://en.cppreference.com/w/cpp/language/initialization):

> *有序动态初始化*，适用于所有其他非局部变量:在单个翻译单元内，这些变量的初始化总是按照它们在源代码中出现的定义的确切顺序[排序](https://en.cppreference.com/w/cpp/language/eval_order)。不同翻译单元中静态变量的初始化是不确定顺序的。不同翻译单元中的线程局部变量的初始化是无序的。

尽管以上是真的，但这是一个非常不可靠且容易出错的设计选择。这是因为 C++程序的构建步骤在语言本身之外。查看像`#include`这样的预处理语句并不能表明一个变量是否在一个独立的翻译单元中。

一些构建工具，如 unity builds，在编译前将许多`.cpp`文件粘贴到一个文件中。无论如何，重点是不应该在一个项目中创建对一个从语言本身看不到的文件的特定构建安排的依赖。

# 静态排序初始化失败

使用非局部静态初始化的一个潜在问题是，这些变量的初始化顺序是不确定的。如果两个或更多的非局部静态相互引用，它们可能不会按照程序希望的顺序初始化。当使用带有静态构造函数的对象时，这种混乱尤其真实。

考虑这样一种情况，一个对象依赖于其构造函数中另一个对象的静态实例，在这种情况下，您首先有一个类似容器的基类。

```
struct Base {
  Link* list; void addLink(Link* ptr) {
    ptr->next = list;
    list = ptr;
  }
};static Base the_base;
```

和一个节点类型类，它在构造时将自己添加到基列表中。

```
struct Link { Link(int num) {
    val = num;
    the_base.addLink(this);
  } int val;
  Link* next;
};static Link a(3);
```

不能保证在第一个`Link`对象初始化之前`the_base`已经初始化。

## 毁灭的命令

类似于初始化没有定义的顺序，静态对象的销毁也没有定义的顺序。也是静态分配的非局部静态对象有退出处理程序，在退出时调用。对于像`std::unique_ptr`或`std::shared_ptr`这样的普通类型来说，这可能是真的。在非局部作用域中有一个`static std::shared_ptr<type>`会导致这样一种情况，即该对象在使用完之前就可能被析构。

## 延迟初始化的动态分配

静态对象的初始化排序和销毁这两个问题的解决方案是将动态分配与延迟初始化配对。这意味着，我们想要使用`new`来分配对象，但是在函数级范围内这样做，这样它将在第一次调用函数时以线程安全的方式被初始化。当这种情况发生时，静态对象将改为指向堆内存的指针，而不是静态分配的，因此不会经历任何自动销毁。