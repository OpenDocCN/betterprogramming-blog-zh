<html>
<head>
<title>My Problem With Lodash.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对Lodash.js的问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-problem-with-lodash-7e64df8173f9?source=collection_archive---------20-----------------------#2019-11-11">https://betterprogramming.pub/my-problem-with-lodash-7e64df8173f9?source=collection_archive---------20-----------------------#2019-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="732c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">反对过度使用某些函数的案例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36256fbd48ee4bbb339cb2317b59eff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vDyMv1L0ltyPsKPj.jpg"/></div></div></figure><p id="0681" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lodash被誉为JavaScript的基本库，这是有道理的。这是一个提供了大量函数的库，有些函数比其他函数更直观，这使得开发人员的工作更加容易。然而，过度依赖lodash会带来效率和代码可读性的损失。</p><p id="3911" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在进入细节之前，我需要坦白，我不是高级程序员，也不是有正规软件背景的工程师。我在软件工程和编码领域已经有一年的经验，也许我在这里说的超出了我的深度。或许lodash <em class="ln">就是</em>一个应该学习，应该经常使用的库。然而，对我来说，它伴随着巨大的可读性成本。</p><p id="c17f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一直有写作的诀窍，写过一个剧本、几个短篇故事和一个短剧，这就是为什么我非常重视代码质量和可读性。对我来说，写代码非常类似于写短篇小说，因为它需要以一种可读的、密集的语法/风格来写，以便更快地抓住要点。在编码的情况下，这个概念近似地转化为效率。</p><p id="7aba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">话虽如此，我认为用lodash来解决每个遇到的问题是不必要的。例如，spread操作符使得lodash的许多功能变得多余，并且可读性更好。</p><h1 id="15ac" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">分配</h1><p id="cdb5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我发现使用spread操作符的最好例子是lodash <code class="fe ml mm mn mo b">_.assign()</code>函数。本质上，该函数将一个对象的所有值分配给另一个对象:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="80e9" class="mt lp iq mo b gy mu mv l mw mx">let prop1 = { b: "Some property", d: null };<br/>let prop2 = { a: [2, 3], c: "An amazing String", d: 777 };<br/>let prop3 = { a: 888 };<br/>let prop4 = { a: 999 };</span><span id="8d34" class="mt lp iq mo b gy my mv l mw mx">const finalProp = _.assign(prop1, prop2, prop3, prop4); console.log(finalProp);<br/>// ==&gt; { a: 999, b: 'Some property', d: 777, c: 'An amazing String'}</span></pre><p id="0acf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这无疑是一个非常有用的功能。然而，它非常容易复制，并且在大多数情况下不需要我们导入<code class="fe ml mm mn mo b">lodash</code>:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e735" class="mt lp iq mo b gy mu mv l mw mx">const finalProp = { ...prop1, ...prop2, ...prop3, ...prop4 };<br/>console.log(finalProp);<br/>// ==&gt; { a: 999, b: 'Some property', d: 777, c: 'An amazing String' }</span></pre><p id="2f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一种方法可能看起来更好，尤其是如果您已经熟悉assign()函数的话。然而，就风格而言，有充分的理由选择第二种方法:</p><ol class=""><li id="ef7f" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ne nf ng nh bi translated">没有额外的函数，这使得文件更具可读性。只使用普通的JavaScript。</li><li id="64e0" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">它消除了<code class="fe ml mm mn mo b">assign</code>函数中发生的事情的模糊性，这可能会做一些程序员没有预料到的事情。</li><li id="3f02" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">您没有向文件中导入任何内容。</li></ol><p id="0d51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的效率也更高:在两个独立的文件中运行这两个函数，(n=10)对于自定义函数来说平均花费<code class="fe ml mm mn mo b">3.290ms</code>，而lodash方法平均花费<code class="fe ml mm mn mo b">4.218ms</code>。因此，自定义函数的效率比lodash函数高28%。</p><h1 id="4139" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">联盟</h1><p id="a3ac" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是我最不喜欢的功能。该函数的名字很恰当，来自集合论，尽管这也要求我们更加注意隐藏的复杂性:对两个数组应用union函数，不仅连接了两个数组，而且还删除了最终数组的副本:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="eb50" class="mt lp iq mo b gy mu mv l mw mx">const _ = require("lodash");<br/>const array1 = [1, 4, "hello", 2, 999];<br/>const array2 = [2, "there", 4.7, "hello"];</span><span id="2f2a" class="mt lp iq mo b gy my mv l mw mx">console.time();<br/>const finalArray = _.union(array1, array2);<br/>console.timeEnd();</span><span id="0ae5" class="mt lp iq mo b gy my mv l mw mx">// console.log(finalArray);<br/>// ==&gt; [ 1, 4, 'hello', 2, 999, 'there', 4.7 ]</span></pre><p id="88b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用相同的对象，我们可以简单地使用<code class="fe ml mm mn mo b">const finalArray = new Set([...array1, ...array2]);</code>来获得相同的结果，同样提高了效率(<code class="fe ml mm mn mo b">0.578ms</code>用于lodash，<code class="fe ml mm mn mo b">0.107ms</code>用于内部，效率提高了540%)。除此之外，当显式地写出来时，也更清楚到底发生了什么。</p><h1 id="ad40" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">克隆和克隆深度</h1><p id="5418" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是一个有趣的问题，因为这是一个我仍然在使用的函数。当第一次接触JavaScript/编程时，我们中的许多人可能会对如何不容易地创建新对象感到有点不安:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="97c5" class="mt lp iq mo b gy mu mv l mw mx">let pocket = ["phone", "wallet"];<br/>let anotherPocket = pocket;<br/>pocket.push("keys");<br/>console.log(pocket === anotherPocket);<br/>// ==&gt; true</span></pre><p id="2844" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不幸找到了解决方案，或者我们仓促地接受了教育(比如我)，那么我们可能已经学会了lodash解决方案，它复制了函数给出的任何对象:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="0685" class="mt lp iq mo b gy mu mv l mw mx">const _ = require("lodash");<br/>let suitcase = { clothes: true };<br/>let vacationItems = { tripleTap: true, bag: suitcase };<br/>const vacationItemsClone = _.clone(vacationItems);</span></pre><p id="8c41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这个解决方案确实可以生成给定对象的浅层副本，但是我平均花费了大约<code class="fe ml mm mn mo b">0.611ms</code>来克隆这个项目。在我看来，更好的解决方案是再次使用spread运算符:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="8142" class="mt lp iq mo b gy mu mv l mw mx">let suitcase = { clothes: true };<br/>let vacationItems = { tripleTap: true, bag: suitcase };<br/>const vacationItemsClone = { ...vacationItems };</span></pre><p id="e958" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">扩展操作符帮助我们实现了同样的结果，同时只取了<code class="fe ml mm mn mo b">0.105ms</code>。这比lodash函数快5.8倍(效率提高581%)。另一种类似的克隆方式给出了大致相同的时间范围。当然，给定的对象非常简单，并且可能存在我的解决方案不起作用的例子。否则，就不再需要lodash函数了。</p><p id="a659" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如何处理<code class="fe ml mm mn mo b">deepCloning</code>一个对象，使得内部对象引用也被克隆？对于这一点，<code class="fe ml mm mn mo b">lodash</code>做了一个非常干净，但是效率低下的工作:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="8498" class="mt lp iq mo b gy mu mv l mw mx">const _ = require("lodash");</span><span id="7bb9" class="mt lp iq mo b gy my mv l mw mx">let suitcase = { clothes: true };<br/>let vacationItems = { tripleTap: true, bag: suitcase }; console.time();</span><span id="5655" class="mt lp iq mo b gy my mv l mw mx">const vacationItemsDeepClone = _.cloneDeep(vacationItems);</span></pre><p id="83b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的mac上，这个函数平均需要<code class="fe ml mm mn mo b">0.985ms</code>，而我的自定义函数只需要<code class="fe ml mm mn mo b">0.197ms</code>(效率提高了500%):</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="8be8" class="mt lp iq mo b gy mu mv l mw mx">let suitcase = { clothes: true };<br/>let vacationItems = { tripleTap: true, bag: suitcase };<br/>console.time();<br/>const vacationItemsDeepClone = JSON.parse(<br/>    JSON.stringify(vacationItems)<br/>);<br/>console.timeEnd();</span></pre><p id="7d0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显然，这是一个比lodash中简单的<code class="fe ml mm mn mo b">cloneDeep()</code>看起来复杂得多的函数，这就是为什么我仍然使用lodash中的<code class="fe ml mm mn mo b">cloneDeep()</code>。我承认<code class="fe ml mm mn mo b">lodash</code>函数并不是特别高效，但是它让代码更具可读性，你也不用担心JSON类试图用stringy<em class="ln">和</em>解析一个非常大的对象。</p><h1 id="94df" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="44c4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Lodash是一个拥有许多资源的大型图书馆。我经常用lodash.js函数，比如<code class="fe ml mm mn mo b">difference()</code>或者<code class="fe ml mm mn mo b">isEqual()</code>。然而，我声明过度使用lodash.js，尤其是对于我提到的一些函数，会对您的项目产生负面影响。</p><p id="868e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">拥有由许多不同的lodash.js函数组成的代码，需要新开发人员学习这个包，而不是JavaScript，这需要时间和精力。在更简单的函数可以使用的地方使用库函数，会降低一个人对任何给定编程语言的理解，最终会降低一个人编码的效率。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="28fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">最初发表于</em><a class="ae nu" href="https://gist.github.com/MichalBurgunder/58c1350dcf3c78c723e2886cf50c6efe" rel="noopener ugc nofollow" target="_blank"><em class="ln">【http://github.com】</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>