<html>
<head>
<title>The Complete SwiftUI Documentation You’ve Been Waiting For</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您期待已久的完整SwiftUI文档</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-swiftui-documentation-youve-been-waiting-for-fdfe7241add9?source=collection_archive---------0-----------------------#2020-02-11">https://betterprogramming.pub/the-complete-swiftui-documentation-youve-been-waiting-for-fdfe7241add9?source=collection_archive---------0-----------------------#2020-02-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="550a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">超越苹果的文档。代码示例、建议的最佳实践以及对所有视图、控件、布局等的解释！</h2></div><p id="15f0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="lf">本文最好在Chrome上查看，因为链接到介质上的部分存在限制。</em></p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj lg"><img src="../Images/a04a3bfd0e842f3dd8013891b121a3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImJ9zJLX4s7_fKx8g7FjfQ.jpeg"/></div></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">苏珊·尹在<a class="ae lw" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7c49" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui" rel="noopener ugc nofollow" target="_blank">苹果的SwiftUI文档</a>涵盖了很多SwiftUI的基础知识。但是那些仍然存在的差距呢？我们都知道，当WWDC在2020年6月到来时，文档可能会大规模更新，但我们不能等那么久！</p><p id="376e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">以下是我对SwiftUI现有文档的每一页所了解到的一切。苹果提供的我就不重复了，他们没说的我尽量补充。为了保持一致，我将使用相同的类别，这绝对不是因为我懒得想自己的类别。</p><p id="ae76" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每个类别标题将直接链接到苹果的版本。</p><p id="35b3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我不指望有人会读完整篇文章。如果有，我佩服你的敬业精神！我估计好一点的编程编辑都要看一遍，我很感谢他们。</p><p id="cf0f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我的建议是，虽然你现在可能不需要所有这些，但你将来可能会需要，所以把它做成书签，以后当你的知识有缺口时再来看它可能会有所帮助。</p><p id="4776" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我的知识也有缺口，这就是为什么我承诺尽可能经常更新这篇文章。如果有你认为我应该澄清或更详细地涉及的领域，让我知道！</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="b81a" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">目录</h1><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="fea1" class="nb mf iu mx b gz nc nd l ne nf">VIEWS AND CONTROLS<br/>- <a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3" rel="noopener">SwiftUI 2 changes</a><br/>- <a class="ae lw" href="#d1ca" rel="noopener ugc nofollow">The View protocol</a><br/>- <a class="ae lw" href="#2307" rel="noopener ugc nofollow">Text</a><br/>- <a class="ae lw" href="#137d" rel="noopener ugc nofollow">Text ViewModifiers</a><br/>- <a class="ae lw" href="#b4d4" rel="noopener ugc nofollow">Standard text modifiers</a><br/>- <a class="ae lw" href="#162d" rel="noopener ugc nofollow">TextField</a><br/>- <a class="ae lw" href="#06e7" rel="noopener ugc nofollow">TextField ViewModifiers</a><br/>- <a class="ae lw" href="#edca" rel="noopener ugc nofollow">SecureTextField</a><br/>- <a class="ae lw" href="#b43a" rel="noopener ugc nofollow">SecureTextField ViewModifiers</a><br/>- <a class="ae lw" href="#6742" rel="noopener ugc nofollow">Font</a><br/>- <a class="ae lw" href="#ead4" rel="noopener ugc nofollow">Image</a><br/>- <a class="ae lw" href="#08d7" rel="noopener ugc nofollow">SF Symbols</a><br/>- <a class="ae lw" href="#ad26" rel="noopener ugc nofollow">Button</a><br/>- <a class="ae lw" href="#cb4b" rel="noopener ugc nofollow">ButtonStyle</a><br/>- <a class="ae lw" href="#a858" rel="noopener ugc nofollow">NavigationView and NavigationLink</a><br/>- <a class="ae lw" href="#7d0c" rel="noopener ugc nofollow">EditButton</a><br/>- <a class="ae lw" href="#893d" rel="noopener ugc nofollow">MenuButton</a><br/>- <a class="ae lw" href="#b6ac" rel="noopener ugc nofollow">PasteButton</a><br/>- <a class="ae lw" href="#3cf6" rel="noopener ugc nofollow">Toggle</a><br/>- <a class="ae lw" href="#52a0" rel="noopener ugc nofollow">Creating a custom ToggleStyle</a><br/>- <a class="ae lw" href="#7966" rel="noopener ugc nofollow">Picker</a><br/>- <a class="ae lw" href="#2aa1" rel="noopener ugc nofollow">DatePicker</a><br/>- <a class="ae lw" href="#7455" rel="noopener ugc nofollow">Slider</a><br/>- <a class="ae lw" href="#fdee" rel="noopener ugc nofollow">Stepper</a></span><span id="3cb7" class="nb mf iu mx b gz ng nd l ne nf">VIEW LAYOUT AND PRESENTATION<br/>- <a class="ae lw" href="#978e" rel="noopener ugc nofollow">HStack, VStack, and ZStack</a><br/>- <a class="ae lw" href="#c810" rel="noopener ugc nofollow">List, ScrollView, ForEach, and DynamicViewContent</a><br/>- <a class="ae lw" href="#5356" rel="noopener ugc nofollow">Identifiable</a><br/>- <a class="ae lw" href="#f38e" rel="noopener ugc nofollow">Axis</a><br/>- <a class="ae lw" href="#f3c0" rel="noopener ugc nofollow">Form</a><br/>- <a class="ae lw" href="#f8c1" rel="noopener ugc nofollow">Group</a><br/>- <a class="ae lw" href="#8d90" rel="noopener ugc nofollow">GroupBox</a><br/>- <a class="ae lw" href="#2c75" rel="noopener ugc nofollow">Section</a><br/>- <a class="ae lw" href="#e2b0" rel="noopener ugc nofollow">Spacer</a><br/>- <a class="ae lw" href="#f5bf" rel="noopener ugc nofollow">Divider</a><br/>- <a class="ae lw" href="#418d" rel="noopener ugc nofollow">TabView</a><br/>- <a class="ae lw" href="#dbd7" rel="noopener ugc nofollow">VSplitView and HSplitView</a><br/>- <a class="ae lw" href="#dc84" rel="noopener ugc nofollow">Alert</a><br/>- <a class="ae lw" href="#b392" rel="noopener ugc nofollow">ActionSheet</a><br/>- <a class="ae lw" href="#3100" rel="noopener ugc nofollow">EmptyView</a><br/>- <a class="ae lw" href="#cbbe" rel="noopener ugc nofollow">EquatableView</a><br/>- <a class="ae lw" href="#bdb1" rel="noopener ugc nofollow">AnyView</a><br/>- <a class="ae lw" href="#a3e8" rel="noopener ugc nofollow">TupleView</a></span><span id="e833" class="nb mf iu mx b gz ng nd l ne nf">DRAWING AND ANIMATION<br/>- <a class="ae lw" href="#789a" rel="noopener ugc nofollow">Animation</a><br/>- <a class="ae lw" href="#1582" rel="noopener ugc nofollow">Animatable and AnimatableData</a><br/>- <a class="ae lw" href="#982c" rel="noopener ugc nofollow">AnimatablePair</a><br/>- <a class="ae lw" href="#db6e" rel="noopener ugc nofollow">EmptyAnimatableData</a><br/>- <a class="ae lw" href="#11ee" rel="noopener ugc nofollow">AnimatableModifier</a><br/>- <a class="ae lw" href="#0817" rel="noopener ugc nofollow">withAnimation (Implicit Animation)</a><br/>- <a class="ae lw" href="#99be" rel="noopener ugc nofollow">AnyTransition</a><br/>- <a class="ae lw" href="#6673" rel="noopener ugc nofollow">InsettableShape</a><br/>- <a class="ae lw" href="#90a3" rel="noopener ugc nofollow">FillStyle</a><br/>- <a class="ae lw" href="#c10c" rel="noopener ugc nofollow">ShapeStyle</a><br/>- <a class="ae lw" href="#176d" rel="noopener ugc nofollow">GeometryEffect</a><br/>- <a class="ae lw" href="#b383" rel="noopener ugc nofollow">Angle</a><br/>- <a class="ae lw" href="#9134" rel="noopener ugc nofollow">Edge and EdgeInsets</a><br/>- <a class="ae lw" href="#4dd2" rel="noopener ugc nofollow">Rectangle, RoundedRectangle, Circle, Ellipse, and Capsule</a><br/>- <a class="ae lw" href="#e425" rel="noopener ugc nofollow">Path</a><br/>- <a class="ae lw" href="#83d6" rel="noopener ugc nofollow">ScaledShape, RotatedShape, and OffsetShape</a><br/>- <a class="ae lw" href="#5a4d" rel="noopener ugc nofollow">TransformedShape</a><br/>- <a class="ae lw" href="#690f" rel="noopener ugc nofollow">Color</a><br/>- <a class="ae lw" href="#c123" rel="noopener ugc nofollow">ImagePaint</a><br/>- <a class="ae lw" href="#3ba2" rel="noopener ugc nofollow">Gradients (Linear/Angular/Radial)</a><br/>- <a class="ae lw" href="#fa47" rel="noopener ugc nofollow">GeometryReader and GeometryProxy</a><br/>- <a class="ae lw" href="#7513" rel="noopener ugc nofollow">CoordinateSpace</a></span><span id="dcbd" class="nb mf iu mx b gz ng nd l ne nf">FRAMEWORK INTEGRATION<br/>- <a class="ae lw" href="#17b6" rel="noopener ugc nofollow">UIHostingController</a><br/>- <a class="ae lw" href="#171f" rel="noopener ugc nofollow">UIViewRepresentable</a><br/>- <a class="ae lw" href="#7b0c" rel="noopener ugc nofollow">UIViewControllerRepresentable</a><br/>- <a class="ae lw" href="#3cb4" rel="noopener ugc nofollow">DigitalCrownRotationalSensitivity</a></span><span id="4128" class="nb mf iu mx b gz ng nd l ne nf">STATE AND DATA FLOW<br/>- <a class="ae lw" href="#efd1" rel="noopener ugc nofollow">State</a><br/>- <a class="ae lw" href="#0e81" rel="noopener ugc nofollow">Binding</a><br/>- <a class="ae lw" href="#65b8" rel="noopener ugc nofollow">ObservedObject</a><br/>- <a class="ae lw" href="#7a99" rel="noopener ugc nofollow">EnvironmentObject</a><br/>- <a class="ae lw" href="#933d" rel="noopener ugc nofollow">FetchRequest and FetchedResults</a><br/>- <a class="ae lw" href="#9a25" rel="noopener ugc nofollow">DynamicProperty</a><br/>- <a class="ae lw" href="#98ed" rel="noopener ugc nofollow">Environment</a><br/>- <a class="ae lw" href="#66a3" rel="noopener ugc nofollow">PreferenceKey</a><br/>- <a class="ae lw" href="#394b" rel="noopener ugc nofollow">LocalizedStringKey</a></span><span id="5148" class="nb mf iu mx b gz ng nd l ne nf">GESTURES<br/>- <a class="ae lw" href="#f198" rel="noopener ugc nofollow">Gestures</a></span><span id="332b" class="nb mf iu mx b gz ng nd l ne nf">PREVIEWS<br/>- <a class="ae lw" href="#8932" rel="noopener ugc nofollow">The PreviewProvider protocol</a></span></pre></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="086d" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/views_and_controls" rel="noopener ugc nofollow" target="_blank">视图和控件</a></h1><p id="c76c" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3" rel="noopener"> SwiftUI 2变更</a></p><h2 id="d1ca" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">查看协议</h2><p id="6bc8" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果您还不知道，SwiftUI使用<code class="fe nx ny nz mx b">View</code>协议来创建可重用的界面元素。视图是值类型，这意味着它们使用一个<code class="fe nx ny nz mx b">Struct</code>而不是一个<code class="fe nx ny nz mx b">Class</code>定义。</p><p id="4b05" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这实际上意味着什么呢？</p><p id="c737" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">结构不允许继承。尽管你的结构符合<code class="fe nx ny nz mx b">View</code>协议，但是它们并没有继承苹果提供的一个叫做<code class="fe nx ny nz mx b">View</code>的基类。</p><p id="0175" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这使得它与<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank">UIView</a></code>不同，UIKit中的几乎所有东西都继承自<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank">UIView</a></code>。一个<code class="fe nx ny nz mx b">UIView</code>如果不被分配一个框架并作为一个<code class="fe nx ny nz mx b">UIViewController</code>子类的子视图被添加，基本上是看不到的。</p><p id="df53" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你创建一个新的Xcode项目，它使用SwiftUI而不是Storyboard作为其用户界面的基础，你会自动得到一个SwiftUI <code class="fe nx ny nz mx b">View</code>的例子，叫做<code class="fe nx ny nz mx b">ContentView</code>。</p><p id="0f17" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您会注意到在<code class="fe nx ny nz mx b">ContentView</code>结构中，有一个名为body的变量。这是<code class="fe nx ny nz mx b">View</code>协议的唯一要求，它使用了Swift 5.1中全新的<code class="fe nx ny nz mx b">some</code>关键字。</p><p id="6398" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可以依靠<a class="ae lw" href="https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui" rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>来解释这个关键字的意思，比我更好:</p><blockquote class="oa ob oc"><p id="0ce7" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">你可以把它看作是一个“反向”通用占位符。与调用者满足的常规泛型占位符不同……不透明结果类型是实现满足的隐式泛型占位符……从中得出的主要结论是，返回<code class="fe nx ny nz mx b">some P</code>的函数是一个返回符合<code class="fe nx ny nz mx b">P</code>的特定单一具体类型的值的函数。</p></blockquote><p id="8636" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们开始看看苹果提供的符合<code class="fe nx ny nz mx b">View</code>协议的示例视图。</p><h2 id="2307" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">文本</h2><p id="ea5e" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">参见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#ab2f" rel="noopener">文本(在2.0中更新)</a></p><p id="d61b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您在创建SwiftUI Xcode项目时得到的那个示例项目可能包括最简单的视图构建块，它被称为<code class="fe nx ny nz mx b">Text</code>。</p><p id="f6a5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在大多数情况下，您将传递一个<code class="fe nx ny nz mx b">String</code>给这个的构造函数，这将是它显示的内容。</p><p id="5ba5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面是一些<code class="fe nx ny nz mx b">Text</code>的初始化器的例子:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="4541" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意，最后一个初始化器，采用了<code class="fe nx ny nz mx b">LocalizedStringKey</code>、<code class="fe nx ny nz mx b">tableName</code>、<code class="fe nx ny nz mx b">bundle</code>和<code class="fe nx ny nz mx b">comment</code>，需要一个使用<code class="fe nx ny nz mx b">.strings</code>文件扩展名的单独文件。</p><p id="3110" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如在<a class="ae lw" href="https://developer.apple.com/documentation/swiftui/text/3065754-init" rel="noopener ugc nofollow" target="_blank">苹果关于这个初始化器</a>的文档中提到的，唯一需要的参数是键的字符串。我给出了一个详细的例子，主要是为了让您了解这些其他参数需要什么。</p><p id="89a6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">tableName</code>的缺省值是<code class="fe nx ny nz mx b">Localizable</code>，这是字符串文件的标准名称。我特意将我的命名为<code class="fe nx ny nz mx b">Local</code>,以说明为什么我需要这个参数。</p><p id="b069" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">默认情况下，这个包是主包，所以在这种情况下传递<code class="fe nx ny nz mx b">Bundle.main</code>是多余的。</p><p id="ade5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注释应该给出上下文信息，但是在这个例子中，我只给出了字符串<code class="fe nx ny nz mx b">Comment</code>。</p><p id="6080" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这里的<code class="fe nx ny nz mx b">Text</code>被嵌入到<code class="fe nx ny nz mx b">VStack</code>中，因为主体变量的不透明结果类型必须被设置为一种类型。换句话说，它不能设置为几个项目，因为这可能涉及几个类型。</p><p id="e5e9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">虽然<code class="fe nx ny nz mx b">VStack</code>可以包含多达十个视图，但是每个视图都可以是<code class="fe nx ny nz mx b">VStack</code>、<code class="fe nx ny nz mx b">HStack</code>或<code class="fe nx ny nz mx b">Group</code>，并且每个视图都可以有十种类型。</p><p id="2f60" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">向下滚动到<a class="ae lw" href="#978e" rel="noopener ugc nofollow"> HStack、VStack和ZStack </a>了解更多详情。</p><h2 id="137d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">文本视图修饰符</h2><p id="b0c1" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">与所有视图一样，文本可以被符合ViewModifier协议的结构修改。</p><p id="99ab" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们来看一个自定义修改器的例子，这样您就可以看到在这些修改器的表面下发生了什么:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">所有这些文本看起来都一样，但是后两个文本使用了自定义的视图修饰符</p></figure><p id="a903" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如您所见，添加<code class="fe nx ny nz mx b">.modifier(YourModifier())</code>来调用ViewModifier是可能的，但是使用<code class="fe nx ny nz mx b">View</code>扩展并给出一个干净的调用点更有意义。</p><p id="048f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是标准修改器的样子，所以做一个<code class="fe nx ny nz mx b">View</code>扩展会让你的修改器看起来更像默认的。</p><p id="0f80" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果没有这个，将很难创建一个比缺省值更容易编写的<code class="fe nx ny nz mx b">ViewModifier</code>,因为以单词“modifier”开始修饰符并调用其构造函数会增加不必要的复杂性。</p><h2 id="b4d4" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">标准文本修饰符</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/16d5aa5a35fbf929bced1843ae6ee85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*njuArl4UWz3pwLyyeERRUQ.png"/></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">默认字体的所有大小和粗细</p></figure><p id="eeb1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这个例子中，我在保存字体对齐的<code class="fe nx ny nz mx b">VStack</code>周围放了一个红色边框。这是为了表明这个<code class="fe nx ny nz mx b">VStack</code>的边界是有限的，因为内部的<code class="fe nx ny nz mx b">Text</code>具有固定的最大尺寸。</p><p id="d549" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果不这样做，<code class="fe nx ny nz mx b">Text</code> s的对齐没有任何效果，因为<code class="fe nx ny nz mx b">VStack</code>容器将扩展以容纳里面的<code class="fe nx ny nz mx b">Text</code>。</p><p id="baa9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了对齐前缘(左)或后缘(右)，我们需要定义前缘或后缘的位置。这也可以通过固定<code class="fe nx ny nz mx b">VStack</code>本身的宽度来实现。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><figure class="lh li lj lk gu ll gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/b6f957442ad2daa32222d0a68f4559b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*5AX1Z8rImCB5LppN1ynK3A.png"/></div></figure><p id="a17f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意这个例子是如何在<code class="fe nx ny nz mx b">Text</code>而不是<code class="fe nx ny nz mx b">View</code>上创建扩展的。这是因为在这种情况下，您只能保证接收到的类型是一个<code class="fe nx ny nz mx b">Text</code>。</p><p id="b853" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不可能通过创建一个<code class="fe nx ny nz mx b">ViewModifier</code>或<code class="fe nx ny nz mx b">View</code>扩展来实现与<code class="fe nx ny nz mx b">greenStrikethrough</code>或<code class="fe nx ny nz mx b">redUnderline</code>的等效，因为这些扩展采用了一个可能不是<code class="fe nx ny nz mx b">Text</code>的通用<code class="fe nx ny nz mx b">View</code>。</p><p id="5977" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">既然您已经知道了这一点，那么您可以创建自己的定制函数来定制<code class="fe nx ny nz mx b">Text</code>，而不需要我上面提到的创建<code class="fe nx ny nz mx b">ViewModifier</code>的中间步骤。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="162d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">文本字段</h2><p id="114a" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果您希望用户输入文本，您将需要一个绑定来存储该数据。第一个例子使用了一个<code class="fe nx ny nz mx b">State</code>变量，它将字符串本地存储在SwiftUI结构中，实际上并不将它保存在任何可以使用它的地方，也不永久存储它。</p><p id="6566" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您想保留您的数据并能够给它一个计算值，您将需要一个<code class="fe nx ny nz mx b">ObservableObject</code>。这实际上为您提供了一个存储数据的常规Swift文件，一旦您开始添加可以修改数据值的控件，这将变得非常有用。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="aa8b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您不需要为您保存的字符串值提供一个<code class="fe nx ny nz mx b">didSet</code>闭包，我只是提供一个例子来展示<code class="fe nx ny nz mx b">didSet</code>何时运行。我的<code class="fe nx ny nz mx b">DataModel</code>类是一个普通的Swift类，所以它的<code class="fe nx ny nz mx b">didSet</code>闭包运行并打印字符串的新值。</p><p id="9aab" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然而，由于SwiftUI视图是动态创建的值类型，所以当您修改本地<code class="fe nx ny nz mx b">State</code>变量时，<code class="fe nx ny nz mx b">didSet</code>回调不会将任何内容打印到控制台。</p><p id="dd87" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你注意到后来的一些初始化器是如何使用<code class="fe nx ny nz mx b">Float</code>而不是<code class="fe nx ny nz mx b">String</code>的吗？</p><p id="2000" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些初始化器可以接受任何类型，但是要注意传入一个提供的<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/formatter" rel="noopener ugc nofollow" target="_blank">Formatter</a></code>类，或者自己创建一个。</p><p id="aa50" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我的例子中，我使用了<code class="fe nx ny nz mx b">NumberFormatter</code>，它不会让您输入任何不是数字的字符。这让我很容易保存我的<code class="fe nx ny nz mx b">Float</code>，而不用担心应用程序会崩溃，因为我不能将一串字母转换成存储<code class="fe nx ny nz mx b">TextField</code>值的<code class="fe nx ny nz mx b">Float</code>。</p><p id="cf4d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">其他初始化器也有两个闭包，第一个是<code class="fe nx ny nz mx b">onEditingChanged</code>。</p><p id="e66a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/textfield/3338359-init" rel="noopener ugc nofollow" target="_blank">苹果关于这个</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/textfield/3338359-init" rel="noopener ugc nofollow" target="_blank">TextField</a></code> <a class="ae lw" href="https://developer.apple.com/documentation/swiftui/textfield/3338359-init" rel="noopener ugc nofollow" target="_blank">初始化器</a>的文档没有提到闭包里面的bool表示什么，但是测试似乎表明它与<code class="fe nx ny nz mx b">TextField</code>被赋予焦点有关。</p><p id="830e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有没有在UIKit的<code class="fe nx ny nz mx b">UITextField</code>上调用过<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiresponder/1621097-resignfirstresponder" rel="noopener ugc nofollow" target="_blank">resignFirstResponder</a></code>？</p><p id="d563" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这实质上抛弃了键盘，因为<code class="fe nx ny nz mx b">UITextField</code>不再需要焦点。即使您可以在某个时候恢复键盘，文本也不会插入到那个<code class="fe nx ny nz mx b">UITextField</code>中，除非您再次将它设为第一响应者。</p><p id="0202" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这都与<code class="fe nx ny nz mx b">UIResponder</code>有关，一个抽象接口，从它继承了<code class="fe nx ny nz mx b">UIView</code>、<code class="fe nx ny nz mx b">UIViewController</code>以及UIKit中的其他所有东西。</p><p id="6c4b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们不知道SwiftUI事件是如何在相同程度上得到处理的，但我使用了短语<em class="lf"> first responder </em>，因为使用过<code class="fe nx ny nz mx b">UITextField</code>的人应该很熟悉它。</p><p id="f3c6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">onEditingChanged</code>中的bool可以被称为<code class="fe nx ny nz mx b">fieldActive</code>或者任何你想叫的名字，这样你就清楚了。</p><p id="433d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">重要的是，当你开始编辑一个<code class="fe nx ny nz mx b">TextField</code>，<code class="fe nx ny nz mx b">onEditingChanged</code>被一个设置为true的bool调用。当你按下键盘的回车键时，调用<code class="fe nx ny nz mx b">onCommit</code>块，之后用一个设置为<code class="fe nx ny nz mx b">false</code>的bool调用<code class="fe nx ny nz mx b">onEditingChanged</code>。</p><h2 id="06e7" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">文本字段视图修饰符</h2><p id="1342" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">关于什么是视图修改器的更详细解释，见<a class="ae lw" href="#137d" rel="noopener ugc nofollow">文本视图修改器</a>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="9dce" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您目前不能更改<code class="fe nx ny nz mx b">TextField</code>中占位符文本的前景色。在我写这篇文章的时候，当在<code class="fe nx ny nz mx b">List</code>中显示<code class="fe nx ny nz mx b">TextField</code> s时，除了默认键盘类型之外，你不能为<code class="fe nx ny nz mx b">TextField</code>使用任何键盘类型。</p><p id="7d5f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我发现试图在<code class="fe nx ny nz mx b">List</code>中显示<code class="fe nx ny nz mx b">TextField</code>也会导致它们相互重叠。以下是在<code class="fe nx ny nz mx b">VStack</code>中展示的所有键盘类型，它们似乎都工作得很好:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="edca" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">安全文本字段</h2><p id="8f58" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">本质上与上面的<code class="fe nx ny nz mx b">TextField</code>相同，附加的好处是隐藏您输入的字符，这对密码很有用。与上面的<code class="fe nx ny nz mx b">TextField</code>一样，您可以选择多种键盘类型，此处仅显示<code class="fe nx ny nz mx b">numberPad</code>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="b43a" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">SecureTextField视图修饰符</h2><p id="0472" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">关于视图修饰符的详细解释，见<a class="ae lw" href="#137d" rel="noopener ugc nofollow">文本视图修饰符</a>。</p><p id="438b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">与<code class="fe nx ny nz mx b">TextField</code>类似，您可以更改前景色或背景色，添加边框，并使用不同的<code class="fe nx ny nz mx b">TextFieldStyle</code>，但此时您不能更改占位符文本的前景色。</p><h2 id="6742" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">字体</h2><p id="9f68" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">我不能详细阐述苹果文档中关于<code class="fe nx ny nz mx b">Font</code>的内容，所以我提供了一种简单的方法来使用定制字体，就像使用苹果标准字体一样:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="f2cb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意我是如何对<code class="fe nx ny nz mx b">Font</code>和<code class="fe nx ny nz mx b">View</code>进行扩展的。不用用扩展，我直接用<code class="fe nx ny nz mx b">Font.custom</code>的时候你就看到了。所有这些方法都会导致相同的<code class="fe nx ny nz mx b">Text</code>，所以这只是一个你认为哪个代码最干净的问题。</p><p id="5bd3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最容易编写的是<code class="fe nx ny nz mx b">View</code>扩展，它不需要你向函数传递任何东西。</p><p id="1200" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">Font</code>扩展名更符合标准Apple字体的分配方式，例如<code class="fe nx ny nz mx b">.font(.headline)</code>。</p><h2 id="ead4" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">图像</h2><p id="fd25" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#fd7f" rel="noopener">图像(在SwiftUI 2.0中更新)</a></p><p id="f011" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">SwiftUI中的<a class="ae lw" href="https://developer.apple.com/documentation/swiftui/image" rel="noopener ugc nofollow" target="_blank">图片</a>比UIKit中的要容易得多。与其需要创建一个<code class="fe nx ny nz mx b">UIImage(named: “Your file name”)</code>并将其分配给<code class="fe nx ny nz mx b">yourUIImageView.image</code>，不如创建<code class="fe nx ny nz mx b">Image</code>与<code class="fe nx ny nz mx b">Text</code>一样简单。</p><p id="7b3c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">只需给它传递一个<code class="fe nx ny nz mx b">String</code>，它会将它设置为一个同名的文件。如果您启动您的应用程序，但它没有该名称的文件，您会收到一条有用的控制台消息，内容如下:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="cfe6" class="nb mf iu mx b gz nc nd l ne nf">No image named ‘Your file name’ found in asset catalog for main bundle. </span></pre><p id="d6f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您发现应用程序中没有出现图像，您可能需要在控制台中搜索。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="c74a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kl iv">默认情况下，图像不可调整大小</strong></p><p id="6d7c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在随后的修改器中改变其大小之前，必须调用<code class="fe nx ny nz mx b">Image</code>上的<code class="fe nx ny nz mx b">.resizable()</code>修改器。</p><p id="0bff" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">scaledToFit</code>修改器将锁定图像的长宽比，并将其缩放到最大尺寸，但不会对屏幕太大。</p><p id="61b1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">scaledToFill</code>修改器也可以缩放你的图像，但是它不能锁定纵横比，因此很可能会拉伸或收缩你的图像以适应可用空间。</p><h2 id="08d7" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">SF符号</h2><p id="1c9a" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果你不熟悉它们，<a class="ae lw" href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/" rel="noopener ugc nofollow" target="_blank"> SF Symbols </a>是一个超过1500个符号的库，苹果提供了从超轻到黑色的九种重量。</p><p id="0a86" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">要在您的图像中使用这些，只需将您传递到图像中的<code class="fe nx ny nz mx b">String</code>标记为<code class="fe nx ny nz mx b">systemName</code>。或许值得下载<a class="ae lw" href="https://developer.apple.com/design/downloads/SF-Symbols.dmg" rel="noopener ugc nofollow" target="_blank"> SF Symbols Mac app </a>，这样你就可以找到你想要使用的符号的系统名称。</p><p id="eaab" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用SF符号给你的应用程序带来一致的外观，由于这些免费符号的灵活性和可访问性，这可能会在未来几年接管iOS生态系统。</p><h2 id="ad26" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">纽扣</h2><p id="975d" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#4777" rel="noopener">按钮(在2.0中更新)</a></p><p id="cb3f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/button" rel="noopener ugc nofollow" target="_blank">Button</a></code>没有自己的样子。换句话说，你将需要给你的<code class="fe nx ny nz mx b">Button</code>一个<code class="fe nx ny nz mx b">Label</code>，它本身是任何符合<code class="fe nx ny nz mx b">View</code>的具体类型。</p><p id="8722" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最明显的例子是一个<code class="fe nx ny nz mx b">Text</code>，它会给出你的按钮将要做什么的信息。在我写这篇文章的时候，Apple在文档中指定的唯一一件事(除了如何创建和样式化它们)是按钮的触发方式因操作系统而异。</p><p id="fc06" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在iOS上，你点击它，在tvOS上，当按钮被选中时，你按下enter，在有或没有Catalyst的macOS应用程序中，苹果没有提到，你用鼠标或触控板点击。</p><p id="7f60" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">构造函数要求你给出一个动作。这可以是一组空的花括号，但至少必须以这种形式出现。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="b8ce" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">除了在花括号中指定您的功能(这会很快变得冗长)，您还可以指定不带花括号和不带 <code class="fe nx ny nz mx b"><em class="lf">()</em></code> <em class="lf">调用操作符的函数名称<em class="lf">。</em>这并没有将动作绑定到变量上，这意味着你不需要<code class="fe nx ny nz mx b">$</code>操作符，你可以在像<code class="fe nx ny nz mx b">Toggle</code>这样的绑定控件上找到它。</em></p><h2 id="cb4b" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">按钮样式</h2><p id="d850" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">有些控件允许您选择现有的样式，比如在这种情况下符合<code class="fe nx ny nz mx b">ButtonStyle</code>的样式。这也意味着你可以为一个<code class="fe nx ny nz mx b">Button</code>创建你自己的定制风格，如何做的细节可以在<a class="ae lw" href="https://swiftui-lab.com/custom-styling/" rel="noopener ugc nofollow" target="_blank"> SwiftUI实验室的定制风格教程</a>中找到。</p><p id="b0b7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如你可能在我对那篇文章的评论中看到的，<code class="fe nx ny nz mx b">SliderStyle</code>目前并不存在(尽管它在苹果的网站上有记录)。让我们浏览一下现有的按钮样式，看看它们是如何工作的。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="332a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意，有些只能在MacOS上使用。</p><h2 id="a858" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">导航视图和导航链接</h2><p id="93e9" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#3320" rel="noopener">导航视图(在2.0中更新)</a></p><p id="7339" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">将视图嵌入到<code class="fe nx ny nz mx b">NavigationView</code>中允许您设置导航标题并链接到其他视图。类似于<code class="fe nx ny nz mx b">Button</code>,<code class="fe nx ny nz mx b">NavigationLink</code>需要一个<code class="fe nx ny nz mx b">Label</code>，它基本上是任何符合<code class="fe nx ny nz mx b">View</code>协议的结构。</p><p id="c75d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在大多数情况下，这可能是一个<code class="fe nx ny nz mx b">Text</code>或<code class="fe nx ny nz mx b">Image</code>，但也可以是您创建的任何自定义视图。</p><p id="ff41" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在iPhone上，作为链接目的地的<code class="fe nx ny nz mx b">View</code>从右边滑入，每个连续的<code class="fe nx ny nz mx b">NavigationLink</code>以同样的方式滑动。当返回初始<code class="fe nx ny nz mx b">View</code>时，可以从左边缘滑动或者使用导航栏左上角的返回按钮。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="6c56" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个例子来自我的手表应用Dog HQ，它显示了全尺寸狗狗照片的滚动列表，每张照片都链接到一个放大版本。</p><p id="daba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是为什么我需要将索引传递给我放大的<code class="fe nx ny nz mx b">DogView</code>的构造函数，这样我就知道我想要哪只狗作为目的地。</p><p id="27a9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">将一个垂直滚动并扩展到我想要的任何大小的<code class="fe nx ny nz mx b">List</code>与一个<code class="fe nx ny nz mx b">ForEach</code>结合起来，允许我创建50行并将该索引传递到具有我指定的名称的闭包中。</p><p id="0dd9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">ForEach</code>的迭代可以是一个数组中最大项数的序列，或者数组可以被传递到<code class="fe nx ny nz mx b">List</code>的构造函数中，并在闭包内用您指定的名称进行访问。</p><p id="01c1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">显然，我只是对这个数组略知皮毛。数组可以包含复杂的类型，比如一个自定义类，它有一个名为<code class="fe nx ny nz mx b">imageName</code>的字符串属性，一个数字值，或者甚至是另一个类的实例，您可以使用点语法来访问它。</p><p id="9b25" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">屏幕顶部的导航栏可以包含一个前导和尾随按钮。其主要用途似乎是添加一个<code class="fe nx ny nz mx b">EditButton</code>，这将在下面详细描述。</p><h2 id="7d0c" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">编辑按钮</h2><p id="57e7" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">当你有一个<code class="fe nx ny nz mx b">List</code>条目并且你想删除其中一些的时候，编辑按钮是非常有用的。点击它进入编辑模式(不出所料)，每行显示一个红色圆圈，并有一条水平线穿过它。</p><p id="e830" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">点击<em class="lf">编辑</em>将向左滑动该行，显示右端的删除按钮，作为最终确认。</p><p id="e88a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您仍然需要实现一个函数来处理从列表中删除数据，否则，您的更改只是可视化的，您的数据实际上不会以您期望的方式被删除。</p><p id="05df" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有关使用<code class="fe nx ny nz mx b">EditButton</code>的更多信息，请参见<a class="ae lw" href="#c810" rel="noopener ugc nofollow"> List、ScrollView、ForEach和DynamicViewContent </a>。</p><h2 id="893d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">菜单按钮</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj ok"><img src="../Images/cf1a70bb9cd1eb87a0c58b92ee469023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1vREzJj2wY4bvFHIzXwUw.png"/></div></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">目前有四个菜单按钮样式选项可用</p></figure><p id="2e95" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">MenuButton</code>只在macOS应用程序上可用，所以我提供了一个使用所有标准<code class="fe nx ny nz mx b">.menuButtonStyle</code>选项的Mac应用程序示例。</p><p id="22f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">从左到右，这些款式分别是<code class="fe nx ny nz mx b">BorderlessButtonMenuButtonStyle</code>、<code class="fe nx ny nz mx b">BorderlessPullDownMenuButtonStyle</code>、<code class="fe nx ny nz mx b">PullDownMenuButtonStyle</code>。</p><p id="34ec" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果最右边的那个和旁边的很像，那是因为它用了<code class="fe nx ny nz mx b">DefaultMenuButtonStyle</code>。</p><p id="6e2b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">由于默认的<code class="fe nx ny nz mx b">MenuButton</code>有<code class="fe nx ny nz mx b">PullDownMenuButtonStyle</code>的外观，所以这些看起来完全一样。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="b6ac" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">粘贴按钮</h2><p id="52a6" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#ec57" rel="noopener">粘贴按钮(在2.0中更新)</a></p><p id="eca2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">此控件允许您在MacOS上粘贴信息，但在iOS上不可用。它可以采用各种数据类型，这些数据类型被表示为UTI类型。</p><p id="6a93" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我在示例中包含了一个函数，可以让您查找任何类型的UTI字符串，这可能会在实现这个按钮时对您有所帮助。一旦您决定了您需要什么类型标识符，您将需要处理您从<code class="fe nx ny nz mx b">NSItemProvider</code>获得的数据。</p><p id="a289" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我已经展示了一个例子，在这个例子中，我只粘贴了数组中的第一项，但是希望它能清楚地说明如何处理其他数据类型和多项。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="b052" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">以下是符合<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsitemproviderwriting" rel="noopener ugc nofollow" target="_blank">NSItemProviderWriting</a></code>的类型列表，因此可以用<code class="fe nx ny nz mx b">PasteButton</code>粘贴:</p><ul class=""><li id="8186" class="ol om iu kl b km kn kp kq ks on kw oo la op le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/contacts/cncontact" rel="noopener ugc nofollow" target="_blank">CNContact</a></code></li><li id="a2eb" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/contacts/cnmutablecontact" rel="noopener ugc nofollow" target="_blank">CNMutableContact</a></code></li><li id="b20c" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/corespotlight/cslocalizedstring" rel="noopener ugc nofollow" target="_blank">CSLocalizedString</a></code></li><li id="eec8" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/mapkit/mkmapitem" rel="noopener ugc nofollow" target="_blank">MKMapItem</a></code></li><li id="4cac" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsattributedstring" rel="noopener ugc nofollow" target="_blank">NSAttributedString</a></code></li><li id="7aa4" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsmutablestring" rel="noopener ugc nofollow" target="_blank">NSMutableString</a></code></li><li id="7f78" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsstring" rel="noopener ugc nofollow" target="_blank">NSString</a></code></li><li id="626c" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/nstextstorage" rel="noopener ugc nofollow" target="_blank">NSTextStorage</a></code></li><li id="c50b" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsurl" rel="noopener ugc nofollow" target="_blank">NSURL</a></code></li><li id="b71f" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/foundation/nsuseractivity" rel="noopener ugc nofollow" target="_blank">NSUserActivity</a></code></li><li id="89cb" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uicolor" rel="noopener ugc nofollow" target="_blank">UIColor</a></code></li><li id="ba9c" class="ol om iu kl b km ou kp ov ks ow kw ox la oy le oq or os ot bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiimage" rel="noopener ugc nofollow" target="_blank">UIImage</a></code></li></ul><p id="29bd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您还可以使用自己的自定义类型来符合该协议，从而允许您粘贴自定义类型的数据。</p><h2 id="3cf6" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">触发器</h2><p id="6ad7" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">参见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#e003" rel="noopener">切换(在2.0中更新)</a></p><p id="89f4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">Toggle</code>是UIKit中<code class="fe nx ny nz mx b">UISwitch</code>的SwiftUI等价物。SwiftUI使用绑定，而不是使用<code class="fe nx ny nz mx b">IBAction</code>函数将Swift代码链接到故事板上的<code class="fe nx ny nz mx b">UISwitch</code>并在其值改变时运行。</p><p id="15b9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果没有将变量标记为<code class="fe nx ny nz mx b">State</code>(在结构内)或<code class="fe nx ny nz mx b">Published</code>(在符合<code class="fe nx ny nz mx b">ObservableObject</code>的外部类中)，SwiftUI不会在值改变时重新绘制<code class="fe nx ny nz mx b">View</code>的内容。</p><p id="7778" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是绑定过程的重要部分，尤其是将外部代码标记为<code class="fe nx ny nz mx b">Published</code>，因为这是SwiftUI知道该变量存在的唯一方式。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="52a0" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">创建自定义ToggleStyle</h2><p id="c83c" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">我注意到<code class="fe nx ny nz mx b">Toggle</code>的初始化器可以接受一个名为<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/togglestyleconfiguration" rel="noopener ugc nofollow" target="_blank">ToggleStyleConfiguration</a></code>的结构，我花了一段时间试图弄清楚如何自己构造这个结构。</p><p id="b804" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在SwiftUI实验室关于定制风格的优秀教程的帮助下，我发现协议<code class="fe nx ny nz mx b">ToggleStyle</code>提供了定制风格的能力。</p><p id="1ff9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它允许您这样做的部分方法是下面的代码行:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="0741" class="nb mf iu mx b gz nc nd l ne nf">typealias <a class="ae lw" href="https://developer.apple.com/documentation/swiftui/togglestyle" rel="noopener ugc nofollow" target="_blank">ToggleStyle</a>.Configuration = <a class="ae lw" href="https://developer.apple.com/documentation/swiftui/togglestyleconfiguration" rel="noopener ugc nofollow" target="_blank">ToggleStyleConfiguration</a></span></pre><p id="86c2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">起初，这种语法让我感到困惑。</p><p id="5d86" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这里使用一个<code class="fe nx ny nz mx b">typealias</code>只是用一个更简洁的本地名称来引用结构的一种方式。这可能是为了使<code class="fe nx ny nz mx b">makeBody</code>函数，如下所示，可以具有与类似协议<code class="fe nx ny nz mx b">ButtonStyle</code>、<code class="fe nx ny nz mx b">PickerStyle</code>和<code class="fe nx ny nz mx b">TextFieldStyle</code>相同的声明签名:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="273e" class="nb mf iu mx b gz nc nd l ne nf">func makeBody(configuration: Self.Configuration) -&gt; some View</span></pre><p id="741a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我不想在这里为<code class="fe nx ny nz mx b">Toggle</code>创建一个自定义的视觉外观，因为这已经在<a class="ae lw" href="https://swiftui-lab.com/custom-styling/" rel="noopener ugc nofollow" target="_blank"> SwiftUI实验室的教程</a>中有很好的介绍了。</p><p id="c15c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">相反，我决定改变标签的处理方式，完全忽略传入的标签，给出两个动态标签，这两个标签根据开关的<code class="fe nx ny nz mx b">isOn</code>状态变化:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="18e2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这里有两个例子，但是看起来完全一样。一种是使用相当冗长的形式，使用<code class="fe nx ny nz mx b">.toggleStyle</code>修饰符，就像标准的<code class="fe nx ny nz mx b">ToggleStyle</code>一样。</p><p id="9a74" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">另一个在<code class="fe nx ny nz mx b">Toggle</code>上使用一个扩展，返回这个冗长的形式，提供一个干净的调用点，但是变得与标准的<code class="fe nx ny nz mx b">ToggleStyle</code>看起来不一致。</p><p id="ccc9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这取决于你喜欢哪一个。不言而喻，在<code class="fe nx ny nz mx b">MyToggleStyle</code>结构中不需要局部变量，缺少局部变量就不需要将值传递给构造函数。</p><p id="8df8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我这样做只是为了展示如何传入自定义值，但是不能改变<code class="fe nx ny nz mx b">makeBody</code>函数的签名。</p><p id="f979" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">换句话说，<code class="fe nx ny nz mx b">makeBody</code>只能带一个<code class="fe nx ny nz mx b">Self.Configuration</code>参数。通过构造一个带有未初始化变量的结构，我们有了另一种方式来传递来自<code class="fe nx ny nz mx b">Toggle</code>构造函数的<code class="fe nx ny nz mx b">isOn</code>绑定和<code class="fe nx ny nz mx b">Label</code>值。</p><p id="3879" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">MyToggleStyle</code>没有利用<code class="fe nx ny nz mx b">configuration.label</code>，这是我们加的<code class="fe nx ny nz mx b">Text(“This label will never be seen”)</code>的值。没有必要添加这个标签，因为没有它也可以构造一个<code class="fe nx ny nz mx b">Toggle</code>,但是有必要指出一个自定义<code class="fe nx ny nz mx b">ToggleStyle</code>如何隐藏它想要的任何东西。</p><p id="8f56" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">既然<code class="fe nx ny nz mx b">makeBody</code>返回<code class="fe nx ny nz mx b">some View</code>，那么你想返回什么都可以。你可以返回一个<code class="fe nx ny nz mx b">Text</code>、<code class="fe nx ny nz mx b">Button</code>、<code class="fe nx ny nz mx b">Image</code>，甚至是一个<code class="fe nx ny nz mx b">VStack</code>，尽管我不知道你为什么要这么做。</p><h2 id="7966" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">采摘者</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj oz"><img src="../Images/55ffb7724535de438619a6be47863621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SUSX_fuhaAu8QQgJ40u_g.png"/></div></div></figure><p id="3d68" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如在关于拣选器的<a class="ae lw" href="https://www.hackingwithswift.com/quick-start/swiftui/pickers-in-forms" rel="noopener ugc nofollow" target="_blank"> Hacking With Swift教程中提到的，在<code class="fe nx ny nz mx b">Form</code>中<code class="fe nx ny nz mx b">Picker</code>的默认行为是将你带到另一个你可以选择选项的地方。</a></p><p id="7e09" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在iOS上你必须把<code class="fe nx ny nz mx b">Form</code>放在<code class="fe nx ny nz mx b">NavigationView</code>里面，否则这个导航不会发生。在一个<code class="fe nx ny nz mx b">Form</code>之外，<code class="fe nx ny nz mx b">DefaultPickerStyle</code>将会是<code class="fe nx ny nz mx b">WheelPickerStyle</code>。</p><p id="ac8a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我还在<code class="fe nx ny nz mx b">UIKit</code>中加入了与<code class="fe nx ny nz mx b">UISegmentedControl</code>外观相似的<code class="fe nx ny nz mx b">SegmentedPickerStyle</code>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="2aa1" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">日期选择器</h2><p id="1af9" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3#9756" rel="noopener">日期选择器(在2.0中更新)</a></p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pa"><img src="../Images/27c212886b27e6ef47fb99b4c3225967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0It5uQqPxp4uCrMoc94fEg.png"/></div></div></figure><p id="531c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">DatePicker</code>与<code class="fe nx ny nz mx b">Picker</code>相似，但风格不尽相同。在<code class="fe nx ny nz mx b">Form</code>内部使用时，<code class="fe nx ny nz mx b">DatePicker</code>只占用一条线。</p><p id="b50d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如你在上面的截图中看到的，一个<code class="fe nx ny nz mx b">Form</code>中的默认<code class="fe nx ny nz mx b">DatePicker</code>有一个标签和当前日期。点击它会导致一个<code class="fe nx ny nz mx b">DatePicker</code>从下面滑出。</p><p id="7d41" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">滑出的<code class="fe nx ny nz mx b">DatePicker</code>与<code class="fe nx ny nz mx b">WheelDatePickerStyle</code>完全相同，这就是为什么它看起来像是现在显示的，而实际上我只是在它下面有一个<code class="fe nx ny nz mx b">WheelDatePickerStyle</code>。</p><p id="b018" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我添加了一个<code class="fe nx ny nz mx b">Picker</code>，您可以用它来尝试不同的日期格式，只是为了展示如何在运行时更改<code class="fe nx ny nz mx b">DatePicker</code>的格式。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="7455" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">滑块</h2><p id="4655" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">滑块允许您在最小值和最大值之间滑动拇指(白色圆圈)。这类似于UIKit中的<code class="fe nx ny nz mx b">UISlider</code>。当您创建它时，您必须设置一个封闭的范围，以便SwiftUI知道最小值和最大值。</p><p id="feda" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">步长可以设置为任意值，如果您不需要将值设置为十进制，这可能会节省您将长的<code class="fe nx ny nz mx b">Float</code>转换为<code class="fe nx ny nz mx b">Int</code>的时间。</p><p id="1f15" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这也有助于您增加或减少记录滑块位置的精确度，通过排除超过您指定的步长数量的小数位，可能会使计算更容易。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="fdee" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">跳舞者</h2><p id="f1bb" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">SwiftUI中的一个<code class="fe nx ny nz mx b">Stepper</code>与<code class="fe nx ny nz mx b">UIKit</code>中的一个<code class="fe nx ny nz mx b">UIStepper</code>基本相同。它由一个相连的减号和加号按钮组成。</p><p id="182d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">并非所有的初始化器都要求你设置一个绑定变量来存储值。它们中的许多都采用闭包，当您递减、递增或编辑<code class="fe nx ny nz mx b">Stepper</code>的值时会调用这些闭包。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="1344" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/view_layout_and_presentation" rel="noopener ugc nofollow" target="_blank">查看布局和演示文稿</a></h1><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pb"><img src="../Images/b531d5e0ea9c85f2237ffe30301bc96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuvW37xaxtfq78soOTT9Sw.png"/></div></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">VStacks是垂直的，HStacks是水平的，ZStacks是多达十个视图的分层堆栈</p></figure><h2 id="978e" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">HStack、VStack和ZStack</h2><p id="9bee" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">虽然总是竖着写，但是这些栈把孩子排列在不同的方向。</p><p id="6455" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">VStack</code>对于任何应用程序来说都是一个有用的起点，因为你可以用多达10个孩子(以及他们所有的后代)快速填充手机屏幕。</p><p id="385f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">HStack</code>将使用可用的水平空间来布局其子项，这可能不允许在纵向手机屏幕上有太多空间。当你想把一个<code class="fe nx ny nz mx b">Text</code>标签放在一个控件旁边时，这是很有用的，比如在一个<code class="fe nx ny nz mx b">List</code>中(见下文)。</p><h2 id="c810" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">List、ScrollView、ForEach和DynamicViewContent</h2><p id="4d95" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#51f2" rel="noopener">列表(在2.0中更新)</a> <br/>另见:<a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#c1f5" rel="noopener">ForEach&amp;DynamicViewContent(在2.0中更新)</a></p><p id="0107" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如在<code class="fe nx ny nz mx b">NavigationLink</code>的例子中提到的，<code class="fe nx ny nz mx b">List</code>是一个滚动视图，它将垂直增长以适应动态的行数。类似于<code class="fe nx ny nz mx b">UIKit</code>中的<code class="fe nx ny nz mx b">UITableView</code>，但是没有任何工作。</p><p id="53fa" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可以像添加<code class="fe nx ny nz mx b">VStack</code>一样添加静态数据到<code class="fe nx ny nz mx b">List</code>，将一个<code class="fe nx ny nz mx b">View</code>放在另一个的上面，或者你可以使用<code class="fe nx ny nz mx b">ForEach</code>。</p><p id="21b0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">ForEach</code>让您循环遍历一个集合，比如一个数组，每次都以标准化的方式显示大量数据。</p><p id="685a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">ScrollView</code>使嵌入其中的<code class="fe nx ny nz mx b">VStack</code>或<code class="fe nx ny nz mx b">HStack</code>能够滚动。默认的<code class="fe nx ny nz mx b">ScrollView</code>垂直滚动，即使<code class="fe nx ny nz mx b">ScrollView</code>的直接子节点是一个<code class="fe nx ny nz mx b">HStack</code>。</p><p id="0f52" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这意味着如果您想要覆盖此行为，您必须使用<code class="fe nx ny nz mx b">ScrollView(.horizontal)</code>。你仍然可以像使用<code class="fe nx ny nz mx b">List</code>一样用<code class="fe nx ny nz mx b">ForEach</code>来使用它们，但是多了一层<code class="fe nx ny nz mx b">VStack</code>或<code class="fe nx ny nz mx b">HStack</code>使得这种方式更加复杂。</p><p id="9b63" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当然，<code class="fe nx ny nz mx b">VStacks</code>没有与<code class="fe nx ny nz mx b">UIKit</code>中的<code class="fe nx ny nz mx b">UITableView</code>单元格外观相似的行。例如，一个由<code class="fe nx ny nz mx b">Text</code>组成的<code class="fe nx ny nz mx b">List</code>将会把那些<code class="fe nx ny nz mx b">Texts</code>一个接一个地堆叠起来，没有分隔物。</p><p id="f751" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">可以定制一个<code class="fe nx ny nz mx b">View</code>来模仿这些行，或者给你的行一个完全不同的外观。</p><p id="9e2b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是除非你需要水平滚动，否则最好使用<code class="fe nx ny nz mx b">List</code>。</p><p id="cb7c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">List</code>也将支持自定义行，并且它还具有带有<code class="fe nx ny nz mx b">VStack</code>的<code class="fe nx ny nz mx b">ScrollView</code>所缺乏的其他特性。</p><p id="17e5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当一个<code class="fe nx ny nz mx b">EditButton</code>被添加到包含一个<code class="fe nx ny nz mx b">List</code>的<code class="fe nx ny nz mx b">View</code>中时，您可以重新排列或删除<code class="fe nx ny nz mx b">List</code>中的项目。</p><p id="93ee" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您没有在这种情况下被调用的方法，那么您的<code class="fe nx ny nz mx b">List</code>行将会消失，但是它后面的数据仍然不受影响。下一次在滑动删除一行后启动应用程序时，该行将会返回，因为底层数据没有被修改。</p><p id="e71f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<a class="ae lw" href="https://www.hackingwithswift.com/books/ios-swiftui/deleting-items-using-ondelete" rel="noopener ugc nofollow" target="_blank">用Swift的</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="https://www.hackingwithswift.com/books/ios-swiftui/deleting-items-using-ondelete" rel="noopener ugc nofollow" target="_blank">onDelete</a></code> <a class="ae lw" href="https://www.hackingwithswift.com/books/ios-swiftui/deleting-items-using-ondelete" rel="noopener ugc nofollow" target="_blank">教程</a>中，可以看到<code class="fe nx ny nz mx b">.onDelete</code>修改器是如何工作的。这使您能够传入一个方法，该方法将在用户滑动鼠标删除您的<code class="fe nx ny nz mx b">List</code>中的项目时运行。</p><p id="3a6f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">DynamicViewContent</code>是<code class="fe nx ny nz mx b">.onDelete</code>修饰符的返回类型，但它意味着<code class="fe nx ny nz mx b">ForEach</code>的内容需要更新。</p><p id="7dc5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">ForEach</code>是另一个<code class="fe nx ny nz mx b">View</code> struct，这意味着当底层数据改变时，它可以自己动态地改变。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="70b8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如你在我的例子中看到的，<code class="fe nx ny nz mx b">.onMove</code>和<code class="fe nx ny nz mx b">.onDelete</code>非常相似。真正的问题发生在你试图使用<code class="fe nx ny nz mx b">.onInsert</code>的时候，我无法使用它。</p><p id="1753" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我期望它的工作方式是在<code class="fe nx ny nz mx b">insert()</code>函数中，这个方法可能会在SwiftUI的未来版本中开始工作。</p><p id="13fa" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">出于某种原因，<code class="fe nx ny nz mx b">.onInsert</code>以字符串的形式接受了一组<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/mobilecoreservices/uttype" rel="noopener ugc nofollow" target="_blank">UTType</a> </code>标识符。这些指定了我们期望插入到<code class="fe nx ny nz mx b">ForEach</code>底层数据中的类型，在本例中是<code class="fe nx ny nz mx b">NSString</code>。</p><p id="2435" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">作为如何创建UTI类型标识符的例子，我从字符串创建了一个<code class="fe nx ny nz mx b">NSItemProvider</code>并打印出来。这为<code class="fe nx ny nz mx b">NSString</code>输出了UTI类型的字符串，这是我在我的<code class="fe nx ny nz mx b">onInsert</code>调用中引用的。</p><p id="3d96" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">即便如此，我提供的名为<code class="fe nx ny nz mx b"><em class="lf">inserted()</em></code>的方法也从来没有被调用过。这似乎表明<code class="fe nx ny nz mx b">.onInsert</code>的功能没有被添加。我只在一个<code class="fe nx ny nz mx b">List</code>和一个<code class="fe nx ny nz mx b">VStack</code>里面试过，所以可能在某个地方有用。</p><p id="f5f8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我知道你是否得到了<code class="fe nx ny nz mx b">onInsert</code>的工作，因为在网上任何地方都没有它的例子。</p><h2 id="5356" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">可辨认的</h2><p id="cb12" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">ForEach</code>swift ui中的循环要求数组中的每一项都是<code class="fe nx ny nz mx b">Identifiable</code>，这意味着每个成员都有自己唯一的标识符。</p><p id="04d2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在下面的例子中，我从一个字符串数组开始。由于<code class="fe nx ny nz mx b">String</code>符合<code class="fe nx ny nz mx b">Hashable</code>协议，所以不需要提供唯一标识符，因为<code class="fe nx ny nz mx b">\.self</code>提供了<code class="fe nx ny nz mx b">hashValue</code>。</p><p id="6703" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我的定制类中符合这个协议将要求我提供一个<code class="fe nx ny nz mx b">hash(into:)</code>函数，它将基本组件组合成一个整数<code class="fe nx ny nz mx b">hashValue</code>，唯一地标识每个实例。</p><p id="e0e6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我还需要重载比较我在<code class="fe nx ny nz mx b">hash(into:)</code>函数中组合的相同属性的<code class="fe nx ny nz mx b">==</code>操作符。</p><p id="fb56" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在苹果的文档中了解更多关于散列协议的信息。</p><p id="9f12" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我创建<code class="fe nx ny nz mx b">myUnhashableType</code>时，我不符合<code class="fe nx ny nz mx b">Hashable</code>协议。</p><p id="77da" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因此，使用ID<code class="fe nx ny nz mx b">\.self</code>不起作用，这可以从第二个<code class="fe nx ny nz mx b">ForEach</code>上面的注释中看出。这会产生一个阻止编译的错误，除非这个<code class="fe nx ny nz mx b">ForEach</code>被注释掉或删除。</p><p id="7b26" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然而，<code class="fe nx ny nz mx b">myIdentifiableType</code>在循环中有一个更容易识别的方法。<code class="fe nx ny nz mx b">Identifiable</code>协议只要求一个名为ID的变量存在，并且对每个实例都是唯一的。</p><p id="2c93" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为此，我只需使用UUID，它会在每次创建新实例时生成一个通用的惟一标识符。</p><p id="a51c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这甚至让我避免了在<code class="fe nx ny nz mx b">ForEach</code>中指定标识符的需要，因为符合<code class="fe nx ny nz mx b">Identifiable</code>准确地告诉了<code class="fe nx ny nz mx b">ForEach</code>它需要什么来标识每个实例。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="f38e" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">轴</h2><p id="44b0" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">这只是一个包含案例<code class="fe nx ny nz mx b">.horizontal</code>和<code class="fe nx ny nz mx b">.vertical</code>的枚举。它用于表示内容可以排列的两个方向。</p><p id="af79" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">例如，一个<code class="fe nx ny nz mx b">ScrollView</code>有一个叫做<code class="fe nx ny nz mx b">axes</code>的属性，它是一个<code class="fe nx ny nz mx b">Axis.Set</code>。这实质上意味着您可以更改轴以包含<code class="fe nx ny nz mx b">.horizontal</code>、<code class="fe nx ny nz mx b">.vertical</code>或两者。这将改变您可以滚动的方向。</p><h2 id="f3c0" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">形式</h2><p id="0cff" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">Form</code>给你一个不像iOS设置菜单的界面。你可以将界面的各个部分分成<code class="fe nx ny nz mx b">Section</code>个部分，这样控件的外观会比在<code class="fe nx ny nz mx b">List</code>中更令人愉快。</p><h2 id="f8c1" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">组</h2><p id="9930" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#7373" rel="noopener">组(在2.0中更新)</a></p><p id="7a52" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">苹果公司简单地将此描述为:</p><blockquote class="pc"><p id="4ff8" class="pd pe iu bd pf pg ph pi pj pk pl le dk translated">"用于分组视图内容的启示."</p></blockquote><p id="1bb6" class="pw-post-body-paragraph kj kk iu kl b km pm jv ko kp pn jy kr ks po ku kv kw pp ky kz la pq lc ld le in bi translated">与<code class="fe nx ny nz mx b">VStack</code>或<code class="fe nx ny nz mx b">HStack</code>对布局的影响不同，<code class="fe nx ny nz mx b">Group</code>根本不会改变布局。相反，它允许你像对待一个孩子一样对待十个孩子。例如，一个<code class="fe nx ny nz mx b">VStack</code>只能有十个孩子，这就把你限制为十个<code class="fe nx ny nz mx b">View</code>。</p><p id="d89c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是如果这10个孩子都是<code class="fe nx ny nz mx b">Group</code> s，那么每个组可以有10个孩子，这样一个<code class="fe nx ny nz mx b">VStack</code>就可以显示100个<code class="fe nx ny nz mx b">View</code> s。</p><p id="20b4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它们被视为一个<code class="fe nx ny nz mx b">View</code>的事实也允许你将<code class="fe nx ny nz mx b">.foregroundColor(.red)</code>或<code class="fe nx ny nz mx b">.frame(width: 300)</code>这样的修饰符应用于整个组，而不是必须为每个<code class="fe nx ny nz mx b">View</code>设置这些修饰符或将<code class="fe nx ny nz mx b">View</code>放置在<code class="fe nx ny nz mx b">VStack</code>这样的布局中。</p><h2 id="8d90" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">分组框</h2><p id="0ba6" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#6348" rel="noopener">分组框(在2.0中更新)</a></p><p id="9c08" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">GroupBox</code>是带有可选标签的<code class="fe nx ny nz mx b">View</code>容器，仅在macOS上可用。</p><h2 id="2c75" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">部分</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pr"><img src="../Images/c322b6c7dd6ba3573b3add265de163c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3879acxQJOHdxqXmaj57qQ.png"/></div></div></figure><p id="432e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">上面的截图显示了一个分成三个<code class="fe nx ny nz mx b">Section</code>的<code class="fe nx ny nz mx b">Form</code></p><p id="4c37" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如你所看到的，<code class="fe nx ny nz mx b">Form</code>在三个<code class="fe nx ny nz mx b">Section</code>之间有间隙，可以看到更细的行显示更暗的背景色。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="e2b0" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">逆电流器</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj ps"><img src="../Images/7c9ac26f280a1c3fb7ff30acbd4a3679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iV9gBxyUO_laQP0f-kiFw.png"/></div></div></figure><p id="3357" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在上面的截图中，我已经展示了<code class="fe nx ny nz mx b">Rectangle</code>和<code class="fe nx ny nz mx b">Spacer</code>的异同。</p><p id="ede5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当<code class="fe nx ny nz mx b">rectangleShown</code>为真时，<code class="fe nx ny nz mx b">HStack</code>中的<code class="fe nx ny nz mx b">Text</code>被推到侧面，<code class="fe nx ny nz mx b">VStack</code>中的<code class="fe nx ny nz mx b">Text</code>被推到顶部和底部。<code class="fe nx ny nz mx b">Rectangle</code>实质上是调整其父<code class="fe nx ny nz mx b">HStack</code>的高度，以占据所有可用的垂直空间。</p><p id="bdcb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果将<code class="fe nx ny nz mx b">rectangleShown</code>设置为假，则<code class="fe nx ny nz mx b">Rectangle</code>将消失，但<code class="fe nx ny nz mx b">Text</code>不会移动。</p><p id="d70a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是因为最大尺寸为无穷大的<code class="fe nx ny nz mx b">Spacer</code>的行为方式与<code class="fe nx ny nz mx b">Rectangle</code>相同。它能够增加其父节点的大小，以占据所有可用空间。</p><p id="6d7b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是将<code class="fe nx ny nz mx b">spacerMaxSize</code>改为false，<code class="fe nx ny nz mx b">Spacer</code>将缩小到<code class="fe nx ny nz mx b">Text</code> s的高度，否则这就是<code class="fe nx ny nz mx b">HStack</code>高度的基础。</p><p id="2d8d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">HStack</code>中的<code class="fe nx ny nz mx b">Text</code>仍然被推到两侧，因为<code class="fe nx ny nz mx b">HStack</code>本身默认有一个无穷大的<code class="fe nx ny nz mx b">maxWidth</code>。</p><p id="58dc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">总之，<code class="fe nx ny nz mx b">Spacer</code>默认情况下只增长到其父级的大小，除非给它们一个无穷大的最大值，否则不会增加其父级的大小。</p><p id="eb46" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">默认情况下，像<code class="fe nx ny nz mx b">Rectangle</code> s这样的视图有一个无限的最大尺寸，并且会增加其父视图的尺寸，除非给它们一个与其父视图相等的最大尺寸。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="f5bf" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">圆规</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pt"><img src="../Images/57a97875993c8ffd36f58c58ca817c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmUnkBglbNqYJBAFJZ6a8w.png"/></div></div></figure><p id="2351" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个<code class="fe nx ny nz mx b">Divider</code>在布局中的<code class="fe nx ny nz mx b">View</code>之间放置一条线。在<code class="fe nx ny nz mx b">VStack</code>中，它们是水平线，而在<code class="fe nx ny nz mx b">HStack</code>中，它们是垂直线。</p><p id="17fd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">将<code class="fe nx ny nz mx b">Dividers</code>上的<code class="fe nx ny nz mx b">.background(Color.red</code>设置为红色分割线。否则，它们将根据当前选择的配色方案设置为默认值。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="418d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">选项卡视图</h2><p id="4434" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">另见:<a class="ae lw" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03#5eb5" rel="noopener"> TabView(在2.0中更新)</a></p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pu"><img src="../Images/748e54e31d506ad52f3b97677e641cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tzj2kbJbDBJJNFlMc3Y_ZQ.png"/></div></div></figure><p id="97f1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">上面的截图来自实现<a class="ae lw" href="https://developer.apple.com/documentation/swiftui/tabview" rel="noopener ugc nofollow" target="_blank">苹果的</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/tabview" rel="noopener ugc nofollow" target="_blank">TabView</a></code> <a class="ae lw" href="https://developer.apple.com/documentation/swiftui/tabview" rel="noopener ugc nofollow" target="_blank">的例子</a>。</p><p id="810a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我没有太多可以补充的了。</p><h2 id="dbd7" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">VSplitView和HSplitView</h2><p id="ba48" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">这些版本的<code class="fe nx ny nz mx b">VStack</code>和<code class="fe nx ny nz mx b">HStack</code>允许用户拖动分隔线来改变每个分割区域的大小。</p><p id="0727" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不出所料，<code class="fe nx ny nz mx b">VSplitView</code>将其子节点垂直排列，而<code class="fe nx ny nz mx b">HSplitView</code>则水平排列。这仅在macOS上可用，因此您不能在iOS或tvOS项目中使用它。</p><h2 id="dc84" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">警报</h2><p id="17ba" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">创建非常容易，但是它们并不像你想象的那样符合<code class="fe nx ny nz mx b">View</code>协议。您不能将类型为<code class="fe nx ny nz mx b">Alert</code>的值放在<code class="fe nx ny nz mx b">VStack</code>或您认为它可能显示的任何地方。</p><p id="9cb8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面，我提供了一个创建警报的三个主要场景的例子。请注意，我已经为前两个警报添加了操作，但这不是必需的。您可以在任何一个警报按钮上执行操作，也可以两个都执行，或者都不执行，这取决于您。</p><p id="e31c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<code class="fe nx ny nz mx b">alert1</code>中，您想要一个默认动作，在本例中称为“OK”，它确认您想要一个动作发生。这会将“您做了一些事情”打印到控制台。</p><p id="0060" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">旁边的按钮是一个取消按钮，这里使用默认的<code class="fe nx ny nz mx b">Alert.Button.cancel</code>创建，它自动提供预期的文本，当它被按下时不采取任何行动。</p><p id="b601" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">alert2</code>非常类似，按下时打印“你试图删除一些东西”到控制台。这里的区别在于按钮是<code class="fe nx ny nz mx b">Alert.Button.destructive</code>类型的，这意味着按钮将是红色的，以指示一个做出永久且潜在负面改变的动作。</p><p id="4c5d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">alert3</code>是最简单的一种警告，你可以有一个标题和可选的消息，但是只有一个按钮可以关闭<code class="fe nx ny nz mx b">Alert</code>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">Alert中断所有用户活动，用一个或两个选项按钮给出消息</p></figure><h2 id="b392" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">行动表</h2><p id="c13e" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">因为它们的工作方式完全相同，所以我用<code class="fe nx ny nz mx b">ActionSheets</code>重复了上面的<code class="fe nx ny nz mx b">Alert</code>的例子。</p><p id="886b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">主要的区别是它们有一系列的按钮，这意味着你可以添加任意数量的按钮。这与<code class="fe nx ny nz mx b">Alert</code>形成对比，后者只有一两个按钮的选项。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">ActionSheet类似于一个警告，但是可以显示无限数量的按钮</p></figure><h2 id="3100" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">空视图</h2><p id="0d8e" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">EmptyView</code>有一个相当描述性的名字。它是一个不占空间的隐形<code class="fe nx ny nz mx b">View</code>。</p><p id="83b9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面我举的例子，画出了<code class="fe nx ny nz mx b">EmptyView</code>和<code class="fe nx ny nz mx b">Spacer</code>的具体对比。<code class="fe nx ny nz mx b">Spacer</code>可以被给定一个特定的帧尺寸，并填充那个空间，而<code class="fe nx ny nz mx b">EmptyView</code>将忽略一个帧修改器。</p><p id="8484" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">默认情况下,<code class="fe nx ny nz mx b">Spacer</code>将填充所有可用空间，这就是为什么我必须在这个例子中将它的高度限制为20。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div><p class="ls lt gk gi gj lu lv bd b be z dk translated">一个<code class="fe nx ny nz mx b">EmptyView </code>也可以作为任何<code class="fe nx ny nz mx b">View</code>结构的主体返回</p></figure><p id="05a3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">也许<code class="fe nx ny nz mx b">EmptyView</code>最有用的方面之一是它可以作为任何<code class="fe nx ny nz mx b">View</code>结构的主体返回。这意味着您可以创建一个空的<code class="fe nx ny nz mx b">View</code>而不会出现错误，因为主体是空的。</p><h2 id="cbbe" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">等值视图</h2><p id="5e4d" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">SwiftUI实验室有<a class="ae lw" href="https://swiftui-lab.com/equatableview/" rel="noopener ugc nofollow" target="_blank">一个关于</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="https://swiftui-lab.com/equatableview/" rel="noopener ugc nofollow" target="_blank">EquatableView</a></code>的很棒的教程，比我能解释得更好。</p><h2 id="bdb1" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">任意视图</h2><p id="9598" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">由于<code class="fe nx ny nz mx b">View</code>是一个协议，您不能创建<code class="fe nx ny nz mx b">View</code>本身的实例。这意味着你不能创建一个<code class="fe nx ny nz mx b">[View]</code>类型的数组，但是你可以创建一个<code class="fe nx ny nz mx b">[AnyView]</code>类型的数组。</p><p id="a30d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面是一个类型为<code class="fe nx ny nz mx b">[AnyView]</code>的数组的例子，以及如何使用<code class="fe nx ny nz mx b">ForEach</code>显示其内容。你不能将数组本身传递给<code class="fe nx ny nz mx b">ForEach</code>的构造函数，因为<code class="fe nx ny nz mx b">AnyView</code>不符合<code class="fe nx ny nz mx b">Hashable</code>的要求。</p><p id="af1c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">相反，我创建了一个从第一个索引到最后一个索引的序列，并用这个索引作为内部数组的下标。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="523e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我还提供了一个用于打乱数组的<code class="fe nx ny nz mx b">Button</code>，只是为了向您展示一个<code class="fe nx ny nz mx b">AnyView</code>的底层类型并不重要。以前的一个<code class="fe nx ny nz mx b">Text</code>可以变成一个<code class="fe nx ny nz mx b">Image</code>，<code class="fe nx ny nz mx b">AnyView</code>只是重绘了内容。</p><h2 id="a3e8" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">TupleView</h2><p id="2faf" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果你不熟悉tuple，<a class="ae lw" href="https://docs.swift.org/swift-book/ReferenceManual/Types.html" rel="noopener ugc nofollow" target="_blank">下面是Swift语言文档中对tuple的解释</a>:</p><blockquote class="oa ob oc"><p id="54ad" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">“复合类型是没有名称的类型，在Swift语言中定义。有两种复合类型:函数类型和元组类型。</p><p id="1a2b" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">复合类型可以包含命名类型和其他复合类型。例如，元组类型<code class="fe nx ny nz mx b">(Int, (Int, Int))</code>包含两个元素。第一个是命名类型<code class="fe nx ny nz mx b">Int</code>，第二个是另一个复合类型<code class="fe nx ny nz mx b">(Int, Int)</code>。"</p></blockquote><p id="083f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在许多方面，<code class="fe nx ny nz mx b">tuple</code>就像一个没有花括号的结构体。如果结构具有未用默认值初始化的属性，则在创建该结构时，必须用括号将这些属性初始化。</p><p id="d3f1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是元组没有初始化器，所以那些括号被分配给一个带有等号的<code class="fe nx ny nz mx b">tuple</code>。与初始化结构属性不同，标签是可选的。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="503c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我提供了第二个例子，它创建了一种新的tuple <code class="fe nx ny nz mx b">twoTexts</code>，如果使用这两个值，它们的标签必须与原来的<code class="fe nx ny nz mx b">twoTexts</code>匹配。</p><p id="c723" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我没有将<code class="fe nx ny nz mx b">myTwoTexts</code>添加到<code class="fe nx ny nz mx b">ContentView</code>的<code class="fe nx ny nz mx b">body</code>中，主要是为了引起注意，尽管<code class="fe nx ny nz mx b">TupleView</code>显示来自几个<code class="fe nx ny nz mx b">View</code>的内容，但它并不需要使用<code class="fe nx ny nz mx b">VStack</code>。</p><p id="4758" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不能以这种方式创建混合类型的数组。您可以创建一个<code class="fe nx ny nz mx b">Text</code>或<code class="fe nx ny nz mx b">Image</code>的数组，但不能创建<code class="fe nx ny nz mx b">View</code>的数组，因为它有协议要求。创建一个混合类型的数组是推断出来的，因为你不能从<code class="fe nx ny nz mx b">Any</code>转换到<code class="fe nx ny nz mx b">View</code>、<code class="fe nx ny nz mx b">Text</code>或<code class="fe nx ny nz mx b">Image</code>。</p><p id="7ecd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有一种方法可以创建混合类型的数组，那就是使用<code class="fe nx ny nz mx b">AnyView</code>。</p><p id="7a74" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">向上滚动到上面的<code class="fe nx ny nz mx b">AnyView</code>,查看使用它的混合阵列示例。</p><p id="7c61" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">与我的大多数例子不同，我为我的<code class="fe nx ny nz mx b">TupleView</code>提供了<code class="fe nx ny nz mx b">ContentView_Previews</code>来展示它的样子。我使用了固定的尺寸，因为我们使用的是小的<code class="fe nx ny nz mx b">View</code>，这样更容易看到<code class="fe nx ny nz mx b">TupleView</code>在单独的预览中显示每个<code class="fe nx ny nz mx b">View</code>。</p><p id="7645" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于普通的<code class="fe nx ny nz mx b">View</code>,你需要创建一个<code class="fe nx ny nz mx b">Group</code>,并指定你想在单独的预览中出现的<code class="fe nx ny nz mx b">View</code>。关于预览的更多信息，请看我在这篇文章末尾写的关于<a class="ae lw" href="#8932" rel="noopener ugc nofollow"/><code class="fe nx ny nz mx b"><a class="ae lw" href="#8932" rel="noopener ugc nofollow">PreviewProvider</a></code><a class="ae lw" href="#8932" rel="noopener ugc nofollow">协议</a>的内容。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a181" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/drawing_and_animation" rel="noopener ugc nofollow" target="_blank">绘图和动画</a></h1><h2 id="789a" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">动画</h2><p id="391c" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">这里有一个使用默认类型<code class="fe nx ny nz mx b">Animation</code>的例子。要使用它们，只需修改你的<code class="fe nx ny nz mx b">View</code>并使用<code class="fe nx ny nz mx b">.animation(.spring())</code>修改器添加一个动画。</p><p id="67d9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您想具体了解想要执行的更改，请参见<code class="fe nx ny nz mx b"><a class="ae lw" href="#0817" rel="noopener ugc nofollow">withAnimation</a></code>。如果您制作一个带有自定义属性的自定义形状，您需要将它们指定为<code class="fe nx ny nz mx b">animatableData</code>(见下文)。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="1582" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">动画和动画数据</h2><p id="ee51" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">Animatable</code>是一个协议，用于告诉SwiftUI如何激活您的自定义<code class="fe nx ny nz mx b">Shape</code>。</p><p id="c16a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">无需显式声明struct符合协议，您可以通过声明一个名为<code class="fe nx ny nz mx b">animatableData</code>的属性来符合协议，该属性告诉SwiftUI您可以制作什么动画。</p><p id="64c0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我的例子中，我已经创建了一个<code class="fe nx ny nz mx b">Square</code>形状，因为<code class="fe nx ny nz mx b">Rectangle</code>已经存在，而<code class="fe nx ny nz mx b">Square</code>不存在。</p><p id="fb0f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">符合<code class="fe nx ny nz mx b">Shape</code>要求您的形状有一个名为<code class="fe nx ny nz mx b">path(in:)</code>的函数，它基本上接受您的形状的框架矩形，并要求您生成一个SwiftUI可以用来绘制形状的<code class="fe nx ny nz mx b">Path</code>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="dc72" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我所做的就是决定哪个长度更短，宽度还是高度。在纵向模式的iPhone上，这是宽度。</p><p id="0ccf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我绘制路径时，我使形状在两个方向上都等于这个较短的长度，而不是使用<code class="fe nx ny nz mx b">rect.maxX</code>或<code class="fe nx ny nz mx b">rect.maxY</code>将正方形拉伸到提供的矩形空间中。</p><p id="e6a8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在Y方向上，我还应用了一个偏移量，这样正方形就可以从屏幕中心的起始位置上下移动。</p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div class="gi gj pv"><img src="../Images/65fe52820feef79f09e95221616f31a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/1*MQbqAFlYz8J_uqplDYIHkw.gif"/></div></figure><p id="39f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">重要的部分是我提供了一个名为<code class="fe nx ny nz mx b">animatableData</code>的变量，通过getter和setter提供对<code class="fe nx ny nz mx b">offset</code>变量的访问。</p><p id="f9e9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">Stepper</code>的步长为25，这意味着每当数字改变时，它们将<code class="fe nx ny nz mx b">Square</code>移动25。为什么这很重要？这是一个足够大的变化，如果没有动画，这将是一个不和谐的运动。</p><p id="548d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">尝试禁用动画，你会明白我的意思。</p><p id="10f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你对我使用的<code class="fe nx ny nz mx b">GeometryReader</code>感到困惑，你可以在这篇文章中找到我的<a class="ae lw" href="#fa47" rel="noopener ugc nofollow">定义。</a></p><h2 id="982c" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">动画对</h2><p id="c768" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">AnimatablePair</code>与上面提到的<code class="fe nx ny nz mx b">Animatable</code>协议有关，这里就不重复基本了。<code class="fe nx ny nz mx b">AnimatablePair</code>允许你将两个<code class="fe nx ny nz mx b">animatableData</code>浓缩成一个值。真的就这么简单。</p><p id="c5ce" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是上面的<code class="fe nx ny nz mx b">Animatable</code>示例的一个版本，它允许<code class="fe nx ny nz mx b">Square</code>同时拥有一个<code class="fe nx ny nz mx b">xOffset</code>和一个<code class="fe nx ny nz mx b">yOffset</code>:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="db6e" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">EmptyAnimatableData</h2><p id="d608" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">在上面的<code class="fe nx ny nz mx b">AnimatablePair</code>和<code class="fe nx ny nz mx b">AnimatableData</code>示例中，我明确告知SwiftUI我希望在我的自定义形状中显示哪些属性。</p><p id="18b9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">由于<code class="fe nx ny nz mx b">Shape</code>本身符合<code class="fe nx ny nz mx b">Animatable</code>协议，所以默认实现被继承。默认实现所做的只是创建一个设置为类型<code class="fe nx ny nz mx b">EmptyAnimatableData</code>的<code class="fe nx ny nz mx b">animatableData</code>属性。</p><p id="8b7b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这允许<code class="fe nx ny nz mx b">Shape</code>的孩子遵守<code class="fe nx ny nz mx b">Animatable</code>协议，而无需实际设置他们的<code class="fe nx ny nz mx b">animatableData</code>。</p><p id="090a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果他们想覆盖这个值，他们可以，就像我在上面的例子中所做的那样。</p><h2 id="11ee" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">动画修改器</h2><p id="00c6" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">AnimatableModifier</code>允许您生成一个带有动画的修改视图。</p><p id="efb1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我已经制作了上一节中关于<code class="fe nx ny nz mx b">Animatable</code>协议的例子的一个版本，它使用了<code class="fe nx ny nz mx b">AnimatableModifier</code>协议。在现有的例子中，我有一个步进器，每次将一个方块上下移动25 °,一边移动一边制作动画。</p><p id="09a3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这个新版本中，我使用蓝色的<code class="fe nx ny nz mx b">Rectangle</code>填充整个屏幕，并应用<code class="fe nx ny nz mx b">AnimatableSquare</code>修改器。</p><p id="a860" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意，我使用了一个<code class="fe nx ny nz mx b">View</code>扩展来避免使用定制修饰符通常需要的笨拙的<code class="fe nx ny nz mx b">.modifier(SquareAnimatable(offset: offset))</code>语法。</p><p id="fc7c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">SquareAnimatable</code>修改器添加一个红色的<code class="fe nx ny nz mx b">Square</code>作为任何<code class="fe nx ny nz mx b">View</code>的覆盖。该覆盖图从创建它的<code class="fe nx ny nz mx b">View</code>中获取它的<code class="fe nx ny nz mx b">offset</code>值，这意味着父<code class="fe nx ny nz mx b">View</code>可以更改该值，而<code class="fe nx ny nz mx b">SquareAnimatable</code>将移动方块并动画显示该更改。</p><p id="7a41" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">本例中的<code class="fe nx ny nz mx b">Square</code>形状实际上是在<code class="fe nx ny nz mx b">SquareAnimatable</code>修饰符的范围内声明的，这意味着带有传递给它的偏移值的<code class="fe nx ny nz mx b">Stepper</code>的父<code class="fe nx ny nz mx b">View</code>甚至不知道如何使它控制的<code class="fe nx ny nz mx b">Square</code>！</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="67ce" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我最初这样做的时候，我把偏移量作为一个<code class="fe nx ny nz mx b">@Binding</code>传递给它。</p><p id="19fa" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不要这样！</p><p id="b297" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">animatableData</code>中的setter试图设置传递的值，您会得到一个运行时警告:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="6386" class="nb mf iu mx b gz nc nd l ne nf">Modifying state during view update, this will cause undefined behavior</span></pre><p id="cfa9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">用Swift 破解解释了为什么<code class="fe nx ny nz mx b">State</code>变量不应该在<code class="fe nx ny nz mx b">View</code>的主体中被改变。</p><p id="c672" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">本质上，问题是当<code class="fe nx ny nz mx b">View</code>正在创建的时候，我们试图改变初始的<code class="fe nx ny nz mx b">@State</code>属性<em class="lf">偏移量</em>。如果是个<code class="fe nx ny nz mx b">Button</code>就不成问题了。</p><h2 id="0817" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">带动画(隐式动画)</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div class="gi gj pv"><img src="../Images/f0c56ceb03a9f8b16a3486f39de29164.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/1*aqfuzT8HSPagTjJ81kqKsQ.gif"/></div></figure><p id="8064" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">将动画放入SwiftUI <code class="fe nx ny nz mx b">View</code>的一个简单方法是将代码放在一个<code class="fe nx ny nz mx b">withAnimation</code>块中。</p><p id="791b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这类似于<code class="fe nx ny nz mx b">UIKit</code>中<code class="fe nx ny nz mx b">UIView.animate(withDuration:Animations:)</code>所用的模块，但默认情况下不需要持续时间。</p><p id="8f6f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您可以传入一个<code class="fe nx ny nz mx b">Animation</code>对象，比如<code class="fe nx ny nz mx b">withAnimation(.linear(duration: 5))</code>，以便更好地控制动画的外观。你甚至可以选择是否将一个持续时间传递给<code class="fe nx ny nz mx b">.linear</code>。</p><p id="b0a0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">关于<code class="fe nx ny nz mx b">Animation</code>的更多细节，请参见本节开头的的<a class="ae lw" href="#789a" rel="noopener ugc nofollow">定义。</a></p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="0c2c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">请注意，在这种情况下，将<code class="fe nx ny nz mx b">.animation(.default)</code>修改器添加到<code class="fe nx ny nz mx b">Rectangle</code>会产生相同的效果，尽管有必要指出不同之处。</p><p id="57d2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">.animation(.default)</code>修改器是隐式动画的一个例子。你基本上是在说我们希望对<code class="fe nx ny nz mx b">Rectangle</code>的任何改变都是动画的。</p><p id="7823" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这意味着，如果我们添加另一个增加宽度的<code class="fe nx ny nz mx b">Button</code>，即使我们没有将这些变化指定为<code class="fe nx ny nz mx b">withAnimation</code>，它也会被动画化。</p><p id="6501" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你想完全控制<code class="fe nx ny nz mx b">View</code>的哪些方面可以被动画化，你需要明确地指定哪些值的变化应该使用<code class="fe nx ny nz mx b">withAnimation</code>来动画化。</p><h2 id="99be" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">任何转换</h2><p id="3c62" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">这类似于<code class="fe nx ny nz mx b">AnyView</code>，它允许你把一个视图当作一个通用的和不透明的返回类型。</p><p id="f5f4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当组合多个过渡时，可以使用<code class="fe nx ny nz mx b">combined</code>方法将过渡加在一起。您也可以添加一个<code class="fe nx ny nz mx b">Animation</code>到一个过渡，其结果是一个<code class="fe nx ny nz mx b">AnyTransition</code>对象。</p><h2 id="6673" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">不可镶嵌形状</h2><p id="97ef" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">strokeBorder</code>允许您绘制切入形状区域的边界，要求<code class="fe nx ny nz mx b">Shape</code>符合<code class="fe nx ny nz mx b">InsettableShape</code>协议。</p><p id="830a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">更多信息请参见本【Swift黑客教程。</p><h2 id="90a3" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">填充样式</h2><p id="edc6" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">FillStyle</code>只有两个选项，都是布尔型。</p><p id="b40f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">奇偶规则与SwiftUI如何决定路径的哪些部分应该被填充有关。引用<a class="ae lw" href="https://www.w3.org/TR/SVG/painting.html#WindingRule" rel="noopener ugc nofollow" target="_blank">SVG</a>的规范:</p><blockquote class="oa ob oc"><p id="915d" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">该规则确定画布上一个点的“内部性”,方法是从该点向任意方向画一条射线到无限远，并计算该射线穿过的给定形状的路径段数。</p><p id="24d5" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">如果这个数是奇数，则点在里面；如果扯平，重点在外面。"</p></blockquote><p id="85de" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">实际上，这会导致带有扭曲填充的形状自身重叠，从而在重叠部分没有填充。在SVG规范中有这种效果的例子，关于奇偶规则的维基百科页面也有。</p><p id="7f0c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果对<code class="fe nx ny nz mx b">isEOFilled</code>参数使用false，则使用非零方法。这确保了所有封闭的空间都被填满，而不仅仅是那些没有重叠的空间。</p><p id="173a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">抗锯齿是平滑锯齿状边缘或“<a class="ae lw" href="https://en.wikipedia.org/wiki/Jaggies" rel="noopener ugc nofollow" target="_blank">锯齿</a>”的过程。当分辨率较低时，锯齿是由光栅图像由方形像素网格组成这一事实造成的。</p><p id="a04a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">尽管水平直线和垂直直线可以以低分辨率呈现而没有锯齿，但是由于试图用正方形像素的网格来表示不垂直于其中一个轴的直线的“阶梯效应”,与这些轴的任何角度差异都会导致出现锯齿。</p><p id="87b4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您对<code class="fe nx ny nz mx b">isAntialiased</code>参数使用true，一些模糊量用于柔化锯齿。否则，将会出现锯齿。</p><h2 id="c10c" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">ShapeStyle</h2><p id="96fa" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">ShapeStyle</code>用于从<code class="fe nx ny nz mx b">Shape</code> s创建<code class="fe nx ny nz mx b">View</code> s。背景修饰符，令人惊讶的是目前还没有文档，声明如下:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="9b33" class="nb mf iu mx b gz nc nd l ne nf">extension View {</span><span id="14d3" class="nb mf iu mx b gz ng nd l ne nf">@inlinable public func background&lt;Background&gt;(_ background: Background, alignment: Alignment = .center) -&gt; some View where Background : View</span><span id="a89f" class="nb mf iu mx b gz ng nd l ne nf">}</span></pre><p id="befb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因为一个<code class="fe nx ny nz mx b">Color</code>不是一个<code class="fe nx ny nz mx b">View</code>，你可以把它传递给这个需要一个<code class="fe nx ny nz mx b">View</code>的函数，这可能会令人惊讶。</p><p id="9194" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">事实上，您可能会惊讶地发现，您可以创建一个只有一个<code class="fe nx ny nz mx b">Color</code>作为主体的<code class="fe nx ny nz mx b">View</code>，尽管<code class="fe nx ny nz mx b">Color</code>并不直接符合<code class="fe nx ny nz mx b">View</code>协议。</p><p id="a752" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">而是<code class="fe nx ny nz mx b">Color</code>符合<code class="fe nx ny nz mx b">ShapeStyle</code>，而<code class="fe nx ny nz mx b">ShapeStyle</code>符合<code class="fe nx ny nz mx b">View</code>本身。</p><p id="de09" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">似乎正在发生的是用<code class="fe nx ny nz mx b">Color</code>创建一个<code class="fe nx ny nz mx b">Rectangle</code>，根据<code class="fe nx ny nz mx b">ShapeStyle</code>的默认实现填充它:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="339b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">ImagePaint</code>、<code class="fe nx ny nz mx b">Border</code>、<code class="fe nx ny nz mx b">Stroke</code>、<code class="fe nx ny nz mx b">Fill</code>、<code class="fe nx ny nz mx b">Gradients</code>似乎都以某种方式使用<code class="fe nx ny nz mx b">ShapeStyle</code>来创造前景和背景。</p><h2 id="176d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">几何效应</h2><p id="dded" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">GeometryEffect</code>允许你创建自定义动画，其中许多动画会产生类似于所提供的<code class="fe nx ny nz mx b">rotation3DEffect</code>修改器的3D效果。</p><p id="d863" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lw" href="https://swiftui-lab.com/swiftui-animations-part2/" rel="noopener ugc nofollow" target="_blank"> SwiftUI实验室有一个关于使用GeometryEffect的很棒的教程</a>。</p><h2 id="b383" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">角</h2><p id="6281" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">您可以创建带有度数或弧度的<code class="fe nx ny nz mx b">Angle</code>，这两者都需要成为<code class="fe nx ny nz mx b">Double</code>。</p><p id="f981" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦创建，您的<code class="fe nx ny nz mx b">Angle</code>的角度或弧度可以作为属性访问。<code class="fe nx ny nz mx b">Angles</code>用于制作<code class="fe nx ny nz mx b">RadialGradients</code>，给<code class="fe nx ny nz mx b">Paths</code>加弧，用于<code class="fe nx ny nz mx b">RotationEffect</code>和<code class="fe nx ny nz mx b">RotationGesture</code>。</p><h2 id="9134" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">边缘和边缘嵌入</h2><p id="7b0f" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">Edge</code>是包含值<code class="fe nx ny nz mx b">.bottom</code>、<code class="fe nx ny nz mx b">.leading</code>、<code class="fe nx ny nz mx b">.top</code>和<code class="fe nx ny nz mx b">.trailing</code>的枚举。它似乎只用在两个修饰语:<code class="fe nx ny nz mx b">.edgesIgnoringSafeAreas</code>和<code class="fe nx ny nz mx b">.padding</code>。</p><p id="8dab" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">EdgeInsets</code>用在类似<code class="fe nx ny nz mx b">.listRowInsets</code>和<code class="fe nx ny nz mx b">.resizable</code>修饰符的地方。</p><h2 id="4dd2" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">矩形、圆形矩形、圆形、椭圆形和胶囊形</h2><p id="33c3" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">您可以轻松创建这些形状，因为它们在SwiftUI中以<code class="fe nx ny nz mx b">Views</code>的形式提供。下图显示了它们之间的区别。</p><p id="a084" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">Circle</code>似乎是唯一一个锁定其长宽比的，所以即使给它一个宽度大于高度的框架(如我在下面的代码中所做的那样)也不会像拉伸<code class="fe nx ny nz mx b">Ellipse</code>一样拉伸<code class="fe nx ny nz mx b">Circle</code>。</p><p id="da40" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">没有叫做<code class="fe nx ny nz mx b">Square</code>的对等物，所以你只能用一个<code class="fe nx ny nz mx b">Rectangle</code>创建一个正方形，并赋予它相等的宽度和高度。</p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pw"><img src="../Images/417695d5a27d24499f3eeb2642a10b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IC5jsGNnxBOMm0PgJRPQQ.png"/></div></div></figure><p id="a014" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">希望并排比较能显示出<code class="fe nx ny nz mx b">Capsule</code>与<code class="fe nx ny nz mx b">RoundedRectangle</code>的不同之处。我给<code class="fe nx ny nz mx b">RoundedRectangle</code>提供了一个15的<code class="fe nx ny nz mx b">cornerRadius</code>，这就是为什么它有一个可见的顶部边缘。</p><p id="7474" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果我将<code class="fe nx ny nz mx b">RoundedRectangle</code>的<code class="fe nx ny nz mx b">cornerRadius</code>设置为其宽度的50%，在本例中为50，它的外观与<code class="fe nx ny nz mx b">Capsule</code>几乎没有区别。</p><p id="a30a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">总之，<code class="fe nx ny nz mx b">Capsule</code>就像是<code class="fe nx ny nz mx b">RoundedRectangle</code>的<code class="fe nx ny nz mx b">cornerRadius</code>总是等于其宽度的50%。</p><p id="5885" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个<code class="fe nx ny nz mx b">Rectangle</code>也与一个<code class="fe nx ny nz mx b">RoundedRectangle</code>相同，带有一个<code class="fe nx ny nz mx b">0</code>的<code class="fe nx ny nz mx b">cornerRadius</code>。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="e425" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">小路</h2><p id="b3e1" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">重复我在<code class="fe nx ny nz mx b">Animatable</code>和<code class="fe nx ny nz mx b">AnimatableData</code>部分说过的话:</p><blockquote class="oa ob oc"><p id="b2dc" class="kj kk lf kl b km kn jv ko kp kq jy kr od kt ku kv oe kx ky kz of lb lc ld le in bi translated">“符合<code class="fe nx ny nz mx b"><em class="iu">Shape</em></code>要求您的形状有一个名为<code class="fe nx ny nz mx b"><em class="iu">path(in:)</em></code>的函数，它基本上接受您的形状的框架矩形，并要求您生成一个<code class="fe nx ny nz mx b"><em class="iu">Path</em></code>，SwiftUI可以使用它来绘制形状。”</p></blockquote><p id="7815" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">苹果教程<a class="ae lw" href="https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes" rel="noopener ugc nofollow" target="_blank"> <em class="lf">绘制路径和形状</em> </a>直接在a <code class="fe nx ny nz mx b">View</code>的body属性中使用路径，不符合<code class="fe nx ny nz mx b">Shape</code>。</p><h2 id="83d6" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">ScaledShape、RotatedShape和OffsetShape</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pr"><img src="../Images/ca6c3c725acfa392091ee0ee1bfd5feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qB719VTn-40CMUgol21UWg.png"/></div></div></figure><p id="bc7d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些转换后的<code class="fe nx ny nz mx b">Shapes</code>非常容易使用，因为它们只需要您传入一个<code class="fe nx ny nz mx b">Shape</code>和必要的转换参数。</p><p id="5738" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于我的缩放后的<code class="fe nx ny nz mx b">Rectangle</code>，我在两个方向上都缩放了0.5。一个<code class="fe nx ny nz mx b">Rectangle</code>通常会占据所有的可用空间，所以很明显这个相对较小，并且位于<code class="fe nx ny nz mx b">VStack</code>的上三分之一的中心。</p><p id="b56d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">旋转和偏移的矩形必须使用它们的框架按比例缩小，否则它们会与其他矩形重叠。</p><p id="aa65" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这张截图是在光线模式下拍摄的，所以默认<code class="fe nx ny nz mx b">foregroundColor</code>是黑色的。我把前两个叠加的<code class="fe nx ny nz mx b">Text</code>改成了白色，但是需要注意的是这在黑暗模式下不起作用。</p><p id="57db" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在黑暗模式下，<code class="fe nx ny nz mx b">Rectangle</code> s将采用默认的白色<code class="fe nx ny nz mx b">foregroundColor</code>。因此，该文本将被隐藏，而偏移<code class="fe nx ny nz mx b">Rectangle</code>的<code class="fe nx ny nz mx b">Text</code>将被默认的黑色背景隐藏。</p><p id="9d78" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在SwiftUI中使用默认背景色和前景色时，请始终考虑明暗模式。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="fdba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我把<code class="fe nx ny nz mx b">OffsetShape</code>的例子放在一个<code class="fe nx ny nz mx b">Group</code>中，它自己的固定高度是200。</p><p id="7697" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是因为偏移一个形状并不会增加分配给它的空间大小，所以尽管由于<code class="fe nx ny nz mx b">OffsetShape</code>的高度，分配的空间会是100，但将其向右下方移动只会将<code class="fe nx ny nz mx b">OffsetShape</code>移出屏幕底部。</p><p id="15b2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">RotatedShape</code>同样，不增加分配的空间来说明轮换。</p><p id="4fa3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">请注意，覆盖的<code class="fe nx ny nz mx b">Text</code>不会与<code class="fe nx ny nz mx b">OffsetShape</code>偏移，从而在<code class="fe nx ny nz mx b">Text</code>应该在<code class="fe nx ny nz mx b">OffsetShape</code>的地方留下了一个有趣的效果。</p><h2 id="5a4d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">变形形状</h2><p id="88c9" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">一个<code class="fe nx ny nz mx b">TransformedShape</code>类似于上面的<code class="fe nx ny nz mx b"><a class="ae lw" href="#83d6" rel="noopener ugc nofollow">ScaledShape</a></code> <a class="ae lw" href="#83d6" rel="noopener ugc nofollow">、</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="#83d6" rel="noopener ugc nofollow">RotatedShape</a></code> <a class="ae lw" href="#83d6" rel="noopener ugc nofollow">和</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="#83d6" rel="noopener ugc nofollow">OffsetShape</a></code> <a class="ae lw" href="#83d6" rel="noopener ugc nofollow">例子，除了它在它的初始化式中接受一个<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform" rel="noopener ugc nofollow" target="_blank">CGAffineTransform</a></code>的单个参数。</a></p><p id="8f0c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">核心图形仿射变换将变换表示为3 x 3矩阵，这意味着它可以在单个实例中表示许多变换。由于一个3 x 3矩阵总是在最右边的列中有[0，0，1]，所以这里所做的所有更改都在前两列中。</p><p id="7dd8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你不知道矩阵乘法是如何工作的，那就去看看这个有趣的网站。</p><p id="596a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">虽然您可以在初始化时或稍后通过调整各个位置<em class="lf"> a </em>、<em class="lf"> b </em>、<em class="lf"> c </em>、<em class="lf"> d </em>、<em class="lf"> t </em> ₓ和<em class="lf"> t </em> ᵧ的属性来使用<code class="fe nx ny nz mx b">GAffineTransform</code>类构建矩阵，但是使用该类最简单的方法是使用Apple提供的构造函数和实例方法。</p><p id="576a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我的例子中，我使用接受翻译的构造函数来尝试将<code class="fe nx ny nz mx b">Rectangle</code>放在屏幕中央。然后我将它缩放并旋转45度。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="7636" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">请注意，您需要将实例方法的结果赋给变量本身，这就是我使用笨拙的语法<code class="fe nx ny nz mx b">affineTransform = affineTransform.scaledBy(x: 0.4, y: 0.4)</code>的原因。</p><p id="b6d8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我最初假设直接调用该方法是可行的，因为Xcode不会以通常的方式警告您:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="137e" class="nb mf iu mx b gz nc nd l ne nf">Result of call to scaledBy(x:y:) is unused</span></pre><p id="9f8d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不要把这个警告的缺失当作证据，证明它被赋值给你像我一样调用它的变量！</p><h2 id="690f" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">颜色</h2><p id="90ff" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">SwiftUI有自己的<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/color" rel="noopener ugc nofollow" target="_blank">Color</a></code>类，是跨平台的，这意味着它可以在macOS、tvOS、iOS和watchOS上工作。这与只在macOS上运行的<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/appkit/nscolor" rel="noopener ugc nofollow" target="_blank">NSColor</a></code>和基本上在其他地方都能运行的<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uicolor" rel="noopener ugc nofollow" target="_blank">UIColor</a></code>形成了对比。</p><p id="7b39" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">SwiftUI中的<code class="fe nx ny nz mx b">Color</code>可以使用<code class="fe nx ny nz mx b">NSColor</code>、<code class="fe nx ny nz mx b">UIColor</code>、红/绿/蓝(RGB)、色调/饱和度/亮度(HSL)或白色/不透明度进行初始化。</p><p id="f87f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些初始化器的一个重要区别是<code class="fe nx ny nz mx b">Color</code>将透明度参数标记为“不透明度”,而不是其他颜色类中的“alpha”。</p><p id="4af4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">与<code class="fe nx ny nz mx b">UIColor</code>不同，<code class="fe nx ny nz mx b">Color</code>不能从<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/coregraphics/cgcolor" rel="noopener ugc nofollow" target="_blank">CGColor</a></code>或<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/coreimage/cicolor" rel="noopener ugc nofollow" target="_blank">CIColor</a></code>初始化。要使用它们，只需将它们传递给<code class="fe nx ny nz mx b">NSColor</code>(在macOS上)或<code class="fe nx ny nz mx b">UIColor</code>(其他地方)的初始化器，并将结果传递给<code class="fe nx ny nz mx b">Color</code>的初始化器。</p><p id="7c93" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在下面的例子中，我在SwiftUI中显示了三种颜色，或者至少，如果SwiftUI允许的话，我会这样做:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="0d4c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如您所见，虽然我可以使用相同的变量构造<code class="fe nx ny nz mx b">CGColor</code>、<code class="fe nx ny nz mx b">UIColor</code>和<code class="fe nx ny nz mx b">Color</code>，但是如果要在我的<code class="fe nx ny nz mx b">View</code>中使用它们，我必须将前两个变量转换为<code class="fe nx ny nz mx b">Color</code>。</p><p id="f47f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您可能还注意到<code class="fe nx ny nz mx b">Color</code>要求这些变量的类型是<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swift/double" rel="noopener ugc nofollow" target="_blank">Double</a></code>，而不是<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/coregraphics/cgfloat" rel="noopener ugc nofollow" target="_blank">CGFloat</a></code>。</p><p id="6b13" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这似乎标志着核心图形浮动结束的开始，但是SwiftUI仍然到处使用它，也许最显著的是设置<code class="fe nx ny nz mx b">View</code>框架的宽度和高度。</p><p id="a95d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">也许有一天，SwiftUI会要求一个<code class="fe nx ny nz mx b">Double</code>来设置一个<code class="fe nx ny nz mx b">View</code>的框架，那一定会标志着一个转折点。</p><h2 id="c123" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">图像绘画</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div class="gi gj pv"><img src="../Images/84725db00b5cc8985633d8ff3e0f5e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/1*GojjY2_2cxxnIKfhDOrTbA.gif"/></div></figure><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="3ba2" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">梯度(线性/角度/径向)</h2><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj pr"><img src="../Images/092e62ee229c44b51d5d4bf13e78a992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnO-opiIILMkH127k-KSjQ.png"/></div></div></figure><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="fa47" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">几何阅读器和几何代理</h2><p id="ccea" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">GeometryReader</code>允许您在屏幕上捕捉<code class="fe nx ny nz mx b">View</code>的几何图形。</p><p id="876f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在上面的例子中，包含整个<code class="fe nx ny nz mx b">View</code>的<code class="fe nx ny nz mx b">ZStack</code>本身嵌入在一个<code class="fe nx ny nz mx b">GeometryReader</code>中，这个闭包不影响布局，但是需要传入一个参数。</p><p id="37c9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lw" href="https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes" rel="noopener ugc nofollow" target="_blank">苹果的教程</a>把这个论点叫做<em class="lf">几何</em>，所以我在我的例子里也是这么做的。被传入的对象是一个<code class="fe nx ny nz mx b">GeometryProxy</code>，它给了我们两个属性和一个方法。</p><p id="9c07" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">方法<code class="fe nx ny nz mx b">frame(in:)</code>允许您传入<code class="fe nx ny nz mx b">CoordinateSpace.local</code>或<code class="fe nx ny nz mx b">CoordinateSpace.global</code>来获取相对于直接父级(局部)或相对于最高级别父级(全局)的帧。</p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj px"><img src="../Images/d71bf828c39ea7a5af72a3618923619c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7GQ-ITMq2UoEDHAiWz2xQ.png"/></div></div></figure><p id="232a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个例子展示了在iPhone 11 Pro Max上使用的两个<code class="fe nx ny nz mx b">GeometryReader</code>。绿色区域是一个<code class="fe nx ny nz mx b">VStack</code>，它是<code class="fe nx ny nz mx b">View</code>的第一个父对象。</p><p id="81a1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">传递到<code class="fe nx ny nz mx b">GeometryReader</code>闭包的<code class="fe nx ny nz mx b">GeometryProxy</code>显示第一个父元素在顶部有44个安全区域insets，在底部有34个。顶部是为了避免将视图放在槽口下面。</p><p id="18b1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在iPhone 8和其他仍然有home键的设备上，顶部安全区域的大小为20，以避开状态栏。</p><p id="1250" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">只有没有home键的iPhones才有34的底部安全区域，这允许用户向上滑动以回家和切换应用程序。</p><p id="f459" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">要忽略任何视图的安全区域，使用<code class="fe nx ny nz mx b">.edgesIgnoringSafeArea(.all)</code>修改器。其他选项有<code class="fe nx ny nz mx b">.bottom</code>、<code class="fe nx ny nz mx b">.leading</code>、<code class="fe nx ny nz mx b">.top</code>和<code class="fe nx ny nz mx b">.trailing.</code></p><p id="0e9e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有关这些选项的更多信息，请参见<a class="ae lw" href="#9134" rel="noopener ugc nofollow">边缘</a>。</p><p id="afe2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">值得注意的是，在大多数情况下，大小似乎是相同的。在全局和局部范围内，父<code class="fe nx ny nz mx b">VStack</code>和较小的红色<code class="fe nx ny nz mx b">VStack</code>都具有静态大小。</p><p id="ba94" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它们的不同之处在于它们的<code class="fe nx ny nz mx b">minX</code>和<code class="fe nx ny nz mx b">minY</code>值。当我第一次把小红<code class="fe nx ny nz mx b">VStack</code>放在一个<code class="fe nx ny nz mx b">HStack</code>里面的时候，全局空间中的<code class="fe nx ny nz mx b">minX</code>值没有变化。</p><p id="88b2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">只有当我插入一个<code class="fe nx ny nz mx b">Spacer</code>时，<code class="fe nx ny nz mx b">VStack</code>才右移八位，造成全局位置<code class="fe nx ny nz mx b">minX</code>和<code class="fe nx ny nz mx b">minY</code>不一样的情况。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="7513" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">坐标空间</h2><p id="ec28" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">坐标空间在上文部分的<code class="fe nx ny nz mx b"><a class="ae lw" href="#fa47" rel="noopener ugc nofollow">GeometryReader</a></code> <a class="ae lw" href="#fa47" rel="noopener ugc nofollow">和</a> <code class="fe nx ny nz mx b"><a class="ae lw" href="#fa47" rel="noopener ugc nofollow">GeometryProxy</a></code> <a class="ae lw" href="#fa47" rel="noopener ugc nofollow">中有更详细的介绍。</a></p><p id="c429" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">主要的区别是<code class="fe nx ny nz mx b">View</code>的本地原点是(0，0)，但是由于它在屏幕上的位置<code class="fe nx ny nz mx b">View</code>的全局位置可能与此不同。</p><p id="5493" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">CoordinateSpace</code>是在使用<code class="fe nx ny nz mx b">GeometryProxy</code>对象的<code class="fe nx ny nz mx b">frame(in:)</code>函数时提供<code class="fe nx ny nz mx b">.local</code>和<code class="fe nx ny nz mx b">.global</code>选项的枚举。</p><p id="4caf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">唯一使用enum的地方是在<code class="fe nx ny nz mx b">DragGesture</code>。<code class="fe nx ny nz mx b">DragGesture</code>的初始化器可以接受一个参数<code class="fe nx ny nz mx b">minimumDistance</code>，这是在采取行动之前需要的移动，以及一个<code class="fe nx ny nz mx b">coordinateSpace</code>枚举的实例。</p><p id="bb67" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有了这个<code class="fe nx ny nz mx b">coordinateSpace</code>设置，传入手势的<code class="fe nx ny nz mx b">onChanged</code>闭包的<code class="fe nx ny nz mx b">Value</code>结构将在其<code class="fe nx ny nz mx b">startLocation</code>和<code class="fe nx ny nz mx b">location</code> <code class="fe nx ny nz mx b">CGPoint</code>属性中给出相对或通用坐标。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a6d5" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/framework_integration" rel="noopener ugc nofollow" target="_blank">框架整合</a></h1><h2 id="17b6" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">UIHostingController</h2><p id="3dc3" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果你在Xcode中创建新的SwiftUI项目，并转到<code class="fe nx ny nz mx b">SceneDelegate</code> Swift文件，你会注意到最上面的函数叫做<code class="fe nx ny nz mx b">func scene(_ :, willConnectTo:, options:)</code>，它包含初始化<code class="fe nx ny nz mx b">ContentView</code>结构实例的代码。</p><p id="651c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，该函数获取当前的<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiwindowscene" rel="noopener ugc nofollow" target="_blank">UIWindowScene</a></code>，它基本上是在iPad 上使用多个窗口的<a class="ae lw" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/supporting_multiple_windows_on_ipad" rel="noopener ugc nofollow" target="_blank">的管理器。如果你有一部iPhone，多窗口是不可能的，所以你只是管理一个窗口。</a></p><p id="2423" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<code class="fe nx ny nz mx b">if let windowScene = scene as? UIWindowScene</code>块中，您会注意到<code class="fe nx ny nz mx b">SceneDelegate</code>立即获得当前窗口。这并不难，因为此时我们还没有在iPad上设置多个窗口，所以只有一个窗口。</p><p id="a4ca" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后，有点像最初的<code class="fe nx ny nz mx b">UIViewController</code>上的<code class="fe nx ny nz mx b">Storyboard</code>，我们设置了<code class="fe nx ny nz mx b">rootViewController</code>。</p><p id="06e9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">创建一个新的<code class="fe nx ny nz mx b">UIHostingController</code>允许我们显示SwiftUI。</p><p id="4b4b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有像SwiftUI实验室的解散模态这样的教程向你展示创建你自己的定制的价值。</p><p id="4781" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我不能提供一个比这更好的例子，但是如果你没有特定的问题要解决，你可能永远不需要创建一个定制的<code class="fe nx ny nz mx b">UIHostingController</code>。</p><p id="649a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您需要在<code class="fe nx ny nz mx b">SceneDelegate</code>中做的主要改变是将一个<code class="fe nx ny nz mx b">EnvironmentObject</code>传递到您的<code class="fe nx ny nz mx b">ContentView</code>中。有关更多信息，请参见<code class="fe nx ny nz mx b"><a class="ae lw" href="#7a99" rel="noopener ugc nofollow">EnvironmentObject</a></code>。</p><h2 id="171f" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">uiviewerepresentable</h2><p id="2443" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">UIViewRepresentable</code>允许您从UIKit中的<code class="fe nx ny nz mx b">UIViews</code>创建SwiftUI <code class="fe nx ny nz mx b">View</code>。</p><p id="ede1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这个例子中，我创建了一个多行<code class="fe nx ny nz mx b">TextField</code>，这在SwiftUI中是不可能的。由于没有等效的<code class="fe nx ny nz mx b">UITextView</code>，我使用<code class="fe nx ny nz mx b">UIViewRepresentable</code>和一个简单的<code class="fe nx ny nz mx b">ObservableObject</code>创建它，将数据永久保存到<code class="fe nx ny nz mx b">UserDefaults</code>。</p><p id="76d6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您在<code class="fe nx ny nz mx b">MultiTextField</code>中输入内容，您的更改会自动即时保存，因此下次您启动应用程序时，文本将保持不变。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="7b0c" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">UIViewControllerRepresentable</h2><p id="6f9b" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">您甚至可以从UIKit中表示整个<code class="fe nx ny nz mx b">UIViewController</code>实例，而不是像上面的<code class="fe nx ny nz mx b">UIViewRepresentable</code>中那样表示单个视图。</p><figure class="lh li lj lk gu ll gi gj paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gi gj py"><img src="../Images/477f28378f17514d3e7baa33472d183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClFdgoomSji-cmeZ_PMcgA.png"/></div></div></figure><p id="39c7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了复制我的例子，您需要在SwiftUI项目中创建一个<code class="fe nx ny nz mx b">Storyboard</code>，并将其命名为默认名称“Storyboard”。</p><p id="12c1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">向<code class="fe nx ny nz mx b">Storyboard</code>添加一个<code class="fe nx ny nz mx b">UIViewController</code>，并在视图层次中选择它。将<code class="fe nx ny nz mx b">Class</code>设置为<code class="fe nx ny nz mx b">ViewController</code>，将<code class="fe nx ny nz mx b">Storyboard ID</code>设置为<code class="fe nx ny nz mx b">initialVC</code>。</p><p id="3072" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">添加一个<code class="fe nx ny nz mx b">UILabel</code>，我使用约束将其居中。</p><p id="148f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我不会在这篇文章中解释UIKit约束，但网上有很多关于它的教程。</p><p id="8214" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你不需要我在顶部添加的<code class="fe nx ny nz mx b">UILabel</code>，上面写着“这是一个来自故事板的ViewController”，这只是为了让它工作时更明显。</p><p id="d211" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你也不需要把背景弄成蓝色，我只是想当我们混合SwiftUI和<code class="fe nx ny nz mx b">UIViewController</code>的时候，这样会让区别更加明显。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="d9f0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你不必从<code class="fe nx ny nz mx b">Storyboard</code>创建你的<code class="fe nx ny nz mx b">ViewController</code>实例，我只是认为这对很多人来说是一个有用的例子。</p><p id="c784" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您需要在<code class="fe nx ny nz mx b">UIViewConrollerRepresentable</code>中包含的只是初始化<code class="fe nx ny nz mx b">ViewController</code>的<code class="fe nx ny nz mx b">makeUIViewController(context:)</code>和对SwiftUI中的变化做出反应的<code class="fe nx ny nz mx b">updateUIViewController(_:, context:)</code>。</p><p id="d416" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意，我有一个链接到我的<code class="fe nx ny nz mx b">ContentView</code>结构的<code class="fe nx ny nz mx b">@Binding</code>属性，这意味着我在SwiftUI <code class="fe nx ny nz mx b">TextField</code>中所做的更改会更新<code class="fe nx ny nz mx b">UIKitVC</code>中的这个属性，而<code class="fe nx ny nz mx b">updateUIViewController(_:, context:)</code>会将这些更改传递给<code class="fe nx ny nz mx b">ViewController</code>类中的实际<code class="fe nx ny nz mx b">UILabel</code>。</p><h2 id="3cb4" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">数字冠旋转敏感度</h2><p id="4cb2" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">这是Apple Watch侧面旋转表盘的一系列敏感问题。它有<code class="fe nx ny nz mx b">.low</code>、<code class="fe nx ny nz mx b">.medium</code>和<code class="fe nx ny nz mx b">.high</code>三个品种。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="132c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/state_and_data_flow" rel="noopener ugc nofollow" target="_blank">状态和数据流</a></h1><h2 id="efd1" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">状态</h2><p id="956c" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">任何你想本地存储在一个<code class="fe nx ny nz mx b">View</code>结构中的变量都应该用这个来标记。如果你添加了一个变量而没有添加<code class="fe nx ny nz mx b">@State</code>，你不能用它来存储一个控件的值。</p><p id="f62d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是因为<code class="fe nx ny nz mx b">@State</code>变量可以在运行时改变，SwiftUI <code class="fe nx ny nz mx b">View</code>将在此基础上重新绘制自己。</p><p id="e247" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">例如，如果你有一个<code class="fe nx ny nz mx b">Button</code>改变了绑定到<code class="fe nx ny nz mx b">Slider</code>的值，那么<code class="fe nx ny nz mx b">Slider</code>将会移动以反映你所做的改变，尽管事实上你并没有移动<code class="fe nx ny nz mx b">Slider</code>本身。</p><p id="4449" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面是三个主要的SwiftUI控件及其相应的<code class="fe nx ny nz mx b">@State</code>变量，以及一个改变它们的重置<code class="fe nx ny nz mx b">Button</code>:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="0e81" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">有约束力的</h2><p id="6de4" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">如果您想影响子<code class="fe nx ny nz mx b">View</code>的父属性中的<code class="fe nx ny nz mx b">@State</code>属性，您需要传递它并将其标记为<code class="fe nx ny nz mx b">@Binding</code>。这使得子节点<code class="fe nx ny nz mx b">View</code>可以像父节点一样直接访问父节点的<code class="fe nx ny nz mx b">@State</code>变量。</p><p id="6960" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在下面的例子中，我使用上面的<code class="fe nx ny nz mx b">@State</code>例子来呈现一个包含子<code class="fe nx ny nz mx b">View</code>的工作表。</p><p id="9541" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">由于局部<code class="fe nx ny nz mx b">@Binding</code>属性未初始化，当您在sheet修饰符中创建<code class="fe nx ny nz mx b">PresentedView</code>结构时，需要初始化它们。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="05d3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您不确定下面一行:</p><pre class="lh li lj lk gu mw mx my mz aw na bi"><span id="a97e" class="nb mf iu mx b gz nc nd l ne nf">Environment(\.presentationMode) var presentationMode</span></pre><p id="fa1b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它用于关闭工作表的“消除”按钮。更多信息，请访问<a class="ae lw" href="#98ed" rel="noopener ugc nofollow">环境</a>。</p><h2 id="65b8" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">观察对象</h2><p id="73ac" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">在我的控件示例中，比如<code class="fe nx ny nz mx b">Toggles</code>和<code class="fe nx ny nz mx b">TextFields</code>，我展示了一种从符合<code class="fe nx ny nz mx b">ObservableObject</code>协议的Swift类访问数据的简单方法。</p><p id="e6f5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了简单起见，我在相同的代码片段中展示了这一点，但它实际上应该在一个单独的Swift文件中。下面是将Swift类绑定为<code class="fe nx ny nz mx b">@ObservedObject</code>的最基本的例子。</p><p id="179b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这意味着对Swift文件中标有<code class="fe nx ny nz mx b">@Published</code>的变量所做的任何更改都会通知SwiftUI文件相应地更新其视图。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="7a99" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">环境对象</h2><p id="a2f1" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">添加一个<code class="fe nx ny nz mx b">EnvironmentObject</code>和添加一个<code class="fe nx ny nz mx b">ObservedObject</code>非常相似。</p><p id="6877" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这里的<code class="fe nx ny nz mx b">DataModel</code>类的结构完全相同，但是我们将它标记为<code class="fe nx ny nz mx b">ContentView</code>内的<code class="fe nx ny nz mx b">EnvironmentObject</code>和<em class="lf">，而不是设置为<code class="fe nx ny nz mx b">DataModel.shared</code>的</em>。</p><p id="12b9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">相反，我们只是用名称和类型来声明它，并且使用<code class="fe nx ny nz mx b">SceneDelegate</code> Swift文件来传递<code class="fe nx ny nz mx b">DataModel.shared</code>。</p><p id="17d8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我已经在<code class="fe nx ny nz mx b">SceneDelegate</code>中包含了需要更改的内容，以便将<code class="fe nx ny nz mx b">EnvironmentObject</code>传入。请记住，您导航到的任何后续视图，比如用一个<code class="fe nx ny nz mx b">NavigationLink</code>或者通过展示一个表，在创建时都需要将相同的<code class="fe nx ny nz mx b">EnvironmentObject</code>传递给它们。</p><p id="6889" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我在我的例子中添加了一个表格，你可以通过按下一个按钮来显示它，只是为了显示<code class="fe nx ny nz mx b">environmentObject</code>是如何通过的(尽管它与<code class="fe nx ny nz mx b">SceneDelegate</code>中的相同):</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="933d" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">FetchRequest和FetchedResults</h2><p id="1f8a" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">在 <code class="fe nx ny nz mx b"><a class="ae lw" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-create-a-core-data-fetch-request-using-fetchrequest" rel="noopener ugc nofollow" target="_blank">FetchRequest</a></code>上有一个很好的<a class="ae lw" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-create-a-core-data-fetch-request-using-fetchrequest" rel="noopener ugc nofollow" target="_blank">黑客与Swift教程。</a></p><h2 id="9a25" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">动态特性</h2><p id="0762" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">为了SwiftUI <code class="fe nx ny nz mx b">View</code>在底层数据改变时被刷新，我们需要一个协议来封装这个底层概念。</p><p id="3779" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">至少一些符合类型<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/binding" rel="noopener ugc nofollow" target="_blank">Binding</a></code>、<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/environment" rel="noopener ugc nofollow" target="_blank">Environment</a></code>、<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/environmentobject" rel="noopener ugc nofollow" target="_blank">EnvironmentObject</a></code>、<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/fetchrequest" rel="noopener ugc nofollow" target="_blank">FetchRequest</a></code>、<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/gesturestate" rel="noopener ugc nofollow" target="_blank">GestureState</a></code>、<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/observedobject" rel="noopener ugc nofollow" target="_blank">ObservedObject</a></code>和<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">State</a></code>应该为在SwiftUI中处理过数据的任何人所熟悉。</p><p id="9adf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些属性在重绘<code class="fe nx ny nz mx b">View</code>的主体之前设置。</p><h2 id="98ed" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">环境</h2><p id="df19" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">“环境”可让您访问与设备设置相关的设置。例如，<code class="fe nx ny nz mx b">ColourScheme.dark</code>允许你预览你的应用在新的黑暗模式下会是什么样子，并与更传统的<code class="fe nx ny nz mx b">ColourScheme.light</code>进行对比。</p><p id="7605" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">可以在辅助功能设置中增加对比度，因此<code class="fe nx ny nz mx b">ColorSchemeContrast.increased</code>或<code class="fe nx ny nz mx b">ColorSchemeContrast.standard</code>是唯一的选项。</p><p id="fc90" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在辅助功能设置中选择粗体文本的结果由<code class="fe nx ny nz mx b">LegibilityWeight.bold</code>显示，否则默认为<code class="fe nx ny nz mx b">LegibilityWeight.regular</code>。</p><p id="fab7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每个<code class="fe nx ny nz mx b">View</code>都有一个关联的<code class="fe nx ny nz mx b">PresentationMode</code>结构，它存储一个属性并有一个方法。该属性是bool <code class="fe nx ny nz mx b">isPresented</code>，它告诉您<code class="fe nx ny nz mx b">View</code>是否是活动的。</p><p id="7a11" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">方法是<code class="fe nx ny nz mx b">dismiss()</code>，它允许你从屏幕上移除当前的<code class="fe nx ny nz mx b">View</code>并返回到<code class="fe nx ny nz mx b">View</code>所显示的位置。</p><p id="0952" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我还可以继续，但是举一个例子列出如何绑定每一个<code class="fe nx ny nz mx b">Environment</code>值并在<code class="fe nx ny nz mx b">List</code>中查看数据可能更有意义:</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><h2 id="66a3" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">偏好键</h2><p id="6c48" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">任何<code class="fe nx ny nz mx b">View</code>都可以使用修饰符<code class="fe nx ny nz mx b">.preferredColorScheme(.dark)</code>强制其外观为黑暗模式，即使设备设置为明亮模式。</p><p id="c126" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这将把<code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/preferredcolorschemekey" rel="noopener ugc nofollow" target="_blank">PreferredColorSchemeKey</a></code>结构的value属性设置为<code class="fe nx ny nz mx b">ColorScheme.dark</code>的值属性。这可以通过强制<code class="fe nx ny nz mx b">View</code>与<code class="fe nx ny nz mx b">.colorScheme(.light)</code>一起使用灯光模式来覆盖，这就是为什么第一个修改器仅指示偏好而非强制状态。</p><p id="8347" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">可以调用<code class="fe nx ny nz mx b">.preferredColorScheme(nil)</code>来表示没有偏好，这会导致使用默认的配色方案，而<code class="fe nx ny nz mx b">.colorScheme(nil)</code>不能被调用。</p><p id="4262" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为什么<code class="fe nx ny nz mx b">.colorScheme(nil)</code>不能叫？</p><p id="de2b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/preferredcolorschemekey" rel="noopener ugc nofollow" target="_blank">PreferredColorSchemeKey</a> </code>符合<code class="fe nx ny nz mx b">PreferenceKey</code>协议，该协议不仅需要一个值，还需要一个在没有设置值时可以使用的<code class="fe nx ny nz mx b">defaultValue</code>。</p><p id="00b8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe nx ny nz mx b">.colorScheme(.light)</code>修饰符根本不设置结构值，只是返回带有所需配色方案的<code class="fe nx ny nz mx b">View</code>。</p><h2 id="394b" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">本地化字符串键</h2><p id="18ea" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated"><code class="fe nx ny nz mx b">LocalizedStringKey</code>可以从字符串中创建，并将尝试使用它在<code class="fe nx ny nz mx b">Localisable.strings</code>或另一个用于<a class="ae lw" href="https://developer.apple.com/internationalization/" rel="noopener ugc nofollow" target="_blank">国际化</a>的文件中找到相应的值。</p><p id="7031" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果找不到值，则使用键本身。</p><p id="f9a6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">关于使用<code class="fe nx ny nz mx b">LocalizedStringKey</code>的示例，参见<a class="ae lw" href="#2307" rel="noopener ugc nofollow">文本</a>。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="9a17" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/gestures" rel="noopener ugc nofollow" target="_blank">手势</a></h1><h2 id="f198" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">手势</h2><p id="0797" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">我知道这应该是他们文档的替代品，但是苹果的教程很好地涵盖了手势。我不想给出类似于<a class="ae lw" href="https://developer.apple.com/documentation/swiftui/gestures" rel="noopener ugc nofollow" target="_blank">所提供的</a>的例子，所以我就让这部分保持原样。</p><p id="2591" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当你掌握了基础知识，苹果公司有另一个教程教你如何将手势组合成更复杂的互动。这两篇文章的底部都有一个标准手势类型的列表，所有这些似乎都有很好的文档记录。</p><p id="4221" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果您发现手势文档中有一页需要进一步解释，请告诉我，我会尽力在这里解释。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a998" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><a class="ae lw" href="https://developer.apple.com/documentation/swiftui/previews" rel="noopener ugc nofollow" target="_blank">预览</a></h1><h2 id="8932" class="nb mf iu bd mg nm nn dn mk no np dp mo ks nq nr mq kw ns nt ms la nu nv mu nw bi translated">PreviewProvider协议</h2><p id="3d9b" class="pw-post-body-paragraph kj kk iu kl b km nh jv ko kp ni jy kr ks nj ku kv kw nk ky kz la nl lc ld le in bi translated">创建一个符合这个提供者的结构允许你创建一个<code class="fe nx ny nz mx b">View</code>的集合，创建一个<code class="fe nx ny nz mx b">Group</code>允许你创建多个预览，每个预览可以有一个不同的平台。</p><p id="0613" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为此，您可以使用<code class="fe nx ny nz mx b">VStack</code>、<code class="fe nx ny nz mx b">HStack</code>和<code class="fe nx ny nz mx b">ZStack</code>，但是这会产生奇怪的结果，即使您选择不同的预览设备，也会在一个屏幕上显示多个预览。</p><figure class="lh li lj lk gu ll"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="ac23" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">除了指定设备，您还可以指定平台。目前的选项有iOS、macOS、tvOS和watchOS。</p><p id="1efa" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">默认情况下，<code class="fe nx ny nz mx b">PreviewLayout</code>值被设置为<code class="fe nx ny nz mx b">.device</code>，它显示设备的外观，并适合其中的预览。将它设置为<code class="fe nx ny nz mx b">.sizeThatFits</code>似乎会给出容器的设备大小，但不会显示容器周围的设备挡板。</p><p id="6116" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最后，将<code class="fe nx ny nz mx b">previewLayout</code>设置为<code class="fe nx ny nz mx b">fixed</code>允许您为容器设置自定义的宽度和高度，这在您不太关心<code class="fe nx ny nz mx b">View</code>在设备上的外观时可能会很有用。</p><p id="3f72" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用<code class="fe nx ny nz mx b">.environment</code>可让您在黑暗模式下预览，并查看您的应用程序如何在不同的本地化环境下工作。</p><p id="aebc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">感谢阅读！</p></div></div>    
</body>
</html>