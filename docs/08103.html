<html>
<head>
<title>3 Advanced Git Commands You Might Not Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不知道的3个高级Git命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-advanced-git-commands-you-might-not-know-fa9fdf3d9168?source=collection_archive---------6-----------------------#2021-03-25">https://betterprogramming.pub/3-advanced-git-commands-you-might-not-know-fa9fdf3d9168?source=collection_archive---------6-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跟踪操作历史，查找东西何时损坏，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f35f562ae059a6f8c7431498a1dfa51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZDsGjtjRvilNdNf3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔希·卡拉布雷斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="f8fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，遇到没有Git知识的软件工程师是个例外。Git已经成为业界如此普遍的工具，以至于你无法用它打动任何人。嗯，你可能会说你对版本控制系统一无所知，从而给别人留下深刻印象。</p><p id="4dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论开发人员如何使用Git(通过命令行或可用产品如SourceTree、Tower、TortoiseGit提供的漂亮UI界面)，重要的是开发人员知道Git的用途及其工作方式。</p><p id="a59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于日常任务，知道如何将文件添加到stage、提交以及从远程存储库推送和提取更改就足够了。掌握了基本命令之后，是时候探索Git还能提供什么了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5cfd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.跟踪操作历史</h1><p id="0433" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您知道吗，Git有一个对存储库执行的所有操作的日志？当您执行提交、重置基础、签出或任何其他操作时，它们都将被保存。</p><p id="da72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git将所有的操作历史保存在一个单独的地方，称为引用日志。它包含执行某个操作时分支状态的链接。而命令的名字是<code class="fe mz na nb nc b">git reflog</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/fdd814180a7fbb369df034f8a10bec60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSsIRqbMwL1I6FOdv-jdWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Git reflog输出</p></figure><p id="a371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到命令的输出。它显示了在本地存储库上执行的所有操作。提交散列中有一个指向历史中该点的引用。</p><p id="3718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么时候可以用？一个用例是审计。有时候事情会出错。例如，在重置基础操作中，特定的提交被意外删除。使用<code class="fe mz na nb nc b">git reflog</code>命令，我们可以找出重置操作开始的时间，并回滚到之前的状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0728" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.发现什么时候东西坏了</h1><p id="56a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有些情况下，我们必须检查一段时间内的Git历史，以找到引入bug的提交。当历史日志中只有十个条目时，这个任务看起来并不困难。但是如果团队很大，历史日志很大，这将花费很多时间。</p><p id="26c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢天谢地，Git为这种情况提供了一个特殊的命令。通过使用<code class="fe mz na nb nc b">git bisect</code>命令，将启动一个二分搜索法。它将检查从问题不存在到提交包含问题之间的提交的历史日志。</p><p id="990b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始搜索，我们需要运行<code class="fe mz na nb nc b">git bisect start</code>。然后我们在日志中提供一个起点和终点来查看。例如，我们知道提交<code class="fe mz na nb nc b">77beb52c</code>没有问题，而提交<code class="fe mz na nb nc b">afeb16fb</code>已经包含了问题。我们用以下命令来描述这一点:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="65d0" class="ni md it nc b gy nj nk l nl nm">git bisect bad afeb16fb<br/>git bisect good <!-- -->77beb52c</span></pre><p id="1da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，Git就可以开始搜索了。它将分割日志，并从日志中间选择提交。我们的工作是判断这个提交是否有问题。如果我们认为该提交中不存在问题，我们就写<code class="fe mz na nb nc b">git bisect good</code>。在这种情况下，起始点将转移到该提交，并且该过程在一个较小的历史日志上重复。</p><p id="8f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看到提交已经包含了这个问题，我们用命令<code class="fe mz na nb nc b">git bisect bad</code>告诉Git。然后，提交成为新的端点，搜索进入下一个循环。</p><p id="04ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个过程一直继续，直到单个提交停留在问题开始的地方。使用这个命令，您将能够快速分析历史日志，并追溯到问题出现的时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1dea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.保存您的草稿</h1><p id="1720" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">想象一下下面的场景:一个软件开发人员正在实现一个新特性。突然，他们不得不切换到一个特定的分支并做出一些改变。但是，当前的变化会带来什么呢？</p><p id="592c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先想到的是提交修改。然而，更多的人可以在分支机构工作。做一件只做了一半的事情是不好的做法。</p><p id="c1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种情况，Git提供了一个特殊的命令:<code class="fe mz na nb nc b">git stash</code>。这个命令将工作目录保存在一个特殊的本地堆栈中。最近添加的更改总是在最上面。成功保存后的所有更改都将从工作目录中删除。</p><p id="da90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">git stash</code>命令类似于现实生活中的草稿。我们可以摆弄文件，做各种实验，但没人会看到它们。在任何时间点，我们都可以应用隐藏的变更并继续未完成的工作。探索新的方法而不填充大量的分支是一个很好的特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ceb4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="1fe6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">给人留下Git知识的印象在今天很难，因为它是日常使用的工具。但是仍然有可能展示Git的良好知识。知道如何应用高级命令可以提高您的工作效率，并帮助您更有效地与团队协作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是Git新手吗？别担心！我准备了一个Udemy课程“<a class="ae ky" href="https://www.udemy.com/course/practical-git-for-absolute-beginners/?referralCode=0EFE893B7A67E8D0D652" rel="noopener ugc nofollow" target="_blank">实用Git:针对绝对初学者</a>”。在不到2个小时的时间里，您将学习Git的基础知识以及如何应用它。让我们一起学习Git吧！</p></div></div>    
</body>
</html>