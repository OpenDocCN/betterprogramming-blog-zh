<html>
<head>
<title>Build an Authentication API With Node, Express, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node、Express和MongoDB构建一个身份验证API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-authentication-api-with-node-express-and-mongodb-112b448c21f2?source=collection_archive---------2-----------------------#2021-09-22">https://betterprogramming.pub/build-an-authentication-api-with-node-express-and-mongodb-112b448c21f2?source=collection_archive---------2-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c08" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">堆栈选择、说明和后续步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77e6db19aea0161ee7600a8fd170f721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVUrTJv7e49YBR1XeQu8RQ.png"/></div></div></figure><p id="a91f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构建一个可以管理用户注册和认证的应用程序API激发了人们的思考。在这次深入探讨中，我们将从预期行为、技术决策、支持包和安全要求等方面逐一介绍这些考虑事项。</p><p id="99c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此之前，让我们先来看一看我们选择的堆栈以及它们所提供的功能。</p><h1 id="4f73" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak"> Node.js </strong></h1><p id="783f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">节点。js是JavaScript的运行环境。它主要用于非阻塞、事件驱动的服务器。</p><p id="ed72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node将使我们能够在前端和后端使用JS，允许全栈JavaScript开发，并且对现有JS开发人员来说有更容易的学习曲线。有一个很好的生态系统，其架构适合运行在分布式设备上的轻量级、高流量、数据密集型(但处理/计算能力较低)的应用程序。</p><p id="a95c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js的理想应用程序可以包括聊天应用程序、股票经纪人仪表板、监控仪表板或在开发过程中代替nGinx使用的反向代理</p><h2 id="0ca9" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">缩放考虑</strong></h2><p id="7042" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">JavaScript的设计是一种单线程语言，这意味着它一次只能处理一个命令，因此它的方法被认为是阻塞方法，但它具有异步功能，这允许它的方法是非阻塞的。</p><p id="3cfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地解释这一点，我把它比作一个有一个服务员和五张桌子的餐馆。</p><p id="61e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">封锁系统——服务员记下一张桌子的订单，在食物准备好并从厨房送来之前，不能为任何其他桌子服务。</p><p id="9fa3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个非阻塞系统——服务员接受一份订单，并把它带到厨房。然后，他们可以自由地接受另一份订单，并把它带到厨房。当食物准备好了，他们会再次被要求把食物从厨房送到各自的桌子上。</p><p id="ab8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过添加负载平衡器或集群来进一步扩展。集群允许我们利用多核系统。因此，我们可以启动Node.js进程集群来处理负载，而不是在单个线程上运行Node.js的单个实例。</p><p id="4e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是有帮助的，但是通常不建议在节点上运行繁重的计算，它们会使CPU紧张并阻塞额外的请求。</p><p id="7041" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个考虑是，对于关系数据库，ORM工具不如其他语言如Rubys的“ActiveRecord”等先进。</p><h2 id="5ef8" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">思绪</strong></h2><p id="c94c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对于我们的登录应用程序，Node和JavaScript与传统的服务器端语言相比没有真正的架构优势，除了它允许我们在应用程序的前端和后端都使用JavaScript。</p><h1 id="227c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak"> MongoDB </strong></h1><p id="7af2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">说到数据库，我们有两个明显的选择:</p><ol class=""><li id="dd9e" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">一个<strong class="kw iu">关系</strong>数据库，将数据存储在由强制模式创建的行和列中。</li><li id="6e40" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">一个<strong class="kw iu">非关系型</strong>数据库，在集合和文档中存储数据，可以是无模式的。</li></ol><p id="0724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种方式各有优势，这取决于您存储的数据以及您可能需要如何访问和操作这些数据。对于这个应用程序，一个比另一个没有太大的优势，但是我决定使用非关系型MongoDB，原因如下。</p><ul class=""><li id="8fbe" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nn nf ng nh bi translated">上手超级快。文档数据模型是一种存储和检索数据的强大方法，它允许开发人员快速移动。MongoDB是一个无模式的NoSQL文档数据库。这意味着您可以在其中存储JSON文档，并且这些文档的结构可以变化，因为它不像SQL数据库那样强制执行。开发人员可以安装MongoDB，并在基于云的DB上立即开始编写代码。</li><li id="01ca" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">Json存储:是的，在SQL数据库上存储JSON是可能的。但是MongoDB及其基于文档的存储非常适合它。JSON是一种简单而强大的方式来描述和存储数据，以及在彼此内部嵌入文档。</li><li id="138d" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">它与Node.js配合得很好。因为MongoDB是一个分布式数据库，允许特别查询和实时更新，并且是Node.js的极好的兼容者，正如我们前面提到的，node . js非常适合于跨分布式设备运行的高流量、数据密集型(但处理/计算能力较低)的应用程序</li></ul><h2 id="4855" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">缩放解决方案</strong></h2><p id="aed7" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">MongoDB的横向扩展架构可以支持海量数据和流量。</p><p id="25fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MongoDB的横向扩展架构将工作分布在许多更小(更便宜)的计算机上，这意味着您可以创建一个应用程序，它可以自信地处理随着业务增长而出现的流量高峰。</p><p id="ce7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，大多数SQL数据库使用纵向扩展的体系结构，这是有局限性的，因为它依赖于创建更快、更强大的计算机。</p><p id="cc89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MongoDB可以支持大量的读写。这些创新的核心是MongoDB的分片方法，当信息在计算机集群中传播时，它允许信息集群存储在一起。</p><p id="b9b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MongoDB还支持数据库事务，允许将对数据库的许多更改组合在一起，并且可以成批进行或拒绝。</p><h1 id="abb6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">表达</h1><p id="2dd1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Express是一个路由和中间件web框架，它本身的功能很少，本质上是一堆中间件函数调用。</p><p id="d800" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些中间件功能可以访问<code class="fe no np nq nr b">req</code>和<code class="fe no np nq nr b">res</code>对象以及<code class="fe no np nq nr b">next</code>参数，后者调用堆栈中的下一个中间件模块。</p><p id="ccb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express将是所有这些好东西的粘合剂:</p><ul class=""><li id="6148" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nn nf ng nh bi translated"><strong class="kw iu">关于我们将创建的用户模型的路由端点。</strong><code class="fe no np nq nr b">express.Router</code>是一个内置于Express中的路由系统，可以满足我们所有的路由需求</li><li id="5b44" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><strong class="kw iu">解析JSON</strong>:<strong class="kw iu"/><code class="fe no np nq nr b">express.json()</code>方法是Express中内置的中间件函数。它使用JSON有效负载解析传入的请求，并基于<code class="fe no np nq nr b">body-parser</code>。</li><li id="c753" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><strong class="kw iu"> JSON Web令牌</strong>:<strong class="kw iu"/>jwt将对应用程序的请求进行签名和认证。我们将创建一些定制的中间件来处理用户认证，监听请求和响应</li><li id="06d8" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><strong class="kw iu">错误响应</strong>:我们将创建定制的中间件来监听服务器端的错误响应，并允许我们以模块化的方式处理它们。</li><li id="d6b0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><strong class="kw iu">express——除非</strong> : <strong class="kw iu"> </strong>当一个条件满足时，有条件地跳过一个中间件，我们可以使用<code class="fe no np nq nr b">express-unless</code>包。这在与定制认证中间件结合使用时尤其有用。</li><li id="b387" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><strong class="kw iu"> bcryptjs </strong> : <strong class="kw iu"> </strong>密码从不以纯文本形式存储。npm包将加密我们的密码，并且是JavaScript中使用密码最多的包之一。</li></ul><h2 id="b6c2" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak">猫鼬</strong></h2><p id="6f04" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Mongoose是一个对象文档建模(ODM)层，位于Node的MongoDB驱动程序之上。如果您来自SQL，它类似于关系数据库的对象关系映射(ORM)。</p><p id="d3de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然不要求在Mongo中使用Mongoose，但它有许多简洁的特性可以在开发过程中提供帮助。我们将关注的问题包括:</p><h2 id="b665" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak"> 1。模式</strong></h2><p id="1479" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们之前提到过Mongo是无模式的，这对于快速开发非常好，尽管对于验证对象和维护结构不是很好。</p><p id="95f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Mongoose模式将定义文档的结构、默认值和验证器。它有助于维护结构，清楚地了解什么将进入数据库，减少可预防的错误，并允许更干净的代码。</p><h2 id="59c1" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated"><strong class="ak"> 2。型号</strong></h2><p id="c0ef" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Mongoose模型提供了一个数据库接口，用于创建、查询、更新、删除记录等。</p><p id="cdcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它还创建了模型抽象，使其更容易使用，所以看起来你只是在使用对象而不是纯数据。</p><p id="6de1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模式有几个可配置的选项，可以传递给构造函数或set方法。我们将使用它来创建JSON对象。</p><h1 id="112e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">软件包安装</h1><ul class=""><li id="8117" class="mz na it kw b kx mi la mj ld ns lh nt ll nu lp nn nf ng nh bi translated"><a class="ae nv" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点</a></li><li id="fbf3" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><a class="ae nv" href="https://nodejs.org/en/docs/guides/getting-started-guide/" rel="noopener ugc nofollow" target="_blank">在你的机器上运行node . js</a></li></ul><p id="a1b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了。现在来建立我们的蒙哥数据库。当然，有不同的方法可以做到这一点，但是我相信最快的方法是利用云上的免费共享数据库。</p><p id="95b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:您应该能够<a class="ae nv" href="https://www.mongodb.com/try" rel="noopener ugc nofollow" target="_blank">按照这些步骤</a>创建Mongo数据库。</p><p id="a168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下载后，在您的终端中运行<code class="fe no np nq nr b">npm init</code>。这将提示您输入一个入口点，我们将把它设置为<code class="fe no np nq nr b">server.js</code>:</p><pre class="kj kk kl km gt nw nr nx ny aw nz bi"><span id="cb3b" class="mn lr it nr b gy oa ob l oc od">$ npm install express mongoose express-unless bcryptjs dotenv jsonwebtoken — save</span></pre><ul class=""><li id="0530" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nn nf ng nh bi translated"><a class="ae nv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">快递</a></li><li id="c49c" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><a class="ae nv" href="https://www.npmjs.com/package/express-unless" rel="noopener ugc nofollow" target="_blank">明示——除非</a></li><li id="66ec" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><a class="ae nv" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> bcryptjs </a></li><li id="50d7" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><a class="ae nv" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> Dotenv </a></li><li id="c516" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><a class="ae nv" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> Jsonwebtoken </a></li></ul><h1 id="98de" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">建筑</h1><p id="4b31" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们将构建一个安全的REST API来处理用户模型的常见需求:</p><pre class="kj kk kl km gt nw nr nx ny aw nz bi"><span id="0370" class="mn lr it nr b gy oa ob l oc od">// User Data</span><span id="8b5b" class="mn lr it nr b gy oe ob l oc od">User {<br/>  Id: (auto generated UUID)<br/>  Username: String<br/>  Email: String<br/>  Password: String<br/>  Date: Date<br/>}</span></pre></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="b4c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将用于创建和安全获取该用户的端点是:</p><ul class=""><li id="f151" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nn nf ng nh bi translated"><code class="fe no np nq nr b">POST</code>在端点上<code class="fe no np nq nr b">/users/register</code>(创建一个新用户)</li><li id="f67d" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">端点<code class="fe no np nq nr b">/users/login</code>上的<code class="fe no np nq nr b">POST</code>(检查用户并认证)</li><li id="797a" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated"><code class="fe no np nq nr b">GET</code>在端点上<code class="fe no np nq nr b">/users/:id</code>(获取特定用户)</li></ul><p id="275b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想做的下一件事是粗略地设计我的目录结构:</p><pre class="kj kk kl km gt nw nr nx ny aw nz bi"><span id="d4c0" class="mn lr it nr b gy oa ob l oc od">Controllers<br/> - Userscontroller.js<br/>Modals<br/> - Usersmodal.js<br/>Services<br/> - Userservice.js<br/>Helpers<br/> - Errorhandler.js<br/> - jwt.js<br/>server.js<br/>.env</span></pre><h2 id="8472" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">server.js</h2><p id="533f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们正在使用Express中间件功能创建一个模块化系统，我们将在该系统中完成以下工作:</p><ul class=""><li id="797d" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nn nf ng nh bi translated">监听请求和响应，并将它们路由到适当的控制器，在本例中是我们的用户控制器</li><li id="5b2d" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">验证请求，这将使用我们的JWT模块，除非它们来自不需要验证的特定路由。</li><li id="d3e8" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">解析JSON数据</li><li id="a33f" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nn nf ng nh bi translated">倾听回答中的错误</li></ul><p id="3efb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当应用程序启动时，我们还将连接到mongoose。</p><p id="1361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您将能够使用Mongo URL，该URL可以通过遵循<a class="ae nv" href="https://www.mongodb.com/try" rel="noopener ugc nofollow" target="_blank">文档</a>来创建。</p><p id="0a9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们也将开始看到<code class="fe no np nq nr b">mongoose</code>的一些优势。</p><p id="a5aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它有两个非常有用的内置方法，在发生错误或成功连接到数据库时充当事件处理程序。</p><p id="0e77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Express将通过监听我们决定的本地主机来再次帮助我们。以下代码将帮助我们做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="c169" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">jwt.js</h2><p id="79a5" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了处理JSON Web令牌(jwt)的创建和授权，我们将创建一些定制的中间件和助手方法。</p><p id="6580" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用这些来检查客户端在请求头中发送的授权令牌，并创建和签名令牌以发送到客户端。</p><p id="391b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经使用了<code class="fe no np nq nr b">dotenv</code>包将秘密密码安全地存储在一个<code class="fe no np nq nr b">.env</code>文件中，该文件用于构建和验证令牌。确保不要将该文件提交到生产环境中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="b5f8" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">错误处理程序. js</h2><p id="3705" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我见过的模块化错误的一个好方法是创建定制的中间件，它监听错误响应并管理返回给客户端的内容。</p><p id="1e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">错误处理中间件模块在调用堆栈中的位置很重要，因为它需要在我们应用的路由中间件之后被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="ece0" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">UserController.js</h2><p id="2522" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们的用户控制器在Express Router的帮助下监听请求，然后决定如何处理这些请求及其后续数据。</p><p id="e3e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当用户注册时，我们做的第一件事就是利用<code class="fe no np nq nr b">bcryptjs</code>来加密密码(尽快这样做是明智的)。它允许我们制造盐。Salts创建唯一的密码，即使在两个用户选择相同密码的情况下，然后散列该密码。</p><p id="c0f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，我们准备将它发送到我们的服务模块，该模块包含用我们创建的散列密码更新我们的MongoDB数据库所需的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="231a" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">UserModals.js</h2><p id="0863" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在我们查看服务模块之前，最好先深入查看一下<code class="fe no np nq nr b">usermodal.js</code>文件。</p><p id="5508" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们利用Mongoose为我们的用户对象创建一个模式。我们将使用它进行类型检查和数据验证。</p><p id="2f3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Mongoose模式有几个可配置的选项，可以传递给构造函数或set方法，我们可以用它来创建一个<code class="fe no np nq nr b">toJSON</code>,这个方法将我们的MongoDB文档转换成可以发送到我们客户端的JSON。</p><p id="218c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们创建并设置一个id属性，并删除<code class="fe no np nq nr b">_id</code>、<code class="fe no np nq nr b">__v</code>以及我们不需要发送回客户端的密码散列。</p><p id="0a71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们创建我们的mongoose模型并导出它。这个模型将可以访问mongoose的所有有用的查询方法，从MongoDB中检索我们的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="6c14" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">UserServices.js</h2><p id="eab1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在我们查看我们的服务模块之前，最好深入查看一下我们的usermodal.js。</p><p id="17f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们利用Mongoose为我们的<code class="fe no np nq nr b">User</code>对象创建一个模式。我们将使用它进行类型检查和数据验证。</p><p id="11ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模式有一些可配置的选项，可以传递给构造函数或set方法，这将很有帮助，因为我们可以使用它来创建一个<code class="fe no np nq nr b">toJSON</code>方法，通过创建和设置一个id属性并删除<code class="fe no np nq nr b">_id</code>、<code class="fe no np nq nr b"> __v</code>和我们不需要发送回客户端的密码散列，将我们的MongoDB文档抽象成JSON，我们很乐意将它发送回客户端。</p><p id="14bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将创建我们的Mongoose模型并导出它。这个模型可以访问所有有用的查询方法，从MongoDB中检索我们的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f197" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你已经发现这是有用的，感谢您的阅读。</p><p id="880a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitHub回购:【https://github.com/gavmac/authentication-api T4】</p><h2 id="3bc3" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">想联系作者？</h2><p id="e3c3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果你喜欢这个，你可能也会喜欢我们在<code class="fe no np nq nr b"><a class="ae nv" href="https://www.notnotnerdy.com/" rel="noopener ugc nofollow" target="_blank">!!nerdy</a></code>创造的其他一些博客文章和创意。每个月都会推出新的设计。</p></div></div>    
</body>
</html>