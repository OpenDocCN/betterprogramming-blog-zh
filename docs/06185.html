<html>
<head>
<title>How to Inject a Logger into Go’s HTTP Handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go的HTTP处理程序中注入一个日志记录器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-inject-a-logger-into-gos-http-handlers-34481a4f2aad?source=collection_archive---------7-----------------------#2020-09-08">https://betterprogramming.pub/how-to-inject-a-logger-into-gos-http-handlers-34481a4f2aad?source=collection_archive---------7-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解开一个反模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ace341a2b59cebe04c8cef57b21b9499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfdMulWU_LAtUdfTPao1Mg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ashwini Chaudhary 在<a class="ae ky" href="https://unsplash.com/s/photos/http?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将记录器分配给包级变量是一个<a class="ae ky" href="https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式</a>。当您在包名称空间中声明<code class="fe lv lw lx ly b">var log = mylogger.New()</code>时，您创建了对您使用的特定记录器品牌的紧密编译时依赖。这使得你的程序变得脆弱，难以修改。</p><p id="9067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是传递一个描述兼容记录器功能的接口，但在运行时之前忽略它的身份。但是那看起来像什么？具体来说，当您想将一个日志记录器传递给一个其签名不受您控制的函数时，会是什么样子呢？</p><p id="a4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">http.HandlerFunc</code>是一种记录必不可少但不直观的类型:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4f77" class="md me it ly b gy mf mg l mh mi">type HandlerFunc(ResponseWriter, *Request)</span></pre><p id="d8f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面对这种签名，一个可以从<code class="fe lv lw lx ly b">HandlerFunc</code>内部访问的包级日志记录器似乎是一个简单的解决方案，但是随着程序的发展，它会回来咬你。我们的任务是:将一个日志接口注入到看起来和行为都像强大的<code class="fe lv lw lx ly b">HandlerFunc</code>的东西中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3f51" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">建立自己的处理器工厂</h1><p id="db90" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，类型声明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口<code class="fe lv lw lx ly b">logger</code>定义了我们选择注入的任何日志记录器必须具备的能力，在本例中是<code class="fe lv lw lx ly b">Printf</code>。记录器的具体类型并不重要；我们只关心它能做什么。</p><p id="519d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">loggingHandlerFunc</code>是这个解决方案的核心——一个看起来很像<code class="fe lv lw lx ly b">http.HandlerFunc</code>的类型，但是它也接受一个实现我们的<code class="fe lv lw lx ly b">logger</code>接口的参数。</p><p id="7df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何将一个传入的<code class="fe lv lw lx ly b">*http.Request</code>转发给一个<code class="fe lv lw lx ly b">loggingHandlerFunc</code>？这就是<code class="fe lv lw lx ly b">loggingHandler</code>的作用。<code class="fe lv lw lx ly b">loggingHandler</code>嵌入了一个<code class="fe lv lw lx ly b">logger</code>和一个<code class="fe lv lw lx ly b">loggingHandlerFunc</code>，并定义了一个熟悉的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的<code class="fe lv lw lx ly b">loggingHandler</code>实现了<code class="fe lv lw lx ly b">http.Handler</code>，它需要单个方法<code class="fe lv lw lx ly b">ServeHTTP(w http.ResponseWriter, r *http.Request)</code>。我们现在可以将一个<code class="fe lv lw lx ly b">*loggingHandler</code>传递给一个<code class="fe lv lw lx ly b">http.ServeMux</code>(或者您选择的任何mux包)，并且到您指定的路由的流量将通过<code class="fe lv lw lx ly b">*loggingHandler</code>传递给嵌入式<code class="fe lv lw lx ly b">loggingHandlerFunc</code>，并在此过程中拾取一个<code class="fe lv lw lx ly b">logger</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种方法会导致大量的手动<code class="fe lv lw lx ly b">*loggingHandler</code>创建，并且在可能的情况下，您希望在许多路线上使用同一个记录器，您会发现自己在重复构建具有相似输入的<code class="fe lv lw lx ly b">*loggingHandler</code>。让我们用工厂来简化它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">loggingHandlerFactory</code>接受一个<code class="fe lv lw lx ly b">logger</code>并返回一个闭包，当用<code class="fe lv lw lx ly b">loggingHandlerFunc</code>调用该闭包时，返回一个新的<code class="fe lv lw lx ly b">*loggingHandler</code>，其中包含正确的记录器。</p><p id="a662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在路线中使用<code class="fe lv lw lx ly b">loggingHandlerFunc</code>变得像将它传递到工厂一样简单。更好的是，您编写的<code class="fe lv lw lx ly b">loggingHandlerFunc</code>可以嵌入到您喜欢的任何结构中，而不仅仅是这里定义的<code class="fe lv lw lx ly b">loggingHandler</code>。这种配置很容易改变，并且在封装之外没有连锁效应。</p><p id="f1fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与更直接但可能会限制您改变的自由的方法形成了某种对比:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe lv lw lx ly b">loggingHandler</code>只嵌入了一个记录器，普通的旧的<code class="fe lv lw lx ly b">http.HandlerFunc</code>被声明为<code class="fe lv lw lx ly b">*loggingHandler</code>上的方法，允许它们访问它的记录器字段。</p><p id="fb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这更容易理解，但是它将你的<code class="fe lv lw lx ly b">http.HandlerFunc</code>绑定到了<code class="fe lv lw lx ly b">loggingHandler</code>的一个实现上。如果<code class="fe lv lw lx ly b">loggingHandler</code>必须改变，它可能会影响每一个连接到它的<code class="fe lv lw lx ly b">HandlerFunc</code>。与第一种方法形成对比，在第一种方法中，<code class="fe lv lw lx ly b">loggingHandlerFunc</code>不关心<em class="no">它的</em>来自哪里，只关心它作为参数被传递。它确保我们的包不仅仅是与外部世界松散耦合，它在内部也是松散耦合的。</p><p id="980a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/AngusGMorrison/71ddf69083d075a8afa6e6e891d25d1d" rel="noopener ugc nofollow" target="_blank">下面是完整的例子</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2821" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">一个可敬的(？)提及</h1><p id="579a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有一种观点认为你可以在<code class="fe lv lw lx ly b">handlerFunc</code>的请求<code class="fe lv lw lx ly b">Context</code>的<code class="fe lv lw lx ly b">Value</code>中<em class="no">隐藏错误事件。当您的<code class="fe lv lw lx ly b">http.HandlerFunc</code>返回时，位于链顶端的那个将负责再次将它们取出，并记录一个关于请求期间发生的所有事情的统一报告。</em></p><p id="af59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一所学校会因为我向你建议而追杀我。</p><p id="71c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个论点是，<code class="fe lv lw lx ly b">Values</code>是一个由<code class="fe lv lw lx ly b">interface{}: interface{}</code>对组成的无定形袋子，它通过再次获取数据所需的类型断言，带来了大量潜在的错误。第二，让这一包无形式的数据在请求的整个生命周期中保持不变相当于线程本地存储，这对Go并发模型是不利的。</p><p id="39d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你对这种异端邪说是如何实现的感到好奇(我知道，你是在找朋友)，彼得·波尔根的ctxdata 是值得一看的代码。</p><p id="cdcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://groups.google.com/g/golang-dev/c/F3l9Iz1JX4g/m/2TpGYsTkAQAJ" rel="noopener ugc nofollow" target="_blank">围绕Go中登录的争论</a>很吸引人(不，真的)。我强烈建议补上它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<a class="ae ky" href="https://dave.cheney.net/" rel="noopener ugc nofollow" target="_blank">戴夫·切尼</a>和<a class="ae ky" href="https://peter.bourgon.org/" rel="noopener ugc nofollow" target="_blank">彼得·波尔根</a>帮助我理解这件事。</p></div></div>    
</body>
</html>