# 使用没有关联的 Rails“属于”进行测试

> 原文：<https://betterprogramming.pub/belongs-to-and-you-better-rails-testing-with-or-without-associations-54fa66c87a21>

## 默认情况下，Belongs_to 需要一个关联，这很好，但是对于测试来说很痛苦。以下是如何写出好的测试的方法

![](img/e5328fe1fa551ec371094610e4f2fa7f.png)

照片由 [SxySelia](https://unsplash.com/@sxy_selia) 在 [Unsplash](https://unsplash.com/s/photos/shock) 上拍摄

回到 Rails 5，古老的‘belongs _ to’属性得到了一个重要的更新:它开始[默认要求关联](https://www.bigbinary.com/blog/rails-5-makes-belong-to-association-required-by-default)。

正如 Rails 告诉我们的，当我们运行`create!`时，它在数据库中通过 ID (500)查找我们的用户。它发现它不存在，并通过引发错误来阻止创建。虽然这不像数据库级外键约束那样严格，但它为我们提供了合理的保护，防止在数据库中创建孤立行。

我非常支持这种改变。做错事应该很难。然而，这种`belongs_to`行为适用于所有环境，包括测试环境。对于我们这些在测试中创建数据库记录的人来说，这意味着我们必须创建更多的数据。你知道测试套件变慢的最大原因是什么吗？正在创建数据！

当我们的数据库位于另一台服务器上时，创建数据是最痛苦的。当然，这是生产级应用程序最常见的持续集成测试设置。每当我们创建一行时，Rails 都会触发一次到数据库的往返。旅行通常需要 20-40 毫秒。这并不可怕，但是当同一个测试需要创建几行，而您有数百个测试时，这当然会增加。最大的不便是当你有一个`belongs_to`等级制度时:

1.  一只`BillingAddress`属于一只`User`
2.  A `User`属于 a `UserGroup`
3.  一个`UserGroup`属于一个`Company`

现在，当我们为`BillingAddress`控制器编写最简单的测试时，它看起来像这样:

假设使用 RSpec 和 FactoryBot

神圣的烟雾！我们的两行测试需要四行设置和四次数据库往返！由于在持续集成环境中运行时，数据库往返将支配我们的测试时间，所以毫不夸张地说，我们的`belongs_to`验证使我们的测试时间翻了两番。

已经被使用 Java 的大公司雇用的读者将知道一种解决方法:通过专门的努力，您可以将您的数据库查询(持久层)从您的对象实例化层剥离，然后存根您的持久化调用。

对于 Rails 群体来说，这甚至更容易:您可以用存根[对控制器中使用的`find`、`find_by`或`where`方法进行猴子修补，以返回一些固定数据。如果您使用的是](https://relishapp.com/rspec/rspec-mocks/v/2-99/docs/method-stubs) [FactoryBot](https://github.com/thoughtbot/factory_bot_rails) ，该数据将由`build`(内部使用`new`)而不是`create`提供，从而完全避开数据库。跳过`create`意味着 Rails 不会运行`belongs_to`关联存在检查。它看起来会像这样:

瞧，根本没有数据库访问！写起来又快又没那么差。这就是*正确的*方式(TM)。

然而，有很多情况我们不会在礼貌的讨论中提出，但确实会遇到。例如，这是一个集成测试，该死的！或者，您的经理不相信存根，因为它们破坏了事物的自然顺序(并且因为它们来自 Java 背景)。或者，你的前同事写了所有这些糟糕的测试，你只需要让它们变得更好，而不是完美。对于你，我的*挑剔的*程序员，我有一个解决方案。

等等不，不要这样！虽然这个例子可能(绝对)是基于我们在我曾经工作过的一家公司实际做的(现在仍然在做的)一件事，但这不是方法！(另外我发誓，我们在改造！)

这个*会*解决你的问题；您将能够在您的测试中找到一个账单地址，但是代价是您已经失去了生产中的关联检查验证所提供的保护！我们真正想要的是一种允许验证不在我们的测试环境中运行的方法。如果我们不必在应用程序中的每个`belongs_to`上将它定义为一个参数，那肯定会很棒。幸运的是，Rails 提供了:

有了测试环境配置中的那一行，每一个`belongs_to`都将只在测试环境中跳过它的验证，允许你编写像这样简洁、生动的测试:

虽然我不会说这一定是你*应该*做的事情，但事实是，这会让你走得非常非常远。它免维护，易于使用，并且只需要一次数据库访问。而且，它仍然保持着您在生产(甚至开发)环境中想要的`belongs_to`验证。

有一种相反的观点认为，您的测试环境应该尽可能地像生产环境一样。这是有效的。当你写代码时，镜像你的开发和生产配置会提醒你*应该*创建一个关联，但是没有。然而，*因为*你是一个负责任的程序员，而*因为*你的代码创建这种关联是很重要的，你应该测试它是否做到了。如果你不喜欢冒险，就用存根。

但是对于我们这些想要体验一下疯狂出轨的人，你是受欢迎的。

**资源**

*   [导致验证错误的 Rails 关系要点](https://gist.github.com/ManickYoj/ab2502e4c04756eb9cd91b99d2ab0809)
*   [为一组层级所属关系创建数据的测试的要点示例](https://gist.github.com/ManickYoj/273171df585d4e7f0b55e879d41a7ef0)
*   [与存根数据检索相同测试的要点](https://gist.github.com/ManickYoj/85787f93ae506f4c56f046239df69f7e)
*   [仅创建相关数据库行的相同测试的要点](https://gist.github.com/ManickYoj/89156c0fa8783ba2b325bf62352e0420)
*   [反例仅使一个归属关系在所有环境中可选](https://gist.github.com/ManickYoj/64e103c7f142f7a9608ded0860ae6f37)
*   [要点配置测试环境绕过归属验证](https://gist.github.com/ManickYoj/afd18f6d4bf1bf3159f2fde9125ddd2d)