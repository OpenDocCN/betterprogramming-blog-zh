<html>
<head>
<title>A Do-it-yourself Implementation of the Golang Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中间件的自助实现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-do-it-yourself-implementation-of-the-golang-middleware-6f02f155ed17?source=collection_archive---------10-----------------------#2022-04-04">https://betterprogramming.pub/a-do-it-yourself-implementation-of-the-golang-middleware-6f02f155ed17?source=collection_archive---------10-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5456" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解中间件的原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8483a590f01f436f1626dac97c0b3f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vr7_XlLQR4M72ikk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的<a class="ae ky" href="https://unsplash.com/@surface?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">面</a>拍下</a></p></figure><p id="4c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们谈到中间件时，你会想到什么？有人会说中间件是拦截器/过滤器，可以用来做一些前置处理和后置处理。</p><p id="23b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是对的，中间件本质上是提供通用的<strong class="lb iu">流程控制</strong>。</p><p id="b4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制什么？也就是上面说的前处理和后处理。</p><p id="edc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们会将常用的流程控制代码放入中间件来完成，比如:</p><ul class=""><li id="d686" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">权限验证</li><li id="58c4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">请求跟踪</li><li id="9666" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">预参数检查</li><li id="035a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">记录</li><li id="c883" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi">…</li></ul><p id="7762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要实现一个中间件，我们需要做什么？</p><p id="e557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来分析一个中间件需要具备哪些功能。</p><ul class=""><li id="53a2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">可以拦截请求，拦截请求失败是没有意义的。</li><li id="d7b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可以绑定多个通用过程控制功能。</li><li id="1461" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行过程控制功能的绑定顺序。</li></ul><p id="c8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过分析，我们可以得出结论，中间件是用来<strong class="lb iu">处理通用函数</strong>的调用关系的。</p><p id="a607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其目的是包装业务函数并返回相同类型的方法。</p><p id="2ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将业务功能包裹在最里面，再将通用的流程控制功能一层一层的包裹在外面，整体看起来有点像食物“<strong class="lb iu">洋葱</strong>”，所以也叫<strong class="lb iu">【洋葱模型】</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/225cad044558b09c20604da93d1145ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFpIf6ldRdOWQcZIASyqLw.png"/></div></div></figure><p id="64bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个中间件中，将有三个部分:</p><ul class=""><li id="ba50" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">预先截取业务逻辑。</li><li id="d4c0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">下一步处理。</li><li id="b7ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">业务逻辑处理完成后的后拦截。</li></ul><p id="1f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了使用3个中间件的处理流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/1f408ce09f04b9f88fe4c8930c7e08f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UGeevuDdxFjOwgDFgQNnA.png"/></div></div></figure><p id="28b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在<code class="fe ml mm mn mo b"><a class="ae ky" href="https://pkg.go.dev/net/http" rel="noopener ugc nofollow" target="_blank">http</a></code>包的帮助下实现了中间件的一个基本版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动程序后，我们用<code class="fe ml mm mn mo b">postman</code>访问<code class="fe ml mm mn mo b">http://localhost:8099</code>，然后在头文件中用值<code class="fe ml mm mn mo b">foo</code>设置<code class="fe ml mm mn mo b">Authorizationthe</code>参数。</p><p id="1a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在访问它之后，我们得到下面的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ed19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看客户端打印:</p><pre class="kj kk kl km gt mr mo ms mt aw mu bi"><span id="c0b4" class="mv mw it mo b gy mx my l mz na">[AuthHandle] token is: foo</span><span id="77d4" class="mv mw it mo b gy nb my l mz na">[LogHandle] start at: 1645004016</span><span id="f900" class="mv mw it mo b gy nb my l mz na">cost 0.000103 second</span></pre><p id="0ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们这里的中间件只是一个空壳，但它不做任何事情。</p><p id="ae45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只是模拟了一个简单版本的中间件的效果，它是以嵌套包装器的形式实现的，留下了一个巨大的问题，那就是每次我们需要添加一个新的中间件时，我们都需要像这样嵌套它，这最终会导致代码膨胀。</p><p id="d43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的代码如下所示。</p><pre class="kj kk kl km gt mr mo ms mt aw mu bi"><span id="fed0" class="mv mw it mo b gy mx my l mz na">middlewareA(middlewareB(middlewareC(middlewareD(business()))))</span></pre><p id="3aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当中间件越来越多的时候，这个根本维护不了。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="72d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分析一下中间件是如何在<code class="fe ml mm mn mo b"><a class="ae ky" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank">Gin</a></code>框架中实现的。</p><p id="aaf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们上面使用的哑方法相比，Gin的实现要好得多，它使用了一个<strong class="lb iu">函数数组</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当请求进来时，<code class="fe ml mm mn mo b">Gin</code>为请求分配一个<code class="fe ml mm mn mo b">Context</code>，它携带一个要处理的<code class="fe ml mm mn mo b">HandlerFunc</code>数组，以及一个跟踪当前正在处理哪个<code class="fe ml mm mn mo b">HandlerFunc</code>的索引<code class="fe ml mm mn mo b">index</code>。</p><p id="f30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，<code class="fe ml mm mn mo b">index</code>的默认初始值是<code class="fe ml mm mn mo b"><strong class="lb iu">-1</strong></code>。对于等于<code class="fe ml mm mn mo b">-1</code>的指数，可以看到<code class="fe ml mm mn mo b">reset()</code>的作用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么他在这里使用默认值-1？因为在<code class="fe ml mm mn mo b">handleHTTPRequest()</code>方法中，<code class="fe ml mm mn mo b">Gin</code>直接调用<code class="fe ml mm mn mo b">Next()</code>函数。</p><p id="4695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样<code class="fe ml mm mn mo b">c.index++</code>就可以得到<code class="fe ml mm mn mo b">0</code>的值，也就是开始执行第一个订阅的中间件。</p><p id="65e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你也可以默认手动执行中间件数组中的第0个中间件，所以不需要设置为<code class="fe ml mm mn mo b">-1</code>，可以设置默认值为<code class="fe ml mm mn mo b">0</code>，但是感觉没那么优雅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一点需要注意，属性<code class="fe ml mm mn mo b">index</code>的类型是<code class="fe ml mm mn mo b">int8</code>，我们知道<code class="fe ml mm mn mo b">int8</code>的长度范围是<code class="fe ml mm mn mo b">-128 ~ 127</code>。</p><p id="d6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以理论上<code class="fe ml mm mn mo b">Gin</code><strong class="lb iu">最多只能处理127 </strong> <code class="fe ml mm mn mo b">HandlerFunc</code>。</p><p id="aba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但实际情况是只能处理<code class="fe ml mm mn mo b">63</code>，接下来看看代码。</p><p id="0784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">Gin</code>使用<code class="fe ml mm mn mo b">use()</code>方法设置<code class="fe ml mm mn mo b">HandlerFunc</code>的嵌套。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="aa03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意上面代码中变量<code class="fe ml mm mn mo b">abortIndex</code>的值只有<strong class="lb iu"> 63 </strong>。</p><p id="aeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe ml mm mn mo b">Group()</code>函数被调用时，<code class="fe ml mm mn mo b">HandlerFunc</code>将被合并，在此确定最大数量，如果超过<code class="fe ml mm mn mo b">abortIndex</code>将报错。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fa07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">Use()</code>的功能很简单，只是在<code class="fe ml mm mn mo b">HandlersChain</code>后面加上<code class="fe ml mm mn mo b">HandlerFunc</code>。</p><p id="b793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何在上下文中实现对<code class="fe ml mm mn mo b">HandlerFunc</code>操作的调用？</p><p id="1a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案很简单，我们只需要调用<code class="fe ml mm mn mo b">Next()</code>函数，在这个方法内，当前上下文执行的索引会加1，然后执行下一个‘handler func’方法。</p><p id="b4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处是，当调用栈返回的索引大于<code class="fe ml mm mn mo b">HandlersChain</code>的大小时，不会重复执行。</p><p id="0ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，每次加一也保证了<code class="fe ml mm mn mo b">HandlerFunc</code>的顺序执行，因为底层是根据数组索引调用的。</p><p id="0aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="861a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们需要解释一下为什么需要执行<code class="fe ml mm mn mo b">c.index++</code>两次。</p><p id="2b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果存在一个有<strong class="lb iu"> 3个元素</strong>的数组，并且在执行完最后一个元素时，也就是下标等于<code class="fe ml mm mn mo b">2</code>时，顺序执行<code class="fe ml mm mn mo b">Next()</code>函数，如果没有第二版，就会导致<strong class="lb iu">死循环</strong>。</p><p id="dd04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为下标为2的时候是最后一个元素，他没有下一个可以执行的<code class="fe ml mm mn mo b">handler()</code>。</p><p id="6c8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环条件为<strong class="lb iu">索引小于数组长度</strong>，其中<code class="fe ml mm mn mo b"><strong class="lb iu">2 &lt; 3</strong></code>始终成立，进入无限循环。</p><p id="0564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这里加第二个<code class="fe ml mm mn mo b">c.index++</code>，当执行完最后一个元素，索引继续加1，最终值会是<code class="fe ml mm mn mo b">3</code>，循环退出。</p><p id="d11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈完了<strong class="lb iu">添加中间件</strong>和<strong class="lb iu">执行中间件</strong>，接下来就是实现一个功能，就是提前中断中间件。</p><p id="c0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我在一个签入中间件中失败了，并且想要直接返回到该中间件而不是继续，我需要尽早中断所有的中间件处理。</p><p id="9670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来看一下<code class="fe ml mm mn mo b">Gin</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里只需要将索引设置为最大值，因为每个<code class="fe ml mm mn mo b">HandlerFunc</code>在调用<code class="fe ml mm mn mo b">Next()</code>方法时都会对索引进行判断，索引超过要处理的函数的切片长度后就不会执行了。</p><p id="b663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们理解了<code class="fe ml mm mn mo b">Gin</code>的设计概念，让我们实现一个简单版本的中间件。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="2d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义上下文结构。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="06a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里面有两个关键要素<code class="fe ml mm mn mo b">handlers</code>和<code class="fe ml mm mn mo b">index</code>。</p><p id="2940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">handlers</code>用于存储我们对每个中间件的通用判断逻辑，也相当于一个一层一层的洋葱。</p><p id="943c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">index</code>用于存储我们当前正在执行的中间件数量。</p><p id="8e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用洋葱模型，这是我们目前正在剥离的层数。</p><p id="9315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义添加中间件的方法。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="79a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里非常简单，只需将<code class="fe ml mm mn mo b">handlers</code> pending函数添加到我们的上下文属性<code class="fe ml mm mn mo b">MyContext</code>中。</p><p id="a8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义执行方法。</strong></p><p id="e4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我有了add方法之后，我还需要有execute方法，它对应于在洋葱模型中剥离下一层洋葱的操作。</p><p id="37ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ml mm mn mo b">Gin</code>中这个方法被称为<code class="fe ml mm mn mo b">Next()</code>，这里我们使用相同的名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">开始使用。</strong></p><p id="8b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，准备好上面的一切，我们来测试一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行后的输出:</p><pre class="kj kk kl km gt mr mo ms mt aw mu bi"><span id="b2a6" class="mv mw it mo b gy mx my l mz na">[AuthMiddleware Start]</span><span id="c4ca" class="mv mw it mo b gy nb my l mz na">[LogHandle] start at: 1645605404</span><span id="772f" class="mv mw it mo b gy nb my l mz na">GET handler func</span><span id="5a34" class="mv mw it mo b gy nb my l mz na">cost 0.000006 second</span></pre><p id="9f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇文章。如果你在这篇文章中发现任何错误，请告诉我。</p></div></div>    
</body>
</html>