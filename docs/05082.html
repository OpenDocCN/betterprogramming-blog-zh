<html>
<head>
<title>Is This a Dependency or a DevDependency?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是依赖还是DevDependency？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-this-a-dependency-or-a-devdependency-678e04a55a5c?source=collection_archive---------1-----------------------#2020-06-07">https://betterprogramming.pub/is-this-a-dependency-or-a-devdependency-678e04a55a5c?source=collection_archive---------1-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在你的package.json中把npm模块放在哪里，并没有看起来那么简单。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/feea853cf81d4ff90951cd05f3f76aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qIToPGHzHmHiSuierEatA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bonniekdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bonnie Kittle </a>在<a class="ae ky" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几天前，有人打开了一个对<a class="ae ky" href="https://github.com/ItalyPaleAle/svelte-spa-router" rel="noopener ugc nofollow" target="_blank"> svelte-spa-router </a>的拉取请求——这是一个开源项目，我为用svelte框架构建的单页应用程序维护了一个客户端路由器——询问他们是否应该在<code class="fe lv lw lx ly b">package.json</code>文件中将该模块作为<code class="fe lv lw lx ly b">dependency</code>或<code class="fe lv lw lx ly b">devDependency</code>安装。</p><p id="17e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这个案例的特殊性，我认为总的来说这是一个很好的问题——值得讨论。什么时候我们应该把<code class="fe lv lw lx ly b">package.json</code>中的一个模块依赖作为<code class="fe lv lw lx ly b">devDependency</code>？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c30a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">医生怎么说</h1><p id="5490" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">实际上有关于把包放在哪里的官方指导，这清楚地写在<a class="ae ky" href="https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file" rel="noopener ugc nofollow" target="_blank"> npm文档</a>中。准确地说:</p><blockquote class="nd ne nf"><p id="4979" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">dependencies</code>:您的应用在生产中需要的包。</p><p id="0eac" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">devDependencies</code>:只需要本地开发和测试的包。</p></blockquote><p id="404f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，当一个模块只用于开发和测试时，你应该把它保存为一个<code class="fe lv lw lx ly b">devDependency</code>；其他都应该是个<code class="fe lv lw lx ly b">dependency</code>。你可能认为这是简单明了的指导，但是就像我的模块的用户一样，在现实生活中事情会变得模糊不清。</p><p id="e500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的答案是<em class="ng">看情况。</em>选择将每个模块放在哪里不仅取决于模块本身，还取决于您的应用程序——甚至取决于它的开发和部署方式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d133" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简单的时候…</h1><p id="1b31" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有一些明显的例子——或者几乎是。像<a class="ae ky" href="https://www.npmjs.com/package/eslint" rel="noopener ugc nofollow" target="_blank"> ESLint </a>这样的包<em class="ng">总是</em>一个<code class="fe lv lw lx ly b">devDependency</code>…当然，除非你正在构建一个CLI，它的工作就是运行ESLint，在这种情况下，你会把它添加为<code class="fe lv lw lx ly b">dependency</code>！</p><p id="cec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他(几乎)总是会成为<code class="fe lv lw lx ly b">devDependencies</code>的包包括:</p><ul class=""><li id="fa84" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">测试框架:<a class="ae ky" href="https://www.npmjs.com/package/mocha" rel="noopener ugc nofollow" target="_blank">摩卡</a>、<a class="ae ky" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank">超级测试</a>、<a class="ae ky" href="https://www.npmjs.com/package/nightwatch" rel="noopener ugc nofollow" target="_blank">夜巡</a>等。，以及它们的依赖关系如<a class="ae ky" href="https://www.npmjs.com/package/chromedriver" rel="noopener ugc nofollow" target="_blank"> ChromeDriver </a></li><li id="d266" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">代码覆盖工具，例如<a class="ae ky" href="https://www.npmjs.com/package/nyc" rel="noopener ugc nofollow" target="_blank"> nyc </a>和<a class="ae ky" href="https://www.npmjs.com/package/coveralls" rel="noopener ugc nofollow" target="_blank">套装</a></li><li id="a72c" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">Linters和代码格式化程序，例如已经提到的<a class="ae ky" href="https://www.npmjs.com/package/eslint" rel="noopener ugc nofollow" target="_blank"> ESLint </a>、<a class="ae ky" href="https://www.npmjs.com/package/tslint" rel="noopener ugc nofollow" target="_blank"> TSLint </a>，以及它们的插件/依赖项</li><li id="ef2c" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">用于本地开发的服务器，如<a class="ae ky" href="https://www.npmjs.com/package/serve" rel="noopener ugc nofollow" target="_blank"> serve </a>、<a class="ae ky" href="https://www.npmjs.com/package/http-server" rel="noopener ugc nofollow" target="_blank"> http-server </a>、<a class="ae ky" href="https://www.npmjs.com/package/sirv" rel="noopener ugc nofollow" target="_blank"> sirv </a>等等</li><li id="0394" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">文档工具，如<a class="ae ky" href="https://www.npmjs.com/package/jsdoc" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>和<a class="ae ky" href="https://www.npmjs.com/package/typedoc" rel="noopener ugc nofollow" target="_blank"> TypeDoc </a></li></ul><p id="43fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于运行在服务器端的Node.js应用程序，通常也是<em class="ng">清楚什么包应该是<code class="fe lv lw lx ly b">dependencies</code>。经验法则是，如果应用程序导入了一个模块(例如，用一个<code class="fe lv lw lx ly b">require('foo')</code>)，那么它应该是一个<code class="fe lv lw lx ly b">dependency</code>。其他都是<code class="fe lv lw lx ly b">devDependency</code>。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ca76" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">…如果不是这样</h1><p id="1518" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们处理客户端(在浏览器中运行)、预处理(例如，使用TypeScript)或两者兼有的应用程序时，答案就不那么明确了。</p><p id="a16d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些情况，我的建议是考虑模块在应用程序中的角色，以及应用程序是如何构建和部署的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0e82" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">客户端应用程序</h1><p id="8c68" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们从基于浏览器的应用程序开始。现代前端开发包括捆绑器、预处理器，有时还包括直接编译器。</p><p id="af02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该工具链通常至少包括一个捆绑器(<a class="ae ky" href="https://www.npmjs.com/package/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>、<a class="ae ky" href="https://www.npmjs.com/package/rollup" rel="noopener ugc nofollow" target="_blank"> Rollup </a>、<a class="ae ky" href="https://www.npmjs.com/package/parcel" rel="noopener ugc nofollow" target="_blank">package</a>等等)或一个任务运行器(比如<a class="ae ky" href="https://www.npmjs.com/package/grunt" rel="noopener ugc nofollow" target="_blank"> Grunt </a>)，外加一个前端框架，比如<a class="ae ky" href="https://www.npmjs.com/package/react" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae ky" href="https://www.npmjs.com/package/angular" rel="noopener ugc nofollow" target="_blank"> Angular </a>、<a class="ae ky" href="https://www.npmjs.com/package/svelte" rel="noopener ugc nofollow" target="_blank">svelet</a>或<a class="ae ky" href="https://www.npmjs.com/package/vue" rel="noopener ugc nofollow" target="_blank"> Vue </a>。此外，通常还有transpilers(如<a class="ae ky" href="https://www.npmjs.com/package/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>和<a class="ae ky" href="https://www.npmjs.com/package/babel" rel="noopener ugc nofollow" target="_blank"> babel </a>)或其他预处理程序(如CSS和JavaScript文件)。</p><p id="0285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的前端应用程序被捆绑时，就像svelte-spa-router的用户一样，您可能会想知道将应用程序的每个依赖项放在哪里。既然只在捆绑阶段使用，那么应该都是<code class="fe lv lw lx ly b">devDependencies</code>？</p><p id="f2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这种情况引入了很多主观性，我能给你的最好建议是看看你的申请，然后根据你的喜好得出你的结论。以下是一些想法和看法。</p><p id="386b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，看看<strong class="lb iu">应用程序是如何部署的</strong>。理想情况下，在生产服务器中，您希望只安装生产依赖项。如果您的前端应用程序与后端应用程序一起部署，并且在应用程序启动时捆绑在一起，那么捆绑器和工具链的其余部分应该作为<code class="fe lv lw lx ly b">dependencies</code>包含在内:事实上，它们是启动应用程序所需要的。</p><p id="e7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果前端应用程序是预先<strong class="lb iu">捆绑的</strong>，例如在持续集成(CI)服务器中或者甚至在开发人员的机器上，那么您可以考虑依赖关系。</p><p id="3bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格遵循官方文档，因为这些包只在构建时使用，它们应该被认为是<code class="fe lv lw lx ly b">devDependencies</code>。然而，在这样做的时候，你会以所有的包都是<code class="fe lv lw lx ly b">devDependencies</code>而结束，对我来说这感觉就像是打败了要点。</p><p id="402a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，在这种情况下，我的建议是将直接进入捆绑代码的包放到<code class="fe lv lw lx ly b">dependencies</code>块中。</p><p id="523b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如你前端应用导入的模块和框架本身(比如React，Angular，Vue，Svelte等。)，都将作为依赖关系放在<code class="fe lv lw lx ly b">package.json</code>文件中。捆扎机、预处理器、传输机等。反而会以<code class="fe lv lw lx ly b">devDependencies</code>的身份出现。</p><p id="daed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是，它清楚地表明了您实际上向您的用户发布了什么样的第三方代码，出于安全原因，这一点非常重要。事实上，它使得审计应用程序的软件供应链和评估依赖项的漏洞对项目的影响变得更加容易。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d9d1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">传输服务器端应用</h1><p id="ea60" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一种情况是使用transpiled的Node.js服务器端应用程序，比如当您使用TypeScript或babel时。</p><p id="8e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面的情况类似，我的建议是从了解应用程序是如何部署的开始。你会在部署之前还是之后运行transpilation？</p><p id="e50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您正在使用TypeScript，您会在部署应用程序之前或每次在服务器中启动应用程序时运行<code class="fe lv lw lx ly b">tsc</code>(TypeScript trans piler)作为构建步骤吗？</p><ul class=""><li id="29de" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">如果您在运行时运行transpiler来启动应用程序，那么transpiler本身和工具链的其余部分应该是<code class="fe lv lw lx ly b">dependencies</code></li><li id="27d6" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果您在部署应用程序之前预先构建了它，那么您可以将transpilers和工具链的其余部分作为<code class="fe lv lw lx ly b">devDependencies</code>。<br/>例如，当您使用构建服务器运行<code class="fe lv lw lx ly b">tsc</code>，在将传输的文件复制到服务器之前，您正在开发人员的机器上运行它，或者当您使用多阶段Docker-image构建，其中第一阶段运行<code class="fe lv lw lx ly b">tsc</code>时，就是这种情况。<br/>与上面前端应用的情况不同，transpilers一般不会捆绑代码(虽然可以)，所以代码中直接导入的所有模块都需要<code class="fe lv lw lx ly b">dependencies</code>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d5a0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">运送npm包</h1><p id="9ebd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上面的两个部分着眼于“完整的应用程序”，然后部署这些应用程序供最终用户访问。但是，如果我们正在处理一个要运送到npm的包呢？</p><p id="b268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们需要特别小心，让<code class="fe lv lw lx ly b">dependencies</code>的列表尽可能小。原因是当有人从npm安装你的包时，他们会安装所有的<code class="fe lv lw lx ly b">dependencies</code>而不是<code class="fe lv lw lx ly b">devDependencies</code>。</p><p id="e53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您使用的技术，npm上的包可以原样发布，不修改源代码(除了纯JavaScript项目之外，这包括前端组件，如React、Svelte等。)或者可以预先进行预处理。</p><p id="1c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，通常不在npm上发布TypeScript文件，而是发布transpiled JavaScript代码和类型定义文件。</p><p id="3722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论哪种情况，我的建议都是一样的:不管你用什么工具链(如果有的话)来构建/传输/打包你的代码，这些包都是以<code class="fe lv lw lx ly b">devDependencies</code>的形式存在的。</p><p id="2c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，如果你发布预处理代码，没有必要让你的用户安装你的预处理程序(transpilers，bundlers，等等)。).另一方面，如果您发布原始源代码，用户将需要使用他们自己的预处理程序，您仍然不应该让他们安装您用于模块开发和测试的东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cfde" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">总的来说，生活更加复杂</h1><p id="6177" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如您所看到的，决定什么去哪里并不像看起来那么简单。npm文档在两行中忽略了什么，我写了一整篇文章，并且我可能忽略了其他一些情况。</p><p id="c469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在一天结束的时候，上面所有的讨论可能都不重要。当你和许多其他人一起在一个大项目上工作时，包会不断地从<code class="fe lv lw lx ly b">package.json</code>文件中添加和删除，并且所有依赖项的适当卫生通常不是团队的首要任务。</p><p id="f97a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些情况下，你不能确定你所有的<code class="fe lv lw lx ly b">dependencies</code>和<code class="fe lv lw lx ly b">devDependencies</code>在任何时候都被放置在正确的位置。</p><p id="493c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">团队经常因过于谨慎而结束。在一个生产服务器上安装所有的包(包括<code class="fe lv lw lx ly b">devDependencies</code>)是一个简单的方法，可以消除很多<em class="ng">我的机器上的</em>类似的问题，节省调试时间。由于npm工具的进步，包括命令，安装依赖项不再像以前那样慢了。</p><p id="d6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，除非您确信每个依赖项都在正确的位置，否则最好以相同的方式对待依赖项中漏洞的所有安全警报，不管它们是针对<code class="fe lv lw lx ly b">dependency</code>还是<code class="fe lv lw lx ly b">devDependency</code>。</p></div></div>    
</body>
</html>