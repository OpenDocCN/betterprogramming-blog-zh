<html>
<head>
<title>Understanding JavaScript Event Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript事件循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-javascript-event-loops-6a972c35e509?source=collection_archive---------9-----------------------#2022-04-13">https://betterprogramming.pub/understanding-javascript-event-loops-6a972c35e509?source=collection_archive---------9-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cb0e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你有没有想过JavaScript是如何运行异步代码的，因为它是单线程语言？嗯，我也是！很疯狂，不是吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a272660f4e32a44bf17e34e8ba318bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V27F5HSpufxfNfZe-A2EdA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由pixabay.com的<a class="ae kv" href="https://pixabay.com/photos/santa-monica-pier-amusement-2438666/" rel="noopener ugc nofollow" target="_blank"/></p></figure><h2 id="cd9c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">JavaScript中的异步代码是什么？</h2><p id="6276" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">JavaScript中的异步代码可能作为<code class="fe ml mm mn mo b">setTimeout</code>或<code class="fe ml mm mn mo b">setInterval</code>函数的回调、click或hover等事件的事件回调、HTTP请求的回调或promise回调出现。</p><h2 id="18a1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">异步代码是如何执行的？</h2><p id="ced3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在多线程框架中，在异步函数的情况下，可能会分配一个新线程，到时候，代码将由这个额外的线程执行。同时，其他线程可以执行代码的不同部分。<br/>另一方面，在单线程框架中，我们没有这样做的资源。那么它如何运行异步代码呢？</p><p id="9331" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">为了理解这一点，我们需要理解我们所说的这个单线程框架是什么。嗯，是JavaScript引擎，它是一个执行JavaScript代码的软件组件。浏览器有多个软件来完成多个任务，浏览器支持的最常见的功能之一是Web APIs。神奇的是:</p><p id="c0ff" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">虽然浏览器的JavaScript引擎是单线程的，但浏览器应用程序本身不是单线程的，因此可以分配不同的线程来处理Web API函数。</p><p id="2be1" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">Web API函数有哪些？点击事件、地理位置服务、计时器、HTTP请求等。</p><p id="397d" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">现在，我们知道我们有几个线程，一个用于JS引擎，它自己执行JS代码，其他的用于处理Web API函数，我们仍然需要理解它是如何作为异步函数实现的？这就是事件队列发挥作用的地方。</p><h2 id="9b4f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是事件队列？</h2><p id="837e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">一连串的动作。对于所有队列，事件队列被实现为先进先出。进入队列的第一个动作将首先弹出。一旦Web API线程完成了它必须做的操作(调用了计时器，返回了HTTP请求，等等)，这些操作就被输入到队列中，然后它会将相关的回调操作插入到事件队列中。有两种方法可以将操作弹出事件队列。</p><ol class=""><li id="9816" class="mu mv iq lu b lv mp ly mq lf mw lj mx ln my mk mz na nb nc bi translated">每次调用栈变空时，JS引擎将检查事件队列中是否有等待的操作，如果有，它将把它添加到调用栈中。</li><li id="0c16" class="mu mv iq lu b lv nd ly ne lf nf lj ng ln nh mk mz na nb nc bi translated">每次向事件队列添加操作时，JS引擎都会检查调用堆栈是否为空，如果是，它会将操作传递给调用堆栈。</li></ol></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="8549" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">让我们看看下面的例子:</p><h2 id="ea31" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第一个例子</h2><p id="ca24" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当调用堆栈为空时，一个操作被添加到事件循环中，并立即转移到调用堆栈。</p><pre class="kg kh ki kj gt np mo nq nr aw ns bi"><span id="36cd" class="kw kx iq mo b gy nt nu l nv nw">console.log("Hi, there");<br/>setTimeout(()=&gt; <br/>    console.log("I'm Tom"), 3000);<br/>console.log("I'm Jerry!");</span></pre><p id="0093" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">首先发生的是，第一行将从调用堆栈中弹出并被执行。</p><pre class="kg kh ki kj gt np mo nq nr aw ns bi"><span id="5c6f" class="kw kx iq mo b gy nt nu l nv nw">&gt;&gt; Hi, there</span></pre><p id="3a2c" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">现在，将弹出下一个命令— <code class="fe ml mm mn mo b">setTimeout</code>，正如前面提到的，这是一个Web API支持的功能。所以浏览器现在创建一个新线程，在执行计时器的回调之前数到3。<br/>接下来，将弹出并执行第三个命令，现在我们来看看</p><pre class="kg kh ki kj gt np mo nq nr aw ns bi"><span id="d21a" class="kw kx iq mo b gy nt nu l nv nw">&gt;&gt; Hi, there<br/>&gt;&gt; I'm Jerry</span></pre><p id="6031" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">三秒钟后，Web API将完成它的三秒钟倒计时，超时回调将被推送到事件队列。<br/>由于在这个阶段调用栈是空的，动作将立即转移到调用栈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/d4ac62486e55b78b2946aee0474b1ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2BUMdNF9AeTvt9TPYMCvug.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">希拉·克莱斯勒的GIF</p></figure><h2 id="fe16" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第二个例子:</h2><p id="41f6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">一个操作进入事件队列并在那里等待，直到调用堆栈为空。</p><pre class="kg kh ki kj gt np mo nq nr aw ns bi"><span id="f92e" class="kw kx iq mo b gy nt nu l nv nw">this.http.get("<a class="ae kv" href="http://www.tomAndJerry.com/getJerry" rel="noopener ugc nofollow" target="_blank">www.tomAndJerry.com/getJerry</a>");<br/>FourSecCalculation();<br/>ThreeSecCalculation();<br/>TwoSecCalculation();</span></pre><p id="aedc" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">第一个动作是HTTP请求，这是另一个Web API操作。这个请求将由Web API线程执行和处理，而下一个动作将从调用堆栈中弹出，并使JavaScript引擎保持忙碌4秒钟。之后，将触发一个耗时3秒的动作，然后触发一个耗时2秒的动作。</p><p id="079e" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">与此同时，HTTP请求将返回一个响应，Web API将在事件队列中添加动作，在事件队列中，它将一直等到调用堆栈为空。</p><p id="7a8d" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">只有在两秒钟的计算执行完成后——调用堆栈将变空，JavaScript引擎才会检查事件队列中是否有操作正在等待。在那里，它将找到HTTP响应动作，并将它插入到调用堆栈中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/db24289228e1bac60d83ce95809b27cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ckZA1k0hqIEYbTHVZK_aKQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">希拉·克莱斯勒的GIF</p></figure><p id="bc7e" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">总而言之JavaScript引擎确实是单线程的，但是它使用其他服务来处理外部动作/API。一旦一个外部服务(比如Web API)完成了它的任务，它就会在事件队列中插入一个回调动作。</p><p id="26b1" class="pw-post-body-paragraph ls lt iq lu b lv mp jr lx ly mq ju ma lf mr mc md lj ms mf mg ln mt mi mj mk ij bi translated">动作将在队列中等待，直到调用栈为空，然后它将被传递给调用栈并被执行——这就是我的朋友们，异步动作是如何在JS中实现的。</p></div></div>    
</body>
</html>