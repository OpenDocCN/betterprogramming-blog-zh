<html>
<head>
<title>Android Jetpack Compose — Create a Component-Based Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Jetpack Compose——创建基于组件的架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-component-based-architecture-in-android-jetpack-compose-96980c191351?source=collection_archive---------2-----------------------#2020-03-17">https://betterprogramming.pub/create-a-component-based-architecture-in-android-jetpack-compose-96980c191351?source=collection_archive---------2-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以不同的方式思考你的用户界面，以声明性函数和相应架构的形式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96e0df2474b949cc67cf639e33a54397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ed1nGW0Qw9nYaE7Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@foxfox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">娜塔莉亚Y </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动机:你可能运行过像网飞/亚马逊Prime这样的应用程序，其中一个单独的屏幕包含许多视图，这些视图可以在整个应用程序中重复使用。例如，考虑亚马逊Prime视频应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/e467fb57e0c981d20272f74768c16793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmOEDyk1VKm7nhLxPmhKUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚马逊Prime视频的主屏幕</p></figure><p id="5bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑主屏幕，<em class="lw"> </em>，它包含一个接一个堆叠在另一个下面的<em class="lw">观看下一部电影、惊悚电影</em>、<em class="lw">推荐电影</em>和<em class="lw">最新电影</em>的列表。以上都有相同的UI，不同的数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/8a2215edef2821fb1a4d1d9d07a88e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNYQ8BYWjk85gdFKVwNz9A.png"/></div></div></figure><p id="7ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑电影屏幕，<em class="lw"> </em>包含电影的概述，在它下面，您可以找到<em class="lw">客户也观看了</em>部分。这与主屏幕上使用的UI相同<em class="lw">。</em>因此，部分视图在整个应用程序中被重用。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4266" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">设计屏幕</h1><p id="6f92" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">你会如何设计这样的屏幕？</p><h2 id="2a7a" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated"><strong class="ak">天真的方式</strong></h2><p id="495b" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">创建上述屏幕的一种方法是对每个屏幕的视图进行硬编码。但是我们遇到了问题。</p><p id="91ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们的领域或表示层不能有改变视图的逻辑。如果我们只是想在屏幕的UI中添加一些类似演职人员的东西，我们最终会改变很多文件。</p><p id="9fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，重复的问题。</p><p id="b350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的方法，我们最终会复制代码来在主屏幕和电影屏幕上呈现电影列表。当你听到<em class="lw">重复</em>的时候，我们把它们移到一个平常的地方。</p><p id="3720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用建议的架构(如下)，我们可以通过将重复代码放在一个普通的叫做<em class="lw"> UIComponents </em>的地方来克服上述问题。</p><h2 id="f67c" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated"><strong class="ak">什么是UIComponents？</strong></h2><p id="ff41" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">可以被<em class="lw">重用</em>和<em class="lw">独立</em>的UI片段称为<em class="lw"> UIComponents </em>。你可以把它们插在任何屏幕上的应用程序的任何地方，你就可以开始了。</p><h2 id="c544" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated"><strong class="ak">什么是基于组件的架构？</strong></h2><p id="6a86" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这里，一个活动的屏幕是由一堆可重用的UIComponents组成的。活动不负责在其XML文件中创建视图。相反，它只包括UIComponents。</p><p id="faf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们只关注在屏幕上呈现UIComponents。稍后，我们在这里看处理UIComponents与外界的交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0bd148d6cbbe29e919f77b1125bd9979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kx_8A-VBkO8-L84qfKNcDQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">电影屏幕ui组件</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8ec2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> Android Jetpack撰写</strong></h1><p id="644a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><a class="ae ky" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>是一个设计工具包，用于简化Android中的UI开发。它是完全声明性的，意味着您通过调用一系列函数<em class="lw">来描述您的UI，这些函数</em>将数据转换成UI层次结构——定义<a class="ae ky" href="https://codelabs.developers.google.com/codelabs/jetpack-compose-basics/#0" rel="noopener ugc nofollow" target="_blank"/></p><p id="6771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Jetpack Compose中，视图是可组合的函数。</p><p id="2d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您在Jetpack Compose中定义视图的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="0802" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Jetpack组件中基于组件的体系结构</h1><p id="ba64" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">本文的剩余部分将分成三个部分，并包含一些代码。</p><ol class=""><li id="062b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">定义/构建UIComponents。</li><li id="cc83" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">通过提供UIComponent所需的数据，由我们的<code class="fe of og oh oi b">ViewModel</code>创建ui component。</li><li id="e26c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">将UIComponents合并到Jetpack组合活动中。</li></ol><p id="8f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序不同层的相互连接如下所示。我们以后会随机应变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3098b6a3bcd596a61b3bc9fd5597a824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1kQxsMnRnw3Y82JYlog0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Android Jetpack compose中基于组件的架构</p></figure><p id="a71a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本演示的目的，我们将创建一个具有以下屏幕的应用程序:</p><ol class=""><li id="ec80" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">主屏幕，播放热门/顶级电影。</li><li id="6ab2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">电影详细信息屏幕，包括电影概述、演员/工作人员、推荐电影和类似电影。</li></ol></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7cd6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 1。构建ui组件</strong></h1><p id="7ae3" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">一个方便的可组合视图的可组合函数类型别名。(记得吗？视图是可组合的函数。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIComponent接口将由所有ui component实现。这是我们UIComponent的基本版本。当我们开始处理交互时，我们会修改它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地适应我们的目的，也为了更好地解释事情，我们将建造一个<code class="fe of og oh oi b">MovieDetailScreen</code>。它具有以下ui组件:</p><ul class=""><li id="67f4" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oj nx ny nz bi translated">电影概述(<code class="fe of og oh oi b">MovieOverviewUIComponent</code>)</li><li id="5949" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oj nx ny nz bi translated">电影演员阵容(<code class="fe of og oh oi b">CastListUIComponent</code></li><li id="ab6a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oj nx ny nz bi translated">电影剧组(<code class="fe of og oh oi b">CrewListUIComponent</code>)</li><li id="b2e4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oj nx ny nz bi translated">类似电影(<code class="fe of og oh oi b">MovieListUIComponent</code>)</li><li id="4544" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oj nx ny nz bi translated">推荐电影(<code class="fe of og oh oi b">MovieListUIComponent</code>)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/861e588bb980f335440ebe47d59ad957.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*AWEp0e4ibcUIydRz7CB1qA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有电影概览、演员表和剧组名单的上部屏幕</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ceb2e46772dda89dca5ffa380e2e9896.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*4b1o6Xpy4khy3lmHkt05Qw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">底部屏幕显示相似和推荐的电影</p></figure><p id="8e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将构建可用于在屏幕上渲染类似电影和推荐电影的<code class="fe of og oh oi b">MovieListUIComponent</code>。</p><p id="da98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为垂直和水平滚动添加两个扩展函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a11e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来造一个<code class="fe of og oh oi b">MovieListUIComponent</code>。</p><p id="41c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.设计<code class="fe of og oh oi b">MovieView</code>(可组合)。这将是一个可组合的函数。温馨提示:视图是Jetpack Compose中的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="48bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.接下来，我们创建一个水平滚动的电影列表— <code class="fe of og oh oi b">HMovieListView.kt</code> <em class="lw">。</em>我们将使用之前创建的扩展函数(<code class="fe of og oh oi b">HStack</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f8dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.既然已经创建了<code class="fe of og oh oi b">View</code>，我们可以创建一个<code class="fe of og oh oi b">MovieListUIComponent</code>。组件从<code class="fe of og oh oi b">ViewModel</code>接收其数据(<code class="fe of og oh oi b">movieList</code>)。该数据由<code class="fe of og oh oi b">HMovieListView</code>使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一部分已经结束，我们已经创建了UIComponents。你可以在<a class="ae ky" href="https://github.com/AnupAmmanavar/MovieBrowsing/tree/master/jetpackui/src/main/java/com/kinley/jetpackui/jetcompose" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得完整的代码。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="41b6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 2。构建表示层</strong></h1><p id="8fcc" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">注意:下面的代码实际上比你在这里看到的更简单。</p><p id="bf1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.让我们创建一个数据类来保存UI的数据，<code class="fe of og oh oi b">MovieDetailPageUiModel</code>。它是不可变的(都是<code class="fe of og oh oi b">val</code> s)。我们使用减速器来更新状态。它包含了视图所需的所有UIComponents。下面看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.在<code class="fe of og oh oi b">ViewModel</code>中，这将是<code class="fe of og oh oi b">MutableLiveData</code>。这保存了特定Jetpack编写活动的完整状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe of og oh oi b">ViewModel</code>是数据持有者，负责创建UIComponents。正如前面指出的，<code class="fe of og oh oi b">ViewModel</code>从多个数据源(API或持久性)获取数据，这是创建组件所必需的。</p><p id="6d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们获得数据时，我们创建我们的UIComponents并更新(减少)我们的<code class="fe of og oh oi b">mutableLiveData</code>。</p><p id="f3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:当我们获取推荐的电影时，我们创建<code class="fe of og oh oi b">MovieListUIComponent</code>并更新<code class="fe of og oh oi b">movieDetailPageUiModel</code>中的<code class="fe of og oh oi b">recommendedMoviesListUIComponent</code>值。</p><p id="59a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这适用于<code class="fe of og oh oi b">movieDetailPageUiModel</code>中的所有值。看一下代码，它清楚地表明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ae28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！你可以在GitHub 上看看我们完整的<code class="fe of og oh oi b">ViewModel</code> <a class="ae ky" href="https://github.com/AnupAmmanavar/MovieBrowsing/tree/master/app/src/main/java/com/kinley/moviebrowsing/features" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="40a5" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 3。构建最后一部分—视图(Jetpack撰写活动)</strong></h1><p id="fb27" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">目标:活动应该像<code class="fe of og oh oi b">RecyclerView</code>一样以垂直方式呈现所有的UIComponents。目前，我们通过使用<code class="fe of og oh oi b">VStack</code>来模仿<code class="fe of og oh oi b">RecyclerView</code>。但是你要考虑用<code class="fe of og oh oi b">AdapterList</code>。</p><ol class=""><li id="8e8a" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">在我们的<code class="fe of og oh oi b">MovieDetailPageView</code>中，我们有一个垂直滚动条来垂直呈现所有的ui组件。视图观察数据的变化并自我更新。</li></ol><p id="2e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们是如何遍历UIComponents列表并以垂直方式呈现它们的。(类似于一个<code class="fe of og oh oi b">RecyclerView</code>中的多个视图类型，其中每个UIComponent是一个不同的视图类型。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.继续上述观点。在<code class="fe of og oh oi b">HomePageUIModel</code>中将需要一个小的改变。我们添加了一个返回UIComponents列表的函数(<code class="fe of og oh oi b">components()</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ca93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.观察<code class="fe of og oh oi b">HomePageUIModel</code>(我们的<code class="fe of og oh oi b">ViewModel</code>中的<code class="fe of og oh oi b">pageData</code>)并在它变化时更新视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="118b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看看GitHub 上的代码<a class="ae ky" href="https://github.com/AnupAmmanavar/MovieBrowsing/blob/master/app/src/main/java/com/kinley/moviebrowsing/screens/MovieDetailActivity.kt" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="cdd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">服务器驱动的UI: </strong>另外，我们可以通过API响应来驱动UI。我们没有在ViewModel中创建UIComponents，而是将它移动到一个公共位置，如下所示。UIComponents是基于服务器响应创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="1393" class="mf mg it bd mh mi ol mk ml mm om mo mp jz on ka mr kc oo kd mt kf op kg mv mw bi translated"><strong class="ak">结论</strong></h1><p id="0bb1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">接下来，我们可以将UIComponents移到一个单独的库中，该库可以跨不同的应用程序重用。</p><p id="ba0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们只在屏幕上显示了UIComponents。在下一篇文章中，将处理UIComponents click事件上的交互👇🏼。</p><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/how-to-handle-user-interactions-with-component-based-architecture-and-jetpack-compose-196e8cdd1aee" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">如何使用基于组件的架构和Jetpack Compose处理用户交互</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">使UIComponents与ComposeActivity交互</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>