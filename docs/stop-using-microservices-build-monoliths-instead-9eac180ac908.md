# 停止使用微服务。而是建造巨石。

> 原文：<https://betterprogramming.pub/stop-using-microservices-build-monoliths-instead-9eac180ac908>

## 为什么大多数公司避免微服务会更好

![](img/12af89b596780ee677bb511262037d1c.png)

照片由 [**罗伯特纳吉**](https://www.pexels.com/@robert-nagy-512974?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 发自 [**Pexels**](https://www.pexels.com/photo/puzzled-gamer-in-illuminated-room-3930070/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

微服务似乎是完美的解决方案。

理论上，它们提高了开发速度，同时允许您独立扩展应用程序的不同部分。

但现实中，微服务是有隐性成本的。也就是说，我不认为没有第一手的构建，你就能真正理解它们的复杂性。

以下是我用微服务构建(有时会失败)时学到的东西。

# 管理数据是一场噩梦

保持微服务之间的数据同步是一项挑战。

每个微服务一个数据库是推荐的模式。它允许松散耦合，并允许特定于服务的团队独立工作，而不会减慢在共享代码上的协作。

但是，当两个应该同步启动的微服务中的一个失败时，会发生什么呢？例如，其中一个微服务更新其数据库，而另一个不更新。

这种情况会造成数据不一致。

从个人经验来看，调查跨服务的数据不一致可能是痛苦的。错误的跨服务性质要求一个人跨越多个服务来纠正错误。不幸的是，这使得微服务的优势之一——特定于团队的服务——开始失效。

通过将两个 DB 调用封装在一个原子事务中，可以很容易地避免在单个应用程序中出现同样的情况，因此所有的插入要么成功，要么都失败。很简单。

但是对于微服务来说，松散耦合使这变得更加困难。

# 更多时间准备

构建微服务架构比将相同的功能整合到一个整体中需要更长的时间。

虽然单个服务很简单，但是交互的服务集合要比类似的整体复杂得多。

monolith 中的函数可以调用任何其他公共函数。但是微服务中的函数仅限于调用同一微服务中的函数。

这需要服务之间的通信。构建 API 或消息传递系统来实现这一点并不容易。

此外，跨微服务的代码重复是无法避免的。monolith 可以一次定义一个模块并多次导入，而微服务是它自己的应用程序——每个应用程序都需要定义模块和库。

# 微服务最适合大型团队

将微服务分配给单个团队是大型工程部门的特权。

尽管这是该架构的一大优势，但只有当你有足够的工程人员为每项服务投入几名工程师时，这才是可行的。缩小开发人员的代码范围给了他们更好地理解代码的带宽，并提高了开发速度。

但大多数创业公司都没有这个闲心。

在没有足够资源的初创公司，一些工程师需要跨所有服务部门工作。

不幸的是，这降低了工作效率，因为应用程序之间的切换可能是一个严重的上下文切换。

我发现调查我已经有一段时间没做的微服务中的 bug 很累人。

# DevOps 更复杂

选择微服务的最有说服力的原因之一是能够在不同类型的服务器上运行不同的服务。

为什么？与训练机器学习模型的服务相比，React 前端可以具有非常不同的内存、CPU 和运行时间要求。为每项服务选择合适的基础设施类型可以大幅降低成本。

但是它也有自己的挑战。

举个例子:在我职业生涯的早期，我曾经丢失了大量的生产数据，因为我忘记重启一个我更新了代码的服务。过时的代码通过 API 请求接收数据，但随后无声地失败了，而不是将其记录在其数据库中。这些数据永远丢失了。

我给出这一点是为了说明，与单个单片应用程序相比，配置、维护和监控多个微服务需要更多的工作。拥有多个应用程序也增加了黑客的攻击媒介。

理论上，“松散耦合”服务允许每个服务在其他服务失败时继续运行。但是这只是一厢情愿的想法——对于有客户的复杂业务来说，真正的松耦合几乎是不可能的。

最终，你的应用架构的可靠性取决于最薄弱的环节。移动的棋子越多，出错的机会就越大。

# **外卖**

很多公司使用微服务，但实际上并不需要。尽管微服务目前很受欢迎，但它并不适合新手。

大多数公司会更好地构建一个整体，然后在绝对必要时将整体分割成微服务。

让财大气粗的大型科技公司从头开始开发微服务架构。

你的早期创业可能还没有准备好。我的不是，它花费了我们大量的时间和精力。