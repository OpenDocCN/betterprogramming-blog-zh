<html>
<head>
<title>6 Swifty Ways of Writing Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6种快速编写代码的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-swifty-ways-of-writing-code-f260286a0dbb?source=collection_archive---------5-----------------------#2020-05-25">https://betterprogramming.pub/6-swifty-ways-of-writing-code-f260286a0dbb?source=collection_archive---------5-----------------------#2020-05-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3ccf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一些鲜为人知的技巧和窍门来提升你的iOS开发技能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/cb87a2ab4ba583b484364b1bcc972226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HS36F1AwM03-x2G0"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克🎞</a>开<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">退溅</a>。</p></figure><p id="d576" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多年来，Swift经历了显著的发展。它提供了类型安全，并且比许多语言更简洁。随着功能数量的不断增加，了解并跟踪一些很酷的技巧正成为一种挑战。</p><p id="e475" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我将带您了解一些快速编写代码的方法。我希望它能帮助你构建更好的iOS应用程序。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="cc89" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用地图安全地打开选装件</h1><p id="e74e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通常，我们使用<code class="fe na nb nc nd b">if let</code>或<code class="fe na nb nc nd b">guard let</code>语法在Swift中安全地打开选项。虽然这一切都很好，但有时您希望有一种没有这些括号的方法——尤其是当您打开一个子属性时。幸运的是，我们可以使用map操作符打开选项。</p><p id="56c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe na nb nc nd b">map</code>闭包内传递的可选值只有在包含某个值时才会被计算，从而确保它不是<code class="fe na nb nc nd b">nil</code>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/34627aa626c064df2ca100363f993a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PurYnuOYcw0fcYBPyQZGMQ.png"/></div></div></figure><p id="388a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在可选元组中使用映射展开也很方便。这里有一个快捷的方法:</p><pre class="kk kl km kn gu nf nd ng nh aw ni bi"><span id="e729" class="nj me iu nd b gz nk nl l nm nn">func sampleTuple() -&gt; (String, String)?{<br/>    return nil<br/>}</span><span id="a7f6" class="nj me iu nd b gz no nl l nm nn">let (a, b) = sampleTuple().map { ($0, $1) } ?? ("NA", "NA")</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c88b" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">初始化时调用willSet和didSet</h1><p id="2568" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">简而言之，当属性首次初始化时，<code class="fe na nb nc nd b">willSet</code>和<code class="fe na nb nc nd b">didSet</code>属性观察器不会被调用。但是您可以通过将初始化包装在一个<code class="fe na nb nc nd b">defer</code>语句中来解决这个问题。</p><p id="9353" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管这种方法有点儿不太好<em class="np">因为你必须以某种方式设置一个默认值(在声明中或者在defer之外),但是知道这一点还是有好处的:</em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/9fa2c789dae1243589d8ec545a9ad3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pe_kpR9vu38xJuHSsBxCog.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="461e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">为默认实现使用协议扩展</h1><p id="1577" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Swift协议很强大，但是它们不允许您指定默认实现。当您希望避免覆盖函数时，这可能会很方便。</p><p id="1e53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，您可以在扩展中使用<code class="fe na nb nc nd b">where</code>子句来指定某些约束的协议实现。但是要确保不要在代码库中过度扩展协议。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/16582a29da27b48c558a207303a270d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*539NsNCzFRNBx6vQHcyv3g.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8c5f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">轻松跟踪字典中的更改</h1><p id="a21f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">可能会有这样一种情况，您想知道Swift字典中发生了什么变化(可能是为了调试)。单调乏味的方法是改变内容。但是也有一种快速的方法。只需在保存字典对象上定义一个下标，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/b027459eae31052d2029fe2dfccd0ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDEi7NMDpCe1bQqWwLEzdA.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a917" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">在不同范围内使用保护字母</h1><p id="77af" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">guard let</code>语句使用安全的故障优先方法，其中<code class="fe na nb nc nd b">nil</code>值确保您立即返回。但有时，使用<code class="fe na nb nc nd b">return</code>并不符合我们的最佳利益。例如，你可能在一个For循环中，并且只希望<code class="fe na nb nc nd b">continue</code>或<code class="fe na nb nc nd b">break</code>。很高兴，你可以这样做:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/4b2d35311d2d2d5734d01eef083dab9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ki1C6Ve-selcspXeMo3VOg.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="86b4" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用重新抛出进行强大的错误处理</h1><p id="f820" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">我们都知道并使用<code class="fe na nb nc nd b">throws</code>关键字，但很少在Swift中利用<code class="fe na nb nc nd b">rethrows</code>的力量。用<code class="fe na nb nc nd b">rethrows</code>关键字声明的函数表明，只有当它的一个函数参数<code class="fe na nb nc nd b">throws</code>出现错误时，它才会抛出错误。</p><p id="9dbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着如果闭包参数不抛出错误，我们在调用它时就不需要使用不同风格的<code class="fe na nb nc nd b">try</code>。Swift让我们使用这种优雅的方式来显著减少样板代码。正如您在下面的代码中所看到的，我们不需要在<code class="fe na nb nc nd b">do-catch</code>块中放置相同的非抛出版本的函数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ne"><img src="../Images/77efb0de435d0c31f0a685186aee9bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uaqlfFWsKA7tLUNz7j7zA.png"/></div></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e476" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="754a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这一次到此为止。感谢阅读，我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>