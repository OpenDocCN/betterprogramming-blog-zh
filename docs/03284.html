<html>
<head>
<title>JavaScript Best Practices: Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践:对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-objects-94da46f7cc13?source=collection_archive---------14-----------------------#2020-01-31">https://betterprogramming.pub/javascript-best-practices-objects-94da46f7cc13?source=collection_archive---------14-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c31b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们在定义对象时会陷入的陷阱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6acaf2a6b36d9f81af2ad730582cdd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dM3lnQQBamM62ewM8t__3g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@gissur1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Gissur Steinarsson </a>在<a class="ae ky" href="https://unsplash.com/s/photos/puffin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以有很多东西要避免。我们可以很容易地遵循一些最佳实践，使我们的JavaScript代码易于阅读。</p><p id="2aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们看看如何以一种易于维护的方式处理对象。当我们定义对象的时候，我们会遇到一些陷阱。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5054" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对原始值使用文字</h1><p id="d8a1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在JavaScript中，有多种方法来声明原始变量。原始变量包括除对象以外的任何类型的变量。</p><p id="d367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是像这样使用文字:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a0f5" class="ne md it na b gy nf ng l nh ni">let x = 1;<br/>let y = true;<br/>let z = '';</span></pre><p id="1047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们为每个变量设置了数字、布尔和字符串的文字值。</p><p id="0b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="48be" class="ne md it na b gy nf ng l nh ni">let x = new Number(1);<br/>let y = new Boolean(true);<br/>let z = new String('');</span></pre><p id="9e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7196" class="ne md it na b gy nf ng l nh ni">let x = Number(1);<br/>let y = Boolean(true);<br/>let z = String('');</span></pre><p id="2703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面声明原始变量的三种方法中，有些方法比其他的好。最好的方法是直接设置文字。另一种方法是使用第三个例子中的函数。</p><p id="52dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们不应该使用构造函数来创建具有原始值的变量？首先，用<code class="fe nj nk nl na b">new</code>操作符定义的任何东西都有类型‘object ’,即使它们有原始值。这使得这些对象之间的比较变得困难。</p><p id="e49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8b0e" class="ne md it na b gy nf ng l nh ni">new String('foo') === new String('foo')</span></pre><p id="f81d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe nj nk nl na b">false</code>,因为它们都是‘object’类型，如果两个对象在JavaScript中没有相同的引用，<code class="fe nj nk nl na b">===</code>将计算为<code class="fe nj nk nl na b">false</code>。这意味着比较是困难的。</p><p id="4bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe nj nk nl na b">==</code>对比也会因为同样的原因评估到<code class="fe nj nk nl na b">false</code>。</p><p id="48f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它们都是“object”类型，所以很难知道它们实际上是字符串、布尔值还是数字。</p><p id="2aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外两种方法要好得多，因为它们会给我们找到合适的类型。例如，下面的代码将得到类型“number”:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="613c" class="ne md it na b gy nf ng l nh ni">let x = 2;<br/>console.log(typeof x);</span></pre><p id="34fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于其他原始数据类型。</p><p id="c7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有理由使用<code class="fe nj nk nl na b">new</code>操作符来声明具有原始值的事物。这只会让生活更加艰难。</p><p id="c486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nj nk nl na b">new</code>也比较慢，因为JavaScript解释器必须比必要的多做一次操作来声明具有“object”类型原语的东西。</p><p id="1e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">Number</code>、<code class="fe nj nk nl na b">String</code>和<code class="fe nj nk nl na b">Boolean</code>函数对于将对象从一种类型转换为另一种类型很有用。例如，如果我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="32a6" class="ne md it na b gy nf ng l nh ni">let x = '2';</span></pre><p id="6459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以用<code class="fe nj nk nl na b">Number</code>函数把它转换成一个数字，如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="563c" class="ne md it na b gy nf ng l nh ni">let y = Number(x);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="044b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">只要对象存在，就使用文本来声明它们</h1><p id="d3a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些对象有相关的文字。例如，数组有<code class="fe nj nk nl na b">[...]</code>文字。正则表达式可以用带斜线的环绕模式来声明。函数可以用<code class="fe nj nk nl na b">function</code>关键字或粗箭头来声明。</p><p id="a8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用构造函数定义值有时会让人感到困惑。例如，数组有两个构造函数。一个有一个参数，参数是数组长度。另一个是逗号分隔的条目列表。</p><p id="ccb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着<code class="fe nj nk nl na b">Array(1)</code>将得到一个空数组，其中<code class="fe nj nk nl na b">length</code>为1，没有内容。另一方面，<code class="fe nj nk nl na b">Array(1,2,3)</code>会得到我们<code class="fe nj nk nl na b">[1,2,3]</code>。</p><p id="cf6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，使用构造函数来声明数组并不清楚。</p><p id="22f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于函数，我们有<code class="fe nj nk nl na b">function</code>关键字或<code class="fe nj nk nl na b">Function</code>构造函数。</p><p id="b059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nj nk nl na b">Function</code>构造函数没有意义，因为我们必须传递包含函数代码的字符串和参数名称的字符串。它为代码注入攻击打开了方便之门，将代码写成字符串是一件痛苦的事情。</p><p id="fa7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">function</code>关键字就清楚多了。它让我们能够编写被文本编辑器识别为功能代码的代码。没有理由用<code class="fe nj nk nl na b">Function</code>构造函数来声明一个函数，除非我们想定义一个有动态代码的函数。</p><p id="978c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe nj nk nl na b">RegExp</code>构造函数适合动态构造正则表达式对象，但在其他方面与正则表达式文字相同。对于静态正则表达式，正则表达式文字和构造函数是相同的，所以构造函数有一些用处。</p><p id="f22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">Object</code>构造函数只是让我们键入比对象文字更多的代码；否则，他们是一样的。这意味着用它来声明对象是没有意义的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动类型转换</h1><p id="50f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于原始值，JavaScript可以根据上下文将事物转换为不同的类型。</p><p id="7d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d255" class="ne md it na b gy nf ng l nh ni">1 == '1'</span></pre><p id="a24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么字符串1将被转换成一个数字。</p><p id="74dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3166" class="ne md it na b gy nf ng l nh ni">1 + '1'</span></pre><p id="5c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后数字1将被转换成一个字符串，这样我们就得到了<code class="fe nj nk nl na b">'11'</code>。JavaScript只是假设我们在连接。</p><p id="c6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，假设我们写道:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f3cc" class="ne md it na b gy nf ng l nh ni">1 - '1'</span></pre><p id="3502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到0，因为它假设我们正在减去两个数字。</p><p id="ab95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们写道:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e491" class="ne md it na b gy nf ng l nh ni">1 - 'a'</span></pre><p id="dc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为结果不是一个数字，我们得到<code class="fe nj nk nl na b">NaN</code>,因为我们不能用一个非数字字符串减去一个数字。</p><p id="2af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算结果为布尔值的表达式中，内部的变量或值被计算为它们的真值或假值。</p><p id="711e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Falsy值包括:</p><ul class=""><li id="7cdd" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi">0</li><li id="2be2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">null</code></li><li id="fa32" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">undefined</code></li><li id="e83d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">空字符串</li><li id="aa88" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">false</code></li><li id="e580" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">NaN</code></li></ul><p id="edbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一切都是真实的。假设我们有以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="94fa" class="ne md it na b gy nf ng l nh ni">0 || undefined || null || 1</span></pre><p id="ad14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到1。JavaScript解释器评估所有的falsy值并返回1，因为这是最后剩下的。</p><p id="b248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保得到我们期望的类型，我们应该把所有东西都转换成我们实际期望的类型，或者我们应该检查类型。</p><p id="0a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要转换像数字、布尔值和字符串这样的原始值，我们可以分别使用<code class="fe nj nk nl na b">Number</code>、<code class="fe nj nk nl na b">Boolean</code>和<code class="fe nj nk nl na b">String</code>函数。我们只是将任何对象传递给这些函数。</p><p id="d381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在某物前使用<code class="fe nj nk nl na b">+</code>符号将其转换为数字。</p><p id="1134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">!!</code>也根据事物的真值将它们转换成布尔型。第一个感叹号根据值的真值转换该值，然后对其求反。然后第二个感叹号将它转换回原始的真值。</p><p id="d03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查原始值的类型，我们可以使用<code class="fe nj nk nl na b">typeof</code>操作符。但是，请注意<code class="fe nj nk nl na b">null</code>的类型是“object”。一切都有我们期待的类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，对象文字是定义对象的最清晰的方式。唯一的例外是当我们需要动态生成代码的函数或动态生成的正则表达式时。我们不应该使用<code class="fe nj nk nl na b">new</code>关键字来声明具有原始值的事物。最后，我们应该小心自动类型转换，并检查类型或根据我们的需要进行转换。</p></div></div>    
</body>
</html>