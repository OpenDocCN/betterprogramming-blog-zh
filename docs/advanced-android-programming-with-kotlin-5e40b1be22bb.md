# 使用 Kotlin 进行高级编程

> 原文：<https://betterprogramming.pub/advanced-android-programming-with-kotlin-5e40b1be22bb>

## kot Lin-您应该使用的独有功能

![](img/49feaa131b88068a1a3104fe7661de1a.png)

与我们需要编写所有内容的 Java 不同，Kotlin 编译器可以理解代码，并在幕后编写样板代码——例如，它可以推断变量声明中的类型。这提高了生产率并节省了时间。

## 科特林让 Android 开发更有趣

如果你在网上搜索，你会发现很多 Kotlin 解决 Java 痛点的方法，以及 Kotlin 的特性如何让 Android 开发更有趣。

正如[为你开源](https://opensourceforu.com/2018/07/kotlin-a-language-for-modern-multi-platform-applications/)所描述的，

> “Kotlin 是一种多平台编程语言，简洁、安全、可互操作且工具友好。它是一种静态类型的编程语言，运行在 Java 虚拟机上，也可以编译成 JavaScript 源代码，或者可以使用 LLVM 编译器基础设施。”

无论您在这里学到了什么编程进步，其中大部分都适用于使用 Kotlin 进行开发的其他平台。

所以，事不宜迟，让我们进入编码部分。

# 科特林扩展

我们要讨论的第一个概念是科特林扩展。正如科特林自己的[文档](https://kotlinlang.org/docs/reference/extensions.html)所说:

> “Kotlin 提供了用新功能扩展类的能力，而不必从类继承或使用设计模式，如装饰器。”

这可以通过一个叫做*扩展的特殊声明来完成。*例如，我们可以在第三方库中为一个不能修改的类编写新的功能，并将它们作为该类中的实际函数使用。这些功能称为*扩展功能。*

# 默认 Kotlin 扩展

Kotlin 是一个包含许多有用功能的包。默认的扩展名是数组列表中的`filter`、`single`、`first`和`last`以及用于检查字符串最后一个字符的`last`。

## **过滤器**

`filter`是数组列表类的扩展函数，通过它我们可以过滤结果，如下所示:

使用筛选器扩展

这不是很棒吗？在 Java 中，我们需要编写所有的循环，创建一个单独的数组，并将所有的对象添加到一个新的数组中…等等。

但在 Kotlin 中，这一切都是通过一个简单的关键字来完成的。

## **单个**

`single`的工作方式与`filter`相同，实现它的语法也是一样的——唯一的区别是`single`只返回一个匹配给定条件的对象。

## **第一个和最后一个**

根据名称本身，我们可以猜测它们分别返回数组的第一个和最后一个对象。

```
**val last** =  arrayAllSeries.**last**()
**val first** =  arrayAllSeries.**first**()
```

有了科特林，总会有更多的东西。在这里，我们可以应用一个条件，并在数组中获取满足这些条件的`first`和`last`对象，如下所示:

带有条件的数组中的第一个和最后一个对象

这只是冰山一角。Kotlin 有无数这样的扩展函数，可以减少业务逻辑中对样板代码的需求。

# 用户定义的扩展

我们可以为 Kotlin 中的任何类创建扩展，以获得用户想要的功能。下面是我经常使用的一些扩展。

## 视图扩展

例如，考虑为一个视图编写一个`RxClick`。下面是代码，展示了我们一般是如何编写的。

RxClick 实现

拜托，都快 2020 年了。谁会写这么多代码来实现一个简单的点击呢？有了 Kotlin，总有简化的空间。

首先，创建一个名为`viewextensions`的 Kotlin 文件，然后编写一个扩展函数在一个视图上实现`RxClick`，如下所示。

RxClick Kotlin 扩展

正如我在开始时解释的那样，我为类`View`、**、**编写了一个新功能，函数名设置为`reactiveclick`、**、**，并编写了我们需要在该函数中运行的任何功能。

这个`reactiveclick`非常类似于视图上的通用点击功能，比如`setOnClickListener`。

下面是我们如何使用`reactiveclick` 函数在一个视图上实现`RxClick`

使用 RxClick Kotlin 扩展

当你开始使用这样的扩展函数时，你就会知道它们的优点了。就好像你在实现自己的风格。

以下是我在项目中使用的几个视图扩展来提高我的工作效率。

我每天使用的几个视图扩展

## 字符串扩展

到目前为止，我们已经研究了视图扩展。接下来，让我们专注于我们可以使用扩展来做的一些验证。

常用的字符串扩展

以上是我经常使用的字符串扩展。我们可以根据项目级别的要求编写任何应用于字符串的功能——就像当你创建一个聊天应用程序时，如果用户键入@，那么你可能希望开始显示用户名建议。

看看我是如何使用扩展来实现的:

## 上下文扩展

这是我的最爱之一。我们可以使用上下文编写很多扩展，比如设置状态栏颜色、获取屏幕高度和宽度、显示吐司，甚至检查互联网连接。

看看我最常用的基于上下文的扩展:

这些扩展是不是很棒？这是我在 Kotlin 会议上第一次看到他们时的想法。

但是不要把所有的扩展功能都组合到一个文件里，几个星期或者几个月之后就标记为垃圾。创建单独的 Kotlin 文件。如`ViewExtensions`、`StringExtensions`、`FileExtensions`等。—就像在 Java 中处理实用程序文件一样。

通常编写这种类型的扩展让我感觉像是在编写自己的语言。这是我喜欢科特林的原因之一。

我在这里展示的扩展是我在所有项目中常用的，但是我们可以为特定于项目的功能编写更多的扩展，就像我们在上面的例子中为聊天应用程序中的提及扩展所做的那样。

# 高阶函数

可以作为参数传递或者可以从函数返回的函数称为*高阶函数。*换句话说，高阶函数就是以函数为参数或者返回函数的函数。

不管您在哪个平台上开发，这些类型的函数都非常方便。作为一名 Android 开发人员，我发现高阶函数可以非常方便地代替点击监听器并将函数作为参数传递。

为了更清楚地理解这一切，让我用一个例子来解释一下。

我们最常使用的是创建一个`RecyclerView`，其中我们创建一个点击监听器并将其传递给适配器。我没有这样做，而是将函数直接作为一个参数传递，该参数应该在用户单击时调用。看一看。

首先，让我们看看适配器的构造函数部分，它有一个高阶函数。

使用高阶函数作为参数的 RecyclerView 适配器构造函数

这里，第二个参数，`block,` 是带有两个参数的高阶函数，需要在点击`RecyclerView`项时调用。

点击`RecyclerView`项，我们将调用`block`、**、**，如下图所示:

在 RecyclerView 项目上调用块函数单击

现在是创建适配器的时候了。看一看:

`coutriesItemClick` 是我们在`CountryAdapter` 中传递的函数，作为参数在项目点击时调用。

```
{  **viewType** : Int, **data** : CountryDetails -> coutriesItemClick(viewType,data) }
```

`viewType`和`data`是通过点击项目视图中调用的`block` 函数传递到这里的参数，如上图所示。

这很好，对吧？我们删除了所有的样板代码来创建一个点击监听器，并且也不需要识别在项目中哪个视图被点击了。

## 具有多点击区域的 Recyclerview 适配器

当项目中有一个或两个单击区域时，将高阶函数作为参数传递是可行的，但如果有两个以上的单击区域呢？那么在构造函数中传递所有的函数是没有优化的。

看看如何有效地处理这种情况。

双击以上即可回收视图适配器

我们可以创建任意数量的点击，并且可以从适配器实例中调用它们，如下所示:

使用适配器中的点击功能

# 限定作用域的函数

如果您使用 Kotlin 已经有一段时间了，那么您应该已经知道作用域函数— `let`、`run`、`apply`等等—在使用它们时有其优势。

基本上，这些函数做同样的事情—对一个对象执行一段代码。不同的是这个对象如何在块中变得可用，以及整个表达式的结果是什么。

让我们来看看其中的一些。

## **让**

Kotlin 的`let`是一个作用域函数，其中在表达式内部声明的变量不能在外部使用。`let`将调用它的对象作为参数，并返回 lambda 表达式的结果。

让我们看看`let`块的用法:

让科特林进来

如果你不用`let`写同样的代码，你将不得不引入一个新的变量，并在你使用它的时候重复它的名字。

没有信

范围函数没有引入任何新的技术功能，但是它们可以使您的代码更加简洁，可读性更好。

另一方面，`let`在空检查中也很方便。看一看:

带字母的空支票

## 奔跑

*   类似于`let`函数，`run`函数也返回最后一条语句
*   与`let`不同，`run`功能不支持`it` 关键字

在科特林跑步

## **应用**

`apply`是另一个限定了作用域的函数，但是我们可以改变我们在块中应用关键字的实体的属性。

```
textviewName?.**apply**{
     **text** = "print this from apply"
}
```

我们对其应用关键字的实体的属性将在块中直接可用——就像在上面的示例中`textview`的`text` 是可用的。

## 随着

`with`是另一个关键字，其作用类似于`apply` ，并且可以访问该关键字实际应用到的实体的属性。

**同**在科特林

范围函数的不同之处在于它们返回的结果:

*   `**a**pply`和`also`返回上下文对象
*   `let`、`run`和`with`返回 lambda 结果

这两个选项允许您根据代码中的下一步操作选择适当的函数。

# 更新

要了解更多关于 Kotlin 的内容，请阅读 Kotlin 高级编程系列中的其他文章:

*   [“使用 Kotlin 进行高级编程—第二部分](https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0)”
*   [“使用 Kotlin 进行高级编程—第 3 部分](https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134)”
*   [“用 Kotlin 进行高级编程—第四部分”](https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048)
*   [“使用 Kotlin 进行高级编程—第 5 部分”](https://medium.com/better-programming/advanced-programming-in-kotlin-part-5-b674ce9e692f)