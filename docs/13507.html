<html>
<head>
<title>How To Create Auto-Saving Forms in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中创建自动保存表单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-auto-save-forms-1a396d17ed7d?source=collection_archive---------0-----------------------#2022-09-02">https://betterprogramming.pub/angular-auto-save-forms-1a396d17ed7d?source=collection_archive---------0-----------------------#2022-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a31c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">角度自动保存表单| RXJS运算符</h2><div class=""/><div class=""><h2 id="ce11" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用RxJs和Angular材料创建反应式和模板驱动的自动保存表单的简要指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/380d98b47882ddb734cf317306c49c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32FUIVLkmpoFbZ--C7AHhQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用Canva创建的照片—资源来自<a class="ae lh" href="https://angular.io/presskit" rel="noopener ugc nofollow" target="_blank"> Angular新闻包</a></p></figure><p id="78aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将研究如何在Angular中创建自动保存的表单。我们将实现这个特性及其所有的功能，比如开关、显示小吃店通知等等。</p><p id="1759" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个过程中，我们将探索几个RxJs操作符。我们将从实现反应式表单的特性开始。最后，我们将看到模板驱动的表单需要什么样的改变。</p><p id="e3ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，让我们开始吧！</p><h1 id="fa3b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">概观</h1><p id="a326" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在我们深入细节之前，让我们快速看一下演示应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/fa9259baa5e8b9079475cc937de5e549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ak7EfKCfEnEemDpGrSo49A.gif"/></div></div></figure><p id="4985" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该表单有两个输入字段:用户的名和姓。它有一个“保存”按钮，如果表单有效，该按钮将被启用。最后，如果启用了自动保存，每当用户更改任何值时，加载栏就会出现在表单的底部。代码如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7281" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能已经注意到了，我们使用有棱角的材料。要安装它，只需要运行:<code class="fe ne nf ng nh b">ng add @angular/material</code>。</p><h1 id="d3dd" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">启用/禁用自动保存功能</h1><p id="a1eb" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">实现自动保存功能的切换非常容易。</p><p id="166a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们在<code class="fe ne nf ng nh b">AppComponent</code>中声明一个<code class="fe ne nf ng nh b">boolean</code>变量<code class="fe ne nf ng nh b">autoSaveEnabled</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2add" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们使用<code class="fe ne nf ng nh b">mat-slide-toggle</code>元素上的<code class="fe ne nf ng nh b">[(ngModel)]="autoSaveEnabled"</code>双向绑定该变量。接下来，我们将变量作为输入传递给包含表单的<code class="fe ne nf ng nh b">UserProfile</code>组件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cf9e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们通过实现<code class="fe ne nf ng nh b"><a class="ae lh" href="https://angular.io/api/core/OnChanges" rel="noopener ugc nofollow" target="_blank">OnChanges</a></code>生命周期钩子来处理<code class="fe ne nf ng nh b">autoSave</code>输入属性的值变化。我们将<code class="fe ne nf ng nh b">changeDetection</code>设置为<code class="fe ne nf ng nh b"><a class="ae lh" href="https://angular.io/guide/change-detection-skipping-subtrees#using-onpush" rel="noopener ugc nofollow" target="_blank">OnPush</a></code>,这样当这个组件的输入属性值发生变化时，就会触发这个组件的变化检测。我们定义了<code class="fe ne nf ng nh b">ngOnChanges</code>方法来根据属性值启用或禁用自动保存(稍后将详细介绍)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="a710" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">自动保存表单</h1><p id="b034" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们需要问的问题是“什么时候”？我们希望什么时候自动保存表单？</p><p id="e479" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望在满足以下所有条件时实现这一点:</p><ol class=""><li id="0004" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">自动保存已启用</li><li id="8e25" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">用户更改了一个值</li><li id="ab1d" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">表格是有效的</li></ol><p id="4673" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">条件#1已经在前面的部分中实现了。其余的在<code class="fe ne nf ng nh b">enableAutoSaving</code>方法中实现。那么，让我们来看看。</p><p id="a7cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了在用户更改值时自动保存表单(条件#2)，我们需要订阅表单的<code class="fe ne nf ng nh b">valueChanges</code> observable。</p><p id="9ca8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从官方文档来看，<code class="fe ne nf ng nh b"><a class="ae lh" href="https://angular.io/api/forms/AbstractControl#valueChanges" rel="noopener ugc nofollow" target="_blank">valueChanges</a></code>是“每当控件的值在UI中或以编程方式改变时，发出一个事件的多播可观察对象”</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="224f" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nw no np nq bi translated">在第1行，我们定义了<code class="fe ne nf ng nh b">changesSubscription</code>来保存订阅。我们在第六行做作业。这将让我们在以后想要禁用该功能时取消订阅。</li><li id="6a0d" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第2行和第3行，我们定义了一个<code class="fe ne nf ng nh b">BehaviorSubject</code>及其相应的可观察值，用于显示或隐藏加载栏。</li><li id="dfb5" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第7行，如果表单无效，我们过滤并停止任何发出的值(条件#3)。保存无效值没有意义。</li><li id="6289" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第8行，假设用户输入了使表单有效的内容，我们发出<code class="fe ne nf ng nh b">true</code>，因此显示加载栏。</li><li id="064f" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第9行，我们使用时间跨度为1000毫秒(=1秒)的<code class="fe ne nf ng nh b"><a class="ae lh" href="https://rxjs.dev/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">debounceTime</a></code>操作符。除非用户停止输入超过一秒钟，否则可观察对象不会发出信号。我们给用户时间在打字时做出反应、暂停或思考。</li><li id="8c6f" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第10–11行，我们使用了<code class="fe ne nf ng nh b">switchMap</code>操作符，它是一个高阶映射操作符。它将用户数据从表单传递给<code class="fe ne nf ng nh b">UsersService</code>的<code class="fe ne nf ng nh b">saveUser</code>方法，并期待一个可观察的。该方法确实返回一个可观察对象，<code class="fe ne nf ng nh b">switchMap</code>自动订阅和取消订阅该对象。<br/>这被称为“内部可观察对象”，因为它嵌套在另一个可观察对象<code class="fe ne nf ng nh b">valueChanges</code>中，后者被称为“外部可观察对象”最后，如果在HTTP请求完成之前发出了另一个值，那么<code class="fe ne nf ng nh b">switchMap</code>会取消该请求以支持新的请求。</li><li id="e4cb" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第12行，我们在内部可观察对象上使用了<code class="fe ne nf ng nh b">finalize</code>操作符。当这个观察完成时(正常或由于错误)，我们发出<code class="fe ne nf ng nh b">false</code>来隐藏加载栏。</li><li id="9f77" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第15行，我们终于从<code class="fe ne nf ng nh b">subscribe</code>到<code class="fe ne nf ng nh b">valueChanges</code>。</li></ul><p id="a579" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的<code class="fe ne nf ng nh b">saveUser</code>方法中，我们使用<code class="fe ne nf ng nh b">catchError</code>和返回<code class="fe ne nf ng nh b">EMPTY</code>来避免将任何错误从内部(<code class="fe ne nf ng nh b">switchMap</code>)可观察传播到外部(<code class="fe ne nf ng nh b">valueChanges</code>)可观察。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e69d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们允许这种情况发生，可观察性将会完成，我们将需要重新订阅来监听值的变化。</p><p id="7f8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，当我们需要禁用该特性时，我们调用<code class="fe ne nf ng nh b">disableAutoSaving</code>方法来取消订阅<code class="fe ne nf ng nh b">changeValues</code>可观察对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="7498" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">观察表单状态的变化</h1><p id="ac22" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">不幸的是，我们还没有完成。</p><p id="a841" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设用户已经填写了表单并且现在是有效的。然后，他们反复按“退格”键，直到其中一个字段为空。表单变为无效，但最后的更改(带有最后一个剩余字符的更改)不会被取消。</p><p id="98c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，这是一个次要的细节，但这些细节使差异！</p><p id="2a5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要观察表单状态的变化并相应地采取行动。为此，我们需要订阅表单的<code class="fe ne nf ng nh b">statusChanges</code> observable。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><ul class=""><li id="b49d" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nw no np nq bi translated">在第1行和第4行，我们定义并设置了<code class="fe ne nf ng nh b">statusSubscription</code>变量，就像我们对<code class="fe ne nf ng nh b">changesSubscription</code>所做的一样。</li><li id="9242" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第5行，我们使用<code class="fe ne nf ng nh b">distinctUntilChanged</code>操作符，当表单从有效变为无效时，只允许发出不同的状态值，反之亦然。</li><li id="bdaa" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第6行，我们使用<code class="fe ne nf ng nh b">pairwise</code>操作符将以前和当前发出的值配对。在第7行，我们使用<code class="fe ne nf ng nh b">tap</code>操作符来使用这个对。</li><li id="82b9" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第8-10行，如果表单的状态从<code class="fe ne nf ng nh b">VALID</code>变为<code class="fe ne nf ng nh b">INVALID</code>，我们调用<code class="fe ne nf ng nh b">disableAutoSaving</code>。这取消了<code class="fe ne nf ng nh b">changesSubscription</code>，因此没有请求被分派。问题已解决！</li><li id="4cc4" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第12–15行，如果表单是<code class="fe ne nf ng nh b">VALID</code>且<code class="fe ne nf ng nh b">changesSubscription</code>关闭，即如果自动保存先前被禁用，我们启用自动保存。</li><li id="f2ce" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第14行，我们在表单上显式调用<code class="fe ne nf ng nh b">updateValueAndValidity</code>。如果我们不这样做，使表单再次有效的第一个更改将不会自动保存。这是因为这个特定的变化发生在调用<code class="fe ne nf ng nh b">enableAutoSaving</code>之前，在这个方法中，我们订阅了<code class="fe ne nf ng nh b">changeValues</code>可观测值。</li><li id="684c" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">在第17行，我们最终订阅了可观察的。</li></ul><p id="bcbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们禁用自动保存特性时，我们必须调用<code class="fe ne nf ng nh b">disableStatusWatching</code>方法来取消订阅<code class="fe ne nf ng nh b">statusChanges</code>观察值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ecbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们实现了<code class="fe ne nf ng nh b">OnDestroy</code>生命周期挂钩。我们在<code class="fe ne nf ng nh b">ngOnDestroy</code>方法中取消订阅这两个订阅，以避免任何内存泄漏。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ae96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，现在我们完成了！😅</p><p id="2be7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和往常一样，你可以在下面的StackBlitz找到一个工作演示，或者只在<a class="ae lh" href="https://github.com/kagklis/ng-autosave-forms.git" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到源代码。</p><p id="4984" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">别忘了订阅我的时事通讯，关注更多类似的内容！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx nd l"/></div></figure><h1 id="32c8" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">模板驱动的表单呢？</h1><p id="5f4a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们看到了这是如何与反应形式一起工作的。我们能自动保存模板驱动的表单吗？当然可以！我们只需要做一些改变。</p><p id="f590" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们需要导入<code class="fe ne nf ng nh b">FormsModule</code>(如果还没有导入)。通过导入<code class="fe ne nf ng nh b"><a class="ae lh" href="https://angular.io/api/forms/FormsModule" rel="noopener ugc nofollow" target="_blank">FormsModule</a></code>，所有<code class="fe ne nf ng nh b">&lt;form&gt;</code>标签上的<code class="fe ne nf ng nh b">NgForm</code>指令变为活动状态。我们不需要添加任何特殊的选择器。</p><p id="125e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是我们如何倾听价值和地位的变化呢？嗯，我们需要拿到表格。</p><p id="c6cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<code class="fe ne nf ng nh b">ngForm</code>作为键将指令导出到一个本地模板变量中。我们还使用<code class="fe ne nf ng nh b">ngModel</code>和<code class="fe ne nf ng nh b">name</code>属性注册子控件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7398" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们通过使用组件类中的<code class="fe ne nf ng nh b">@ViewChild</code>装饰器来获取表单的引用。就是这样！我们现在可以使用这个引用，做我们到目前为止看到的事情。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="35cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意到第19行奇怪的语法了吗？不，这不是打印错误。</p><p id="f739" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ne nf ng nh b">NgForm</code>指令创建一个顶级<code class="fe ne nf ng nh b"><a class="ae lh" href="https://angular.io/api/forms/FormGroup" rel="noopener ugc nofollow" target="_blank">FormGroup</a></code>实例，并将其绑定到一个表单，以跟踪聚合表单值和验证状态。这个<code class="fe ne nf ng nh b">FormGroup </code>实例可以通过<code class="fe ne nf ng nh b">form</code>属性来访问。</p><p id="4537" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是<code class="fe ne nf ng nh b">NgForm</code>没有提供<code class="fe ne nf ng nh b">updateValueAndValidity</code>方法或任何其他方式来强制更新表单。因此，我们使用这种变通办法。</p><p id="5002" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在GitHub和StackBlitz上的单独分支中找到前面链接中的源代码。</p><h1 id="7dff" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="e923" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在本文中，我们演示了如何在Angular中创建自动保存的表单。在此期间，我们使用并解释了几个RxJs操作符。最后，我们强调了反应式表单实现和模板驱动表单实现之间的区别。</p><p id="931b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章，并且你学到了一些新的东西。</p><p id="a798" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ny">感谢阅读。敬请关注更多内容。</em></p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="b25f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ny">延伸阅读:</em> </strong></p><div class="og oh gp gr oi oj"><a href="https://javascript.plainenglish.io/custom-pipes-in-angular-the-ultimate-guide-e54bb400e3ce" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">角形定制管道——终极指南</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">如何在Angular中创建自定义管道，什么是纯管道和不纯管道，以及如何使用纯管道来改善</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lb oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://javascript.plainenglish.io/angular-interceptors-a-complete-guide-7294e2317ecf" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">角度截击机:完全指南</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">什么是角拦截器？它是如何工作的？如何创建一个并提供给应用程序？如何绕过它们…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="os l"><div class="oy l ou ov ow os ox lb oj"/></div></div></a></div></div></div>    
</body>
</html>