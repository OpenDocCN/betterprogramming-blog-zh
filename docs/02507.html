<html>
<head>
<title>Let Git Aliases Boost Your Productivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Git别名提高您的生产力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/let-git-aliases-boost-your-productivity-ced0fcdd65b5?source=collection_archive---------15-----------------------#2019-12-04">https://betterprogramming.pub/let-git-aliases-boost-your-productivity-ced0fcdd65b5?source=collection_archive---------15-----------------------#2019-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1b34" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Git别名简化复杂的日常工作流程，确保您的工具是您工作效率的催化剂，而不是障碍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1fe7062f9e423ce3dd02fa846c8903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5LrukdkofovVJNLB5GWVg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<em class="kv">负空格经</em> <a class="ae kw" href="https://www.pexels.com/photo/computer-keyboard-34153/" rel="noopener ugc nofollow" target="_blank"> <em class="kv"> Pexel </em> </a></p></figure><p id="5c51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我试图做除了提交本地Git存储库的单个分支之外的任何事情时，我经常发现自己使用Google作为拐杖。这没有任何意义。像Git这样的工具应该是开发人员生产力的催化剂，而不是障碍。事实证明，我没有利用我的工具的一个功能，这个功能实际上是为解决这个问题而设计的。</p><p id="3306" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输入<a class="ae kw" href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases" rel="noopener ugc nofollow" target="_blank"> Git别名</a>:这是一种内置的方法，可以简化复杂的日常工作流，这些工作流自己很难记住。</p><p id="4ccc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">基本上，它们是这样工作的:</p><ul class=""><li id="44e7" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">为您定期执行的操作定义别名。例如，为<code class="fe mc md me mf b">git fetch &amp;&amp; get merge origin/dev</code>定义别名<code class="fe mc md me mf b">sync</code>。</li><li id="7439" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">使用所述别名。例如，调用<code class="fe mc md me mf b">git sync</code>,而不是上面容易出错命令组合。</li></ul><p id="f800" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如您所见，别名不仅有助于简化记忆复杂命令组合的需要，还可以节省击键次数！就这么简单。</p><p id="5d30" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面，我们将讨论创建别名的实际技术细节，以及您可能希望在您的环境中采用的一些有用的技术。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="3c03" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">创建别名</h1><p id="2ddf" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">有几种方法可以创建别名。Git文档实际上为此提供了一行程序，但是我发现使用这种机制会导致更多的问题。</p><p id="62fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我更喜欢用下面的命令在我配置的文本编辑器(默认情况下通常是<code class="fe mc md me mf b">vim</code>或类似的编辑器)中打开我的全局Git配置:</p><pre class="kg kh ki kj gt np mf nq nr aw ns bi"><span id="04b3" class="nt mt iq mf b gy nu nv l nw nx">git config -e --global</span></pre><p id="89da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从打开的文本文件中，您可以创建或修改<code class="fe mc md me mf b">[alias]</code>部分。例如，要创建两个别名(特别是一个<code class="fe mc md me mf b">co</code>别名和一个<code class="fe mc md me mf b">sync</code>别名)，文件必须包含以下文本:</p><pre class="kg kh ki kj gt np mf nq nr aw ns bi"><span id="893a" class="nt mt iq mf b gy nu nv l nw nx">[alias]<br/>        co = checkout<br/>        sync = !git pull origin dev</span></pre><p id="03ff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mc md me mf b">[alias]</code>部分的每一行代表一个不同的别名。</p><p id="3dd0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="ny">注意上面</em> <code class="fe mc md me mf b"><em class="ny">sync</em></code> <em class="ny">别名命令开始的</em> <code class="fe mc md me mf b"><em class="ny">!</em></code> <em class="ny">。以</em> <code class="fe mc md me mf b"><em class="ny">!</em></code> <em class="ny">开始别名命令意味着后面是</em> <code class="fe mc md me mf b"><em class="ny">bash</em></code> <em class="ny">命令。排除</em> <code class="fe mc md me mf b"><em class="ny">!</em></code> <em class="ny">意味着接下来只是一个</em> <code class="fe mc md me mf b"><em class="ny">git</em></code> <em class="ny">命令。</em></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="af4a" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">有用的别名</h1><p id="8b7a" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">别名的可能性是无限的。重要的是，您定义了对您的特定日常工作流有价值的那些。</p><p id="80a1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是我为自己的个人工作流程定义的一些别名。我发现它们大大简化了我的Git用法。你可能会也可能不会有同样的感觉。</p><h2 id="753a" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">结账处</h2><p id="53ea" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">这个别名非常简单。这是一个检查新分支的快捷键。</p><ul class=""><li id="d856" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">co = checkout</code></li><li id="8999" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法举例:<code class="fe mc md me mf b">git co my-fancy-branch</code></li></ul><h2 id="b31b" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">暂存并提交更改</h2><p id="ceb6" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">大多数时候，当我想提交改变时，我只是想准备并提交我所做的一切。这个别名允许我这样做。</p><ul class=""><li id="87e7" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">ac = !git add -A &amp;&amp; git commit</code></li><li id="d4fc" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法举例:<code class="fe mc md me mf b">git ac -m "Some Commit Message Goes Here"</code></li></ul><h2 id="80a3" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">创建新分支</h2><p id="93de" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">创建一个本地分支，然后再推一个远程分支，当我试图推我的更改并意识到我不记得如何创建新分支的远程版本时，几乎总是会让我停下脚步。出于这个原因，我发现最好在一行中同时做这两项工作。因此，这个别名从当前工作分支创建一个新的本地分支，然后立即将其连接到一个新的远程分支。</p><ul class=""><li id="d289" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">create-branch = !git checkout -b $1 &amp;&amp; git push -u origin</code></li><li id="ca41" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法示例:<code class="fe mc md me mf b">git create-branch “my_new_branch”</code></li></ul><p id="97bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="ny">注意这个别名中的</em> <code class="fe mc md me mf b"><em class="ny">$1</em></code> <em class="ny">。这会将传递给别名的第一个参数(在本例中是所需的分支名称)插入到要执行的命令中。</em></p><h2 id="4876" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">带开发的同步分支</h2><p id="cc2c" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">我试图将我的特性分支与团队中其他开发人员定期推进的<code class="fe mc md me mf b">dev</code>分支同步。这有助于我避免在没有注意到的情况下意外破坏其他特性、测试等等——反之亦然。这个别名很快地同步了我当前的工作分支。</p><ul class=""><li id="6117" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">sync = !git pull origin dev</code></li><li id="828a" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法举例:<code class="fe mc md me mf b">git sync</code></li></ul><h2 id="76b7" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">列出分支的已更改文件</h2><p id="da13" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">当我结束一个特性分支的工作，并准备创建一个pull请求来把它放入<code class="fe mc md me mf b">dev</code>时，我喜欢最后看一下所有已经被更改的文件。这有助于我确保，例如，我不会在代码库中引入新的<a class="ae kw" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">代码气味</a>。这个别名将列出在我当前工作的分支中已经被改变的所有文件的名称。</p><ul class=""><li id="4bb7" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">get-changes = !git diff — name-only origin/dev</code></li><li id="cf79" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法举例:<code class="fe mc md me mf b">git get-changes</code></li></ul><h2 id="3706" class="nt mt iq bd mu nz oa dn my ob oc dp nc lg od oe ne lk of og ng lo oh oi ni oj bi translated">删除旧的本地分支</h2><p id="a6b2" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">在我的团队中，每当我们将一个拉请求合并到<code class="fe mc md me mf b">dev</code>中，我们就会删除相关的特性分支。这有助于让我们的活动保持干净——因此在任何给定的时刻都很容易看到正在进行的事情。</p><p id="35fc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为我们这样做了，所以我可以非常快速地清理旧分支的本地克隆，方法是删除已经在远程上删除的分支。实际上，我发现定期这样做会加速我执行的其他一些Git操作，尽管我不知道为什么。</p><ul class=""><li id="7491" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">别名:<code class="fe mc md me mf b">clean-branches = !git remote prune origin &amp;&amp; (git branch -vv | grep ‘origin/.*: gone]’ | awk ‘{print $1}’ | xargs git branch -D)</code></li><li id="c173" class="lt lu iq kz b la mg ld mh lg mi lk mj lo mk ls ly lz ma mb bi translated">用法举例:<code class="fe mc md me mf b">git clean-branches</code></li></ul><p id="98c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个别名可能是我最喜欢的一个——它简化了相当复杂的命令管道，并有助于保持我的环境整洁。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="313b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">尝试一下Git别名——它们似乎改变了每个了解它们的开发人员的生活。如果你有任何有用的别名，请在下面的评论中分享！</p></div></div>    
</body>
</html>