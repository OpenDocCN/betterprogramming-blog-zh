<html>
<head>
<title>How To Read an Image File in C++ in Android With NDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用NDK读取Android中C++的一个图像文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-read-an-image-file-in-c-in-android-with-ndk-5d837039da3a?source=collection_archive---------3-----------------------#2022-11-12">https://betterprogramming.pub/how-to-read-an-image-file-in-c-in-android-with-ndk-5d837039da3a?source=collection_archive---------3-----------------------#2022-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Android的原生层中直接读取任何文件的不同方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fc89c4359b77d253f623b447569a54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QKewSOibYNRLfpmC.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@olafval" rel="noopener ugc nofollow" target="_blank">奥拉夫瓦尔</a>在<a class="ae ky" href="https://unsplash.com/photos/UTk9cXzYWAg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="65c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Android中的软件开发可以使用Java SDK或<a class="ae ky" href="https://developer.android.com/ndk" rel="noopener ugc nofollow" target="_blank">原生开发工具包，又名NDK </a>，由Android开源项目(AOSP)提供。NDK通常用于编写高性能代码，如图像处理算法。</p><p id="bfee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多应用程序需要从磁盘读取文件。对于读取图像文件，通常的方法是使用Android SDK中可用的Java APIs读取文件，或者使用像<code class="fe lv lw lx ly b">MediaStore</code>API这样的高级抽象。在本文中，我不会介绍在Java层中读取不同文件格式的信息。</p><p id="614b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，可能需要在本地层(C++)处理图像文件。在这种情况下，通常的方法是执行以下操作:</p><ul class=""><li id="203c" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">将图像作为<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>加载。</li><li id="8951" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">和JNI一起把它送到原生层。</li><li id="4cdc" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">在本地层进行读/写操作。</li></ul><p id="76a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在某些情况下，您可能希望直接在本机层中读取图像。如果你有这样的情况——这篇文章是给你的！</p><blockquote class="mn mo mp"><p id="c589" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">参考消息:当我说“本机层”或“本机代码”时，它指的是C++代码。我可能会在文章中交替使用这些术语。</p></blockquote><p id="bcda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，虽然这篇文章主要是关于在C++中读取图像文件，但是这些概念可以很容易地推广到在Android的原生层中读取任何文件格式。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="1bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始介绍步骤和代码示例之前，还有一个问题需要解决。</p><p id="0e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mq">为什么首先要读取原生层中的图像？</em></p><p id="0e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在“如何做”之后介绍它</p><p id="9add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人告诉我，并不是每个人都对我经常提到的“为什么”感兴趣。</p><p id="8b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mq">被老婆(-_-)！</em></p><p id="3cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请告诉我事实是否如此。</p><h1 id="bc7d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">如何读取原生层中的图像</h1><p id="57c1" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你正在阅读这篇文章，我希望你熟悉Android开发基础、NDK、Java本地接口(JNI)等概念。</p><p id="ac1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您也熟悉Android中的作用域存储概念。</p><p id="a5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改善对外部存储上的应用程序和用户数据的保护，Android收紧了应用程序访问Android上的文件的方式。</p><p id="2619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR </strong>不要求过多权限，就不能再访问文件。这对用户有好处！使用文件选择器，您仍然可以要求用户授予对特定文件的权限。</p><p id="4a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们不再用<code class="fe lv lw lx ly b">File</code>了。在Android中处理<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank"> Uri </a>更具扩展性。</p><p id="fd1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从读取图像文件的<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank"> Uri </a>开始。</p><h2 id="04f9" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">获取要读取的图像的Uri</h2><p id="ffc4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您可以使用<a class="ae ky" href="https://developer.android.com/reference/android/provider/MediaStore" rel="noopener ugc nofollow" target="_blank">Mediastore</a>API或使用文件选择器类的UI来获取文件的<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank"> Uri </a>。</p><p id="f165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的图像拾取器可以像这样在<code class="fe lv lw lx ly b">Activity</code>中实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有图像拾取器的Android活动示例。</p></figure><p id="d5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文的其余部分，我将假设您已经有了Uri<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank">和</a>。</p><p id="36dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是从这个<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank"> Uri </a>中获取文件描述符。</p><h2 id="4741" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">从Uri获取文件描述符</h2><p id="fae8" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在Unix和类Unix操作系统中，文件描述符(FD)是文件或其他IO资源(如管道或网络套接字)的唯一标识符。它们通常具有非负整数值。负值用作误差值。</p><p id="fe0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Android中，我们可以使用<a class="ae ky" href="https://developer.android.com/reference/android/net/Uri" rel="noopener ugc nofollow" target="_blank"> Uri </a>来获取相应的<a class="ae ky" href="https://developer.android.com/reference/android/content/res/AssetFileDescriptor" rel="noopener ugc nofollow" target="_blank"> AssetFileDescriptor </a>，并使用它在Java层打开文件，获取其<code class="fe lv lw lx ly b">FD</code>值。一旦我们获得本机<code class="fe lv lw lx ly b">FD</code>值，我们就可以通过JNI将这个微小的整数值编组到本机层，以便直接读取文件。</p><p id="2e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要提示:</strong>在这种方法中，资源由Java层打开，由本地层使用，请确保发生以下情况:</p><ul class=""><li id="552f" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">Java层继续拥有文件，即本机层不应该关闭文件流。</li><li id="1b41" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">Java层保持文件打开，直到本机层读取了该文件或者不再需要打开该文件。</li></ul><p id="7166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">违反这些规则会导致意外的竞态条件。</p><p id="18cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何在Java层获得原生的<code class="fe lv lw lx ly b">FD</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Android中从Uri获取fd值的代码片段。</p></figure><h2 id="4ce9" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">通过JNI将FD值发送到本地层</h2><p id="18e0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">对于其余的内容，我希望读者能够熟悉</p><ul class=""><li id="7693" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">用Android设置JNI。</li><li id="c026" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">Android中的JNI基础知识。</li></ul><blockquote class="mn mo mp"><p id="69f7" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated"><em class="it"> JNI代表Java原生接口— </em> <a class="ae ky" href="https://developer.android.com/ndk/samples/sample_hellojni" rel="noopener ugc nofollow" target="_blank"> <em class="it">参考Android </em> </a> <em class="it">的hello-jni样例。</em></p></blockquote><p id="9242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了读取本地层中的文件，我们需要一个基本的Java库和一个相应的JNI文件。下面是一个Java库的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JNI图书馆的Java部分，用于阅读JNI的图像</p></figure><p id="012f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个相应的名为<code class="fe lv lw lx ly b">image-loader-jni.cc</code>的JNI文件，它被嵌入到通过构建JNI构建目标而创建的<code class="fe lv lw lx ly b">libimage-loader-jni.so</code>二进制文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于读取原生层图像的JNI文件的框架。</p></figure><h1 id="7368" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">读取本地层中的文件</h1><p id="a64d" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">并返回一些关于文件的信息</p><p id="9e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种方法可以解决这个问题。我将列举其中的两个:</p><h2 id="9cd8" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">在NDK用图像解码器读取图像</h2><p id="38dc" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">NDK有<a class="ae ky" href="https://developer.android.com/ndk/guides/image-decoder" rel="noopener ugc nofollow" target="_blank"> ImageDecoder </a> API，可以读取JPEG、PNG、GIF、WebP等不同格式的图像。</p><p id="7312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><p id="79b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是NDK的一部分，因此您可以执行以下操作:</p><ul class=""><li id="24a3" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">跳过向项目添加另一个第三方本机依赖项的麻烦。</li><li id="f911" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">通过不添加第三方库获得隐式APK大小缩减。</li><li id="c96e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">因为它是平台的一部分，所以你可以免费获得关键更新(你这边不需要更新)。</li></ul><p id="3fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，</p><ul class=""><li id="d22d" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">支持多种图像格式，允许不透明地解码任意文件。</li></ul><p id="b8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="bebc" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">这是在API等级30中添加的，所以你只能针对这个版本以上的设备！</li><li id="308e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">与位图类似，它将图像解码成一种<code class="fe lv lw lx ly b">Bitmap</code>格式(<a class="ae ky" href="https://developer.android.com/ndk/reference/group/bitmap#androidbitmapformat" rel="noopener ugc nofollow" target="_blank">示例</a>)。默认情况下，图像以<code class="fe lv lw lx ly b">ARGB_8888</code>格式解码(每像素4字节)。</li><li id="d36d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">这是一个不透明的图书馆。您不能为特定的文件格式输入解码器。</li></ul><p id="c8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何使用它来读取图像并将一些信息返回给Java层。</p><blockquote class="mn mo mp"><p id="cbe8" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我本可以在JNI代码本身中添加做任何事情的例子，但这不是石器时代，我们不是那种人。</p><p id="af37" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我们喜欢代码中的一些结构。所以，让我们写一个新的叫做‘Image’的库。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们图像库的头文件</p></figure><p id="11fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们实现解码来自<code class="fe lv lw lx ly b">fd</code>的图像的逻辑。这将在<code class="fe lv lw lx ly b">ImageFactory#FromFd(..)</code>下的<code class="fe lv lw lx ly b">image.cc</code>中执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ImageFactory在图像库中的实现</p></figure><p id="f93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，使用JNI的这个库，阅读来自<code class="fe lv lw lx ly b">fd</code>的图像。</p><p id="3ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里还有一些提示:</p><ul class=""><li id="a085" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">你可以使用像<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/ndk/reference/group/image-decoder#aimagedecoder_settargetsize" rel="noopener ugc nofollow" target="_blank">AImageDecoder_setTargetSize</a></code>这样的API直接读取重新缩放的图像。</li><li id="1cd0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">同样，可以使用类似<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/ndk/reference/group/image-decoder#group___image_decoder_1gaf281588607767ff1232c704c7f7d57ec" rel="noopener ugc nofollow" target="_blank">AImageDecoder_setCrop</a></code>的API在消费前进行裁剪。</li></ul><p id="4e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在实践中，我发现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/ndk/reference/group/image-decoder#aimagedecoder_settargetsize" rel="noopener ugc nofollow" target="_blank">AImageDecoder_setTargetSize</a></code>比我预期的下采样操作要慢。如果您担心这个API的性能，并且您手头有另一种方法，请尝试分别加载全分辨率图像和下采样<code class="fe lv lw lx ly b">Image</code>。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="ab72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过解释和代码示例，您可以获得原生层中图像解码的工作版本。</p><p id="bdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是进一步阅读的一些理由:</p><ul class=""><li id="f709" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">您希望在原生层解码图像，但是您有许多使用Android &lt;= API 30.</li><li id="36a9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">You want to read something other than an image.</li><li id="4d9e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">You have a custom and better decoder of your own.</li><li id="7fbf" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">You are a curious reader, you knowledge hog!</li><li id="b143" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">We still have the pending Mr. Elephant in the room to address.</li></ul><h2 id="1b3f" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">Read image with custom decoders</h2><p id="0a32" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">The following approach can be used to read any file using  【T4】  value, and then you can use your own decoder to decode the image.</p><p id="8add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">For this example, I’ll assume you have some decoder of your own, and it’s implemented underneath  【T5】  implementation. Let's assume an interface. Here’s the code:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Updated interface of image library with a method to decode Image from string image buffer.</p></figure><h2 id="6851" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated"><strong class="ak">的客户以Unix方式读取文件！</strong></h2><p id="5a7c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">对于这种方法，在进入本机层细节之前，我们需要来自Java层的两条附加信息。</p><ol class=""><li id="79db" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu om mf mg mh bi translated"><code class="fe lv lw lx ly b">fd</code>的<code class="fe lv lw lx ly b">start offset</code>(很有可能<code class="fe lv lw lx ly b">0</code>除非你不想从头开始读文件)。您可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/content/res/AssetFileDescriptor#getStartOffset()" rel="noopener ugc nofollow" target="_blank">AssetFileDescriptor#getStartOffset()</a></code> API来实现这一点。</li><li id="ff17" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu om mf mg mh bi translated"><code class="fe lv lw lx ly b">length</code>的文件。您可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/content/res/AssetFileDescriptor#getLength()" rel="noopener ugc nofollow" target="_blank">AssetFileDescriptor#getLength()</a></code> API得到这个。</li></ol><p id="9ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java层获得这些信息后，通过JNI将其发送到本机层。对于下面的例子，我假设你想解码一个图像文件，你的解码器可以处理它。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用fd读取图像并使用我们的图像解码器进行解码的代码片段。</p></figure><p id="d237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的解码器支持缓冲数据，您也可以使用上述方法读取缓冲区中的图像文件。</p><h1 id="1aea" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">为什么应该(或不应该)在本机层读取文件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/889413e20bd0d9879991dd277be8649d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*u_U-pSQT2ZsBGHMh.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">房间里的大象——作者使用<a class="ae ky" href="https://huggingface.co/spaces/stabilityai/stable-diffusion" rel="noopener ugc nofollow" target="_blank">稳定扩散</a>生成的图像。使用稳定扩散生成的图像在<a class="ae ky" href="https://huggingface.co/spaces/CompVis/stable-diffusion-license" rel="noopener ugc nofollow" target="_blank">creativml Open RAIL-M</a>下由<a class="ae ky" href="https://huggingface.co/spaces/stabilityai/stable-diffusion" rel="noopener ugc nofollow" target="_blank">huggingface.co</a>免费提供。</p></figure><p id="cbf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么您可能希望在本机层而不是Java层读取文件是您的问题。</p><p id="b465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我想根据我的经验，使用不同用例的例子来澄清一些误解。</p><h2 id="5e16" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">在本地层使用图像</h2><p id="0154" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果您关心的是Java层中读取或解码图像的高延迟。注意，Android Java SDK还附带了<a class="ae ky" href="https://developer.android.com/reference/android/graphics/ImageDecoder" rel="noopener ugc nofollow" target="_blank"> ImageDecoder，它也有一个Java API </a>。相同的本机实现可能支持这一点。您可以使用这些API将图像读取为<a class="ae ky" href="https://developer.android.com/reference/android/graphics/drawable/Drawable" rel="noopener ugc nofollow" target="_blank"> Drawable </a>或<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap" rel="noopener ugc nofollow" target="_blank"> Bitmap </a>。</p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于您可能想要在原生层中进行的任何后期处理，您可以轻松地编组对原生层的<code class="fe lv lw lx ly b">Bitmap</code>引用。NDK对<a class="ae ky" href="https://developer.android.com/ndk/reference/group/bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>有很好的支持，允许你用很少的开销在Java和Native之间处理它们。</p><blockquote class="mn mo mp"><p id="48d6" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我计划在另一篇文章中写更多关于它的内容。</p></blockquote><p id="c318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Java层相比，在本机层使用<code class="fe lv lw lx ly b">ImageDecoder</code>可能不会带来延迟方面的好处。如果你有一些解码器实现可以比NDK库更快地处理解码，你可能会得到延迟的好处。</p><p id="114a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仍然在原生层读取文件的一个有效理由可能是在不需要的时候在Java层中去掉讨厌的<code class="fe lv lw lx ly b">Bitmaps</code>。</p><p id="2bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如你想读取一个图像，做一些后期处理，编码成JPEG格式保存到磁盘，就可以避免在Java中持有一个<code class="fe lv lw lx ly b">Bitmap</code>引用。</p><p id="47b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常发现持有大量的<code class="fe lv lw lx ly b">Bitmaps</code>会导致明显的性能问题——可能是因为当<code class="fe lv lw lx ly b">Bitmap</code>不再被引用时，我们不得不依靠GC来回收它们持有的内存。GC可能不总是按预期工作。然而,<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap#recycle()" rel="noopener ugc nofollow" target="_blank">Bitmap#recycle()</a></code> API也可以帮助你做到这一点。</p><h2 id="85f3" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">避免跨JNI边界的文件数据的编组</h2><p id="6469" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果下列情况属实，最好使用本机方法:</p><ul class=""><li id="84de" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">您需要读取可选的文件格式，并且您已经为它定制了解码器实现。通过这种方式，您可以避免首先在Java层以<code class="fe lv lw lx ly b">String</code>的形式读取它，然后通过JNI将它编组到本机层。</li></ul><p id="c8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是100%确定数据编组如何跨越Java原生边界，但这是Android开发者网站在JNI发布的避免编组大量数据的<a class="ae ky" href="https://developer.android.com/training/articles/perf-jni#general-tips" rel="noopener ugc nofollow" target="_blank"> #1提示。</a></p><p id="a3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，将<code class="fe lv lw lx ly b">fd</code>传递给本机层“可能”更有性能。</p><h2 id="f3b7" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">使用纯C++库</h2><p id="e79b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">这和上面的观点类似。如果您有第三方库来解码您的图像或自定义文件格式，而这些格式不是Java版本或纯Java版本的，那么使用共享方法来读取文件将是一个好主意。</p><h2 id="8b22" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">比起Java，你更喜欢C++</h2><p id="8cf2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">无可奉告；我听到了！</p><blockquote class="oo"><p id="fbf5" class="op oq it bd or os ot ou ov ow ox lu dk translated">做你认为合适的事——因为这个世界是你的画布！</p></blockquote><h1 id="9ff2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz oy ka nn kc oz kd np kf pa kg nr ns bi translated">参考</h1><ul class=""><li id="0fb7" class="lz ma it lb b lc nt lf nu li pb lm pc lq pd lu me mf mg mh bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/File_descriptor" rel="noopener ugc nofollow" target="_blank">文件描述符—维基百科</a></li><li id="4dfd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://developer.android.com/reference/android/content/res/AssetFileDescriptor" rel="noopener ugc nofollow" target="_blank">asset file descriptor—Android文档</a></li><li id="7cf7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://developer.android.com/ndk/samples/sample_hellojni" rel="noopener ugc nofollow" target="_blank">引用Android的hello-jni示例</a></li><li id="bb63" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://developer.android.com/ndk/guides/image-decoder" rel="noopener ugc nofollow" target="_blank">关于图像解码器的NDK指南</a></li><li id="e245" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://developer.android.com/training/articles/perf-jni#general-tips" rel="noopener ugc nofollow" target="_blank">安卓开发者网站JNI提示</a></li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="d10f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mq">原载于</em><a class="ae ky" href="https://blog.minhazav.dev/how-to-read-an-image-file-in-c++-in-android-ndk/" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://blog . minhazav . dev</em></a></p></div></div>    
</body>
</html>