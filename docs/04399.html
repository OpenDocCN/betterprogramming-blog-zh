<html>
<head>
<title>How to Get Started With a GraphQL, React, Apollo Client, and Apollo Server App (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始使用GraphQL、React、Apollo客户机和Apollo服务器应用程序(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-started-with-a-graphql-react-apollo-client-and-apollo-server-app-part-2-ac864ff9d46e?source=collection_archive---------4-----------------------#2020-04-10">https://betterprogramming.pub/how-to-get-started-with-a-graphql-react-apollo-client-and-apollo-server-app-part-2-ac864ff9d46e?source=collection_archive---------4-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="873a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建前端客户端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15a818375cec4984f6e51d211769f857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W_pGSIsy2UWOw_2CgiL1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@wezlar11?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迪恩·普</a>在<a class="ae ky" href="https://unsplash.com/s/photos/front-end?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博客是由两部分组成的系列文章的一部分。在第一部分<a class="ae ky" href="https://medium.com/better-programming/how-to-get-started-with-a-graphql-react-apollo-client-and-apollo-server-app-403dab1a7801" rel="noopener">中，我们创建了后端服务器</a>。此外，你可以在<a class="ae ky" href="https://github.com/thakursachin467/graphql-starter" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到整个教程的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本博客系列的前一部分中，我们讨论了为什么GraphQL 很棒，以及它如何帮助我们最小化我们下载的数据，并通过只请求我们需要的数据来使它最小化。让我们开始构建一个轻量级前端，看看我们如何使用<a class="ae ky" href="https://www.apollographql.com/docs/react/v3.0-beta/" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>使我们的React应用程序更加高效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0963" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">设置React-Apollo客户端</strong></h1><p id="04d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里我们将使用<code class="fe mz na nb nc b">create-react-app</code>来创建我们的启动代码。<code class="fe mz na nb nc b">create-react-app</code>是开始建立React项目的好方法。它由React团队构建和维护，因此我们可以期待React应用程序的顶级配置。你可以在GitHub 上查看<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code> <a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/77fd40950f3d7e10777e2bbbb512ad25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*c1VtA104rFwGa-2CHLg3KQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在生成React starter代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9fc51aedb16b8a3b87ccc9330f8d06d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeH25qHzeHCEDXmCteqvmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前端文件夹结构</p></figure><p id="4423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了基本的React启动代码，让我们从添加Apollo客户端依赖项开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/399ff15df84cebb945be4ac727f204fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C31MFRd1TqMrw6mQhqBdWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向我们的客户端添加Apollo依赖项</p></figure><ul class=""><li id="3b4b" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe mz na nb nc b">apollo-boost</code>:包含设置Apollo客户端所需的一切的包</li><li id="04db" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe mz na nb nc b">@apollo/react-hooks</code> : React基于钩子的视图层集成</li><li id="eb3a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe mz na nb nc b">graphql</code>:也解析您的GraphQL查询</li></ul><p id="d5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经添加了基本的依赖项，现在我们开始设置Apollo客户机与服务器交互。让我们从创建我们的<code class="fe mz na nb nc b">apollo-client.js</code>文件开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/821494ff7ed6c595a67243fba50d6e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*QgcXFuMJ4wOURek9hnnIgw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建我们的阿波罗档案</p></figure><p id="938b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建我们的Apollo客户机，这样我们就可以开始与我们的后端服务进行交互。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ed5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端给了我们很多方法，但是我们主要使用其中的两个，它们是<code class="fe mz na nb nc b">mutate</code>和<code class="fe mz na nb nc b">query</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/0dbcc8680d335039650186774c4b43d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJLjRVqtx7qdOaP0v68wNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户端中可用的方法</p></figure><p id="4118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，<code class="fe mz na nb nc b">mutate</code>是用来在我们的服务器上执行变异的。我们也可以使用其他方法，比如<code class="fe mz na nb nc b">localState</code>。Apollo客户端还帮助我们维护React应用程序的状态，因此我们不需要Redux或任何其他状态管理包。我们还可以使用Apollo客户端包的内置缓存。</p><p id="2ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要让我们的React应用程序访问我们的客户端可以用来构建接口的数据。为此，我们需要使用<code class="fe mz na nb nc b">ApolloProvider</code>包装整个应用程序。<code class="fe mz na nb nc b">ApolloProvider</code>类似React的<code class="fe mz na nb nc b"><a class="ae ky" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">Context.Provider</a></code>。如果您以前使用过React，您可能知道React上下文。它包装您的React应用程序并将客户端放在上下文中，这允许您从组件树中的任何位置访问它。在<code class="fe mz na nb nc b">App.js</code>中，让我们用一个<code class="fe mz na nb nc b">ApolloProvider</code>包装我们的React应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经用<code class="fe mz na nb nc b">ApolloProvide</code>包装了整个应用程序，我们可以在应用程序的任何地方执行<code class="fe mz na nb nc b">Query</code>和<code class="fe mz na nb nc b">Mutation</code>，并访问数据。让我们看看我们能做些什么。让我们为我们的任务创建一个新文件，并在其中写入我们所有的查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bd3629ea54bdcca06c31b73b26351dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*BF-NOWAtko_WqjW6SfV_YA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建查询和任务文件</p></figure><p id="4cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经设置了Apollo客户端并用<code class="fe mz na nb nc b">ApolloProvider</code>包装了整个应用程序，我们就可以开始用<code class="fe mz na nb nc b">useQuery</code>钩子请求数据了。<code class="fe mz na nb nc b">useQuery</code>是一个从<code class="fe mz na nb nc b">@apollo/react-hooks</code>导出的钩子，它利用<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子API </a>与您的UI共享GraphQL数据。所以让我们开始吧。</p><p id="6f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建包装在<code class="fe mz na nb nc b">gql</code>函数中的GraphQL查询。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在<code class="fe mz na nb nc b">useQuery</code>钩子中使用这些查询。当我们的组件渲染并且<code class="fe mz na nb nc b">useQuery</code>钩子运行时，将返回一个包含<code class="fe mz na nb nc b">loading</code>、<code class="fe mz na nb nc b">error</code>和<code class="fe mz na nb nc b">data</code>属性的结果对象。Apollo客户端为我们跟踪错误和加载状态，这将反映在<code class="fe mz na nb nc b">loading</code>和<code class="fe mz na nb nc b">error</code>属性中。一旦我们的查询结果返回，它将被附加到<code class="fe mz na nb nc b">data</code>属性。我们可以处理来自<code class="fe mz na nb nc b">object</code>的应用程序的所有状态，这些状态是从我们的<code class="fe mz na nb nc b">useQuery</code>钩子返回的。</p><p id="72ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe mz na nb nc b">useQuery</code>钩子创建我们的第一个组件，并获取我们的任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们只需要将新添加的组件添加到我们的<code class="fe mz na nb nc b">App.js</code>中，这样我们就可以看到结果了。就这么办吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们启动我们的后端和前端服务，看看结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f8f361b5200a1bff3efad34daa54571a.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*gwNsrnj2LWrewaBv5VKl0w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在启动前端服务器</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8e25d3ea796b0393e64aa32956cc7fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*6KOFqJHGnwr5ooK_NASYhw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启动我们的后端服务</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bcff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们去<code class="fe mz na nb nc b"><a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></code>看看我们的app是什么样子的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5747dc3f9ea642b69bb183bf30a26c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCREEaMnMX_A03P63zT8aA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a></p></figure><p id="6be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来不太好，但是你明白了。我们已经设置了Apollo客户端，并且能够从数据库中获取数据。但是我们有一个小问题。在头版，我们是过度抓取。我们只是使用任务名称，但是我们获取所有的<code class="fe mz na nb nc b">id</code>,不管它们是否完成。这可不好。</p><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过度抓取意味着我们在网络呼叫期间使用了更多的用户数据，我们希望节省网络带宽。在我们的例子中，几乎没有，但是对于一个大的应用程序，节省带宽意味着我们的应用程序加载更快，响应更快。这就是我们提高应用程序速度所需要的。</p><p id="ad05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们解决它。我们删除了所有不必要的字段，并使我们的<code class="fe mz na nb nc b">queries</code>轻量级，以节省一些带宽。我们可以通过更新<code class="fe mz na nb nc b">GET_TASKS</code>查询来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ba5491672e81fc7d3b2687a60d6e46dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JhhdQG1BxrzN3YNGKwI5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从查询中删除不必要的数据</p></figure><p id="f8cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做之后，如果我们回到我们的应用程序，我们会发现什么都没有改变。这就是GraphQL的强大之处。您可以只要求您正在使用的数据，并节省一些网络带宽。</p><p id="967c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续前进。我们的第二个查询将是<code class="fe mz na nb nc b">Mutation</code>，向我们的后端服务添加一些数据。让我们在<code class="fe mz na nb nc b">src</code>文件夹中创建一个新组件，将任务添加到我们的后端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/335c424c27b827e010c5bcf37717ca4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*WZp_ZkHiO3sa0I3wb1Vwew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建新组件以添加任务</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="280b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建组件是为了在后端创建<code class="fe mz na nb nc b">Task</code>。让我们把它添加到我们的<code class="fe mz na nb nc b">App.js</code>文件中，看看它看起来怎么样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/83cd14d1e3d7bb2f5d9790faac6e8092.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*SS7m-lCZaAxb8OSqCLzoFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a></p></figure><p id="ede8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们看到了我们的新组件。我们来添加一些任务，看看是否有效。我们添加了一个名为Add New Task的新任务，但只是在刷新页面之后，因为这时会发生数据的重新提取。我们可以很容易地解决这个问题，但我们应该感到高兴，因为现在我们能够在后端服务上与查询和变异进行交互。我们可以通过只请求我们的前端服务所需的数据来非常高效地做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/361a3ebbad6f5b91d65021a8dae25985.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Ih-JEAOEOiBDDBub5T1rkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7273" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">再蚀刻</h1><p id="f8e8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Apollo Client给我们的另一个真正有用的方法叫做<code class="fe mz na nb nc b">refetch</code>。顾名思义，如果我们觉得数据可能被更新了，我们可以再次获取一些数据。让我们看看如何使用这种方法。要使用它，我们可能需要对代码进行一些重构。但是首先，让我们看看这个方法在哪里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f33201c8de62be4954af3fb1df427912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oR1NZtvKi4dV-fE2hHSTBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从useQuery中引用方法</p></figure><p id="c2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论我们在哪里使用<code class="fe mz na nb nc b">useQuery</code>，我们都可以使用<code class="fe mz na nb nc b">refetch</code>方法。重新提取使您能够刷新查询结果以响应特定的操作。在我们的例子中，每当我们添加新任务时，我们可以使用<code class="fe mz na nb nc b">refetch</code>方法来获取额外的任务。因此，让我们做一些重构，将状态向上移动一级，这样我们就可以将这个方法传递给<code class="fe mz na nb nc b">AddTask</code>组件来使用它。让我们创建另一个名为<code class="fe mz na nb nc b">TaskContainer</code>的组件，并在其中移动我们的<code class="fe mz na nb nc b">AddTask</code>和<code class="fe mz na nb nc b">Task</code>组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ba1d71886f71049b4ea72fac922f736b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*ej6NmfXykoJxU0C8s9vwXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务容器. js</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经将<code class="fe mz na nb nc b">Task</code>组件的状态向上移动了一级，我们可以将这个状态作为<code class="fe mz na nb nc b">props</code>传递给我们的<code class="fe mz na nb nc b">Task</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有改变我们的任务组件，除了现在没有本地状态，我们有来自<code class="fe mz na nb nc b">props</code>的状态。在我们的<code class="fe mz na nb nc b">App.js</code>文件中，我们只需要导入我们新创建的组件，重构就快完成了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用我们的<code class="fe mz na nb nc b">refetch</code>方法。如您所知，我们已经将该方法传递给了<code class="fe mz na nb nc b">AddTask</code>组件，因此我们可以通过<code class="fe mz na nb nc b">props</code>访问该方法。让我们进入我们的<code class="fe mz na nb nc b">AddTask.js</code>文件，看看我们想做什么。每当我们添加一个新任务时，我们都希望重新提取所有的任务，所以在成功添加新任务后，我们可以在我们的<code class="fe mz na nb nc b">onSubmit </code>调用中添加<code class="fe mz na nb nc b">refetch</code>方法。让我们看看那是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e05f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">投票</h1><p id="8eb1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们回到浏览器并添加一个新任务时，我们不必刷新页面；我们在那里看到我们新添加的任务。我知道我们可以不通过网络调用用很多方法来实现，但是在这里我想展示我们从Apollo Client得到的方法，这些方法可以在很多其他情况下帮助我们。</p><p id="5208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe mz na nb nc b">refetch</code>之外，我们还获得了轮询，在轮询中，我们可以指定在多少时间间隔之后我们希望特定的查询触发并从后端服务获取数据。轮询通过以指定的时间间隔定期执行查询来提供与服务器的近乎实时的同步。让我们看一个投票的小例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9fd8379cbacd68531d912efc9499dc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyO-QIFCEoCqGEEN_3dtlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">投票</p></figure><p id="995d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将轮询指定为500，我们将每隔0.5秒从后端服务获取任务。这些小方法在某些情况下会很方便，并且很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c27" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">提取策略</h1><p id="30cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Apollo客户端最重要的一点是它为我们提供了内置的缓存。我们可以通过指定<code class="fe mz na nb nc b">fetchPolicy</code>来指定如何从我们的后端获取数据。当您构建高响应性和快速的应用程序时，这非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/96d687e2a87dc375bd65cb434b7c87df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKIW-uGLyA2abd09tbd45w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取策略Apollo客户端</p></figure><p id="ba39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许您指定何时从服务器获取结果，以及何时从本地缓存加载数据。fetch策略告诉Apollo是优先从服务器获取最新数据还是从缓存获取更快的响应。如何根据您的用例定义您的获取策略完全由您决定。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d018" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2c9c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用GraphQL创建一个应用程序可以给你带来很多好处。有很多很棒的库可以做到这一点，但是到目前为止，Apollo Client是最好的库之一，它提供了很多有用的方法，在某些情况下非常有用。用GraphQL构建服务可以给你带来很多好处，比如节省带宽。客户对数据有更多的控制权，包括他们想要什么数据，什么数据对构建某些组件有用，什么不有用。</p></div></div>    
</body>
</html>