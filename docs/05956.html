<html>
<head>
<title>Level Up Your Asynchronous JavaScript Skills by Implementing a Bluebird-Style Promise.map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现蓝鸟风格的Promise.map来提升您的异步JavaScript技能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-your-own-bluebird-style-promise-map-in-js-7c081b7ad02c?source=collection_archive---------3-----------------------#2020-08-20">https://betterprogramming.pub/implement-your-own-bluebird-style-promise-map-in-js-7c081b7ad02c?source=collection_archive---------3-----------------------#2020-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1be6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更好的异步性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec1f49abf5036dc3efb6ab8ba15f01df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5S_1o7Iv9Jwsko2kjME3A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@valentinantonucci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">瓦伦丁·安托努奇</a>在<a class="ae kv" href="https://unsplash.com/s/photos/promise?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="03e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在工作中用<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>做了很多网页抓取。通常，您不希望一次启动所有API调用，因为这样做可能会淹没其他人的服务器，触发他们的DDoS保护，或者更糟，使他们离线。</p><p id="6b7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web上的数据抓取通常分两步完成:</p><ol class=""><li id="a7cd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">您访问一个索引页面，在那里您可以找到所有子资源的“列表”,您可以调用它来获取一些细节。以资产门户为例。网站可能会按位置组织酒店信息，或者每个酒店都有自己的页面。</li><li id="0e8a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您将一个接一个地访问步骤1中列表上的项目，以获取详细信息。</li></ol><p id="9eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将所有step 2 API调用包装在一个巨大的<code class="fe mg mh mi mj b">Promise.all</code>中肯定不是一个好主意。正确的方法是使用交错和/或速率限制。JavaScript的<code class="fe mg mh mi mj b">Promise</code>非常适合交错，因为很容易从<code class="fe mg mh mi mj b">Promise</code>创建瀑布行为。你只需<code class="fe mg mh mi mj b">.then</code>所有的调用，让它们一个接一个地发生。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d11a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要限制速率，您可以引入一个定时延迟:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="10d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种延迟实现之间有细微的差别。第一个方法在调用之前等待1000毫秒，而第二个方法首先调用，并等待1000毫秒来传递结果。这种差异在下图中非常明显:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/ed7fe5447848e79b8ea310b620b93fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Axt6SJ_t1J-8V-QbM1xeEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="5d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然瀑布模式在项目列表很小时很有用，但在较大的列表中会非常慢，因为您实际上是在“单线程”上运行我们能做得更好吗？</p><p id="054a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是肯定的。它使用的是<code class="fe mg mh mi mj b">bluebird</code>中的承诺API扩展之一<code class="fe mg mh mi mj b">Promise.map</code>。这里的神奇之处在于<code class="fe mg mh mi mj b">concurrency</code>选项。</p><div class="mn mo gp gr mp mq"><a href="http://bluebirdjs.com/docs/api/promise.map.html" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">Promise.map</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">给定一个有限的(数组是可迭代的)，或一个可迭代的承诺，从而产生承诺(或承诺和…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">bluebirdjs.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kp mq"/></div></div></a></div><p id="3e76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">concurrency</code>所做的是让你设置一次“线程”的最大数量。<code class="fe mg mh mi mj b">Promise.all</code>对“线程”的数量没有限制如果我的列表包含1000个条目，那么将同时触发1000个API调用<em class="nf"/>。另一方面，如果我使用上面显示的瀑布模式，我最终会处理一个“线程”<code class="fe mg mh mi mj b">Promise.map</code>提供了一个中间地带。</p><p id="33a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mg mh mi mj b">concurrency</code>是一个如此有用的选择，为什么它不首先在<code class="fe mg mh mi mj b">Promise.all</code>实施呢？</p><p id="698c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">Promise.all</code>:</p><ul class=""><li id="0436" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ng ly lz ma bi translated">接受一个数组作为它的唯一参数。</li><li id="11b0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated">该数组包含未决承诺，当数组中的每个承诺都已解析时,<code class="fe mg mh mi mj b">Promise.all</code>将解析。</li></ul><p id="9976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">Promise.map</code>:</p><ul class=""><li id="f6fa" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ng ly lz ma bi translated">接受数组和映射函数。</li><li id="69db" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated">将对数组中的每个项目调用mapper函数，每次都返回一个待定承诺。当所有返回的承诺解决后，<code class="fe mg mh mi mj b">Promise.map</code>解决。</li></ul><p id="5d5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为没有用<code class="fe mg mh mi mj b">Promise.all</code>传入函数，所以所有未决的承诺一定是在其他地方生成的(通过调用API调用函数)。所以当<code class="fe mg mh mi mj b">Promise.all</code>收到未决承诺集合时，所有的调用都已经开始了。另一方面，<code class="fe mg mh mi mj b">Promise.map</code>可以随意调度调用，因为它对输入数组和映射函数进行操作，将输入转换为输出。也就是说，使用<code class="fe mg mh mi mj b">Promise.all</code>实现<code class="fe mg mh mi mj b">Promise.map</code>行为并非不可能。</p><p id="7b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢尽可能多地使用原生的<code class="fe mg mh mi mj b">Promise</code>，我发现为一个函数安装一个完整的<code class="fe mg mh mi mj b">bluebird</code>模块是不经济的。所以我想，“为什么不写我自己的<code class="fe mg mh mi mj b">Promise.map</code>？”</p><p id="05a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用原生的<code class="fe mg mh mi mj b">Promise.all</code>实现<code class="fe mg mh mi mj b">Promise.map</code>的技巧是不在输入数组的映射版本上调用<code class="fe mg mh mi mj b">Promise.all</code>,而是在一个包含线程的更小的数组上调用<code class="fe mg mh mi mj b">Promise.all</code>,这些线程基本上是前面显示的瀑布模式的副本。这个数组的大小由<code class="fe mg mh mi mj b">concurrency</code>选项控制。这是一个直观的表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/59dc87a64c5485dab3a7b294b7ef2281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9U-z8QhSnEUMCCrJAbp_w.png"/></div></div></figure><p id="b402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和一个基本实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><ul class=""><li id="7a1c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ng ly lz ma bi translated">第8-12行设置了<code class="fe mg mh mi mj b">concurrency</code>线程。</li><li id="ef68" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated">内部函数<code class="fe mg mh mi mj b">wrappedMapper</code>(第16-23行)处理并发线程的填充。</li></ul><p id="f376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次调用<code class="fe mg mh mi mj b">wrappedMapper</code>时，它都会执行以下操作:</p><ol class=""><li id="8cf2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将输入数组中的下一项出队。</li><li id="98b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对输入调用映射器函数。</li><li id="908e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">等待调用返回的承诺解决。</li><li id="fd5a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将已解析的项放入输出数组中(在相应的索引处)。</li><li id="0304" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果输入数组中还有剩余项，则再次调用自身。</li></ol><p id="2af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出<code class="fe mg mh mi mj b">Promise.map</code>函数是瀑布模式的一个更一般的实现。在一个极端，如果<code class="fe mg mh mi mj b">concurrency</code>被设置为<code class="fe mg mh mi mj b">1</code>，它的行为与简单的瀑布模式完全一样。如果没有设置<code class="fe mg mh mi mj b">concurrency</code>，则默认为另一个极端，即<code class="fe mg mh mi mj b">Infinity</code>。然后，它的行为类似于<code class="fe mg mh mi mj b">Promise.all</code>，在整个输入数组的前面调用<code class="fe mg mh mi mj b">mapper</code>。</p><p id="dc63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的基本实现有两个突出的问题:</p><ol class=""><li id="7ac5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">内部函数<code class="fe mg mh mi mj b">wrappedMapper</code>假设<code class="fe mg mh mi mj b">mapper</code>总是返回一个承诺或结果。如果<code class="fe mg mh mi mj b">mapper</code>返回一个不可命名的值，将抛出一个未定义的属性错误。</li><li id="39e3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">根据<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> MDN web docs </a> , <code class="fe mg mh mi mj b">Promise.all</code>接受一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">可迭代</a>——不仅仅是数组。在<code class="fe mg mh mi mj b">Promise.map</code>的情况下，传递一个iterable意味着可以提供一个不固定的输入列表。这对于处理API调用失败时的重试特别有用。</li></ol><p id="26fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个更完整的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4a42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何确保从<code class="fe mg mh mi mj b">mapper</code>返回一个名称？一种可能的方法是检查<code class="fe mg mh mi mj b">.then</code>方法的存在，并分别处理可命名和不可命名。更健壮的方法是将返回值包装在<code class="fe mg mh mi mj b">Promise.resolve</code>中。它确保了<code class="fe mg mh mi mj b">.then</code>方法始终存在，避免了类型检查和单独处理的需要。</p><ul class=""><li id="bc30" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ng ly lz ma bi translated"><code class="fe mg mh mi mj b">Promise.resolve</code>应用于第22行。</li><li id="b6e9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated">第18行用迭代器对象替换了数组索引。</li></ul><p id="28d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用相同的逻辑来实现<code class="fe mg mh mi mj b">Promise.filter</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d5f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天关于JS异步编程的文章到此结束。感谢您的阅读！</p></div></div>    
</body>
</html>