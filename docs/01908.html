<html>
<head>
<title>My CoreData Migration (Test)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的核心数据迁移(测试)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-coredata-migration-test-53402ea2a363?source=collection_archive---------17-----------------------#2019-10-21">https://betterprogramming.pub/my-coredata-migration-test-53402ea2a363?source=collection_archive---------17-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a86c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻量级和重量级迁移演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/01c3d5895bea4a40d3ce2f6ffa5f9856.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*egSx1bJPda-6pFt2Lz5i_w.png"/></div></figure><p id="d7c3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我在<code class="fe lj lk ll lm b">CoreData</code>上工作时，我通常能够执行到新模型版本的轻量级迁移。但是每当遇到更复杂的用例时，我都在努力寻找解决方案。</p><p id="41bf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是我写这篇文章的原因。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="7442" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是首先，轻量级迁移和重量级迁移有什么区别？</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="8089" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">轻量级迁移</h1><blockquote class="mm mn mo"><p id="0d01" class="kn ko mp kp b kq kr jr ks kt ku ju kv mq kx ky kz mr lb lc ld ms lf lg lh li ij bi translated">核心数据通常可以执行自动数据迁移，称为轻量级迁移。轻量级迁移根据源和目标托管对象模型之间的差异来推断迁移。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://developer.apple.com/documentation/coredata/using_lightweight_migration" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">使用轻量级迁移</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">核心数据通常可以执行自动数据迁移，称为轻量级迁移。轻量级…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">developer.apple.com</p></div></div></div></a></div><p id="e43a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对我来说，这意味着简单的用例，比如添加和重命名变量，或者创建新的关系和对象。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="7c7b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">重量级迁移</h1><blockquote class="mm mn mo"><p id="5a26" class="kn ko mp kp b kq kr jr ks kt ku ju kv mq kx ky kz mr lb lc ld ms lf lg lh li ij bi translated">当对数据模型的更改超出轻量级迁移的能力时，在极少数情况下使用重量级(手动)迁移。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://developer.apple.com/documentation/coredata/heavyweight_migration" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">重量级迁移</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在极少数情况下，当对数据模型的更改超出轻量级的能力时，使用重量级(手动)迁移…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">developer.apple.com</p></div></div></div></a></div></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="93b0" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">从轻量级迁移的测试开始</h1><p id="d40d" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">先说一个简单的<code class="fe lj lk ll lm b">CoreData</code>模型。我们有一个人，他有一个名字，一个姓氏，以及他是否是老师的信息(作为一个布尔人)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/811de0cf37495e1dbd24269a16fe1a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*wF0vzG3iUqt5zzvxht3r4w.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">模型1</p></figure><p id="3e93" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，我们很快意识到这个模型不足以满足我们的新目的。新模型更改了变量名，并添加了变量“年龄”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4381c8184211d9f3de3986436f53e5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*ic00xUj4UK3NK_2eDSA2nQ.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">模型2</p></figure><p id="ec01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为这个修改是通过轻量级迁移完成的，所以我们现在已经完成了新模型版本的创建。但是如果我们在XCUnitTests的帮助下测试迁移，我们会感觉好很多！</p><p id="03e7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是执行此操作的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="4b50" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志1:</h2><p id="61dd" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">加载<code class="fe lj lk ll lm b">ManagedObjectModel</code>并用包含SQLite文件URL的<code class="fe lj lk ll lm b">PersistentStoreCoordinator</code>初始化<code class="fe lj lk ll lm b">NSManagedObjectContex</code>。</p><h2 id="129f" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志2:</h2><p id="615a" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">为迁移添加一些测试数据。在这种情况下，它是一个人是一名教师。</p><h2 id="329a" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志3:</h2><p id="2c8d" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">加载作为迁移目的地的<code class="fe lj lk ll lm b">ManagedObjectModel</code>。对于轻量级迁移，我们必须设置以下选项:</p><ul class=""><li id="f125" class="oe of iq kp b kq kr kt ku kw og la oh le oi li oj ok ol om bi translated"><code class="fe lj lk ll lm b">NSInferMappingModelAutomaticallyOption</code></li><li id="6cf8" class="oe of iq kp b kq on kt oo kw op la oq le or li oj ok ol om bi translated"><code class="fe lj lk ll lm b">NSMigratePersistentStoresAutomaticallyOption</code></li></ul><p id="979d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这使得<code class="fe lj lk ll lm b">CoreData</code>知道它应该尝试自动迁移。<br/>然后我们创建<code class="fe lj lk ll lm b">PersistentStoreCoordinator</code>并添加一个<code class="fe lj lk ll lm b">PersistentStore</code>。使用与第一个模型版本相同的URL很重要。</p><h2 id="1459" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志4:</h2><p id="d099" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">我们现在可以测试迁移，我们可以看到变量已被重命名，并添加了“age”。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="43fc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">重量级迁移</h1><p id="ed68" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">因为我们知道每个人是否是一个<code class="fe lj lk ll lm b">teacher</code>，我们想把他们分成<code class="fe lj lk ll lm b">teachers</code>和<code class="fe lj lk ll lm b">students</code>。为此，我们需要创建一个新对象<code class="fe lj lk ll lm b">Person(teacher: true)</code>-&gt;-<code class="fe lj lk ll lm b">Teacher &amp; Persons(teacher: false)</code>-&gt;-<code class="fe lj lk ll lm b">Student</code>。<br/>我们将通过添加新的CoreData模型版本3来实现这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ot ou di ov bf ow"><div class="gh gi os"><img src="../Images/9abae513431b31504d6c9c4d80de4885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cATQI9bbPZg2SkbISfeEA.png"/></div></div></figure><p id="9c17" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了执行这个迁移，我们需要一个映射模型和一个定制的迁移策略。您可以删除除一个实体映射之外的所有实体映射。现在我们需要为迁移添加一个自定义策略。确保在自定义策略类名前面添加项目名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ot ou di ov bf ow"><div class="gh gi ox"><img src="../Images/1f88b5cfe9de02837f98d72ee2e09558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVgo-2pPhswkutUpRN6MKA.png"/></div></div></figure><p id="f85c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们需要<code class="fe lj lk ll lm b">EntityMigrationPolicy</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="a010" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志1:</h2><p id="7508" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">检查实体是否是一个<code class="fe lj lk ll lm b">person</code>。</p><h2 id="0ae0" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志2:</h2><p id="752c" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">从实体中获取名称</p><h2 id="9465" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志3:</h2><p id="253b" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">创建一个<code class="fe lj lk ll lm b">teacher</code>或一个<code class="fe lj lk ll lm b">student</code>并再次添加<code class="fe lj lk ll lm b">values</code>。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="5da0" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">测试重量级迁移</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="c7c0" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志1:</h2><p id="a507" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">正如<code class="fe lj lk ll lm b">LightWeight</code>迁移一样，我们将读取旧模型并创建<code class="fe lj lk ll lm b">ManagedObjectContext</code>。</p><h2 id="ae34" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志2:</h2><p id="48fb" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">这里我们添加了应该迁移的新元素</p><h2 id="f390" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志3:</h2><p id="2ee1" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">在这里，我们迁移到新的模型版本。因此，我们需要获得映射模型，并用旧模型和新模型创建<code class="fe lj lk ll lm b">MigrationManager</code>。然后，我们在管理器和映射模型的帮助下运行迁移。然后我们加载新的<code class="fe lj lk ll lm b">ManagedObjectContext</code>。</p><h2 id="5bda" class="ns lv iq bd lw nt nu dn ma nv nw dp me kw nx ny mg la nz oa mi le ob oc mk od bi translated">标志4:</h2><p id="056a" class="pw-post-body-paragraph kn ko iq kp b kq nf jr ks kt ng ju kv kw nh ky kz la ni lc ld le nj lg lh li ij bi translated">最后，我们添加一些测试来验证迁移是否成功。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="2bee" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望这篇文章能帮助你测试你的<code class="fe lj lk ll lm b">CoreData</code>迁移代码！</p><div class="mt mu gp gr mv mw"><a href="https://github.com/Monntay/CoreDataMigration" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">Monntay/CoreDataMigration</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kl mw"/></div></div></a></div></div></div>    
</body>
</html>