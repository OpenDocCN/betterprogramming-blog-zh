<html>
<head>
<title>Unit Test Best Practices in Xcode and Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xcode和Swift中的单元测试最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-test-best-practices-in-xcode-and-swift-bed60ba38c48?source=collection_archive---------4-----------------------#2019-09-03">https://betterprogramming.pub/unit-test-best-practices-in-xcode-and-swift-bed60ba38c48?source=collection_archive---------4-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8175089bee7fb81b5e636ca564ec897c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2jW9IqhWzWns4OBq1-t_g.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@markusspiske" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kf" href="https://unsplash.com/photos/VZnmCtD5KdI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写单元测试和编写应用程序代码一样重要。当截止日期临近时，单元测试通常是第一个被跳过的。具有讽刺意味的是，这可能是项目最终放缓的原因。如果你已经写了很多单元测试来覆盖你的应用程序的大部分逻辑，一旦你的项目成长了，你会感谢你未来的自己。</p><p id="aca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并不包括对内存泄漏的<a class="ae kf" href="https://www.avanderlee.com/swift/memory-leaks-unit-tests/" rel="noopener ugc nofollow" target="_blank">测试</a>或<a class="ae kf" href="https://www.avanderlee.com/swift/ui-test-share-extension/" rel="noopener ugc nofollow" target="_blank">编写共享扩展的UI测试</a>，而是主要关注编写更好的单元测试。我也将分享我的最佳实践，它帮助我开发更好更稳定的应用程序。</p><p id="a1cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你写好了测试，就该运行它们了。有了下面的建议，当那个时刻到来时，你会变得更有效率。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="baef" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是单元测试？</h1><p id="45e5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">单元测试是自动化测试，它运行并验证一段代码(称为<em class="mo">单元</em>)，以确保它的行为符合预期并符合其设计。</p><p id="dd37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单元测试在Xcode中有自己的目标，并使用<a class="ae kf" href="https://developer.apple.com/documentation/xctest" rel="noopener ugc nofollow" target="_blank"> XCTest框架</a>编写。<code class="fe mp mq mr ms b">XCTestCase</code>的子类包含要运行的测试方法，其中只有以<code class="fe mp mq mr ms b">test</code>开头的方法会被Xcode解析并可以运行。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="6a94" class="nb lm it ms b gy nc nd l ne nf">/// A simple struct containing a list of users.<br/>struct UsersViewModel {<br/>    let users: [String]<br/><br/>    var hasUsers: Bool {<br/>        return !users.isEmpty<br/>    }<br/>}<br/><br/>/// A test case to validate our logic inside the `UsersViewModel`.<br/>final class UsersViewModelTests: XCTestCase {<br/><br/>    /// It should correctly reflect whether it has users.<br/>    func testHasUsers() {<br/>        let viewModel = UsersViewModel(users: ["Antoine", "Jaap", "Lady"])<br/>        XCTAssertTrue(viewModel.hasUsers)<br/>    }<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="700a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">编写单元测试时的心态</h1><p id="31b1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当编写高质量的单元测试时，你的心态是很重要的。有了一些基本原则，您就可以确保在编写您的应用程序最需要的测试时高效且专注。</p><h2 id="b17a" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">您的测试代码和您的应用程序代码一样重要</h2><p id="4476" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在我们深入实际应用技巧之前，我首先想提一个重要的心态。就像编写应用程序代码一样，您应该尽力为测试编写高质量的代码。</p><p id="eb87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑重用代码、使用协议、定义属性(如果它们在多个测试中使用),并确保您的测试清理所有创建的数据。这将使你的单元测试更容易维护，并防止奇怪的失败测试。</p><h2 id="dabc" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">100%的代码覆盖率不应该是你的目标</h2><p id="791b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">虽然100%的覆盖率是一个很大的目标，但是它不应该是你写测试的主要目标。确保首先至少测试您最重要的业务逻辑，因为这已经是一个很好的开始。达到100%可能相当耗时，而且好处并不总是那么大。事实上，要达到100%可能需要很大的努力。</p><p id="9d8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最重要的是，100%的覆盖率可能会产生误导。上面的单元测试例子有100%的覆盖率，因为它达到了所有的方法。然而，它没有测试所有的场景——它只测试了一个非空数组，也可能有一个空数组的场景，其中<code class="fe mp mq mr ms b">hasUsers</code>属性应该返回false。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/94e3939b244824f51dc8ef551c65443c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FICw0aqgj2freCdI.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">可以通过编辑您的方案来启用单元测试代码覆盖率</p></figure><h2 id="f36a" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">在修复bug之前写一个测试</h2><p id="fc4e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">跳到一个bug上并尽快修复它是很有诱惑力的。虽然这很好，但如果您能防止将来再次出现同样的错误，那就更好了。</p><p id="1344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过在修复bug之前编写单元测试，您可以确保相同的bug不会再次发生。将其视为测试驱动的错误修复，从现在开始被称为TDBF。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0b43" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">用Swift编写单元测试</h1><p id="6920" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">既然你已经有了正确的心态，那么是时候实际回顾一下用Swift编写单元测试的一些技巧了。</p><p id="7e62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多种方法可以测试相同的结果，但是当测试失败时，它们并不总是给出相同的反馈。以下提示将帮助您编写测试，这对您作为开发人员是有帮助的。</p><h2 id="608d" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">命名测试用例及方法</h2><p id="72a2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">给你的测试用例和方法起一个好名字有助于你快速识别失败的测试。此外，它还帮助您探索您是否已经测试了某个场景或某段代码。</p><p id="d683" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了容易地找到某个类的测试用例，建议使用相同的命名和“测试”我们在上面的例子中做到了这一点，在这个例子中，我们根据<code class="fe mp mq mr ms b">UsersViewModel</code>命名来命名<code class="fe mp mq mr ms b">UsersViewModelTests</code>。</p><h2 id="ea94" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">不要对任何事情都使用XCTAssert</h2><p id="6a49" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">以下代码行测试了完全相同的结果:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="a81f" class="nb lm it ms b gy nc nd l ne nf">func testEmptyListOfUsers() {<br/>    let viewModel = UsersViewModel(users: ["Ed", "Edd", "Eddy"])<br/>    XCTAssert(viewModel.users.count == 0)<br/>    XCTAssertTrue(viewModel.users.count == 0)<br/>    XCTAssertEqual(viewModel.users.count, 0)<br/>}</span></pre><p id="50fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，该方法正在测试一个空的用户列表。然而，我们定义的视图模型不是空的，因此，所有断言都失败了。</p><p id="9531" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果显示了为什么对验证类型使用正确的断言很重要。<code class="fe mp mq mr ms b">XCTAssertEqual</code>方法为我们提供了更多关于断言失败原因的上下文。这不仅显示在红色错误中，还显示在控制台日志中，这有助于您更快地识别失败的测试。</p><h2 id="c99a" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">安装和拆卸</h2><p id="8d4e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在多个测试方法中使用的参数可以被定义为测试用例类中的属性。您可以使用<code class="fe mp mq mr ms b">setUp()</code>方法来设置每个测试方法的初始状态，并使用<code class="fe mp mq mr ms b">tearDown()</code>方法来清除。</p><p id="f209" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">苹果有一些关于这些方法的很棒的<a class="ae kf" href="https://developer.apple.com/documentation/xctest/xctestcase/understanding_setup_and_teardown_for_test_methods" rel="noopener ugc nofollow" target="_blank">文档</a>，可以帮助你理解如何正确地使用它们。</p><p id="fd39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">提示:</strong>您还可以向设置和拆卸方法中添加断言，使它们在每个测试中运行。</p><h2 id="3995" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">投掷方法</h2><p id="a6d1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">就像写应用程序代码的时候，你也可以定义一个抛出测试方法。这允许您在测试中的方法抛出错误时使测试失败。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="342c" class="nb lm it ms b gy nc nd l ne nf">func testDecoding() throws {<br/>    /// When the Data initializer is throwing an error, the test will fail.<br/>    let jsonData = try Data(contentsOf: URL(string: "user.json")!)<br/><br/>    /// The `XCTAssertNoThrow` can be used to get extra context about the throw<br/>    XCTAssertNoThrow(try JSONDecoder().decode(User.self, from: jsonData))<br/>}</span></pre><p id="bde5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当在任何进一步的测试执行中不需要抛出方法的结果时，可以使用<code class="fe mp mq mr ms b">XCTAssertNoThrow</code>方法。</p><p id="a925" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保检查相反的<code class="fe mp mq mr ms b">XCTAssertThrowsError</code>方法，以匹配预期的错误类型。</p><h2 id="718e" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">展开可选值</h2><p id="0c8f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">Xcode 11中的新特性是<code class="fe mp mq mr ms b">XCTUnwrap</code>方法，它最适合用在抛出测试方法中，因为它是一个抛出断言。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="d131" class="nb lm it ms b gy nc nd l ne nf">func testFirstNameNotEmpty() throws {<br/>    let viewModel = UsersViewModel(users: ["Antoine", "Maaike", "Jaap"])<br/><br/>    let firstName =  try XCTUnwrap(viewModel.users.first)<br/>    XCTAssertFalse(firstName.isEmpty)<br/>}</span></pre><p id="9243" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mp mq mr ms b">XCTUnwrap</code>断言可选变量的值不是<code class="fe mp mq mr ms b">nil</code>，如果断言成功，则返回其值。它阻止你编写一个<code class="fe mp mq mr ms b">XCTAssertNotNil</code>结合解包或者处理剩余测试代码的条件链接。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9d7c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在Xcode中运行单元测试</h1><p id="4f0a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">一旦你写好了测试，就该运行它们了。</p><h2 id="7682" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">重新运行最新测试</h2><p id="a8e2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<br/> <code class="fe mp mq mr ms b">⌃ Control + ⌥ Option + ⌘ Command + G</code>再次运行您最后一次运行的测试。</p><h2 id="1e73" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">运行组合测试</h2><p id="59f2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用CTRL或SHIFT键选择您想要运行的测试，右键单击并选择“运行X测试方法”</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/cbbd5b73b6b212f990c797460a264412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ohVg7AFkOKUdqNr.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">一次运行多个单元测试</p></figure><h2 id="0d7e" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">在测试导航器中应用过滤器</h2><p id="6140" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">test navigator底部的过滤栏允许您缩小测试概述的范围。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/28a4534e70879dd87fcad37ef77700fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/0*ZV_2CfVGd5wRoYO4.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">测试导航器过滤栏</p></figure><ul class=""><li id="a512" class="nu nv it ki b kj kk kn ko kr nw kv nx kz ny ld nz oa ob oc bi translated">使用搜索字段根据名称搜索特定测试</li><li id="b620" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">仅显示当前所选方案的测试(如果您有多个测试方案，这很有用)</li><li id="d1d2" class="nu nv it ki b kj od kn oe kr of kv og kz oh ld nz oa ob oc bi translated">仅显示失败的测试(这将帮助您快速找到失败的测试)</li></ul><h2 id="f5f8" class="nb lm it bd ln ng nh dn lr ni nj dp lv kr nk nl lz kv nm nn md kz no np mh nq bi translated">在侧边栏中启用覆盖</h2><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/95cb2ad2fab2c5e67b2d334e82082b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*219WeJ0hihMyDeU0.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">显示测试覆盖率迭代计数</p></figure><p id="022b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显示测试迭代计数可以向您显示在最后一次运行测试期间是否命中了某段代码。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/c895aebcd3a445e8e80d04ec236560f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zUMlaLf0OO43FqPV.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">测试覆盖率以内联方式显示</p></figure><p id="624c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它显示迭代的次数(在上面的例子中是18次),当达到次数时，一段代码变成绿色。当一段代码为红色时，意味着它在最后一次运行测试中没有被覆盖。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1ef3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="1c4f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如您所见，您可以做很多事情来使编写单元测试变得更加容易。改变心态，使用正确的设置，不要到处使用<code class="fe mp mq mr ms b">XCTAssert</code>。</p><p id="c506" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢！</p></div></div>    
</body>
</html>