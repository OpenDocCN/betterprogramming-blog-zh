<html>
<head>
<title>Empowered Lifecycle-Aware ViewModel For Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持Android的生命周期感知视图模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/empowered-lifecycle-aware-viewmodel-for-android-f495de9a8170?source=collection_archive---------7-----------------------#2022-04-04">https://betterprogramming.pub/empowered-lifecycle-aware-viewmodel-for-android-f495de9a8170?source=collection_archive---------7-----------------------#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2593" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将生命周期事件委托给视图模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/93b7983d91b14f13c18fdc695ddb25f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*87OBa0qB-VukSrUW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马特·哈德森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图模型的存在是为了从视图中去掉所有的业务逻辑。无论您如何构建视图模型，一些逻辑仍然与视图的生命周期紧密相关。例如，一个小的用例是在每次打开屏幕时执行一些跟踪。假设这个屏幕注入了一个ViewModel，并且这个ViewModel理所当然地拥有跟踪逻辑，那么您需要检测何时触发这样的操作。</p><p id="b898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为生命周期属于视图的领域，所以您可以将它留给视图负责——例如，覆盖<code class="fe ls lt lu lv b">onResume</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7719" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不要忘记为什么我们要使用视图模型。最终，我们打算将这个业务逻辑提取到ViewModel中进行测试。有了这个架构，我们可以对实现进行单元测试——已经用正确的参数调用了跟踪，如果您使用的是<a class="ae kv" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>，就调用<code class="fe ls lt lu lv b">verify</code>。</p><p id="ce0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可悲的是，我们无法测试我们的行为。我们不能断言跟踪是在用户打开屏幕时发生的。只是跟踪被正确地实现了。这是一个巨大的差异！更不用说它不能很好地扩展。如果有人无意中删除了您视图中的这部分代码，您将得到:</p><ul class=""><li id="0873" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">这是一种倒退，因为你不再跟踪你打开的屏幕。</li><li id="af98" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">视图模型中的一些死代码。</li><li id="b58f" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">绿色单元测试覆盖了一个未插电的用例。</li></ul><p id="5026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我已经说明了我的情况，让我们看看如何让我们的视图模型生命周期意识到。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="9453" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">生命周期感知组件</h1><p id="c122" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">了解生命周期可以让您观察特定视图发生的任何生命周期事件。基本上，您将这些事件从视图转移到视图模型。</p><p id="dce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ViewModel已经通过它的<code class="fe ls lt lu lv b">onCleared</code>回调来响应生命周期事件。ViewModel的生命周期与视图不同，但当不再需要它时会得到通知。</p><p id="4921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进一步增强其生命周期意识，我们可以依赖Google的Jetpack库<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.android.com/topic/libraries/architecture/lifecycle" rel="noopener ugc nofollow" target="_blank">androidx.lifecycle</a></code>。当您想让一个组件具有生命周期意识时，只需实现它的<code class="fe ls lt lu lv b">LifecycleObserver</code>接口，并将其声明为您想要观察的生命周期所有者的观察者。如果你不需要对所有的生命周期事件做出反应，你可以使用<code class="fe ls lt lu lv b">DefaultLifecycleObserver</code>界面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个生命周期感知视图模型，您不再需要在视图中覆盖<code class="fe ls lt lu lv b">onResume</code>。视图模型负责所有的业务逻辑。恭喜你！</p><p id="b984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是测试呢？所以我们才这么做对吗？</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="b3ab" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">测试，测试</h1><p id="ec59" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我编写了一个空壳来测试我们的视图模型</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="00ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这个测试有效，我们需要一个从一种状态转换到另一种状态的机制。我们需要三样东西:</p><ol class=""><li id="fbf2" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr nq me mf mg bi translated">一个<code class="fe ls lt lu lv b">LifecycleRegistry</code>来操纵生命周期状态。</li><li id="6338" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr nq me mf mg bi translated">一个<code class="fe ls lt lu lv b">LifecycleOwner</code>我们传递到<code class="fe ls lt lu lv b">LifecycleRegistry</code>。</li><li id="f1a6" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr nq me mf mg bi translated">A <code class="fe ls lt lu lv b">LifecycleObserver</code>:我们用例的测试视图模型。</li></ol><p id="dd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建一个<code class="fe ls lt lu lv b">LifecycleRegistry</code>，我们可以使用专门为测试设计的<code class="fe ls lt lu lv b">createUnsafe</code>方法。我们将把<code class="fe ls lt lu lv b">LifecycleOwner</code>注入到<code class="fe ls lt lu lv b">LifecycleRegistry</code>中作为模拟:</p><pre class="kg kh ki kj gt nr lv ns nt aw nu bi"><span id="ed17" class="nv mu iq lv b gy nw nx l ny nz">val lifecycleOwner = mock&lt;LifecycleOwner&gt;()<br/>val lifecycleRegistry = LifecycleRegistry.createUnsafe(lifecycleOwner)</span></pre><p id="bb39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要将视图模型注册到<code class="fe ls lt lu lv b">LifecycleRegistry</code>。</p><pre class="kg kh ki kj gt nr lv ns nt aw nu bi"><span id="2b79" class="nv mu iq lv b gy nw nx l ny nz">lifecycleRegistry.addObserver(viewModel)</span></pre><p id="8c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您可以指向所需的生命周期状态:</p><pre class="kg kh ki kj gt nr lv ns nt aw nu bi"><span id="5ff6" class="nv mu iq lv b gy nw nx l ny nz">lifecycleRegistry.<em class="oa">currentState </em>= Lifecycle.State.<em class="oa">RESUMED</em></span></pre><p id="ba32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们测试过的类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在可以基于特定的生命周期状态来测试您的视图模型了！我们可以更进一步，去掉一些样板文件。</p><p id="0af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是将其提取到一个类中，在其构造函数中采用生命周期观察者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bf47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您测试过的类中，创建它的一个实例，并使用提供的公共方法更改生命周期状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="43b4" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">结束语</h1><p id="23b5" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">测试实现的行为可以帮助您构建可伸缩的应用程序。使用MVVM架构时，确保将所有业务逻辑提取到视图模型中。</p><p id="ef79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使您的视图模型具有生命周期意识，您可以将一些属于视图的逻辑委托给视图模型。您的视图只能更新其状态并执行来自ViewModel的效果。仅此而已！</p><p id="e9d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然本文关注的是视图模型，但这并不妨碍您让其他组件具有生命周期意识。在一些用例中，当业务持有者组件需要访问这些信息来执行一些操作而不必将它们暴露给视图时，这可能会很方便。</p><p id="ed45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总是保持你的视图代码最少。</p></div></div>    
</body>
</html>