<html>
<head>
<title>Meet &amp; Greet — List Pagination in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">会议和问候—在SwiftUI中列出分页</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/meet-greet-list-pagination-in-swiftui-8330ee15fd61?source=collection_archive---------15-----------------------#2019-08-12">https://betterprogramming.pub/meet-greet-list-pagination-in-swiftui-8330ee15fd61?source=collection_archive---------15-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何向SwiftUI列表添加对分页API响应的支持</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0efca6a37c98f233990f506f35cf39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqgSs4VRO5OaMIo8TSo5dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">引导分页的屏幕截图</p></figure><p id="94ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最新的SwiftUI演示项目从REST API获取数据，然后对响应进行分页。这就是为什么我在寻找一种简单的方法来为SwiftUI列表视图添加分页支持。</p><p id="cd0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在当前的测试版(Xcode 11 beta 5)中，没有提供现成的功能。这就是为什么我们将在接下来的几分钟内实现一个简单的解决方案。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="65aa" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">目标</h1><p id="e8e9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然我们可以在列表视图的内容块中访问当前迭代中的一个条目，但是我们不知道它在列表中的当前位置或者我们离列表的末尾有多远。这就是分页的用武之地。</p><p id="f569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分页对不同的人有不同的含义。让我们从定义我想要的最终目标开始:</p><blockquote class="mz na nb"><p id="611f" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">在滚动期间，列表应该获取并追加下一页的项目。当用户到达列表末尾并且请求仍在进行中时，应该显示加载视图。</p></blockquote><p id="0961" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到这一点，让我们实现一个解决方案来修复这些问题，并为列表视图添加分页支持。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6cd8" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">实施</h1><p id="9973" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这一节中，我们将看看两种不同的方法。虽然第一种方法更明显，但高级用户可能会喜欢第二种方法的面向用户的功能。</p><h2 id="7931" class="nf mc it bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">第一种方法</h2><p id="2b2d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">一个简单的解决方案是检查当前迭代中的项是否是列表的最后一项。如果这是真的，我们触发一个异步请求来获取下一页的项目。</p><p id="266f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">RandomAccessCollection+isLastItem</strong></p><p id="d215" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为列表视图支持<code class="fe nr ns nt nu b">RandomAccessCollection</code> <strong class="la iu"> </strong>，所以我们可以创建一个扩展并实现一个<code class="fe nr ns nt nu b">isLastItem</code>函数。关键是<code class="fe nr ns nt nu b">Self </code>需求，它限制了元素符合<code class="fe nr ns nt nu b">Identifiable</code>协议的集合的扩展。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="8664" class="nf mc it nu b gy nz oa l ob oc"><strong class="nu iu">extension RandomAccessCollection where Self.Element: Identifiable {<br/>    func isLastItem&lt;Item: Identifiable&gt;(_ item: Item) -&gt; Bool {</strong><br/>        guard !isEmpty else {<br/>            return false<br/>        }<br/>        <br/>        guard let itemIndex = firstIndex(where: { $0.id.hashValue == item.id.hashValue }) else {<br/>            return false<br/>        }<br/>        <br/>        <strong class="nu iu">let distance = self.distance(from: itemIndex, to: endIndex)<br/>        return distance == 1</strong><br/>  <strong class="nu iu">  }<br/>}</strong></span></pre><p id="adc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将一个符合<code class="fe nr ns nt nu b">Identifiable</code>协议的项目传递给函数，如果该项目是集合中的最后一个项目，它将返回true。</p><blockquote class="mz na nb"><p id="a4b4" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">该函数在集合中查找给定项的索引。它使用<code class="fe nr ns nt nu b"><em class="it">id</em></code>属性的哈希值(<code class="fe nr ns nt nu b"><em class="it">Identifiable</em></code>协议的要求)将其与列表中的其他项目进行比较。如果找到了项目索引，这意味着项目索引和结束索引之间的距离必须正好是1(结束索引等于集合中的当前项目数)。这就是我们如何知道给定的项目是最后一个项目。</p></blockquote><p id="d004" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用类型清除包装器<code class="fe nr ns nt nu b">AnyHashable</code>直接比较类型为<code class="fe nr ns nt nu b">Hashable</code>的id，而不是比较哈希值。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="356d" class="nf mc it nu b gy nz oa l ob oc">guard let itemIndex = firstIndex(where: { <strong class="nu iu">AnyHashable($0.id) == AnyHashable(item.id)</strong> }) else {<br/>    return false<br/>}</span></pre><p id="161a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在基础已经奠定，我们可以实现用户界面了。</p><p id="33c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">用户界面</strong></p><p id="0bdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望在到达末尾时触发列表更新。为了实现这一点，我们可以在每个项目的根视图上使用<code class="fe nr ns nt nu b">onAppear</code>修改器。(在本例中，它是一个VStack。)这就调用了下面的<code class="fe nr ns nt nu b">listItemAppears</code>函数。我们一会儿就来看看。</p><p id="4c53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果当前迭代的项目是最后一个项目，将向用户显示加载视图。在这个简单的例子中，它是<code class="fe nr ns nt nu b">Text(“Loading …”)</code>。</p><p id="267b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于SwiftUI是声明性的，下面的代码应该是不言自明的:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="159e" class="nf mc it nu b gy nz oa l ob oc">struct <strong class="nu iu">ListPaginationExampleView</strong>: View {<br/>    <a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var items: [String] = Array(0...24).map { "Item \($0)" }<br/>    </strong><a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var isLoading: Bool = false<br/>    </strong><a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var page: Int = 0<br/>    private let pageSize: Int = 25</strong><br/>    <br/>    var body: some View {<br/>        NavigationView {<br/>            <strong class="nu iu">List(items) { item in</strong><br/>                <strong class="nu iu">VStack</strong>(alignment: .leading) {<br/>                    <strong class="nu iu">Text(item)</strong><br/>                    <br/>                    <strong class="nu iu">if self.isLoading &amp;&amp; self.items.isLastItem(item) {</strong><br/>                        Divider()<br/>                        <strong class="nu iu">Text("Loading ...")</strong><br/>                            .padding(.vertical)<br/>                    <strong class="nu iu">}</strong><br/>                }<strong class="nu iu">.onAppear {<br/>                    self.listItemAppears(item)<br/>                }</strong><br/>            <strong class="nu iu">}</strong><br/>            .navigationBarTitle("List of items")<br/>            .navigationBarItems(trailing: <strong class="nu iu">Text("Page index: \(page)")</strong>)<br/>        }<br/>    }<br/>}</span></pre><blockquote class="mz na nb"><p id="5f82" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">助手函数<code class="fe nr ns nt nu b"><strong class="la iu"><em class="it">listItemAppears</em></strong></code> <strong class="la iu"> </strong>在内部<strong class="la iu"> </strong>检查给定项目是否是最后一个项目。如果它是当前页面的最后一项，则增加当前页面，并将下一页的项目追加到列表中。此外，我们通过<code class="fe nr ns nt nu b"><strong class="la iu"><em class="it">isLoading</em></strong></code>变量跟踪装载状态，该变量定义了何时显示装载视图。</p></blockquote><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="7112" class="nf mc it nu b gy nz oa l ob oc">extension <strong class="nu iu">ListPaginationExampleView</strong> {<br/>    private <strong class="nu iu">func</strong> <strong class="nu iu">listItemAppears&lt;Item: Identifiable&gt;(_ item: Item)</strong> <strong class="nu iu">{</strong><br/>        <strong class="nu iu">if items.isLastItem(item) {</strong><br/>            <strong class="nu iu">isLoading = true</strong><br/>            <br/>            /*<br/>                Simulated async behaviour:<br/>                Creates items for the next page and<br/>                appends them to the list after a short delay<br/>             */<br/>            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 3) {<br/>                <strong class="nu iu">self.page += 1</strong><br/>                let moreItems = self.getMoreItems(forPage: self.page, pageSize: self.pageSize)<br/>                <strong class="nu iu">self.items.append</strong>(contentsOf: moreItems)<br/>                <br/>                <strong class="nu iu">self.isLoading = false</strong><br/>            }<br/>        <strong class="nu iu">}</strong><br/>    <strong class="nu iu">}</strong><br/>}</span></pre><p id="57f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个实现中，只有当前迭代<em class="my">中的项目是最后一个项目</em>时，我们才获取下一页的项目。</p><p id="5d09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但这并不是最好的用户体验，对吗？在一个真正的应用程序中，如果达到或超过了一个定义的阈值，我们会希望预加载下一个页面。此外，只有在真正必要的情况下(例如，如果请求花费的时间比预期的长)，我们才应该用负载指示器来打扰用户。在我看来，这将带来更好的用户体验。</p><p id="5d36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到这些用户体验问题，让我们跳到第二种方法。</p><h2 id="d7fb" class="nf mc it bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">第二种方法</h2><p id="31df" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这里，我们将学习如果超过了给定的阈值，如何获取下一页的项目。</p><p id="30a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">RandomAccessCollection+is thresholditem</strong></p><p id="049c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们将从扩展<code class="fe nr ns nt nu b">RandomAccessCollection</code>开始。这次我们将实现一个名为<code class="fe nr ns nt nu b">isThresholdItem</code> <em class="my"> </em>的函数，它确定给定的项目是否是阈值项目。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="f9d8" class="nf mc it nu b gy nz oa l ob oc"><strong class="nu iu">extension RandomAccessCollection where Self.Element: Identifiable {</strong><br/>    <strong class="nu iu">func isThresholdItem&lt;Item: Identifiable&gt;(offset: Int,<br/>                                             item: Item) -&gt; Bool {</strong><br/>        guard !isEmpty else {<br/>            return false<br/>        }<br/>        <br/>        guard let itemIndex = firstIndex(where: { AnyHashable($0.id) == AnyHashable(item.id) }) else {<br/>            return false<br/>        }<br/>        <br/>        let distance = self.distance(from: itemIndex, to: endIndex)<br/>        <strong class="nu iu">let offset = offset &lt; count ? offset : count - 1</strong><br/>        <strong class="nu iu">return offset == (distance - 1)</strong><br/>    <strong class="nu iu">}</strong><br/><strong class="nu iu">}</strong></span></pre><blockquote class="mz na nb"><p id="a416" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">这个函数寻找给定项目的索引。如果找到，它将计算到结束索引的距离。指定的偏移量(即结束前的项目数)应等于<code class="fe nr ns nt nu b"><strong class="la iu"><em class="it">distance — 1</em></strong></code>。我们必须从距离中减去1，因为结束索引等于count属性的值(即集合中的当前项目数)。我还为偏移量添加了一个简单的验证检查。偏移量应小于集合中的当前项数。</p></blockquote><p id="b75b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们准备好再次进入用户界面。</p><p id="4ce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">用户界面</strong></p><p id="a498" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">UI实现与第一种方法中的UI几乎相同。然而，有一个关键的区别，那就是在<code class="fe nr ns nt nu b">listItemAppears</code>函数中。</p><blockquote class="mz na nb"><p id="2356" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">记住，我们在这里重用了第一种方法中的<code class="fe nr ns nt nu b"><em class="it">isLastItem</em></code>函数。只有当用户到达列表的末尾并且对下一页的请求仍在进行时，加载视图才会显示。</p></blockquote><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="3eb7" class="nf mc it nu b gy nz oa l ob oc">struct <strong class="nu iu">ListPaginationThresholdExampleView</strong>: View {<br/>    <a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var items: [String] = Array(0...24).map { "Item \($0)" }<br/>    </strong><a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var isLoading: Bool = false<br/>    </strong><a class="ae od" href="http://twitter.com/State" rel="noopener ugc nofollow" target="_blank"><strong class="nu iu">@State</strong></a><strong class="nu iu"> private var page: Int = 0<br/>    private let pageSize: Int = 25<br/>    private let offset: Int = 10</strong><br/>    <br/>    var body: some View {<br/>        NavigationView {<br/>            <strong class="nu iu">List(items) { item in</strong><br/>                <strong class="nu iu">VStack</strong>(alignment: .leading) {<br/>                    Text(item)<br/>                    <br/>                    <strong class="nu iu">if self.isLoading &amp;&amp; self.items.isLastItem(item) {</strong><br/>                        Divider()<br/>                        <strong class="nu iu">Text("Loading ...")</strong><br/>                            .padding(.vertical)<br/>                    <strong class="nu iu">}</strong><br/>                }<strong class="nu iu">.onAppear {<br/>                    self.listItemAppears(item)<br/>                }</strong><br/>            <strong class="nu iu">}</strong><br/>            .navigationBarTitle("List of items")<br/>            .navigationBarItems(trailing: <strong class="nu iu">Text("Page index: \(page)")</strong>)<br/>        }<br/>    }<br/>}</span></pre><blockquote class="mz na nb"><p id="cdb9" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">我们不调用<code class="fe nr ns nt nu b"><strong class="la iu"><em class="it">isLastItem</em></strong></code> <em class="it">，</em> <strong class="la iu"> </strong>而是调用<code class="fe nr ns nt nu b"><strong class="la iu"><em class="it">isThresholdItem</em></strong></code> <strong class="la iu"> </strong>来检查给定的项是否是阈值项。</p></blockquote><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="4eb2" class="nf mc it nu b gy nz oa l ob oc">extension <strong class="nu iu">ListPaginationThresholdExampleView</strong> {<br/>    private <strong class="nu iu">func listItemAppears&lt;Item: Identifiable&gt;(_ item: Item) {</strong><br/>        <strong class="nu iu">if items.isThresholdItem(offset: offset,<br/>                                 item: item) {</strong><br/>            <strong class="nu iu">isLoading = true</strong><br/>            <br/>            /*<br/>                Simulated async behaviour:<br/>                Creates items for the next page and<br/>                appends them to the list after a short delay<br/>             */<br/>            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5) {<br/>                <strong class="nu iu">self.page += 1</strong><br/>                let moreItems = self.getMoreItems(forPage: self.page, pageSize: self.pageSize)<br/>                <strong class="nu iu">self.items.append(contentsOf: moreItems)</strong><br/>                <br/>                <strong class="nu iu">self.isLoading = false</strong><br/>            }<br/>        <strong class="nu iu">}</strong><br/>    <strong class="nu iu">}</strong><br/>}</span></pre><p id="29f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你是一个特别细心的读者，你可能已经注意到一些代码片段丢失了。让我们在下一节讨论这些问题。</p><h2 id="a960" class="nf mc it bd md ng nh dn mh ni nj dp ml lh nk nl mn ll nm nn mp lp no np mr nq bi translated">缺失的代码片段</h2><p id="b9bd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><strong class="la iu">获取更多项目</strong></p><p id="40fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图显示了<code class="fe nr ns nt nu b">getMoreItems</code>功能的实现:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="ea74" class="nf mc it nu b gy nz oa l ob oc">extension <strong class="nu iu">ListPaginationExampleView</strong> {<br/>    /*<br/>        In a real app you would probably fetch data<br/>        from an external API.<br/>     */<br/>    private <strong class="nu iu">func getMoreItems(forPage page: Int,<br/>                              pageSize: Int) -&gt; [String]</strong> {<br/>        let maximum = ((page * pageSize) + pageSize) - 1<br/>        let moreItems: [String] = Array(items.count...maximum).map { "Item \($0)" }<br/>        return moreItems<br/>    }<br/>}</span></pre><p id="4991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">字符串+可识别的</strong></p><p id="1ae5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是使<em class="my">列表</em> <em class="my">视图</em>工作所需的最后一个扩展:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="150e" class="nf mc it nu b gy nz oa l ob oc">/*<br/>    If you want to display an array of strings<br/>    in the List view you have to specify a key path,<br/>    so each string can be uniquely identified.<br/>    With this extension you don't have to do that.<br/> */<br/><strong class="nu iu">extension String: Identifiable</strong> {<br/>    public var id: String {<br/>        return self<br/>    }<br/>}</span></pre><p id="9647" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个字符串扩展使得在相关的列表视图初始化器中直接使用字符串数组变得容易。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="585d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结果呢</h1><p id="1c82" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">最后，让我们看看我们的结果。</p><p id="b9af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一张GIF展示了<code class="fe nr ns nt nu b">isLastItem</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c1a1d445bc39e42356a7190660f93a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zIWrvuAHnc930hEJ6eE5AQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示iPhone XR模拟器上最后一个项目方法的动画图像</p></figure><p id="59fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一张gif展示了<code class="fe nr ns nt nu b">isThresholdItem</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2acdce8bc010cb12587d191dad001a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B3GX6a-8wZeAkVNugpdlxw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iPhone XR模拟器上显示阈值方法的动画图像</p></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="157f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你。您现在可以在SwiftUI列表中使用分页了。</p><p id="8c8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次感谢您阅读我的一篇文章！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="58a5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">资源</h1><p id="b503" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">本文的代码如下:</p><div class="of og gp gr oh oi"><a href="https://github.com/crelies/List-Pagination-SwiftUI" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">cre lies/List-分页-SwiftUI</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><p id="5be6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还提供套装:</p><div class="of og gp gr oh oi"><a href="https://github.com/crelies/ListPagination" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">crelies/ListPagination</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">这个Swift包提供了RandomAccessCollection的扩展，帮助您将分页支持添加到SwiftUI…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>