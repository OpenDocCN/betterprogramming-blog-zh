<html>
<head>
<title>Building a gRPC Server With Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust构建gRPC服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-grpc-server-with-rust-be2c52f0860e?source=collection_archive---------2-----------------------#2022-05-09">https://betterprogramming.pub/building-a-grpc-server-with-rust-be2c52f0860e?source=collection_archive---------2-----------------------#2022-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e908" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><span class="l ki kj kk bm kl km kn ko kp di">一个</span>分步指南</h2></div><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/b60110c7a640cf794b2d1cc78d114247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0zeLieO_hVOJMLjo"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">由<a class="ae lg" href="https://unsplash.com/es/@floriankrumm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛里安·克拉姆</a>在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="98ce" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">背景和导言</h1><h2 id="45b7" class="lz li it bd lj ma mb dn ln mc md dp lr me mf mg lt mh mi mj lv mk ml mm lx mn bi translated">RPC vs JSON vs SOAP</h2><p id="30b8" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">一旦我了解了<a class="ae lg" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>和<a class="ae lg" href="https://github.com/facebook/fbthrift" rel="noopener ugc nofollow" target="_blank"> Thrift </a>，就很难再去使用更传统的基于JSON的REST API或<a class="ae lg" href="https://en.wikipedia.org/wiki/SOAP" rel="noopener ugc nofollow" target="_blank"> SOAP </a> API。</p><p id="df7d" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">gRPC和Thrift这两个著名的<a class="ae lg" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> RPC </a>框架有很多相似之处。前者源于谷歌，后者源于脸书。它们都易于使用，对各种编程语言都有很好的支持，并且都是高性能的。</p><p id="d656" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">最有价值的特性是多语言代码生成和服务器端反射。这些使得API本质上是类型安全的。有了服务器端反射，探索API的模式定义变得更加容易，而不必阅读和理解实现。</p><h2 id="2b1c" class="lz li it bd lj ma mb dn ln mc md dp lr me mf mg lt mh mi mj lv mk ml mm lx mn bi translated">Grpc与节俭</h2><p id="165a" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">从历史上看，Apache Thrift一直是一个受欢迎的选择。然而，近年来，由于缺乏脸书的持续支持，以及与<a class="ae lg" href="https://github.com/facebook/fbthrift" rel="noopener ugc nofollow" target="_blank"> fbthrift </a>的分叉，它慢慢失去了人气。</p><p id="1462" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">与此同时，gRPC以更健康的生态系统赶上了越来越多的功能。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nm"><img src="../Images/7386ed21c7921f133641f2225b63d26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5PNPz9WLFYdDHWvFB89_Q.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated"><em class="nn">GRPC(蓝色)与阿帕奇节俭(红色)的对比。</em> <a class="ae lg" href="https://trends.google.com/trends/explore?date=all&amp;q=GRPC,%2Fm%2F02qd4d1" rel="noopener ugc nofollow" target="_blank"> <em class="nn">谷歌趋势</em> </a></p></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi no"><img src="../Images/e6db2950189fdad4b380dd7875caadd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkTrSeGKa29G_C00Lp9Baw.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">gRPC、fbThrift和Apache Thrift之间的GitHub star历史。<a class="ae lg" href="https://star-history.com/#grpc/grpc&amp;facebook/fbthrift&amp;apache/thrift&amp;Date" rel="noopener ugc nofollow" target="_blank">https://star-history.com</a></p></figure><p id="c6da" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">到今天为止，除非你的应用程序在某种程度上与脸书有关联，否则没有理由考虑节俭。</p><h2 id="824b" class="lz li it bd lj ma mb dn ln mc md dp lr me mf mg lt mh mi mj lv mk ml mm lx mn bi translated">GraphQL怎么样？</h2><p id="1aea" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">GraphQL是另一个由脸书发起的框架。它与上面的两个RPC框架有许多相似之处。</p><p id="8990" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">移动API开发最大的一个痛点就是有些用户从来不升级自己的app。因为我们希望保持向后兼容性，所以我们要么在API中保留旧的未使用的字段，要么创建API的多个版本。GraphQL的一个动机就是解决这个问题。它被设计成一种“查询语言”,允许客户指定其需要的数据字段。这使得处理向后兼容性变得更加容易。</p><p id="9fd3" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">GraphQL在开发移动API以及面向公众的API(如<a class="ae lg" href="https://docs.github.com/en/graphql" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)方面有很大的价值。因为在这两种情况下，我们都不容易控制客户端行为。</p><p id="b460" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">然而，如果我们正在为web前端构建一个API，或者为内部后端服务构建一个API，那么选择GraphQL而不是gRPC没有什么好处。</p><h2 id="bf0c" class="lz li it bd lj ma mb dn ln mc md dp lr me mf mg lt mh mi mj lv mk ml mm lx mn bi translated">锈</h2><p id="296b" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">以上是到目前为止网络框架的一个小概述。除了网络之外，我们还需要决定应用服务器的语言。</p><p id="f716" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">基于<a class="ae lg" href="https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread" rel="noopener ugc nofollow" target="_blank">栈溢出调查</a>:“第六年，Rust是最受喜爱的语言。”它的类型安全、优雅的内存管理、广泛的社区支持和性能，所有这些都使Rust成为后端服务开发非常有吸引力和前途的编程语言，尽管学习曲线相对陡峭。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi np"><img src="../Images/dffe945db606ebf3fe1a143c72424aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8Hv01jwar_w_49eDq4Yag.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">铁锈是最受喜爱的语言。<a class="ae lg" href="https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread" rel="noopener ugc nofollow" target="_blank">堆栈溢出调查2021 </a></p></figure><p id="762d" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">我们也开始看到Rust在业界被越来越广泛的采用:<a class="ae lg" href="https://engineering.fb.com/2021/04/29/developer-tools/rust/" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae lg" href="https://www.wired.com/2016/03/epic-story-dropboxs-exodus-amazon-cloud-empire/" rel="noopener ugc nofollow" target="_blank"> Dropbox </a>、<a class="ae lg" href="https://youtu.be/u6ZbF4apABk" rel="noopener ugc nofollow" target="_blank"> Yelp </a>、<a class="ae lg" href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae lg" href="https://opensource.googleblog.com/2021/02/google-joins-rust-foundation.html" rel="noopener ugc nofollow" target="_blank"> Google </a>等。很明显，锈菌将会继续生长，并且会一直存在。</p><p id="8802" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">这就是我们今天的教程要研究的内容——用Rust中的gRPC构建一个小型服务器。</p><h1 id="a9b7" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">安装铁锈</h1><p id="790e" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">用以下材料安装Rust:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="dc36" class="lz li it nr b gy nv nw l nx ny">$ curl --proto '=https' --tlsv1.2 -sSf &lt;https://sh.rustup.rs&gt; | sh</span></pre><p id="e9b2" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">如果您之前安装了Rust，我们可以通过以下方式进行更新:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="c588" class="lz li it nr b gy nv nw l nx ny">$ rustup update stable</span></pre><p id="b48b" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">让我们仔细检查一下<code class="fe nz oa ob nr b">rustc</code>(Rust编译器)和<code class="fe nz oa ob nr b">cargo</code>(Rust包管理器)的安装版本:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="ad8d" class="lz li it nr b gy nv nw l nx ny">$ rustc --version</span><span id="2f22" class="lz li it nr b gy oc nw l nx ny">rustc 1.60.0 (7737e0b5c 2022-04-04)</span><span id="43bd" class="lz li it nr b gy oc nw l nx ny">$ cargo --version</span><span id="5c99" class="lz li it nr b gy oc nw l nx ny">cargo 1.60.0 (d1fd9fe2c 2022-03-01)</span></pre><p id="b8d9" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">有关安装的更多信息，请查看https://www.rust-lang.org/tools/install。</p><h1 id="76a0" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">创建Rust项目</h1><p id="08cd" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">运行以下命令创建一个新的“Hello World”项目:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="a2e3" class="lz li it nr b gy nv nw l nx ny">$ cargo new rust_grpc_demo --bin</span></pre><p id="a723" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">让我们编译并运行程序:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="52a7" class="lz li it nr b gy nv nw l nx ny">$ cd rust_grpc_demo</span><span id="c0f4" class="lz li it nr b gy oc nw l nx ny">$ cargo run</span><span id="1c21" class="lz li it nr b gy oc nw l nx ny">   Compiling rust_grpc_demo v0.1.0 (/Users/yuchen/Documents/rust_grpc_demo)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1.75s<br/>     Running `target/debug/rust_grpc_demo`<br/>Hello, world!</span></pre><p id="5391" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">这显示了我们目前拥有的文件结构:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="84d9" class="lz li it nr b gy nv nw l nx ny">$ <!-- -->find . -not -path "./target*" -not -path "./.git*" | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/| - \1/"</span><span id="7dad" class="lz li it nr b gy oc nw l nx ny">  |-Cargo.toml<br/>  |-Cargo.lock<br/>  |-src<br/>  |  |-main.rs</span></pre><h1 id="6b9b" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">定义gRPC接口</h1><p id="cae4" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">gRPC使用<a class="ae lg" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>来序列化和反序列化数据。让我们在一个<code class="fe nz oa ob nr b">.proto</code>文件中定义服务器API。</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="115b" class="lz li it nr b gy nv nw l nx ny">$ mkdir proto<br/>$ touch proto/<!-- -->bookstore.proto</span></pre><p id="fe35" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">我们定义了一个书店服务，只有一个方法:提供一个图书id，并返回关于这本书的一些细节。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2e56" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">我们将用<a class="ae lg" href="https://docs.rs/tonic/latest/tonic/" rel="noopener ugc nofollow" target="_blank"> tonic </a>创建我们的gRPC服务。将以下依赖项添加到<code class="fe nz oa ob nr b">Cargo.toml</code>文件中:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a041" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">为了从<code class="fe nz oa ob nr b">bookstore.proto</code>生成Rust代码，我们在机箱的<code class="fe nz oa ob nr b">build.rs</code>构建脚本中使用了<code class="fe nz oa ob nr b">tonic-build</code>。</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="ef28" class="lz li it nr b gy nv nw l nx ny">$ touch build.rs</span></pre><p id="33dc" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">将以下内容添加到<code class="fe nz oa ob nr b">build.rs</code>文件中:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3aeb" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">需要特别指出的一点是，我们添加了这个<code class="fe nz oa ob nr b">.out_dir(“./src”)</code>来将默认输出目录更改为<code class="fe nz oa ob nr b">src</code>目录，这样我们就可以更容易地看到生成的文件。</p><p id="46cf" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">在我们准备编译之前还有一件事。<code class="fe nz oa ob nr b">tonic-build</code>依靠<a class="ae lg" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">协议缓冲编译器</a>将<code class="fe nz oa ob nr b">.proto</code>文件解析成可以转换成Rust的表示。让我们安装<code class="fe nz oa ob nr b">protobuf</code>:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="1834" class="lz li it nr b gy nv nw l nx ny">$ brew install protobuf</span></pre><p id="158e" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">并再次检查<strong class="mq iu"> protobuf </strong>编译器是否安装正确:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="22c4" class="lz li it nr b gy nv nw l nx ny">$ protoc --version</span><span id="865b" class="lz li it nr b gy oc nw l nx ny">libprotoc 3.19.4</span></pre><p id="9e5e" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">准备编译:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="d79a" class="lz li it nr b gy nv nw l nx ny">$ cargo build</span><span id="640f" class="lz li it nr b gy oc nw l nx ny">    Finished dev [unoptimized + debuginfo] target(s) in 0.31s</span></pre><p id="df34" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">这样，我们应该会生成一个文件<code class="fe nz oa ob nr b">src/bookstore.rs</code>。此时，我们的文件结构应该如下所示:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="88ac" class="lz li it nr b gy nv nw l nx ny">  | - Cargo.toml<br/>  | - proto<br/>  |  | - bookstore.proto<br/>  | - Cargo.lock<br/>  | - build.rs<br/>  | - src<br/>  |  | - bookstore.rs<br/>  |  | - main.rs</span></pre><h1 id="0395" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">实现服务器</h1><p id="1823" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">最后，是时候整合服务了。用以下零件替换<code class="fe nz oa ob nr b">main.rs</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d80c" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">正如我们所看到的，为了简单起见，我们没有真正的图书设置数据库。在这个端点中，我们简单地返回一本假书。</p><p id="ae57" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">运行服务器的时间:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="a010" class="lz li it nr b gy nv nw l nx ny">$ <!-- -->cargo run</span><span id="856e" class="lz li it nr b gy oc nw l nx ny">   Compiling rust_grpc_demo v0.1.0 (/Users/yuchen/Documents/rust_grpc_demo)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 2.71s<br/>     Running `target/debug/rust_grpc_demo`<br/>Bookstore server listening on [::1]:50051</span></pre><p id="4c37" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">很好，我们的gRPC服务器已经启动并运行了！</p><h1 id="17c4" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">额外收获:服务器反射</h1><p id="2b3c" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">正如开头所说，gRPC最初给我留下的第一印象是因为它能够进行服务器反射。它不仅在服务开发过程中非常方便，而且还使与前端工程师的沟通变得更加容易。因此，如果不解释如何为Rust服务器添加这一功能，结束本教程是不完整的。</p><p id="6218" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">将以下内容添加到依赖项中:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="028e" class="lz li it nr b gy nv nw l nx ny">tonic-reflection = "0.4.0"</span></pre><p id="6991" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">更新<code class="fe nz oa ob nr b">build.rs</code>。需要修改的行标有<code class="fe nz oa ob nr b">// Add this</code>注释。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c7a7" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">最后，将<code class="fe nz oa ob nr b">main.rs</code>更新如下。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="2bb9" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">测试gRPC服务器</h1><p id="7bec" class="pw-post-body-paragraph mo mp it mq b mr ms ju mt mu mv jx mw me mx my mz mh na nb nc mk nd ne nf ng im bi translated">有很多GUI客户端可以玩gRPC服务器，比如<a class="ae lg" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>、<a class="ae lg" href="https://kreya.app/" rel="noopener ugc nofollow" target="_blank"> Kreya、</a> <a class="ae lg" href="https://github.com/bloomrpc/bloomrpc" rel="noopener ugc nofollow" target="_blank"> bloomrpc </a>、<a class="ae lg" href="https://github.com/gusaul/grpcox" rel="noopener ugc nofollow" target="_blank"> grpcox </a>等。为了今天简单起见，我们将使用命令行工具<code class="fe nz oa ob nr b">grpc_cli</code>。</p><p id="c8fd" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">要安装:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="16bf" class="lz li it nr b gy nv nw l nx ny">$ brew install grpc</span></pre><p id="52eb" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">为了测试我们的第一个gRPC端点:</p><pre class="kr ks kt ku gt nq nr ns nt aw nu bi"><span id="ab64" class="lz li it nr b gy nv nw l nx ny">$ grpc_cli call localhost:50051 bookstore.Bookstore.GetBook "id: 'test-book-id'"</span><span id="34a6" class="lz li it nr b gy oc nw l nx ny">connecting to localhost:50051<br/>Received initial metadata from server:<br/>date : Sun, 08 May 2022 20:15:39 GMT<br/>id: "test-book-id"<br/>name: "Zero to One"<br/>author: "Peter"<br/>year: 2014<br/>Rpc succeeded with OK status</span></pre><p id="84ee" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">看起来有用！我的朋友，这就是我们如何在Rust中构建gRPC服务器。</p><p id="b118" class="pw-post-body-paragraph mo mp it mq b mr nh ju mt mu ni jx mw me nj my mz mh nk nb nc mk nl ne nf ng im bi translated">今天到此为止。感谢阅读和快乐编码！和往常一样，源代码可以在<a class="ae lg" href="https://github.com/yzhong52/rust_grpc_demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>