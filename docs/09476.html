<html>
<head>
<title>Secure Your Kubernetes Cluster With AppArmor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AppArmor保护您的Kubernetes集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secure-your-kubernetes-cluster-with-apparmor-e4bb9fef37e1?source=collection_archive---------8-----------------------#2021-08-30">https://betterprogramming.pub/secure-your-kubernetes-cluster-with-apparmor-e4bb9fef37e1?source=collection_archive---------8-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="076f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的集装箱工作负载启用AppArmor的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e4dedd5fefa00c8197ff7f501a0a2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ApZ6Ea_dyTSjY1BF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pierre Bamin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d8dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://apparmor.net/" rel="noopener ugc nofollow" target="_blank"> AppArmor </a>是一个标准的Linux安全模块实现，允许您在组和用户级权限之上，对您的Linux系统实施细粒度控制。因此，它有助于将您的程序限制在运行所需的有限的资源、文件和其他权限范围内。此外，它使您能够在容器应用程序中实现最小特权原则。</p><p id="698e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">市场上的大多数容器都使用标准Linux发行版的基本映像。虽然使用像Alpine这样的发行版作为基础映像可以在很大程度上帮助减少攻击面，因为它不包含不必要的包管理器和其他膨胀软件，但我们仍然需要限制容器进程，只做它打算做的事情，即，它应该只修改文件，并运行它需要的命令——其他所有事情都应该被拒绝。</p><p id="7119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AppArmor帮助实施这种方法。然而，虽然AppArmor在减少攻击面方面有很大帮助，但它也有其局限性。因此，不应将其视为灵丹妙药，还应考虑保护容器的其他方法。</p><p id="4578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AppArmor使用包含允许或拒绝特定操作的特定规则的配置文件。您可以在“强制”或“审核”模式(也称为投诉模式)下使用AppArmor配置文件。当你对一个特定的程序不够了解时，最好先在抱怨模式下运行它，看看你的容器进程正在执行什么合法的操作。然后，您可以在配置文件中添加所需的操作，并使用enforce模式拒绝所有其他操作。</p><p id="38a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为AppArmor是一个标准的Linux特性，所以概要文件应该加载到Kubernetes节点上。虽然您可以通过将配置文件复制到Kubernetes集群的所有节点上，使用Ansible或类似的启动脚本来手动完成此操作，但它在GKE这样的托管产品中效果不太好，在这些产品中，您的节点也会随着流量自动缩放，并且使用AppArmor配置文件初始化新节点可能并不简单。</p><p id="8d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的一个很好的解决方案是使用DaemonSet在您的节点上配置AppArmor配置文件，因为daemon set在所有节点上运行。管理配置文件的一个很好的方法是使用Kubernetes本地configMap资源，它可以帮助将它们存储在您的Kubernetes集群的etcd中。我们将在演示中研究这种方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8289" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建GKE集群</h1><p id="79b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本练习中，我们将使用GKE，为此您需要一个GCP帐户。然而，请随意使用您喜欢的任何解决方案。没关系。首先，我们需要使用以下命令创建我们的GKE集群:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9c68" class="ne md it na b gy nf ng l nh ni">$ gcloud container clusters create cluster-1 --zone us-central1-a</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/715945b06654905b450ce82b8b74dd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SK5hck8gEnEEDnpFsrhPGQ.gif"/></div></div></figure><p id="732b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，GKE集群已经创建。下一步是查看AppArmor装载机DaemonSet。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">表观装载机DaemonSet</h1><p id="4cf8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将在集群中创建三个配置文件:</p><ul class=""><li id="b9b2" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">拒绝写入—此配置文件拒绝所有写入。它特别适用于只读窗格。</li><li id="482b" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">审核写入—此配置文件不拒绝任何写入，但它将审核对计划pod的节点日志的所有写入尝试。</li><li id="0ff4" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">Nginx——这个概要文件是一个细粒度策略的例子，它在nginx容器上实现了最小特权原则。我们将详细研究这个问题。</li></ul><p id="777b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">资源清单文件由多个资源组成。建议我们在不同的名称空间中创建DaemonSet和相关的ConfigMap资源，以将该名称空间仅限于集群管理员。因此，<code class="fe ny nz oa na b">apparmor-loader.yaml</code>清单文件的第一部分是名称空间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="69ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要在下面的<code class="fe ny nz oa na b">ConfigMap</code>中定义概要文件:</p><p id="bbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据部分中，我们有多个要加载到节点上的概要文件。第一个概要文件，如下面的部分清单所示，由“拒绝所有文件写入”规则<code class="fe ny nz oa na b">deny /** w,</code>组成</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa na b">ConfigMap</code>中的下一个配置文件是审计所有写入，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有以下细粒度的策略，允许NGINX需要运行的一切，拒绝它不需要做的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="985c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清单的下一部分是<code class="fe ny nz oa na b">DaemonSet</code>。让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然大部分清单都是标准的，但是让我们来看看spec部分:</p><ul class=""><li id="c975" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">它运行一个名为<code class="fe ny nz oa na b">apparmor-loader</code>的容器，这个容器使用了<code class="fe ny nz oa na b">google/apparmor-loader:latest</code>容器。容器将在<code class="fe ny nz oa na b">/profiles</code>目录中定义的所有AppArmor概要文件加载到它正在运行的节点上。这里要记住的一点是，虽然它可以将新的概要文件加载到节点中，但是它不能删除或修改现有的概要文件。</li><li id="5401" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">它每30秒轮询一次<code class="fe ny nz oa na b">/profile</code>目录中的新配置文件</li><li id="b877" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">它挂载<code class="fe ny nz oa na b">/sys</code>和<code class="fe ny nz oa na b">/etc/apparmor.d</code>目录来访问AppArmor模块，并从<code class="fe ny nz oa na b">ConfigMap</code>挂载profiles目录来访问我们已经定义的概要文件。</li></ul><p id="244a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经了解了它的作用，让我们继续应用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/7ea1be0cf3fbfcaaffb8ead6aa8138be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7q4ThpHWQwOtgTVtUsTjew.gif"/></div></div></figure><p id="7af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe ny nz oa na b">DaemonSet</code>的pod正在每个节点上运行。现在，让我们打开一个外壳，看看里面有什么。我们将首先切换到<code class="fe ny nz oa na b">/profiles</code>目录并列出概要文件，我们应该看到所有三个概要文件都列在其中。当我们<code class="fe ny nz oa na b">cat</code>配置文件时，我们应该看到我们包含在<code class="fe ny nz oa na b">ConfigMap</code>中的数据，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/51c20d3d91d855b14e29164c57c2df1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CJxOK6DJPMzYy7w7zgnFtQ.gif"/></div></div></figure><p id="9876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当所有三个概要文件都被加载时，让我们创建使用这些概要文件的pod。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="27d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拒绝所有写入</h1><p id="1d11" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们首先创建一个使用“拒绝所有写入”规则的pod。要使用规则，我们需要在<code class="fe ny nz oa na b">annotations</code>中指定规则，如下面的<code class="fe ny nz oa na b">busybox-deny-writes.yaml</code>清单文件所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="62a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该注释的格式如下:</p><p id="e374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa na b">container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;: localhost/&lt;profile_name&gt;</code></p><p id="67a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将<code class="fe ny nz oa na b">k8s-apparmor-deny-write</code>概要文件应用到<code class="fe ny nz oa na b">busybox</code>容器。让我们在这个yaml上做<code class="fe ny nz oa na b">kubectl apply</code>,看看我们会得到什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a712899b278467df2890438385d6573a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AbwRH3qj2YHas6OuWwmZwQ.gif"/></div></div></figure><p id="c2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe ny nz oa na b">exec</code>命令获取pod的shell并尝试使用<code class="fe ny nz oa na b">touch</code>命令创建文件时，我们什么也做不了。这就是否认规则为我们做的。现在，让我们看一下审计规则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="01f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">审核所有写入</h1><p id="cdd1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在实施规则之前，我们使用审计模式来查看容器试图做什么。因此，让我们尝试使用这里的规则，以便当我们向容器文件系统写入内容时，日志中会生成一个审计日志。</p><p id="a3c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下<code class="fe ny nz oa na b">busybox-audit-writes.yaml</code>清单使用审计写入规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ebc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续应用这个清单，打开一个到pod的shell会话，并尝试编写几个文件。我们还将尝试打开一个到部署了pod的节点的shell会话，并从日志中获取审计日志。让我们看看如何:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/551abcccd16297e41540cac415886f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TSHChAnabv1-J-qDb-p-9A.gif"/></div></div></figure><p id="13bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们可以写入文件系统，所有写入也可以在日志中获得。现在，没有人想在一个容器中实现简单的“拒绝所有写入”或“审计所有写入”规则。相反，您应该对您希望在系统上给予容器的权限进行更细粒度的控制。接下来让我们来看看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d625" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">NGINX的细粒度策略</h1><p id="036f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将在运行NGINX容器的pod中使用我们之前定义为<code class="fe ny nz oa na b">k8s-apparmor-nginx</code>的NGINX细粒度策略。让我们先看看<code class="fe ny nz oa na b">nginx.yaml</code>清单文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="269a" class="ne md it na b gy nf ng l nh ni">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nginx<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  securityContext:<br/>    seccompProfile:<br/>      type: Localhost<br/>      localhostProfile: profiles/fine-grained.json<br/>  containers:<br/>  - name: nginx<br/>    image: nginx<br/>    securityContext:<br/>      allowPrivilegeEscalation: false</span></pre><p id="25cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续应用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/bb2c4bd5d2a7962dcf93c4d4b8c6151d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qBFrLVSgFhjAYVg6MurOMg.gif"/></div></div></figure><p id="00eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，我们已经成功创建了nginx pod。现在，它似乎运行得很好，我们还可以看到pod的一些审核事件，就像我们审核文件写入操作一样。现在，让我们继续向nginx pod发送一个请求，看看是否会得到响应。我们将使用<code class="fe ny nz oa na b">kubectl port-forward</code>将流量从本地机器的端口<code class="fe ny nz oa na b">8080</code>转发到容器的端口<code class="fe ny nz oa na b">80</code>，然后从一个单独的终端会话中点击<code class="fe ny nz oa na b">localhost:8080</code>上的<code class="fe ny nz oa na b">curl</code>命令，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/b6ef9c4a620df1078657bbefb473fe05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ojVdVAeh7i7pUMG0fPMijw.gif"/></div></div></figure><p id="3c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，我们在这里得到默认的NGINX响应。细粒度的规则不会阻止NGINX需要做的任何事情。但是，它会拒绝访问NGINX不需要运行的文件和目录。这是对您的细粒度访问，以及我们如何使用AppArmor对我们的容器执行最小特权原则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03b0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="52a9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">AppArmor like <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/secure-your-kubernetes-cluster-with-seccomp-9403ecf831b2"> Seccomp </a>有助于围绕容器工作负载启用安全边界，并允许我们实现最小特权原则。在加强Kubernetes集群时，它们很有帮助，并且是基本的Kubernetes安全最佳实践。</p><p id="1135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>