<html>
<head>
<title>Exploring the Template Method Design Pattern Through JdbcTemplate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过JdbcTemplate探索模板方法设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-the-template-method-pattern-through-jdbctemplate-4ee02ec9fcad?source=collection_archive---------8-----------------------#2022-04-13">https://betterprogramming.pub/exploring-the-template-method-pattern-through-jdbctemplate-4ee02ec9fcad?source=collection_archive---------8-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">模板方法模式的基础以及JdbcTemplate如何实现该模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd98157563c2d22d9cb7200048eed5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPJub29iCjTlH1NY-lYP5w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@ryoji__iwata" rel="noopener ugc nofollow" target="_blank">良治</a>在<a class="ae kv" href="https://unsplash.com/photos/5siQcvSxCP8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近我看到了这个关于设计模式的精彩视频。</p><p id="a04e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于如何学习设计模式的观点对我来说很有意义。</p><blockquote class="ls lt lu"><p id="f0ec" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">只有当你看到一个模式是如何在框架和库中实际使用的，你才会对这个模式有一个透彻的理解。</p></blockquote><p id="44b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我看了很多设计模式的书和网上的资源，但是对于如何在一个真实的项目中使用每个模式，我仍然感到缺乏深入的了解。</p><p id="fff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅仅阅读设计模式是很难应用的。除非你见过它们适用的真实情况，否则几乎不可能理解它们的真正价值。</p><p id="3a56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就像通过阅读一本书来学习骑自行车或游泳。你可以记住这些步骤——用你的左腿旋转方向盘，然后用右腿，一遍又一遍地重复这个动作——在你需要停下自行车的时候使用刹车。但是，如果你认为你已经准备好骑自行车，而没有练习使用辅助轮，你很可能会撞到树上。</p><p id="2ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将这些建议付诸实践，我决定养成一种习惯，研究java中流行的框架和库的内部结构，以理解不同的模式是如何被用来产生优秀的代码的。我会在一系列博客中记录我的学习成果。</p><p id="7be7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从模板方法模式及其在JdbcTemplate中的用法开始。我们还会看到设计模式在现实生活中的用法可能不完全像教科书上的模式。所以，你需要有敏锐的眼光。</p><p id="7a6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是首先，让我们回顾一下模板方法模式的基础知识。</p><h1 id="0d42" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是模板方法模式？</h1><p id="ea50" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">模板方法定义了算法的结构，并通过允许子类提供不同的实现，允许对一个或多个步骤进行细微的修改。</p><p id="a850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子。</p><p id="f55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您正在创建各种表格文件格式的报告，如excel、CSV等。</p><p id="4a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是excel的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c29f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是CSV…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分代码看起来与我们刚刚在Excel中实现的代码非常相似。有很多重复的地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/08e83682e79c11b7ce9f3a97b9c3da8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5L3s4v6BW7o6-_xd3oUNhw.png"/></div></div></figure><p id="f9f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将公共代码移到一个名为<code class="fe mz na nb nc b">TabularReport</code>的公共类中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ffbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">TabularReport</code>中的<code class="fe mz na nb nc b">prepareReport()</code>是这里的模板方法，我们在这里定义了算法的框架来准备一个报表。它被声明为final，因为我们不希望子类覆盖它，因为我们希望控制算法。</p><p id="04fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将第3步和第4步概括为<code class="fe mz na nb nc b">addHeaders()</code>和<code class="fe mz na nb nc b">addRows()</code>。因为excel和CSV将以不同的方式实现这些步骤，所以它们被声明为抽象的。</p><p id="0a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要创建CSV和Excel类。他们现在依靠<code class="fe mz na nb nc b">TabularReport</code>类来创建报告，只需要担心添加标题和行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/0117e7c2753983c9fe6e15b5d3f86530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMLPbEp7O8rRuJBpJn3LCg.png"/></div></div></figure><p id="2290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到我们是如何最大化代码重用的。</p><p id="5d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模板方法模式就是为算法创建一个模板。更具体地说，这是一种将算法定义为一组步骤的方法。这些步骤中的一个或多个被定义为抽象的，并由子类实现，从而确保算法的结构不变。</p><h1 id="7380" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">核心Java中的模板方法模式</h1><p id="59df" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这种模式在Java的很多库中都有使用。一个这样的地方是<code class="fe mz na nb nc b">AbstractList/AbstractSet</code>。这个类为Java中的各种列表集合提供了一些基本的列表行为实现，比如<code class="fe mz na nb nc b">ArrayList</code>和<code class="fe mz na nb nc b">LinkedList</code>。</p><p id="518d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">AbstractList</code>中模板方法的一个例子是<code class="fe mz na nb nc b">addAll()</code>方法，它用于将元素集合添加到列表中。它依赖于一个抽象方法<code class="fe mz na nb nc b">add()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">子类只需要提供抽象的<code class="fe mz na nb nc b">add()</code>、<code class="fe mz na nb nc b">get()</code>和<code class="fe mz na nb nc b">set()</code>方法的实现。</p><p id="87ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想创建自己的定制列表，你可以通过扩展<code class="fe mz na nb nc b">AbstractList</code>来实现，并通过使用它的模板免费获得基本的列表行为。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="9faa" class="ni ma iq nc b gy nj nk l nl nm">int [] array = { 2, 4, 6 };<br/>EvenNumberList mylist = new EvenNumberList(array);<br/>mylist.addAll(Arrays.<em class="lv">asList</em>(8, 10, 12));<br/>mylist.subList(2, 4);</span></pre><h1 id="128c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">JdbcTemplate中的模板模式</h1><p id="b00c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在是时候来一次短暂的春游了。对于那些没有使用过<code class="fe mz na nb nc b">JdbcTemplate</code>的人来说，它是一个spring库，简化了java中Jdbc的使用。它执行核心的Jdbc工作流，让应用程序代码只提供SQL查询和提取结果。您是否想到了最适合这个用例的模式？是的，你猜对了！模板方法模式。</p><p id="4776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们感兴趣的示例模板方法是<code class="fe mz na nb nc b">execute</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="57e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，模板方法控制算法:</p><ol class=""><li id="7898" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">首先，它获得一个数据库连接。</li><li id="f975" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">创建一个语句对象。</li><li id="d31a" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">将语句设置应用于语句对象。</li><li id="9ef5" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">然后它调用使用<code class="fe mz na nb nc b">StatementCallback</code>接口提供的<code class="fe mz na nb nc b">action.doInStatement</code>。</li><li id="494f" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">关闭语句对象</li><li id="d994" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">释放数据库连接。</li></ol><p id="ab50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法的用户不必担心处理Jdbc连接的复杂性，仍然可以通过简单地实现<code class="fe mz na nb nc b">StatementCallback</code>接口来执行SQL查询。</p><p id="9202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这确保了算法的结构不变，也防止了错误。用户可以执行查询，而不会遇到无法关闭连接的麻烦。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="kg kh ki kj gt ne nc nf ng aw nh bi"><span id="a5d7" class="ni ma iq nc b gy nj nk l nl nm">jdbcTemplate.update("UPDATE Customers SET ContactName='James' where id=7")</span></pre><h2 id="7d3f" class="ni ma iq bd mb ob oc dn mf od oe dp mj lf of og ml lj oh oi mn ln oj ok mp ol bi translated">但是这看起来和模板方法模式有什么不同吗？</h2><p id="72ac" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你是对的！模板模式要求实现一个算法结构，并让子类改变它的某些部分。但是这里我们并没有子类化<code class="fe mz na nb nc b">JdbcTemplate</code>。我们将具体方法作为参数传递。</p><p id="6957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来也像是一种策略模式。这是因为策略模式使用组合来改变行为，而模板方法使用继承。</p><p id="9269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是请记住，在策略模式中，您编写的类控制整个算法。但是这里算法的形成仍然是用模板法。<code class="fe mz na nb nc b">execute()</code>的算法缺少了<code class="fe mz na nb nc b">doInStatement()</code>的一个步骤，你只需要提供一个实现它的类。所以，从那方面来说，它更像是模板方法。</p><p id="f4a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这场辩论没有对错之分。这并不重要。我们只需要抓住设计的精神。</p><h1 id="e7a4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="e483" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们看到了模板方法模式如何为我们提供代码重用的重要技术。我们还看到，设计模式在实际代码库中的实现可能与教科书模式略有不同。</p><p id="6782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检验您设计技能的下一步是开始使用模式重构您当前的项目。如果你没有经历过他们所解决的问题，你就不会完全理解他们。请记住，它们不是银弹。你的北极星应该是基本的设计原则，比如代码可读性、可重用性和可测试性。</p></div></div>    
</body>
</html>