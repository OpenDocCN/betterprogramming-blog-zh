<html>
<head>
<title>How Does `ls` Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“ls”是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-ls-work-14fdc2b85308?source=collection_archive---------5-----------------------#2022-10-26">https://betterprogramming.pub/how-does-ls-work-14fdc2b85308?source=collection_archive---------5-----------------------#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7997" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我探索了Unix中最有用和“过度设计”的命令之一背后的代码</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi gj"><img src="../Images/9ea69c6c1bac72bc35ddefc42ed88245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BDqRkG3ZzB8LIEk1.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.wallpaperflare.com/linux-tux-simple-minimalism-wallpaper-gjzim" rel="noopener ugc nofollow" target="_blank">来自壁纸flare </a></p></figure><h1 id="861a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为什么我想谈论ls？</h1><p id="22fe" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我认为探索一点Linux代码和它在内部是如何工作的会很有趣。我觉得我对操作系统的了解相当有限，所以我认为深入代码并试图理解它会推动我真正理解一些基础知识，如内核、inodes、信号等。如果你也有同感，那就继续吧！</p><p id="8e25" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不过，快速前言，我可能会谈到的大部分代码都是用C编写的，如果你不懂C，那也没关系。只要你对指针和结构之类的概念有了基本的理解，你还是应该能够理解所写的内容。如果你对C、指针或结构一无所知，不要担心。继续讲下去，你应该能理解我将要讲的大部分内容。</p><p id="c83e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们先快速讨论一下代码和目录结构。只有一个5500多行代码文件实现了<code class="fe mo mp mq mr b">ls</code>、<code class="fe mo mp mq mr b">ls.c</code>。该文件是GNU coreutils包的一部分，它只是一个包含其他常用工具的包，如<code class="fe mo mp mq mr b">cd</code>、<code class="fe mo mp mq mr b">cat</code>、<code class="fe mo mp mq mr b">copy</code>等。</p><p id="a49a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你真的很好奇，这里的<a class="ae ku" href="https://github.com/coreutils/coreutils/blob/master/src/ls.c" rel="noopener ugc nofollow" target="_blank">是源代码。如果没有，那么继续读下去，获得一个删节版。但是在我们继续之前，让我们讨论几个Linux概念。</a></p><h1 id="d9e1" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">了解一些先决条件</h1><h2 id="53b5" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">信息节点</h2><p id="f002" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">信息节点是关于文件的元数据。它们本质上告诉操作系统文件的所有者、所有者的<code class="fe mo mp mq mr b">groupID</code>、文件拥有的权限、文件大小、文件在磁盘上的存储位置等等。<code class="fe mo mp mq mr b">ls</code>命令的大部分输出来自inode信息！</p><p id="6ef8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，它们完全独立于文件名。因此，您可以重命名一个文件，它仍然具有相同的inode。</p><p id="ac44" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以使用带有<code class="fe mo mp mq mr b">-i</code>选项的<code class="fe mo mp mq mr b">ls</code>命令来查看文件的索引节点号。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi ne"><img src="../Images/c8bc2bbe823a978695accbfba996b5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rJhZ3uD-IQB59r4L9KDEQ.png"/></div></div></figure><p id="bbea" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们会多谈一点关于inode的内容，但是现在，我们知道Linux创建了这些元数据对象来存储关于文件的数据，其中文件的数据存储在磁盘中，并且它们可以通过inode编号唯一地标识。</p><h2 id="68ab" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">不同的文件类型</h2><p id="7284" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果您还不知道，Linux中的每个文件都有特定的类型。这实际上是运行<code class="fe mo mp mq mr b">ls -l</code>时第一位代表的内容。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nf"><img src="../Images/611a20d48679e59eba7246578e583cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v821DQYfaDLQzro0uxRZ3Q.png"/></div></div></figure><p id="e14b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可能已经猜到了，<code class="fe mo mp mq mr b">d</code>的意思是目录。</p><p id="2725" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于像<code class="fe mo mp mq mr b">ls</code>这样的常规文件，该位是不设置的。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi ng"><img src="../Images/3922054ebc60e3e260c097376c96709b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PiYk0ovWI_n_zLuBJzwyoA.png"/></div></div></figure><p id="c4cb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">除此之外，还有使用<code class="fe mo mp mq mr b">l</code>字母的链接，使用<code class="fe mo mp mq mr b">c</code>字母的字符特殊文件，以及相当多的文件类型。我现在不会一一介绍，但我知道有很多类型。</p><h2 id="3057" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">核心</h2><p id="77c4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我想我们都曾在教育或职业生涯中读到或听到过“内核”这个词。我个人总是听到流行但模糊的描述，比如“硬件和软件之间的接口”我们可能也见过这样的图表:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nh"><img src="../Images/90b25ae43850445a810a05e94582dac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sp96TJZtoDuQHXZ5.png"/></div></div></figure><p id="c973" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我相信这些都是非常宽泛的想法，至少对我来说，这并没有描述内核，留给我的问题比答案还多，我们为什么需要内核？应用程序可以直接与硬件交互吗？内核是做什么的？它提供了什么样的接口？它对内存、CPU或其他硬件有多少访问权限？中间还有其他层吗？</p><p id="617c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所以，我花了一些时间试图理解内核和它真正的含义。这是我解释它的机会。</p><p id="f549" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">把操作系统想象成三层。顶部是用户进程。这些是网络浏览器、应用程序、你的网络服务器等。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2152731a94aa70c6b764857a791be7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*TcCw6_5SdPetB6apmCtFOw.png"/></div></figure><p id="55c3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这下面是内核。这包含了大量与硬件直接交互的代码，比如设备驱动、内存管理、权限等等。所以当你执行一个没有<code class="fe mo mp mq mr b">sudo</code>的命令，而这个命令需要sudo时，得到的回应是你不能这么做，这就是内核。尽管它的大部分细节通常对美国软件工程师是隐藏的。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nj"><img src="../Images/8a481c06a4d423c711125dcde9fa49fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*ra3Byy0RVcSH-Ldp-9qEZw.png"/></div></div></figure><p id="464b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">内核下面是硬件。这是物理内存、磁盘、CPU、网卡等。，在你的系统里。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/da2e5fa9aa86f554d334d1e905e3b60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*LvO6iCTND8RVCXvgfX4ggg.png"/></div></figure><p id="0901" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于涉及硬件的操作，进程可以对内核进行系统调用。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cfbd16f11b0332c92b495e0c5d9f8022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*jy8fiPjUSS_tsGxsxLFbdA.png"/></div></figure><p id="9c29" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">例如，一个进程必须读取磁盘上的一个文件，并对内核进行系统调用。内核获得关于进程的信息，例如，哪个用户执行了进程，哪个用户创建了可执行文件，等等。，并决定要做什么。</p><p id="fd71" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果它觉得一切正常，它会创建一个文件描述符并将其返回给进程。</p><p id="39eb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你们中的一些人可能会说，你从来没有编写过任何进行系统调用的代码。这很正常。大多数现代编程语言都在内核之上构建了一个接口，使得大多数操作变得更加容易。这一抽象层做了很多工作，比如错误处理、日志记录、管理文件描述符、管理内存(这一层没有自动垃圾收集！)，等等。比如<a class="ae ku" href="https://github.com/python/cpython/blob/main/Modules/_io/_iomodule.c" rel="noopener ugc nofollow" target="_blank">这个</a>就是Python的<code class="fe mo mp mq mr b">open</code>函数的来源。</p><p id="5889" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">绕过内核，让进程直接与硬件对话是可能的，尽管这通常并不简单，甚至对大多数来说也不是必需的。我发现了一些绕过内核的例子，但是这些看起来真的是小众用例。</p><p id="5629" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">例如，<a class="ae ku" href="https://blog.cloudflare.com/kernel-bypass/" rel="noopener ugc nofollow" target="_blank">这篇来自Cloudflare </a>的帖子谈到了他们如何绕过内核来实现更高的网络性能。</p><p id="4e6e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">BIOS，我们听到的另一个流行词，是直接与硬件交互的东西。另一方面，BIOS是主板的一部分，它的功能非常有限。它为主板提供基本的输入和输出，并在引导过程中提供帮助。应用程序根本不会与BIOS交互。</p><p id="3818" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我发现Steven Rostedt (他是Linux内核的开发者之一)的这个演讲对理解这些概念非常有帮助。我认为这张来自演讲的图表很好地总结了这一点:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nl"><img src="../Images/d84b1a8d44ab59d7ee4eb01de47733a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d8LHie7dPgRpkfdWeQYjw.png"/></div></div></figure><p id="83d0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你想更深入地研究这个问题，我建议你去看看这个演讲。</p><h2 id="44d8" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">系统调用</h2><p id="1878" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">系统调用是Linux内核的接口。就像我们的服务向用户公开REST API接口一样</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9f9580840439d133ca734784f47f76f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*2-RR-O0Tw-u_Q78jkaBsqg.png"/></div></figure><p id="2bfe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">系统调用为Linux内核提供了一个接口。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/236cf2e69e05ad9f28ba6ea04e59d3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*B9KL5oQFE9EK0QF7_LGDwg.png"/></div></figure><p id="ffd1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了更多地了解这些系统调用，让我们写一点代码吧！这里你可能会问的第一个问题是，选择哪种语言？</p><p id="b0e3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">答案有点复杂，但是我们先来了解一下在C中是怎么做的，然后我们再花点时间思考一下如何在其他语言中执行同样的操作。</p><p id="fec4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，让我们试验一下<code class="fe mo mp mq mr b">stat</code>系统调用。这个调用非常简单。它接受一个文件路径，并返回关于该文件的一系列信息。现在，我们将打印两个返回值，即文件的所有者和文件的字节大小。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9395" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">输出是可以预测的，如下所示:</p><pre class="kf kg kh ki gt np mr nq nr aw ns bi"><span id="b278" class="ms kw iq mr b gy nt nu l nv nw">uid = 765<br/>filesize = 11</span></pre><p id="6e8f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回到我们关于语言的讨论，我们能用Python或NodeJS写同样的程序吗？</p><p id="34ec" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这些语言在内部调用相同的系统调用，因为您只能使用这些系统调用来与硬件交互。例如，在这里查看一些NodeJS代码<a class="ae ku" href="https://github.com/nodejs/node/blob/main/deps/uv/src/unix/fs.c#L1584" rel="noopener ugc nofollow" target="_blank"/>，您可以看到它是如何开始文件路径的。他们围绕这些系统调用做了更多的工作，为开发人员提供了一个更简单的接口，但是在幕后，他们正在进行内核提供的相同的系统调用。</p><h2 id="7e15" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">科里蒂尔斯</h2><p id="936b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">GNU coreutils是一个安装在每个Linux发行版中的通用工具包。这些提供了像<code class="fe mo mp mq mr b">cat</code>、<code class="fe mo mp mq mr b">ls</code>、<code class="fe mo mp mq mr b">copy</code>等命令。</p><p id="7bdf" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在内部，这些命令对Linux内核进行多次系统调用，并进行大量的格式化、颜色、错误处理等。</p><h2 id="edba" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">什么是目录？</h2><p id="1cba" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">就像Linux中的其他东西一样，目录也是文件。</p><p id="0e23" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但与常规文件不同，目录链接到它们包含的文件。这些数据是如何在内核中被抽象出来的(下一篇关于探索Linux内核源代码的文章？！)，但我们并不关心他们是如何存储这些信息的。我们只关心如何检索这些信息。</p><p id="f07c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae ku" href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/readdir.html" rel="noopener ugc nofollow" target="_blank">为此，我们把系统称为</a> <code class="fe mo mp mq mr b"><a class="ae ku" href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/readdir.html" rel="noopener ugc nofollow" target="_blank">readdir</a></code> <a class="ae ku" href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/readdir.html" rel="noopener ugc nofollow" target="_blank">。</a> <code class="fe mo mp mq mr b">readdir</code>允许我们读取目录中的文件。这实际上非常简单，我们调用<code class="fe mo mp mq mr b">readdir</code>，并且在每次调用时，它都返回给我们一堆关于目录中的单个文件的信息。我们需要一直循环调用它，直到它返回NULL，此时它已经遍历了目录中的所有文件。</p><p id="5d86" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们通过一些简单的代码来看看它是如何工作的:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ff9d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是输出结果:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nx"><img src="../Images/7a179ebb7b51b04b962f71d65485663b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHc0nY8JIkcCLg0ZW8NMbg.png"/></div></div></figure><p id="ed12" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所以目录只是关于它们存储的文件的数据。</p><h2 id="6c7b" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">斯达</h2><p id="554b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe mo mp mq mr b">stat</code>是一个常见的系统调用，用于获取文件的inode信息。它返回了很多信息，我们一个一个来了解文件在Linux中是如何表示的。</p><p id="a8dc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是由<code class="fe mo mp mq mr b">stat</code>系统调用返回的所有数据。</p><pre class="kf kg kh ki gt np mr nq nr aw ns bi"><span id="8a32" class="ms kw iq mr b gy nt nu l nv nw">dev_t  st_dev;<br/>mode_t  st_mode;                 <br/>nlink_t  st_nlink;               <br/>uid_t  st_uid;<br/>gid_t  st_gid;<br/>dev_t  st_rdev;<br/>off_t  st_size;<br/>blkcnt_t st_blocks;<br/>blksize_t st_blksize;</span></pre><p id="240e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以在<code class="fe mo mp mq mr b">stat</code>命令中使用<code class="fe mo mp mq mr b">-x</code>标志来查看详细输出。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi ny"><img src="../Images/1ba4a652cb97551d59a8c146412316a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3E3svPflMn2C7isrZR5LQ.png"/></div></div></figure><p id="024a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">再次提醒一下，<code class="fe mo mp mq mr b">stat</code>命令不同于<code class="fe mo mp mq mr b">stat</code>系统调用。<code class="fe mo mp mq mr b">stat</code>命令是一个用C编写的有用的包装器(在GNU coreutils中打包成一个命令),它调用<code class="fe mo mp mq mr b">stat</code>系统调用。所以这个命令并没有显示出<code class="fe mo mp mq mr b">stat</code>系统调用的全部输出。我用C写了一些简单的代码来执行<code class="fe mo mp mq mr b">stat</code>系统调用并打印其输出。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a2a7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是我得到的输出:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nz"><img src="../Images/96a23ff98bbb70b33a5cf4daa23a40ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4rg5QcGKRrpn2bY70LRBQ.png"/></div></div></figure><p id="6cf0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我知道这很多，但是别担心，大部分都不重要。像<code class="fe mo mp mq mr b">st_id</code>(用户ID的缩写)、<code class="fe mo mp mq mr b">st_guid</code>(组ID的缩写)、<code class="fe mo mp mq mr b">st_size</code>(以字节为单位的文件大小)这样的字段应该已经很明显了。我只是想展示一个例子，说明进行系统调用是多么容易。</p><h1 id="e547" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">浏览代码流</h1><p id="f840" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">代码很长。就是5500+线，也不好看。</p><p id="3117" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不用说，试图涵盖所有内容是不可能的，所以我尽力绘制出总的流程，并将所有的复杂性都隐藏起来。</p><p id="c602" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你真的想花时间去理解<code class="fe mo mp mq mr b">ls</code>的全部代码，在我看来，唯一的方法就是<a class="ae ku" href="https://github.com/coreutils/coreutils/blob/master/src/ls.c" rel="noopener ugc nofollow" target="_blank">检查代码</a>。</p><p id="931a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你想要节略版，看看我下面画的流程图。</p><p id="dee4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于经历过这种情况的人，完全免责声明——这是一种极端的过度简化，但这张图片应该让你对一切是如何工作的有一个大致的了解。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi oa"><img src="../Images/a46e867973eef650b81a0fa1daca9b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_zbH8YC99qyJMYr1IQnUg.png"/></div></div></figure><h1 id="7908" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="83f8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">你们中的一些人可能已经注意到，这篇文章主要是关于理解Linux，而不是关于<code class="fe mo mp mq mr b">ls</code>，这就是我的学习过程。事实上，这是我一开始的目标！</p><p id="8ad3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">总的来说，Linux和操作系统是巨大的。如果没有找到一个有趣的部分来探索，通过看书和看讲座来深入覆盖它们是很困难的(也是很无聊的)。所以，我选择了一些感觉非常有趣和有挑战性的东西，并跟随它到它带领我去的任何地方，我知道在我理解<code class="fe mo mp mq mr b">ls</code>之前我会学习很多关于Linux的东西。</p><h1 id="e743" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">旁注</h1><h2 id="4d2c" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">过度工程化</h2><p id="9301" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在结束这篇文章之前，我想展示我在一个流行的GNU项目中发现的一段引文:</p><blockquote class="ob oc od"><p id="4e59" class="ln lo ni lp b lq mj jr ls lt mk ju lv oe ml ly lz of mm mc md og mn mg mh mi ij bi translated"><code class="fe mo mp mq mr b"><em class="iq">ls</em></code>命令是coreutils中最复杂的实用程序。丰富的功能，如格式控制、颜色支持、模式过滤和排序与信号处理程序、哈希表、<a class="ae ku" href="http://www.gnu.org/software/libc/manual/html_node/Obstacks.html" rel="noopener ugc nofollow" target="_blank"> obstacks </a>、<a class="ae ku" href="https://www.emacswiki.org/emacs/DiredMode" rel="noopener ugc nofollow" target="_blank">接口模式</a>、缓存和访问控制交织在一起，提供了一个多功能的工具。</p><p id="9b94" class="ln lo ni lp b lq mj jr ls lt mk ju lv oe ml ly lz of mm mc md og mn mg mh mi ij bi translated">—<a class="ae ku" href="http://www.maizure.org/projects/decoded-gnu-coreutils/ls.html" rel="noopener ugc nofollow" target="_blank">http://www . maizure . org/projects/decoded-GNU-coreutils/ls . html</a></p></blockquote><p id="a0de" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我真的很喜欢这句话，因为我是在埋头于<code class="fe mo mp mq mr b">ls.c</code>源代码时读到这句话的。如果我还没有提到，它有5500+行长！很多都是关于颜色、格式、过滤等等。很高兴发现我不是唯一一个认为代码有点长的人！</p><h2 id="c1fe" class="ms kw iq bd kx mt mu dn lb mv mw dp lf lw mx my lh ma mz na lj me nb nc ll nd bi translated">你的文件有漏洞吗？</h2><p id="472d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">先说我写的打印stat输出的C程序。这是我运行它时得到的输出:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nz"><img src="../Images/96a23ff98bbb70b33a5cf4daa23a40ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4rg5QcGKRrpn2bY70LRBQ.png"/></div></div></figure><p id="718e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是该文件包含的内容:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi ny"><img src="../Images/9f10b70ac8b0b770e6c1e225683abbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bvfNhaztxcUKkLKFrewlA.png"/></div></div></figure><p id="ba89" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是我上面附上的截图有一点很诡异。试试看能不能找到不一致的地方。</p><p id="df68" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你还没找到，我们来做个小实验。我会更改文件的内容，然后再次运行我的代码。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nz"><img src="../Images/7685a21f7f10901e7182e263a7c7d912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhwgadbWxLsAL1DpUttzSQ.png"/></div></div></figure><p id="dd8b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">用旧内容和新内容运行<code class="fe mo mp mq mr b">du -h</code>也揭示了一些有趣的事情:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi oh"><img src="../Images/34f0714c556f4346788759d6d5295267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSHTuXcQMcfX1_VEzIdvNw.png"/></div></div></figure><p id="b94e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你还没想明白，运行<code class="fe mo mp mq mr b">du</code>时文件大小好像没有变化。另外，<code class="fe mo mp mq mr b">stat</code>命令显示了<code class="fe mo mp mq mr b">st_size</code>的不同值，但<code class="fe mo mp mq mr b">st_blocks</code>的值保持不变！<code class="fe mo mp mq mr b">st_blocks</code>显示块计数始终保持为8，结果为4096字节(<a class="ae ku" href="https://unix.stackexchange.com/questions/521151/why-is-st-blocks-always-reported-in-512-byte-blocks" rel="noopener ugc nofollow" target="_blank">由于历史原因，无论</a> <code class="fe mo mp mq mr b"><a class="ae ku" href="https://unix.stackexchange.com/questions/521151/why-is-st-blocks-always-reported-in-512-byte-blocks" rel="noopener ugc nofollow" target="_blank">st_blksize</a></code>的值如何，Linux中的块大小始终为512)，因此文件占用的字节似乎没有变化！</p><p id="c16f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，为什么会发生这种情况呢？</p><p id="f0ff" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们快速浏览一下这里发生了什么。当您想要在硬盘或固态硬盘上存储数据时，您可以将数据存储在“块”上块是文件系统中数据存储的最小单位。它本质上是建立在物理硬件之上的抽象概念。当操作系统想要写入或读取数据时，它实际上是在读取或写入数据块。所以当你想读一个文件时，操作系统会找到文件所在的块，然后一个一个地捡起这些块。</p><p id="6e74" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">像<code class="fe mo mp mq mr b">ext4</code>这样的文件系统不能在一个块中存储多个文件。但是单个文件可以存储在多个块中。这意味着如果你创建一个只有一个字符的文件，它仍然占用一个块。对于我的系统，块大小是4096字节或4KB。该文件总是占用磁盘中4KB的空间。我创建的任何文件，即使只包含一个字符，也总是会占用至少一个块。该块是保留的，不能用于任何其他文件，因此即使包含单个字符的文件也仍然会占用磁盘上4KB的空间。</p><p id="3984" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是我在探索其他东西时进入的一个有趣的小侧道，但它对我来说很有趣，很新，所以我想我也可以在这里添加它。</p></div></div>    
</body>
</html>