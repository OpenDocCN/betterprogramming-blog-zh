<html>
<head>
<title>How To Recover From a Failed Automated Docker Hub Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从失败的自动化Docker Hub构建中恢复</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-recover-from-a-failed-automated-docker-hub-build-8b6c1cc3d7d4?source=collection_archive---------14-----------------------#2019-10-01">https://betterprogramming.pub/how-to-recover-from-a-failed-automated-docker-hub-build-8b6c1cc3d7d4?source=collection_archive---------14-----------------------#2019-10-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6f46" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">自动化构建三部分系列的最后一部分</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ff0178f798175f3bdca2d15388f0e8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufBx-wj1iF_sRsdd"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅各布·欧文斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1124" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本系列的前两篇文章中，我们看到了如何在GitHub 上自动构建Docker映像，以及如何在Docker Hub 上测试自动构建。在这最后一篇文章中，我们将看到如何从测试失败的自动化构建中恢复。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1adc" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使主分支上的构建失败</h1><p id="95f3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">继续我们在“<a class="ae kz" href="https://medium.com/@NMichas/how-to-test-your-automated-builds-on-docker-hub-e40879f35d1e" rel="noopener">如何在Docker Hub </a> <em class="na">上测试您的自动化构建”中停止的地方，“</em>让我们使用我们的<code class="fe nb nc nd ne b">docker-compose.test.yml</code>文件并让它失败。我们可以通过简单地搞乱测试命令来引入失败条件，将它改为调用一个不存在的脚本(即<code class="fe nb nc nd ne b">helloFOO</code>):</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="70dc" class="nj me iu ne b gz nk nl l nm nn">sut:<br/>  build: .<br/>  command: /helloFOO</span></pre><p id="3793" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">继续添加并推送该文件。请记住，我们正在推进主分支，因此我们希望Docker Hub中的一个构建会自动触发主标签。事实上，几分钟后我们可以看到这个构建失败了:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/4cd3926c8cf7be907a89e4dcd76aea7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SabLYjkf_SSnLr7WLcmMuQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由于自动化测试失败，构建失败</p></figure><p id="7d19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于我们直接在主<em class="na"> </em>分支上工作，要修复这个错误，我们只需在<code class="fe nb nc nd ne b">docker-compose.test.yml</code>上纠正上述修改，然后重新推送。几分钟后…</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/cb717c722c7dc233fe0146ee61cb1051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIYjKtjEM1BpwWPuPUU9iQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">更正以前失败的版本</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d264" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用标签时从故障中恢复</h1><p id="ed29" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">还记得在“<a class="ae kz" href="https://medium.com/@NMichas/how-to-test-your-automated-builds-on-docker-hub-e40879f35d1e" rel="noopener">如何在Docker Hub </a>上测试您的自动化构建”中，我们创建了两个不同的构建规则吗？一个是针对主<em class="na"> </em>分支的，另一个是针对每次我们在GitHub repo中推送新标签的。让我们探索后一个规则。</p><p id="075a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，重新修改您的<code class="fe nb nc nd ne b">docker-compose.test.yml</code>来引入错误的脚本调用，这使得我们之前的主分支构建失败。然后，引入并推送新标签1.0.1:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/4abea79392e49e6861b9a1d049d316e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlgTJhglkkFAwfz_ivVDqA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">标记图像</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/5973906a545af09f3238081100be4612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHcMpWv9tUpJdLvMys504g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Docker Hub构建您的主分支机构以及您的1.0.1标签</p></figure><p id="4f4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如所料，上面的两个构建都失败了:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ns"><img src="../Images/d9215ca6c46a7423f96a7700aaf9cd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLWCjQ6BYF-eg88B-jrJrw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">失败的构建</p></figure><p id="0419" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">纠正错误的修改并推入母版<em class="na"> </em>将修复母版图像，但是您的标记图像呢？嗯，事情可能会变得棘手。您看，版本控制系统的要点——特别是像Git这样的分布式系统——是您可以在本地存储库中自由地(几乎)做任何您想做的事情。它只是您自己的本地副本，即使您完全搞砸了，您也可以恢复到以前的提交，重新应用隐藏的代码，或者精挑细选您认为最新的代码视图。</p><p id="780c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">也就是说，直到你推。然后，您自己的代码视图就变成了同一个存储库的所有其他用户的公共财产，Git现在包含了您在存储库历史上的精彩贡献。那么，如何着手修复这个失败的构建呢？有两种方法。</p><h2 id="a42a" class="nj me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">制作新版本(好方法)</h2><p id="4041" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">像每一个优秀的Git公民一样，您甚至不会考虑修改Git存储库的历史。您按照“Git中的东西，留在Git中”的格言生活和呼吸，因此您唯一的选择是发布一个新的版本。在这种情况下，事情对您来说非常简单:纠正错误并创建一个新的1.0.2标签。如上所述，一旦推送，Docker Hub将触发一个构建，几分钟后您就可以使用您的1.0.2映像了。</p><h2 id="898b" class="nj me iu bd mf nt nu dn mj nv nw dp mn lj nx ny mp ln nz oa mr lr ob oc mt od bi translated">移除和重新引入标签(丑陋的方式)</h2><p id="47c3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">你花了世界上所有的时间向你的客户解释我们需要推1.0.2，但是客户坚持说:“我们的FOO政策不允许我们有版本差距。下一个版本<strong class="lc iv">必须是1.0.1。好吧，至少你尽力了。</strong></p><p id="3f38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Git允许您从本地存储库和远程存储库中删除标签。因为这是一个紧急情况，我们会这样做。但是，请记住，由于您已经推送了您的原始标记，存储库的其他用户可能已经使用或看到了它，并且他们现在可能会对标记的底层提交ID发生变化感到困惑(或恼怒)。在这种情况下，在移动标签之前，最好先与团队的其他成员交流您的意图。</p><p id="38da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，让我们删除标签，修复错误，重新添加标签，然后按:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/b17e847b01cc4315db75961edb1c89a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUuFQ-ofyTdPvsc2OqBa2g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">重新引入标签</p></figure><p id="8649" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">几分钟后…</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/12b6ad9d3abd673891ce6483312afff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGuc7K3TqIxeGNUTmOapLg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">您新推出的1.0.1映像</p></figure><p id="a879" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的新1.0.1版本已经准备就绪，构建成功。注意到同一个版本/标签是如何引用不同的提交ID的吗？如果可能的话，尽量避免。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e4f1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">那个重试按钮</h1><p id="71e4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在上面的一些截图中，您可能已经注意到，当Docker Hub构建失败时，会提供一个重试按钮:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/83d7676525f18bf2c5cdeaf08b3ab060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tk29AxR5aSqTefDTwEu0RQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">重试以前失败的构建</p></figure><p id="6b4b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">重试按钮可以让你重新触发Docker Hub构建。但是，这里应该注意的是，重试将针对失败作业的原始提交ID进行。如果失败的原因是代码中的逻辑错误，构建将不可避免地再次失败，因此重试这些失败的构建没有任何意义。另一方面，如果您100%确定失败不是由于您自己的代码，但是可能Docker Hub上发生了一些奇怪的事情，一些依赖项暂时不可用，等等。，您可以通过重试来快速恢复失败的生成。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7f50" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">基于HTTPS的触发器</h1><p id="3006" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">最后一件事，不一定与恢复有关，但通常与触发构建有关:Docker Hub允许您创建HTTPS链接，当被调用时，会触发构建。您可以在Docker Hub存储库中的Builds &gt; Configure Automated Builds &gt; Build triggers下定义构建触发器:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/ebbdaa78a9a98803a8bae166fbffe2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9eJMblPS1dFDX90YA3xmg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过HTTPS触发构建</p></figure><p id="a705" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过执行以下命令来触发上面的构建:</p><pre class="kk kl km kn gu nf ne ng nh aw ni bi"><span id="4a17" class="nj me iu ne b gz nk nl l nm nn">curl -v -X POST <a class="ae kz" href="https://cloud.docker.com/api/build/v1/source/dda1c169-9d75-4af8-9fff-e88b8eba15ce/trigger/5fe2aa57-6c62-4489-a618-920123cb6174/call/" rel="noopener ugc nofollow" target="_blank">https://cloud.docker.com/api/build/v1/source/dda1c169-9d75-xxxx-xxxx-xxxxxxxxxxxx/trigger/5fe2aa57-6c62-xxxx-xxxx-xxxxxxxxxxxx/call</a></span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/b7b26b62bfd904fca21685e40b07ad93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKTMK1rlUlWSkvO0buThuA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过HTTPS触发构建</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="448c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">本系列的其他文章</h1><p id="90d6" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">本文是Docker Hub和自动化构建系列的一部分。该系列的其他文章有<a class="ae kz" href="https://medium.com/better-programming/build-your-docker-images-automatically-when-you-push-on-github-18e80ece76af" rel="noopener">当你推GitHub </a>时自动构建你的Docker映像和<a class="ae kz" href="https://medium.com/better-programming/how-to-test-your-automated-builds-on-docker-hub-e40879f35d1e" rel="noopener">如何在Docker Hub上测试你的自动化构建</a>。</p></div></div>    
</body>
</html>