<html>
<head>
<title>Create a Flutter Plugin To Write Platform-specific Code for Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个Flutter插件，为Windows编写特定于平台的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flutter-platform-plugin-windows-1-8b7c0a96fac4?source=collection_archive---------3-----------------------#2022-03-25">https://betterprogramming.pub/flutter-platform-plugin-windows-1-8b7c0a96fac4?source=collection_archive---------3-----------------------#2022-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过编写您的Flutter桌面应用程序来利用Windows特有的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3ee17f95ed764a27e95e4d91347b533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hje42lJmPNdwCWt3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">桑杰·梅赫拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">剧情简介:</em>学习在插件中使用<em class="lv">平台通道</em>从Flutter调用Windows API。该示例显示了如何从Windows注册表中获取信息。</p><h1 id="44ab" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">介绍</h1><p id="0da2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Flutter是一个非常棒的工具，它让我们可以编写可以在越来越多的不同平台上编译和发布的应用程序。为了做到这一点，Flutter通过从我们的角度完全抽象出操作系统或硬件层来工作。</p><p id="7ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当开发我们的应用程序时，我们只“看到”Flutter APIs，我们不能包含汇编代码，使用dll，调用OS APIs，等等。该引擎控制着一切，当然，它有许多与屏幕和输入交互的功能，用于访问存储、网络和所有支持平台之间的其他通用功能。但其他一些东西并不是现成的，比如定位服务、运动传感器、蓝牙等。</p><p id="9ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想把一个只写了一次的应用程序发布到每一个可用的平台上时，这是一个公平的价格，但是如果我们想要更多的目标操作系统可以提供给我们的东西，会发生什么呢？或者我们是否会访问特定的硬件或库？<br/>在大多数情况下什么都没有，我们被覆盖了:在<a class="ae ky" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>或<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> Github </a>上搜索，我们会找到一个会给我们所需要的东西的包，有人已经为我们解决了那个问题。但是有时我们需要更多，或者我们不想只为一个Win32调用依赖一个巨大的包。</p><h1 id="d4d4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">可能的解决方案</strong></h1><p id="917c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Flutter提供了两种方法来让我们的应用开箱即用:</p><ul class=""><li id="23ba" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://dart.dev/guides/libraries/c-interop" rel="noopener ugc nofollow" target="_blank"> dart:ffi </a>，是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Foreign_function_interface" rel="noopener ugc nofollow" target="_blank">外来函数接口</a>库，“调用原生C APIs，对原生内存进行读写、分配、解除分配”(来自dart.dev)。仅使用Dart语言，它允许我们编写Dart代码而不是C来调用外部库。然而，dart代码在管理内存和变量、调用外部函数等方面与C代码相似..它也适用于纯Dart程序，没有抖动。</li><li id="cee8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://docs.flutter.dev/development/packages-and-plugins/developing-packages" rel="noopener ugc nofollow" target="_blank">插件</a>，使用Flutter的<a class="ae ky" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">平台通道</a>，<strong class="lb iu">这就是我们将在本教程中看到的。</strong></li></ul><p id="ba89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">插件是“一个专门的Dart包，它包含一个用Dart代码编写的API以及一个或多个特定于平台的实现”。让我们看看它是如何工作的。</p><blockquote class="nh ni nj"><p id="958a" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">如果有时这个教程对飞镖/颤振专家来说很无聊，我提前道歉，但这也是初学者学习的机会。</p></blockquote><h1 id="cf14" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><em class="nn">例子:我们想要什么</em></h1><p id="3e40" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们想知道在Windows中是否激活了黑暗模式，在Flutter中似乎很容易，我们可以读取<em class="lv"> MediaQuery </em>对象的<code class="fe no np nq nr b">platformBrightness</code>属性:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d2d0" class="nw lx it nr b gy nx ny l nz oa">MediaQuery.of(context).platformBrightness</span></pre><p id="3bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很容易，不是吗？该属性可以采用两个值之一:<em class="lv">暗</em>或<em class="lv">亮。<br/> </em>但是有一个问题:要得到一个<code class="fe no np nq nr b">MediaQuery</code>对象，我们必须使用<em class="lv">。服务定位器，它在窗口小部件树中查找实例化的服务定位器。所以我们有两个约束:我们需要一个上下文来向上搜索，并且这个上下文必须在他的父行中有一个<code class="fe no np nq nr b">MediaQuery</code>。首先满足这些先决条件的地方是在<code class="fe no np nq nr b">MaterialApp</code>(或者Cupertino，Fluent等。)子上下文。<br/>假设出于某种原因我们需要知道黑暗模式是在 <code class="fe no np nq nr b">MateralApp</code>正在构建之前<strong class="lb iu">设置的，还是在构建之外(进入<code class="fe no np nq nr b">Run()</code>方法？服役吗？一起吗？在供应商那里？)在这种情况下，我们必须找到另一种方法，我们必须偷偷离开Flutter让我们呆在里面的盒子。</strong></em></p><h1 id="10e9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我们必须在哪里得到它</h1><p id="7451" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们正在学习，所以在这个例子中，我们将抛开其他现成的解决方案(是的，有相应的包)并找到自己的方法。</p><p id="f25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在谷歌上快速搜索，我们发现当前的主题设置在Windows注册表中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5e35cf6ee185f4ac4f0082e7000337f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DaYm2rmvweT-BFc9TdUbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Windows注册表编辑器</p></figure><p id="a6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的设计值由<code class="fe no np nq nr b"><em class="lv">AppUseLightTheme</em></code> <em class="lv"> </em> valueName标识，它位于键:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/637352d163392c2f6f20830d40abb616.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*sGt91j-xwkG_zlRQLebDxw.png"/></div></figure><h1 id="d6e3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">如何获得(差不多)</h1><p id="28d0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要获得这个值，我们需要查询Win32 API，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是一个栈溢出忍者(在借用代码中)，所以来自这里的<a class="ae ky" href="https://stackoverflow.com/questions/51334674/how-to-detect-windows-10-light-dark-mode-in-win32-application" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bb62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们知道了地点和方法，让我们开始:</p><h1 id="ad1b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实施</h1><p id="0f43" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Windows命令提示符下，将<em class="lv"> cd </em>放到我们要创建插件的文件夹中，并:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="546e" class="nw lx it nr b gy nx ny l nz oa">flutter create --org it.example --template=plugin --platforms=windows windows_dark_mode</span></pre><p id="0c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设Flutter SDK已经正确安装和配置，我们将获得一个新的“windows_dark_mode”文件夹，其中包含我们的插件存根。让我们用IDE打开这个项目，然后选择“windows”作为目标，点击“运行”或“调试”，这将运行Flutter在我们的包的子文件夹中为我们创建的示例项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6d79e04acc71a2bd542d629a76bbd7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*nXTiQLffNm3Tqnj1wDht0w.png"/></div></figure><p id="9550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它描述了我们的Windows版本，它是如何工作的？如果我们在“\example\lib\main.dart”中查找，我们会在InitState中找到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/717ecb442d89e2abb20c3304b19fec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*II0EAVY8-DRG25US0a7Wyw.png"/></div></figure><p id="20cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过访问该属性，我们可以从操作系统中获得平台版本。我们打开/lib/windows_dark_mode.dart:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/5b58a55fe41f5e343b432791e8411a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1OXxVQtHvU0WjNDBnD1XQ.png"/></div></div></figure><p id="b0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里找到了我们的<code class="fe no np nq nr b">WindowsDarkMode</code>类和<code class="fe no np nq nr b">platformVersion</code> getter。这里没有C语言或Win32 API的痕迹，所以让我们试着去理解。这就是我们所看到的:</p><ol class=""><li id="593e" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu oi mz na nb bi translated">我们的示例应用程序从<code class="fe no np nq nr b"><em class="lv">platformVersion</em></code>属性中检索Windows版本；</li><li id="ce86" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oi mz na nb bi translated">该属性的getter依次调用 <code class="fe no np nq nr b"><em class="lv">_channel</em></code>对象上的<code class="fe no np nq nr b"><em class="lv">invokeMethod</em></code> <em class="lv">，在调用中指定“getPlatformVersion”；</em></li><li id="b819" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oi mz na nb bi translated"><em class="lv"> _channel </em>声明为<code class="fe no np nq nr b"><a class="ae ky" href="https://api.flutter.dev/flutter/services/MethodChannel-class.html" rel="noopener ugc nofollow" target="_blank"><em class="lv">MethodChannel</em></a></code>，实例化为“windows_dark_mode”通道名。</li></ol><p id="28fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定这些线索，我们可以假设当从<em class="lv">命名通道调用<em class="lv">命名方法</em>时，</em>这个请求到达某个地方，我们将从同一个地方收到答案。</p><blockquote class="nh ni nj"><p id="e0cc" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">等等，我们已经看到了，调用远程API是我们的日常工作！</p><p id="8c3c" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">克拉罗阙司！我们从“后端”调用API，<code class="fe no np nq nr b">MethodChannel</code>是我们的传输。这就是<a class="ae ky" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">平台通道</a>的工作方式，我们在Dart端有一个代理Api，它调用平台端的另一个API。</p><p id="247c" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">为什么有人决定走这条明显扭曲的道路，而不是让我们包含特定于平台的代码？</p><p id="e71c" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">可能有很多答案，但我更喜欢简单的:<strong class="lb iu">抽象</strong>。这样，我们就有了我们的应用程序代码，<strong class="lb iu">在</strong><strong class="lb iu"/>每个平台上编译，因为Dart端不知道平台端的其他代码。如果您尝试在Windows以外的平台上运行这个示例，它会运行，这要感谢在示例的main中访问<code class="fe no np nq nr b"><em class="it">platformVersion</em></code>属性时的try-catch块。</p></blockquote><p id="9279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从这里开始写，让我们把这个方法添加到<code class="fe no np nq nr b"><em class="lv">WindowsDarkMode</em></code> <em class="lv"> </em>类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢把<code class="fe no np nq nr b"><em class="lv">try-catch</em></code>放在这里，所以如果发生错误，我会简单地假设黑暗模式被禁用。如果你在windows以外的平台上使用这个插件运行你的应用，这是正常的。</p><p id="a0ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看“后端”，打开<code class="fe no np nq nr b">/windows/windows_dark_mode_plugin.cpp</code> <em class="lv">、</em>，专注于对我们来说重要的事情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1ae2c0e18a9ae348d54c21d7b060c1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQRsV4ym0p8HnRIyjf8R7Q.png"/></div></div></figure><p id="902a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有<code class="fe no np nq nr b">WindowsDarkModePlugin</code>类，这是我们的平台端后端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="74ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b"><em class="lv">RegisterWithRegistrar</em></code>实现中，方法通道被实例化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/eaf229f58b021b9e3b327371fe1bd3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*wulY8FzF-TDprp2UcLiOVg.png"/></div></figure><blockquote class="nh ni nj"><p id="0b6d" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">其中一个参数是标识它的名称。它与/lib/windows_dark_mode.dart中传递给<code class="fe no np nq nr b">MethodChannel</code>实例化的名称相同</p></blockquote><p id="c645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些行之后，<code class="fe no np nq nr b"><em class="lv">WindowsDarkModePlugin::HandleMethodCall</em></code> <em class="lv"> </em>被设置为该通道的处理程序。当另一方发出请求时，它将被触发，比如在Dart中调用<code class="fe no np nq nr b"><em class="lv">platformVersion</em></code> <em class="lv"> </em> getter:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/679c9432ce004200e8106ab696696f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*a1YYgK1n09-0xxXQeCRpSQ.png"/></div></figure><p id="b868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分析一下<code class="fe no np nq nr b">WindowsDarkModePlugin::HandleMethodCall</code>方法的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="73f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道，每次从另一端发出请求时，都会调用这个方法。它接收一个具有<code class="fe no np nq nr b"><em class="lv">method_name</em></code>属性的<code class="fe no np nq nr b"><em class="lv">method_call</em></code>值。一个通道可以处理不同种类的请求，因此<code class="fe no np nq nr b">method_name</code>识别来自“客户端”的特定请求。到目前为止，它只识别<code class="fe no np nq nr b">getPlatformVersion</code>请求，这与我们在Dart客户端看到的字符串值相同。</p><p id="3173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序返回一个<code class="fe no np nq nr b">EncodableValue</code>对象，该对象是围绕要返回的字符串构造的。在Dart中，拆箱是隐式的，它发生在窗帘后面。</p><p id="58cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将开始实现我们的新端点，所以我们必须添加代码来响应我们的新请求，<a class="ae ky" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">有人</a>告诉我们(当时Flutter的构建方法还不存在)函数必须很短，所以最好稍微重构一下这个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经提取了<code class="fe no np nq nr b"><em class="lv">getPlatformVersion()</em></code> <em class="lv"> </em>方法，并修改了<code class="fe no np nq nr b"><em class="lv">HandleMethodCall()</em></code>以在方法名匹配并执行相关代码时退出，现在无需链接更多if-else块即可轻松添加新调用。我们可以继续添加新案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="92d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并添加我们的新方法，从注册表中获取所需的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="d673" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">试运转</h1><p id="173c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们已经完成了实施。我们可以在我们的IDE中测试它的运行，但在此之前，我们必须更改<code class="fe no np nq nr b">\example\lib\main.dart</code><em class="lv"/>中的<code class="fe no np nq nr b"><em class="lv">build</em></code> <em class="lv"> </em>方法，调用我们的新平台方法。</p><p id="9cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe no np nq nr b">_MyAppState</code>课上，声明:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="eba7" class="nw lx it nr b gy nx ny l nz oa">bool _darkModeEnabled=false<strong class="nr iu">;</strong> </span></pre><p id="8228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe no np nq nr b">InitState</code>中设置它的值，调用我们新创建的属性:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f0e2" class="nw lx it nr b gy nx ny l nz oa">_darkModeEnabled=await WindowsDarkMode.isDarkModeAppEnabled;</span></pre><p id="f532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<em class="lv"> </em> <code class="fe no np nq nr b"><em class="lv">Text()</em></code> <em class="lv">小部件</em>初始化成<code class="fe no np nq nr b"><em class="lv">build</em></code> <em class="lv"> </em>方法<em class="lv">，</em>到<em class="lv"> </em>显示其值<em class="lv"> : </em></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3a1c" class="nw lx it nr b gy nx ny l nz oa">Text('Running on: $_platformVersion\nDark Mode is : $_darkModeEnabled')</span></pre><p id="36d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/93d7c5cb1adcc60feac05924b6928214.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*8kSp29S6hCopy5y4CWKszQ.png"/></div></figure><p id="eda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这台电脑上启用了黑暗模式，相信我，如果我停用它并再次运行，应用程序将显示“假”。</p><p id="3175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇教程对你有用。很快我将继续这个话题，用其他教程，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dynamic-theme-settings-change-in-a-flutter-desktop-app-63f137630417">展示我们如何从OS </a>接收动态事件，以及我们如何在Windows中调试插件的c++代码。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="7883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述教程的完整代码可以在这个<a class="ae ky" href="https://github.com/pgiacomo69/windows_dark_mode" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。感谢阅读。</p></div></div>    
</body>
</html>