<html>
<head>
<title>Using the PreferenceKey Protocol to Align Views in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PreferenceKey协议在SwiftUI中对齐视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-preferencekey-protocol-to-align-views-7f3ae32f60fc?source=collection_archive---------9-----------------------#2019-10-21">https://betterprogramming.pub/using-the-preferencekey-protocol-to-align-views-7f3ae32f60fc?source=collection_archive---------9-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd86" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你习惯于使用界面构建器来布局视图，那么当你在SwiftUI中时，感觉就像有人偷了你的工具箱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbfb03d23e34852ba5455592b22a4a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQSeecGokyuvB3L_GHaKNg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苏珊·霍尔特·辛普森在<a class="ae kv" href="https://unsplash.com/s/photos/toolbox?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b71f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您有一个由三个<code class="fe ls lt lu lv b">TextField</code>项组成的简单视图，并且您编写了如下所示的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您运行它时，您会得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/2f3f10631c6587c460d1fff60ada1afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QY4RlNdXQUq5owuQqrwvEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1</p></figure><p id="20ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">唉，</em>你以为。但是你记得在某处读到过关于<code class="fe ls lt lu lv b">Spacer()</code>的内容，所以你试着把它加在<code class="fe ls lt lu lv b">Text</code>和<code class="fe ls lt lu lv b">TextField</code>项之间。</p><p id="6203" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你猜怎么着？这两者都没什么区别。</p><p id="2c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">于是你在互联网上搜寻解决方案。似乎什么都不管用。然后，一个朋友问你是否看过SwiftUI essentials 上的<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2019/216/" rel="noopener ugc nofollow" target="_blank"> WWDC 19视频。你没有，所以你坐了一个小时听两个家伙赞美SwiftUI的优点。你(再次)变得非常兴奋。但是你错过了52分钟左右的几秒钟，在这几秒钟里，偏好被顺便提及。</a></p><p id="4f39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">偏好是聪明的东西——尤其是<code class="fe ls lt lu lv b">PreferenceKey</code>协议。它看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文的其余部分，我将向您展示如何使用它来获得如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/0e3845a4fd3f049302c4be6d50859556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkJwKpz4CqmWmirN4uRYpg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2</p></figure><p id="55be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义，根据<a class="ae kv" href="https://github.com/DKJone/SwiftUI-Learning/blob/master/SwiftUI-example/SwiftUI-example/SwiftUI.swift" rel="noopener ugc nofollow" target="_blank"> GitHub文件</a>说:<em class="lz"> A </em> <code class="fe ls lt lu lv b">PreferenceKey</code> <em class="lz">是一个视图产生的命名值。具有多个子视图的视图会自动将所有子值合并成一个对其祖先可见的值</em>。</p><p id="459b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ColumnWidthPreferenceKey</code>下面是我对<code class="fe ls lt lu lv b">PreferenceKey</code>的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe ls lt lu lv b">Text</code>视图收集的值是它们的宽度，这些值由<code class="fe ls lt lu lv b">reduce</code>函数形成一个<code class="fe ls lt lu lv b">ColumnWidthPreference</code>值数组。</p><p id="d7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这是怎么发生的呢？</p><p id="32e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是生成图2中视图的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ccb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这是一个由三个<code class="fe ls lt lu lv b">HStacks</code>组成的<code class="fe ls lt lu lv b">Form</code>，每个包含一个<code class="fe ls lt lu lv b">Text</code>视图，后跟一个<code class="fe ls lt lu lv b">TextField</code>视图。每一个都接受一个值到一个<code class="fe ls lt lu lv b">Binding</code>。就本文而言，重要的特性是:</p><ul class=""><li id="be3d" class="ma mb iq ky b kz la lc ld lf mc lj md ln me lr mf mg mh mi bi translated"><code class="fe ls lt lu lv b">Text</code>修饰符:<code class="fe ls lt lu lv b">frame</code>和<code class="fe ls lt lu lv b">background</code>。</li><li id="9f7e" class="ma mb iq ky b kz mj lc mk lf ml lj mm ln mn lr mf mg mh mi bi translated"><code class="fe ls lt lu lv b">Form</code>修改器:<code class="fe ls lt lu lv b">modifier</code>。</li></ul><p id="bb49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">background</code>的自变量为<code class="fe ls lt lu lv b">columnWidthEqualiserView</code>，定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ac30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们有一个<code class="fe ls lt lu lv b">GeometryReader</code>的声明，它被定义为一个容器视图，该视图将其内容定义为其自身大小和坐标空间的函数。</p><p id="b532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是通过一个<code class="fe ls lt lu lv b">GeometryProxy</code>实现的，它提供了对容器视图的大小和坐标空间的访问。</p><p id="1e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在示例代码中，容器视图是<code class="fe ls lt lu lv b">Text</code>视图。<code class="fe ls lt lu lv b">GeometryReader</code>后面是一个闭包，它的单个参数就是这样一个<code class="fe ls lt lu lv b">GeometryProxy</code>。闭包所做的是在由<code class="fe ls lt lu lv b">fill</code>修改的容器内创建一个<code class="fe ls lt lu lv b">Rectangle</code>形状，用清晰的颜色填充视图，并由<code class="fe ls lt lu lv b">preference</code>为<code class="fe ls lt lu lv b">ColumnWidthPreferenceKey</code>生成一个键/值对。这就是它如何为<code class="fe ls lt lu lv b">Text</code>视图构建一个宽度值数组。</p><p id="23a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Form</code>修改器的参数是<code class="fe ls lt lu lv b">ColumnWidth</code>，定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d0a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对<code class="fe ls lt lu lv b">ColumnWidthPreferenceKey</code>变化的响应。</p><p id="0acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它遍历所有子视图的首选项键/值对，寻找最宽的<code class="fe ls lt lu lv b">Text</code>视图(+20)，并将它保存到传递给它的参数<code class="fe ls lt lu lv b">width</code>。然后使用新的宽度重建视图，这就是<code class="fe ls lt lu lv b">frame</code>的用武之地。</p><p id="a8c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，这有点复杂——但确实有效。</p></div></div>    
</body>
</html>