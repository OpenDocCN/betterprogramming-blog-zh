<html>
<head>
<title>Power Up Your Flutter Development Process by Implementing Clean Architecture and Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现干净的架构和测试驱动的开发来增强你的Flutter开发过程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flutter-clean-architecture-test-driven-development-practical-guide-445f388e8604?source=collection_archive---------0-----------------------#2022-02-05">https://betterprogramming.pub/flutter-clean-architecture-test-driven-development-practical-guide-445f388e8604?source=collection_archive---------0-----------------------#2022-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dcac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Flutter代码库中建立干净架构的完整过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6a5db16adaf873013466fc763aed1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-N7TbKkCsbtKztuhebyGSw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">瑞安·安塞尔在<a class="ae kv" href="https://unsplash.com/s/photos/floor-plan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自2018年12月4日向公众发布以来，带有Flutter的应用开发生态系统经历了非常迅速的发展。选择Flutter作为开发快速迭代产品的SDK是正确的选择。但是在选择Flutter的时候，开发者也要开始思考如何组织app的状态管理，如何设计app(幕后)具有可维护性和可扩展性。</p><p id="31c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这些问题，我们需要在开始开发功能之前设计应用程序的架构。</p><h1 id="9428" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">干净的建筑</h1><p id="d377" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">架构在开发应用程序时非常重要。架构可以比作平面图，它描述了应用程序项目中的流程。实现该架构的主要目的是关注点分离(SoC)。所以，如果我们能一次专注于一件事，事情会变得更容易。</p><p id="610a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Flutter的上下文中，clean architecture将帮助我们将业务逻辑的代码与平台相关的代码(如UI、状态管理和外部数据源)分开。此外，我们编写的代码可以更容易独立测试(可测试)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a4bdc01dcc7415de6312e4adcc814f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtSvmSz5XOeSTeBWEjUeXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">干净的架构图</p></figure><p id="3e2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，从顶部看，干净的架构被描绘成一个金字塔或一片洋葱。clean架构将把Flutter项目分为3个主要层，即:</p><h2 id="00f1" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">数据和平台层</h2><p id="f5a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据层位于最外层。这一层由数据源代码组成，如消费Rest API、访问本地数据库、Firebase或其他来源。此外，在这一层上，通常有构建UI(小部件)的平台代码。</p><h2 id="bfb8" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">表示层</h2><p id="0019" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">表示层由从存储库中访问应用程序数据的代码组成。此外，还有状态管理代码，如providers、BLoC等等。</p><h2 id="e399" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">畴层</h2><p id="5785" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">领域层是干净架构中最深的一层。这一层包含业务逻辑应用程序的代码，例如实体和用例。</p><blockquote class="nb nc nd"><p id="1511" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">每一层都依赖于其他层。图上的箭头显示了各层之间的关系。最外层将依赖于内层等等。</p></blockquote><p id="0c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里不依赖于任何其他层的层只是领域层(独立的),它是业务逻辑的代码。这样，应用程序更具适应性和动态性。例如，如果我们想将状态管理从provider更改为BLoC，迁移过程将不会干扰现有的业务逻辑。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="a106" class="ls lt iq bd lu lv np lx ly lz nq mb mc jw nr jx me jz ns ka mg kc nt kd mi mj bi translated">测试驱动开发</h1><p id="1fce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">除了实现干净的架构之外，为了在产生最小的错误和减少重复的调试和修复过程方面优化开发过程，我们必须经历一个测试过程。</p><p id="9373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试驱动开发是一个应用程序开发过程，其中测试是驱动开发的主要特征。在应用程序中创建功能之前，将首先编写测试代码场景。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/499b779ab1846ef84f669c39adaa6030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4aHudsWKs3QyERchcNnBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试驱动的开发工作流</p></figure><p id="cade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用TDD的应用程序开发过程的工作流程如上图所示。注意，TDD过程是迭代的，它被称为红绿重构过程。</p><h2 id="3ef1" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤1:编写测试场景(红色)</h2><p id="44a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个特性的开发首先从编写一个测试场景开始。编写测试场景通常遵循PRD文档中的特性需求(针对公司中的情况)。在测试场景中，通常会有一个开发功能的流程，例如确定使用的数据源(例如远程或本地)，确保来自API的传入数据产生适当的模型，根据数据设计视图的状态流，等等。。当我们第一次编写测试场景时，我们会得到错误。这是正常的，因为功能代码尚不存在。</p><blockquote class="nb nc nd"><p id="3991" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">为特性编写测试场景是作为开发特性(实际代码)的指南来完成的。</p></blockquote><h2 id="2668" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤2:使测试场景成功(绿色)</h2><p id="7fbd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一步中，实际的特征码编写已经完成。在这一阶段编写代码不一定要整洁和最佳，因为这一步的主要目标是使之前编写的测试代码成功。</p><h2 id="3065" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤3:重构代码</h2><p id="8234" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在测试代码成功运行并且没有任何错误之后，是时候整理和优化已经编写的代码了，包括测试代码和实际的功能代码。</p><p id="1630" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用TDD过程，最终获得的结果是除了一个具有最小缺陷的应用程序之外，还有一个整洁和最佳的应用程序代码。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="405e" class="ls lt iq bd lu lv np lx ly lz nq mb mc jw nr jx me jz ns ka mg kc nt kd mi mj bi translated">案例研究实施</h1><p id="37e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们将尝试在一个迷你项目中实现我们之前谈到的两个概念，即天气应用程序。这次我们将使用<a class="ae kv" href="https://openweathermap.org/api" rel="noopener ugc nofollow" target="_blank"> OpenWeather API </a>作为我们应用程序的数据源。</p><p id="6d49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该项目的文件夹结构如下所示:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="e75c" class="mp lt iq nv b gy nz oa l ob oc">lib<br/>├── data<br/>│   ├── constants.dart<br/>│   ├── datasources<br/>│   │   └── remote_data_source.dart<br/>│   ├── exception.dart<br/>│   ├── failure.dart<br/>│   ├── models<br/>│   │   └── weather_model.dart<br/>│   └── repositories<br/>│       └── weather_repository_impl.dart<br/>├── domain<br/>│   ├── entities<br/>│   │   └── weather.dart<br/>│   ├── repositories<br/>│   │   └── weather_repository.dart<br/>│   └── usecases<br/>│       └── get_current_weather.dart<br/>├── injection.dart<br/>├── main.dart<br/>└── presentation<br/>    ├── bloc<br/>    │   ├── weather_bloc.dart<br/>    │   ├── weather_event.dart<br/>    │   └── weather_state.dart<br/>    └── pages<br/>        └── weather_page.dart</span><span id="ac86" class="mp lt iq nv b gy od oa l ob oc">test<br/>├── data<br/>│   ├── datasources<br/>│   │   └── remote_data_source_test.dart<br/>│   ├── models<br/>│   │   └── weather_model_test.dart<br/>│   └── repositories<br/>│       └── weather_repository_impl_test.dart<br/>├── domain<br/>│   └── usecases<br/>│       └── get_current_weather_test.dart<br/>├── helpers<br/>│   ├── dummy_data<br/>│   │   └── dummy_weather_response.json<br/>│   ├── json_reader.dart<br/>│   ├── test_helper.dart<br/>│   └── test_helper.mocks.dart<br/>└── presentation<br/>    ├── bloc<br/>    │   └── weather_bloc_test.dart<br/>    └── pages<br/>        └── weather_page_test.dart</span></pre><p id="eaed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想遵循这个教程，你可以在这个<a class="ae kv" href="https://github.com/codestronaut/flutter-weather-app-sample.git" rel="noopener ugc nofollow" target="_blank"> Github库</a>上使用下面的启动代码。</p><h2 id="6481" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤1:在领域层编写代码</h2><p id="b189" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一步是在领域层编写代码。为什么是域层？因为这一层是不依赖于任何其他层的层。所以从这一层入手会比较安全。</p><h2 id="7dfc" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">用例</h2><p id="5bf1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在测试/领域部分，我们只需要为用例编写测试场景。在这种情况下，我们有1个用例，<code class="fe oe of og nv b">get_current_weather_test.dart</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><blockquote class="nb nc nd"><p id="ebc9" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">上面的测试代码在开始时会有一个错误。这很正常，因为我们还没有编写实际的代码。</p></blockquote><p id="e3bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于领域层的实际特性代码，有3个部分，即实体、用例以及存储库。我们从写天气实体开始，它是<code class="fe oe of og nv b">weather.dart</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="42bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们继续为<code class="fe oe of og nv b">weather_repository.dart</code>写代码。天气知识库是一个抽象类，稍后将在数据层实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="eb69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将为用例<code class="fe oe of og nv b">get_current_weather.dart</code>编写代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在回到测试代码之前，我们必须创建一个模拟天气知识库。打开<code class="fe oe of og nv b">test_helper.dart</code>，添加<code class="fe oe of og nv b">WeatherRepository</code>。在<code class="fe oe of og nv b">test _helper.dart</code>中，还有一个对HTTP库的模拟，这样它可以在测试期间模拟对API的请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="71fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过终端运行以下命令来生成模拟文件:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="ce62" class="mp lt iq nv b gy nz oa l ob oc">flutter pub run build_runner build</span></pre><p id="6029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，回到<code class="fe oe of og nv b">get_current_weather_test.dart</code>并导入<code class="fe oe of og nv b">MockWeatherRepository</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cf8d30909ccb65388671fb39d6fb796e.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*gE8hZZbEf6UMOZpl.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取当前天气用例测试结果</p></figure><h2 id="7508" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤2:在数据层编写代码</h2><p id="f697" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在领域层处理完测试代码和特性之后，我们现在可以继续处理数据层的代码。在数据层，有数据源、模型和存储库。</p><blockquote class="nb nc nd"><p id="663e" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">等等，领域层也有存储库吗？是的，领域层的存储库是一个抽象类的形式，其中有一些功能仍然需要实现。因此，在数据层的存储库中，我们将开始实现抽象类。</p></blockquote><h2 id="c5d7" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">模型</h2><p id="4f42" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好，我们将从模型开始，这个过程从为模型编写测试代码开始，<code class="fe oe of og nv b">weather_model_test.dart</code>。在这里，我们将测试3个主要内容:</p><ul class=""><li id="eb47" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">我们所创建的模型是否等同于领域层的实体？</li><li id="b0a7" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated"><code class="fe oe of og nv b">fromJson()</code>函数是否返回有效的模型？</li><li id="e5f4" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated"><code class="fe oe of og nv b">toJson()</code>函数是否返回合适的JSON映射？</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="bcf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们继续编写<code class="fe oe of og nv b">weather_model.dart</code>的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，返回测试代码并导入<code class="fe oe of og nv b">weather_model.dart</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1b1f4ea722a432e4744c6d95c9efbbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*H6iBDr4V7MwAY-GC.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型测试结果</p></figure><h2 id="9501" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">数据源</h2><p id="b096" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们继续处理数据源中的代码。这里是<code class="fe oe of og nv b">remote_data_source_test.dart</code>的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的<code class="fe oe of og nv b">remote_data_source_test.dart</code>代码将测试从API获取天气数据的过程。有两个条件:</p><ul class=""><li id="01ee" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">成功获取数据时返回有效模型</li><li id="7fd2" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">获取数据失败时返回一个<code class="fe oe of og nv b">ServerException</code></li></ul><p id="e6e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要像这样的<code class="fe oe of og nv b">JSON</code>形式的虚拟数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON响应示例</p></figure><p id="7cfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后继续编写数据源的代码<code class="fe oe of og nv b">remote_data_source.dart</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，返回测试代码并导入<code class="fe oe of og nv b">remote_data_source.dart</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/b15ec9c7428627224da293601e90d4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/0*T29lt2PCzuvKKpL5.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据源测试结果</p></figure><h2 id="92ff" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">仓库</h2><p id="f1e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">接下来，我们将处理存储库的代码，即<code class="fe oe of og nv b">weather_repository_impl_test.dart</code>和<code class="fe oe of og nv b">weather_repository_impl.dart</code>。这里的术语<code class="fe oe of og nv b">impl</code>是实现的意思。</p><p id="80e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在<code class="fe oe of og nv b">weather_repository_impl_test.dart</code>上进行测试，我们需要访问数据源。因此，我们将首先为之前创建的远程数据源生成一个模拟。将<code class="fe oe of og nv b">RemoteDataSource</code>添加到<code class="fe oe of og nv b">test_helper.dart</code>中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="93cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，运行下面的<strong class="ky ir">命令</strong>从数据源生成一个模拟:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="925b" class="mp lt iq nv b gy nz oa l ob oc">flutter pub run build_runner build</span></pre><p id="c595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe oe of og nv b">MockRemoteDataSource</code>已经准备好用于测试，现在我们为<code class="fe oe of og nv b">weather_repository_impl_test.dart</code>编写代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="14f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，测试的场景是:</p><ul class=""><li id="3cf5" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">成功的API请求返回<code class="fe oe of og nv b">current weather</code>数据</li><li id="2226" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">当对API的请求失败时返回<code class="fe oe of og nv b">ServerFailure</code></li><li id="c8ac" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">未连接互联网时恢复<code class="fe oe of og nv b">ConnectionFailure</code></li></ul><p id="9825" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们继续进行<code class="fe oe of og nv b">weather_repository_impl.dart</code>的工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="080f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，返回测试代码并导入<code class="fe oe of og nv b">weather_repository_impl.dart</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/7c347358b05e131d4706be80b950475b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9A8AdwQsGjptIt9K.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">知识库测试结果</p></figure><h2 id="aa36" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">步骤3:在表示层编写代码</h2><p id="8251" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在领域和数据层工作之后，最后一步是在表示层处理代码。在这一层，有状态管理(在这种情况下我们使用<em class="ne"> BLoC </em>)和页面。</p><h2 id="db01" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">状态管理(<em class="pb">集团</em>)</h2><p id="5635" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我们将代码状态管理(<em class="ne"> BLoC </em>)。对于在<code class="fe oe of og nv b">weather_bloc_test.dart</code>上的测试，我们需要访问用例<code class="fe oe of og nv b">MockGetCurrentWeather</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="dba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后运行以下命令从GetCurrentWeather生成一个模拟。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="d678" class="mp lt iq nv b gy nz oa l ob oc">flutter pub run build_runner build</span></pre><p id="7e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们继续处理<em class="ne">块</em>状态管理代码。这里我们的<em class="ne"> BLoC </em>代码由<code class="fe oe of og nv b">weather_state.dart</code>、<code class="fe oe of og nv b">weather_event.dart</code>和<code class="fe oe of og nv b">weather_bloc.dart</code>组成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="5265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，返回测试代码并导入<code class="fe oe of og nv b">weather_bloc.dart</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/715fe43936af2b2d4d8c5cd773feb616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*Y6ZNCGRNpztjyogB.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阻塞状态管理测试结果</p></figure><h2 id="5034" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">页</h2><p id="5685" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在完成了<em class="ne">块</em>代码之后，我们将为应用程序的页面或用户界面创建代码。先说测试代码，即<code class="fe oe of og nv b">weather_page_test.dart</code>。在这里，我们将测试3样东西:</p><ul class=""><li id="f30f" class="ok ol iq ky b kz la lc ld lf om lj on ln oo lr op oq or os bi translated">完成填充<code class="fe oe of og nv b">TextField</code>后，应用程序的状态应该从<code class="fe oe of og nv b">WeatherEmpty</code>变为<code class="fe oe of og nv b">WeatherLoading</code>。</li><li id="4464" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">当应用程序的状态为<code class="fe oe of og nv b">WeatherLoading</code>时，显示进度指示器。</li><li id="96c5" class="ok ol iq ky b kz ot lc ou lf ov lj ow ln ox lr op oq or os bi translated">当应用程序的状态为<code class="fe oe of og nv b">WeatherHasData</code>时，显示包含天气信息的小部件。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们继续编写<code class="fe oe of og nv b">weather_page.dart</code>的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ed34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，返回测试代码并导入<code class="fe oe of og nv b">weather_page.dart</code>然后运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/39f0365661c915f9f76118c1f8cbb99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*Ku5h-CEMysreQDfh.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">页面测试结果</p></figure><h1 id="2de1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行应用程序</h1><p id="61d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">至此，我们已经完成了具有一个特性的应用程序，该特性基于对城市名称的搜索来获取最新的天气信息。现在，我们将尝试在模拟器上运行应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/5850407efe14690da6e7095ecdb87cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pz5FoVgJFjQd9p6J.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">决赛成绩</p></figure><h1 id="75d2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概述</h1><p id="a8f0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实现测试驱动开发和干净架构的过程确实非常复杂。然而，如果我们依赖于最终的结果，即最少的bug、添加特性的便利性和库迁移(如状态管理)，这是值得的！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="7572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以运行测试覆盖，看看是否所有的代码都已经测试过了。在终端的项目目录中运行以下命令:</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="1e2b" class="mp lt iq nv b gy nz oa l ob oc">flutter test --coverage<br/>genhtml coverage/lcov.info -o coverage/html<br/>open coverage/html/index.html</span></pre><p id="96ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/217d4267305cf4f532d3d5bb59ec8220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*appZ7n1L9Tt1tSjH.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试覆盖率结果</p></figure><p id="6d64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是在Flutter项目中实现干净架构和测试驱动开发的过程。希望有用。谢谢大家！</p><p id="4222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码:</p><div class="pf pg gp gr ph pi"><a href="https://github.com/codestronaut/flutter-weather-app-sample.git" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ir gy z fp pn fr fs po fu fw ip bi translated">GitHub-codestronaut/flutter-weather-app-sample:这个库是一个学习TDD的样例应用程序…</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">github.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw kp pi"/></div></div></a></div></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="39d7" class="ls lt iq bd lu lv np lx ly lz nq mb mc jw nr jx me jz ns ka mg kc nt kd mi mj bi translated">参考</h1><ul class=""><li id="c04b" class="ok ol iq ky b kz mk lc ml lf px lj py ln pz lr op oq or os bi translated"><a class="ae kv" href="https://ieeexplore.ieee.org/abstract/document/9071367" rel="noopener ugc nofollow" target="_blank">https://ieeexplore.ieee.org/abstract/document/9071367</a></li></ul></div></div>    
</body>
</html>