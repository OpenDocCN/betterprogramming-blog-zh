<html>
<head>
<title>Database Testing Made Easy With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest简化了数据库测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/database-testing-made-easy-with-jest-db96ad5f1f46?source=collection_archive---------2-----------------------#2020-01-19">https://betterprogramming.pub/database-testing-made-easy-with-jest-db96ad5f1f46?source=collection_archive---------2-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试数据库并不像你想象的那么困难——知道如何做可能是救命稻草</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f8d85c656cd5b969e5f0d52e367afc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjFzq_JcSPviXP4u5b60Vw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fabioha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae ky" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试是软件开发生命周期中非常重要的一部分。通过在整个代码库中预防和检测错误，它避免了大量的返工。</p><p id="6438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有的应用程序都以某种形式使用数据库。那么数据库可以测试吗？当然可以。如果获取和发布数据是应用程序的需求，为什么不测试一下呢？有几个库可以用来执行这些任务，但是在这篇关于数据库测试的文章中，Jest将用于测试，Mongoose用于与Mongo数据库通信。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="370c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">下载依赖关系</strong></h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="346c" class="mz md it mv b gy na nb l nc nd">$ yarn add jest mongoose dotenv</span></pre><p id="e670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mv b">DotEnv</code>库用于测试中使用的值。在Jest中使用Mongoose也需要注意，但是有一个解决方法。创建一个<code class="fe ne nf ng mv b">jest.config.js</code>文件，然后添加下面的代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="97e9" class="mz md it mv b gy na nb l nc nd">+ jest.config.js</span><span id="2337" class="mz md it mv b gy nh nb l nc nd">module.exports = {<br/>  testEnvironment: 'node'<br/>};</span></pre><p id="8c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建用于测试的脚本和将包含在测试中的环境变量。这些变量对于如何执行测试很重要。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c8a0" class="mz md it mv b gy na nb l nc nd">+ package.json</span><span id="5358" class="mz md it mv b gy nh nb l nc nd">"scripts": {<br/>    "test": "./node_modules/.bin/jest --no-cache"<br/> }</span><span id="4605" class="mz md it mv b gy nh nb l nc nd">+ .env</span><span id="9bde" class="mz md it mv b gy nh nb l nc nd">DATABASE=shop<br/>COLLECTION=customers</span><span id="b1e6" class="mz md it mv b gy nh nb l nc nd">CUSTOMER_NAME=John<br/><a class="ae ky" href="mailto:CUSTOMER_EMAIL=bshelling@gmail.com" rel="noopener ugc nofollow" target="_blank">CUSTOMER_EMAIL=john@example.com</a><br/><a class="ae ky" href="mailto:CUSTOMER_EMAIL_ALT=test@email.com" rel="noopener ugc nofollow" target="_blank">CUSTOMER_EMAIL_ALT=doe@example.com</a></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3de5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用描述块创建一个测试文件</h1><p id="93bb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个描述块将测试分组以使它们有组织。在本例中，描述块被标记为“客户CRUD”。为表示用于与数据库通信的端点而创建的测试。总共将运行五个测试。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a360" class="mz md it mv b gy na nb l nc nd">+ database.test.js</span><span id="8263" class="mz md it mv b gy nh nb l nc nd">const mongoose = require('mongoose');<br/>require('dotenv').config();</span><span id="c511" class="mz md it mv b gy nh nb l nc nd">describe('Customer CRUD',() =&gt; {</span><span id="cfb6" class="mz md it mv b gy nh nb l nc nd">});</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c1c3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置数据库连接</h1><p id="f928" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在运行测试之前，需要用一些其他设置建立到数据库的连接。Jest有两个函数包含在describe块中，<code class="fe ne nf ng mv b">beforeAll</code>和<code class="fe ne nf ng mv b">afterAll</code>。<code class="fe ne nf ng mv b">beforeAll</code>功能将在测试执行前执行所有动作，而<code class="fe ne nf ng mv b">afterAll</code>功能将在测试完成后执行其动作。</p><p id="2e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置包括连接到数据库、创建数据库和创建集合。该数据库将是一个测试数据库，是生产中使用的数据库的副本。在这个例子中，测试数据库被标记为<code class="fe ne nf ng mv b">test_shop</code>。拆除操作包括删除测试数据库。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ebbd" class="mz md it mv b gy na nb l nc nd">beforeAll(async () =&gt; {<br/>       <br/>   connection = await mongoose.connect('mongodb://localhost:27017/test_'+process.env.DATABASE,{useNewUrlParser: true, useUnifiedTopology: true });<br/>   db = mongoose.connection;<br/>   const collection = process.env.COLLECTION;<br/>   await db.createCollection(collection);</span><span id="25c2" class="mz md it mv b gy nh nb l nc nd">});</span><span id="0f08" class="mz md it mv b gy nh nb l nc nd">afterAll(async () =&gt; {</span><span id="57c6" class="mz md it mv b gy nh nb l nc nd">   const collection = "test_"+process.env.COLLECTION;<br/>   await db.dropCollection(collection);<br/>   await db.dropDatabase();<br/>   await db.close();<br/>   await connection.close();</span><span id="4a73" class="mz md it mv b gy nh nb l nc nd">});</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">阶段测试</h1><p id="c4fb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第一个测试是将单个客户发布到客户集合中。这首先是因为除非重复这个步骤，否则下一个测试将会失败——但是目标是保持测试精益。因此，添加了一个客户并测试了响应。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="358a" class="mz md it mv b gy na nb l nc nd">test("Add Customer POST /customers",async () =&gt; {</span><span id="abf3" class="mz md it mv b gy nh nb l nc nd">const response = await customers.create({</span><span id="e4ff" class="mz md it mv b gy nh nb l nc nd">      name: process.env.CUSTOMER_NAME,<br/>      email: process.env.CUSTOMER_EMAIL});<br/>      await response.save();<br/>      expect(response.name).toBe(process.env.CUSTOMER_NAME);</span><span id="e457" class="mz md it mv b gy nh nb l nc nd">});</span></pre><p id="f88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，测试将检查是否有来自响应的客户。因为响应是一个对象数组，所以测试期望数组的长度大于零。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4472" class="mz md it mv b gy na nb l nc nd">test("All Customers GET /customers", async () =&gt; {</span><span id="e2eb" class="mz md it mv b gy nh nb l nc nd">   const response = await customers.find({});<br/>   <br/>   expect(response.length).toBeGreaterThan(0);</span><span id="0f35" class="mz md it mv b gy nh nb l nc nd">});</span></pre><p id="07f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新记录的测试分为两部分。一个测试检查保存时通过的电子邮件，另一个测试查询更新的记录以检查其当前的电子邮件地址。它应该是提供的任何替代电子邮件。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="71a3" class="mz md it mv b gy na nb l nc nd">test("Update Customer PUT /customers/:id", async () =&gt; {<br/>  const response = await customers.updateOne({name: process.env.CUSTOMER_NAME},{email: process.env.CUSTOMER_EMAIL_ALT});<br/>  expect(response.ok).toBeTruthy();<br/>});</span><span id="aab4" class="mz md it mv b gy nh nb l nc nd">test("Customer update is correct", async () =&gt; {<br/>const responseTwo = await customers.findOne({name: process.env.CUSTOMER_NAME});<br/>expect(responseTwo.email).toBe(process.env.CUSTOMER_EMAIL_ALT);<br/>});</span></pre><p id="91f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个测试很简单。通过期待有效的响应来测试记录的删除:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6551" class="mz md it mv b gy na nb l nc nd">test("Delete Customer DELETE /customers/:id", async() =&gt; {<br/>  const response = await customers.deleteOne({name: process.env.CUSTOMER_NAME});<br/>  expect(response.ok).toBe(1);<br/>});</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4913" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运行测试</h1><p id="c034" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在，当测试执行时，报告应该返回套件和通过的五个测试。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e738" class="mz md it mv b gy na nb l nc nd">$ yarn test</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/9aac361d5c625a4a88600e0006a93927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROGuLu_Gor_rnr66UBXt6g.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d425" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整示例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目示例</p></figure><p id="ed12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想得到更多这样的帖子，请注册我的时事通讯以获得最新消息。<a class="ae ky" href="https://share.hsforms.com/1tVh1vq1ZSHy0JlsTnFBwwg4c0tk" rel="noopener ugc nofollow" target="_blank">注册简讯</a></p></div></div>    
</body>
</html>