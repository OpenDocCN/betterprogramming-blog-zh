<html>
<head>
<title>Managing Private Files With AWS S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS S3管理私有文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-private-files-with-aws-s3-d17cb9e3dcde?source=collection_archive---------4-----------------------#2022-07-20">https://betterprogramming.pub/managing-private-files-with-aws-s3-d17cb9e3dcde?source=collection_archive---------4-----------------------#2022-07-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7f37" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">了解使用AWS S3在应用程序中处理私有文件的两种方法</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/2e9fe7277809e270b9f1d20b0dc2013f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vGC_4QUjxoLCFNBa"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">作者图片</p></figure><h1 id="db42" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">概观</h1><p id="22f4" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">回到2020年，在我工作的公司，有人告诉我，我们正在将我们的图像从<a class="ae mk" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>迁移到<a class="ae mk" href="https://aws.amazon.com/es/s3/" rel="noopener ugc nofollow" target="_blank"> AWS S3 </a>，我将负责执行迁移。长话短说，我完成了迁移，但在此过程中，我遇到了一个问题—我们的映像必须是私有的，只能由管理员查看。两年后，我面临着一个类似的问题，但是使用了不同的用例。</p><p id="b73b" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">在本文中，我将向您展示使用AWS S3管理私有文件的两种方法:一种是我在2020年做的，另一种是我现在计划做的。</p><h1 id="2650" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">方法1:通过后端端点获取文件</h1><p id="4fee" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">这个解决方案是我在迁移图像时使用的。它主要包括创建一个后端端点，该端点将验证请求图像的用户是否有查看文件的必要权限。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mq"><img src="../Images/ee1d689d6c10c7bfc8f963cb24800796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdxMZALw7Qc0-v2npZXxcA.png"/></div></div></figure><h2 id="3ab6" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">我的</strong>u<strong class="ak">sè案</strong></h2><p id="95ff" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">授予管理员访问权限，这样他们就可以看到很少被请求的私有图像(三倍)。</p><p id="c6e7" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这种方法的一个缺点是，私有文件首先从S3传到我们的后端，再从那里传到客户端，这增加了传输成本。但是这对于我们的用例来说是可以的，因为这些图像仅仅被请求一两次，然后就忘记了。毕竟，除非我们需要验证历史数据，否则不再需要它们。</p><h1 id="4b6e" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">解决方案2:预先设计URL</h1><p id="5a7f" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">这个解决方案在于使用所谓的预设计URL。这些URL背后的想法是在一段时间内提供对私有文件的访问，我们通过在后端使用私有凭证对我们的S3的对象密钥进行签名来实现，然后设置一个过期时间，在该时间内，预签名URL将对请求有效。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nd"><img src="../Images/d9beaed2f36afbd7b99ea010c50be0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t1-ofCLBZJSPyY7-"/></div></div></figure><p id="e5e9" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">如您所见，对于这个方法，我们还使用一个后端端点来验证用户是否有权查看私有文件，因此我们可以返回签名的URL。</p><h2 id="9f15" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">我的</strong> u <strong class="ak"> se案例</strong></h2><p id="bc86" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">呈现一个带有姓名和图片的雇员列表(为了保持示例简单),这些雇员将在应用程序中经常被访问。</p><p id="11b5" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这样，我们解决了第一种方法的传输成本问题，而不是将文件从S3传输到我们的后端，然后再传输到客户端。我们只需向客户端发送一个签名的URL，该URL可用于直接从S3获取文件。</p><p id="c6b2" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这里我们将面临的一个问题是，每次我们对一个URL签名时，都会生成一个新的签名。所以浏览器不能缓存图像，因为URL总是会改变，所以我们每次都会有这样的东西:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ne"><img src="../Images/dec6f5a394a2a6d1d3ac6bb16e00457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d-Rue5eHhrfgOOUe"/></div></div></figure><p id="06b6" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">在每个请求中，用户将下载文件，而不是从缓存中获取。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nf"><img src="../Images/2edd9046fbfa1b37360f9f7289588b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dWMrTuhpnUOmns6Y"/></div></div></figure><p id="729c" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这个问题在这篇<a class="ae mk" href="https://advancedweb.hu/cacheable-s3-signed-urls/" rel="noopener ugc nofollow" target="_blank">文章</a>中有详细解释，但基本上，我们需要一种方法来为预先设计的URL获取相同的签名，这样浏览器就可以缓存文件。</p><p id="e36b" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">另一件事是，我需要在前端呈现一个员工列表，其中每个人都有一个私人图像，但拥有一个每次只签署一个URL的端点将是我们服务器的一个<a class="ae mk" href="https://hernanreyes.dev/how-the-n1-query-problem-can-burn-your-database" rel="noopener ugc nofollow" target="_blank"> N+1查询问题</a>。因此，当我们返回员工列表时，我们还必须返回预先签名的URL以避免这个问题。</p><p id="1099" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">在我调查这个的时候，我看到<a class="ae mk" href="https://www.notion.so/" rel="noopener ugc nofollow" target="_blank">idea . so</a>和<a class="ae mk" href="https://raindrop.io/" rel="noopener ugc nofollow" target="_blank"> raindrop.io </a>使用这些预先设计好的URL来处理你账户里面的私人文件。</p><h1 id="d322" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">固定S3铲斗</h1><p id="2fb9" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">我们迟早要做的事情是配置我们的S3，以便在使用AWS SDK时访问我们的后端，这样我们就可以从我们的S3桶上传或获取文件。</p><p id="8e61" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">AWS为我们提供了不同的方法来访问我们的S3 bucket，但是因为我们在同一个AWS帐户中工作，所以我们将使用IAM策略来提供对我们的bucket的访问。</p><h2 id="4043" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">IAM策略</h2><p id="1f15" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">这些策略控制对AWS上资源的访问(在我们的例子中是S3 ),并附加到AWS帐户中的用户、角色或组等实体，以定义这些实体在AWS提供的不同服务中可以做什么。</p><p id="de7d" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">现在，我们将继续进行配置:</p><p id="c453" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这里我假设您已经有一个AWS帐户</p><h2 id="03a5" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">创建存储我们的对象的桶</strong></h2><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ng"><img src="../Images/19f9702b5079bd92fb7c16263e3eb3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QWIDWbZziNP0eTKN"/></div></div></figure><p id="ceba" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">如果您也有公共文件，您必须像我在这里做的那样禁用阻止公共访问选项。</p><h2 id="92cd" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">创建一个策略来定义我们用户的权限</strong></h2><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ng"><img src="../Images/e07a0c0eef751c9ef14155770dbad9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7N_xGFJGBWIYRWw9"/></div></div></figure><p id="56ce" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">对于我的例子，我只需要三个权限:</p><ol class=""><li id="f581" class="nh ni ir lq b lr ml lu mm lx nj mb nk mf nl mj nm nn no np bi translated"><code class="fe nq nr ns nt b">PutObject</code>上传文件</li><li id="59b5" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated"><code class="fe nq nr ns nt b">PutObjectAcl</code>定义文件是公开的还是私有的</li><li id="7b99" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated"><code class="fe nq nr ns nt b">GetObject</code>获取文件</li></ol><p id="3d0e" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">此外，我指定这个策略只对我们刚刚创建的带有字段的bucket有效:<code class="fe nq nr ns nt b">"Resource": "arn:aws:s3:::hrmtest/*"</code></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><h2 id="0a53" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">创建一个用户来获取我们后端所需的凭证</strong></h2><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ng"><img src="../Images/aed566152593aa8a2cffef7cef6b0d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9AIx0J2adfUx_91DwmIBUw.gif"/></div></div></figure><p id="cc16" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这里，我们使用上一步中刚刚创建的策略创建用户，这样我们就可以获得在应用程序中使用它们的凭证。</p><p id="129e" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">之后，我们就可以在应用程序中使用我们的凭证了。</p><h1 id="55dc" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">代码时间！</h1><p id="f372" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">我正在准备一个小项目，我们将能够从AWS S3上传和获取文件。我们将使用从AWS下载的凭证，并将它们放在启动服务时将被读取的<code class="fe nq nr ns nt b">.env</code>文件中，这样我们就可以向AWS发出请求。代码如下:</p><pre class="kh ki kj kk gu ob nt oc od aw oe bi"><span id="60b3" class="mr kx ir nt b gz of og l oh oi"># AWS S3<br/>S3_ACCESS_KEY_ID=AKIAZCF3JGYORXJMZPMY<br/>S3_SECRET_ACCESS_KEY=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<br/>S3_BUCKET_NAME=hrm-article-demo<br/>S3_BUCKET_REGION=us-east-1</span></pre><p id="bcfe" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">到本文发表时，凭证将不再存在，所以不要费心尝试用它们做些什么。</p><p id="6292" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">在我们读取凭证之后，我们将使用它们来获得到AWS S3的会话。代码如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><h2 id="d1df" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">上传方式</strong></h2><p id="aaf5" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">有了这个，我们就可以上传公共或私人文件。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><h2 id="d998" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak"> GetFile方法</strong></h2><p id="9e23" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">为了获得私有文件，我们将使用这个方法。对于公共文件，AWS给我们一个如下格式的URL:<code class="fe nq nr ns nt b">https://{bucket-name}.s3.amazonaws.com/{object-key.png}</code>→<a class="ae mk" href="https://hrm-article-demo.s3.amazonaws.com/employees/1399d998-b505-4ce2-b49b-bd8073de9b9e.jpg" rel="noopener ugc nofollow" target="_blank">https://HRM-article-demo . S3 . amazonaws . com/employees/1399 d998-b505-4ce 2-b49b-BD 8073 de 9 b 9 e . jpg</a>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><h2 id="6d97" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">预设计方法</strong></h2><p id="f933" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">有了这个，我们将能够签署我们的私人文件的关键，所以我们可以看到该文件一段时间。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="0cdc" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">另一种不需要每次都获得相同签名的方法如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="7587" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">如果你不介意每次都得到相同的签名，这是一个更简洁的解决方案。</p><p id="e854" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">这里，我只展示了本文感兴趣的代码。如果你想看到项目的所有代码，只需进入:<a class="ae mk" href="https://github.com/hernanhrm/blog-examples/tree/main/private-files" rel="noopener ugc nofollow" target="_blank">https://github . com/hernanhrm/blog-examples/tree/main/private-files</a>。</p><p id="138c" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">此外，我提到在后端，我们需要验证用户是否有所需的权限来查看所请求的文件，但我没有在本文中包括该代码，因为我将撰写一篇关于如何在应用程序中处理身份验证和授权的文章。</p><h1 id="6e62" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">游戏时间！</h1><p id="58de" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">现在我们有了代码，我们可以玩它了。</p><h2 id="2847" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">上传图像</strong></h2><p id="1ebc" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">我们将上传一个私人图像，所以看到它的唯一方式是通过我们的端点获取文件或签署URL。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oj"><img src="../Images/2927486fec52cfc28687fe0169388e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y-HVNmYDTU8_tFbU"/></div></div></figure><p id="5ca7" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">一旦我们发送请求，我们将得到如下响应:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ok"><img src="../Images/e00d29ac245a1bc8c0dfeaa482093417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fKYS3pYuS816xm-l"/></div></div></figure><p id="7f67" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">正如我刚才告诉你的，查看图像的唯一方式是通过我们的端点来获取文件或签署URL，因此如果我们尝试使用AWS给我们的URL，它将向我们显示如下内容:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ol"><img src="../Images/27ea5b907614da92c45c92eebe730f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2OIj1w6lO4KLophN"/></div></div></figure><p id="ef15" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">但是，如果我们使用我们创建的端点从AWS获取文件，我们将获得文件:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj om"><img src="../Images/79df03807451018287d6ecce5eb4e54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M6DcVzR-rsf5Rtjj"/></div></div></figure><p id="894f" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">对，就是我。现在让我们试着签名URL:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj on"><img src="../Images/ba3df47aa4e12f3dde7f0db5a4f6dfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4zwbjdLDJjqcwn49"/></div></div></figure><p id="f2d0" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">现在，如果我们使用预先指定的URL，我们也将在文件仍然有效时获取它。看起来是这样的:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oo"><img src="../Images/5d4eb078cb731515848758d6f338fd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*89cSp44ItKHj20DI"/></div></div></figure><h2 id="7002" class="mr kx ir bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><code class="fe nq nr ns nt b"><strong class="ak">GetEmployees</strong></code>法<strong class="ak">法</strong></h2><p id="4190" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">对于我的用例，我告诉过你我需要为员工的照片生成一个签名的URL，但是调用一个端点来逐个签名一个URL将是一个N+1查询问题。因此，我将使用一种方法在请求雇员时获取辞职的URL。代码如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><p id="57b0" class="pw-post-body-paragraph lo lp ir lq b lr ml js lt lu mm jv lw lx mn lz ma mb mo md me mf mp mh mi mj ik bi translated">因此，如果我们为我们的员工上传一些图像，当我们请求GET <code class="fe nq nr ns nt b">api/v1/employees</code>时，我们将在当天每次执行请求时获得一个带有相同签名的已签名URL，正如我们可以看到的，浏览器缓存了图像。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj op"><img src="../Images/c9cb9e875a8561160912e515d6ccc7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aUnKGRwIHzj9Kk4s"/></div></div></figure><h1 id="952e" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">结论</h1><p id="f3e3" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">好了，这比我预期的要长，但是我用我在工作中遇到的用例向您展示了如何配置您的S3和从AWS S3获取私有文件的两种方法。所以我希望你能根据你的情况决定用什么方法。</p><h1 id="a908" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">参考</h1><ol class=""><li id="bdb0" class="nh ni ir lq b lr ls lu lv lx oq mb or mf os mj nm nn no np bi translated">为了便于说明，<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/excalidraw.com"> Excalidraw </a></li><li id="f8e4" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated"><a class="ae mk" href="https://advancedweb.hu/tags.html#S3%20signed%20URLs-ref" rel="noopener ugc nofollow" target="_blank">深入了解预签名网址的工作原理</a></li><li id="123b" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated">如果你会说西班牙语，这里有一个关于https://ed.team/cursos/s3 S3的很好的课程</li><li id="e749" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated"><a class="ae mk" href="https://medium.com/@aidan.hallett/securing-aws-s3-uploads-using-presigned-urls-aa821c13ae8d" rel="noopener">使用预先设计的URL保护AWS S3上传的安全</a></li><li id="2bf2" class="nh ni ir lq b lr nu lu nv lx nw mb nx mf ny mj nm nn no np bi translated"><a class="ae mk" href="https://github.com/hernanhrm/blog-examples/tree/main/private-files" rel="noopener ugc nofollow" target="_blank">项目资源库</a></li></ol></div></div>    
</body>
</html>