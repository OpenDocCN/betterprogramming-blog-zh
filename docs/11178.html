<html>
<head>
<title>Async/Await: Generic Network Layer With Swift 5.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">async/Await:Swift 5.5通用网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-await-generic-network-layer-with-swift-5-5-2bdd51224ea9?source=collection_archive---------0-----------------------#2022-02-24">https://betterprogramming.pub/async-await-generic-network-layer-with-swift-5-5-2bdd51224ea9?source=collection_archive---------0-----------------------#2022-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ee4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何最大化它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b31e8df70d8e3ee1c1adb69563c5076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxBRUnHoGIwt6jAHc4-lqw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">泰勒·维克在<a class="ae kv" href="https://unsplash.com/s/photos/data-center?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="b100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们学习如何开发前端应用程序时，从服务器接收响应是最酷的事情之一。正是在这种互动中，应用程序变得栩栩如生。</p><p id="d5eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将向您展示如何为您的iOS应用程序创建一个简单而通用的网络层，而不必在每次发出请求时都编写大量代码，避免出现样板文件。</p><p id="e71f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还没有掌握API的概念，我强烈建议你在继续之前阅读<a class="ae kv" href="https://medium.com/free-code-camp/what-is-an-api-in-english-please-b880a3214a82" rel="noopener">这篇文章</a>。此外，很好地理解<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/difference-between-protocol-oriented-programming-pop-and-object-oriented-programming-oop-in-swift-2dc3048b4fd?gi=1d2e64777904">面向协议编程(POP) </a>和<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/async-and-await-in-swift-5-5-5c8abb9f4f85">异步/等待</a>结构并发性也很重要。</p><h1 id="13c0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">TMDB:电影数据库</h1><p id="3ef2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了在本文中帮助我们，我们将使用TMDB的API来发出一些请求，你可以在文档<a class="ae kv" href="https://developers.themoviedb.org/3/" rel="noopener ugc nofollow" target="_blank">中看到这些请求。简言之，TMDB是一个包含电影、电视节目、连续剧等信息的数据库。</a></p><p id="3f95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用API是免费的，但这并不意味着它是完全开放的。为了提出请求，你需要一个访问令牌，你可以按照以下步骤在TMDB的页面上注册获得:</p><p id="48e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.进入https://www.themoviedb.org/的TMDB页面:<a class="ae kv" href="https://www.themoviedb.org/" rel="noopener ugc nofollow" target="_blank"/></p><p id="c7c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.点击“加入TMDB”</p><p id="74fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.注册然后登录</p><p id="1ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.进入设置&gt; API:<a class="ae kv" href="https://www.themoviedb.org/settings/api" rel="noopener ugc nofollow" target="_blank">https://www.themoviedb.org/settings/api</a></p><p id="c9a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成了。在页面底部，您将在API读取访问令牌(v4 auth)部分找到您的令牌。大概是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/ea984632fede507a1d083a2c96939e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NVLgRgNzPOJtytzvgtPGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TMDB访问令牌。</p></figure><h1 id="beb7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">项目</h1><p id="0305" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所以你可以继续阅读这篇文章，我创建了这个<a class="ae kv" href="https://github.com/victorcatao/RequestApp" rel="noopener ugc nofollow" target="_blank">示例项目</a>，它使用<a class="ae kv" href="https://www.hackingwithswift.com/example-code/language/what-is-mvc" rel="noopener ugc nofollow" target="_blank"> MVC </a>架构。您可以克隆存储库并打开。xcodeproject跟进。在该文件中，您将找到这三个文件夹，这三个文件夹是我们首先要处理的主要文件所在的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e47336dd4004ba5abdc3d30019cef27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*B-71Sxd-DN7QisoYkafGKA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目文件夹。</p></figure><ul class=""><li id="df95" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><code class="fe na nb nc nd b">Endpoint</code>:设置所有端点的协议。</li><li id="061e" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">HTTPClient</code>:本文最重要的文件之一。这是执行通用请求的方法所在的位置。</li><li id="6f81" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">HTTPMethod</code>:使用主HTTP方法执行请求的Enum。如果需要，可以添加其他的，如<em class="nj">头</em>、<em class="nj">迹</em>、<em class="nj">选项</em>等。</li><li id="c6b5" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">RequestError</code>:枚举有一些错误，我们会处理。如果您使用的API或您的应用程序有其他特殊情况，请将它们添加到此枚举中。</li><li id="57a5" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">MoviesEndpoint</code>:带有<a class="ae kv" href="https://developers.themoviedb.org/3/movies" rel="noopener ugc nofollow" target="_blank"> TMDB API电影</a>服务端点的Enum。对于每种情况，可以配置特定的端点，确定<code class="fe na nb nc nd b">path</code>、<code class="fe na nb nc nd b">method</code>、<code class="fe na nb nc nd b">header</code>和<code class="fe na nb nc nd b">body</code>变量。</li><li id="bfc2" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">MoviesService</code>:负责执行<a class="ae kv" href="https://developers.themoviedb.org/3/movies" rel="noopener ugc nofollow" target="_blank">电影服务请求</a>的结构。</li><li id="b95d" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">TopRated</code>:解码来自<a class="ae kv" href="https://developers.themoviedb.org/3/movies/get-top-rated-movies" rel="noopener ugc nofollow" target="_blank">最高额定端点</a>的响应的模型。</li><li id="7c1b" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">Movie</code>:对包含电影的响应进行解码的模型。</li><li id="6863" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">MainViewController</code>:项目唯一的<em class="nj">控制者</em>，负责发出请求并显示响应。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/253cb74cf2a3d844e009faa380b5d53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*NGSzcJe3-LDZGqQ9a4A9qg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例项目</p></figure><h1 id="c2ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">网路层</h1><p id="ff72" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在进入文章最酷的部分(<code class="fe na nb nc nd b">HTTPClient</code>)之前，我们需要浏览一下其他部分，这样你就能理解正在发生的一切。</p><p id="f092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b"><strong class="ky ir">Endpoint</strong></code>是一个<em class="nj">协议</em>，其中所有的端点需要符合告知它们所有的细节:<code class="fe na nb nc nd b">scheme</code>、<code class="fe na nb nc nd b">host</code>、<code class="fe na nb nc nd b">path</code>、<code class="fe na nb nc nd b">method</code>、<code class="fe na nb nc nd b">header</code>和<code class="fe na nb nc nd b">body</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">Endpoint</code>协议有一个默认的<code class="fe na nb nc nd b">scheme</code>和<code class="fe na nb nc nd b">host</code>实现，因为它通常只有一个用于所有端点。因此，没有必要一直实施它。如有必要，您可以重写此实现。</p><p id="6f80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">path</code>变量将作为<code class="fe na nb nc nd b">scheme</code>和<code class="fe na nb nc nd b">host</code>的补充，形成端点URL。它是这样工作的:<code class="fe na nb nc nd b">scheme</code> + <code class="fe na nb nc nd b">host</code> + <code class="fe na nb nc nd b">path</code>。例如:假设端点URL是<code class="fe na nb nc nd b">https://api.themoviedb.org/3/movie/top_rated</code>，那么<code class="fe na nb nc nd b">path</code>应该是<code class="fe na nb nc nd b">/3/movie/top_rated</code>。</p><p id="564f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当需要时,<code class="fe na nb nc nd b">header</code>变量应该返回一个<em class="nj">字典</em>,其中包含端点文档需要的所有头信息。这通常是通过<em class="nj">授权</em>执行认证的地方，您将在下面看到。</p><p id="f408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<code class="fe na nb nc nd b">header</code>变量一样，在必要时，<code class="fe na nb nc nd b">body</code>也是一个字典，必须包含端点文档请求发送的主体信息。</p><p id="9421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">method</code>变量的类型是<code class="fe na nb nc nd b">RequestMethod</code>，代表端点的HTTP方法，可以是:GET、POST、PUT、DELETE、PATCH、HEAD等。对于这个API，只包含了前五个方法，但是如果在您的上下文中有意义，您可以添加更多的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="faf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RequestError枚举包含一些可能的错误，<strong class="ky ir"> HTTPClient </strong>将识别并返回这些错误，以便应用程序可以处理这些错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个枚举有一个<code class="fe na nb nc nd b">customMessage</code>变量，例如，它可以用来向用户显示反馈消息或跟踪错误。</p><p id="3884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TopRated struct是一个<a class="ae kv" href="https://developer.apple.com/documentation/swift/codable/" rel="noopener ugc nofollow" target="_blank">可编码</a>模型，用于解码来自TMDB API的<a class="ae kv" href="https://developers.themoviedb.org/3/movies/get-top-rated-movies" rel="noopener ugc nofollow" target="_blank"> top_rated端点</a>的响应。请注意，它具有用于将Snake case条目(由API发送，名为<code class="fe na nb nc nd b">total_pages</code>)重命名为Camel case的<code class="fe na nb nc nd b">CodingKeys</code> enum，这是Swift中最常用的模式。</p><p id="e1f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">Movie</code>结构遵循同样的思想。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在你已经知道了理解<code class="fe na nb nc nd b">HTTPClient</code>的所有必要部分，你终于到了这篇文章最重要的部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">HTTPClient</code>是一个默认实现<code class="fe na nb nc nd b">sendRequest</code>功能的协议，负责向服务器发出请求。作为一个参数，它接收模型的<code class="fe na nb nc nd b">Endpoint</code>和<code class="fe na nb nc nd b">type</code>来解码API响应。</p><p id="16d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为返回，我们将有一个<code class="fe na nb nc nd b">Result</code>，它可以是成功的解码响应，也可以是RequestError中创建的一个错误。</p><p id="39c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，它伴随着关键字<code class="fe na nb nc nd b">async</code>，这表示它是一个异步函数，将在一个单独的线程上运行，并且可以在任何时候返回<code class="fe na nb nc nd b">Result</code>。</p><p id="a7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，<code class="fe na nb nc nd b">Endpoint</code>协议包含了使用它所需的所有信息。这是所有这些信息将被使用的地方。</p><p id="7d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法首先创建我们将与<a class="ae kv" href="https://developer.apple.com/documentation/foundation/urlcomponents" rel="noopener ugc nofollow" target="_blank"> URLComponents </a>一起使用的<code class="fe na nb nc nd b">URL</code>。这里我们将使用端点的<code class="fe na nb nc nd b">scheme</code>、<code class="fe na nb nc nd b">host</code>和<code class="fe na nb nc nd b">path</code>来配置<em class="nj"> urlComponents </em>对象。通过它，我们将得到用于创建<code class="fe na nb nc nd b">URLRequest</code>的<code class="fe na nb nc nd b">URL</code>，如果失败，将返回<code class="fe na nb nc nd b">.invalidURL</code>错误。</p><p id="0c73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们需要为端点消费创建一个<code class="fe na nb nc nd b">URLRequest</code>。但是等等，这个<code class="fe na nb nc nd b">URLRequest</code>是什么？<a class="ae kv" href="https://developer.apple.com/documentation/foundation/urlrequest" rel="noopener ugc nofollow" target="_blank">苹果文档</a>将帮助我们:</p><blockquote class="nn no np"><p id="7aeb" class="kw kx nj ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">封装了加载请求的两个基本属性:要加载的URL和用于加载它的策略。此外，对于HTTP和HTTPS请求，<code class="fe na nb nc nd b"><em class="iq">URLRequest</em></code>包括HTTP方法(<code class="fe na nb nc nd b"><em class="iq">GET</em></code>、<code class="fe na nb nc nd b"><em class="iq">POST</em></code>等)和HTTP头</p></blockquote><p id="ad6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，代码接下来要做的是从实例化的URL创建一个URLRequest。之后，<code class="fe na nb nc nd b">httpMethod</code>和<code class="fe na nb nc nd b">allHTTPHeaderFields</code>分别通过参数传递的端点的<code class="fe na nb nc nd b">method</code>和<code class="fe na nb nc nd b">header</code>变量进行配置。</p><p id="055a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">httpBody</code>也按照相同的逻辑进行配置，以防有任何数据要发送到端点。</p><p id="4340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你需要做的就是提出请求。我们很接近了！为此，我们将在刚刚创建的URLRequest中使用<code class="fe na nb nc nd b">URLSession.shared.data</code>。但是等一下，什么是URLSession？再一次，让我们转向<a class="ae kv" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>:</p><blockquote class="nn no np"><p id="f25b" class="kw kx nj ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">"<code class="fe na nb nc nd b"><a class="ae kv" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank"><em class="iq">URLSession</em></a></code>类和相关类提供了一个API，用于从URL指示的端点下载数据和向其上传数据。"</p></blockquote><p id="9b3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，这个类抽象了应用程序和API之间的所有通信。带有执行请求所需的所有信息的<code class="fe na nb nc nd b">URLSession</code>将返回API响应。</p><p id="d583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面一行中，创建了<code class="fe na nb nc nd b">URL.shared.data()</code>函数的返回元组。注意，使用<code class="fe na nb nc nd b">try</code>是必要的，因为在运行这个函数时可能会抛出异常(这就是为什么我们使用<code class="fe na nb nc nd b">do/catch</code>语句)。</p><p id="7796" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它还有<code class="fe na nb nc nd b">await</code>关键字，只有当<code class="fe na nb nc nd b">URL.shared.data()</code>函数完成并返回元组时，才会导致下一行被执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在这项工作差不多完成了。如果API返回任何响应，我们继续分析<code class="fe na nb nc nd b">statusCode</code>，如果没有，我们从<code class="fe na nb nc nd b">RequestError</code>返回错误<code class="fe na nb nc nd b">.noResponse</code>。</p><p id="9084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为API返回了一个响应，所以对<code class="fe na nb nc nd b">statusCode</code>的分析是在可能的<a class="ae kv" href="https://httpstatuses.com/" rel="noopener ugc nofollow" target="_blank"> HTTP状态</a>之上完成的。对于本文，筛选了一个理想的案例，其中[200，201，…，299]被认为是成功的，因此我们可以尝试解码响应，将接收到的JSON转换为可解码的模型，并最终返回到可以使用它的负责任的方法。</p><p id="eca5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还考虑了401 ( <a class="ae kv" href="https://httpstatuses.com/401" rel="noopener ugc nofollow" target="_blank">未授权</a>)案例，通常由过期会话引起，其中每个上下文都需要应用程序采取行动(例如，要求用户再次登录)。</p><h1 id="13ab" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用</h1><p id="e1be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然您已经了解了网络层的工作原理，那么就有必要了解如何使用它。跟着我，很简单！</p><p id="53ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe na nb nc nd b"><a class="ae kv" href="https://developers.themoviedb.org/3/movies" rel="noopener ugc nofollow" target="_blank">Movies</a></code>服务中的所有端点，我们将使用<code class="fe na nb nc nd b">MoviesEndpoint</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">MoviesEndpoint</code>是符合端点协议的enum。它拥有每个端点所需的所有信息。要添加一个新的<code class="fe na nb nc nd b"><a class="ae kv" href="https://developers.themoviedb.org/3/movies" rel="noopener ugc nofollow" target="_blank">Movies</a></code>服务端点，只需添加一个新的案例并填写每个变量中的信息:<code class="fe na nb nc nd b">path</code>、<code class="fe na nb nc nd b">method</code>、<code class="fe na nb nc nd b">header</code>和<code class="fe na nb nc nd b">body</code>。</p><p id="8572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们来谈谈<code class="fe na nb nc nd b">Service</code>，它是负责发出请求的结构体。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">MoviesService</code>是app用来发出请求的struct。请注意以下几点:</p><ul class=""><li id="3d1a" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">它符合<code class="fe na nb nc nd b">HTTPClient</code>协议，这意味着它内部有一个<code class="fe na nb nc nd b">sendRequest</code>函数来执行请求，因此不需要为每个请求重复代码。</li><li id="93cb" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated">它符合<code class="fe na nb nc nd b">MoviesServiceable</code>协议，这对于测试和依赖注入是至关重要的。你很快就会看到更多的细节。</li><li id="00e7" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated">函数声明有关键字<code class="fe na nb nc nd b">async</code>，遵循已经在<code class="fe na nb nc nd b">HTTPClient</code>中注释过的相同逻辑，表明它是一个异步函数。</li></ul><p id="be68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然你已经理解了<code class="fe na nb nc nd b">Service </code>结构是如何工作的，那么就看看它们在<code class="fe na nb nc nd b">MainViewController</code>中是如何使用的吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="27e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建的<code class="fe na nb nc nd b">MoviesService</code>将通过符合<code class="fe na nb nc nd b">MoviesServiceable</code>协议的对象的依赖注入来使用。<code class="fe na nb nc nd b">MainViewController</code>是这样实例化的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="958a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有其他方法可以完成这种依赖注入，例如，可以使用MVVM架构，并将一个包含服务的<code class="fe na nb nc nd b">ViewModel</code>注入到<code class="fe na nb nc nd b">ViewController</code>中。然而，为了简洁起见，我们将使用上面显示的方法。</p><p id="0208" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，剩下的就是使用注入的<code class="fe na nb nc nd b">Service</code>实际发出请求。由于我们正在使用一个<code class="fe na nb nc nd b">async</code>函数，我们需要创建一个<code class="fe na nb nc nd b">Task</code>来运行异步代码。参见<a class="ae kv" href="https://developer.apple.com/documentation/swift/task/3856791-init" rel="noopener ugc nofollow" target="_blank">苹果文档</a>了解此功能:</p><blockquote class="nn no np"><p id="dfc1" class="kw kx nj ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">"当创建代表调用它的同步函数操作的异步工作时，使用这个函数."</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d87e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当请求返回一个<code class="fe na nb nc nd b">Result&lt;Movie, RequestError&gt;</code>时<code class="fe na nb nc nd b">await</code>才会导致<code class="fe na nb nc nd b">switch</code>行被执行。返回后，可以让<code class="fe na nb nc nd b">switch</code>根据需要在每个上下文中管理它。</p><p id="0e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！现在，让我们看一下如何测试我们的网络层并使用模拟。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">吉菲。</p></figure><h1 id="75d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">试验</h1><p id="23ca" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在你只需要知道如何测试你的网络层和使用模拟。该项目有以下四个文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1055877087892fb90d93bf150d3046d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*bvN5wm5oFzVysfJpKA-gQw.png"/></div></figure><ul class=""><li id="503e" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><code class="fe na nb nc nd b">RequestAppTests</code>:负责执行app测试的类。</li><li id="cdde" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">Mockable</code>:将JSON文件转换为可编码文件的协议。</li><li id="8354" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">top_rated_response</code>:这是一个. json文件，带有来自<a class="ae kv" href="https://developers.themoviedb.org/3/movies/get-top-rated-movies" rel="noopener ugc nofollow" target="_blank">顶级TMDB API </a>的返回示例。</li><li id="de4f" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">movie_response</code>:这是一个. json文件，包含一部TMDB电影的<a class="ae kv" href="https://developers.themoviedb.org/3/movies/get-movie-details" rel="noopener ugc nofollow" target="_blank">细节API </a>的返回示例。</li></ul><p id="d5de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">Mockable</code>是一个避免样板文件的协议，默认实现了<code class="fe na nb nc nd b">loadJSON</code>函数，它读取一个内部。json文件并将其转换成给定的可编码模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="55f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没什么大不了的，对吧？现在看下面的代码来理解我们如何使用<code class="fe na nb nc nd b">Mockable</code>协议和<code class="fe na nb nc nd b">MoviesServiceable</code>来创建一个mock。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="88e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你还记得我们在app ( <code class="fe na nb nc nd b">MoviesService</code>)中使用的<code class="fe na nb nc nd b">Service</code>类也符合<code class="fe na nb nc nd b">MoviesServiceable</code>协议吗？你还记得当我们在<code class="fe na nb nc nd b">ViewController </code>上使用依赖注入时，我们注入了一个<code class="fe na nb nc nd b">MoviesServiceable </code>类型的实例，而不是一个<code class="fe na nb nc nd b">MoviesService</code>吗？这样，您可以注入另一个不同的实例，以便能够重用和测试您的<code class="fe na nb nc nd b">ViewController</code>。参见下面的模拟案例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a7ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe na nb nc nd b">loadTableView</code>函数负责发出请求和更新movies变量，因此<code class="fe na nb nc nd b">movies.count</code>必须等于my <code class="fe na nb nc nd b">top_rated_response.json</code>中的条目数，在本例中只有一个。此外，代码还测试该项目的标题是否与JSON文件中包含的标题相同。</p><p id="898f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以只测试您的模拟，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9f0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法来实现测试。例如，我们可以有一个带有<code class="fe na nb nc nd b">Service </code>的<code class="fe na nb nc nd b">ViewModel</code>来测试请求和<code class="fe na nb nc nd b">ViewModel </code>负责的各种功能，并单独用<code class="fe na nb nc nd b">ViewController</code>执行UI测试。</p><p id="80db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在模拟返回中使用其他JSONs，我们可以创建其他具有不同返回的<code class="fe na nb nc nd b">Mockables</code> &amp; <code class="fe na nb nc nd b">MoviesServiceable</code>类，或者使<code class="fe na nb nc nd b">MoviesServiceMock</code>类更加可重用，注入文件名、失败类型等。</p><p id="1821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以通过缓存实现、多部分、管理其他状态代码等使网络层更加健壮。此外，我们可以注入JSONDecoder和URLSession本身，使其更具可重用性和可测试性。本文基于一个简单的上下文，但是每个上下文都需要特定的实现和复杂性。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="3b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读，让我们继续编码吧！</p><pre class="kg kh ki kj gt oc nd od oe aw of bi"><span id="4049" class="og lt iq nd b gy oh oi l oj ok"><strong class="nd ir">Want to Connect?</strong></span><span id="2eb2" class="og lt iq nd b gy ol oi l oj ok">You can add me on <a class="ae kv" href="https://www.linkedin.com/in/victorcatao/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>