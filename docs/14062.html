<html>
<head>
<title>Implement Integration Tests in Jetpack Compose Android Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose Android应用程序中实现集成测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-integration-tests-in-jetpack-compose-android-apps-de4efd0cfa8d?source=collection_archive---------2-----------------------#2022-11-01">https://betterprogramming.pub/implement-integration-tests-in-jetpack-compose-android-apps-de4efd0cfa8d?source=collection_archive---------2-----------------------#2022-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0bd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Android测试深度指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e03a66aa6744ee4a331d78efde60d908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-g0dAXmyB-rnlv9a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@uxindo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">印尼UX</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的第一部分中，我们已经介绍了用单元测试测试业务逻辑。在本文中，我们将测试EasyTODO应用程序的各种特性，比如过滤器部分可见性切换、屏幕间导航、错误案例验证等。，使用集成测试。</p><p id="b6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集成测试位于单元测试之上。它们用于测试两个类或组件如何一起工作。这些类可以是任何东西，比如单击一个过滤器按钮在屏幕上显示过滤器部分。与单元测试不同，集成测试涉及android组件，因此我们需要一个物理设备或仿真器来执行它们。</p><p id="dc23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">涉及Android组件使得设置集成测试变得有点复杂，比如定制测试运行器、刀柄测试设置等。我们将在接下来的几节中一步一步地介绍所有这些内容:</p><ul class=""><li id="8417" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://sgkantamani.medium.com/testing-in-android-part-1-unit-tests-de6cbc118fe3" rel="noopener">Android第1部分中的测试:单元测试</a></li><li id="76a2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Android测试第2部分:集成测试— <strong class="lb iu">你在这里</strong></li></ul><h1 id="449a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">刀柄设置</h1><p id="2950" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">理论说够了。让我们从编写集成测试的依赖注入设置开始。</p><h2 id="9973" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">希尔特斯特鲁纳</h2><p id="05b8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当我们使用Hilt库进行依赖注入时，我们需要创建一个使用<code class="fe ns nt nu nv b">HiltTestApplication</code>而不是常规<code class="fe ns nt nu nv b">className</code>的自定义<code class="fe ns nt nu nv b">AndroidJUnitRunner</code>。</p><p id="04d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ns nt nu nv b">androidTest</code>内的根包下创建一个定制的Kotlin类<code class="fe ns nt nu nv b">HiltTestRunner</code>。用AndroidJUnitRunner扩展该类并覆盖<code class="fe ns nt nu nv b">newApplication</code>。在return语句中，用<code class="fe ns nt nu nv b">HiltTestApplication</code>类名替换<code class="fe ns nt nu nv b">className </code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="eee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要在<code class="fe ns nt nu nv b">defaultConfig</code>节点下的gradle文件中配置<code class="fe ns nt nu nv b">HiltTestRunner</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="273d" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">TestAppModule</h2><p id="5d93" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们已经配置了<code class="fe ns nt nu nv b">HiltTestRunner</code>，下一步是创建<code class="fe ns nt nu nv b">TestAppModule</code>，实际手柄的测试版本<code class="fe ns nt nu nv b">AppModule</code>，我们在其中配置像房间数据库、存储库、用例等依赖项。</p><p id="eaf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，我们为什么需要<code class="fe ns nt nu nv b">TestAppModule</code>？答案很简单，我们不希望测试中出现真正的数据库或实际的API调用。假设在<code class="fe ns nt nu nv b">TestAppModule</code>中，我们可以返回内存中的房间数据库，这样会更快。为了在测试中灵活地使用假的或轻量级的数据源，我们需要<code class="fe ns nt nu nv b">TestAppModule</code>。</p><blockquote class="ny nz oa"><p id="816b" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意:即使你使用真正的刀柄<code class="fe ns nt nu nv b"><em class="it">AppModule</em></code>没有任何错误，测试也会运行。</p></blockquote><p id="3e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们知道了为什么我们需要创建<code class="fe ns nt nu nv b">TestAppModule</code>，让我们从编码部分开始。除了房间内存数据库之外，在我们的例子中也是一样的。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="72e5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创建测试用例并声明规则</h1><p id="e5f8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">下一步是创建测试用例。让我们挑选过滤器部分的可见性变化。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8421692730032be80f176c2bf78c856e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TZjv0DOkKf7gxzy8K6I5mg.gif"/></div></figure><p id="af0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部发生的情况是，我们用事件<code class="fe ns nt nu nv b">TasksEvent.ToggleFilterSection</code>调用<code class="fe ns nt nu nv b">ToDoListViewmode</code>类中的<code class="fe ns nt nu nv b">onEvent</code>函数，我们将更新在<code class="fe ns nt nu nv b">TasksScreen</code> compose函数中观察到的状态，以切换过滤器部分的可见性。所以我们测试这两个类的交互。</p><p id="ade8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论说够了。让我们创建测试用例；这类似于我们在第1部分中创建单元测试的方式。首先，导航到该类，然后将光标放在类名上，并按下<code class="fe ns nt nu nv b">control + return</code> (macOS)。这将触发一个弹出窗口，允许我们选择测试选项。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/30031a06520e225182b1bfbf895eda07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgXpebunuN2uSa452OZTVg.png"/></div></div></figure><p id="8a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把您带到创建测试弹出窗口，在这里我们可以配置名称、路径、测试库等。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/6255b8801ce80504db1d5ef45b2c49ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwBBI1ssRTOhLnO42xVxVQ.png"/></div></div></figure><p id="ee94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果观察目的包，目的包无非就是将要创建测试用例的路径，Android Studio在Android测试包下创建测试用例，包结构和主包一样。完成后，点击“确定”按钮。</p><p id="a00c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要用<code class="fe ns nt nu nv b">HiltAndroidTest</code>和<code class="fe ns nt nu nv b">@UninstallModules(AppModule::class).</code>来注释这个类</p><ul class=""><li id="7a94" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">HiltAndroidTest</code>:用于标记需要注入的Android模拟器测试的注释。</li><li id="46ae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">UninstallModules(AppModule::class)</code>:基本上，<code class="fe ns nt nu nv b">AppModule</code>和<code class="fe ns nt nu nv b">TestAppModule</code>公开了相同的依赖关系，这会导致冲突，所以我们在这里告诉hilt不要使用<code class="fe ns nt nu nv b">AppModule</code>类。</li></ul><p id="faef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一看:</p><pre class="kj kk kl km gt oi nv oj ok aw ol bi"><span id="96cb" class="ng mk it nv b gy om on l oo op"><strong class="nv iu">@HiltAndroidTest<br/>@UninstallModules(AppModule::class)</strong><br/>class TasksScreenTest {</span><span id="fe9d" class="ng mk it nv b gy oq on l oo op">}</span></pre><h1 id="541e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创建规则</h1><p id="3912" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里我们需要两个规则:<code class="fe ns nt nu nv b">HiltAndroidRule</code>和<code class="fe ns nt nu nv b">createAndroidComposeRule</code>。</p><ul class=""><li id="75a1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Hilt的TestRule可以与JVM或仪器测试一起使用。此规则是必需的。没有这个测试规则，将不会创建<code class="fe ns nt nu nv b">Dagger </code>组件。</li><li id="1425" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ns nt nu nv b">createAndroidComposeRule</code>:为给定的activity类提供特定于android的<code class="fe ns nt nu nv b">createComposeRule</code>实现的工厂方法。<code class="fe ns nt nu nv b">createComposeRule</code>用于测试一个合成函数。</li></ul><p id="5c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要确保<code class="fe ns nt nu nv b">HiltAndroidRule</code>在<code class="fe ns nt nu nv b">createAndroidComposeRule</code>之前执行，因此我们需要指定执行顺序，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要编写设置函数，其中需要触发刀柄规则上的注入函数(完成匕首注入)。这应该在执行任何测试之前完成。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e13d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。我们已经完成了集成测试的手柄和合成设置。</p><h1 id="3364" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用组合规则探索节点标识</h1><p id="4a41" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在编写实际的测试用例之前，我们需要学习一个概念，就是获取屏幕上视图的引用，类似于<code class="fe ns nt nu nv b">findViewById</code>。</p><p id="e07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里包括两件事情:我们寻找视图的方式和我们用来寻找视图引用的度量标准。幸运的是，Compose UI test library提供了多种简单的方法来实现这一点。</p><p id="b2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于度量标准，我们可以基于显示的文本来查找视图，比如文本字段，或者我们可以使用<code class="fe ns nt nu nv b">contentDescription</code>来查找图标，或者我们可以添加一个<code class="fe ns nt nu nv b">testtag</code>来查找任何组合视图并在我们的测试中使用它。</p><p id="0c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于方法，compose out of the box提供了类似于<code class="fe ns nt nu nv b">onNodeWithTag</code>、<code class="fe ns nt nu nv b">onNodeWithContentDescription</code>和<code class="fe ns nt nu nv b">onNodeWithText</code>的功能来查找匹配标准的视图的单个引用。我们还可以找到具有功能<code class="fe ns nt nu nv b">onAllNodesWithTag</code>、<code class="fe ns nt nu nv b">onAllNodesWithContentDescription</code>和<code class="fe ns nt nu nv b">onAllNodesWithText</code>的多个视图。我们必须用<code class="fe ns nt nu nv b">composeRule</code>来使用上面的功能，看看:</p><pre class="kj kk kl km gt oi nv oj ok aw ol bi"><span id="03a9" class="ng mk it nv b gy om on l oo op">composeRule.onNodeWithTag(TestTags.FILTER_BUTTON).assertExists()<br/>composeRule.onNodeWithText("Filter").assertExists()<br/>composeRule.onNodeWithContentDescription("Filter").assertExists()</span></pre><p id="af60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一系列文章中，我使用了Google真理库中的assert语句。我们已经在本系列的第1部分中导入了这个库。</p><p id="bac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速注意，添加<code class="fe ns nt nu nv b">TestTags</code> Kotlin对象类，在<code class="fe ns nt nu nv b">main</code>目录下的以下包结构中声明所有测试标签常量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/9154b377e0bf2e3a942a646767d5b27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hJUsJ5kYDJfOkWuOgwiPw.png"/></div></div></figure><h1 id="2f7b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">首次集成测试</h1><p id="95ef" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">先说命名。这不是强制性的，但是我更喜欢使用动作和结果作为函数名的一部分，用<code class="fe ns nt nu nv b">_</code>分开。看一看:</p><pre class="kj kk kl km gt oi nv oj ok aw ol bi"><span id="241f" class="ng mk it nv b gy om on l oo op">@Test<br/>fun clickToggleFilterSection_isVisible(){<br/>}</span></pre><p id="d230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用四个函数来完成测试用例:</p><ol class=""><li id="1535" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu os mb mc md bi translated">用于确保视图不在视图层次结构中，这是Google真理库的一部分。</li><li id="a2ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu os mb mc md bi translated"><code class="fe ns nt nu nv b">performClick</code>:用于执行点击各个视图，组成UI测试库的一部分。</li><li id="a291" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu os mb mc md bi translated"><code class="fe ns nt nu nv b">assertExists</code>:用于确保视图已经存在于视图层次结构中，是Google真理库的一部分。</li><li id="fbf6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu os mb mc md bi translated"><code class="fe ns nt nu nv b">assertIsDisplayed</code>:用于确保各个视图对用户可见，构成UI测试库的一部分。</li></ol><p id="1de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，看一下测试用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="091e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行测试用例，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/dfdd9ae859e58d06b5d39deb13f87eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Y0FP_DJT-eBrzn5MRHfqDQ.gif"/></div></figure><blockquote class="ny nz oa"><p id="c775" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注:添加了<code class="fe ns nt nu nv b"><em class="it">Thread.sleep</em></code>以便清楚地看到测试执行，除非需要，否则请不要实时添加。</p></blockquote><h1 id="0cc8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">两个屏幕之间的集成测试</h1><p id="b1ed" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在我们已经编写了第一个集成测试，下一步是编写两个屏幕之间导航的集成测试。编写这样的集成测试将为您有效地编写端到端测试用例做好准备。大多数端到端测试用例只不过是几个集成测试的组合。</p><p id="a967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到测试用例，我们将测试从任务列表屏幕添加任务屏幕的导航。我们将通过单击plus fab按钮并验证用户是否在add tasks屏幕上来完成此操作。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们运行测试用例。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ef98092bbd1262821f543b1e3b2c40ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hfx08CZQGSe5UCOXtCnqsA.gif"/></div></figure><h1 id="e63d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">检查错误情况的集成测试</h1><p id="8be1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们以一个集成测试来结束这篇文章。这一个与异常处理有关。我们将考虑为此创建一个任务特性。如果您看到添加任务用例，如果用户试图添加一个没有有效标题的任务，它将抛出一个异常。看一下使用案例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/324baa19ef95c08fac2e71163b23cc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wk356vgEprqAbTrU73dcQ.png"/></div></div></figure><p id="7ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写这个测试用例包括三个步骤:</p><ol class=""><li id="9ec9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu os mb mc md bi translated">首先，我们将通过单击fab按钮导航到add task屏幕。</li><li id="0ae8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu os mb mc md bi translated">然后，我们将在没有有效标题的情况下单击“保存”按钮。</li><li id="3325" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu os mb mc md bi translated">最后，我们将验证是否向用户显示了带有异常消息的<code class="fe ns nt nu nv b">snackbar</code>。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们运行用例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/918416846027294e823218e781a8a168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Zl8qx9dj2aZDinurDdl7Ug.gif"/></div></figure><p id="6aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的开源项目中找到更多的集成测试。请随意克隆项目并进行试验。请确保您在分支机构<code class="fe ns nt nu nv b">feature/integration_tests</code>上。</p><h1 id="fb10" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">下一步是什么？</h1><p id="0b66" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">既然我们已经完成了集成测试，下一步就是使用端到端测试来测试诸如添加任务、删除任务等特性。敬请关注更多内容。</p></div></div>    
</body>
</html>