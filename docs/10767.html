<html>
<head>
<title>Dynamically Change Backend Environment in Android at Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在运行时动态改变Android的后端环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamically-change-backend-environment-in-android-at-runtime-d3af9ec7391f?source=collection_archive---------12-----------------------#2022-01-26">https://betterprogramming.pub/dynamically-change-backend-environment-in-android-at-runtime-d3af9ec7391f?source=collection_archive---------12-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4178" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过同时使用所有环境来加速您的Android应用程序开发</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f07b05d66b03c04c683e6d7ee316fd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rxt3ZKVnntlEFLoVkPTWnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">后端的环境示例</p></figure><p id="f621" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在处理大规模应用程序时，将服务上的环境分开总是很重要的。这有助于我们防止任何会影响最终用户正在使用的服务的不必要的问题。</p><p id="ebd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Android应用程序的上下文中，开发人员通常使用<code class="fe lr ls lt lu b">build variant</code>或<code class="fe lr ls lt lu b">build flavor</code>根据他们的后端环境来分离应用程序。</p><p id="06bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将学习如何在不使用<code class="fe lr ls lt lu b">build variant</code>或<code class="fe lr ls lt lu b">build flavor</code>的情况下，在运行时动态改变后端的环境。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="9b0d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">图书馆</h1><p id="bd9b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">在继续之前，我们将使用以下库:</p><ul class=""><li id="29d7" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><a class="ae ni" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Okhttp </strong> </a>，Android应用的http客户端</li><li id="c838" class="mz na iq kx b ky nj lb nk le nl li nm lm nn lq ne nf ng nh bi translated"><a class="ae ni" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Koin </strong> </a>，Android应用依赖注入工具</li></ul><p id="e443" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，请在继续之前配置您的Android应用程序来使用这两个库。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="4010" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">环境</h1><p id="d934" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">我们将用来改变Android应用环境的关键词是<code class="fe lr ls lt lu b">interceptor</code>。但实际上是什么呢？</p><blockquote class="no"><p id="0c1e" class="np nq iq bd nr ns nt nu nv nw nx lq dk translated">拦截器是一种强大的机制，可以监控、重写和重试调用</p></blockquote><p id="112f" class="pw-post-body-paragraph kv kw iq kx b ky ny jr la lb nz ju ld le oa lg lh li ob lk ll lm oc lo lp lq ij bi translated">基本上，通过使用<code class="fe lr ls lt lu b">interceptor</code>，我们将使用我们将要定义的环境来改变所有的API调用。</p><p id="5c8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们将有三个环境，即<strong class="kx ir">开发</strong>、<strong class="kx ir">试运行</strong>和<strong class="kx ir">生产</strong>。</p><p id="2d21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将在Kotlin的注释类中定义所有这三个环境，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">环境的注释类</p></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="78c2" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">创建拦截器</h1><p id="52b8" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">在定义了我们将要使用的环境之后，是时候创建<code class="fe lr ls lt lu b">interceptor</code>来根据应用程序运行时所选择的环境改变基本URL了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">改变环境的拦截器</p></figure><p id="1f8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个新类中，我们继承了<code class="fe lr ls lt lu b">interceptor</code>并覆盖了它的'<code class="fe lr ls lt lu b">intercept</code>方法。</p><p id="aa6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还定义了一个名为<code class="fe lr ls lt lu b">env</code>的变量，它将定义在调用API时我们将使用哪个环境。以及用于每个环境另外三个基本URL。</p><p id="2c47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe lr ls lt lu b">intercept</code>方法中，我们定义了一个基于所选环境的变量，我们将通过用之前定义的基本URL更改主机来返回一个新的请求。</p><p id="9f80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还将定义另一个名为<code class="fe lr ls lt lu b">setEnvironment</code>的方法，它将提示用户选择下一次API调用使用的环境。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="f7c5" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">注射</h1><p id="c45e" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">我们将使用Koin注入<code class="fe lr ls lt lu b">EnvironmentInteceptor</code>,以确保当应用程序运行时，我们的应用程序中只有一个该类的实例。像这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Koin模块</p></figure><p id="925c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将<code class="fe lr ls lt lu b">yourModule</code>添加到Koin定义中的<code class="fe lr ls lt lu b">Application</code>类</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="870d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">履行</h1><p id="b78b" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">最后，我们将使用之前在<code class="fe lr ls lt lu b">EnvironmentInterceptor</code>中定义的对话框提示用户定义我们将使用的环境。</p><p id="3ec9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在应用程序中第一次调用API之前调用您的<code class="fe lr ls lt lu b">setEnvironment</code>。下面是一个在<code class="fe lr ls lt lu b">SplashScreenActivity</code>中这样做的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="dbee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="of">嗖…！！就像那个</em>一样，你可以改变后端的环境，而不需要构建单独的apk。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="ae87" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">提高安全性</h1><p id="5e31" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">改变环境只在开发阶段需要<strong class="kx ir"> </strong>，这不能发布到最终用户将使用的应用程序版本。</p><p id="d8c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何无缝地分离它们？我们将区分每个<code class="fe lr ls lt lu b">build variant</code>的<code class="fe lr ls lt lu b">EnvironmentInterceptor</code>。默认情况下，Android项目有2个<code class="fe lr ls lt lu b">build variant</code>，即:</p><ul class=""><li id="1e6a" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">调试我们在开发过程中使用的应用程序的变体</li><li id="ebe3" class="mz na iq kx b ky nj lb nk le nl li nm lm nn lq ne nf ng nh bi translated"><strong class="kx ir">发布</strong>我们将向最终用户发布的应用程序的变体</li></ul><p id="364d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们将在不同的目录中创建两个类。假设<code class="fe lr ls lt lu b">EnvironmentInterceptor</code>位于数据包中。那么我们将把它存放在:</p><pre class="kg kh ki kj gt og lu oh oi aw oj bi"><span id="1e8e" class="ok md iq lu b gy ol om l on oo">app\src\<strong class="lu ir">debug</strong>\java\&lt;PACKAGE_NAME&gt;\data\EnvironmentInterceptor.kt</span><span id="d341" class="ok md iq lu b gy op om l on oo">app\src\<strong class="lu ir">release</strong>\java\&lt;PACKAGE_NAME&gt;\data\EnvironmentInterceptor.kt</span></pre><p id="943c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将我们之前创建的<code class="fe lr ls lt lu b">EnvironmentInterceptor</code>移动到<code class="fe lr ls lt lu b">debug</code>目录中。而对于<code class="fe lr ls lt lu b">release</code> <strong class="kx ir"> </strong>目录，这样定义<code class="fe lr ls lt lu b">EnvironmentInterceptor</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">版本变体的环境拦截器</p></figure><p id="f5f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将使我们的应用程序的发布版本不会向用户提示对话框，并将使用已经在应用程序中定义的嵌入式环境。</p></div></div>    
</body>
</html>