<html>
<head>
<title>When Should We Use Static Local Variables in C++?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中什么时候应该使用静态局部变量？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-should-we-use-static-local-variables-in-c-3c08570581e6?source=collection_archive---------4-----------------------#2022-01-13">https://betterprogramming.pub/when-should-we-use-static-local-variables-in-c-3c08570581e6?source=collection_archive---------4-----------------------#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9da9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解当我们使用静态局部变量时实际会发生什么，以及何时应该使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eecb97c2e60884cda7f118192f0c6051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSWWRDBREODA22mP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@udayawal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乌代·阿瓦尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="4870" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++存储持续时间</h1><p id="4dd8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">学习C++时，我们经常忽略的一个基础知识是理解存储持续时间的细节。对象的存储持续时间决定了它的生存期。它还决定了对象将存储在内存的哪个部分，是在堆栈、堆还是数据上。C++中有四种不同的存储持续时间。需要注意的一点是，存储持续时间与作用域不同。</p><h2 id="8b4e" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">自动的</h2><p id="7884" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是在块<code class="fe mz na nb nc b">{}</code>内创建的对象的存储持续时间。它只住在那个街区。具有此存储持续时间的对象存储在堆栈中。对象的生存期只在块内得到保证。</p><p id="cc3d" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">它适用于没有<code class="fe mz na nb nc b">static</code>、<code class="fe mz na nb nc b">thread_local</code>或<code class="fe mz na nb nc b">extern</code>关键字的局部变量。当我们将这些关键字中的一个添加到局部变量中时，或者当我们动态分配内存时，存储持续时间会发生变化。</p><h2 id="a834" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">静态</h2><p id="e6a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">具有静态存储持续时间的对象从程序启动到退出都是活动的。它们存储在内存的数据段中，这就是为什么只要程序运行，它们就存在。</p><p id="57f4" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">它适用于全局变量、静态成员变量和静态局部变量。需要注意的一点是，只有<em class="ni">个对象实例</em>具有这个存储持续时间。</p><p id="3bbb" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">它们通常在调用<code class="fe mz na nb nc b">main()</code>之前被初始化，但是对于静态局部变量，如果用非零或非常量初始化，它们可能在<em class="ni">函数第一次被调用</em>时被初始化。</p><h2 id="2182" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">动态的</h2><p id="064d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个存储持续时间是针对我们使用<code class="fe mz na nb nc b">new</code>操作符或<code class="fe mz na nb nc b">std::malloc</code>动态创建的对象的。我们手动控制它们的生存期，它们存储在内存的堆段中。</p><p id="b995" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如上所述，当对象被定义在一个块中时，它的范围可以是局部的，但是如果我们动态地创建它，它的存储持续时间可以是动态的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e655" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">在这个例子中，名为<code class="fe mz na nb nc b">a</code>的变量的范围在<code class="fe mz na nb nc b">create_a()</code>内，但是存储持续时间是动态的，在退出<code class="fe mz na nb nc b">create_a()</code>后它仍然是活动的。</p><h2 id="4ca9" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">线</h2><p id="3d7d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">具有线程存储持续时间的对象在线程开始时开始，直到线程结束。每个线程都有自己的对象实例。</p><h2 id="43e3" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">我们想讨论的是</h2><p id="4c11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们在本文中的重点是，我们想看看当我们使用静态局部变量时，实际上会发生什么。<code class="fe mz na nb nc b">static</code>关键字也用于指定链接类型(无链接、内部链接或外部链接)，但这不是我们这里的重点。</p><h1 id="b71f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">静态意味着只有一个实例</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/178869fe33c211ae5b76d053246b9db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*0lL2yCWFkcm8lp3u_J0Nfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">静态局部变量(图片由作者提供)</p></figure><p id="8667" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">正如上面关于存储持续时间的部分所解释的，<code class="fe mz na nb nc b">static</code>意味着只有一个实例。仔细想想，这是有意义的，因为具有静态存储持续时间的对象会一直存在，直到程序退出。因此，在成员函数中使用静态局部变量时，我们必须小心。我们来看一个例子，这个例子可能不是很有趣，但是足以很好的展现概念。</p><p id="d8cf" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">假设我们想写一个继承自<code class="fe mz na nb nc b">MultiplierBase</code>的类<code class="fe mz na nb nc b">Multiplier</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="db4e" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">它接受一个参数来设置基类存储的<code class="fe mz na nb nc b">multiplier</code>(成员变量)。调用<code class="fe mz na nb nc b">Multiply()</code>函数时，通过调用<code class="fe mz na nb nc b">GetMultiplier()</code>得到乘数。由于我们认为乘数永远不会改变，所以我们希望使它成为<code class="fe mz na nb nc b">static</code>和<code class="fe mz na nb nc b">const</code>，我们将它存储在一个局部变量中。</p><p id="268a" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">但是，问题是当我们有多个<code class="fe mz na nb nc b">Multiplier</code>实例时，我们只有一个<code class="fe mz na nb nc b">multiplier</code>(局部变量)实例。因此，当客户端代码执行以下操作时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9e96" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">它打印:</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="a5bf" class="mn la it nc b gy nq nr l ns nt">4<br/>4</span></pre><p id="89c8" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我们希望它打印的是:</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="ecbe" class="mn la it nc b gy nq nr l ns nt">4<br/>6</span></pre><p id="4af5" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">发生这种情况是因为我们只有一个<code class="fe mz na nb nc b">multiplier</code>(局部变量)的实例，并且它只在第一次调用函数时初始化一次，在第<code class="fe mz na nb nc b">5</code>行。</p><h1 id="6bd4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">它被初始化一次</h1><p id="1b13" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了确保静态局部变量只被初始化一次，我们的代码实际上发生了什么？编译器通过添加一个保护变量来修改我们的函数。我们的功能如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a13f" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">由编译器转换为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5a38" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我们可以看到我们的代码越来越长，编译器插入额外的代码，以确保我们的静态变量只初始化一次。</p><p id="e458" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">上面的代码仅用于说明，编译器生成的确切代码是特定于实现的。编译器可以实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Double-checked_locking" rel="noopener ugc nofollow" target="_blank">双重检查锁定</a>模式的变体。</p><h2 id="1096" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">Const局部静态是线程安全的</h2><p id="d9a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从上面的代码中可以看出，编译器使用了一个保护变量来进行同步。这是为了确保即使在多线程环境中，我们的静态局部变量也只初始化一次。因此，如果我们的静态局部变量是const限定的，它就是线程安全的。</p><h1 id="8424" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么时候应该使用静态局部变量？</h1><p id="1a91" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">众所周知，有许多方法可以编写工作代码，在我们希望对象在整个运行时都存在的情况下，我们有许多选择，比如让它成为静态成员变量、全局变量或静态局部变量。</p><p id="7493" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">当我们希望在局部范围内只有一个对象实例时，静态局部变量是有用的，这意味着对函数的所有调用将共享同一个对象。</p><p id="9d98" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">使用全局变量或静态成员变量也可以达到同样的效果。但是我们应该问问自己，对象是否只在函数内部使用。</p><p id="99a9" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">例如，我们有一个名为<code class="fe mz na nb nc b">AreaCalculator</code>的类，它应该提供计算各种形状的函数，如正方形、矩形、圆形等。像圆周率等常数。，由免费函数提供。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8a36" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">在这种情况下，我们可以选择让<code class="fe mz na nb nc b">pi</code>成为一个成员变量，它也可以成为<code class="fe mz na nb nc b">static</code>。但是，由于它只被<code class="fe mz na nb nc b">Circle()</code>函数使用，我认为最好把它作为一个静态局部变量。</p><h1 id="98f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="96a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">静态局部变量具有以下属性:</p><ul class=""><li id="6974" class="nu nv it lt b lu nd lx ne ma nw me nx mi ny mm nz oa ob oc bi translated">局部范围，它们只在声明它们的块中可见</li><li id="6e82" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">静态存储持续时间，它们持续到程序退出，并且只有一个实例</li><li id="1c81" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">没有连接，从模块外部看不到，因此没有内部/外部连接</li><li id="2bac" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">可能是惰性求值，它们被初始化一次，如果初始化为非零和非常数，则在第一次调用函数时被初始化</li></ul><p id="68be" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">编译器将额外的代码插入到带有静态局部变量的函数中，以确保即使在多线程环境中它们也只被初始化一次。</p><p id="ad62" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果语义上我们的对象只在那个函数中需要，并且在那个函数的所有调用中共享，我们应该选择使用它。</p></div></div>    
</body>
</html>