<html>
<head>
<title>Simple Serverless: Neat and Tidy Lambda Functions Use Powertools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的无服务器:整洁的Lambda函数使用Powertools</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-serverless-neat-and-tidy-lambda-functions-use-powertools-935f90574f80?source=collection_archive---------4-----------------------#2020-11-13">https://betterprogramming.pub/simple-serverless-neat-and-tidy-lambda-functions-use-powertools-935f90574f80?source=collection_archive---------4-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少开始编写Lambda函数的挫败感和时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62e40c496645b32393b392e355f9a377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3NFDuBiYgWhHcwK0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托弗·伯恩斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="96e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写的每一个Lambda函数都是以同样的方式开始的:一堆解包事件然后验证其内容的代码。听起来熟悉吗？</p><p id="9980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我永远记不住某些事件有效负载的确切键名。我如何再次从一个<code class="fe lv lw lx ly b">ApiGateway</code>事件中获取标题？是<code class="fe lv lw lx ly b">headers</code>还是<code class="fe lv lw lx ly b">Headers</code>？</p><p id="6c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦对了，是<code class="fe lv lw lx ly b">headers</code> <em class="lz">和</em> <strong class="lb iu"> <em class="lz"> </em> </strong> <code class="fe lv lw lx ly b">multiValueHeaders</code>。当然是了。</p><p id="0642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我创建的每个新Lambda函数都以与我创建的其他Lambda函数非常相似的方式开始:</p><ul class=""><li id="e9f3" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">谷歌事件有效载荷结构。</li><li id="4808" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">解包内容并调用<code class="fe lv lw lx ly b">json.loads</code>将字符串转换成字典。</li><li id="7e6d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">验证内容。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2c2f" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">我的第一个想法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/7de1df3304084c3bd55a9fe7dad5b4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68_aZchIyBRGbeIkKVqGlA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="f1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在编写和重写这类代码时越是沮丧，就越有动力去寻找更好的方法。所以我求助于编写助手库。下面是一个<code class="fe lv lw lx ly b">ApiRequest</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我可以把我的晦涩的<code class="fe lv lw lx ly b">event</code>变成一个Python对象。</p><p id="610c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，因为现在我不需要记住所有这些事件属性的键名。还有，我的IDE会在我输入<code class="fe lv lw lx ly b">parsed_event</code>的时候提示他们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3e37d1307e2645d5d5ef20c40d71aea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*VSMj3MHqMPsxBW75zkg--w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IDE提示在起作用</p></figure><p id="2a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了。为了前面的一点努力，我现在节省了大量的时间来设置我的Lambda函数。但这还不够。我仍然需要验证事件内容。那么其他事件源呢？</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="557c" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">AWS Lambda Powertools简介</h1><p id="e42f" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">最初基于<a class="ae ky" href="https://github.com/getndazn/dazn-lambda-powertools" rel="noopener ugc nofollow" target="_blank">DAZN Powertools</a>,<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank">AWS fork</a>专注于为Lambda函数提供干净、轻量级的实用程序。以下是这个项目的一些原则:</p><blockquote class="nw nx ny"><p id="a415" class="kz la lz lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">“简化最佳实践的采用—实用程序的主要优先事项是促进最佳实践的采用，正如AWS良好架构的无服务器透镜中所定义的那样；所有其他功能都是可选的。</p><p id="54a8" class="kz la lz lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">保持精简—出于安全性和易维护性的考虑，仔细考虑了额外的依赖性，并防止对启动时间产生负面影响。</p><p id="4526" class="kz la lz lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">我们从社区开始反向工作——我们的目标是找到对80%的客户最有效的平衡。通过征求意见(RFC)来考虑和讨论新出现的实践</p><p id="bde6" class="kz la lz lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">习惯用法—实用程序遵循编程语言习惯用法和特定于语言的最佳实践。"</p></blockquote><p id="bce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在使用<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python" rel="noopener ugc nofollow" target="_blank"> AWS Lambda Powertools </a>的<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/core/logger/" rel="noopener ugc nofollow" target="_blank">日志</a>和<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/core/tracer/" rel="noopener ugc nofollow" target="_blank">跟踪</a>功能(顺便说一下，这真的很有用)。因此，当他们宣布围绕<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/utilities/data_classes/" rel="noopener ugc nofollow" target="_blank">事件源数据类</a>增加功能时，我既好奇又兴奋。</p><h2 id="9822" class="oc mw it bd mx od oe dn nb of og dp nf li oh oi nh lm oj ok nj lq ol om nl on bi translated">事件源数据类</h2><p id="f06f" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">简而言之，事件源数据类提供了与我上面的助手库相同的功能。但是我看到了转换的一些明显的好处:</p><ul class=""><li id="2ecc" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">由一个团队维护——不仅仅是我！</li><li id="fcc0" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">涵盖11种不同的事件源类型(包括Kinesis，SQS等。).</li><li id="2621" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank"> Powertools </a>团队更接近AWS生态系统，比我更不容易“错过”变化。</li></ul><p id="1f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这些数据类很简单。此示例实现了与上面我自己的代码相同的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cc64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太简单了——我的IDE仍然能够完成在我之前的例子中可以完成的所有重要工作。</p><p id="8c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是……仍然没有验证。而且在使用这个数据类的时候，我还是要在请求体上做一个<code class="fe lv lw lx ly b">json.loads</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="46b5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">电动工具来救援！</h1><p id="2aa0" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">我们可以构建自己的数据类模型，并使用<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank"> Powertools </a>中的另一个可用功能来验证和解析请求:<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/utilities/parser/" rel="noopener ugc nofollow" target="_blank"> Parser </a>。</p><p id="fe1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了继续上面的例子，我们将解析API请求体。到目前为止，我们可以通过<code class="fe lv lw lx ly b">parsed_event.body</code>访问它，但是它仍然是一个未知内容的字符串化对象。</p><p id="5032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将通过构建一个模型来定义一个正确形成的请求体应该是什么样子。假设我们正在等待一个请求，告诉我们一个学生的名字、姓氏、最喜欢的颜色，以及他们正在参加或已经参加的考试的列表。我们可以这样定义模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们使用类型注释来指示每个字段的类型。我们还引用了一个子模型(学生考试)。</p><p id="bf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我想指出的是<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank"> Powertools </a>使用的这个建模模式实际上是建立在<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>之上的。Pydantic是一个非常强大的数据验证库，它提供了比我们在这里演示的更多的功能。</p><h2 id="0939" class="oc mw it bd mx od oe dn nb of og dp nf li oh oi nh lm oj ok nj lq ol om nl on bi translated">从语法上分析</h2><p id="a7fe" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">现在我们已经定义了请求体应该是什么样子，让我们来解析它。为此，我们将使用<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank">电动工具</a>中的<code class="fe lv lw lx ly b">parse</code>功能。该函数接受两个输入——您希望解析的数据和解析的模型(第14行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="33bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这样的好处是什么呢？因为<code class="fe lv lw lx ly b">BaseModel</code>和<code class="fe lv lw lx ly b">parse</code>是建立在<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>之上的，我们现在可以从它提供的所有好的验证中受益，包括:</p><ul class=""><li id="0563" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">必填字段</li><li id="deb1" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">字段类型</li></ul><p id="1b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们不需要编写更多的验证代码。</p><p id="7c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个很大的好处是，我们的IDE现在也可以代表我们做更多的工作。我们现在在我们的<code class="fe lv lw lx ly b">parsed_body</code>上得到属性名称提示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3e57fdfc68f61f317cd1ab61f3f67279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*udDkJBEuB5-H7cpUQ2btsQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IDE暗示！</p></figure><h2 id="3a42" class="oc mw it bd mx od oe dn nb of og dp nf li oh oi nh lm oj ok nj lq ol om nl on bi translated">更多数据…</h2><p id="4617" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">让我们继续我们的例子。假设我们的Lambda函数负责从另一个源添加学生最喜欢的颜色。注意，在我们上面的模型定义中，我们声明了<code class="fe lv lw lx ly b">favourite_colour: Optional[str]</code>,这样<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>知道这个字段在加载时允许为空。但是一旦我们有了这个属性的值，我们就可以给它赋值了。下面是我们设置该值的方式:</p><pre class="kj kk kl km gt oo ly op oq aw or bi"><span id="55b0" class="oc mw it ly b gy os ot l ou ov">parsed_body.favourite_colour = "red"</span></pre><p id="c2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以配置我们的模型，以决定当使用<code class="fe lv lw lx ly b">validate_assignment</code>配置设置参数时，它是否应该主动验证参数。在<a class="ae ky" href="https://pydantic-docs.helpmanual.io/usage/model_config/" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多相关内容。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="87b5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">完整的圆</h1><p id="f2ad" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">最后，让我们把这个事件兜一圈。我们希望能够将填充的模型转换回dict对象，并将其包含在API响应中。</p><p id="534f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们不能只返回我们的模型实例。API网关不会喜欢这样。但是<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank">镇静剂</a>再次帮了我们一把。我们的模型从<code class="fe lv lw lx ly b">BaseModel</code>继承了一个叫做<code class="fe lv lw lx ly b">.dict()</code>的方法。我们可以调用这个方法将我们的模型实例作为dict对象返回(第25行)。这是我们完成的Lambda的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这段代码看起来很干净。代码易读、简洁。重要的是，不管事件源是什么，它在我们编写的任何其他Lambda函数中看起来都非常相似。因此函数之间的上下文切换要容易得多。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="a893" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">接下来去哪里？</h1><p id="2111" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">这仅仅是使用<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda Powertools </a>和<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>的可能性的开始。我建议查看以下功能，以帮助补充我们在这篇文章中学到的内容:</p><ul class=""><li id="f587" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">【Pydantic的PyCharm插件</li><li id="e987" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><a class="ae ky" href="https://pydantic-docs.helpmanual.io/usage/schema/#field-customisation" rel="noopener ugc nofollow" target="_blank">现场定制</a></li><li id="1a0f" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><a class="ae ky" href="https://pydantic-docs.helpmanual.io/usage/models/#model-properties" rel="noopener ugc nofollow" target="_blank">模型属性</a></li></ul><p id="a37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要就此打住。这个工具有很多可能性。继续你的研究是很值得的。</p><p id="36e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你和我一样觉得电动工具有用。</p></div></div>    
</body>
</html>