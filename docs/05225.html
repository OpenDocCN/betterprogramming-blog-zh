<html>
<head>
<title>How Does the Browser Render a Webpage?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器如何渲染网页？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-the-browser-render-a-webpage-75cdb53ba49d?source=collection_archive---------7-----------------------#2020-06-22">https://betterprogramming.pub/how-does-the-browser-render-a-webpage-75cdb53ba49d?source=collection_archive---------7-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dfbd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解浏览器的内部工作方式以及它们一直在做的事情:DOM、CSSOMs、渲染树、布局和绘画</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3938b78a53d1057e0fd38d8494921a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcDPYR5IeZOkdSxt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@hansonluu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hanson Lu </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我从2018年开始专业做网站，贡献了很多基于网络的应用。问题是，我在一个非常小的范围内工作，在这个范围内，事情没有我现在工作的范围那么重要。</p><p id="a8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的拉动式请求在工作中经历了许多变化，这让我感到沮丧。有一天，我决定解决浏览器如何呈现HTML页面的秘密，并使用它来编写更好的CSS、HTML和JS。</p><p id="35cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在网上创造流畅的体验，你需要了解浏览器是如何工作的。要呈现页面，当您访问网站时，浏览器需要遵循许多步骤:</p><ol class=""><li id="bb08" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">查阅你的资源。</li><li id="7d20" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在服务器和客户端之间创建连接。</li><li id="e49f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">增量下载资源。</li><li id="6e54" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">解析HTML。</li><li id="e9a4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">解析CSS。</li><li id="42dc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建DOM。</li><li id="466c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建CSSOM。</li><li id="a8ca" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">从DOM和CSSOM创建渲染树。</li><li id="ce99" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">开始页面布局，然后绘画。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/60dd46a79f4f67e9ecdb2863e91d0439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Imspi9H9gdXg92ofdR7wQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" rel="noopener ugc nofollow" target="_blank">https://www . html 5 rocks . com/en/tutorials/internals/howsbrowserswork/</a></p></figure><p id="f0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从第3点开始深入理解浏览器是如何工作的。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="7f1a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">下载资源</h1><p id="dcbc" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">当在服务器和客户机之间建立TCP连接时，数据以小块的方式递增发送。为了理解这一点，让我们举个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设这是你要做的app。您有一个类似于这样的<code class="fe nn no np nq b">style.css</code>样式表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能希望这在纳秒内呈现，但是如果您了解浏览器的内部工作方式，您就会理解这些问题——并且您可能是提出解决这些问题的解决方案的人。</p><p id="963f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几件事要记住:</p><ol class=""><li id="4134" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">HTML是增量呈现的。最好将HTML响应流式传输到客户端，而不是等待整个页面准备就绪。(spa就不是这样了。)</li><li id="c53c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">CSS是渲染阻塞的。尽快把CSS放到浏览器里。</li></ol></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="141e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们开始接收HTML时，我们开始解析它。这看起来很简单，但是它有很多复杂性。假设它遇到下面这条线:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="b072" class="nv mp iq nq b gy nw nx l ny nz">&lt;link rel="stylesheet" href="style.css"&gt;</span></pre><p id="c0aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将停止解析HTML并发出请求调用来获取文件。它会下载文件并解析文件。同样的情况也发生在<code class="fe nn no np nq b">&lt;script&gt;</code>标签上。没有CSS，浏览器不会呈现页面。如果是这样，它会显示一个难看的页面，当CSS无法加载时，您可能已经看到了。</p><p id="9967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是你把CSS链接放在头部的原因，因为没有CSS的页面看起来很糟糕。如果你的脚本标签在底部，就在结束的body标签的正上方，它们不会打断页面的呈现，你可以在页面上看到一些东西来吸引用户。</p><p id="9913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的例子，我们已经下载了资源，或者我们已经开始将HTML流式传输到浏览器。让我们看看接下来会发生什么。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="6881" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">解析HTML和CSS</h1><p id="4cd0" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">解析HTML基本上是对HTML的每一部分进行标记，使之有意义。HTML解析器非常宽容，倾向于自己完成很多事情，比如插入缺少的结束标记等等。</p><p id="982f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在HTML5之前，没有构建DOM的标准，所以不同的浏览器最终会得到不同外观的DOM。现在大家都按照标准来。这里有一个HTML解析的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/e22222d8ad3979cb5b7caf167d2b8a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohKV-1Gmdvyr0n_tRe_l1w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/fundamentals/performance/critical-rendering-path/render-tree-construction</a></p></figure><p id="b24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一步之后，我们最终得到了一个DOM树。我们仍然有一个显示给最终用户的空白屏幕。</p><p id="bf07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CSS不像HTML。由于其级联属性，不能对其进行增量解析。它必须被解析一次，所以要记住你在初始加载时发送的CSS的大小。解析完CSS之后，我们就有了一个CSSOM。现在让我们进入下一步，创建一个渲染树。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="ee8c" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">渲染树</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/62302ad11d2381df3788cba18811a7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDiTAbp5TzyntJFXLXOXHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/fundamentals/performance/critical-rendering-path/render-tree-construction</a></p></figure><p id="b577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">渲染树省略了所有不需要的节点，比如<code class="fe nn no np nq b">display:none</code>、<code class="fe nn no np nq b">&lt;script&gt;</code>、<code class="fe nn no np nq b">&lt;meta&gt;</code>。</p><p id="2bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能遇到的一个重要区别是<code class="fe nn no np nq b">display:none</code>和<code class="fe nn no np nq b">visibility: hidden</code>。渲染树不包含带有<code class="fe nn no np nq b">display: none</code>的节点，但包含了<code class="fe nn no np nq b">visibility:hidden</code>。</p><p id="cb95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这张图片给出了一个清晰的例子，展示了如何将DOM和CSSOM合并在一起创建一个渲染树。这是浏览器开始布局节点之前的最后一步。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="cf64" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">布局</h1><p id="90d8" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们还没有在屏幕上画任何东西。在这一步中，我们将计算树中节点的大小和位置。它非常擅长它所做的事情，所以这里没有什么可探索的。我们将在接下来的部分中研究这个问题。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="bc95" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">绘画</h1><p id="0635" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">布局完成后，我们最终开始在屏幕上绘制像素。这是我们开始在浏览器上看到东西的地方。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="75e1" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">丢了什么吗？</h1><p id="aca6" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们已经经历了很多，但是我们缺少现代web应用程序最重要的部分:JavaScript。<strong class="ky ir"><em class="oc"/></strong>JS如何融入整个画面？让我们进一步探索。</p><p id="d62b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们遇到一个<code class="fe nn no np nq b">&lt;script&gt;</code>，解析就完全停止。我们获取文件，解析文件，运行JavaScript，然后继续一点一点地解析HTML。如果我们在脚本中使用<code class="fe nn no np nq b">document.write()</code>，解析将再次开始。下图可以更好地解释这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cec3d6c688d1016553017633ea25fb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*YYoytFvqDKecNjCVecje2w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JS执行，来源:<a class="ae kv" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" rel="noopener ugc nofollow" target="_blank">https://www . html 5 rocks . com/en/tutorials/internals/howsbrowserswork/</a></p></figure><p id="7f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么人们倾向于将脚本放在结束body标签的上方。这样，所有的解析都已经完成，文档节点可以通过JavaScript获得。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="51a2" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="81c3" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">现在，您对浏览器的工作原理有了一个大致的了解。现在，您可以更深入地研究如何以最佳方式构建代码，并避免所有的反模式。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="bb06" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">资源</h1><ul class=""><li id="894f" class="ls lt iq ky b kz ng lc nh lf oe lj of ln og lr oh ly lz ma bi translated"><a class="ae kv" href="https://gist.github.com/faressoft/36cdd64faae21ed22948b458e6bf04d5" rel="noopener ugc nofollow" target="_blank">告别要点</a></li><li id="6e17" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oh ly lz ma bi translated"><a class="ae kv" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path" rel="noopener ugc nofollow" target="_blank">developer.google.com</a></li></ul></div></div>    
</body>
</html>