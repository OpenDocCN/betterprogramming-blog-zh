<html>
<head>
<title>Demystifying GitOps — Ephemeral Pull Request Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开数字版权管理的神秘面纱—短暂的请求请求环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-gitops-ephemeral-pull-request-environments-5f1032f01299?source=collection_archive---------12-----------------------#2022-04-19">https://betterprogramming.pub/demystifying-gitops-ephemeral-pull-request-environments-5f1032f01299?source=collection_archive---------12-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa56" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将短暂环境用于验收测试、渗透测试、端到端测试或负载测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3212e542420d617bc0a4802c94a9dd17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SPzybxN1JDN5E2Im"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇·🇺🇦</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想演示如何为在GitHub上创建的请求设置临时环境。这可以应用于Argo CD拉请求生成器支持的任何SCM。没有一种方法和一套工具来实现这种特性。</p><p id="360e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用两种不同的Kubernetes风格作为拉请求环境，第一种是Kubernetes名称空间，第二种是虚拟Kubernetes集群，它可以提供更好的隔离。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/8ba3d74b24c0f32a8572dd152366e0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LUo_ulLybI3y2-fP.png"/></div></div></figure><h1 id="23e3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">所用工具</strong></h1><ol class=""><li id="cdb9" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">Argo CD拉取请求生成器:Argo CD拉取请求生成器是其中一个应用程序生成器，用于监视SCM的新拉取请求，然后根据这些拉取请求生成必要的应用程序定义。</li><li id="536d" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">Github动作:Github动作用于此功能的CI部分。每当生成新的拉取请求时，都会触发一个Github操作，为拉取请求的要素分支生成并推送容器映像。</li><li id="dfb4" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">vccluster:vccluster用于此功能的虚拟Kubernetes群集部分。这是Loft Labs在K3S、K0S或普通K8S的基础上开发的一款很棒的工具。对于这个演示，我尝试了K3S和K0S。由于我在K3S安装过程中遇到的问题，最终版本依赖于K0S。</li><li id="1e96" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">ArgoCD Secret Synchronizer:一个我为实验目的开发的自定义操作符，用于将Vcluster创建的机密与Argo CD Cluster的机密进行同步。通过使用该运营商，消除了手动干预要求，并且所创建的虚拟集群被自动添加到Argo CD管理集群的列表中。</li></ol><p id="b6f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了上面这些之外，您还需要有一个具有管理权限的Kubernetes集群(可以使用Killercoda，有关示例场景，请参见构件部分)，用于应用程序代码的Github存储库、helm charts、Argo CD CRDs和Argo CD应用程序资源定义。</p><h1 id="538a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak"> Github存储库</strong></h1><ol class=""><li id="67dd" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/a1tan/ephemeralenvironments" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">ephemeralenvironments</strong></a></code>:这个git存储库包含Argo CD CRDs、拉请求<code class="fe nb nc nd ne b">applicationset</code>定义和Argo CD秘密同步资源定义。所有这些资源都由kustomization管理。<code class="fe nb nc nd ne b">kustomization.yaml</code>文件可以在每个文件夹中看到。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/f3ffb24f819efdafdd07ed814a1ad9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bykvy8CaO7gddI52gVJB8Q.png"/></div></div></figure><p id="309d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想运行这个示例，克隆这个git存储库并执行下面的两个命令:</p><ul class=""><li id="bcfa" class="ml mm iq ky b kz la lc ld lf ng lj nh ln ni lr nj mt mu mv bi translated"><code class="fe nb nc nd ne b">kubectl apply -k ephemeralenvironments/managementstack/argocd</code></li><li id="0738" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated"><code class="fe nb nc nd ne b">kubectl apply -k ephemeralenvironments/managementstack/argocdapplications</code></li></ul><p id="96c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个将Argo CD CRDs和资源应用到由<code class="fe nb nc nd ne b">kubeconfig</code>文件指向的管理集群，第二个创建一个<code class="fe nb nc nd ne b">applicationset</code>定义，该定义为上述五个文件夹生成Argo CD应用。<a class="ae kv" href="https://www.katacoda.com/a1tan/scenarios/ephemeralenvironments" rel="noopener ugc nofollow" target="_blank">如果您愿意，我们构建了一个Killecoda场景</a>来演示这些步骤。</p><p id="76b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/a1tan/ephemeralcluster" rel="noopener ugc nofollow" target="_blank">ephemeralcluster</a></code> : <strong class="ky ir"> </strong>这个git存储库包含以声明方式部署Vcluster的舵图。在上面的<code class="fe nb nc nd ne b">ephemeralenvironments</code>仓库的<code class="fe nb nc nd ne b">pullrequests</code>目录中有一个<code class="fe nb nc nd ne b">applicationset</code>定义指向这个仓库。</p><p id="4685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/a1tan/app-ephemeraltest" rel="noopener ugc nofollow" target="_blank">app-ephemeraltest</a></code>:该库包含示例应用程序代码(一个简单的dotnet api)、dockerfile、helm chart、GitHub actions定义，用于为每个pull请求构建和推送图像，以及在示例场景中演示的示例pull请求。<code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/a1tan/app-ephemeraltest/tree/f-ephemeralpullrequest" rel="noopener ugc nofollow" target="_blank">f-ephemeralpullrequest</a></code>分支用于该样本，并从该分支创建样本拉取请求，以合并到<code class="fe nb nc nd ne b">main</code>分支。</p><h1 id="dcf1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">拉取请求生成器</strong></h1><p id="e1c3" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">拉请求生成器是Argo CD模板生成器之一，它使用SCM APIs来获取拉请求信息并生成必要的应用程序定义。默认情况下，<code class="fe nb nc nd ne b">applicationset</code>控制器以30秒的时间间隔轮询SCM APIs，如果需要可以更改。除此之外，如果需要，SCMs webhook也可以配置为触发<code class="fe nb nc nd ne b">applicationset</code>控制器以消除等待时间。</p><h2 id="19c9" class="nn lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated"><strong class="ak">部署到虚拟集群</strong></h2><p id="0f20" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">下面给出了用于将示例应用程序部署到虚拟集群的拉请求生成器:</p><pre class="kg kh ki kj gt nz ne oa ob aw oc bi"><span id="d622" class="nn lu iq ne b gy od oe l of og">apiVersion: argoproj.io/v1alpha1<br/>kind: ApplicationSet<br/>metadata:<br/>  name: sampleapps<br/>  namespace: argocd<br/>spec:<br/>  generators:<br/>  - pullRequest:<br/>      github:<br/>          owner: a1tan<br/>          repo: app-ephemeraltest<br/>      requeueAfterSeconds: 120<br/>  template:<br/>    metadata:<br/>      name: 'sampleapp-{{branch}}-{{number}}'<br/>    spec:<br/>      source:<br/>        repoURL: '<a class="ae kv" href="https://github.com/a1tan/app-ephemeraltest.git'" rel="noopener ugc nofollow" target="_blank">https://github.com/a1tan/app-ephemeraltest.git'</a><br/>        targetRevision: '{{head_sha}}'<br/>        path: charts/sampleapp<br/>        helm:<br/>          parameters:<br/>          - name: "image.tag"<br/>            value: "pull-{{head_sha}}"<br/>          - name: "environment"<br/>            value: "PR-Vcluster-Dev"<br/>      project: default<br/>      destination:<br/>        server: <a class="ae kv" href="https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local" rel="noopener ugc nofollow" target="_blank">https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local</a><br/>        namespace: 'sampleapp-{{branch}}-{{number}}-namespace'<br/>      syncPolicy:<br/>          automated:<br/>              allowEmpty: true<br/>              prune: true<br/>              selfHeal: true</span></pre><p id="394c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个拉请求生成器监听Github帐户“a1tan”和存储库<code class="fe nb nc nd ne b">app-ephemeraltest</code>上的拉请求。</p><p id="853c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还将轮询间隔更改为120秒，这在现实世界中可能很烦人。当它检测到一个新的拉请求时，它创建一个用<code class="fe nb nc nd ne b">sampleapp-{{branch}}-{{number}}</code>模式命名的应用程序。它将在带有<code class="fe nb nc nd ne b">targetRevision: ‘{{head_sha}}</code>的分支和带有<code class="fe nb nc nd ne b">path: charts/sampleapp</code>的路径上执行最新的提交。它还将图像标签设置为<code class="fe nb nc nd ne b">pull-{{head_sha}}</code>，该标签指向Github Actions CI管道构建的最新pull请求图像。还有另一个头盔参数来区分这个部署和下面的<code class="fe nb nc nd ne b">namespace</code>版本。</p><p id="5b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于目的地，该<code class="fe nb nc nd ne b">applicationset</code>使用与主<code class="fe nb nc nd ne b">kubernetes</code>集群不同的集群参考作为<code class="fe nb nc nd ne b">server: <a class="ae kv" href="https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local" rel="noopener ugc nofollow" target="_blank">https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local</a></code>。它将这个应用程序应用到一个新创建的临时虚拟集群实例。</p><p id="02e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的拉请求生成器也部署了此实例:</p><pre class="kg kh ki kj gt nz ne oa ob aw oc bi"><span id="29ac" class="nn lu iq ne b gy od oe l of og">apiVersion: argoproj.io/v1alpha1<br/>kind: ApplicationSet<br/>metadata:<br/>  name: ephemeralcluster<br/>  namespace: argocd<br/>spec:<br/>  generators:<br/>  - pullRequest:<br/>      github:<br/>          owner: a1tan<br/>          repo: app-ephemeraltest<br/>      requeueAfterSeconds: 120<br/>  template:<br/>    metadata:<br/>      name: 'cluster-{{branch}}-{{number}}'<br/>    spec:<br/>      source:<br/>        repoURL: '<a class="ae kv" href="https://github.com/a1tan/ephemeralcluster.git'" rel="noopener ugc nofollow" target="_blank">https://github.com/a1tan/ephemeralcluster.git'</a><br/>        targetRevision: 'main'<br/>        path: charts/vcluster<br/>        helm:<br/>          parameters:<br/>          - name: "syncer.extraArgs[0]"<br/>            value: "--out-kube-config-server=<a class="ae kv" href="https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local" rel="noopener ugc nofollow" target="_blank">https://cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local</a>"<br/>          - name: "syncer.extraArgs[1]"<br/>            value: "--tls-san=cluster-{{branch}}-{{number}}.cluster-{{branch}}-{{number}}-namespace.svc.cluster.local"<br/>      project: default<br/>      destination:<br/>        server: <a class="ae kv" href="https://kubernetes.default.svc" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc</a><br/>        namespace: 'cluster-{{branch}}-{{number}}-namespace'<br/>      syncPolicy:<br/>          automated:<br/>              allowEmpty: true<br/>              prune: true<br/>              selfHeal: true</span></pre><p id="3108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此<code class="fe nb nc nd ne b">applicationset</code>定义服务器引用不同，<code class="fe nb nc nd ne b">server: <a class="ae kv" href="https://kubernetes.default.svc" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc</a></code>。Vcluster部署到主群集中的命名空间。它还有两个helm参数<code class="fe nb nc nd ne b">— out-kube-config-server</code>和<code class="fe nb nc nd ne b">— tls-san</code>，使创建的Vcluster可以从Argo CD实例访问。</p><p id="7348" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序在<code class="fe nb nc nd ne b">main</code>群集的<code class="fe nb nc nd ne b">cluster-{{branch}}-{{number}}-namespace</code>命名空间上创建所有Vcluster资源。在这个名称空间上还创建了一个包含用于访问这个虚拟集群实例的<code class="fe nb nc nd ne b">kubeconfig</code>的密码。</p><p id="04d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ne b">ArgoCDSecretSynchronizer</code>操作员利用此<code class="fe nb nc nd ne b">kubeconfig</code>并创建必要的Argo CD簇秘密。这样，主集群上的Argo CD实例可以管理虚拟集群上的示例应用程序。</p><h2 id="dfe5" class="nn lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated"><strong class="ak">部署到名称空间</strong></h2><p id="890b" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">还有第三个拉请求生成器定义，用于将示例应用程序部署到主集群上的名称空间。</p><p id="16c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要一个更简单的解决方案，并且不想为每个拉请求创建一个虚拟集群，那么您可以使用这个设置。</p><pre class="kg kh ki kj gt nz ne oa ob aw oc bi"><span id="9abb" class="nn lu iq ne b gy od oe l of og">apiVersion: argoproj.io/v1alpha1<br/>kind: ApplicationSet<br/>metadata:<br/>  name: sampleapps-ns<br/>  namespace: argocd<br/>spec:<br/>  generators:<br/>  - pullRequest:<br/>      github:<br/>          owner: a1tan<br/>          repo: app-ephemeraltest<br/>      requeueAfterSeconds: 120<br/>  template:<br/>    metadata:<br/>      name: 'sampleapp-ns-{{branch}}-{{number}}'<br/>      # namespace: 'myapp-{{branch}}-{{number}}-namespace'<br/>    spec:<br/>      source:<br/>        repoURL: '<a class="ae kv" href="https://github.com/a1tan/app-ephemeraltest.git'" rel="noopener ugc nofollow" target="_blank">https://github.com/a1tan/app-ephemeraltest.git'</a><br/>        targetRevision: '{{head_sha}}'<br/>        path: charts/sampleapp<br/>        helm:<br/>          parameters:<br/>          - name: "image.tag"<br/>            value: "pull-{{head_sha}}"<br/>          - name: "environment"<br/>            value: "PR-Namespace-Dev"<br/>      project: default<br/>      destination:<br/>        server: <a class="ae kv" href="https://kubernetes.default.svc" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc</a><br/>        namespace: 'sampleapp-ns-{{branch}}-{{number}}-namespace'<br/>      syncPolicy:<br/>          automated:<br/>              allowEmpty: true<br/>              prune: true<br/>              selfHeal: true</span></pre><p id="170b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与其他示例<code class="fe nb nc nd ne b">applicationset</code>定义的唯一区别是服务器选择器<code class="fe nb nc nd ne b">server: <a class="ae kv" href="https://kubernetes.default.svc" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc</a></code>。通过这个服务器选择器，示例应用程序被部署到<code class="fe nb nc nd ne b">main</code>集群上的<code class="fe nb nc nd ne b">sampleapp-ns-{{branch}}-{{number}}-namespace</code>名称空间。Helm环境参数的设置也有所不同，以验证应用程序的部署是否正确。</p><h1 id="2a68" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">提示</strong></h1><p id="2634" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">要记住的一点是，如果你在你的舵图中使用一个分支名称作为你的服务名称，要小心你的分支命名策略，它必须是一个有效的DNS名称。因此，您可以选择“f-blabla”类型的命名，而不是使用feature/blabla类型的命名。</p><p id="314f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在下面找到我因为这个错误收到的错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/622c616fc79d0b81bcab15c3c770c20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89kUROoEPE2rYsuARYNGxg.png"/></div></div></figure><p id="965f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Github速率限制也是一个关键问题。对于这个示例的第一次运行，我使用了默认值30秒。在太多次不成功的同步尝试后，收到下面的速率限制错误，然后我将requeue周期增加到120秒。对于这些速率限制，Webhook配置是更好的选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/b007bcfc912b57a24c97cd4ccbfd4f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJ645C7nfKGB97y61K4JfQ.png"/></div></div></figure><p id="af7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记在github动作上使用<code class="fe nb nc nd ne b">${{ github.event.pull_request.head.sha }}</code>来请求提交sha。使用此表达式标记您的图像，以成功获取Argo CD上的特定拉请求图像。</p><h1 id="d602" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">结论</strong></h1><p id="5607" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">如果您希望您的特性在合并到主分支之前符合done的定义，那么创建拉请求环境是一个关键步骤。</p><p id="707c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用短暂的环境进行验收测试、渗透测试、端到端测试或负载测试。依赖性管理是本文中我们没有提到的另一个关键问题。</p><p id="a634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，将一个简单的应用程序部署到一个环境中是不够的。这个应用程序有很多依赖项，包括数据库、数据库表、分布式缓存服务、密钥库、身份提供者、消息代理，甚至根据我们想要测试的场景的其他服务。</p><p id="579c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些都需要以一种适用于这种短暂环境的方式来定义。打包方法和工具也被确定来管理这样的需求。在后面的帖子中，我想详细阐述这个话题。</p><h1 id="2de2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">工件</strong></h1><ul class=""><li id="5e2d" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr nj mt mu mv bi translated"><a class="ae kv" href="https://killercoda.com/altanaltundemir/scenario/ephemeralenvironments" rel="noopener ugc nofollow" target="_blank">杀手科达场景</a></li><li id="89a8" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated"><a class="ae kv" href="https://github.com/a1tan/ephemeralenvironments" rel="noopener ugc nofollow" target="_blank">应用程序定义的Github存储库</a></li><li id="14c2" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated"><a class="ae kv" href="https://github.com/a1tan/app-ephemeraltest" rel="noopener ugc nofollow" target="_blank">示例应用程序的Github存储库</a></li><li id="7bb5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated">【Vcluster资源的Github存储库</li></ul><h1 id="ee1d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考</h1><ol class=""><li id="eb2c" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated"><a class="ae kv" href="https://argocd-applicationset.readthedocs.io/en/stable/Generators-Pull-Request/" rel="noopener ugc nofollow" target="_blank">拉请求发生器</a></li><li id="ae11" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" href="https://www.vcluster.com/docs/getting-started/deployment" rel="noopener ugc nofollow" target="_blank"> Vcluster </a></li><li id="a8fd" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" href="https://github.com/a1tan/argocdsecretsynchronizer" rel="noopener ugc nofollow" target="_blank"> Argo CD秘密同步器</a></li></ol><h1 id="da3d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">以前的</h1><ul class=""><li id="8ac1" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr nj mt mu mv bi translated"><a class="ae kv" href="https://medium.com/p/fbfee94f8188/edit" rel="noopener">揭秘GitOps-Bootstrapping Flux </a></li><li id="86b1" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated"><a class="ae kv" href="https://medium.com/@aaltundemir/demystifying-gitops-bootstrapping-argo-cd-4a861284f273" rel="noopener">揭秘GitOps-引导Argo CD </a></li><li id="b0bd" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr nj mt mu mv bi translated"><a class="ae kv" href="https://medium.com/@aaltundemir/demystifying-gitops-intro-2b9c3cbef404" rel="noopener">揭秘GitOps-简介</a></li></ul></div></div>    
</body>
</html>