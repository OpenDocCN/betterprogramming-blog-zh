<html>
<head>
<title>Building the Rust Web App — Proper Error Handling and Return Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Rust Web应用程序—正确的错误处理和返回值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-the-rust-web-app-proper-error-handling-and-return-values-723f1f07f8cd?source=collection_archive---------13-----------------------#2022-07-11">https://betterprogramming.pub/building-the-rust-web-app-proper-error-handling-and-return-values-723f1f07f8cd?source=collection_archive---------13-----------------------#2022-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2adc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">要使您的web应用程序正常工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbaf5f3f33f2e0afb3907383da796ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJ_axG_BKLzywCqq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@aldebarans" rel="noopener ugc nofollow" target="_blank">阿鲁迪巴S </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="7180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关于编写web应用程序的系列文章的第四部分。对于这个系列，我们将在<a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank"> Rust </a>中编写web应用程序，我将向您解释如何自己编写它。</p><p id="c5e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您不愿意自己编写代码，我在这里创建了一个包含本系列所有代码的库。在本系列每一部分的结尾，我都提交了一个存储库。<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/building-the-rust-web-app-how-to-use-object-relational-mapper-3af2084555b6">在上一部分</a>中，我们讨论了使用对象关系映射器，或简称ORM，来使我们的数据库工作更加容易。在这一部分，我们给我们的应用程序提供了更合适的错误处理和返回值。最终，它将看起来更像一个标准的网络应用程序。</p><h1 id="46d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">正确的返回值</h1><p id="360d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，我们的回报都是纯数据。JSON的片段或字符串。然而，正如我在开始时提到的，我们的应用程序应该接受请求并返回HTML、JavaScript和CSS来显示网页。从技术上来说，这是一个谎言。我们已经制定的<code class="fe mq mr ms mt b">GET</code>、<code class="fe mq mr ms mt b">PUT</code>、<code class="fe mq mr ms mt b">POST</code>和<code class="fe mq mr ms mt b">DELETE</code>方法基本上保持不变。然而，我们的服务器中的一些路径会返回HTML，这是事实。恰好有些路径返回正在显示的东西，有些路径用来做事。无论如何，让我们实现一个实际返回显示内容的路径。</p><p id="035e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经非常广泛地使用Rocket来返回值，因为它是最后一个触及我们的值并在它们被发送到浏览器之前将它们转化为响应的东西。可想而知，Rocket还提供了对返回HTML、CSS和JavaScript的支持。</p><p id="743c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以把一系列的字符串放在一起，通过简单地操作字符串，用CSS和JavaScript制作我们自己的HTML文件，但是我不打算这么做。它很乏味，很长，而且我不认为它真的提供了任何有价值的东西。我们将直接跳到在此基础上构建的抽象，即使用模板引擎。基本上，我们写出一个HTML文件，但是我们留下可以输入数据的地方，并且在发送回模板之前提供数据。为什么这种抽象存在是显而易见的。编写一个漂亮的HTML文件并提供必要的数据比处理一大堆乱七八糟的字符串更容易。</p><p id="f896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，Rocket允许您使用和返回模板，还允许您从列表中选择想要使用的模板引擎(模板引擎是获取我们的模板并将其转换为正确的HTML的工具)。出于我们的目的，我们将使用名为<a class="ae kv" href="https://tera.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Tera </a>的模板引擎。</p><p id="ce2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要配置Rocket从某个目录中提取模板，因此修改<code class="fe mq mr ms mt b">Rocket.toml</code>如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="faff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们需要导入解释模板的Rocket库，所以修改<code class="fe mq mr ms mt b">Cargo.toml</code>如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在与<code class="fe mq mr ms mt b">Rocket.toml</code>相同的层次上，创建一个名为<code class="fe mq mr ms mt b">templates</code>的目录。对于我们创建的模板，我们将在最后使用文件扩展名<code class="fe mq mr ms mt b">.tera</code>来让Rocket知道我们想用handlebars来编译它。说到这里，在<code class="fe mq mr ms mt b">templates</code>目录下，创建一个名为<code class="fe mq mr ms mt b">base.html.tera</code>的文件。这个文件基本上是我们所有内容的包装器。其他每一个模板基本都会说“从<code class="fe mq mr ms mt b">base.html.tera</code>中间开始”，所以我们只需要写出<code class="fe mq mr ms mt b">&lt;!DOCTYPE html&gt;</code>和其他那些繁琐的导入一次。现在，将以下代码添加到<code class="fe mq mr ms mt b">base.html.tera</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们将创建待办事项的实际列表。创建一个名为<code class="fe mq mr ms mt b">todo_list.html.tera</code>的文件。用下面的代码填充它(这将把内容放在我们命名为content的块中)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0eb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们正在使用模板引擎根据我们将从数据库中提取的数据动态创建项目。在<code class="fe mq mr ms mt b">main.rs</code>中，我们将设置正确渲染模板的函数，并将模板引擎添加到Rocket应用程序中。它的代码看起来像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e7b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，如果我们再次运行程序，并在浏览器中打开链接，我们将看到数据库中的项目列表。不过，看起来也不是特别好。如果我们可以使用一些CSS来改善外观，那就太好了，但是我们如何将CSS放到我们的前端呢？这使我们走上了提供静态内容的道路。</p><h1 id="522a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提供静态内容</h1><p id="70f6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.stackpath.com/static-content/" rel="noopener ugc nofollow" target="_blank">静态内容</a>是不变的内容。这意味着，无论用户做什么，无论应用程序中发生什么，文件都不会改变。大多数CSS文件和图像都是静态内容。它们在应用程序的过程中不会真正改变。它们只是存在并提供额外的信息。</p><p id="b8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多时候，我们希望静态内容可以自由获取。换句话说，我们真的希望能够简单地提交一个快速的<code class="fe mq mr ms mt b">GET</code>请求，然后毫不费力地撤回这些内容。幸运的是，包括Rocket在内的大多数web框架都提供了一种功能来公开一个充满静态内容的文件夹。在这个文件夹被“公开”后，我们可以运行<code class="fe mq mr ms mt b">GET</code>请求，就像我们在那个文件夹的路径中移动一样，并且可以拉回相关的文件。</p><p id="0e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们将所有静态内容放在一个名为<code class="fe mq mr ms mt b">public</code>的新文件夹中，该文件夹与<code class="fe mq mr ms mt b">Cargo.toml</code>位于同一层。在这个文件夹中，我们将放置所有的CSS，图片和其他静态内容，我们希望我们的网站能够使用。然后，我们将使用Rocket来显示该文件夹。让Rocket暴露该文件夹的代码发生在<code class="fe mq mr ms mt b">main.rs</code>，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c8d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们已经安装了public中所有从<code class="fe mq mr ms mt b">/</code>开始使用的文件。这意味着，如果我们的公共文件夹中有一个名为<code class="fe mq mr ms mt b">todo_list.css</code>的文件，调用<code class="fe mq mr ms mt b">http://127.0.0.1:8000/todo_list.css</code>将返回那个CSS。如果我们有一个名为<code class="fe mq mr ms mt b">images</code>的公共文件夹，我们把一个名为<code class="fe mq mr ms mt b">pizza.png</code>的图像放在那里，调用<code class="fe mq mr ms mt b">http://127.0.0.1:8000/images/pizza.png</code>将返回那个图像。使用这个，我们现在可以为我们的模板编写CSS，并且当我们在前端时可以检索它们。</p><p id="d2e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们使用我们的新能力来服务静态内容！在<code class="fe mq mr ms mt b">public</code>文件夹中，创建一个名为<code class="fe mq mr ms mt b">todo_list.css</code>的文件，并放入以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6797" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在我们的<code class="fe mq mr ms mt b">base.html.tera</code>文件中，我们需要导入CSS。为此，我们需要使用一个<code class="fe mq mr ms mt b">link</code>元素来引入一个样式表。我们使用<code class="fe mq mr ms mt b">href</code>道具传入一个包含CSS的URL。如果现在开始给定URL，则假定基本URL是我们的网站。</p><p id="4065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用非行话的术语来说，将下面的代码放在<code class="fe mq mr ms mt b">base.html.tera</code>中的meta标签之间</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="2fa3" class="na lt iq mt b gy nb nc l nd ne">&lt;link rel="stylesheet" href="/todo_list.css" /&gt;</span></pre><p id="4822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你重新运行你的应用程序，表格看起来会好一点。现在，本着做一点样式的精神，让我们用下面的代码在<code class="fe mq mr ms mt b">public</code>中创建另一个名为<code class="fe mq mr ms mt b">container.css</code>的文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在<code class="fe mq mr ms mt b">base.html.tera</code>中的meta标记之间添加以下样式表链接</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="b679" class="na lt iq mt b gy nb nc l nd ne">&lt;link rel="stylesheet" href="/container.css" /&gt;</span></pre><p id="cee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了它，我们的造型看起来更过得去了。</p><h1 id="8901" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">修正我们反应的代码</h1><p id="d6e3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们的函数仍然返回不正确的值。即使在实现了前面的修复之后，如果您尝试添加一个任务，您将会看到一个充满JSON的空白页面，这是我们不希望看到的。我们更愿意做的是重定向到我们的TODO列表页面，并添加一个类似“任务已创建！”。幸运的是，Rocket有一个名为<code class="fe mq mr ms mt b"><a class="ae kv" href="https://api.rocket.rs/v0.4/rocket/response/struct.Flash.html" rel="noopener ugc nofollow" target="_blank">Flash</a></code>的结构，可以完美地为我们做到这一点。</p><p id="10d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们修改我们的<code class="fe mq mr ms mt b">add_task</code>函数，以便更好地与我们的应用程序一起工作！我们需要做的就是修改它，使用那个<code class="fe mq mr ms mt b">Flash</code>结构来重定向和发送消息</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们修改<code class="fe mq mr ms mt b">index</code>来接收消息并将其传递给我们的HTML</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="89e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们修改<code class="fe mq mr ms mt b">todo_list.html.tera</code>的顶部以使用该消息。</p><pre class="kg kh ki kj gt mw mt mx my aw mz bi"><span id="fa97" class="na lt iq mt b gy nb nc l nd ne">{% extends "base" %} {% block content %}<br/>&lt;h1&gt;Todo List&lt;/h1&gt;<br/>{% if flash %}<br/>&lt;p class="{{ flash.0 }}-flash"&gt;<br/>  {{ flash.1 }}<br/>&lt;/p&gt;<br/>{% endif %}<br/>...</span></pre><p id="4e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，将以下CSS添加到<code class="fe mq mr ms mt b">container.css</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="85ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们修改删除任务，使其也能正常工作。将函数更改为如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f53a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，我们的删除应该可以正常工作了。</p><h1 id="120b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">困难的编辑操作</h1><p id="5c67" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">可悲的是，编辑操作将使我们的生活更加困难。实现它的最简单的方法是在我们的应用程序中创建另一个打开新页面的路由。在此页面中，我们可以编辑任务并提交编辑内容。</p><p id="59c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要创建将要访问的模板。在<code class="fe mq mr ms mt b">templates</code>中创建一个名为<code class="fe mq mr ms mt b">edit_task_form.html.tera</code>的新文件，并在其中输入以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe mq mr ms mt b">main.rs</code>中，添加以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，把它放到<code class="fe mq mr ms mt b">rocket</code>的<code class="fe mq mr ms mt b">routes!</code>宏中。接下来，修改<code class="fe mq mr ms mt b">todo_list.html.tera</code>中的编辑按钮，改为如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="de90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，进入<code class="fe mq mr ms mt b">main.rs</code>，修改<code class="fe mq mr ms mt b">edit_task</code>功能如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="650b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，进入<code class="fe mq mr ms mt b">todo_list.css</code>并添加以下CSS</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b3c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，如果您停止并重新启动应用程序，并尝试web部件。现在，您可以正确地使用所有CRUD操作了。</p><h1 id="8cfb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理错误</h1><p id="51c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们处理错误的方式是不充分的。即使我们的错误不会使服务器崩溃，它们仍然会将用户带到404、500或其他状态页面。如果这个错误能更好地集成到应用程序中，并且不影响用户体验，那就更好了。我们可以使用相同的<code class="fe mq mr ms mt b">Flash</code>结构，我们已经使用我们的成功回报，也使用它为我们的不良回报。事实上，<code class="fe mq mr ms mt b">Flash</code>通过关联函数<code class="fe mq mr ms mt b">Flash::error</code>支持这一点。所以，我们将遍历那些不返回模板的函数，并让它们在失败时返回<code class="fe mq mr ms mt b">Flash::error</code> s，而不是将用户发送到404或500页面。下面是<code class="fe mq mr ms mt b">delete_task</code>的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cc6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe mq mr ms mt b">edit_task</code>的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe mq mr ms mt b">add_task</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="84d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，你可能已经注意到<code class="fe mq mr ms mt b">read_tasks</code>不再真的需要被使用，因为<code class="fe mq mr ms mt b">index</code>现在基本上做同样的事情，所以你可以自由地保留那个函数用于调试，或者如果你不想要它就删除它。</p><p id="e614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然你可能看不到错误，除非你特意去引起一个错误，但是要意识到，当错误确实发生时，它确实工作。</p><p id="986c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可能已经注意到，我没有切换从返回<code class="fe mq mr ms mt b">Template</code> s的路线返回的<code class="fe mq mr ms mt b">DatabaseError</code>，因为如果页面加载失败，404或500页面出现来取代它的位置要正常得多。所以，它在那里工作。</p><h1 id="d3fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">页码</h1><p id="7c48" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们的Todo列表是一个未知数量的项目列表。一个人可能有100多项任务，也可能有3项。通常，当我们显示一个数据列表时，这个列表可能会很长，我们必须对数据进行分页。这意味着我们把列表分成几页，每一页都有一定数量的条目。然后，当我们想要查看项目时，我们一次只显示一页项目。</p><p id="2960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">&lt;Quick Aside&gt;</code></p><p id="562b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在许多社交媒体应用程序中，如Reddit、Instagram、Twitter或脸书，主页将是你所关注的人的帖子列表。然而，你可以继续滚动，只要你想。当你到达主页上文章的末尾时，它会加载更多的内容，然后你就可以浏览这些内容了。我们通常称之为<a class="ae kv" href="https://blog.hubspot.com/website/pagination-vs-infinite-scroll" rel="noopener ugc nofollow" target="_blank">无限滚动列表</a>。但是，这也是分页！这个应用程序显然不只是加载无限数量的帖子。它也以块或页的形式加载文章，并把它们放在列表中，它只是试图获取下一页的文章，并在你到达底部之前把它们添加到列表中。</p><p id="9267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">&lt;/Quick Aside&gt;</code></p><p id="a94c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，我们希望为我们的应用程序实现这一点。不仅仅是为了学习分页，还因为它会让这个应用程序更容易使用。</p><p id="4899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，要做到这一点，我们需要稍微改变一下<code class="fe mq mr ms mt b">index</code>的工作方式。我们不只是返回数据库中的每一个任务，而是希望获取一个参数来了解用户需要哪一页的任务。此外，我们希望浏览器能够指定每个页面有多少任务。这可以在以后使用，通过根据垂直尺寸改变每页的任务数量，使列表更好地适用于不同的设备。我们也可以只放一个输入，并允许用户指定他们想要在每个页面上有多少项目。两者都可以很好地工作，但这显然是我们想要的选择。</p><p id="ef80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加它很简单。分页由<code class="fe mq mr ms mt b">sea-orm</code>提供。只需修改<code class="fe mq mr ms mt b">index</code>如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会注意到<code class="fe mq mr ms mt b">index</code>的路线现在有了一些新的参数。它们的编写方式使它们成为可选的，所以它们不需要打开页面。在任何情况下，修改<code class="fe mq mr ms mt b">todo_list.html.tera</code>如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，修改<code class="fe mq mr ms mt b">todo_list.css</code>,如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="953c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，我们已经添加了基本的分页。然而，这种分页有一个可用性问题。因为我们的添加、删除和编辑任务都要经过路径<code class="fe mq mr ms mt b">/</code>，所以每当我们试图对列表做新的事情时，我们都会回到第一页，这并不理想。但是，它符合我们演示分页的目的。我们也可以增加其他的可用性特性，比如过滤和排序列表，但是我不会在这里做这些。我不认为它们对更大的网络应用架构真的那么重要。然而，如果您想知道，<code class="fe mq mr ms mt b">sql</code>和SeaORM <a class="ae kv" href="https://sqlbolt.com/lesson/filtering_sorting_query_results" rel="noopener ugc nofollow" target="_blank">实现了过滤和排序项目的方法</a>，您只需在您运行的任何查询中使用这些方法来取回您的项目。</p><p id="af63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这就是我今天的全部内容。在本系列的下一部分中，我们将解决多用户问题，并将授权添加到我们的基本web应用程序中。</p><p id="a94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。我希望这个系列能够继续帮助您提高web开发技能。</p><h1 id="81a9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="4352" class="nf ng iq ky b kz mk lc ml lf nh lj ni ln nj lr nk nl nm nn bi translated">【rust-lang.org】Rust编程语言(T4)</li><li id="3096" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">本系列的GitHub库</a></li><li id="ae06" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://tera.netlify.app/" rel="noopener ugc nofollow" target="_blank">万亿</a></li><li id="63c8" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://blog.stackpath.com/static-content/" rel="noopener ugc nofollow" target="_blank">什么是静态内容？静态内容如何工作(stackpath.com)</a></li><li id="6e09" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://api.rocket.rs/v0.4/rocket/response/struct.Flash.html" rel="noopener ugc nofollow" target="_blank">火箭闪光::响应—生锈</a></li><li id="43b6" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://blog.hubspot.com/website/pagination-vs-infinite-scroll" rel="noopener ugc nofollow" target="_blank">分页与无限滚动:哪一个对你的内容更好？(hubspot.com)</a></li><li id="cc8f" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><a class="ae kv" href="https://sqlbolt.com/lesson/filtering_sorting_query_results" rel="noopener ugc nofollow" target="_blank"> SQLBolt —学习SQL — SQL第四课:查询结果的过滤和排序</a></li></ul></div></div>    
</body>
</html>