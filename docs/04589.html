<html>
<head>
<title>How to Improve Docker Image Size With Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用图层改善Docker图像大小</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-improve-docker-image-size-with-layers-3ad62be0da9b?source=collection_archive---------3-----------------------#2020-04-23">https://betterprogramming.pub/how-to-improve-docker-image-size-with-layers-3ad62be0da9b?source=collection_archive---------3-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1af7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化您的容器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd67d0864c5d3ea7520b1739e958812d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eABiEHEHdNkjGXoS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@hasanalmasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈桑·阿尔马西</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7cfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将深入探讨Docker的联合文件系统(UFS)层。我将试着解释图层是如何工作的，然后如何正确地使用它们来缩小你的图片。</p><p id="7f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有想过为什么你的Docker图片会如此巨大？或者，您可能已经从映像中删除或卸载了一些内容，但大小并未改变。那是因为你在和UFS的层作对。一旦你知道了图层是如何工作的，你就可以更容易地创建更小的图像，并且更好地控制所有的变化。让我们从头开始:那些层是什么？</p><p id="6581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果你正在寻找一个如何最小化你的图像尺寸的解决方案，只需滚动图层部分。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7ff3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">层解释</h1><p id="4681" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">码头集装箱是由多层构成的。每当我们添加、更改或删除文件时，我们都会在旧层之上添加一个新层。所有这些层的组合或联合是用户或容器所看到的；这是从上到下的视图。另一方面，实际分层视角不同。</p><p id="631b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说例子。我们将使用Ubuntu映像创建一个新容器，并向其中添加一个新文件。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="b144" class="nc ma iq my b gy nd ne l nf ng">docker run --name mod_ubuntu ubuntu:latest touch /mychange</span></pre><p id="5bd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用<code class="fe nh ni nj my b">docker diff</code>和al看到文件系统的所有变化。带<code class="fe nh ni nj my b">docker history</code>的图层。让我们检查一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/ee9fa795addaf2ea6d1bfa7db014a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ymrExsNkspYYVnGIYJeKg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼克洛夫，J. (2016) <a class="ae kv" href="https://www.manning.com/books/docker-in-action-second-edition" rel="noopener ugc nofollow" target="_blank">诉讼中的码头工人</a></p></figure><p id="9dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用<code class="fe nh ni nj my b"><a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/diff/" rel="noopener ugc nofollow" target="_blank">docker diff</a></code>看到文件系统的所有变化，用<code class="fe nh ni nj my b"><a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/history/" rel="noopener ugc nofollow" target="_blank">docker history</a></code>看到所有层的变化。让我们检查一下。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="b2d0" class="nc ma iq my b gy nd ne l nf ng">docker diff mod_ubuntu</span><span id="d64b" class="nc ma iq my b gy nl ne l nf ng"># output<br/>A /mychange</span></pre><p id="830d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字母<code class="fe nh ni nj my b">A</code>表示该文件已被添加。总共有三个选项，它们是:</p><ul class=""><li id="6a60" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><code class="fe nh ni nj my b">A</code> —添加了文件或目录</li><li id="799c" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe nh ni nj my b">C</code> —文件或目录被更改</li><li id="f43c" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe nh ni nj my b">D</code> —文件或目录被删除</li></ul><p id="90a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下新图像中的所有图层。为此，我们首先必须提交它并标记它。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a413" class="nc ma iq my b gy nd ne l nf ng">docker commit mod_ubuntu mod_ubuntu:latest</span></pre><p id="4a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以运行<code class="fe nh ni nj my b">history</code>来查看所有的图层。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="3d68" class="nc ma iq my b gy nd ne l nf ng">docker history mod_ubuntu</span></pre><p id="60f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/b8a03a17fd592fc2ee42b643f1b90f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-FsCh2aDxir4c1J0IRpeA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker历史输出</p></figure><p id="5aae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到原始图像的所有图层，然后是我们的图层。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="586d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们通过提交不断地添加、删除和更改文件到映像，我们的映像将会变大。重要的一点是，图像的大小是所有图层的总和。</p><p id="3563" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看另一个例子。我们将使用我们的<code class="fe nh ni nj my b">mod_ubuntu</code>图像，添加<code class="fe nh ni nj my b">git</code>，然后将其命名为<code class="fe nh ni nj my b">git_ubuntu</code>。要做到这一点，我们必须运行一个容器并进入它的终端。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7c91" class="nc ma iq my b gy nd ne l nf ng">docker run -it --name git_ubuntu mod_ubuntu /bin/bash</span><span id="0b2e" class="nc ma iq my b gy nl ne l nf ng">#output<br/>root@898d6e1aef74:/#</span></pre><p id="fb28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在我们的容器中，所以让我们更新工具并安装<code class="fe nh ni nj my b">git</code>。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="3170" class="nc ma iq my b gy nd ne l nf ng">apt-get update &amp;&amp; apt-get -y install git</span></pre><p id="4fe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们会看到大量的文本。完成后，只需输入<code class="fe nh ni nj my b">exit</code>。现在，我们希望将容器提交为一个新的图像，这次使用提交消息，这样我们就知道添加了什么。用<code class="fe nh ni nj my b">-m</code>或<code class="fe nh ni nj my b">--message</code>添加信息。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a0e0" class="nc ma iq my b gy nd ne l nf ng">docker commit -m "added git" git_ubuntu git_ubuntu:latest</span></pre><p id="1dcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该看到新的图像id作为确认。让我们看看我们所有的图像。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4125" class="nc ma iq my b gy nd ne l nf ng">docker image ls</span></pre><p id="912e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/0871fb2aa4629d220359e36ca427869e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYkof1YCBIt5OsHhurzFaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker图像列表</p></figure><p id="af11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的新形象更大了。我们也可以用<code class="fe nh ni nj my b">docker history git_ubuntu</code>检查它的图层。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0b184995523579ddccf1e62df8eb5f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XOPGy63ja_ZC4ikzfW06w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新图像的Docker历史记录</p></figure><p id="9fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有两层，我们从<code class="fe nh ni nj my b">mod_ubuntu</code>扩展的旧层和安装了<code class="fe nh ni nj my b">git</code>的新层。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="af73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们创建另一个图像。这一次，我们将使用<code class="fe nh ni nj my b">git_ubuntu</code>，卸载<code class="fe nh ni nj my b">git</code>，删除<code class="fe nh ni nj my b">mychange</code>文件，然后创建一个新的映像。新图像将被称为<code class="fe nh ni nj my b">plain_ubuntu</code>。理论上，我们删除了所有内容，所以我们应该以与<code class="fe nh ni nj my b">ubuntu:latest</code>相同的大小结束。让我们看看会发生什么。</p><p id="e9dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次运行<code class="fe nh ni nj my b">plain_ubuntu</code>容器的终端和那里的所有操作。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="12aa" class="nc ma iq my b gy nd ne l nf ng">docker run -it --name plain_ubuntu git_ubuntu /bin/bash</span><span id="334b" class="nc ma iq my b gy nl ne l nf ng">#output<br/>root@cace613e4176:/#</span><span id="9094" class="nc ma iq my b gy nl ne l nf ng">#in container's terminal<br/>apt-get uninstall -y git &amp;&amp; rm mychange</span><span id="5001" class="nc ma iq my b gy nl ne l nf ng">#then<br/>exit</span><span id="522e" class="nc ma iq my b gy nl ne l nf ng">#finally commit changes<br/>docker commit -m "removed git" plain_ubuntu plain_ubuntu</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/46fa268ba8203f26e6dca57f525852f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36W9yy4EH17Jhekg3Y0Jyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像列表</p></figure><p id="0aec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，新图像比以前的大。差别不大，但还是应该小一些。现在让我们看看它的层次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/4c4269720e1b45295b177d1a4ef35eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Rc5ylQNpg5pbCRyLBcm2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">plain_ubuntu映像的所有提交</p></figure><p id="ad08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个结果背后的原因是，每次我们提交一些东西，我们就增加了一个新的层。正如我前面提到的，图像的总大小是所有图层的总和。下图显示了发生这种情况的原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/a670b8231164d612b4e28926093dbd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf-5mtP8NZD_JKsmiCVvjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼克洛夫，J. (2016) <a class="ae kv" href="https://www.manning.com/books/docker-in-action-second-edition" rel="noopener ugc nofollow" target="_blank">诉讼中的码头工人</a></p></figure><p id="c5bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从用户的角度来看，我们只能看到所有操作后留下的文件，但在引擎盖下，一切都还在。我们添加和移除的所有东西仍然在我们的图像中。这通常是有帮助的，因为我们可以访问所有的提交，所以我们知道发生了什么以及什么时候发生的。然而，如果我们想运送小图像，我们必须考虑和处理它。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a0bd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">管理尺寸</h1><p id="e3df" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有两种方法可以缩小图像。一个相当残酷，但简单有效。第二种更乏味，但显然更加敏捷和健壮。</p><p id="e151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的方法就是用Docker导出图片，然后再导入。越复杂的越像做全流程。</p><h2 id="c438" class="nc ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">展平图像</h2><p id="d013" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个过程将创建一个<em class="mw">展平的</em>图像。顾名思义，所有层将被展平到只有一个。这将显著减小尺寸，但绝不会减到最小。它应该只用于我们不需要跟踪变更、提交等的简单图像。；它只是一个简单的容器。</p><p id="eb1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续前面的例子。我们有基本上是T1的T0图像，但是它的大小和T2一样。我们能做的就是用<code class="fe nh ni nj my b"><a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/export/" rel="noopener ugc nofollow" target="_blank">docker export</a></code>在本地导出到一个文件。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7ea9" class="nc ma iq my b gy nd ne l nf ng">docker export -o plain_ubuntu.tar plain_ubuntu</span></pre><p id="fff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制台中有输出，但我们最终得到的是图像的存档。重要的一点是，它只导出容器，不考虑容器体积。</p><p id="a85c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，下一步是将图像导入回来。我们和<code class="fe nh ni nj my b"><a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/import/" rel="noopener ugc nofollow" target="_blank">docker import</a></code>一起做。让我们将新导入的图像标记为<code class="fe nh ni nj my b">plain_ubuntu:imported</code>，这样我们以后可以更容易地找到它。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="bde6" class="nc ma iq my b gy nd ne l nf ng">docker import plain_ubuntu.tar plain_ubntu:imported</span></pre><p id="d20f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制台将返回新图像的id作为确认。现在我们等待的时刻。通过扁平化我们节省了多少空间？<br/>我们来看看<code class="fe nh ni nj my b">docker images ls</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7c93f037185cfe231e35ec1e74c9464e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*he8CckUZQMq9IH3KIA7o0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">顶部带有导入的所有图像的列表</p></figure><p id="ab6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它更小，这是一点，但它甚至没有接近原来的<code class="fe nh ni nj my b">ubuntu_latest</code>。现在让我们用<code class="fe nh ni nj my b">docker_history</code>检查它的提交。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5b6a" class="nc ma iq my b gy nd ne l nf ng">docker history plain_ubntu:imported</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/77e3d2af0e53909fd861af52ce7695b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW71epWlo5UrEOhxKytnHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">展平图像的提交历史记录</p></figure><p id="634f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用导出和导入，我们丢失了关于提交历史的所有信息，但是我们节省了一些空间。这是一种快速简单的方法，但是正如我提到的，只适用于简单的图像，我们不关心版本和历史。</p><h2 id="7ea4" class="nc ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">分支</h2><p id="627c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个想法是分支变更，正确地标记它们，并在需要时重用它们。它增加了更多的手动工作，因为有时我们必须返回并从头开始，但它会缩小图像的大小。此外，它们将只包含必需的文件，没有任何不必要的附加。</p><p id="fdf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们添加、更改或删除某些东西(基本上是可以添加更多层和增加图像大小的任何东西)时，我们都应该提交一个带有适当标签的新图像。想法是将变更标记为次要版本或补丁。我们应该特别关注补丁。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/701f0d029386829e2a92f9bae393bc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erQ6swW9671cavc3mv3xsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼克洛夫，J. (2016) <a class="ae kv" href="https://www.manning.com/books/docker-in-action-second-edition" rel="noopener ugc nofollow" target="_blank">诉讼中的码头工人</a></p></figure><p id="88b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据上面的例子，详细的标签不仅可以帮助我们管理图像的历史和大小，还可以帮助使用我们图像的人。虚线表示图像和标签之间的先前连接，实线表示当前连接。我们可以给图像分配和重新分配标签。一张图片可以有几个标签，所以不要害怕标签。这只会有所帮助。</p><p id="e867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们修改过的Ubuntu映像的例子中，从头开始，我们可以将它标记为<code class="fe nh ni nj my b">1.0.0</code>。然后我们添加<code class="fe nh ni nj my b">mychange</code>并创建一个标签为<code class="fe nh ni nj my b">1.0.1</code>的新图像作为补丁。然后我们决定安装<code class="fe nh ni nj my b">git</code>，所以让我们现在把<code class="fe nh ni nj my b">1.1.0</code>作为一个次要版本。我们做了一些工作，决定给我们的图像增加一点，所以现在我们把它标记为<code class="fe nh ni nj my b">1.1.1</code>。现在我们决定卸载<code class="fe nh ni nj my b">git</code>；这就是体力劳动发挥作用的地方。</p><p id="7338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该采取我们的<code class="fe nh ni nj my b">1.0.1</code>形象和分支。然后，我们添加我们在<code class="fe nh ni nj my b">1.1.1</code>中所做的更改，并将其标记为<code class="fe nh ni nj my b">1.0.2</code>，例如。当然，有时这很乏味，但从长远来看，我们最终会得到包装精美的图像和正确标记的回购协议。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="464a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="0058" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们总结一下我们所知道的:</p><ul class=""><li id="fa31" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">每当我们提交一些东西，我们就增加一个新的层次。</li><li id="f75a" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">图像是一堆层，用户只能看到最上面的一层。</li><li id="e33e" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">图像大小是所有图层的总和。</li><li id="0d78" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">我们可以通过导出和导入来展平图像，但是我们会丢失提交历史。</li><li id="b6f2" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">我们可以给一张图片分配几个标签。</li><li id="9b61" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">我们应该慷慨解囊。</li><li id="453b" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">不要忘记为实际的最新版本保留<code class="fe nh ni nj my b">latest</code>标签。</li></ul><p id="e477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章很长，但是了解层是如何工作的对于完全理解如何适当地优化容器大小是非常重要的。希望你安然无恙地度过了难关！谢谢你。</p></div></div>    
</body>
</html>