<html>
<head>
<title>Simplifying Bloc State Management in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化颤振中的阻塞状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplifying-bloc-state-management-in-flutter-a8de43a994e4?source=collection_archive---------6-----------------------#2020-04-01">https://betterprogramming.pub/simplifying-bloc-state-management-in-flutter-a8de43a994e4?source=collection_archive---------6-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="36ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Bloc实现Flutter中更干净的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51b30259cdb2dafd056f3f9a76c98ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV7KLGiy7GNYMT21raimMA.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="0940" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你一直在开发Flutter应用程序，你应该知道以最好的方式管理应用程序的状态是至关重要的。</p><p id="d19d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Flutter为我们提供了许多状态管理选项，比如Provider、Bloc、Redux和MobX。</p><p id="51a1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">今天，我们来看看集团。</p><p id="f176" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我知道这可能有点难以理解，对我来说也是如此。但现在我想我明白了，所以我来为你简化一下。</p><p id="7212" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们知道，在Flutter中，很容易将UI逻辑与业务逻辑混淆，这并不是开发可维护应用程序的最佳方式。</p><p id="8ae1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Bloc为你的应用程序提供了一个更好的结构——通过分离应用程序的UI和业务逻辑。但是在我们进入如何实现它之前，让我们先了解一下…</p><p id="dd42" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这篇文章会有点长，但是作为一个初学者，到最后你会对如何使用Bloc充满信心。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="bc10" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak"> Bloc </strong>到底是什么？</h1><p id="e064" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated"><em class="mw"> Bloc </em>代表<em class="mw">业务逻辑和组件。</em>它就像一个黑匣子，把你所有的业务逻辑(和相关的组件)包装起来，把各种app事件映射到app状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/bfb970527f3feb40a0462fa0d4c4b8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYqDFIhvQpxamBjw7JRbVQ.png"/></div></div></figure><p id="8669" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果这个定义对你来说太专业了，让我们通过几个例子来更好地理解它。</p><h2 id="19ab" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated">如果您正在使用天气应用程序:</h2><p id="8483" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">你的应用程序中会有各种各样的事件，比如<code class="fe nk nl nm nn b">getWeather()</code><code class="fe nk nl nm nn b">setLocation()</code><code class="fe nk nl nm nn b"> </code>和<code class="fe nk nl nm nn b">resetWeather()</code>，这些事件会被用户的动作或者你的应用程序的一些内部逻辑所触发。</p><p id="d699" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">成功执行操作后，这些操作将相应地用新状态更新您的应用程序的UI。</p><h2 id="7170" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated"><strong class="ak"> <em class="no">再比如——默认的颤振计数器app </em> </strong></h2><p id="282f" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这里只有一个事件，那就是<code class="fe nk nl nm nn b">incrementCounter</code>，它生成新的状态，显示计数器的递增值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b00de68f923172d65e2e576da8c8de50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOCifupkxLKJzLYfX8r_IQ.png"/></div></div></figure><p id="9b70" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">bloc</code>是一个黑盒，告诉你应该对哪个事件执行哪个操作，然后在操作完成后应该产生哪个状态。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="7ec0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">你如何为你应用程序定义阻塞？</h1><h2 id="8331" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated">要付出一点小小的代价</h2><p id="c659" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">Bloc的一个主要缺点是我们必须编写大量的样板代码——即使是最小的UI更改。</p><p id="556d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是我到目前为止看到的唯一缺点，但它确实通过将所有UI逻辑从业务逻辑中分离出来简化了你的应用程序代码。</p><p id="e923" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，您可以将所有样板代码作为一种投资，使您的代码易于维护和理解。</p><h2 id="8fae" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated">这是你得到的</h2><p id="499a" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">例如，假设您正在使用Bloc构建一个天气应用程序。您已经定义了所有的事件和状态，您的应用程序运行良好。</p><p id="7b22" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在，如果您必须在同一个屏幕中添加另一个功能，您可以非常简单地在您的<code class="fe nk nl nm nn b">bloc</code>中定义一个新事件和一个新状态，以及如何将新事件映射到一个新状态的一点逻辑。</p><p id="e8bb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">你完了！你不需要接触/干扰其他已构建的事件和状态，你可以非常简单地添加你的新特性集，不会有太大的问题。</p><p id="798e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这类似于固体原理的开闭原理告诉你要做的事情。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1ad4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我们将会建造什么</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/25dd528270277bfc6c8ae99c0cb189f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxvOQcX27mlt9OmM2F2JHQ.png"/></div></div></figure><p id="1ce5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将构建一个计数器应用程序的修改版本，这将帮助您更清楚地了解<code class="fe nk nl nm nn b">bloc</code>。</p><p id="28f1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">将有四个按钮:</p><ul class=""><li id="e368" class="nr ns it ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><strong class="ky iu">递增计数器值:</strong>即时更新计数器值</li><li id="67cb" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><strong class="ky iu">递减计数器值:</strong>立即更新计数器值</li><li id="37b5" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><strong class="ky iu">生成随机值:</strong>我们将模拟一些延迟，然后更新该值</li></ul><p id="1733" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你理解了需求，你可以看到我们上面加粗的是事件，冒号右边的解释是状态。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c25e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">1.将这些依赖项添加到您的pubspec.yaml中</h1><p id="f419" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">截至2020年3月，我将为Flutter添加这种依赖性。</p><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="ba57" class="my ma it nn b gy oj ok l ol om">flutter_bloc: ^3.2.0<br/>equatable: ^1.1.0</span></pre><p id="f2e2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b"><a class="ae on" href="https://pub.dev/packages/bloc" rel="noopener ugc nofollow" target="_blank">bloc</a></code>是由bloclibrary.dev团队创建的库，它提供了<code class="fe nk nl nm nn b">bloc</code>模式的核心基础。但是它稍微复杂一点——因此，我们得到了<code class="fe nk nl nm nn b"> flutter_bloc</code>,由同一个团队创建，只是为了让Flutter开发者更容易。</p><p id="0a9d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">谢谢团队！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="b4e8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">2.创建您的“集团”类</h1><p id="8a4b" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我的UI代码将在<code class="fe nk nl nm nn b">counter_screen.dart</code>文件内的<code class="fe nk nl nm nn b">CounterScreen</code>中。<br/>(我们稍后会谈到UI部分。)</p><p id="6091" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">用名称<code class="fe nk nl nm nn b">counter_screen_bloc.dart</code>为您的<code class="fe nk nl nm nn b">bloc</code>类创建一个新的Dart文件。我们将定义这个<code class="fe nk nl nm nn b">bloc</code>类文件。</p><p id="e352" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在<code class="fe nk nl nm nn b">bloc</code>屏幕中，我们将定义三样东西:</p><ul class=""><li id="9f47" class="nr ns it ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><strong class="ky iu">事件:</strong>显示所有可能的事件</li><li id="3903" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><strong class="ky iu">状态:</strong>显示所有可能的状态</li><li id="bfff" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">如何将这些事件映射到状态</li></ul><p id="ad97" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这些是后续步骤所需的导入语句。</p><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="63b7" class="my ma it nn b gy oj ok l ol om">import 'package:bloc/bloc.dart';<br/>import 'package:equatable/equatable.dart';</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="bb16" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">3.定义事件</h1><p id="a9ff" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在空白的<code class="fe nk nl nm nn b">bloc</code>类文件中，首先定义一个事件。</p><p id="ea3d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我把它命名为<code class="fe nk nl nm nn b">CounterScreenEvent</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8b1e7629ca5826ccac1fb659fb8817e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CeajsNhQ0ISLDLw9R4xsA.png"/></div></div></figure><p id="6a47" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">Equatable</code>使我们的类等价/可比，这是<code class="fe nk nl nm nn b">bloc</code>类内部映射逻辑所需要的。</p><p id="467b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">Equatable</code>要求您像我们在这里所做的那样覆盖<code class="fe nk nl nm nn b">get props</code>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="907c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">4.定义状态</h1><p id="4638" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在这些下面，让我们定义每一个将被映射到的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/3806b5219d1994b9772ccd72373709a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-yaMYBIuB8czMEBmSSj8w.png"/></div></div></figure><h2 id="0e8c" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated"><strong class="ak">为什么，就两个状态？</strong></h2><p id="15c1" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">用户要么会在屏幕上看到递增/递减的计数器值，要么会在我们试图生成模拟网络呼叫的随机数时看到加载屏幕。</p><p id="8301" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">ShowCounterValue</code>状态将有一个与之相关联的计数器值。因此，我们在该类中定义了一个名为<code class="fe nk nl nm nn b">counterValue</code>的属性，帮助您将计数器值从Bloc传递到应用程序的UI。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="962b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">5.最后，定义我们的“集团”</h1><p id="2ac3" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">是的，我们终于可以定义我们的<code class="fe nk nl nm nn b">bloc</code>。</p><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="2bdc" class="my ma it nn b gy oj ok l ol om"><em class="mw">/// BLoC<br/></em>class <strong class="nn iu">DashboardScreenBLoC</strong> extends Bloc&lt;<strong class="nn iu">CounterScreenEvent</strong>, <strong class="nn iu">CounterScreenState</strong>&gt; {</span><span id="9682" class="my ma it nn b gy oq ok l ol om">  <strong class="nn iu">int counterValue = 0;</strong></span><span id="31f5" class="my ma it nn b gy oq ok l ol om">@override<br/>  CounterScreenState get <strong class="nn iu">initialState</strong> =&gt; <strong class="nn iu">ShowCounterValue</strong>(<strong class="nn iu">counterValue</strong>);<br/><br/>  @override<br/>  Stream&lt;CounterScreenState&gt; <strong class="nn iu">mapEventToState</strong>(CounterScreenEvent event) <strong class="nn iu">async*</strong> {<br/>    // <em class="mw">TODO : Map event to state<br/>  </em>}<br/>}</span></pre><ul class=""><li id="54af" class="nr ns it ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">在第一行中，我们有<code class="fe nk nl nm nn b">DashboardScreenBloc</code>，它扩展了前面定义的<code class="fe nk nl nm nn b">Bloc&lt;Event,State&gt;</code></li><li id="aaf0" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">我们为我们的计数器值定义了一个名为<code class="fe nk nl nm nn b">counterValue</code>的属性，它将用于维护我们的计数器的状态</li><li id="81cc" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">现在我们要定义<code class="fe nk nl nm nn b">initialState</code>。当<code class="fe nk nl nm nn b">bloc</code>加载时，初始状态将被设置为<code class="fe nk nl nm nn b">ShowCounterValue(counterValue)</code>。</li><li id="1c1d" class="nr ns it ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">最后，我们有一个<code class="fe nk nl nm nn b">mapEventToState</code>函数(正如它的名字所表示的那样)。如果你看一下这个函数，你会看到它被标记为<code class="fe nk nl nm nn b">async*</code>。</li></ul><p id="9882" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了让大家保持一致，我将解释一下<br/> <code class="fe nk nl nm nn b">async</code>和<code class="fe nk nl nm nn b">async*</code>。</p><p id="60f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果您的函数在执行某个操作后返回一个未来值，我们将该函数标记为<code class="fe nk nl nm nn b">async</code>。这些函数只返回值一次，它们的执行以return语句结束。</p><p id="c415" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">另一方面，标记为<code class="fe nk nl nm nn b">async*</code>的函数返回一个流。这个函数产生不同的值，并不只是返回它们。它们的执行仍在继续，并且它们可以产生您想要的任意多的值。</p><p id="d8d2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这就是为什么它们的输出被称为<em class="mw">流。</em></p><p id="40ed" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们通过将事件映射到状态来结束我们的<code class="fe nk nl nm nn b">bloc</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/398e736e377cee2b6a93275bbabbc5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZpPvLnvmIKNY7RbU7iRJQ.png"/></div></div></figure><p id="3017" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">下面是完整的<code class="fe nk nl nm nn b">counter_screen_bloc.dart</code>代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os kv l"/></div></figure><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="1bce" class="my ma it nn b gy oj ok l ol om">Important Thing To Know</span></pre><p id="57eb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">关于<code class="fe nk nl nm nn b">bloc</code>需要知道的一件重要事情是，如果<code class="fe nk nl nm nn b">nextState == currentState</code>的计算结果为<code class="fe nk nl nm nn b">true</code>，那么<code class="fe nk nl nm nn b">bloc</code>会忽略状态转换。</p><p id="659c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果您不将state类扩展为<code class="fe nk nl nm nn b">Equatable</code>，那么您将从<code class="fe nk nl nm nn b">yield</code>调用的所有状态都将被视为唯一的。</p><p id="4b81" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果这符合您的要求，您不应该太麻烦，但是如果有可能会出现一个接一个重复的状态，为什么要浪费您的性能来重建相同的状态呢？</p><p id="60ae" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，我们扩展了<code class="fe nk nl nm nn b">Equatable</code>并覆盖了<code class="fe nk nl nm nn b">props</code>方法。</p><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="1de3" class="my ma it nn b gy oj ok l ol om">class ShowCounterValue extends CounterScreenState {<br/>  @override<br/>  List&lt;Object&gt; get props =&gt; [counterValue];</span><span id="9335" class="my ma it nn b gy oq ok l ol om">  final int counterValue;</span><span id="acd1" class="my ma it nn b gy oq ok l ol om">  ShowCounterValue(this.counterValue);<br/>}</span></pre><p id="cf90" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你不覆盖<code class="fe nk nl nm nn b">props</code>方法，你的<code class="fe nk nl nm nn b">bloc</code>将不知道如何比较这两个状态类，并且很可能将它们视为相同。因此，您不会看到新状态被触发。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="adb8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">6.让我们在用户界面上工作</h1><h2 id="0159" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated"><strong class="ak">从main.dart开始</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/99c6377e29e7f539f9706fc1881726ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbJQ69TeSFlgKWRH2-NinQ.png"/></div></div></figure><p id="d224" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因为我们在名为<code class="fe nk nl nm nn b">CounterScreen</code>的UI中使用了名为<code class="fe nk nl nm nn b">CounterScreenBloc</code>的<code class="fe nk nl nm nn b">bloc</code>，所以我们使用了一个<code class="fe nk nl nm nn b">BlocProvider</code>并定义了哪些<code class="fe nk nl nm nn b">bloc</code>必须提供什么。</p><p id="21d1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这里是完整的<code class="fe nk nl nm nn b">main.dart</code>代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os kv l"/></div></figure><h2 id="e866" class="my ma it bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated"><strong class="ak">让我们看看里面的</strong> <code class="fe nk nl nm nn b"><strong class="ak">'counter_screen.dart’</strong></code></h2><p id="0246" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在<code class="fe nk nl nm nn b">CounterScreen</code>的<code class="fe nk nl nm nn b">build</code>函数中，我们必须初始化<code class="fe nk nl nm nn b">bloc</code>。类似地，在dispose函数中，我们必须关闭我们的<code class="fe nk nl nm nn b">bloc</code>来避免内存泄漏。</p><pre class="kj kk kl km gt of nn og oh aw oi bi"><span id="9e80" class="my ma it nn b gy oj ok l ol om">It's a good practice to dispose the bloc in the <strong class="nn iu">dispose()</strong> function of the same widget whose <strong class="nn iu">build()</strong> you may have used to initialize the bloc.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f372b747d5ff5245d1f95363454a578b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUvGyHR1AAN6MWQa7ZYOEw.png"/></div></div></figure><p id="f4d1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">以下是完整的<code class="fe nk nl nm nn b">counter_screen.dart</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os kv l"/></div></figure><p id="7507" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">就是这样！你应该有一个正常工作的项目。</p><p id="e8ab" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">下面是整个项目的代码:</p><div class="ov ow gp gr ox oy"><a href="https://github.com/devDeejay/Flutter_Bloc_Counter_Example" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">devDeejay/Flutter _ Bloc _ Counter _ Example</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">新的颤振应用。这个项目是颤振应用的起点。一些资源让你…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="7c28" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="3bb9" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">就是这样！这就是你需要知道的，用干净的代码构建一个超棒的Flutter应用程序——这都要感谢Bloc。</p><p id="6c7e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">同样，您看到的样板代码是保持代码可维护性的一种投资。</p><p id="f640" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">也正因为如此，我不建议你在所有的屏幕上都应用它——只有在涉及到很多不同状态的时候。</p><p id="be3a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">否则，<a class="ae on" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> Provider </a>是另一个很好的状态管理解决方案，可以在应用程序中提供更简单的特性。</p></div></div>    
</body>
</html>