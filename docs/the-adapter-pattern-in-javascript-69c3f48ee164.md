# JavaScript 中的适配器模式

> 原文：<https://betterprogramming.pub/the-adapter-pattern-in-javascript-69c3f48ee164>

## 用例子来帮助你实现它

![](img/f55f67cd3130ddcb7ee60068d19de804.png)

照片由 [Daryan Shamkhali](https://unsplash.com/@daryan?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄。

你有没有遇到过以`Adapter`作为函数后缀的代码？您可能正在阅读包含使用适配器模式的两个接口之间行为兼容性的代码。本文将介绍 JavaScript 中的适配器模式，并解释为什么该模式很重要，以及为什么它在现代编程中是有益的。

适配器的工作方式是您创建一个函数(可以是一个类，但不一定要实现为一个类)，让*无缝地将其接口的属性和方法适应*到一个新的类中——就好像适配器仍然可以被识别并像原来一样工作，同时能够与新的接口一起工作。

随着 JavaScript 中的 web 技术不断发展，很容易看到这种模式在今天的开源项目中使用(例如 [axios-mock-adapter](/axios-mock-adapter) )。

# 看起来怎么样

用 JavaScript 编写适配器模式没有正确的方法。然而，它们都有相同的目标:提供一个接口到另一个接口的兼容性。

例如，如果我们有一个函数，它接受一个对象列表(在接下来的例子中，我们将每个对象都称为*动作对象*)，并在将它们传递给另一个调用它们的每一个`execute`方法的函数之前，将它们转换为数组中的`Action`实例，那么如果想要保持兼容性，任何对实现的新介绍都应该遵循类似的接口。

让我们看看这些具有共同`actionType`属性的动作对象:

给定这些类别，我们定义:

假设我们有一个`ActionChain`,它接受动作对象的数组，并为它们的执行做准备:

每个动作都可以在我们的应用程序中顺利运行，因为它们都共享一个兼容的界面。

如果我们想在应用程序中引入一个新的动作，但使用更简洁和健壮的语法，如果新的实现在运行时破坏了你当前的程序，我们就必须记住这个信息。

假设我们在一家公司的前端工作，我们的团队经理想把`pageJump`对象(比如`{ actionType: "pageJump", destination: "/contact" }`)换成更短的语法，比如`{ goto: "/contact" }`。如果我们在应用程序中做这个改变，那么我们的代码就会被破坏。这是因为我们的 runner `runActions`执行了新语法中不存在的`execute`方法。

我们可以通过使用*适配器*支持`goto`动作来解决这个问题，这样程序就可以以同样的方式运行。

我们可以从创建一个扩展基础的类开始`Action`:

由于`goto`基本上只是`pageJump`的另一个版本(它们的最终目标是一样的)，我们可以定义一个不同的适配器，它可以接受两者中的任何一个，并返回可以在`ActionChain`中运行的东西:

这样，我们就可以保持我们的`pageJump`行为方式相同。不仅如此，我们还可以让他们使用`goto`所具有的扩展方法(例如，可以随时访问`this.history`并设置新的 URL)。

现在，我们可以继续进一步开发该应用程序，同时避免在迁移一些旧代码时中断更改:

# 其他示例

我相信，更多来自不同角度的例子可以帮助开发人员更好地理解概念，所以这里有更多利用这种模式的例子。

## 计算器

以下是摘自[要点](https://gist.github.com/drenther/670720f4787a9ba4de967c0e8ee8cd7c)的一个例子:

如果一个计算器应用程序是使用`OldCalculator`编写的，并且您想为它提供一种与`NewCalculator`接口一起工作的方式，您需要某种方式来匹配`NewCalculator`它们的行为方式是相同的。

下面的示例是使用解决该问题的适配器编写的:

## Axios 适配器

在本文的前面，我提到了 axios-mock-adapter，它在代码中使用 adapter 模式，通过支持使用 promises 和原始回调方法来提供兼容性:

这是一个很好的例子，因为它们的语法明显不同。然而，他们最终都实现了自己的目标。这很好！

# 结论

这篇文章到此结束！我希望你觉得这个很有价值。展望未来！