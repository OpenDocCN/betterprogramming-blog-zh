<html>
<head>
<title>How to Create a React App With Email Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建带有电子邮件身份验证的React应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-react-app-with-email-authentication-372a67a6d27b?source=collection_archive---------4-----------------------#2020-01-31">https://betterprogramming.pub/how-to-create-a-react-app-with-email-authentication-372a67a6d27b?source=collection_archive---------4-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9121" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">电子邮件是比任意用户名更好的登录凭证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce33c3c336bd0aaeade6b576e6a9082c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTMg5_SJG8BKz7wqMk_yIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tjevans?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·埃文斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/bank-safe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电子邮件是很好的登录凭证——比任意的用户名好得多。</p><p id="9ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户会忘记凭据，但他们很少会忘记自己的电子邮件地址。每当用户忘记密码时，您可以向他们发送新密码。</p><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为你可以验证电子邮件地址。向输入的电子邮件地址发送确认请求，以确保您网站的用户可以访问电子邮件收件箱。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="49a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何将电子邮件认证添加到React应用程序中</h1><p id="f442" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设你有一个真正的秘密——比如这个React页面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ecb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只授予登录用户访问权限！我们要求用户输入他们的电子邮件地址和密码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/acd924eb1eac08e34331c9f9ecf264a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njNUqDzKEL7Xiy47FHE3KA.png"/></div></div></figure><p id="18cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的登录页面有两个输入框和一个按钮。一个用于电子邮件地址，一个用于密码。我们用一个<a class="ae ky" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">反应状态钩子</a>来控制这两个字段的值。</p><p id="861b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击按钮时，我们检查输入的电子邮件和密码是否正确。我们使用正则表达式来验证电子邮件的格式。如果没有通过验证，我们禁用按钮(意思是，我知道)。</p><p id="a18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦电子邮件有效，我们就检查密码是否与我们的秘密字符串<code class="fe nc nd ne nf b">let-me-in</code>匹配。如果是的话，我们会把用户转到我们的秘密页面！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这两个页面添加到React应用程序中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="b21e" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“你开玩笑吧！”</em> </strong></h2><p id="57fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">显然，这不是很安全。任何电子邮件地址都可以。甚至<em class="nt">foo@fake.com</em>。用户可以查看我们的React应用程序的代码。他们可以很容易地找到他们需要输入的字符串。</p><p id="40ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=https://codeburst.io/why-would-you-implement-a-backend-for-your-react-app-365bb8a8431d" rel="noopener ugc nofollow" target="_blank">大部分React apps不需要后端</a>。但是身份验证是实现身份验证的一个很好的理由——您必须能够信任验证登录凭证的代码。</p><p id="7287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的流程如下所示:</p><ul class=""><li id="98ac" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">前端在请求中向后端发送登录凭据。</li><li id="8cf5" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">后端的可信代码验证凭证。</li><li id="0a6a" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">如果凭证正确，后端将安全数据发送到前端。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1c56f4195a68a80fcccc8f06282e5834.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*UlfEOOccQaakKPtG3BHDlw.png"/></div></figure><p id="ce00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=/www.infrastructure-components.com" rel="noopener ugc nofollow" target="_blank">基础设施组件</a>创建这个软件架构。这些类似React的组件<a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=https://medium.com/dailyjs/do-you-like-react-then-why-dont-you-configure-your-infrastructure-with-it-e8cb36e742a2" rel="noopener ugc nofollow">为我们做技术配置</a>，让我们轻松地创建一个带有后端的React应用。</p><div class="oj ok gp gr ol om"><a href="https://codeburst.io/why-dont-you-use-server-side-rendering-in-your-react-app-acd51359c4b4" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">为什么不在React应用中使用服务器端渲染？</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">如果复杂是原因，那么这是给你的！</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">codeburst.io</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><p id="74dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个同构的应用程序。这是一个具有服务器端和客户端渲染的React web应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="be6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe nc nd ne nf b">&lt;LoginPage/&gt;</code>按钮中，我们用<code class="fe nc nd ne nf b">authCallback</code>函数替换了硬编码的密码验证。我们提供了<code class="fe nc nd ne nf b">email</code>、<code class="fe nc nd ne nf b">password</code>，以及到我们秘密页面的路径(<code class="fe nc nd ne nf b">/secret</code>)。我们希望这个函数在后端进行验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bfd5" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“介绍一个神奇功能的好称呼！但是我们的秘密页面仍然不安全。知道'/secret '路径还是可以打开的！”</em> </strong></h2><p id="6285" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当然，我们需要限制对安全路线的访问。姑且称之为<code class="fe nc nd ne nf b">&lt;SecuredRoute path="/secret" ... /&gt;</code>。它告诉我们的应用程序，这条路线必须得到保护，而<code class="fe nc nd ne nf b">&lt;Route path="/login" ... /&gt;</code>仍然可以访问。</p><p id="647c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了一个<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>组件来确保用户只有在登录后才能访问<code class="fe nc nd ne nf b">&lt;SecuredRoute/&gt;</code>。否则，它会将它们重定向到<code class="fe nc nd ne nf b">&lt;LoginPage/&gt;</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/329bfc4a24987a656d475abf2189e99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*m0Us0USc5KNGFmKNjnWNKw.png"/></div></figure><p id="009b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们将<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>包裹在整个<code class="fe nc nd ne nf b">&lt;WebApp/&gt;</code>的周围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f328" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“太好了！更神奇！但是服务器怎么知道一封邮件和一个密码是否匹配呢？”</em> </strong></h2><p id="990b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的应用需要一个持久的数据层。某个可以存储凭证的地方。我们为什么不在我们的应用程序中添加一个<code class="fe nc nd ne nf b">&lt;DataLayer/&gt;</code>？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/8c013d4e216012e5d9f25cbefc6a4532.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*oN6NBNwPqIVLJ35v-qmuDw.png"/></div></figure><p id="c765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，它是我们的<code class="fe nc nd ne nf b">&lt;WebApp/&gt;</code>的另一个包装组件。我们指定<code class="fe nc nd ne nf b">loginUrl</code>让它知道将未授权的用户重定向到哪里。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="517f" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“我都不敢问！但是我们如何让用户进入数据层呢？”</em> </strong></h2><p id="57e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我很高兴你问了。我们的<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>验证用户是否在数据中。如果没有，<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>会向用户输入的地址发送一封电子邮件。如果她可以访问收件箱，她可以通过单击链接来验证电子邮件地址。</p><p id="385e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>可以将电子邮件地址作为<code class="fe nc nd ne nf b">pending</code>存储在数据层中，旁边还有一个令牌，它也会将其放入验证链接中。当<code class="fe nc nd ne nf b">tustworthy code</code>收到带有令牌的请求时，它会验证令牌是否匹配并激活帐户。从那里开始，用户可以登录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/dd538ab58532c967bb4205c0fcd54acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*VRbYxcxnhefKY3irktIJ-g.png"/></div></figure><p id="f7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来看看我们的增强型<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>。我们指定发送电子邮件所需的所有数据。<code class="fe nc nd ne nf b">callbackUrl</code>是当用户点击邮件中的链接时，我们后端接收确认请求的路径。我们通过回调函数来指定邮件主题和文本。<code class="fe nc nd ne nf b">getHtmlText</code>提供<code class="fe nc nd ne nf b">recipient</code>的电子邮件地址和准备好的确认<code class="fe nc nd ne nf b">url</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f9c0" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“用户离开后重新打开页面会发生什么？他们必须再次输入凭据吗？”</em> </strong></h2><p id="0aa3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这不会带来很好的用户体验，不是吗？</p><p id="720e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的认证保持用户会话。但是React不这样做。如果您重新加载一个页面(F5)或在浏览器中输入一个新的URL，您将获得一个“新的”实例。所有本地存储的数据都将丢失。</p><p id="c92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络提供了一个解决方案——cookies！cookie是用户计算机上的一个小文件，其大小足以保存用户身份和验证令牌。它跨浏览器会话保存数据。更重要的是，浏览器会自动将cookie发送到服务器。每当用户键入应用程序的URL时，浏览器都会发送它。当然，我们需要将cookie数据存储在数据层中。<code class="fe nc nd ne nf b">trustworthy code</code>需要验证一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/75dc3ee33f13ad01b171132255114b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*MPrX6lVqw0TBwBZxOMKcbA.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c17f" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated"><strong class="ak"> <em class="ns">“当用户自动发送cookie时，如果用户离开电脑怎么办？任何人都可以接触到它。”</em> </strong></h2><p id="da1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要实现一个删除cookie的<code class="fe nc nd ne nf b">userLogout</code>函数。让我们给<code class="fe nc nd ne nf b">&lt;SecretPage/&gt;</code>添加一个按钮来调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="05a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，很多。但是我们的React应用并不复杂。我们在应用程序中增加了另一层。<code class="fe nc nd ne nf b">&lt;Identity/&gt;</code> <em class="nt"> </em>将特定于浏览器和特定于用户的数据存储在cookie中。在我们的代码中，我们将其添加为<code class="fe nc nd ne nf b">&lt;Authentication/&gt;</code>组件的父组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="9c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看我们的应用程序。我们尝试打开我们的秘密页面(步骤1)。该应用程序识别出我们没有登录，并将我们重定向到登录页面。我们输入凭据(步骤2)。由于我们尚未注册，该应用程序会向我们发送一封带有验证链接的确认电子邮件。</p><p id="ba17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们打开链接时(步骤3)，应用程序验证令牌，并将我们重定向到我们的秘密页面。当我们点击注销按钮(第4步)时，应用程序删除cookie，我们返回到我们的登录页面。从现在开始，我们可以直接使用凭据登录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/9957f84641cc45c44d43acf754b87409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXomjxg1Sy7snviAzyz2CA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d5c9" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">“看起来这么简单只是因为你到处都用了快捷方式！”</h2><p id="e813" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不得不承认，我们在这里使用的组件和功能都已经存在。我说这些反应——就像<a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=http://www.infrastructure-components.com" rel="noopener ugc nofollow" target="_blank">基础设施——组件</a>为我们做所有的技术配置，他们确实做了。</p><p id="22e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有使用过基础设施组件，这两篇文章会对你有所帮助:</p><ul class=""><li id="c343" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=https://codeburst.io/why-dont-you-use-server-side-rendering-in-your-react-app-acd51359c4b4" rel="noopener ugc nofollow" target="_blank">如何设置一个同构的React app </a>(就像我们这里用的这个)。这篇文章详细介绍了这种应用程序。它还介绍了如何将您的应用程序部署到AWS。</li><li id="0781" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.react-architect.com/page?ref=medium_auth&amp;dest=https://medium.com/dailyjs/how-to-send-automated-e-mails-in-a-full-stack-react-app-4e1527acae43" rel="noopener ugc nofollow">如何在全栈React app中发送邮件</a>。发送电子邮件需要您首先验证您(发件人)的电子邮件帐户。这篇文章告诉你如何去做。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="70d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下完整的源代码——它甚至不到一百行代码。你可以在GitHub库中找到它。</p></div></div>    
</body>
</html>