<html>
<head>
<title>Learning TypeScript — Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习类型脚本—接口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learning-typescript-interfaces-d36ca8b83758?source=collection_archive---------1-----------------------#2020-12-05">https://betterprogramming.pub/learning-typescript-interfaces-d36ca8b83758?source=collection_archive---------1-----------------------#2020-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd34" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">描述我们物体的形状</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d43edb48fd0dc107416a002635384aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bw9s23BQLiLWatUq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Patrick Fore 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="a660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是学习型脚本系列的第2部分。在第1部分中，我们研究了什么是TypeScript，如何安装它，以及它的基本类型。在本文中，我们将探索它的接口。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="78a0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是接口？</h1><p id="b593" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">简单地说，界面是描述对象形状的一种方式。在TypeScript中，我们只关心检查对象中的属性是否具有声明的类型，而不关心它是否专门来自同一个对象实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="582e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了强调TypeScript如何只检查对象的形状，我们让<code class="fe my mz na nb b">thisObj</code>和<code class="fe my mz na nb b">thatObj</code>具有相同的属性<code class="fe my mz na nb b">name</code>。尽管是两个不同的对象，但是当<code class="fe my mz na nb b">printName()</code>将它们作为参数时，这两个对象都通过了类型检查。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1aac" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可选属性</h1><p id="4628" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有时，我们会遇到这样的情况，并非所有的属性在任何时候都是必需的——只是在特定的条件下。我们将用可选属性对这些情况进行类型检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b356" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<code class="fe my mz na nb b">defineMammal({ name: ‘chicken’, legs: 2, wings: 2, color: ‘white’ })</code>没有通过类型检查，因为<code class="fe my mz na nb b">color</code>没有列为接口中定义的属性之一。它也不是哺乳动物，所以抛出这个错误的原因不止一个。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="74d8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">只读属性</h1><p id="daac" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果我们想要创建定义后看起来不可变的对象，我们将使用<code class="fe my mz na nb b">readonly</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了对象，数组可以定义为只读的，也可以用<code class="fe my mz na nb b">ReadonlyArray&lt;T&gt;</code>形式的泛型来定义。使用这种类型，您可以定义一个删除了所有变异方法的元组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe my mz na nb b">readonly</code>仅对编译步骤有效。一旦编译成JavaScript，这个属性就消失了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5b4c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">超额财产检查</h1><p id="75c0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要允许接口接受尚未定义的属性，可以这样定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1b81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，变量<code class="fe my mz na nb b">chicken</code>具有属性<code class="fe my mz na nb b">color</code>，TypeScript接受该属性，因为它允许使用类型为<code class="fe my mz na nb b">any</code>的多余属性。然而，如果<code class="fe my mz na nb b">legs</code>的类型是<code class="fe my mz na nb b">string</code>而不是<code class="fe my mz na nb b">number</code>，编译器将抛出一个错误，因为<code class="fe my mz na nb b">legs</code>被定义为具有类型<code class="fe my mz na nb b">number</code>。</p><p id="0e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以在接口中使用<code class="fe my mz na nb b">[propName: string]: any</code>，首先初始化变量，然后将它赋给执行类型检查的变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做的原因是，只有对象文字受到比赋给变量的对象更严格的类型检查。只要该对象中至少包含一个属性，该解决方法就可以工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7037" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">功能类型</h1><p id="6f21" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了描述函数类型，接口被赋予一个调用签名，它类似于一个函数声明，只给出参数列表和返回类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a4ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不需要定义<code class="fe my mz na nb b">myPrintNums</code>的函数参数和返回值的类型，因为TypeScript会将它们推断为类型<code class="fe my mz na nb b">printNums</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7cb3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可索引类型</h1><p id="6c99" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这些是我们可以“索引”的类型，比如<code class="fe my mz na nb b">a[1]</code>或<code class="fe my mz na nb b">a['hi']</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fa12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以定义数字和字符串可索引类型，但是数字索引必须始终是字符串索引的子类型。</p><p id="b9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用索引签名来描述字典模式，但是请注意，它们强制所有属性都必须与其返回类型相匹配。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">legs</code>属性抛出了一个错误，因为字典被设置为所有类型为<code class="fe my mz na nb b">string</code>的<code class="fe my mz na nb b">indexes</code>都将返回类型<code class="fe my mz na nb b">string</code>而不是数字。您可以通过在<code class="fe my mz na nb b">index</code>的类型中包含<code class="fe my mz na nb b">number</code>来解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a63a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以创建索引签名<code class="fe my mz na nb b">readonly</code>来防止任何类型的突变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="931b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">类别类型</h1><p id="1f3a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于类来说，要强制一个类型，你必须有一个接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个类有两种类型的接口:</p><ul class=""><li id="ece0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">发生在类外的静态方。</li><li id="ae89" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">描述类中类型(不是实现)的实例端<strong class="ky ir"> </strong>。</li></ul><p id="bf2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有实例端使用接口进行检查，而构造函数在初始化新对象时使用静态端进行检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3aad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">扩展接口</h1><p id="542b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">就像一个类可以从另一个类扩展一样，接口也可以从另一个接口扩展。这允许您将成员从一个接口复制到另一个接口，并在其上展开。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e3ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显而易见，接口<code class="fe my mz na nb b">mammal</code>是<code class="fe my mz na nb b">Animal</code>的扩展，以便对<code class="fe my mz na nb b">dog</code>进行正确的类型检查。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a22a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">混合类型</h1><p id="e1ff" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在极少数情况下，你必须同时描述一个对象和一个函数。幸运的是，TypeScript支持这些混合类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fa9e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">接口扩展类</h1><p id="6001" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接口也可以从类扩展。它们通过复制所有成员及其类型来实现这一点。如果类有私有或受保护的变量，那些接口类型只能由类本身(私有和受保护的)或它的子类(仅受保护的)实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6f44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，私有成员只能由基类本身访问，而受保护的成员可以由基类及其子类访问。这只适用于TypeScript。一旦编译成JavaScript，所有成员都是公共的，可以从任何地方通过引用实例来访问。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e535" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="88fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">概括地说，我们知道接口描述了对象的形状，包括对象文字、函数和类。</p><p id="3b28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以选择是否包含带有可选属性<strong class="ky ir"> </strong>的某些属性，并在这些属性前面添加<code class="fe my mz na nb b">?</code>。</p><p id="f37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只读属性<strong class="ky ir"> </strong>可以通过在属性前添加<code class="fe my mz na nb b">readonly</code>来定义。要描述只读数组，使用通用的<code class="fe my mz na nb b">ReadonlyArray&lt;T&gt;</code>。</p><p id="9648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于您想要描述的对象中任何多余的属性<strong class="ky ir"> </strong>，您可以在接口中使用类似<code class="fe my mz na nb b">[propName: string]: any;</code>的东西。</p><p id="af92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以使用两种可索引类型来描述对象(甚至是数组):数字和字符串。</p><p id="570b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于类，您可以使用两种类型的<code class="fe my mz na nb b">implement</code>接口:<code class="fe my mz na nb b">static</code>和<code class="fe my mz na nb b">instance</code>。</p><p id="9e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，接口可以由其他接口或类扩展，并可用于描述既可以是函数又可以是对象的混合类型。</p></div></div>    
</body>
</html>