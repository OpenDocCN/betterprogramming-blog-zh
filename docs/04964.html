<html>
<head>
<title>The Proper Way to Start a Django Project With GraphQL (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GraphQL启动Django项目的正确方法(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-graphql-with-django-and-graphene-part-2-5fe08f2d637a?source=collection_archive---------10-----------------------#2020-05-26">https://betterprogramming.pub/introduction-to-graphql-with-django-and-graphene-part-2-5fe08f2d637a?source=collection_archive---------10-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ee8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个带身份验证的简单待办应用程序—查询和突变</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fd443edac05657d8b2ca7c5b9205c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ri8W3LSfnLHSFVd-ghUbw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ilyapavlov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊利亚·巴甫洛夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="43ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在</em> <a class="ae ky" href="https://medium.com/better-programming/proper-way-to-start-a-django-project-with-graphql-6e230d4b4d2c" rel="noopener"> <em class="lv">本系列第一篇</em> </a> <em class="lv">中，我们谈到了从零开始一个Django和Graphene项目的正确方式。今天，我们将重点讨论如何创建GraphQL端点。本文假设您已经启动并运行了一个基本的应用程序。如果没有，请随时查看第一篇文章。</em></p><p id="f4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是一种强大的语言，用于从后端查询您需要的确切数据。与它的前身REST不同，使用GraphQL APIs，您最终可以通过一个端点(通常称为<code class="fe lw lx ly lz b">/api/graphql/</code>或简称为<code class="fe lw lx ly lz b">/graphql/</code>)来批量查询客户端所需的数据。类似地，也可以发送多个突变来操纵数据或触发后端事件。除了用于获取的查询和用于操作的突变之外，还有使服务器能够将数据推送到客户机的订阅。但那是以后的事了。</p><p id="9c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们关注如何用GraphQL创建一个简单的CRUD(创建、读取、更新和删除)后端。大多数人都会同意，开始学习一项新技术的最好方法就是亲自动手。在本文的其余部分，我们将通过一个简单应用程序的GraphQL后端进行编码。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0b92" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">输入TodoMVC！</h1><p id="80db" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当你开始学习一门新的编程语言时，你要做的第一件事就是编写一个打印出“Hello World”的程序。同样，当你开始学习一个新的web栈时，你要做的第一件事就是写一个待办事项app。这是一个非常流行的想法，以至于有一个非常著名的项目叫做<a class="ae ky" href="http://todomvc.com/" rel="noopener ugc nofollow" target="_blank"> TodoMVC </a>，它列出了一堆使用不同框架的相同待办事项应用的参考实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3f0bc051d70ccabf54805359ba7c30b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUaDCnQWwBCAix_IHCuMoA.png"/></div></div></figure><p id="6568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是应用程序在野外的样子。今天的目标是编写必要的后端代码来支持这样一个应用程序。如您所见，用户可以创建待办事项，删除它们，将它们标记为完成(或未完成)，并根据完成状态过滤待办事项列表。还有一个批量操作，“clear completed”<em class="lv">—</em>相当简单的东西。好吧，让我们深入代码，好吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6ba8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">首要任务:新的应用和数据模型</h1><p id="1f8f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们将通过创建一个新的<a class="ae ky" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>应用程序来开始代码。Django应用程序是Django项目中某种程度上封装的一组代码，它们具有一定的共性<em class="lv">。一个典型的Django应用程序通常会有几十个甚至几百个小应用程序。由于我们的应用程序将关注待办事项，所以我们将它称为待办事项。多方便啊！</em></p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="b77c" class="nj mi it lz b gy nk nl l nm nn">$ cd mybackend<br/>mybackend $ workon mybackend<br/>(mybackend) mybackend $ cd mybackend<br/>(mybackend) mybackend/mybackend $ django-admin startapp todos<br/>(mybackend) mybackend/mybackend $ cd todos<br/>(mybackend) mybackend/mybackend/todos $ ls -l<br/>    __init__.py<br/>    admin.py<br/>    apps.py<br/>    migrations<br/>    models.py<br/>    tests.py<br/>    views.py</span></pre><p id="a6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe lw lx ly lz b">django-admin</code>的<code class="fe lw lx ly lz b">startapp</code>命令创建了一个应用程序，并用必要的文件填充了应用程序文件夹。这里要意识到的一件有点令人困惑的事情是，我们在项目根目录下的<code class="fe lw lx ly lz b">mybackend</code>模块中创建了我们的应用程序，而不是将应用程序直接放在根目录下。这样做的好处是确保您的应用程序模块是用您的应用程序模块的名称命名的(在本例中是“mybackend”)。然后我们需要编辑<code class="fe lw lx ly lz b">app.py</code>并相应地更新它的名称和标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dd71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要在<code class="fe lw lx ly lz b">settings.py</code>将这个新应用程序添加到我们的<code class="fe lw lx ly lz b">INSTALLED_APPS</code>列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经为应用程序做好了基本的设置，我们可以开始考虑我们需要的数据模型了。幸运的是，我们的示例应用程序非常简单。我们只需要一个单一的模型来捕获待办事项，其中一个<code class="fe lw lx ly lz b">text</code>字段用于实际文本，一个<code class="fe lw lx ly lz b">boolean</code>字段用于将待办事项标记为完成。在那里，我们还可以添加一些关于<code class="fe lw lx ly lz b">created</code>和<code class="fe lw lx ly lz b">modified</code>时间戳的信息。哦，显然，我们需要为数据库中的每个条目设置一个唯一的主键。</p><p id="7016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个非常好的库叫做<code class="fe lw lx ly lz b">django-model-utils</code>，它为我们提供了在应用程序中使用的有用的模型混合和实用程序。我们将首先通过以下方式安装它:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="c77b" class="nj mi it lz b gy nk nl l nm nn">(mybackend) mybackend <strong class="lz iu">$</strong> pip install django-model-utils<br/>(mybackend) mybackend <strong class="lz iu">$</strong> pip freeze &gt; requirements.txt</span></pre><p id="0b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们准备好实现我们的模型了，在<code class="fe lw lx ly lz b">models.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="71dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们有一个名为<code class="fe lw lx ly lz b">text</code>的<code class="fe lw lx ly lz b">TextField</code>用于存储待办文本，一个名为<code class="fe lw lx ly lz b">completed</code>的<code class="fe lw lx ly lz b">BooleanField</code>用于存储完成信息(默认为<code class="fe lw lx ly lz b">False</code>)。我们还从<code class="fe lw lx ly lz b">model_utils</code>(又名<code class="fe lw lx ly lz b">django-model-utils</code>)提供的两个mixin:<code class="fe lw lx ly lz b">TimeStampedModel</code>和<code class="fe lw lx ly lz b">UUIDModel</code>。正如你可能猜到的，<code class="fe lw lx ly lz b">TimeStampedModel</code> mixin增加了两个<code class="fe lw lx ly lz b">DateTimeField</code>来捕获<code class="fe lw lx ly lz b">created</code>和<code class="fe lw lx ly lz b">modified</code>时间戳。并且<code class="fe lw lx ly lz b">UUIDModel</code> mixin为我们的模型添加了一个基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Universally_unique_identifier" rel="noopener ugc nofollow" target="_blank"> UUID </a>的主键。</p><p id="a580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，模型代码完成了。现在我们需要在数据库上创建这些模型。为此，请使用以下方法:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="c872" class="nj mi it lz b gy nk nl l nm nn">(mybackend) mybackend <strong class="lz iu">$ </strong>python manage.py makemigrations<br/>(mybackend) mybackend <strong class="lz iu">$ </strong>python manage.py migrate</span></pre><p id="fbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令将首先生成一个迁移文件，描述我们刚刚创建的模型，然后对数据库应用迁移。您应该将迁移文件提交到您的Git存储库中。</p><p id="8080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们在这里，我们也可以为管理员提供一个简单的管理界面，如果他们认为有必要的话，可以随意处理待办事项。为此，我们只需编辑我们的<code class="fe lw lx ly lz b">admin.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了我们的第一个管理页面，让我们看看它的运行情况。首先，我们需要创建一个超级用户:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="1a42" class="nj mi it lz b gy nk nl l nm nn">(mybackend) mybackend <strong class="lz iu">$ </strong>python manage.py createsuperuser</span></pre><p id="b935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的命令，并按照提示进行操作。然后就可以运行<code class="fe lw lx ly lz b">python manage.py runserver</code>，用刚刚创建的凭证登录<a class="ae ky" href="http://127.0.0.1:8000/admin/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/admin/</a>了。你应该会看到一个Todos <em class="lv">的链接。”</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="aab4" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">GraphQL查询和变异</h1><p id="d0d6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">是时候向外界(也就是您的客户)公开这个模型了。为此，我们将在<code class="fe lw lx ly lz b">mybackend/mybackend/todos/</code>下再创建三个文件，即<code class="fe lw lx ly lz b">mutations.py</code>、<code class="fe lw lx ly lz b">queries.py</code>和<code class="fe lw lx ly lz b">types.py</code>。顾名思义，<code class="fe lw lx ly lz b">mutations.py</code>是编写突变的模块，<code class="fe lw lx ly lz b">queries.py</code>是查询模块，<code class="fe lw lx ly lz b">types.py</code>是从GraphQL端点返回的对象类型模块。</p><p id="f4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说类型。一般来说，你的每一个模型都会有一个类型。在我们的案例中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单，多亏了石墨烯的Django集成。<code class="fe lw lx ly lz b">DjangoObjectType</code>只是期望一个模型元指向我们实际的模型类(即<code class="fe lw lx ly lz b">Todo</code>)并生成相应的类型。</p><p id="e98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了类型，我们可以继续创建返回待办事项的查询。之后我们会处理变异来操纵这些物品。在我们的<code class="fe lw lx ly lz b">queries.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们公开了两个查询:<code class="fe lw lx ly lz b">todos</code>和<code class="fe lw lx ly lz b">todo</code>。<code class="fe lw lx ly lz b">todos</code>查询返回待办事项列表。它接受一个参数<code class="fe lw lx ly lz b">completed</code>来根据完成状态过滤待办事项。另一方面，<code class="fe lw lx ly lz b">todo</code>查询返回一个待办事项，给出它的<code class="fe lw lx ly lz b">id</code>。</p><p id="f346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要将这些查询注册到我们的模式中。为此，我们需要将我们的<code class="fe lw lx ly lz b">schema.py</code>更新为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="caba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？我们刚刚创建了一个新的<code class="fe lw lx ly lz b">Query</code>类，它从<code class="fe lw lx ly lz b">todo</code>应用程序中的<code class="fe lw lx ly lz b">Query</code>类扩展而来。这个新的顶级<code class="fe lw lx ly lz b">Query</code>将从每个应用程序的<code class="fe lw lx ly lz b">Query</code>开始延伸。如果你愿意，现在你可以回到你的管理界面，添加一些待办事项。然后访问<a class="ae ky" href="http://127.0.0.1:8000/graphql" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/graph QL</a>并运行以下查询(在左侧键入并点击播放按钮):</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="fcb6" class="nj mi it lz b gy nk nl l nm nn">{<br/>  todos{<br/>    text<br/>    completed<br/>  }<br/>}</span></pre><p id="126d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该在右侧看到作为JSON对象的查询结果。</p><p id="b4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您刚刚在自己创建的后端上运行了第一个GraphQL查询。</p><p id="c450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然查询已经解决了，我们可以开始研究突变了。至少，我们需要能够创建待办事项，更新待办事项(将它们标记为完成)，以及删除待办事项。继续将以下代码插入您的<code class="fe lw lx ly lz b">mutations.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这里的代码是不言自明的。但是简单描述一下，每一类对应一个单独的突变。在他们的<code class="fe lw lx ly lz b">Arguments</code>子类中，我们定义了突变期望得到的参数。在他们的<code class="fe lw lx ly lz b">mutate</code>函数中，我们实现了我们需要的行为。参数集作为位置参数传递给<code class="fe lw lx ly lz b">mutate</code>函数，正如您在<code class="fe lw lx ly lz b">UpdateTodo</code>和<code class="fe lw lx ly lz b">DeleteTodo</code>中看到的。第二个位置参数<code class="fe lw lx ly lz b">info</code>保存了一些关于突变的元数据，包括上下文(稍后会详细介绍)。然后，这些变异类被注册到一个顶级的<code class="fe lw lx ly lz b">Mutation</code>，其中每个字段的名称都对应于GraphQL接口中变异的公开名称。石墨烯甚至可以方便地为我们自动识别这些字段名。</p><p id="6fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们可以测试我们编写的这些新的突变之前，我们只需要在我们的模式中注册它们。类似于我们注册查询的方式，我们将更新<code class="fe lw lx ly lz b">schema.py</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="837e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您返回到<a class="ae ky" href="http://127.0.0.1:8000/graphql" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/graph QL</a>并运行以下代码，您应该会看到第一次成功变异的结果:</p><pre class="kj kk kl km gt nf lz ng nh aw ni bi"><span id="a57e" class="nj mi it lz b gy nk nl l nm nn">mutation {<br/>  createTodo(text:"A new to-do item.", completed:false) {<br/>    todo {<br/>      id<br/>      text<br/>      completed<br/>      created<br/>      modified<br/>    }<br/>  }<br/>}</span></pre><p id="19c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多刺激啊！</p><p id="3d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您注意的话，您会发现我们没有实现“清除完成”的批量操作。我将把它作为一个练习留给你去解决。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a747" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包扎</h1><p id="6711" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是一个使用Django和Graphene创建GraphQL接口的简单例子。但是不管你的界面有多大或多复杂，你在这里学到的一般思想和模式仍然适用。</p><p id="9423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的下一篇文章中，我们将讨论如何借助JSON Web令牌在我们的GraphQL APIs上启用身份验证。一定要订阅不要错过！</p></div></div>    
</body>
</html>