<html>
<head>
<title>How To Create a Generic Backend Firebase API in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中创建通用后端Firebase API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-how-to-create-a-generic-backend-firebase-api-b6396208f460?source=collection_archive---------6-----------------------#2021-05-18">https://betterprogramming.pub/swift-how-to-create-a-generic-backend-firebase-api-b6396208f460?source=collection_archive---------6-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b36b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Swift泛型和反射来创建单个API端点，以便为任何对象类型执行Firebase CRUD操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6808d1351a1be21c9ba192fe38d3572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hFxNJZx4S-k-8VwC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发基于Swift并带有<a class="ae ky" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>后端的iOS应用程序时，一种常见的方法是创建一个repository类，用于处理从您的应用程序创建、读取、更新和删除(CRUD)Firebase Firestore存储库对象的任务。通常，每当有新类型引入到您的应用程序中，并且为新类型实现了所有CRUD操作时，repository类都会更新。这些新实现中的大多数都是样板代码，在不同类型的实现中重复使用。</p><p id="99cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理这种情况的一个更好的方法可能是使用Swift generics创建一个基本后端类，该类可以处理将来创建的任何符合指定协议的类，而无需为新类型复制存储库实现。</p><p id="530c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文提供了一种可行的最小代码方法来实现Firebase后端操作，可以插入到任何新的或现有的iOS项目中。本文还使用Swift reflection实现了一种在将定制对象保存为Firebase文档时处理对象主键的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4617" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="76ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们将开发一个带有后端API的iOS演示应用程序，它将执行和演示以下任务:</p><ul class=""><li id="e74c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">将新对象保存到Firebase Firestore存储库中。该方法将从Firebase生成一个<code class="fe ni nj nk nl b">documentID</code>,并使用这个id作为对象的惟一键以及保存的文档的名称。要做到这一点，我们需要能够在运行时查询任何类型的属性和该类实例的属性数据。为了实现这一点，我们利用了<a class="ae ky" href="https://www.swiftbysundell.com/articles/reflection-in-swift/" rel="noopener ugc nofollow" target="_blank">快速反射</a>。</li><li id="be4d" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">通过提供唯一的主键，从Firestore存储库中检索保存的对象</li><li id="9931" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">根据按字段和字段值提供的条件检索对象数组</li><li id="ce71" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">更新存储库中已经存在的对象</li><li id="ed8a" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">从存储库中删除基于唯一主键的现有对象</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="86f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="0ef9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该解决方案要求您已经配置了Firebase，创建了一个项目，并将Firebase添加到您的iOS应用程序中。按照<a class="ae ky" href="https://firebase.google.com/docs/ios/setup" rel="noopener ugc nofollow" target="_blank">官方文档</a>创建一个新的Firebase项目，并将Firebase添加到您的应用程序中。</p><p id="812e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，您应该在云中有一个空的Firebase Firestore项目，已经创建了您的Podfile，并且已经使用pod install初始化了您的Xcode项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/51e3cb021ab056a08c4a76ee613f12b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AAAuRXwzQAT8bb_8Hwp_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">空Firestore数据库</p></figure><p id="2f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift版本的反射允许我们查询一个类型的实例，查看所有存储的属性，并访问每个属性的数据。不幸的是，Swift实现只提供对这些元数据的只读访问。我们不能使用快速反射来改变任何属性值。对于这篇文章，我们需要这种能力。幸运的是，有一个第三方包，<a class="ae ky" href="https://github.com/wickwirew/Runtime" rel="noopener ugc nofollow" target="_blank"> Runtime </a>，正好提供了我们需要的这种能力。</p><p id="caca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面一行添加到您的pod文件中，并再次执行pod安装。</p><pre class="kj kk kl km gt ns nl nt nu aw nv bi"><span id="d37e" class="nw md it nl b gy nx ny l nz oa">pod ‘Runtime’</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="bb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置所需的先决条件后，将执行以下步骤:</p><ul class=""><li id="0ff8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">添加<code class="fe ni nj nk nl b">backendAPI</code>类型</li><li id="9023" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">测试API</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2eb9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加backendAPI类型</h1><p id="ccf1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在您的iOS项目中，添加一个新的Cocoa Touch Swift文件。(右键单击项目导航器中的根组，并选择New File。)</p><p id="5bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将文件命名为<code class="fe ni nj nk nl b">BackendAPI.swift</code>(T2的一个子类)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/afe8ce066910626174bcf129cf3aa173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGai7Gv6ZWLQwo410Ls7gg.png"/></div></div></figure><p id="5a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要这个类能够与任何类一起工作。为此，我们必须将该类转换为泛型类型。我们在类型定义中包含了一个类型参数<code class="fe ni nj nk nl b">T</code>，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="49f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">T</code>为类型提供一个占位符名称，稍后调用<code class="fe ni nj nk nl b">backendAPI</code>类型时提供。</p><p id="a39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们包含一个类型约束，要求<code class="fe ni nj nk nl b">T</code>符合<code class="fe ni nj nk nl b">Codable</code>类型。<code class="fe ni nj nk nl b">Codable</code>是一个类型别名，它结合了<code class="fe ni nj nk nl b">Encodable</code>和<code class="fe ni nj nk nl b">Decodable</code>两个协议，使对象能够很容易地序列化为外部格式。我们会要求传递给<code class="fe ni nj nk nl b">backendAPI</code>的所有定制对象都符合这些协议。</p><h2 id="3c7e" class="nw md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">实现保存方法</h2><p id="0d75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要实现Save方法，请将以下代码添加到<code class="fe ni nj nk nl b">BackendAPI</code>类中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f0bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码执行以下任务:</p><ul class=""><li id="5d23" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">定义一个方法签名，并通过完成处理程序传递一个类型为<code class="fe ni nj nk nl b">T</code>的通用类型obj</li><li id="e0ad" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">初始化几个局部变量——将obj通用类型转换为var，以启用唯一键更新，所有要保存的自定义类型都需要唯一键名<code class="fe ni nj nk nl b">doc_id</code>。该值可以根据需要进行更改。</li><li id="5395" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">还将var初始化为运行时传递给该方法的泛型类的名称。</li><li id="e2a3" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">使用反射(运行时)来查询泛型类型并检查该类型是否包含已定义的唯一键</li><li id="17e4" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">如果类型中存在唯一的键属性，则从Firestore后端初始化一个文档引用对象，以获得一个新的<code class="fe ni nj nk nl b">documentID</code></li><li id="d55c" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">使用反射(运行时)用obj中返回的<code class="fe ni nj nk nl b">documentID</code>更新唯一键属性</li><li id="7999" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">用<code class="fe ni nj nk nl b">documentID</code>作为文档键保存对象到Firebase</li></ul><h2 id="a93d" class="nw md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">实现Get方法</h2><p id="d389" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将实现两个重载的Get方法。第一种方法将惟一键作为一个字符串(在我们的例子中是<code class="fe ni nj nk nl b">doc_id</code>),并通过一个完成处理程序在Firebase Firestore中返回一个带有等价惟一键的单一对象。</p><p id="a5a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个Get方法接受两个字符串参数，<code class="fe ni nj nk nl b">getByField</code>和<code class="fe ni nj nk nl b">getByValue</code>，并使用这些参数查询Firestore中的任何特定字段。第二个Get方法根据完成处理程序中提供的字段和值返回匹配文档的数组。</p><p id="57c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，与前面的Save方法一样，Firebase文档的名称是通过调用泛型类型的字符串表示形式自动确定的。</p><p id="2f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个Get方法的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码执行以下任务:</p><ul class=""><li id="51c0" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">通过类型的字符串表示形式获取泛型类型的名称</li><li id="979d" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">通过第一个Get方法中的唯一键id或第二个Get方法中提供的字段和值，使用类型名初始化对Firebase的查询</li><li id="5405" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">如果返回任何文档，将返回的文档转换为泛型类型表示，并通过完成处理程序将类型返回给调用代码</li></ul><h2 id="c9af" class="nw md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">实现更新和删除方法</h2><p id="887d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实现Update和Delete方法非常简单，与其他方法的实现一致。</p><p id="da98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Update方法，更新的类型被传递给该方法。该方法首先检查类型属性，以确认类型的结构是否符合预期(通过检查唯一id字段的存在)。一旦类型结构被确认，该方法调用Firestore <code class="fe ni nj nk nl b">setData</code>方法来执行实际的文档更新。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新操作的结果通过完成处理程序返回给调用方法。</p><p id="3ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Delete方法，惟一的键id ( <code class="fe ni nj nk nl b">doc_id</code>)被传递给该方法，并用于检索相应的Firebase文档。然后通过引用句柄从Firebase Firestore中删除该文档。</p><p id="106c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新和删除方法的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e49" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试API</h1><p id="449a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了测试API，我们创建一些样本类型(类和结构)并将这些类型的实例传递给<code class="fe ni nj nk nl b">backendAPI</code>对象实例。</p><ul class=""><li id="8516" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在您的Xcode项目中，添加一个新的Swift文件(<code class="fe ni nj nk nl b">Models.swift</code>)，并包含以下代码来定义两种类型:<code class="fe ni nj nk nl b">Book</code>和<code class="fe ni nj nk nl b"> Vehicle</code>。注意，每种类型都有一个名为<code class="fe ni nj nk nl b">doc_id</code>的属性。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/84054d7fb56a01433aa2ac7b20a7056b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88-dxtu6vl0IC6_uw1Im8w.png"/></div></div></figure><ul class=""><li id="b409" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在主情节提要中，添加一个按钮和两个标签，如图所示。设置所有必要的约束，并分别设置<code class="fe ni nj nk nl b">@IBAction</code><code class="fe ni nj nk nl b">@IBOutlet</code><em class="oq"/>方法和连接，<em class="oq"> </em>到<code class="fe ni nj nk nl b">ViewController.swift</code>文件中的按钮和标签。</li><li id="9723" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">将以下代码添加到上面创建的<code class="fe ni nj nk nl b">@IBAction</code>方法中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="2533" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">当您创建要保存的类型的对象时，您不需要为唯一键(<code class="fe ni nj nk nl b">doc_id</code>)提供值。让它空着。该值将作为<code class="fe ni nj nk nl b">documentID</code>从Firebase系统中生成。</li><li id="d0f1" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">要调用API，您需要使用定义的语法(在方括号&lt;&gt;之间)提供类型的名称作为泛型类型的参数</li><li id="a00a" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">测试闭包中返回的布尔对象，并相应地执行任何操作。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/dd27cbedcdab975d2e367275d4b61b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*a55qP5hV_RL1qhPKMIYVkg.png"/></div></figure><ul class=""><li id="0dc7" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">新数据现已成功保存到Firebase Firestore。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/8b8efe993eb51319d3d9cb52a61503a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsdH90bbPhE5dvg_GjEpOA.png"/></div></div></figure><ul class=""><li id="6113" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">注意，文档是用Firebase生成的<code class="fe ni nj nk nl b">documentID</code>保存的。</li><li id="187c" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">实现其他操作(获取、更新和删除)的代码也非常相似。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3314" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="1ec6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们已经能够演示一个高效且极简的代码库的实现，该代码库可以用作API端节点，用于将任何类型的对象保存到Firebase Firestore后端存储。</p><p id="7945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用Swift泛型和反射，我们能够在处理多个对象的保存时避免低效的代码重复。</p><p id="fa33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码库可以作为任何基于Swift的iOS应用程序项目的基础或灵感。</p><p id="4480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/oidele/FirebaseBackendAPI" rel="noopener ugc nofollow" target="_blank"> FirebaseBackendAPI </a>的源代码在GitHub上。</p><p id="5026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读我的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ad9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="fe28" class="mz na it lb b lc mu lf mv li ot lm ou lq ov lu ne nf ng nh bi translated"><a class="ae ky" href="https://www.swiftbysundell.com/articles/reflection-in-swift/" rel="noopener ugc nofollow" target="_blank">迅捷的反射</a></li><li id="7da1" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><a class="ae ky" href="https://firebase.google.com/docs/ios/setup" rel="noopener ugc nofollow" target="_blank"> Firebase文档</a></li><li id="7d86" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/wickwirew/Runtime" rel="noopener ugc nofollow" target="_blank">运行时</a>包</li></ul></div></div>    
</body>
</html>