<html>
<head>
<title>Higher-Order Functions in Objective-C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Objective-C中的高阶函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/higher-order-functions-in-objective-c-850f6c90de30?source=collection_archive---------9-----------------------#2017-07-25">https://betterprogramming.pub/higher-order-functions-in-objective-c-850f6c90de30?source=collection_archive---------9-----------------------#2017-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e6d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NSArray的Map、filter、reduce和flatMap实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09ffe5ade48086d737193c70e298415b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kAugZSvNj41G5CRQiwQ6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的Screencap。</p></figure><h1 id="395a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不，你的眼睛没有说谎，题目不是错别字</h1><p id="31bc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">你可能听说过函数式编程或高阶函数，如<code class="fe mj mk ml mm b">map</code>、<code class="fe mj mk ml mm b">filter</code>、<code class="fe mj mk ml mm b">reduce</code>、<code class="fe mj mk ml mm b">flatMap</code>等。，对于斯威夫特来说。相信我，如果你今天开始在你的项目中使用它们，你会爱上它们的。在另一个函数中使用函数作为参数的方法是如此方便和简洁，以至于很容易上瘾，很难拒绝。</p><p id="c6f4" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">那么，目标C呢？我们能在其中获得相同的想法或相似的方式吗？是的，我们可以。我们可以创建一个<code class="fe mj mk ml mm b">NSArray</code>类别，并迭代它的每个元素以获得相同的结果。在本文中，我将演示如何在Objective-C中为<code class="fe mj mk ml mm b">map</code>、<code class="fe mj mk ml mm b">filter</code>、<code class="fe mj mk ml mm b">reduce</code>和<code class="fe mj mk ml mm b">flatMap</code>创建基于块的函数。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="970e" class="kv kw iq bd kx ky mz la lb lc na le lf jw nb jx lh jz nc ka lj kc nd kd ll lm bi translated">首先，让我们来看看它是如何在一个迅捷的操场上表现的</h1><p id="42bf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果你注意下面的片段，你会注意到代码本身的意图是关注集合中每个元素的功能，没有<code class="fe mj mk ml mm b">for-loop</code>模式的迹象。它帮助开发人员专注于更多的操作，而不是用数据处理控制流程。</p><ul class=""><li id="e006" class="ne nf iq lp b lq mn lt mo lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir"> Map </strong>:迭代一个集合，对其中的每个元素应用相同的块操作。<br/> <code class="fe mj mk ml mm b">print(characters.map({ String($0).uppercased() }))</code></li><li id="5014" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Filter </strong>:迭代一个集合，返回满足条件的元素。<br/> <code class="fe mj mk ml mm b">print(characters.filter({ $0 == “o”}))</code></li><li id="f757" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Reduce </strong>:将集合中的所有元素组合起来，创建一个输出。<br/> <code class="fe mj mk ml mm b">print(characters.reduce(“”, { String($0) + String($1) }))</code></li><li id="c7fc" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> FlatMap </strong>:展平一个集合的集合。<br/> <code class="fe mj mk ml mm b">let _characters = [“Hello”.characters, “, “.characters, “playground”.characters] print(_characters.flatMap({ $0 }))</code></li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="05f8" class="kv kw iq bd kx ky mz la lb lc na le lf jw nb jx lh jz nc ka lj kc nd kd ll lm bi translated">好了，现在让我们把手弄脏</h1><p id="08bf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">与Swift不同，高阶函数不是Objective-C中的内置函数。因此，我们需要创建自己的<code class="fe mj mk ml mm b">category</code>来访问这些函数。如果你浏览下面的代码，核心概念基本上并不复杂。它围绕着函数<code class="fe mj mk ml mm b">enumerateObjectsUsingBlock:</code>并根据其用途增加了一些小的变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="c279" class="kv kw iq bd kx ky mz la lb lc na le lf jw nb jx lh jz nc ka lj kc nd kd ll lm bi translated">那么，你如何使用它们呢？</h1><p id="8f80" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">用法和Swift很像但是有点啰嗦。但是，模式和思路还是一样的。我们只负责操作，不需要处理流量控制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><ul class=""><li id="97cc" class="ne nf iq lp b lq mn lt mo lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir"> Map </strong>:迭代一个数组，对其中的每个元素应用相同的块操作。<br/> <code class="fe mj mk ml mm b">NSLog(@”%@”, [array map:^id(id obj) { return [(NSString *)obj uppercaseString]; }]);</code></li><li id="154c" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Filter </strong>:迭代一个数组，返回满足条件的元素。<br/> <code class="fe mj mk ml mm b">NSLog(@”%@”, [array filter:^BOOL(id obj) { return [(NSString *)obj isEqualToString:@”o”]; }]);</code></li><li id="d52d" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Reduce </strong>:将一个数组中的所有元素组合成一个输出。</li></ul><pre class="kg kh ki kj gt nu mm nv nw aw nx bi"><span id="51a3" class="ny kw iq mm b gy nz oa l ob oc">NSLog(@"%@", [array reduce:@"Hey, " block:^id(id obj1, id obj2) { return [NSString stringWithFormat:@"%@%@", obj1, obj2]; }]);<br/>array = @[<br/>  @[@"H", @"e", @"l", @"l", @"o"],<br/>  @[@",", @" "],<br/>  @[@"w", @"o", @"r", @"l", @"d", @"!"]<br/>  ];</span></pre><ul class=""><li id="555d" class="ne nf iq lp b lq mn lt mo lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir"> FlatMap </strong>:展平一个数组的数组。<br/> <code class="fe mj mk ml mm b">NSLog(@”%@”, [array flatMap:^id(id obj) { return obj; }]);</code></li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="095f" class="kv kw iq bd kx ky mz la lb lc na le lf jw nb jx lh jz nc ka lj kc nd kd ll lm bi translated">但是等等，这里可能有问题</h1><p id="4fc9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">是的，魔鬼总是在细节中。这就是为什么“但是”一直如此重要。作为一名有多年经验的开发人员，您可能想知道在Objective-C中这是否是一个好的实践？原因是类型安全或多或少成为了开发人员的责任。毕竟，Swift和Objective-C在类型推断和类型安全的许多方面并不共享相同的理念。我的建议是为每个函数添加一个类限制器，以提高安全性。虽然添加一个类限制器可能会变得太罗嗦，但我仍然认为从长远来看这是更安全和更好的。</p><p id="e1be" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">下面的代码片段演示了类限制器的用法。完整的实现可从这里的GitHub获得。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><ul class=""><li id="2faf" class="ne nf iq lp b lq mn lt mo lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir"> Map </strong>:迭代一个数组，对其中的每个元素应用相同的块操作。<br/>T3】</li><li id="1e7d" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Filter </strong>:迭代一个数组，返回满足条件的元素。<br/> <code class="fe mj mk ml mm b">NSLog(@”%@”, [array filter:^BOOL(id obj) { return [(NSString *)obj isEqualToString:@”o”]; } class:[NSString class]]);</code></li><li id="4505" class="ne nf iq lp b lq nn lt no lw np ma nq me nr mi nj nk nl nm bi translated"><strong class="lp ir"> Reduce </strong>:将一个数组中的所有元素组合成一个输出。</li></ul><pre class="kg kh ki kj gt nu mm nv nw aw nx bi"><span id="60f5" class="ny kw iq mm b gy nz oa l ob oc">NSLog(@"%@", [array reduce:@"Hey, " block:^id(id obj1, id obj2) { return [NSString stringWithFormat:@"%@%@", obj1, obj2]; } class:[NSString class]]);<br/>array = @[<br/>    @[@"H", @"e", @"l", @"l", @"o"],<br/>    @[@",", @" ", <a class="ae od" href="http://twitter.com/3" rel="noopener ugc nofollow" target="_blank">@3</a>],<br/>    @[<a class="ae od" href="http://twitter.com/6" rel="noopener ugc nofollow" target="_blank">@6</a>, <a class="ae od" href="http://twitter.com/8" rel="noopener ugc nofollow" target="_blank">@8</a>, <a class="ae od" href="http://twitter.com/6" rel="noopener ugc nofollow" target="_blank">@6</a>],<br/>    @[@"w", @"o", @"r", @"l", @"d", @"!"]<br/> ];</span></pre><ul class=""><li id="76a4" class="ne nf iq lp b lq mn lt mo lw ng ma nh me ni mi nj nk nl nm bi translated"><strong class="lp ir"> FlatMap </strong>:展平一个数组的数组。<br/> <code class="fe mj mk ml mm b">NSLog(@”%@”, [array flatMap:^id(id obj) { return obj; } class:[NSString class]]);</code></li></ul></div></div>    
</body>
</html>