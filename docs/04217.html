<html>
<head>
<title>Understanding the Ruby Method Lookup Chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Ruby方法查找链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-ruby-method-lookup-chain-d6f9d7997849?source=collection_archive---------18-----------------------#2020-03-30">https://betterprogramming.pub/understanding-the-ruby-method-lookup-chain-d6f9d7997849?source=collection_archive---------18-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4475" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">揭开Ruby的神秘面纱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7216ed2bbdb944728b58d7c2ae79019b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*30mrS9RLd45EZ54N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="c8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在Ruby中调用一个方法时，很多事情都是在幕后发生的。Ruby解释器必须知道这个方法是在哪里声明的，才能知道它必须解释什么行为。</p><p id="f632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程被称为<em class="ls">方法查找。</em></p><p id="5353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它遍历一个对象的祖先链，查看这个方法是在哪里声明的。</p><p id="f0f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的好朋友Mehdi Farsi写了一篇<a class="ae kv" href="https://medium.com/rubycademy/ruby-object-model-part-1-4d06fa486bec" rel="noopener">文章解释祖先链</a>。我不能比他解释得更好，所以如果你不熟悉Ruby的祖先链，我建议你去看看。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="92c9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">那么它是如何表现的呢？</h1><p id="a56a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设您有以下几个类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="47e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">Dog</code>类继承自<code class="fe mz na nb nc b">Animal</code>类，后者定义了一个<code class="fe mz na nb nc b">#speak</code>方法。</p><p id="450b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以这样做:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="ab85" class="nh mb iq nc b gy ni nj l nk nl">dog = Dog.new<br/>=&gt; #&lt;Dog:0x00007ff5b78e9270&gt;</span><span id="aaf5" class="nh mb iq nc b gy nm nj l nk nl">dog.speak<br/>"I am from the Animal class"<br/>=&gt; "I am from the Animal class"</span></pre><p id="e31d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过简单的继承，我们的<code class="fe mz na nb nc b">Dog</code>类实例可以访问其父类的<code class="fe mz na nb nc b">#speak</code>方法。</p><p id="f2f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Ruby究竟如何知道在哪里可以找到这个方法呢？</p><p id="7b0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，很简单。</p><p id="5268" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使用类似下面的方法检查调用该方法的对象(在本例中，是一个<code class="fe mz na nb nc b">Dog</code>类的实例):</p><p id="d328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">#instance_methods</code>顾名思义，以数组的形式返回实例的方法。在这种情况下，<code class="fe mz na nb nc b">Dog.instance_methods</code>返回一堆从其祖先继承的方法，包括我们的<code class="fe mz na nb nc b">#speak</code>方法:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="e3f1" class="nh mb iq nc b gy ni nj l nk nl">Dog.instance_methods</span><span id="cebd" class="nh mb iq nc b gy nm nj l nk nl">=&gt; [<strong class="nc ir">:speak</strong>, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, ...]</span></pre><p id="5f64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这不是我们想要的，因为我们只想要在<code class="fe mz na nb nc b">Dog</code>类中定义的方法，而不要它的祖先的方法。</p><p id="0fa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将<code class="fe mz na nb nc b">false</code>传递给<code class="fe mz na nb nc b">instance_methods</code>,以便只获取在<code class="fe mz na nb nc b">Dog</code>类中定义的方法:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="c55c" class="nh mb iq nc b gy ni nj l nk nl">Dog.instance_methods(false)<br/>=&gt; []</span></pre><p id="8f0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以得出结论，Ruby使用了类似于:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="5bfb" class="nh mb iq nc b gy ni nj l nk nl">Dog.instance_methods(false).include?(:speak)<br/>=&gt; false</span></pre><p id="9ccf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们知道<code class="fe mz na nb nc b">Dog</code>类没有定义<code class="fe mz na nb nc b">#speak</code>方法，我们可以在祖先链中向上一个类到<code class="fe mz na nb nc b">Animal</code>类。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="c188" class="nh mb iq nc b gy ni nj l nk nl">Dog.ancestors<br/>=&gt; [Dog, Animal, Object, Kernel, BasicObject]</span></pre><p id="b25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它进入<code class="fe mz na nb nc b">Animal</code>类，在那里它找到了圣杯。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="1d50" class="nh mb iq nc b gy ni nj l nk nl">Animal.instance_methods(false)<br/>=&gt; [:speak]</span></pre><p id="4f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">算法很简单:</p><ol class=""><li id="fe3b" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">检查当前对象，查看它是否定义了该方法，如果没有，请转到步骤2。</li><li id="978d" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">只要它没有被定义，它就调用它的超类并重复步骤1。</li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6d27" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="fd08" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种算法使得查找链密封，没有方法重叠，也使得覆盖方法成为可能。</p><p id="504a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到<code class="fe mz na nb nc b">Dog</code>类和<code class="fe mz na nb nc b">Animal</code>类都定义了<code class="fe mz na nb nc b">#speak</code>方法。所以在一个<code class="fe mz na nb nc b">Dog</code>实例上调用这个方法时…</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="87ca" class="nh mb iq nc b gy ni nj l nk nl">Dog.new.speak<br/>"I am from the Dog class"<br/>=&gt; "I am from the Dog class"</span></pre><p id="7828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…算法检查该方法是否在调用它的对象中定义。在这种情况下，它是<code class="fe mz na nb nc b">Dog</code>的一个实例:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="2a9f" class="nh mb iq nc b gy ni nj l nk nl">Dog.instance_methods(false)<br/>=&gt; [:speak]</span><span id="0cd1" class="nh mb iq nc b gy nm nj l nk nl">Dog.instance_methods(false).include?(:speak)<br/>=&gt; true</span></pre><p id="ccd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它停止了——因为我们已经找到了我们的赢家。</p></div></div>    
</body>
</html>