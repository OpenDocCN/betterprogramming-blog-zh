<html>
<head>
<title>5 Useful Jasmine and Jest Matchers for Easier Expectations in JavaScript Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个有用的Jasmine和Jest匹配器，让JavaScript测试中的预期更加容易</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-useful-jasmine-and-jest-matchers-for-easier-expectations-in-javascript-tests-98acd31e443e?source=collection_archive---------14-----------------------#2021-01-26">https://betterprogramming.pub/5-useful-jasmine-and-jest-matchers-for-easier-expectations-in-javascript-tests-98acd31e443e?source=collection_archive---------14-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">写下能证实你所关心的事情的期望</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43c9e6a4c8458000724f4560e42f303a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUspog85SBZNuLzD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="a9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试是现代软件开发的重要组成部分。在过去的几年里，工具已经有了很大的改进，可以帮助开发人员编写好的测试。毕竟，编写测试不应该感到乏味。相反，测试确保现有的功能按预期工作。</p><p id="363e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数常见的编程语言，如Java、C#、Python和JavaScript，都有很好的测试框架。在JavaScript世界里，<a class="ae ky" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae ky" href="https://jasmine.github.io" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>是流行的测试框架。不管任何特定的编程语言或框架，测试通常具有或多或少相同的结构:</p><ul class=""><li id="c235" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">测试框架由于特殊的功能(例如带有Jest的<code class="fe me mf mg mh b">describe</code>和<code class="fe me mf mg mh b">it</code>)或者特殊的注释(例如带有JUnit的<code class="fe me mf mg mh b">@Test</code>)而识别测试用例。</li><li id="0106" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">许多测试文件包含不止一个测试用例。因此，在一个地方进行测试设置通常是有意义的(例如，使用<code class="fe me mf mg mh b">beforeEach</code>和Jest)。</li><li id="d240" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">运行一些测试后，您可能想要清理一下。例如，删除测试中创建的数据(例如，使用<code class="fe me mf mg mh b">afterAll</code>和Jest)。</li><li id="e3b9" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">每个测试用例应该包含至少一个期望/断言(例如<code class="fe me mf mg mh b">expect(addNumbers(1, 2)).toEqual(3)</code> with Jest)。期望是关键的部分，因为它们会让我们知道被测试的功能是否如预期的那样工作。最后，它们作为最新的文档。</li></ul><p id="6152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，有些功能比其他功能更容易测试。例如，一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>可以很容易地被测试，因为它的返回值对于相同的参数是相同的，并且它的求值没有副作用。另一方面，一个UI组件(例如一个<code class="fe me mf mg mh b">Calendar</code>组件)可以有多个子组件、各种输入和输出，并且依赖于外部API。有时候，很难说测试应该有多彻底。在某些情况下，验证快乐路径可能就足够了。在其他情况下，当它是关键软件部分时，您可能想要检查所有边缘情况。</p><p id="88a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，我们希望验证一个函数是用一组特定的参数调用的。例如，一个名为<code class="fe me mf mg mh b">getOrCreate(id)</code>的函数可能会调用一个名为<code class="fe me mf mg mh b">get(id)</code>的函数，我们可以使用期望来验证这个函数。不幸的是，事情并不总是那么简单:</p><ul class=""><li id="7406" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">函数可以有多个参数。</li><li id="2c2e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">函数可以有深度嵌套对象的参数。</li><li id="290e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">函数可以有不同类型的参数(如<code class="fe me mf mg mh b">parse(param: Date | string | number</code>)。</li></ul><p id="2b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了不使你的测试用例过于复杂，关注你真正关心的部分是一个好主意。幸运的是，许多测试框架提供了帮助编写好的测试期望的方法。在本文中，我将提到一些有用的测试期望工具，它们可以与Jest和Jasmine一起使用。</p><p id="dd80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">有趣的事实:我是在用JUnit(一个Java测试框架)编写测试之后才发现这些工具的，然后我想知道Jest和Jasmine是否也会有类似的东西。原来是这样的！</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="3e95" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">Jest和Jasmine Matchers可简化测试预期</h1><p id="d2f8" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">根据<a class="ae ky" href="https://jasmine.github.io/2.5/introduction" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="ns nt nu"><p id="3458" class="kz la mn lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated"><code class="fe me mf mg mh b">jasmine.any</code>将构造函数或“类”名作为期望值。如果构造函数匹配实际值的构造函数，它返回<code class="fe me mf mg mh b">true</code>。</p><p id="9aa4" class="kz la mn lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">如果实际值不是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>，则<code class="fe me mf mg mh b">jasmine.anything</code>返回<code class="fe me mf mg mh b">true</code></p><p id="1fc7" class="kz la mn lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated"><code class="fe me mf mg mh b">jasmine.stringMatching</code>用于当你不想精确匹配一个更大的对象中的字符串，或者匹配一个间谍期望中的字符串的一部分。</p><p id="afa5" class="kz la mn lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated"><code class="fe me mf mg mh b">jasmine.objectContaining</code>是针对那些期望只关心实际中的某些键/值对的时候。</p><p id="3ee5" class="kz la mn lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated"><code class="fe me mf mg mh b">jasmine.arrayContaining</code>适用于期望值只关心数组中某些值的情况。</p></blockquote><p id="67fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个展示所有这些功能的基本示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的测试案例中，我们使用像<code class="fe me mf mg mh b">jasmine.objectContaining</code>这样的助手来编写测试期望，这些期望集中在我们实际想要测试的部分。这使得我们的测试更容易阅读和维护。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8ff3" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="683a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">感谢您阅读这篇短文。正如您所看到的，Jasmine和Jest都提供了有用的工具来编写好的测试期望。你知道其他写合理的测试期望的技巧吗？请在评论中告诉我。</p></div></div>    
</body>
</html>