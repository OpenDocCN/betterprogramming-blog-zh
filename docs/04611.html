<html>
<head>
<title>How to Use OpenZeppelin’s New AccessControl Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用OpenZeppelin的新AccessControl合约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-openzeppelins-new-accesscontrol-contract-5b49a4bcd160?source=collection_archive---------3-----------------------#2020-04-24">https://betterprogramming.pub/how-to-use-openzeppelins-new-accesscontrol-contract-5b49a4bcd160?source=collection_archive---------3-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5989" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用最新版本的黄金标准智能合同库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9822ea69a6995205f29f5b801749eebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5JRtezpSoEU4VYYkJMMCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OpenZeppelin</p></figure><p id="bde8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">OpenZeppelin的智能合同库第三版已经发布了！在最新的版本中，他们引入了一种全新的方法来控制对函数的访问。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e229" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们所知道的</h1><p id="d020" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">控制对某些功能的访问对于确保智能合约的安全性至关重要，自从以太坊虚拟机推出以来，<a class="ae lu" href="https://solidity.readthedocs.io/en/v0.6.6/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>就是这种情况。</p><p id="3587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熟悉OpenZeppelin智能合同库的开发人员知道，它已经提供了根据访问级别限制功能的选项。</p><p id="1d4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最常见的是由<code class="fe mz na nb nc b">Ownable</code>契约管理的<code class="fe mz na nb nc b">onlyOwner</code>模式。另一个是Openzeppelin的<code class="fe mz na nb nc b">Roles</code>合同，它使合同能够在部署前定义多个角色，并在每个功能中设置规则，确保<code class="fe mz na nb nc b">msg.sender</code>拥有正确的角色。</p><h2 id="1f12" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">可拥有的</h2><p id="cd0c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe mz na nb nc b">onlyOwner</code>模式是最常用和最容易实现的访问控制方法。很原始但是很高效。</p><p id="a754" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它假设智能合约只有一个管理员，并允许管理员将所有权转移到另一个地址。</p><p id="4347" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">扩展<code class="fe mz na nb nc b">Ownable</code>契约允许子契约用<code class="fe mz na nb nc b">onlyOwner</code>自定义修饰符定义函数。这些功能要求交易的发送者是单一管理员。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="55bf" class="nd md it nc b gy nt nu l nv nw">function normalFunction() public {<br/>    // anyone can call this<br/>}</span><span id="661e" class="nd md it nc b gy nx nu l nv nw">function restrictedFunction() public onlyOwner {<br/>    // only the owner can call this<br/>}</span></pre><p id="ec42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个简单的例子，展示了如何利用由<code class="fe mz na nb nc b">Ownable</code>契约提供的自定义修饰符来限制函数访问。</p><h2 id="c30d" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">角色</h2><p id="4d99" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">尽管<code class="fe mz na nb nc b">Ownable</code>契约非常流行且易于使用，但是存储库中的其他OpenZeppelin契约只使用<code class="fe mz na nb nc b">Roles</code>库进行访问控制。这是因为<code class="fe mz na nb nc b">Roles</code>库提供的灵活性超过了<code class="fe mz na nb nc b">Ownable</code>契约的刚性。</p><p id="c1ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个库，它没有被子契约扩展，而是被用作一个工具，通过<code class="fe mz na nb nc b">using</code>语句向数据类型添加功能。<code class="fe mz na nb nc b">Roles</code>库为<code class="fe mz na nb nc b">Role</code>数据类型提供了三个函数，这是它自己定义的。</p><p id="3331" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图1显示了<code class="fe mz na nb nc b">Roles</code>的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1: Roles.sol</p></figure><p id="d2f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在顶部，您可以看到<code class="fe mz na nb nc b">Role</code>结构。契约使用它来定义多个角色及其成员。函数<code class="fe mz na nb nc b">add()</code>、<code class="fe mz na nb nc b">remove()</code>和<code class="fe mz na nb nc b">has()</code>是库用来与<code class="fe mz na nb nc b">Role</code>结构交互的函数。</p><p id="12bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，图2显示了一个令牌如何使用两个独立的角色<code class="fe mz na nb nc b">_minters</code>和<code class="fe mz na nb nc b">_burners</code>，来对某些功能应用访问限制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:实现角色</p></figure><p id="e4fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意在<code class="fe mz na nb nc b">mint()</code>函数中，require语句如何通过使用<code class="fe mz na nb nc b">_minters.has(msg.sender)</code>函数来确保消息的发送者是minter。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c668" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">怎么样</h1><p id="d424" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">鉴于这已经成为标准有一段时间了，对开发者来说一个大消息是<strong class="la iu"/><code class="fe mz na nb nc b"><strong class="la iu">Roles</strong></code><strong class="la iu">契约已经在从版本2.5.x到3.x的升级中被移除</strong></p><h2 id="4c5d" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">原则</h2><p id="f872" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe mz na nb nc b">Roles</code>库在它所提供的功能上有些限制。</p><p id="d303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个库，数据存储必须受进口合同的控制。理想情况下，访问控制应该在某种程度上被抽象出来，导入契约只需要考虑对每个功能的限制。</p><p id="0702" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的<code class="fe mz na nb nc b">AccessControl</code>合同被吹捧为:</p><blockquote class="oa ob oc"><p id="b97d" class="ky kz od la b lb lc ju ld le lf jx lg oe li lj lk of lm ln lo og lq lr ls lt im bi translated">“满足所有授权需求的一站式商店。它让您可以轻松定义具有不同权限的多个角色，以及允许哪些帐户授予和撤销每个角色。它还通过启用系统中所有特权帐户的枚举来提高透明度。”</p></blockquote><p id="59da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该语句的最后两点在<code class="fe mz na nb nc b">Roles</code>库中是不可能的。</p><p id="0154" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">OpenZeppelin看起来正在转向一个更像基于角色的访问控制(RBAC)和基于属性的访问控制(ABAC)标准的系统，这两种标准在传统计算安全中非常突出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">剖析代码</h1><p id="a803" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">图3显示了<code class="fe mz na nb nc b">AccessControl</code>合同代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3: AccessControl定义</p></figure><p id="3c4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第42行的<code class="fe mz na nb nc b">RoleData</code>结构使用<code class="fe mz na nb nc b">EnumerableSet</code>(也是版本3的新特性)作为存储成员的数据结构。这允许对特权用户进行简单的迭代。</p><p id="61a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该结构还将<code class="fe mz na nb nc b">adminRole</code>存储为一个<code class="fe mz na nb nc b">bytes32</code>变量。这定义了哪个角色充当特定角色的管理员(即，能够充当该角色的管理员的角色，向用户授予和撤销该角色)。</p><p id="8ee7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当角色被授予或撤销时，就会发出事件，这在第57行和第66行进行了定义。</p><p id="c28a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">Roles</code>契约只提供了三个功能:<code class="fe mz na nb nc b">has()</code>、<code class="fe mz na nb nc b">add()</code>和<code class="fe mz na nb nc b">remove()</code>。这些形式存在于<code class="fe mz na nb nc b">AccessControl</code>中，还有额外的功能，如获取角色计数、通过ID获取角色的特定成员，以及放弃角色的能力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何使用它</h1><p id="4db2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">图2给出了一个令牌契约的例子，它需要两个单独的角色，<code class="fe mz na nb nc b">_minters</code>和<code class="fe mz na nb nc b">_burners</code>，使用了<code class="fe mz na nb nc b">Roles</code>库。为了保持连续性，我们将使用相同的概念并应用<code class="fe mz na nb nc b">AccessControl</code>契约来实现。</p><p id="cce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图4显示了它的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:实现访问控制</p></figure><p id="d370" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，发生了什么变化？首先，每个角色不再在子契约中定义，因为它们存储在父契约中。只有字节32 id作为常量状态变量存在于子契约中(本例中为<code class="fe mz na nb nc b">MINTER_ROLE</code>和<code class="fe mz na nb nc b">BURNER_ROLE</code>)。</p><p id="b5de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在构造函数中使用<code class="fe mz na nb nc b">_setupRole()</code>来设置角色的初始管理员，绕过<code class="fe mz na nb nc b">AccessControl</code>中的<code class="fe mz na nb nc b">grantRole()</code>执行的检查(因为在构造时还没有管理员)。</p><p id="513f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，不是调用库函数作为数据类型的扩展(即<code class="fe mz na nb nc b">_minters.has(msg.sender)</code>)，这些函数本身就是内部的(<code class="fe mz na nb nc b">hasRole(MINTER_ROLE, msg.sender)</code>)。这使得子契约中的代码通常更加清晰易读。</p><p id="f626" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与使用<code class="fe mz na nb nc b">Roles</code>库相比，抽象掉更多的功能可以让子契约更容易地构建在<code class="fe mz na nb nc b">AccessControl</code>契约之上。在上一篇文章中，<a class="ae lu" href="https://medium.com/coinmonks/proposing-future-ethereum-access-control-72e56e14e68e" rel="noopener">我提出了使用</a> <code class="fe mz na nb nc b"><a class="ae lu" href="https://medium.com/coinmonks/proposing-future-ethereum-access-control-72e56e14e68e" rel="noopener">AccessControl</a></code>构建的RBAC和ABAC系统的未来实现。</p><p id="8d0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有兴趣进一步探索这种可能性，加拿大阿尔贝托·单面山制作了<a class="ae lu" href="https://github.com/HQ20/contracts/tree/master/contracts/access" rel="noopener ugc nofollow" target="_blank">合同的例子，扩展了</a> <code class="fe mz na nb nc b"><a class="ae lu" href="https://github.com/HQ20/contracts/tree/master/contracts/access" rel="noopener ugc nofollow" target="_blank">AccessControl</a></code>提供的基本功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c23e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0570" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe mz na nb nc b">AccessControl</code>的推出是以太坊生态系统在系统安全方面向行业标准迈进的一大步。</p><p id="dc58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该合同得到了行业专家的大力支持。我想象一些有趣而复杂的系统将很快从这份合同中产生，将这一衣钵推得更远。</p><p id="be0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我强烈建议将OpenZeppelin合同导入到您的项目中，并自己对它们进行扩展。你永远不知道你会学到什么或偶然发现什么！</p><p id="642b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>