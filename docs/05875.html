<html>
<head>
<title>Implementing a Global Authentication Interceptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现全局身份验证拦截器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-global-authentication-interceptor-8ee877143654?source=collection_archive---------6-----------------------#2020-08-13">https://betterprogramming.pub/implementing-a-global-authentication-interceptor-8ee877143654?source=collection_archive---------6-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用OkHttp拦截器刷新您的服务器访问令牌</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a64d3253ad720a4162997b75e1d978fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XaWt12Io37IExMwK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何实现一个全局身份验证拦截器。这个拦截器的工作是当您收到未经授权的响应时刷新访问令牌。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0df3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="c342" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将你的服务器升级到SSL并不一定意味着你在野外是安全的。您的服务器需要确认您在没有任何黑客拦截的情况下与用户通信(通常被称为中间人攻击)。</p><p id="a984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速注意:在大多数情况下，使用证书锁定功能可以避免中间人攻击。你可以从这篇<a class="ae ky" href="https://medium.com/better-programming/secure-communication-with-the-server-from-your-android-client-with-certificate-pinning-5f53cea55972" rel="noopener">文章</a>中了解什么是证书钉住，以及如何在Android中实现。</p><p id="04ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们有证书锁定，但最好有某种用户验证。有不同的方法来验证您正在与实际用户通信，其中之一是令牌验证。它可能是标准的JWT令牌，也可能是您自定义的逻辑。</p><p id="50a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在高层次上看到这个令牌验证，它将是这样的:首先，如果响应状态代码是401，这意味着未经授权，它可能是一个黑客拦截，或者实际的令牌已过期，您将执行一个常规的服务调用。在这种情况下，我们必须请求新的访问令牌。如果生成了令牌，那么我们必须重新初始化原始请求流。如果没有，我们应该注销用户，假设连接被破坏。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拦截机</h1><p id="04f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">理论部分讲够了，让我们从什么是拦截器开始。拦截器是一种强大的机制，可以监控、重写和重试服务调用。这里有一个简单的拦截器，它记录传出的请求和传入的响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用OkHttp3库的简单日志拦截器</p></figure><p id="fbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">addInterceptor</code>是我们可以向请求构建器OkHttp builder添加拦截器的函数。然后我们创建了一个拦截器的新实例，在其中我们获得了作为输入的<code class="fe nb nc nd ne b">interceptor.chain</code>。</p><p id="5697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个链中，我们可以得到<code class="fe nb nc nd ne b">request</code>对象，它包含了关于<code class="fe nb nc nd ne b">request</code>主体、标题等等的详细信息。一旦请求完成，我们就可以访问响应。</p><p id="a171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在<code class="fe nb nc nd ne b">chain</code>实例上调用带有<code class="fe nb nc nd ne b">request</code>对象的<code class="fe nb nc nd ne b">proceed</code>函数时，实际执行将开始。<code class="fe nb nc nd ne b">proceed</code>函数的输出是来自服务器的响应，包括附加信息，如状态代码和其他东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e5b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">认证拦截器</h1><p id="d0f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经了解了如何创建拦截器及其工作原理，那么让我们开始构建身份验证拦截器。</p><p id="9a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个拦截器的目标是当原始请求发出未经授权的访问时，调用访问令牌功能的刷新。成功检索到刷新后的令牌后，我们需要实例化请求。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">认证拦截器逻辑</p></figure><p id="6673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一步中，我们创建了原始的<code class="fe nb nc nd ne b">request</code>对象，如果我们得到了未授权的访问，就重新初始化它。在下一步中，我们用请求对象调用了链上的<code class="fe nb nc nd ne b">proceed</code>函数。</p><p id="4a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，请求开始执行。一旦请求完成，我们将得到响应，我们需要做的第一件事是通过比较状态代码来验证请求是否成功。如果响应中的状态代码是200，那么请求成功执行。</p><p id="eeeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果请求成功，那么我们必须直接返回响应。如果不是，我们需要使用状态代码检查错误类型。如果状态码是401，那么就是未授权访问；同样，如果您希望处理其他错误，我们需要在<code class="fe nb nc nd ne b">else</code>块中实现它。</p><p id="814b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果原始请求响应未经授权，那么我们需要创建一个新的请求来调用<code class="fe nb nc nd ne b">getAccessToken</code>服务调用。一旦我们首先获得响应，我们需要保存最新的访问令牌以备将来使用。</p><p id="2e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们需要更新原始请求对象中的最新令牌，然后重新发起请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="39d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最佳化</h1><p id="1ef0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">仅此而已。现在，您的应用程序有了一个全局身份验证拦截器。为了使代码更加优化，我们可以创建一个新的类来扩展拦截器，并在这里包含与身份验证相关的逻辑。这样，我们可以隔离拦截器的功能，因此代码看起来更有组织。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过代码隔离的错误处理拦截器</p></figure><p id="5c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要添加拦截器，我们需要创建一个<code class="fe nb nc nd ne b">ErrorHandlingInteceptor</code>的实例，如下所示:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a0d8" class="nj md it ne b gy nk nl l nm nn">val <strong class="ne iu">client </strong>= OkHttpClient.Builder()<strong class="ne iu"><br/>client</strong>.addInterceptor( <strong class="ne iu">ErrorHandlingInteceptor()</strong>)</span></pre></div></div>    
</body>
</html>