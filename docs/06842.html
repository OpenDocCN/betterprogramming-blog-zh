<html>
<head>
<title>Solving Deceiving Problems Presented by Heroku Dyno Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决Heroku Dyno过程提出的欺骗问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploying-a-python-discord-bot-using-dblpy-on-heroku-259e48c873ec?source=collection_archive---------10-----------------------#2020-11-10">https://betterprogramming.pub/deploying-a-python-discord-bot-using-dblpy-on-heroku-259e48c873ec?source=collection_archive---------10-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4bf8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将运行dblpy的Python Discord bot部署到Heroku</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ed77ba07b41648d167ea415983b8559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7plThrsRNdDYBYsbSheXBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抽象的web流程dyno(图片来源:作者)</p></figure><p id="1380" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有相当多的资源在讨论使用<a class="ae lr" href="https://discordpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> discordpy </a>库的Discord机器人的制作，还有相当多的资源在讨论Heroku 上的<a class="ae lr" href="https://www.freecodecamp.org/news/how-to-deploy-an-application-to-heroku/" rel="noopener ugc nofollow" target="_blank">主机。然而，当这两个主题放在一起时，信息似乎很少。</a></p><p id="ebed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我第一次开始构建Discord机器人时，我把所有的代码都混杂在一个名为<code class="fe ls lt lu lv b">bot.py</code>的文件中。随着我的知识和编程能力的进步，我很快就了解到了<a class="ae lr" href="https://discordpy.readthedocs.io/en/latest/ext/commands/cogs.html" rel="noopener ugc nofollow" target="_blank">齿</a>作为一种将命令组织成相应组的方式的美妙之处。在我最近的项目中，我决定实现<a class="ae lr" href="https://dblpy.readthedocs.io/en/latest/api.html" rel="noopener ugc nofollow" target="_blank"> dblpy API </a>，以便在用户投票给我的机器人时接收一个webhook。这个API非常简单，可以作为一个齿轮集成到我的项目中，它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://discordbots.org/api/docs#pylib" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="214a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">cog实际上使用指定的路径、认证令牌和端口创建了一个webhook服务器(在类的初始化中)。然后，每当POST请求被发送到该路径时，服务器就会获取它并执行<code class="fe ls lt lu lv b">on_dbl_vote</code>函数。我的目标是使用这些函数在用户投票的Discord频道中发送定制的消息。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="36bc" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">问题</h1><p id="52a2" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我遇到的第一个问题是不知道将定制的消息发送到哪里。默认情况下，POST请求发送的数据只包含投票用户的id和被投票的机器人的id。我无法通过使用这些数据来确定在哪个服务器和渠道中做出响应。</p><p id="0d88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的第二个问题是设置web服务器端点来接收webhooks。当我在本地测试我的程序时，我能够使用<a class="ae lr" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>将我的机器暴露给互联网，然后向提供的ngrok URL发送请求。当我把我的机器人部署到Heroku时，这是不可行的。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="934b" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">溶液过程</h1><p id="0ee7" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">POST请求发送的数据中包括对投票URL的查询。典型的URL如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/8ca72133b4a36e7b002a511e8982392d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mzLyxLZ5Da1bNPdE.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://tomcrowedigital.com/common-ecommerce-issues-mistakes" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="9230" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过让用户单击包含服务器和频道id的查询参数的链接，我可以在收到投票事件时随时获得这些数据。我的实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c962" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样一来，我就可以在Heroku上托管我的机器人了。我清理了我的代码，并将我的开发分支与我的主分支合并，然后由Heroku的自动部署进行挑选。我在<a class="ae lr" href="https://top.gg/" rel="noopener ugc nofollow" target="_blank"> Discord Bot List </a> (DBL)上更改了webserver端点，使其指向我的Heroku应用所在的位置，而不是指向我的本地机器。我等待我的机器人启动，然后从DBL发送一个测试后的请求。很快，我开始得到一个错误，告诉我没有web进程在运行。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="8593" class="nh mg iq lv b gy ni nj l nk nl">at=error code=H14 desc="No web processes running" method=POST path="/dblwebhook" host=_.herokuapp.com request_id=7a54e44c-5c2a-40fe-8bfc-097313c0c919 fwd="_" dyno= connect= service= status=503 bytes= protocol=https</span></pre><p id="c0f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在研究了错误之后，我的Procfile似乎配置错误。Procfile告诉Heroku要运行什么类型的进程，以及在什么文件上运行该进程。我将我的进程类型设置为<em class="nm">工人</em>，进一步研究后发现它不适合web服务器。来自<a class="ae lr" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank"> Heroku </a>:</p><blockquote class="nn no np"><p id="3198" class="kv kw nm kx b ky kz jr la lb lc ju ld nq lf lg lh nr lj lk ll ns ln lo lp lq ij bi translated">“Heroku应用程序的web进程类型很特殊:它是唯一可以从Heroku路由器接收外部HTTP流量的进程类型。如果您的应用程序包含web服务器，您应该将其声明为应用程序的web进程。</p></blockquote><p id="a874" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，我刚刚错误地配置了我的流程类型，所需要的只是从<em class="nm"> worker </em>到<em class="nm"> web </em>的快速改变。这正是我所做的。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="b007" class="nh mg iq lv b gy ni nj l nk nl"># worker: python bot.py<br/>web: python bot.py</span></pre><p id="a74a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将我的代码推送到GitHub，并通过向Heroku应用程序的端点发送POST请求再次测试了我的DBL投票事件，它成功了！我的机器人已经收到了网络钩子并做出了相应的反应。然而，如果没有附带的警告，我不会写一篇关于我在第二次尝试中实现的简单解决方案的文章。不幸的是，我从<em class="nm">工人</em>到<em class="nm">网络</em>的转变就是这样。</p><p id="6703" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Python bot推荐使用工作进程的原因是它总是处于活动状态。这意味着工人总是在倾听命令，并能够立即做出反应。另一方面，web进程在空闲一段时间后会进入休眠状态。</p><p id="ccaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如Heroku文档中所述，</p><blockquote class="nn no np"><p id="edeb" class="kv kw nm kx b ky kz jr la lb lc ju ld nq lf lg lh nr lj lk ll ns ln lo lp lq ij bi translated">“如果一个应用程序有一个免费的web dyno，而该dyno在30分钟内没有收到任何web流量，它将<strong class="kx ir">休眠</strong>。”</p></blockquote><p id="3767" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于显而易见的原因，这不适用于Discord bot，它通过API而不是通过web接收流量。在这一点上，我尝试了许多不同的解决方案，从创建我自己的web服务器并在Heroku之外托管它，到重构我的代码，到不断调用<a class="ae lr" href="https://dblpy.readthedocs.io/en/latest/api.html" rel="noopener ugc nofollow" target="_blank"> dblpy </a> API进行投票计数。这些都没有给我带来多大的成功，我又回到了起点:需要web进程的HTTP路由，但是需要工作进程的正常运行时间。同时运行这两个进程怎么样？</p><p id="3203" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我修改了我的Procfile，让我的进程同时运行我的<code class="fe ls lt lu lv b">bot.py</code>文件，如下所示:</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="abb3" class="nh mg iq lv b gy ni nj l nk nl">worker: python bot.py<br/>web: python bot.py</span></pre><p id="09be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将我的代码推送出去，并向我的应用程序域发送了一个测试webhook。然后，web进程触发并在正确的通道中发送适当的响应。那里一切似乎都很好。接下来，我在Discord chat中尝试了一个命令，并等待worker进程对它做出反应。这也奏效了；然而，工作进程并不是唯一一个捕获命令的进程。</p><p id="4a9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还记得web进程在收到web流量后是如何空闲一段时间的吗？在这段空闲时间里，它的行为就像工作进程一样，能够从Discord API接收命令。这意味着在某人投票后的三十分钟内，任何随后输入的命令都会得到类似如下的重复响应:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/93ecc3b9f9022042091917cab8780e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1Dt906Q9UOPZMq0zIZXIw.png"/></div></div></figure><p id="bf1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为防止双重响应的唯一方法是划分流程的任务。我制作了一份我的<code class="fe ls lt lu lv b">bot.py</code>文件的副本，并将其命名为<code class="fe ls lt lu lv b">bot_web.py</code>。这个新文件运行了我的Discord bot的第二个实例，但它只负责web功能。</p><p id="de90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将新文件与我的web服务器链接起来，我创建了一个名为<code class="fe ls lt lu lv b">cogs_web</code>的新文件夹，并添加了我的<code class="fe ls lt lu lv b">dbl.py</code>文件。现在，web流程能够访问的唯一cogs是与web服务器相关联的cogs。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/36ec99df9ac691af386623c71ed06fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZVtJX1X-wpLxTXUmX8j1A.png"/></div></div></figure><p id="7e98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将我的Procfile更改为:</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="eccf" class="nh mg iq lv b gy ni nj l nk nl">worker: python bot.py<br/>web: python bot_web.py</span></pre><p id="8faf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我把我的新代码推到GitHub重新部署。我再次将我的测试webhook发送到我的Heroku应用程序，并将我的测试命令发送到我的Discord服务器。这一次一切似乎都很完美，我能够按预期使用机器人。但是遗憾的是，我在Heroku文档中漏掉了一行，这将是这个解决方案失败的原因。</p><blockquote class="nn no np"><p id="a28a" class="kv kw nm kx b ky kz jr la lb lc ju ld nq lf lg lh nr lj lk ll ns ln lo lp lq ij bi translated">"除了web dyno睡眠之外，worker dyno(如果存在)也会<em class="iq">睡眠."</em></p></blockquote><p id="527b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">web流程实际上会导致任何其他流程停止运行。这意味着每当web进程进入睡眠状态时，worker进程也会跟着进入睡眠状态。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="780f" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">解决办法</h1><p id="3382" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">一次次的失败难倒了我，我有了将我的Discord机器人投入生产的最终想法:两个不同的Heroku应用程序。虽然网络服务器是主要项目的一部分，但Heroku不喜欢它与机器人的其余部分托管在一起。解决这个问题的一个简单方法是域分割。一个应用程序将处理机器人的主要功能，而另一个将托管web服务器并成为webhooks的端点。</p><p id="b5cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我通过创建一个新的Heroku应用程序并将其与我原来的应用程序使用的相同GitHub存储库连接来实现这一点。一旦两个应用程序都提取了相同的代码，我就在每个应用程序上切换流程类型，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/77c80d2d707ca33670c10efb9c9b7404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVj9z7yF2sGg41WRBVT96Q.png"/></div></div></figure><p id="f862" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最初的Heroku应用程序打开了工作进程，这样它就可以响应不和谐的命令，而关闭了web进程，以防止它休眠。与此同时，我的webserver Heroku应用程序反向工作，web进程打开以接收webhooks，而worker进程关闭。这种新的配置非常有效，因为没有任何dyno进程相互干扰或重叠作业。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="1c5c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">外卖食品</h1><p id="f27c" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">希望这篇文章对一个我觉得非常沮丧但最终能够解决的问题提供了见解。也许有比运行同一个机器人的两个实例更有效的解决方案，我很乐意听到它们。欢迎在下面留下任何想法，或者通过我的个人资料联系我。</p><p id="9641" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nm">本文中提到的项目的所有源代码都可以在我的</em> <a class="ae lr" href="https://github.com/kozzza/alice-bot" rel="noopener ugc nofollow" target="_blank"> <em class="nm"> GitHub </em> </a> <em class="nm">上找到，并随时邀请我的</em><a class="ae lr" href="https://top.gg/bot/723813871881551932" rel="noopener ugc nofollow" target="_blank"><em class="nm">Discord bot</em></a><em class="nm">到您的服务器上！</em></p></div></div>    
</body>
</html>