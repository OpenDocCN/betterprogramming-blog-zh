<html>
<head>
<title>Jetpack Compose Clean Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写干净的导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-clean-navigation-94b386f7a076?source=collection_archive---------1-----------------------#2022-10-03">https://betterprogramming.pub/jetpack-compose-clean-navigation-94b386f7a076?source=collection_archive---------1-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Jetpack Compose中实现干净导航</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65bc3c4270270d0a7bf2d2f02cd50538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni1e3G8oYf9eNUL6UhxVCg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本图中使用的Jetpack Compose徽标是由Google创建的官方徽标<a class="ae kv" href="https://android-developers.googleblog.com/2020/08/announcing-jetpack-compose-alpha.html" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="2063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Android世界的每个人都知道Jetpack Compose中的导航并不是它最闪亮的一面。执行导航需要传递大量的<code class="fe ls lt lu lv b">callbacks</code>和<code class="fe ls lt lu lv b">navControllers</code>，如果在发送参数之前需要做一些业务逻辑呢？代码变得相当混乱。</p><p id="d8b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于如何实现导航有很多讨论，<a class="ae kv" href="https://github.com/raamcosta/compose-destinations" rel="noopener ugc nofollow" target="_blank">一个很棒的库也有</a>。请随意查看，为拉斐尔·科斯塔创造了这样的东西而欢呼吧。</p><p id="41b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你不想依赖别人，或者你公司的政策是不使用外部库，那该怎么办呢？导航是应用程序中最重要的事情之一。你不能依赖别人，即使那个图书馆是全天候维护的。你需要创造一个有效的解决方案。在讨论我的干净解决方案之前，让我们深入问题，这样我们就能100%理解我们在这里做什么。</p><h1 id="6523" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">问题简介</h1><p id="534d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当前最常见的导航实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你超过了兰姆达斯，就这样。第二个选择是你通过<code class="fe ls lt lu lv b">navController</code>而不是lambdas。这两种解决方案看起来都没那么好。如果屏幕足够复杂，它可能有太多的回调。你的代码变得混乱不堪。也许你关于路由的逻辑不是这样硬编码的，但是你得到了问题的关键。</p><p id="b465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要做一些业务逻辑，比如计算一些东西，计算的结果是下一屏的一个参数怎么办？您需要调用<code class="fe ls lt lu lv b">ViewModel</code>来完成业务逻辑(<code class="fe ls lt lu lv b">View</code>不应该这么做)，观察结果，然后调用回调。在<code class="fe ls lt lu lv b">Screen</code>和<code class="fe ls lt lu lv b">ViewModel</code>之间前后移动太多。</p><p id="262b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着解决所有这些问题，让它变得更干净一点。</p><h1 id="790d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Jetpack撰写干净的导航</h1><p id="8981" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我的解决方案的想法是有一个自定义导航器，将提供给每一个<code class="fe ls lt lu lv b">ViewModel</code>。通过调用导航器的功能，我们可以导航到不同的屏幕。所有导航事件都收集在<code class="fe ls lt lu lv b">MainScreen</code>中，这样我们就不需要向其他屏幕传递回调或<code class="fe ls lt lu lv b">navController</code>。一旦我们仔细阅读代码，就会更清楚了。</p><p id="0c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们为路由创建一个特殊的类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="afd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Destination</code>有一个带两个参数的构造函数。第一个是基本路由，第二个是该路由的参数。每个<code class="fe ls lt lu lv b">Destination</code>会有<code class="fe ls lt lu lv b">route</code>和<code class="fe ls lt lu lv b">fullRoute</code>。<code class="fe ls lt lu lv b">route</code>是没有参数的基本路线，将使用该路线创建带有参数名称的<code class="fe ls lt lu lv b">fullRoute</code>或带有参数值的<code class="fe ls lt lu lv b">fullRoute</code>。</p><p id="ac91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe ls lt lu lv b">Destination</code>将返回它的路由。<code class="fe ls lt lu lv b">appendParams</code>函数将只是向路线添加参数，并返回带有参数值的<code class="fe ls lt lu lv b">fullRoute</code>。</p><p id="3afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来是添加一些我们将要使用的导航组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9f2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">NavHost</code>与<code class="fe ls lt lu lv b">androidx.navigation.compose</code>中的相同，唯一不同的是<code class="fe ls lt lu lv b">startDestination</code>参数属于<code class="fe ls lt lu lv b">Destination</code>类型。</p><p id="b7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的事情，用<code class="fe ls lt lu lv b">composable</code>代替<code class="fe ls lt lu lv b">route: String</code>，我们有<code class="fe ls lt lu lv b">destination: Destination</code>。</p><p id="9a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们实现自定义导航器。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ef85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">AppNavigator</code>有<code class="fe ls lt lu lv b">navigationChannel</code>将被收集在<code class="fe ls lt lu lv b">MainScreen</code>中，它有四个导航功能。包含所有可能发生的导航意图。你可以在这里添加更多的链接，例如，一个深层链接或类似的东西。<code class="fe ls lt lu lv b">navController</code>函数需要每个<code class="fe ls lt lu lv b">NavigationIntent</code>的参数。</p><p id="7121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">AppNavigator</code>的实现非常简单。只是将<code class="fe ls lt lu lv b">NavigationIntents</code>发送给<code class="fe ls lt lu lv b">navigationChannel</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个小提示，我使用<code class="fe ls lt lu lv b">Dagger-Hilt</code>作为阿迪框架。随意使用任何DI框架。</p><p id="29e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来实现<code class="fe ls lt lu lv b">MainScreen</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="620e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">MainScreen</code>中，我们使用自定义的<code class="fe ls lt lu lv b">NavHost</code>和<code class="fe ls lt lu lv b">composable</code>。我们记得从<code class="fe ls lt lu lv b">MainViewModel</code>传到<code class="fe ls lt lu lv b">NavigationEffects</code>的<code class="fe ls lt lu lv b">navController</code>，以及从<code class="fe ls lt lu lv b">MainViewModel</code>传来的<code class="fe ls lt lu lv b">navigationChannel</code>。<code class="fe ls lt lu lv b">NavigationEffects</code>只需收集<code class="fe ls lt lu lv b">navigationChannel</code>并导航至所需屏幕。正如你所看到的，它更干净，我们不必通过任何回调或<code class="fe ls lt lu lv b">navController</code>。</p><p id="6c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">MainViewModel</code>简单。正在从<code class="fe ls lt lu lv b">AppNavigator</code>获取<code class="fe ls lt lu lv b">navigationChannel</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下唯一要展示的是我们如何调用导航器函数。我们来看一下<code class="fe ls lt lu lv b">HomeViewModel</code>的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ff61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">HomeScreen</code>将调用相应的函数，在<code class="fe ls lt lu lv b">HomeViewModel</code>中，我们只调用<code class="fe ls lt lu lv b">AppNavigator</code>函数，并作为路由的参数调用<code class="fe ls lt lu lv b">Destination</code>。</p><p id="4adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<code class="fe ls lt lu lv b">UsersViewModel</code>以查看向后导航和向路线传递参数的示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8f30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！</p><h1 id="13ab" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="1715" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我认为仍有改进的空间，但这可能是一个好的起点。这使得我们的代码更加干净，不需要在屏幕上收集来自<code class="fe ls lt lu lv b">ViewModel</code>的副作用来导航。</p><p id="87e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以争论是否应该从<code class="fe ls lt lu lv b">ViewModel</code>开始导航，但我认为应该这样。<code class="fe ls lt lu lv b">View</code>应该是“愚蠢的”，只显示数据。我们在点击上做什么，应该由<code class="fe ls lt lu lv b">ViewModel</code>负责。</p><p id="318e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的GitHub repo中找到所有的源代码。</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="16b1" class="mz lx iq lv b gy na nb l nc nd"><strong class="lv ir">Want to Connect?</strong></span><span id="878c" class="mz lx iq lv b gy ne nb l nc nd"><a class="ae kv" href="https://github.com/Giga99" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kv" href="https://www.linkedin.com/in/igor-stevanovic/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><a class="ae kv" href="https://twitter.com/igor_s1999" rel="noopener ugc nofollow" target="_blank"><br/>Twitter</a><br/><a class="ae kv" href="https://giga99.github.io/portfolio-website/" rel="noopener ugc nofollow" target="_blank">Portfolio website</a></span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="afbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想了解更多关于Jetpack Compose的信息，请阅读以下文章:</p><ul class=""><li id="3477" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implement-bottom-sheet-in-jetpack-compose-d6472e8eaf2e">在Jetpack Compose中执行底板</a></li><li id="5842" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implement-horizontal-and-vertical-viewpager-in-jetpack-compose-a7a91f2ac746">在Jetpack Compose中实现水平和垂直view pager</a></li><li id="f1f7" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://medium.com/better-programming/build-a-camera-android-app-in-jetpack-compose-using-camerax-4d5dfbfbe8ec" rel="noopener">使用CameraX在Jetpack Compose中构建一个相机Android应用</a></li></ul><p id="2f65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，通过阅读本文，您可以了解如何使用拦截器在请求中包含访问令牌:</p><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/android-access-token-logic-with-retrofit-okhttp-interceptors-740ea48547a0"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Android访问令牌逻辑和改进的OkHttp拦截器</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使用OkHttp拦截器的访问令牌头逻辑</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">better编程. pub</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>