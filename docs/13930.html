<html>
<head>
<title>How to Transform a Monolith Application Into a Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将整体应用程序转变为微服务架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-transform-a-monolith-application-into-a-microservices-architecture-1e00363a03ba?source=collection_archive---------1-----------------------#2022-10-16">https://betterprogramming.pub/how-to-transform-a-monolith-application-into-a-microservices-architecture-1e00363a03ba?source=collection_archive---------1-----------------------#2022-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将monolith应用程序迁移到微服务架构的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9cd0e40bc2333fcfc8e282cc127ea4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_gGddQ60pK46sDmI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安德斯·吉尔登在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片|所有其他图片由作者提供</p></figure><p id="64d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们以一家运营多年的创业公司为例。他们的主要目标是建立平台和扩大公司。</p><p id="4e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发团队继续在相同的代码基础上添加新的特性和服务。经过几年的不断扩张，他们的代码库变得太大，并显示出局限性。</p><p id="4dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下问题开始出现:</p><ul class=""><li id="5d17" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">不可能运行主测试服，因为它太大了。此外，运行和验证代码需要太多时间。</li><li id="b8e6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">因为单个应用程序处理每个请求，所以伸缩是困难的。</li><li id="e628" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">太多的依赖项必须在上线前更新和全面测试，这使得升级框架、语言版本或操作系统变得不可能。</li><li id="bf0d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">难以在截止日期前完成，因为开发人员无法理解产品。</li><li id="f5ea" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">开发速度变得非常慢，不能处理所有的依赖。</li><li id="2891" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">团队有太多的开发人员，没有一台开发机器可以处理产品。</li></ul><p id="a384" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示如何将单片应用程序转换为微服务架构，我构建了如下所示的示例架构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/7fd514e3669f4581d5c8f234d0c4dfd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVqI-sw6ulSvwBy2iNoh-A.png"/></div></div></figure><p id="b031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然应用程序可以提供多种服务，但是为了这篇文章，我们必须限制我们的范围。</p><h1 id="11cd" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">这个不可思议的旅程的开始</h1><p id="575b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在第一阶段，您可以将您的应用程序分成多个项目，而无需重写代码库，最重要的是，不会打扰您的客户/用户。</p><p id="d0e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始迁移到新的应用程序之前。记住下面这句话:</p><blockquote class="ne"><p id="e4ef" class="nf ng iq bd nh ni nj nk nl nm nn lr dk translated">停止给巨石柱喂食</p></blockquote><p id="9374" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">如果你不明白它的意思，请继续读下去。</p><p id="6939" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一次，每当你添加一个新的代码到你的monolith，提醒你自己和你的团队避免喂养你的monolith。</p><p id="6e39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你准备好了，我们开始吧。</p><p id="b21e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您在monolith服务器上使用了一个名为“monolith-repo”的代码存储库，在这里您可以处理所有类型的请求并运行后端作业。</p><h1 id="e99b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">步骤1:将Cron作业和守护进程移动到新的服务器上</h1><p id="d191" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我选择这个是因为它是内部的，如果我们把所有的后端工作转移到新的服务器上，没有人会受到干扰。</p><p id="b92a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到您的项目目录。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="34ec" class="ny mi iq nu b gy nz oa l ob oc">cd monolith-repo</span></pre><p id="f2ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从“主”分支创建一个分支，并将其命名为“cron-jobs-and-daemons”</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="e729" class="ny mi iq nu b gy nz oa l ob oc">git branch cron-jobs-and-daemons</span></pre><p id="ee18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该在项目中看到两个分支:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0c79" class="ny mi iq nu b gy nz oa l ob oc">git branch<br/>main<br/>cron-jobs-and-daemons</span></pre><p id="a10d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个新的分支。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3197" class="ny mi iq nu b gy nz oa l ob oc">git checkout cron-jobs-and-daemons</span></pre><p id="e031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候将代码库从“整体回购”中分离出来了为此，在GitHub中创建一个新的私有存储库，并给出自己选择的名称。我称之为“后端工作”</p><p id="78e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了新的存储库，就将“cron-jobs-and-daemons”分支从“monolith-repo”推到这个新的存储库。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="6a13" class="ny mi iq nu b gy nz oa l ob oc">git push <a class="ae kv" href="https://github.com/tanvir/backend-jobs.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tanvir/backend-jobs.git</a> cron-jobs-and-daemons:cron-jobs-and-daemons</span></pre><p id="9fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的命令在新的存储库中创建了一个新的分支“cron-jobs-and-daemons”，并推送其中的所有代码。</p><p id="9062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">git创建“main”作为默认分支，其中没有任何内容。将“cron-jobs-and-daemon”分支合并到主分支中。</p><p id="a4a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的开发机器上创建一个“monolith-repo”项目的副本，命名为“backend-jobs”</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f7c1" class="ny mi iq nu b gy nz oa l ob oc">cp -R monolith-repo backend-jobs</span></pre><p id="20bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，两个存储库是相同的，并且代码没有区别。</p><p id="a5b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到您的新项目。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="ab5a" class="ny mi iq nu b gy nz oa l ob oc">cd backend-jobs</span></pre><p id="3faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目连接到您旧的monolith存储库，但是我们可以在<code class="fe od oe of nu b">.git/config</code>文件中将其更改为一个新的存储库。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="5315" class="ny mi iq nu b gy nz oa l ob oc">vi .git/config</span></pre><p id="a577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将GitHub的来源从旧的存储库更改为新的存储库。一旦项目与一个新的源连接起来，您就可以使用这个新的存储库了。</p><p id="3bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">移除“主”分支并再次获取它，以查看它是否已连接。如果你的主分支是空的，那么你是连通的。否则，您可能需要进行一些配置。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="4f56" class="ny mi iq nu b gy nz oa l ob oc">git branch -D main<br/>git fetch origin main:main<br/>git checkout main</span></pre><p id="00a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将您的“cron-jobs-and-daemon”合并到新存储库的“main”分支中。</p><p id="9984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您已经对这个概念有了更好的理解，我们已经创建了一个流畅的工作流来将我们的代码从一个存储库合并到另一个存储库。如果随后需要合并任何内容，我们可以轻松完成。</p><p id="bc72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请确保“monolith-repo”和“backend-jobs”的“主要”分支在这一点上是相同的，因为这两个项目现在将采取不同的开发路径。</p><p id="ee5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这感觉很奇怪，但请记住，我们的目标是“停止喂养巨石”</p><p id="d720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你成功地建立了这个工作流程，你就向停止整块石头的进给迈出了一步。</p><p id="5ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有后端作业都将被添加到“后端作业”存储库中，现在您将继续在“monolith-repo”中添加其他功能。</p><p id="5430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦准备就绪，下一个挑战就是在生产环境中进行部署，并将所有作业转移到这台新服务器上，而不会造成干扰或停机。</p><p id="31d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用云，创建monolith应用程序的映像来启动新的服务器。此过程将为您提供100%相同的配置，您可以信赖。</p><p id="e070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦后端作业服务器启动并运行，您可能需要修复数据库安全组。但是在此之前，停止新服务器上的所有cron作业和守护进程，因为它们运行在旧服务器上。修复数据库连接后，它将开始执行任务。</p><p id="29be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以完全控制您的新服务器。什么都没有运行，但是你已经准备好开始移动你的第一份工作。万岁！</p><p id="bab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">建议</strong>:休息一下，保持对一切事物的新鲜感。</p><p id="371d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候了。从最简单的工作开始。停用旧服务器上的第一个作业，并在新服务器上启动。</p><p id="bc1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在确认第一个工单之前，不要移动第二个工单。即使是同一个服务器，也不要相信它在工作。进行适当的测试，确认搬运工作正常。</p><p id="db5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您的第一个任务开始工作，您就可以继续下一个任务，以此类推，直到您的所有作业都被迁移。</p><p id="e2a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！通过这样做，您已经在您的组织中建立了一个迁移到微服务架构的工作流。我知道这不是一个微服务，但离迁移到那里又近了一步。</p><p id="9ea1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成这一转换后，应用程序架构将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/9196e181c6e7bea98e9e5b9c60d68d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzZqCeGewG5c1T0d_DvGbw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用服务器和后端作业服务器</p></figure><p id="ddf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经转移到两个不同的应用程序，而没有创建新的代码，也没有向团队添加新的专业知识或技术。</p><p id="77ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">庆祝的时间到了！</p><p id="1953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们进入下一个应用程序之前，还有一件事要讨论。</p><p id="e659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您切换到了一台新的服务器，但仍有一些作业等待部署。问题是，在开发这些工作的旧“整体回购”上发出了拉取请求。</p><p id="792e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住我们在上面建立的工作流程。一旦主分支中合并了pull请求，您就可以将主分支合并到“cron-jobs-and-daemons”分支，并将其推送到新的存储库，就像我们之前所做的那样。</p><p id="fd6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您的代码被推送到一个新的存储库，您就可以创建一个新的临时分支“merge-main-and-cron-jobs-and-daemon”来创建一个稳定的状态。一旦成功合并，您就可以在您的主分支中合并它，并在生产中部署它。</p><p id="7033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看这个工作流程有多灵活。您可以开始开发新的特性，也可以合并旧分支的代码，而无需停止持续的开发和部署。</p><h1 id="3d67" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">步骤2:将您的超级管理员功能转移到新的应用程序/服务器</h1><p id="03e5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这个应用程序是内部的，因为如果出现问题，不会对我们的客户造成伤害。内部用户可能会受到影响，但是让我们信守承诺，在不干扰工作流的情况下将这个应用程序迁移到新的服务器上。</p><p id="4c35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要遵循与上面相同的步骤，但是有额外的步骤，因为这个web应用程序有到所有其他应用程序的路由。在这一点上，我强烈建议删除路由定义，以访问除超级管理员以外的其他应用程序路由。</p><p id="7246" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成这一转换后，应用程序架构将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/217cffe56c29dca8a684ccf7c4f243dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9E6KvvwrepTeKUhzzehFTg.png"/></div></div></figure><p id="2f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经到了这一步，我假设您理解这种划分应用服务器的方法背后的原因，这样我们就可以停止向我们的monolith应用程序添加新代码。</p><h1 id="eca2" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">步骤3:现在是时候将所有其他用户应用程序转移到他们自己的存储库和服务器中了</h1><p id="20d3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">前两步是为了让您在接触比其他应用程序更关键的特定于用户的应用程序之前获得经验。</p><p id="d487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，按照上面学到的所有步骤，为每个应用程序创建额外的域。</p><p id="e2cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><p id="b6ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe od oe of nu b">domain.com</code> <br/> <code class="fe od oe of nu b">admin.domain.com</code> <br/> <code class="fe od oe of nu b">api.domain.com</code> <br/></p><p id="99fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，您会非常小心地逐一准备和推出这些应用程序。</p><p id="e937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您认为您的用户在管理员和其他应用程序之间是共享的，那么在应用程序之间使用共享的登录cookie。这样，您的用户只需登录一次就可以访问其他应用程序。</p><p id="2b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始构建真正的微服务之前，您的应用的最终架构将如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/a6a4f45b293c0590b97fe9618feaf515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhTk3H6R34U3fLsDwYwJGg.png"/></div></div></figure><p id="e69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这之后，你的monolith-repo就不再被使用了，你可以在你的GitHub账户中存档或者设置为只读。</p><p id="9f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！你已经成功地“停止给巨石柱喂食”</p><p id="d539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你现在有几个选择。每种选择都各有利弊。</p><h1 id="1c97" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">(可选)步骤4:清理所有存储库</h1><p id="248d" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">至此，您已经在所有专用存储库中复制了monolith应用程序。现在您可以在您的开发工作流程中创建一个计划来分配一定数量的资源，并删除所有与应用程序无关的额外代码。</p><p id="3809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的monolith应用程序现在已经在所有特定的存储库中复制了。现在可以删除应用程序中不必要的代码了，您可以在开发工作流中建立一个计划来分配特定数量的资源。</p><p id="21e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，管理存储库不需要API、超级管理和后端作业的代码。慢慢地删除所有这些，并将其部署在生产服务器上。</p><p id="139c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以对所有其他应用程序执行相同的步骤，以保留它所需要的内容。</p><p id="00b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为您只添加了必要的代码，所以这一步将帮助您提高应用程序的性能并简化开发。</p><h1 id="3e94" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">(可选)步骤5:将应用程序升级到最新的框架、编程语言版本和Linux发行版</h1><p id="898e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在所有的应用程序都很小巧，易于升级。测试套装运行速度更快，因为它更小，可以快速测试相关的应用程序。</p><p id="4528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上五个步骤可能会花费你的开发团队很多时间；然而，它发生在你开发产品的其他功能和不断发展业务的时候。</p><p id="f0d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您已经建立了一个良好的开发工作流，可以导致独立的微服务，因为您可以看到数据库是架构的瓶颈。如果业务增长过快，它就无法扩展。</p><p id="7450" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据你的资源和公司增长率，你可以做第4步和第5步。否则，您可以直接转到第6步，我们将在架构中引入独立的微服务。</p><h1 id="65b7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">步骤6:微服务架构之路</h1><p id="93c4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">大多数应用都有一些通用的功能，这些功能很容易被识别并转移到独立的微服务中。</p><p id="6494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我总是把微服务分为两类:外部和内部。</p><p id="b6c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">外部:与外部服务通信以执行特定任务的微服务，如发送电子邮件、支付网关、视频编码等。</p><p id="6eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内部:第二类微服务在平台内部执行任务，如用户API、订单API、玩家API等。</p><p id="7a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于哪种类型的微服务易于构建并与平台集成，一直存在争议。我总是说外部服务很容易成为目标。</p><p id="0eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，电子邮件服务是第一个，因为它不依赖于数据库或其他任何东西。我将称之为“消息API”</p><p id="f161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将其构建为REST API或无服务器应用程序。您可以将发送电子邮件的逻辑移到这个API中，并将其与所有向用户发送电子邮件的应用程序集成在一起。</p><p id="b7c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该微服务将与外部电子邮件服务进行通信，如AWS SES、邮戳或您使用的任何其他服务。它将帮助您封装对其自身微服务的依赖。</p><p id="7d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次微服务后，您的应用架构将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fcbfff0e548ab1ffd74e182081efb178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDgeaj2vDlBHR7haqMTj_g.png"/></div></div></figure><p id="a391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当第一个微服务上线时，你应该和你的团队一起庆祝，因为你已经建立了一个工作流程，开始将你的整体架构转变为真正的微服务。</p><p id="83f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在遵循同样的路径，构建其他外部微服务，并将它们集成到您的应用程序中。</p><p id="c517" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内部微服务总是需要额外的工作，因为我们必须拆分数据库并解决其他依赖关系。在这里，我可以推荐两种分割数据库及其相关API的方法。</p><p id="021b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这取决于你的团队决定走哪条路。我将在本文中向您解释这两个问题:</p><ol class=""><li id="2fba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ok ly lz ma bi translated">首先是API，然后是数据库</li><li id="5268" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ok ly lz ma bi translated">API和数据库同时分离</li></ol><p id="237d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个练习的目标是所有的应用程序都将作为前端应用程序运行，所有的一切都将通过一个API来完成。</p><p id="3ffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要拆分数据库并构建新的API来支持前端应用程序。</p><h1 id="20a9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">解决方案1:先有API，后有数据库</h1><p id="ebe2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们需要找到一种不依赖其他东西而能独立生存的商业模式。例如，具有从系统添加、更新和删除订单的基本订单API。</p><p id="47f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经将monolith应用程序分成了多个应用程序，订单功能可能会在多个应用程序中复制。这意味着我们有许多重复的代码来执行相同的任务。现在是时候解决这个问题了。</p><p id="cc04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将引入订单API，并将所有逻辑移入应用程序。将大量代码复制粘贴到新的API中。</p><p id="b4dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是订单API的端点:</p><ul class=""><li id="dc8e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe od oe of nu b">POST /orders</code></li><li id="93d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe od oe of nu b">GET /orders/{order-key}</code></li><li id="f41b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe od oe of nu b">DELETE /orders/{order-key}</code></li></ul><p id="6492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以将订单API集成到发生这些操作的所有应用程序中，并删除重复的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/ac4ffa0aa1ca6757ce085783dc1863b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaVBysmpfjls90Xnt2KdFg.png"/></div></div></figure><p id="50b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，架构正在成长，API也开始有所回报。尽管订单API与monolith数据库的通信必须被修复。让我们马上解决这个问题。</p><p id="f2f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在尝试分离关系数据库，它很难从活动的应用程序中分离出来，并且可能在多个表中具有作为外键的顺序关系。</p><p id="9bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前没有与订单表的直接连接，因为所有订单都通过新的订单API。为了防止对订单表的直接查询，在将订单数据移动到单独的数据库之前，我们必须确保所有关系都通过订单API端点检索数据。</p><h1 id="37d6" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">订单数据库作为独立的微服务</h1><p id="c8f0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们需要创建一个新的数据库，并将您现有的所有订单迁移到其中。</p><p id="4994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于它是一个订单不断到来的生产应用程序，如何将所有最新的订单同步到一个新的数据库而不丢失它们呢？</p><p id="d014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过AWS出色的<a class="ae kv" href="https://aws.amazon.com/dms/" rel="noopener ugc nofollow" target="_blank">数据迁移服务</a>来实现这个目标。创建在新数据库和monolith之间持续同步数据的数据迁移任务。</p><p id="387b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的<code class="fe od oe of nu b">Order</code>表现在在新数据库和monolith之间是相同的。</p><p id="0266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是连接到新的数据库，并断开您的API与monolith的连接。</p><p id="2091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦订单API开始使用新的数据库，所有即将到来的订单将被添加到新的数据库，而不是monolith。</p><p id="06e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">庆祝的时间到了！</p><p id="8e9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的平台上运行了第一个独立的微服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/32808a32e59c0c9e599f6940e3bc5348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjqYv0xFoOGCqhdEwH51og.png"/></div></div></figure><p id="09cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个微服务可能需要一些额外的步骤，但如果你遵循我的基本准则，你可以实现你的目标。</p><h1 id="435f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">解决方案2: API和数据库同时拆分</h1><p id="47eb" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果你觉得方案1太慢，可以一气呵成，那就开发你的微服务API，同时拆分数据库。</p><h2 id="b40f" class="ny mi iq bd mj on oo dn mn op oq dp mr lf or os mt lj ot ou mv ln ov ow mx ox bi translated">下一步是什么？</h2><p id="af31" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">您可以继续创建新的微服务，并将它们与前端应用程序集成，直到您完成为止。</p><p id="6a7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您的前端应用程序不再直接与数据库和来自API的一切进行通信，您就可以计划在最新的框架中开发您的现代前端。</p><p id="3ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。</p><p id="bc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你从这篇文章中学到了一些东西。如果你有问题，请随时提问。</p></div></div>    
</body>
</html>