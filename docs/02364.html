<html>
<head>
<title>Who said we cannot unit test SwiftUI views?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁说我们不能对SwiftUI视图进行单元测试？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hacking-swiftui-for-unit-testing-and-runtime-inspection-5f6329ff1697?source=collection_archive---------20-----------------------#2019-11-25">https://betterprogramming.pub/hacking-swiftui-for-unit-testing-and-runtime-inspection-5f6329ff1697?source=collection_archive---------20-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7be1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建单元测试框架背后的故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/957b2997ccd71a39cc1262b7fd872e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TkULV_bF7v-2KgVI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">美国宇航局在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的<a class="ae ky" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">照片</a></p></figure><p id="cbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维克多·切尔诺梅尔金，一位90年代的俄罗斯政治家，曾经说过:</p><blockquote class="lv lw lx"><p id="2ee3" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">这种事以前从未发生过，现在又发生了</p></blockquote><p id="8309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我想起了我们发现自己在SwiftUI中的处境:我们有一个全新的、令人兴奋的技术——但是有稳定性问题、不完整的API和稀缺的文档。这种事以前从未发生过，现在又发生了。</p><p id="d159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，事情并没有想象的那么糟糕，团队已经开始在生产项目中采用SwiftUI。尽管如此，反对在生产中使用它的一个主要理由是完全没有能力对UI进行单元测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/57a34a08dab8b2dff9f48e88fe467bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DB_mtkJXUfDMFiSj6XB2BA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2019/226/" rel="noopener ugc nofollow" target="_blank">swift ui-WWDC 2019数据流程</a></p></figure><p id="ab03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态函数应该很容易测试——只需一个<code class="fe md me mf mg b">if </code>。我们需要访问该函数的输出。</p><p id="62b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI中的视图相互嵌套，形成了一个静态类型的结构层次结构，没有API来检查视图的内容。</p><p id="4f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天苹果可能会发布SwiftUI的单元测试工具，但谁知道这是否/何时会发生。</p><p id="fdd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我决定造一个。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="66de" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">该工具</h1><p id="3df4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">由于无法访问SwiftUI的内部<a class="ae ky" href="https://worthdoingbadly.com/swiftui-html/" rel="noopener ugc nofollow" target="_blank">阴影属性图</a>，我尝试使用Swift的反射API。当我们在调试器中的断点处停止时，Xcode用它来打印变量的内容。SwiftUI视图中可用的信息之多让我感到惊讶。</p><p id="0765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来SwiftUI视图有一个非常分支的内部结构，所以我必须实现的第一件事是内部属性的递归遍历:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="34be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您为简单的视图层次结构调用此函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="976e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…你会得到一个相当长的输出。但是，可以用更易读、更简洁的方式对其进行重组:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="ddeb" class="nr mp it mg b gy ns nt l nu nv">"view" of type AnyView<br/>  ↳ "storage" of type AnyViewStorage&lt;Text&gt;<br/>      ↳ "view" of type Text<br/>          ↳ "modifiers" of type Array&lt;Modifier&gt;<br/>              ↳ value = []<br/>          ↳ "storage" of type Storage<br/>              ↳ "verbatim" of type String<br/>                  ↳ value = "Hello, world!"</span></pre><p id="b2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一种直觉，那就是事情不可能这么简单——肯定有一堵墙，我不能仅仅通过反射来穿过它，但我很好奇我能挖多远。</p><p id="d6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，在前进的道路上有许多陷阱在等待着我:</p><ol class=""><li id="f611" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">反射中的所有类型都被擦除到<code class="fe md me mf mg b">Any</code></li><li id="d7c9" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">计算属性，如<code class="fe md me mf mg b">var body: some View</code>，在反射中不可用</li><li id="719e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">有一些通用的私有结构和函数类型，很难将值转换为这些类型</li><li id="7fe9" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">很难初始化所有<code class="fe md me mf mg b">init</code>方法都是私有的结构</li><li id="cd0e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">SwiftUI依赖需要通过<code class="fe md me mf mg b">Environment</code>注入</li><li id="dc43" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">在对输入进行微小的调整后，层次结构会有显著的变化——例如，<code class="fe md me mf mg b">Text("Hi")</code>与<code class="fe md me mf mg b">Text(hiValue)</code></li><li id="aeb1" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">总的来说，有很多关于私人建筑的模糊和信息的缺乏</li></ol><p id="7800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论我遇到的有趣的用例以及我应对挑战的方法，但在此之前，让我向您展示我经过几天的反复试验后得到的结果:</p><div class="ok ol gp gr om on"><a href="https://github.com/nalexn/ViewInspector" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">nalexn/ViewInspector</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">ViewInspector是一个用于对基于SwiftUI的项目进行单元测试的库。它允许在…中遍历SwiftUI视图层次结构</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><p id="dab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个库，您可以从层次结构中提取您的自定义视图，并在单元测试中评估它的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从标准SwiftUI视图中读取实际值，例如<code class="fe md me mf mg b">Text</code>的<code class="fe md me mf mg b">String</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以代表用户以编程方式触发副作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，该框架支持iOS和macOS的SwiftUI中可用的大多数视图，以及使用<code class="fe md me mf mg b">UIViewRepresentable</code>从UIKit移植的视图:</p><blockquote class="lv lw lx"><p id="f4fb" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe md me mf mg b"><em class="it">AnyView</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Button</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">DatePicker</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Divider</em></code><code class="fe md me mf mg b"><em class="it">EquatableView</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">ForEach</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Form</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">GeometryReader</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Group</em></code><code class="fe md me mf mg b"><em class="it">GroupBox</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">HSplitView</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">HStack</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Image</em></code> <code class="fe md me mf mg b"><em class="it">SecureField</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Slider</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Stepper</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">TabView</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Text</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">TextField</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">Toggle</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">VSplitView</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">VStack</em></code><em class="it"/><code class="fe md me mf mg b"><em class="it">ZStack</em></code></p></blockquote><p id="2c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最终确实撞上了几堵牢不可破的墙，但总的来说，我对结果很满意。</p><p id="4072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，是时候讲一些黑客故事了。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="fc39" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">在不调用<code class="fe md me mf mg b">init()</code>的情况下创建结构</h1><p id="7ace" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有一个有趣的SwiftUI视图提供了关于视图容器大小的信息:<code class="fe md me mf mg b">GeometryReader</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反射显示该视图不直接存储包含的视图。相反，它为构建封闭视图提供了一个闭包。闭包有一个参数——<code class="fe md me mf mg b">GeometryProxy</code>值。</p><p id="cedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着在上面的例子中获得<code class="fe md me mf mg b">Text</code>视图的唯一方法是用<code class="fe md me mf mg b">GeometryProxy</code>调用这个闭包。</p><p id="c347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，幸运的是，<code class="fe md me mf mg b">GeometryProxy</code>是一个公共结构，但是它没有任何公共初始化器。</p><p id="330b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有工厂，怎么构建价值？</p><p id="c502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与对象相反，值类型不需要存储指向父类的指针来进行自我标识，这意味着即使内部没有<code class="fe md me mf mg b">isa</code>指针，它们也能保持功能...我有一个疯狂的想法，我决定尝试一下。</p><p id="f825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我想找出<code class="fe md me mf mg b">GeometryProxy</code>占用的字节数。Swift为此提供了<code class="fe md me mf mg b">MemoryLayout</code>:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="fad8" class="nr mp it mg b gy ns nt l nu nv">MemoryLayout&lt;GeometryProxy&gt;.size<br/>&gt;&gt; 48</span></pre><p id="f88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以分配内存:在堆栈上和在堆上。</p><p id="e9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后者更加灵活，因为您可以指定所需的字节数:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="f3af" class="nr mp it mg b gy ns nt l nu nv">let pointer = UnsafeMutableRawBufferPointer<br/>                  .allocate(byteCount: 48, alignment: 8)</span></pre><p id="6579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是动态内存需要用<code class="fe md me mf mg b">deallocate()</code>手动释放，并且比在堆栈上分配要慢，所以我决定用第一个选项，这更奇怪。</p><p id="df9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要声明一个取相同字节数的值类型:48。我给<code class="fe md me mf mg b">MemoryLayout</code>打了一个<code class="fe md me mf mg b">Double</code>的电话，不出所料，得到了以下消息:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="401f" class="nr mp it mg b gy ns nt l nu nv">MemoryLayout&lt;Double&gt;.size<br/>&gt;&gt; 8</span></pre><p id="319c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我声明了一个结构体，比如说，它保存了六个doubles。它的总内存大小应该是48:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="a618" class="nr mp it mg b gy ns nt l nu nv">struct Allocator {<br/>    let data: (Double, Double, Double, <br/>               Double, Double, Double) = (0, 0, 0, 0, 0, 0)<br/>}<br/>MemoryLayout&lt;Allocator&gt;.size<br/>&gt;&gt; 48</span></pre><p id="6aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！最后一步是转换类型:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="7655" class="nr mp it mg b gy ns nt l nu nv">let proxy = unsafeBitCast(Allocator(), to: GeometryProxy.self)</span></pre><p id="da08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还活着。活着！</p><p id="7f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，不能保证假的<code class="fe md me mf mg b">GeometryProxy</code>会正确工作，因为内部变量可能不期望为零，但是，幸运的是，这工作得很好:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="b0fd" class="nr mp it mg b gy ns nt l nu nv">proxy.size<br/>&gt;&gt; CGSize(0, 0)</span></pre><p id="e493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个想法，找到负责存储<code class="fe md me mf mg b">CGSize</code>的字节的位置，并用自定义值初始化它们。但是反射表明<code class="fe md me mf mg b">size</code>，就像<code class="fe md me mf mg b">GeometryProxy</code>上的所有其他公共变量都是计算出来的，所以没有办法实现这一点。</p><p id="f7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在我用这个Frankenstein结构调用了<code class="fe md me mf mg b">GeometryReader</code>上的工厂闭包之后，我得到了包含的视图，没有任何问题。当然，视图的布局是混乱的，但是至少可以安全地提取值，比如<code class="fe md me mf mg b">Text</code>上的字符串。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="365a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">强制转换为未知的泛型类型</h1><p id="cfc6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">另一个值得注意的案例是<code class="fe md me mf mg b">ForEach</code>。为了探索内部机制，我做了一个简单的设置，将一组字符串转换为<code class="fe md me mf mg b">Text</code>视图:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="e792" class="nr mp it mg b gy ns nt l nu nv">let array = ["0", "1", "2"]<br/>let view = ForEach(array, id: \.self) { Text($0) }</span></pre><p id="a039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的BFG10K函数<code class="fe md me mf mg b">attributesTree(value:)</code>显示如下:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="ad46" class="nr mp it mg b gy ns nt l nu nv">"view" of type ForEach&lt;Array&lt;String&gt;, String, Text&gt;<br/>  ↳ "data" of type Array&lt;String&gt;<br/>      ↳ value = ["0", "1", "2"]<br/>  ↳ "content" of type (String) -&gt; Text<br/>  ↳ "idGenerator" of type WritableKeyPath&lt;String, String&gt;<br/>      ↳ value = WritableKeyPath&lt;String, String&gt;<br/>  ↳ "contentID" of type Int<br/>      ↳ value = 0</span></pre><p id="91f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我可以使用内容构建器闭包<code class="fe md me mf mg b">content: (String) -&gt; Text</code>提取<code class="fe md me mf mg b">Text</code>视图，方法是向它提供一个<code class="fe md me mf mg b">data: [String]</code>数组的元素。</p><p id="4135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要做的就是将<code class="fe md me mf mg b">data</code>和<code class="fe md me mf mg b">content</code>从反射的默认类型<code class="fe md me mf mg b">Any</code>转换成正确的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，硬编码类型<code class="fe md me mf mg b">String</code>和<code class="fe md me mf mg b">Text</code>不会为任意的<code class="fe md me mf mg b">ForEach</code>工作，所以我需要从别处获取类型。</p><p id="b69a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe md me mf mg b">type(of: value)</code>动态获取类型的天真尝试并没有让编译器高兴——它需要在编译时知道类型。基本上这不是一个有效的代码:<code class="fe md me mf mg b">let casted = value as? type(of: value)</code>。</p><p id="aaed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，类型信息应该在编译时就知道了。我们能从哪里得到它？</p><p id="46e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到的第一个可行的解决方案是从调用者端提供类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不喜欢这种方法，因为它体积大，不方便使用，所以我求助于下面的方法。</p><p id="c635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经声明了一个删除类型的中间件协议，并扩展了<code class="fe md me mf mg b">ForEach</code>以符合该协议。诀窍在于，在<code class="fe md me mf mg b">ForEach</code>的扩展中，我们有内容提取所需的内部类型信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以最初的提取函数现在只需要将<code class="fe md me mf mg b">view: Any</code>转换成中间件协议并调用<code class="fe md me mf mg b">extractContent()</code>。因为<code class="fe md me mf mg b">ForEach</code>现在符合该协议，所以转换成功，并且提取按预期工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="130c" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">SwiftUI的原生环境注入</h1><p id="c2cf" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">SwiftUI通过<code class="fe md me mf mg b">@ObservedObject</code>、<code class="fe md me mf mg b">@EnvironmentObject</code>和<code class="fe md me mf mg b">@Environment</code>属性提供了一个非常方便的依赖注入机制。</p><p id="e400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在检查框架中支持<code class="fe md me mf mg b">@ObservedObject</code>没有任何实际问题，但我不得不花相当多的时间试图找出如何注入<code class="fe md me mf mg b">@EnvironmentObject</code>。</p><p id="684e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个视图通过<code class="fe md me mf mg b">.environmentObject(...)</code>接收到一个传统的DI注入时，它被包装到一个<code class="fe md me mf mg b">ModifiedContent</code>类型的视图中。这种类型的视图在SwiftUI中广泛使用，用于对视图进行各种调整，例如<code class="fe md me mf mg b">.padding()</code>、<code class="fe md me mf mg b">.blur(radius:)</code>等。</p><p id="4f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe md me mf mg b">ModifiedContent</code>是相当透明的——它的一个属性<code class="fe md me mf mg b">content</code>提供了封闭的视图，可以很容易地提取出来。</p><p id="1a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题出在另一个属性<code class="fe md me mf mg b">modifier</code>，它通常指的是一个<em class="ly">半私有</em>类型的值，比如<code class="fe md me mf mg b">_PaddingLayout</code>。我称它们为半私有，因为如果你将它们粘贴到源代码中，Xcode会识别这些类型，但是它们的符号被排除在公共头文件之外。如果您按住control键点按并选择“跳到定义”，Xcode将无法找到它们。</p><p id="bb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些类型，Xcode Autocomplete会显示一些实例变量——例如，<code class="fe md me mf mg b">_PaddingLayout</code>有<code class="fe md me mf mg b">var edges: Edge.Set</code>和<code class="fe md me mf mg b">var insets: EdgeInsets?</code>。</p><p id="35ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以回到注入<code class="fe md me mf mg b">@EnvironmentObject</code>的问题:视图被包装在<code class="fe md me mf mg b">ModifiedContent</code>中，其中<code class="fe md me mf mg b">modifier</code>具有类型<code class="fe md me mf mg b">_EnvironmentKeyWritingModifier&lt;InjectedObject?&gt;</code>。</p><p id="3f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个修饰符没有公共方法，下面是当我们注入一个类型为<code class="fe md me mf mg b">InjectedObject</code>的对象时，反射显示的内容:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="099e" class="nr mp it mg b gy ns nt l nu nv">"modifier" of type _EnvironmentKeyWritingModifier&lt;InjectedObject?&gt;<br/>   ↳ "keyPath" of type WritableKeyPath<br/>       ↳ value = WritableKeyPath&lt;EnvironmentValues, InjectedObject?&gt;<br/>   ↳ "value" of type InjectedObject?<br/>       ↳ value = InjectedObject(...)</span></pre><p id="1d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它确实保留了对<code class="fe md me mf mg b">InjectedObject</code>的引用，并且还有一个<code class="fe md me mf mg b">WritableKeyPath</code>用于<code class="fe md me mf mg b">EnvironmentValues</code>。</p><p id="6b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些<code class="fe md me mf mg b">EnvironmentValues</code>很神秘。到目前为止，我知道<code class="fe md me mf mg b">@EnvironmentObject</code>和<code class="fe md me mf mg b">@Environment</code>都在使用它来存储SwiftUI视图使用的值，但是我的实验表明<code class="fe md me mf mg b">EnvironmentValues</code>只在渲染时提供给视图层次结构——并且在渲染后被撤回。</p><p id="705c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到在渲染周期之外异步读取<code class="fe md me mf mg b">@EnvironmentObject</code>是被禁止的——您将得到相同的崩溃，就好像您从未在<code class="fe md me mf mg b">.environmentObject(...)</code>调用中提供过<code class="fe md me mf mg b">InjectedObject</code>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="6a59" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">检查框架背后的设计决策</h1><p id="e869" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我想让图书馆安全又方便使用。我只知道调用者端的语法应该是什么样子:它应该被链接到像<code class="fe md me mf mg b">view.anyView.hStack.button</code>这样的调用。</p><p id="74ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，每个中间元素都应该返回一个静态类型的值来限制可用选项:为<code class="fe md me mf mg b">AnyView</code>调用<code class="fe md me mf mg b">.tap()</code>或为<code class="fe md me mf mg b">Text</code>调用<code class="fe md me mf mg b">.hStack</code>是没有意义的。</p><p id="975b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一个选择是创建一个面向对象的类层次结构，但是在使用了几年面向函数和面向协议的编程之后，我对OOP产生了强烈的过敏<a class="ae ky" href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53" rel="noopener"/>。</p><p id="d081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我决定使用一个统一的结构<code class="fe md me mf mg b">InspectableView</code>，并将多态行为封装在它的泛型参数<code class="fe md me mf mg b">View</code>中:</p><pre class="kj kk kl km gt nn mg no np aw nq bi"><span id="1e19" class="nr mp it mg b gy ns nt l nu nv">struct InspectableView&lt;View&gt; {<br/>    let view: Any<br/>}</span></pre><p id="3035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我以为我会使用SwiftUI视图作为<code class="fe md me mf mg b">View</code>参数，但我很快意识到大多数SwiftUI视图也有通用参数。像<code class="fe md me mf mg b">InspectableView&lt;HStack&lt;VStach&lt;Text&gt;&gt;&gt;</code>这样的结构操作起来会过于笨重和脆弱。</p><p id="e436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我创建了一个空的<code class="fe md me mf mg b">struct ViewType { }</code>作为未来视图类型的基本名称空间，例如，<code class="fe md me mf mg b">ViewType.Button</code>代表<code class="fe md me mf mg b">Button</code>视图。</p><p id="dc31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为库的用户可能会错误地认为他们可以在那个参数中替换SwiftUI视图。为了帮助他们快速识别这是错误的路径，我对泛型类型进行了限制，以符合一个简单的协议<code class="fe md me mf mg b">KnownViewType</code>，SwiftUI视图默认不符合该协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在已经准备好开始用泛型构建多态行为了。</p><p id="944e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI中的视图可以包含单个视图(<code class="fe md me mf mg b">AnyView</code>)、一组视图(<code class="fe md me mf mg b">HStack</code>)，或者不包含其他视图(<code class="fe md me mf mg b">Text</code>)。</p><p id="f266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了封装这个行为，我定义了两个协议:<code class="fe md me mf mg b">SingleViewContent</code>和<code class="fe md me mf mg b">MultipleViewContent</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="08f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，任何<code class="fe md me mf mg b">ViewType</code>都能够根据其性质采用内容提取策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像<code class="fe md me mf mg b">Text</code>这样没有包含视图的视图，它的同伴<code class="fe md me mf mg b">ViewType.Text</code>简单地选择不遵守这些协议。</p><p id="7bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在每个<code class="fe md me mf mg b">ViewType</code>都可以宣布其提取内容的策略。</p><p id="77bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难题的最后一部分是添加方法，比如从父节点中提取<em class="ly">的<code class="fe md me mf mg b">.hStack</code>。</em></p><p id="ba8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个很简单——我只是用一个以要提取的视图类型命名的方法扩展了<code class="fe md me mf mg b">InspectableView where View: SingleViewContent</code>,允许这样的视图用<code class="fe md me mf mg b">.hStack</code>继续这个链，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<code class="fe md me mf mg b">MultipleViewContent</code>也定义了类似的扩展。</p><p id="56c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，对于像<code class="fe md me mf mg b">ViewType.Button</code>这样的类型，我可以添加对像<code class="fe md me mf mg b">.tap()</code>这样的方法的独占支持。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="983a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方法，<code class="fe md me mf mg b">InspectableView</code>获得了一组可用于特定<code class="fe md me mf mg b">ViewType</code>的受控方法，消除了使用视图提取库时可能出现的逻辑错误。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="2bb1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="57c2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这就是创建ViewInspector框架背后的故事。如果你有一个SwiftUI项目，你想用unit yests来覆盖它——考虑尝试一下。</p><div class="ok ol gp gr om on"><a href="https://github.com/nalexn/ViewInspector" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">nalexn/ViewInspector</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">ViewInspector是一个用于对基于SwiftUI的项目进行单元测试的库。它允许在…中遍历SwiftUI视图层次结构</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><p id="8be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更好地理解内部使用的SwiftUI机制，使用那个函数<code class="fe md me mf mg b">attributesTree(value:)</code>，破解那些黑盒视图。</p></div></div>    
</body>
</html>