<html>
<head>
<title>Metaprogramming With Ruby: Send and Public Send Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby: Send和Public Send方法进行元编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/metaprogramming-with-ruby-send-and-public-send-methods-f85aa8f91366?source=collection_archive---------4-----------------------#2021-02-05">https://betterprogramming.pub/metaprogramming-with-ruby-send-and-public-send-methods-f85aa8f91366?source=collection_archive---------4-----------------------#2021-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始写动态代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49d57546dbeb429cde154ab7943bc9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKy97QsVWkP9GMLsSMwYgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/woman-sitting-on-the-floor-using-a-laptop-4050299/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@vlada-karpovich?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Vlada Karpovich </a>的照片。</p></figure><p id="6aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写动态代码有时会很困难。幸运的是，Ruby支持元编程，它允许你编写代码来为你动态地编写更多的代码。</p><p id="c474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建类或方法并动态调用它们时，元编程是一种强大的技术，这也使您的代码变得枯燥。使用元编程的缺点是，它比编写普通代码要昂贵得多，并且在我看来，只有在没有其他方法来解决问题或完成您想要的事情时，您才应该使用元编程。</p><p id="2ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论如何在Ruby中使用<code class="fe lw lx ly lz b">send</code>和<code class="fe lw lx ly lz b">public_send</code>方法。</p><p id="34ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来了解一下这两种方法是做什么的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="22e7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">发送</h1><p id="f581" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">此方法将字符串或符号作为参数，并将该消息发送给对象。<code class="fe lw lx ly lz b">send</code>方法的第二个参数代表该方法接收的任何参数。</p><p id="1a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="d79d" class="ni mi it lz b gy nj nk l nl nm">full_name = "Mia Smith Jr."<br/>full_name.send("count", "i") # 2<br/>full_name.send(:upcase) # "MIA SMITH JR."</span></pre><p id="2974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们声明了一个变量并指定了字符串<code class="fe lw lx ly lz b">“Mia Smith Jr.”</code>。然后我们使用<code class="fe lw lx ly lz b">send</code>方法来执行字符串中的<code class="fe lw lx ly lz b">count</code>和<code class="fe lw lx ly lz b">upcase</code>方法。由于<code class="fe lw lx ly lz b">count</code>方法将我们想要计数的字符作为参数，我们可以将它作为第二个参数传递给<code class="fe lw lx ly lz b">send</code>方法。</p><p id="a4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道这是如何发生的，答案很简单。<code class="fe lw lx ly lz b">send</code>方法接受我们传递的第一个参数，并在对象上执行该方法。如果对象响应该方法，那么输出将是成功的。否则，会产生错误。</p><p id="a781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lw lx ly lz b">respond_to?</code>方法检查一个对象是否响应了一条消息。这是预先检查一个对象是否能处理特定消息的好方法。</p><p id="75f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以确认一个字符串是否像这样响应<code class="fe lw lx ly lz b">split</code>方法:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="55eb" class="ni mi it lz b gy nj nk l nl nm">full_name.respond_to?(:split) # true</span></pre><p id="66c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，我们可以向<code class="fe lw lx ly lz b">send</code>和<code class="fe lw lx ly lz b">public_send</code>方法传递一个字符串或一个符号。但是只要有可能，最好使用符号，因为它们是字符串的优化版本。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9f38" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">公共发送</h1><p id="ea3b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这个方法做的事情和<code class="fe lw lx ly lz b">send</code>方法完全一样。然而，微小的区别是它只调用公共方法——不调用任何私有或受保护的方法。</p><p id="e2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个如何使用<code class="fe lw lx ly lz b">public_send</code>方法的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们有两个类:一个<code class="fe lw lx ly lz b">device</code>类和一个<code class="fe lw lx ly lz b">device reporter</code>类。我们初始化一个新的<code class="fe lw lx ly lz b">device</code>，并将该实例传递给<code class="fe lw lx ly lz b">device reporter</code>。然后，reporter类使用<code class="fe lw lx ly lz b">public send</code>方法向<code class="fe lw lx ly lz b">device</code>对象发送消息，在本例中是<code class="fe lw lx ly lz b">tech_details</code>方法。因为<code class="fe lw lx ly lz b">device</code>实例确实响应了这个消息，所以它不会抛出错误。它将只返回方法中定义的散列。</p><p id="01f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以正如你所看到的，我们在<code class="fe lw lx ly lz b">device</code>实例上调用了一个公共方法。如果我们使用<code class="fe lw lx ly lz b">public_send</code>方法调用一个受保护的或者私有的方法(例如<code class="fe lw lx ly lz b">total_price</code>方法)，它将会给我们一个错误。原因是创建<code class="fe lw lx ly lz b">public send</code>方法是为了确保我们没有违反另一个对象的内部细节(也就是说，我们没有调用任何我们不应该调用的方法)。</p><p id="6316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的实践，因为我们希望我们的对象保持它们的细节是私有的，并封装所有不应该向其他对象公开的内容。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f41f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">为什么你应该使用这些方法</h1><p id="194e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这就是<code class="fe lw lx ly lz b">send</code>和<code class="fe lw lx ly lz b">public_send</code>方法的主要区别。但是用这两种方法有什么好处呢？答案很简单:它允许我们动态地向对象发送消息。</p><p id="a65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用<code class="fe lw lx ly lz b">send</code>方法来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有一个<code class="fe lw lx ly lz b">book service</code>类，它在构造函数中接收一些参数，并有一个公共方法。在这种情况下，我们使用的是<code class="fe lw lx ly lz b">send</code>方法，而不是<code class="fe lw lx ly lz b">public_send</code>方法，因为我们想要向<code class="fe lw lx ly lz b">self</code>发送消息。这意味着我们想要执行一个属于同一个类的方法，所以我们不必使用<code class="fe lw lx ly lz b">public_send</code>方法，因为我们可以调用<code class="fe lw lx ly lz b">self</code>的任何私有或受保护的方法。</p><p id="3a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在call方法中，我们根据在构造函数中收到的过滤器动态地向<code class="fe lw lx ly lz b">self</code>发送消息。这样，我们可以避免使用<code class="fe lw lx ly lz b">if</code>语句，代码看起来非常干净。</p><p id="01ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看另一个使用<code class="fe lw lx ly lz b">public_send</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们有一个<code class="fe lw lx ly lz b">notifier service</code>类，它接收构造函数中的<code class="fe lw lx ly lz b">notifier_type</code>、<code class="fe lw lx ly lz b">message</code>和<code class="fe lw lx ly lz b">user</code>作为参数。然后它有一个<code class="fe lw lx ly lz b">notify</code>公共方法，首先调用<code class="fe lw lx ly lz b">user_fields</code>私有方法并将结果赋给<code class="fe lw lx ly lz b">fields</code>全局变量。</p><p id="e115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">user_fields</code>方法中，我们迭代一个包含一组用户属性的常量。对于每个属性，我们使用<code class="fe lw lx ly lz b">public_send</code>方法将消息动态发送给用户对象，并将该属性分配给散列。这将产生用户属性的散列。</p><p id="94b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，<code class="fe lw lx ly lz b">notify</code>方法中的下一行再次使用<code class="fe lw lx ly lz b">send</code>来根据我们收到的<code class="fe lw lx ly lz b">notifier_type</code>参数执行正确的方法。</p><p id="aeee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之前，一切看起来都很好。现在来看看<code class="fe lw lx ly lz b">User</code>班。</p><p id="6328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户类在构造函数中取<code class="fe lw lx ly lz b">name</code>、<code class="fe lw lx ly lz b">last_name</code>和<code class="fe lw lx ly lz b">age</code>。它有一个公共方法和一个私有方法。这个类的重要部分是它只有针对<code class="fe lw lx ly lz b">name</code>和<code class="fe lw lx ly lz b">last_name</code>的访问器，而不是针对<code class="fe lw lx ly lz b">age</code>。<code class="fe lw lx ly lz b">Age</code>是一个私有的reader属性，这意味着它应该只对该类是可访问的，而不对其他对象公开。</p><p id="f8f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们照原样运行这段代码，它将产生一个错误，因为在<code class="fe lw lx ly lz b">notifier service</code>中定义的常量包含了来自<code class="fe lw lx ly lz b">user</code>对象的私有属性。所以，当迭代这个数组并试图使用<code class="fe lw lx ly lz b">public_send</code>方法时，它会抛出一个错误，说这是一个私有方法，因此我们不能调用它。</p><p id="4069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我发现<code class="fe lw lx ly lz b">public_send</code>方法真正有用的地方。如果你因为某种原因忘记了<code class="fe lw lx ly lz b">user</code>对象有某些属性或者方法被定义为private，这个方法会告诉你，你在试图侵犯另一个对象的内部细节。</p><p id="710c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要修复这个错误，我们可以使用我前面提到的<strong class="lb iu"> </strong> <code class="fe lw lx ly lz b">respond_to?</code>方法:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="6503" class="ni mi it lz b gy nj nk l nl nm">def user_fields<br/>  USER_FIELDS.each_with_object({}) do |field, memo|<br/>    memo["#{field}"] = user.public_send(field) if user.respond_to?(field)<br/>  end<br/>end</span></pre><p id="8a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这一改变，即使我们向<code class="fe lw lx ly lz b">user fields</code>常量添加私有方法和属性，它也不会抛出错误，因为我们在尝试对其使用<code class="fe lw lx ly lz b">public_send</code>方法之前，会检查用户是否响应了该消息。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8c9a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">关键要点</h1><ul class=""><li id="87a7" class="np nq it lb b lc mz lf na li nr lm ns lq nt lu nu nv nw nx bi translated">当您想要在同一个类(<code class="fe lw lx ly lz b">self</code>)中动态调用方法和属性时，请使用<code class="fe lw lx ly lz b">send</code>方法。</li><li id="45af" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当您想要动态调用其他对象的方法和属性时，请使用<code class="fe lw lx ly lz b">public_send</code>方法。这确保您没有调用任何私有方法或属性。</li><li id="c58b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当你想知道一个对象在实际发送它之前是否响应一个特定的消息时，使用<strong class="lb iu"> </strong> <code class="fe lw lx ly lz b">respond_to?</code>方法。</li></ul><p id="2f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你已经发现这是有用的。</p><p id="c1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会觉得这很有趣:</p><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/understanding-the-object-id-method-in-ruby-f61bb3888113" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">理解Ruby中的Object_id方法</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Ruby和许多编程语言一样，可以创建对象来存储属性、方法和执行…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/codestory/what-is-the-power-of-inversion-of-control-fd4953630444" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">控制反转的力量是什么？</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Ruby编程语言示例</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/postgresql-views-with-ruby-on-rails-78260cd6f021" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用Ruby on Rails的PostgreSQL视图</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">利用视图的力量封装复杂的查询。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>