<html>
<head>
<title>Django Quick Tips: Context Processors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django快速提示:上下文处理器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-quick-tips-context-processors-da74f887f1fc?source=collection_archive---------7-----------------------#2020-06-23">https://betterprogramming.pub/django-quick-tips-context-processors-da74f887f1fc?source=collection_archive---------7-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ddf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中更好的模板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8eb0e82f66eb37396e05528886e296bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U-pd5W26fM1pdQoA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@vishnurnair?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毗湿奴R奈尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="79e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们讨论一下上下文处理器，看看如何在您的Django项目中有效地使用它们。</p><blockquote class="lv lw lx"><p id="2b99" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">上下文处理器有一个简单的接口:它是一个Python函数，接受一个参数，一个HttpRequest对象，并返回一个添加到模板上下文中的字典。每个上下文处理器必须返回一个字典。</p><p id="f082" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">自定义上下文处理器可以位于代码库中的任何位置，只要它们被引擎的context_processors参数指向。“— <a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/templates/api/" rel="noopener ugc nofollow" target="_blank">姜戈的文件</a></p></blockquote><p id="f2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用多个独立的<code class="fe mc md me mf b">views</code>时，您可能会将不同的数据对象加载到不同的视图中，但是有时用例要求您在整个应用程序中使用相同的数据——我指的是在应用程序的所有模板中。在那种情况下你会怎么做？初学者可能会重复将数据加载到每个视图的模板上下文中的过程，这不是很聪明，对吗？</p><p id="b98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是自定义上下文处理器非常有用的地方。</p><p id="275e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们马上就会看到如何将它们付诸实践，但让我们定义一个用例，让您轻松掌握我们将要实现的内容。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="41c0" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">用例</h1><p id="6b17" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您正在开发一个课程管理系统或LMS，您需要为可用的课程主题实现一个搜索栏，并且该搜索栏应该在整个应用程序中都可用。为了这个快速教程，我们将简单地使数据在HTML <code class="fe mc md me mf b">&lt;option&gt;</code>或<code class="fe mc md me mf b">&lt;ul&gt;</code>标签中可用，以列出所有可用的主题。</p><p id="41f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个中级Django开发人员，你可能知道Django模板语言<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/templates/language/" rel="noopener ugc nofollow" target="_blank">，但是如果你不知道也不用担心。请记住，Django让您能够创建一个基础模板，然后通过简单地扩展基础模板来添加其他模板。这是您通常加载所有静态文件的地方。我包含了链接，所以你可以查找它。</a></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ee1b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">履行</h1><p id="a1aa" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">要创建自定义上下文处理器，请在应用程序文件夹中添加一个新文件。我们称之为<code class="fe mc md me mf b">custom_context_processor.py</code>:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="f9cf" class="no mo it mf b gy np nq l nr ns">$ touch your_app/custom_context_processor.py</span></pre><p id="83a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们导入我们的模型并定义我们的函数:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="c57f" class="no mo it mf b gy np nq l nr ns">from .models import Subject</span><span id="d9fc" class="no mo it mf b gy nt nq l nr ns">def subject_renderer(request):<br/>    return {<br/>       ‘all_subjects’: Subject.objects.all(),<br/>    }</span></pre><p id="b1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这再简单不过了。你可能会问，“到底是怎么回事？”是的，就这么简单。</p><p id="28ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下这个定义，这样你就会明白它有多简单。</p><p id="1631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上下文处理器是一个接口:</p><ul class=""><li id="f5c0" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><code class="fe mc md me mf b">subject_renderer(request)</code>:一个Python函数，它接受一个参数，这个参数是一个请求对象。</li><li id="fa43" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe mc md me mf b">all_subject</code> : <strong class="lb iu"> </strong>一个<strong class="lb iu"> </strong>的可用科目列表作为字典返回。</li></ul><p id="94cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的上下文处理器实现，这对于我们的用例来说已经足够了。</p><p id="86ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了使它在我们的模板中可访问，我们需要将它添加到我们模板的上下文中，所以打开<code class="fe mc md me mf b">settings.py</code> <strong class="lb iu"> </strong>并像这样添加它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ff7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在所有模板中提供了该功能。现在是渲染<code class="fe mc md me mf b">_base.html</code>并显示主题列表的时候了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以浏览所有的应用程序模板，并且所有的主题仍然可见或可访问。</p><p id="061c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这足够简单。如果事实并非如此，请随意回复。我很乐意再给你演示一遍。</p><p id="31ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯。</p></div></div>    
</body>
</html>