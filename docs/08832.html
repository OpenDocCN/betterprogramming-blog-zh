<html>
<head>
<title>Data Caching With NSCache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NSCache进行数据缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/analysing-data-caching-with-nscache-e0fcbed17b2b?source=collection_archive---------9-----------------------#2021-06-16">https://betterprogramming.pub/analysing-data-caching-with-nscache-e0fcbed17b2b?source=collection_archive---------9-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优化SwiftUI应用中数据使用的真实案例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f3169aff5d8d3f008db599287df475f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVw56-JToWySViotHWqtMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="4d42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最近开源了我的用于macOS的<a class="ae lu" href="https://github.com/mattrighetti/HNReaderApp" rel="noopener ugc nofollow" target="_blank"> HackerNews阅读器</a>，它完全是用用于macOS的SwiftUI编写的。分析我的场景有助于解释数据缓存和避免数据浪费。</p><p id="5f22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想更详细地了解代码，您可以在项目的GitHub资源库中继续学习。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方案</h1><p id="df91" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">黑客新闻(Hacker News)是一家知名网站，在平台上存储用户举报的新闻。正如HN API的文档所规定的，每个单独的故事都将由一个<code class="fe mz na nb nc b">Item</code>结构来表示。我们希望获取可用的条目，以便用户以数据效率最高的方式进行阅读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c3f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不使用缓存的初始实施</h1><p id="c35e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">该应用程序有一个<code class="fe mz na nb nc b">ItemCell</code> <strong class="la iu"> </strong>视图<strong class="la iu"> </strong>，它从父视图中获取一个<strong class="la iu"> </strong> <code class="fe mz na nb nc b">ItemId</code>，一旦它出现在屏幕上，它将自动获取该项目并为我显示。这种方法使得数据使用量非常低，并且消除了后端的很多压力，因为实际上只会获取显示的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6444948f95dcc70cd1df394ece94cebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0KWAWmDnu2p_MdFVzfDuA.png"/></div></div></figure><p id="4f74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用程序的侧边栏允许用户在五个不同类别的故事之间导航。您可以想象，一些新闻可能属于多个类别，因此当用户在类别之间来回切换时，他们基本上是在请求以前获取的相同项目。</p><p id="81bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种没有一些后台逻辑的方法会大大增加您的数据使用量，降低应用程序的整体性能，还会给HackerNews后端带来很大压力，不必要地多次向我们提供相同的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缓存数据</h1><p id="b75a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们实际上可以做的是通过id缓存下载的项目来解决这个问题。通过这种方式，项目将只被提取一次，应用程序不会因为无用的重复请求而浪费数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b949594c772c5e2e3b1ed7b461d8c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGewxEQNZvEdXv1q986s6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API不会缓存以前下载的项目。</p></figure><h2 id="9934" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">履行</h2><p id="4ce2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们知道每一项都由一个<code class="fe mz na nb nc b">ItemId</code>唯一标识，T3是一个整数变量。因此，我们可以使用该数据从缓存中存储和检索项目。</p><p id="98a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写时，<code class="fe mz na nb nc b"><a class="ae lu" href="https://developer.apple.com/documentation/foundation/nscache" rel="noopener ugc nofollow" target="_blank">NSCache</a></code>实现只接受类类型，所以如果我们想将它存储在缓存对象中，我们需要为<code class="fe mz na nb nc b">Item</code>结构创建一个简单的类包装器。在这个场景中，我们不需要包装我们的键(<code class="fe mz na nb nc b">ItemId</code>)，因为有一个更短的方法:将它转换为<code class="fe mz na nb nc b">String</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/191b32ff2ff158df5d20d38e3f935f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGUVxtoz6EyT93FAkYHZNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在NSCache中保存结构的StructWrapper实现(<a class="ae lu" href="https://github.com/mattrighetti/HNReaderApp/blob/95ea9fa0dfd8598d79f864e9b347dfdb5a363f92/HNReader/HNClient/ItemCache.swift#L7-L13" rel="noopener ugc nofollow" target="_blank">代码</a>)</p></figure><p id="2dbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在存储和检索对象非常简单。我们需要一个具有两个功能的缓存对象:一个用于缓存对象，另一个用于在找到对象时取回对象。我还实现了通用的单例设计模式，以确保我总是使用相同的缓存对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/22f7c6ae264706fedb31d351dbcbd078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDna-u5dByF9H0L1LVOMhQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ItemCache实现(<a class="ae lu" href="https://github.com/mattrighetti/HNReaderApp/blob/95ea9fa0dfd8598d79f864e9b347dfdb5a363f92/HNReader/HNClient/ItemCache.swift#L16-L30" rel="noopener ugc nofollow" target="_blank">代码</a>)</p></figure><p id="a51d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们已经拥有了缓存元素和在获取元素之前检查内存中是否存在元素所需的一切。提取功能将在实际提取数据之前检查缓存命中/未命中。只有当我们对所请求的对象进行缓存未命中时，才会进行提取，并且当正确提取项目时，我们只需将它保存在缓存中。下次我们试图获取该项时，它将立即从缓存中取出，而无需任何额外的获取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/90d7de44ccb1970286085da8a3e87921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWVzlOyFbhQYbru8Pk1mOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://github.com/mattrighetti/HNReaderApp/blob/95ea9fa0dfd8598d79f864e9b347dfdb5a363f92/HNReader/View/ItemCell.swift#L129-L142" rel="noopener ugc nofollow" target="_blank">代码</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="df28" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">优化是你必须一直寻找的东西——对你的用户和你可能在应用中使用的其他第三方服务都是如此。</p><p id="7e82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过一个非常简单的对象，我们实际上已经做了一些相当大的改进。现在，获取的项将被缓存，并准备好在下次需要时以成本<em class="ns"> O(1) </em>进行检索。</p></div></div>    
</body>
</html>