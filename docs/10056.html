<html>
<head>
<title>React Context + TypeScript — The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Context + TypeScript —最简单的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-react-context-with-typescript-the-easy-way-2ed1010f6e84?source=collection_archive---------3-----------------------#2021-11-19">https://betterprogramming.pub/how-to-use-react-context-with-typescript-the-easy-way-2ed1010f6e84?source=collection_archive---------3-----------------------#2021-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ca0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…为什么React开发人员教你不正确</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c250dee58f8d82b21f618e890cf2458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NgWHz06U01PQBoshwSOTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ff10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前几天，我在将一个JavaScript组件转换为TypeScript时，在一个特定的领域被绊倒了:React Context。</p><p id="2c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要误解我的意思，我以前已经使用过无数次TypeScript，但是由于某种原因，我不喜欢上下文。于是我回到画板，查了一些教程，再次熟悉了一下语境。</p><p id="bcbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，在这个过程中，我发现了一些清晰的思维模式和捷径，可以让理解毫不费力地对背景做出反应。</p><p id="482e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我今天在这里分享的内容。</p><h1 id="038e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">React上下文的3个部分—可视化</h1><p id="f895" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我喜欢认为上下文需要三个部分。官方文档称之为创建上下文、生产者和消费者。但是，我认为用一个普通变量的比喻来思考这些更容易。</p><h2 id="8b12" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">上下文创建者</h2><p id="54ae" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">把这看作是你的上下文的<code class="fe ne nf ng nh b">let myContext;</code>。它只是创建上下文，但还没有填充任何功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="27b1" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">上下文提供者</h2><p id="9730" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">将此视为您的上下文的<code class="fe ne nf ng nh b">myContext = [];</code>。它用一些合理的默认数据填充已经创建的上下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="5d8f" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">上下文消费者</h2><p id="15e4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">把这个想象成<code class="fe ne nf ng nh b">myContext = [1,2,3];</code>或者<code class="fe ne nf ng nh b">let myData = myContext[0]</code>。这是您操作上下文或读取其数据的地方(因此命名为“消费者”)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="733f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">但是…这些打字有个问题。</h1><p id="08c6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">因为我们在创建上下文时使用了<code class="fe ne nf ng nh b">undefined</code>,所以当我们消费它时没有得到好的类型。</p><p id="3071" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我们想使用上下文时，我们必须先检查它是否未定义。这意味着如果我们想使用<code class="fe ne nf ng nh b">addTodo</code>功能，例如，我们必须做<code class="fe ne nf ng nh b">myContext ? myContext.addTodo() : null</code>。</p><p id="f200" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这种检查有点奇怪，因为如果我们正确地使用上下文，它应该永远不会是未定义的。如果使用上下文的组件在提供者之下，那么上下文将总是具有从提供者传入的默认值。</p><p id="79ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要给它一个默认类型<code class="fe ne nf ng nh b">undefined</code>的唯一原因是如果消费者不是提供者的子组件。</p><p id="46fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我经常看到的一种解决方案是给出更具体的字段级默认值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9fe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们没有将整个上下文默认设置为<code class="fe ne nf ng nh b">undefined</code>，而是为每个字段插入了合理的默认值。在某种意义上，这更好，因为我们不再需要在消费时检查它是否是未定义的。</p><p id="b2ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c677" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以变成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e3ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用我们的变量比喻再次解释这一点:在我们做<code class="fe ne nf ng nh b">let myContext</code>之前，然后是<code class="fe ne nf ng nh b">myContext = []</code>。这很糟糕，因为您将上下文的类型从<code class="fe ne nf ng nh b">undefined</code>更改为数组。一般来说，你不希望在数据被创建后改变它的数据类型。</p><p id="f5ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这种更好的输入方式，现在我们马上开始做<code class="fe ne nf ng nh b">let myContext = []</code>。我相信你能明白为什么这样更好。</p><h1 id="e85a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">但是这带来了另一个问题…</h1><p id="b82d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果我们做了这样的改变，消费上下文就更容易了，但是如果你有一个组件试图消费非子上下文呢？</p><p id="562b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个组件现在将调用<code class="fe ne nf ng nh b">myContext.addTodo()</code>函数，但是它没有做它所期望的，而是静静地失败了。那是因为函数只是长这样:<code class="fe ne nf ng nh b">() =&gt; {}</code>。</p><p id="87ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您可能会想:“好吧，您可以更改该功能，将一些内容记录到控制台中”。你可以。但是，如果它不是一个函数，而是一个字段呢？在这种情况下，您将如何登录控制台？</p><p id="df78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，这并不能解决根本问题。</p><p id="9ab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">潜在的问题是React允许组件使用上下文，即使它们不是子组件(尽管它不做任何事情)。此外，由于React在这种情况下不会显式抛出错误，这使得键入内容和管理它们的依赖关系变得更加困难。</p><p id="b0ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人认为React的设计很糟糕。</p><p id="a4c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一个组件试图使用一个上下文，但不是该上下文的子组件，那么<em class="lu">应该</em>抛出一个显式错误并崩溃。这是因为只有在用户出错时才会出现这种情况。要么是开发人员把组件移到了不应该的地方，要么是他们把上下文移到了不应该的地方。</p><p id="608b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">按照React目前的处理方式，除非您对组件进行了功能测试，否则您不会知道事情无法正常工作。如果它抛出了一个显式错误，您将立即知道页面何时呈现。</p><p id="e3c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也带来了最后一个问题:</p><blockquote class="nk nl nm"><p id="f0d9" class="ky kz lu la b lb lc ju ld le lf jx lg nn li lj lk no lm ln lo np lq lr ls lt im bi translated">无论如何，为什么我必须为我的上下文显式定义类型？难道不应该根据传递给提供者的内容自动生成类型吗？</p></blockquote><p id="eddc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嘣！如果你是这样想的，你是对的。但遗憾的是，因为上下文在任何组件(不仅仅是子组件)中都是可访问的，所以你必须提供默认值以防它不是子组件。这是因为两种情况中的一种会发生。要么:</p><p id="9de8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(a)上下文消费者是提供者的子代→它将使用传递给提供者的数据。</p><p id="331c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(b)上下文消费者不是提供者的子代→它将使用传递给<code class="fe ne nf ng nh b">createContext</code>函数的默认数据。</p><h1 id="c85e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">那么，我们如何解决这两个问题呢？</h1><p id="8eb3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">好事是我们可以在这里一举两得。解决方案很简单:</p><blockquote class="nq"><p id="2b29" class="nr ns it bd nt nu nv nw nx ny nz lt dk translated">如果一个组件试图使用一个上下文并且不是提供者的子组件，抛出一个显式错误。</p></blockquote><p id="45ca" class="pw-post-body-paragraph ky kz it la b lb oa ju ld le ob jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">如果这样做，那么上下文可以根据传递给提供者的属性自动类型化。这是因为没有组件会使用提供者范围之外的上下文，所以我们不需要为那个用例添加类型。</p><p id="587f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们现在可以明确保证组件没有被意外地移动到它需要的上下文之外。</p><p id="eb8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，这就对了。一石二鸟！</p><p id="3d19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现这一点也不难。您可以在当前上下文API的基础上实现这个附加功能，或者使用一个库。我个人使用一个名为<a class="ae of" href="https://github.com/jamiebuilds/unstated-next" rel="noopener ugc nofollow" target="_blank"> unstated-next </a>的库来为我实现这些更改。这个库有40行长，为上下文添加了正确的输入和显式错误。</p><p id="7be0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解这个库的更多信息，我实际上写了一篇关于使用unstated-next进行状态管理的文章<a class="ae of" rel="noopener ugc nofollow" target="_blank" href="/the-container-pattern-for-better-state-management-in-react-9351fe4381d1">。否则，可以随意使用本文中讨论的任何方法来键入组件。它们都是有效的解决方案，只是有你想要知道的权衡和风险。</a></p></div></div>    
</body>
</html>