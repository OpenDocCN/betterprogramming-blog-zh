<html>
<head>
<title>Avoid These 5 Mistakes When Handling Exceptions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中处理异常时避免这5个错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avoid-these-5-mistakes-when-handling-exceptions-in-python-645f0ce92c92?source=collection_archive---------6-----------------------#2020-07-23">https://betterprogramming.pub/avoid-these-5-mistakes-when-handling-exceptions-in-python-645f0ce92c92?source=collection_archive---------6-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ab9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用最佳实践来处理代码中的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a7de878b2f6854336cf03b54229b2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K51qF1w6LIMHxpCI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="077b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谁也不能保证他们的代码没有bug。随着我们项目范围的扩大，我们越来越有可能错过一些在项目交付时可能发生的意想不到的方面。这都是因为我们不能总是考虑最终客户会对我们的项目做什么。因此，当我们编写代码时，我们应该尝试解决可能的异常用例，处理这些意外情况的一种方法是在开发阶段处理可能的异常。下面的代码向您展示了可能是最简单的错误处理示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异常处理示例</p></figure><p id="7b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，该函数计算两个数字之间的比率。然而，人们可能会通过将分母设置为零来调用这个函数，这将导致<code class="fe lx ly lz ma b">ZeroDivisionError</code>被提高。通过处理这个异常，我们通知代码的用户他们不能除以零。这样，他们可以调整如何使用这一特殊功能。</p><p id="78d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为Python中错误处理的经典例子，您可能已经多次看到上面的代码或其排列。您可能已经对如何处理异常有了一些想法。然而，当您在代码中处理异常时，会犯一些错误。在本文中，我们将探讨一些你应该避免的错误。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="29e4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.缺乏特异性</h1><p id="81f9" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">显然，当我们处理特定的异常时，我们应该对将要遇到的异常有所预期。通过识别这些异常，我们知道如何正确处理它们。然而，我看到一些代码具有非常普通的异常处理，这完全违背了错误处理的目的——一件不愉快的事情刚刚发生，阻止了我们的代码正常运行，我们正在试图恢复它。</p><p id="27ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，一些程序员犯的第一个错误是他们没有指定他们正在处理什么异常。此外，它们没有给出任何关于错误的有意义的信息。让我们通过修改我最初分享的代码来看一个这样的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用异常处理</p></figure><p id="6ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码向您展示了错误消息是多么的无意义。正如您可能看到的，函数的两次调用有两个不同的问题。第一次调用使用字符串作为分母，而第二次调用使用零作为分母。应该区别对待！此外，我们应该对每个异常给出具体的错误消息。让我们看看下面的代码，看看可能的修复方法。</p><p id="e51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，理论上，我们可以在运行操作之前检查参数的类型。这个解决方案只是为了向您展示如何具体处理异常。另一个实现见下一节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特定异常处理</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="08bf" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.没有尝试解决这个问题</h1><p id="20d7" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在上面的代码中，我们向您展示了我们可以为我们获得的参数获得一个字符串值，并且我们编写了一些代码来处理可能的异常(即<code class="fe lx ly lz ma b">TypeError</code>)。在大多数情况下，我们会引发异常，因为我们不希望这些情况经常发生，但是如果我们代码的许多用户以字符串格式发送数字呢？当然，我们仍然可以继续引发<code class="fe lx ly lz ma b">TypeError</code>异常，但是用户体验可能不会很好。换句话说，如果我们能够提出一些特殊的异常，我们至少可以尝试解决这个问题。请看下面的代码修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误校正</p></figure><p id="a3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们只是使用了不同的实现策略。具体来说，在执行除法之前，我们可以将传递的参数转换为浮点数。通过这样做，如果用户意外地传递了字符串格式的数字(即上面示例中的4)，我们仍然可以处理该操作，这可能会改善用户体验。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d231" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.“try”子句中的代码太多</h1><p id="1eae" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">另一个常见的错误是有些人在<code class="fe lx ly lz ma b">try</code>条款中放了大量代码。<em class="nf">试</em>是什么意思？意思是某件事可能行得通，也可能行不通，我们在运行它之前是不知道的。这很像进行一项实验，可能会失败。我们可能不应该也不需要去尝试一些肯定会发生的事情。让我们看看本文中使用的例子的一个变体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">try子句有问题</p></figure><p id="0fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe lx ly lz ma b">try</code>子句包含了对<code class="fe lx ly lz ma b">print</code>函数的四次调用，这可能会非常混乱，因为我们不知道哪些行会导致问题。您认为在前三次调用中，在什么情况下调用<code class="fe lx ly lz ma b">print</code>函数可能会失败？可能没什么可想的。唯一导致问题的代码是第四次调用，这可能会导致<code class="fe lx ly lz ma b">ZeroDivisionError</code>异常。因此，我们应该从<code class="fe lx ly lz ma b">try</code>条款中去掉预期没有问题的那一行。通过这样做，我们非常清楚地表明了我们的意图，即只有调用分部才能引发异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">干净的尝试子句</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a42d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.没有利用‘else’子句</h1><p id="064c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在前面的章节中，我们探索了<code class="fe lx ly lz ma b">try</code>和<code class="fe lx ly lz ma b">except</code>子句，这是Python中异常处理的主干。然而，Python支持在处理异常时使用<code class="fe lx ly lz ma b">else</code>子句。具体来说，<code class="fe lx ly lz ma b">else</code>子句中的代码在成功执行<code class="fe lx ly lz ma b">try</code>子句中的代码后运行。通过这样做，我们可以保持<code class="fe lx ly lz ma b">try</code>子句中的代码尽可能的简洁，这将提高我们期望在<code class="fe lx ly lz ma b">try</code>子句中处理的可能异常的可见性。让我们利用<code class="fe lx ly lz ma b">else</code>子句来修改这个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">利用Else子句</p></figure><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们通过放置<code class="fe lx ly lz ma b">print</code>函数来利用<code class="fe lx ly lz ma b">else</code>子句，该函数仅在我们使用有效参数调用函数时执行。值得注意的是，当出现异常时，它不会被执行。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="17a4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.不明白‘finally’子句何时执行</h1><p id="dba0" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">除了<code class="fe lx ly lz ma b">else</code>子句，Python的异常处理也支持<code class="fe lx ly lz ma b">finally</code>子句。<code class="fe lx ly lz ma b">finally</code>条款位于<code class="fe lx ly lz ma b">else</code>条款之后。但是，如果没有<code class="fe lx ly lz ma b"> else</code>条款，则应该遵循<code class="fe lx ly lz ma b">except</code>条款。无论是否捕获到异常，都会执行<code class="fe lx ly lz ma b">finally</code>子句中的代码，这也是为什么有人说<code class="fe lx ly lz ma b">finally</code>子句保证运行的原因。让我们看看如何使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Finally处理异常</p></figure><p id="6ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，在两个函数调用中，<code class="fe lx ly lz ma b">finally</code>子句中的代码在没有异常时运行(因此，<code class="fe lx ly lz ma b">else</code>子句也执行)，并且有一个异常被捕获(因此，<code class="fe lx ly lz ma b">except</code>子句执行)。值得注意的是，有些人确实理解<code class="fe lx ly lz ma b">finally</code>子句在异常处理中的用法，但他们不知道执行顺序。让我们看看下面这个可能的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Finally子句执行顺序</p></figure><p id="26ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe lx ly lz ma b">finally</code>子句返回一个<code class="fe lx ly lz ma b">None</code>值，同时，<code class="fe lx ly lz ma b">try</code>子句返回计算出的值。有些人可能认为<code class="fe lx ly lz ma b">finally</code>子句中的返回值无关紧要，因为<code class="fe lx ly lz ma b">try</code>子句将首先被执行，因此将返回正确的值。</p><p id="a3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶的是，如你所见，计算出的值是<code class="fe lx ly lz ma b">None</code>。到底发生了什么？这是因为如果<code class="fe lx ly lz ma b">try</code>子句要通过break、continue或return语句来完成它的执行，那么<code class="fe lx ly lz ma b">finally</code>子句将在break、continue或return语句执行之前执行。因此，在我们的例子中，我们返回的是<code class="fe lx ly lz ma b">None</code>值。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d17d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">结论</strong></h1><p id="3b24" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在本文中，我们回顾了人们在Python异常处理方面可能犯的五个常见错误。当然，人们还会犯其他的错误，但是避免这些错误会让你为在项目中正确处理异常做好准备。</p></div></div>    
</body>
</html>