<html>
<head>
<title>Understanding Layered Architecture in KMM, Part 2 — Designing the Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解KMM的分层架构，第2部分—设计解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536?source=collection_archive---------6-----------------------#2022-04-03">https://betterprogramming.pub/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536?source=collection_archive---------6-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3869" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分，共5部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/920dd4f2322d970a1f006b086027ed4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*XD1B17HMX_rUewgaIDRJEA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">最终建筑设计</p></figure><h1 id="05e5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">设计解决方案</h1><p id="daad" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们将要开发的应用程序非常简单，但是为了理解将项目分层的所有特性，我们将使它变得复杂，也许是不必要的。</p><p id="c10e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们的应用程序将显示电影列表。就是这样。就这样。因此，我们将创建层，并赋予每一个责任。我将按照我们开发它的顺序列出它们:</p><h1 id="415a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">领域</h1><p id="3a91" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在这里，我们将创建我们的主要“电影”模型。此外，储存库和数据源的契约或定义。</p><p id="9277" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">存储库将是一个<code class="fe mk ml mm mn b">domain</code>包中的接口，数据源的类将在另一个<code class="fe mk ml mm mn b">data</code>包中，我们将在本系列的下一章中看到(包括帮助我们将数据保存到本地数据库的库和帮助我们从REST服务获取数据的库)。</p><p id="febe" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在我们的领域层内将是我们希望我们的应用程序拥有的所有逻辑<strong class="ll ir">，而不管它将在什么平台上实现</strong>。</p><p id="7160" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">例如，我们是否希望我们的应用程序显示电影列表？然后我们必须创建一个负责给我们带来电影的类。这个类就是我们所说的“用例”，<em class="mo">用例</em>或者<em class="mo">交互器</em>。不管你是在编写Android还是iOS应用程序，它都会显示一个电影列表，逻辑在两者中都是一样的。</p><p id="0f9f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这意味着我们的领域模块必须能够从Android应用的源代码中“提取”自身，并且能够在另一个<em class="mo">框架</em>中使用，同时保持核心功能。</p><p id="f66f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">也许创建一个只有一个功能的类似乎不是很有用，这个类唯一的功能是返回存储库提供给它的电影列表。就好像这个<em class="mo">用例</em>是一个扶手，一座桥。</p><p id="ab00" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">但是我们这样来看:阅读下面的结构，你觉得这个例子app是做什么的？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a4e95ba5c50e1ac1f5ca3d7fa84eaf51.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/0*YUsUK3O9kkUT1C7z"/></div></figure><p id="7c26" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最有可能是一个有购物车的应用，对吧？其中您可以看到产品，促销，将它们添加到购物车，并在购物车中的所有数据都经过验证的情况下进行购买。</p><p id="dadd" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当你进入一个项目，发现像这样的东西，你就节省了大量的时间去尝试理解应用程序是如何工作的。当然，可能还有执行更复杂动作的<em class="mo">用例</em> / <em class="mo">交互器</em>。</p><p id="25d8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们的应用程序将只有一个<em class="mo">用例</em>实现:<code class="fe mk ml mm mn b">GetMoviesInteractor</code>。顺便说一下，在创建用例类时，我更喜欢使用术语“交互器”，因为交互器是实现系统用例的对象。</p><h1 id="a746" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">数据</h1><p id="15ca" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于每个框架或平台，数据层也应该是相同的。无论应用程序是在安卓、iOS、网络还是桌面上运行都没关系。存储库和数据源实现的逻辑应该完全相同。</p><p id="8daf" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">然而，我们在这里发现了一个障碍。每个平台都有不同的方式连接到REST APIs或将数据保存到本地数据库中。安卓多采用翻新，iOS应用采用Alamofire。那么，我们如何处理一种独特的方式来访问数据，即使是外部或内部的呢？</p><p id="1309" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">您可以考虑改型，因为它适用于任何JVM项目，并且KMM的核心是一个纯Kotlin模块。然而，<a class="ae mq" href="https://github.com/square/retrofit/issues/3181" rel="noopener ugc nofollow" target="_blank">正如你在Github </a>上看到的，Jake Wharton解释说这将需要一些时间，因为翻新依赖于其他库，比如OkHttp。</p><p id="643e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">到目前为止(2022年3月)，我们能找到的最佳选择是使用<a class="ae mq" href="https://ktor.io/docs/http-client-multiplatform.html" rel="noopener ugc nofollow" target="_blank"> Ktor </a>来消费REST APIs。</p><p id="9993" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">以及我们应该使用什么作为本地数据源库？为此，有<a class="ae mq" href="https://cashapp.github.io/sqldelight/multiplatform_sqlite/" rel="noopener ugc nofollow" target="_blank"> SqlDelight </a>，KMM项目的实现非常简单！我们需要为每个平台创建数据库驱动程序，并将数据源实现放在<code class="fe mk ml mm mn b">commonMain</code>(<code class="fe mk ml mm mn b">shared</code>模块中的核心包)中。它们(数据源)将依赖于数据库驱动程序接口。轻松点。</p><h1 id="e009" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍会；展示会</h1><p id="da29" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是最简单的一个(也可能不是)。这里我们只需要写每个平台的UI！即使用Android的Jetpack Compose，iOS的SwiftUI等。</p><p id="bc25" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果您想尝试更复杂的东西，您可以尝试在<code class="fe mk ml mm mn b">shared</code>模块中添加一个<code class="fe mk ml mm mn b">presentation</code>包，并为视图、演示者和视图模型定义契约(如果您想实现MVP或MVVM模式的话)。老实说，这是我还没有尝试过的东西，但可能会非常有趣。</p><h1 id="3a1f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">最后…</h1><p id="4c7b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是我们项目的最终架构设计:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7dd5a253a81332cc2c7994245a0fdc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*odyxHL1p7f5cykYV"/></div></figure><p id="9364" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如你所看到的，我们正在最大限度地实现一个独特的跨业务层，可以被任何平台使用。</p><p id="9e64" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们的项目树应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/a0d64498de017419c0c607f622e1c485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PVYHP_a4HQj6iXCP"/></div></div></figure><p id="c4ea" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">您可能已经注意到，我们开始从核心，从业务逻辑或领域层构建软件。业务的规则和需求将指导软件的开发:领域驱动的开发。</p><p id="63e3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir">注意:我正在Github中开发一个开源的Kotlin多平台项目，看看吧！</strong></p><div class="mw mx gp gr my mz"><a href="https://github.com/jflavio11/LayeredKotlinMultiplatform" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub-jflavio 11/LayeredKotlinMultiplatform:展示分层的示例KMM应用程序…</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">这个项目是由一系列的职位，你可以在我的博客https://jflavio.com领域和数据层…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kl mz"/></div></div></a></div><h1 id="6a12" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">此帖子系列的拆分</h1><p id="2c16" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是我们为项目设计解决方案的第二篇文章。下面，我们将讨论域层的实现。本指南将分为以下几个帖子:</p><ol class=""><li id="9b98" class="no np iq ll b lm mf lp mg ls nq lw nr ma ns me nt nu nv nw bi translated"><a class="ae mq" href="https://medium.com/@jflavio11/understanding-layered-architecture-in-a-kotlin-multiplatform-project-part-1-a7488f478978" rel="noopener">简介</a></li><li id="73c5" class="no np iq ll b lm nx lp ny ls nz lw oa ma ob me nt nu nv nw bi translated"><a class="ae mq" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536" rel="noopener">设计解决方案(本帖)</a></li><li id="a076" class="no np iq ll b lm nx lp ny ls nz lw oa ma ob me nt nu nv nw bi translated"><a class="ae mq" href="https://jflavio11.medium.com/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a" rel="noopener">创建领域层</a></li><li id="7b86" class="no np iq ll b lm nx lp ny ls nz lw oa ma ob me nt nu nv nw bi translated"><a class="ae mq" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-4-the-data-layer-6fc0e153fffb" rel="noopener">创建图层数据</a></li><li id="3938" class="no np iq ll b lm nx lp ny ls nz lw oa ma ob me nt nu nv nw bi translated">实现表示层</li></ol></div></div>    
</body>
</html>