<html>
<head>
<title>The Long-Awaited Go Feature: Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">期待已久的Go特性:泛型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-long-awaited-go-feature-generics-4808f565dbe1?source=collection_archive---------1-----------------------#2022-02-10">https://betterprogramming.pub/the-long-awaited-go-feature-generics-4808f565dbe1?source=collection_archive---------1-----------------------#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Go中使用泛型的简短指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3b4190087d156f763890d11f9e6f38c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwzWqJ4CMQm4j7XS2ppMMg.jpeg"/></div></div></figure><p id="edff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自诞生以来，Go因许多原因而受到称赞，但也因其他原因而受到批评，这是本故事主题的主要痛点:泛型。或者说是缺少它们。</p><p id="e2e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，这个决定背后的原因是保持语言的简单，因为这是Go的哲学。</p><p id="a8b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">来自Go的常见问题:</p><blockquote class="ln lo lp"><p id="d6b9" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">Go旨在作为一种编写服务器程序的语言，随着时间的推移，这种语言易于维护。(更多背景资料见<a class="ae lu" href="https://go.dev/talks/2012/splash.article" rel="noopener ugc nofollow" target="_blank">本文</a>。)设计集中在可伸缩性、可读性和并发性等方面。多态编程在当时对语言的目标来说似乎并不重要，因此为了简单起见被忽略了。</p><p id="d9b9" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi">[…]</p><p id="885f" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">泛型很方便，但是它们的代价是类型系统和运行时的复杂性。我们还没有找到一种设计能提供与复杂性相称的价值，尽管我们在继续思考它。与此同时，Go内置的映射和切片，加上使用空接口构造容器的能力(通过显式拆箱),意味着在许多情况下可以编写代码来做泛型所能做的事情，即使不太流畅。</p></blockquote><h1 id="228b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">什么是泛型？</h1><p id="be31" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">有时候，实现可以处理任何数据类型的数据结构或算法是很有用的，比如对数组的每个元素执行操作的函数，而不管数据类型如何。例如，如果我们想要迭代一个元素数组，在控制台上打印每个元素——到目前为止，这样做的唯一方法是这样的:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3b9f" class="mx lw iq mt b gy my mz l na nb"><br/>func Print(arr []interface{}) {</span><span id="b2f0" class="mx lw iq mt b gy nc mz l na nb">for _, elem := range arr {<br/>   switch o := i.(type) {<br/>        case int64:<br/>            fmt.Printf("%5d\n", o)<br/>        case float64:<br/>            fmt.Printf("%7.3f\n", o)<br/>        case string:<br/>            fmt.Printf("%s\n", o)<br/>        default: // covers structs and such<br/>            fmt.Printf("%+v\n", o)<br/>    }<br/>}<br/>}</span></pre><p id="4d19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">依我拙见，不太实际。</p><p id="c275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">泛型是Go开发团队要求最多的功能，如下图所示，该图摘自<a class="ae lu" href="https://go.dev/blog/survey2020-results" rel="noopener ugc nofollow" target="_blank"> Go 2020调查</a>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/ec027c7bb417d9dbb87b5ab528e1341d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bLsWD3WT-CyDdAQZaRFVg.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">泛型是目前最受欢迎的特性</p></figure><p id="d3a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">已经听到了请求，泛型将在1.18版本中发布(预计在2022年2月发布)。</p><p id="1f49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不意味着在那之前我们不能玩得开心。发布日期是生产就绪版本，我们现在可以访问beta 2(你可以在这里了解如何安装它<a class="ae lu" href="https://go.dev/blog/go1.18beta2" rel="noopener ugc nofollow" target="_blank"/>)。事不宜迟，让我们进入Go泛型吧！</p><h1 id="8e24" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">定义通用函数</h1><p id="a2ea" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">要定义一个泛型函数，我们必须将泛型类型标识符放在方括号中，在函数名之后，参数之前，后面跟有单词<code class="fe ni nj nk mt b">any</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="774b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们可以传递任何数据类型的任何切片，并打印出来。让我们用一段int，另一段string和最后一段struct来试试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a8b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们得到以下控制台输出:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c6bc" class="mx lw iq mt b gy my mz l na nb">1<br/>2<br/>3<br/>4<br/>hello<br/>i'm<br/>using<br/>generics<br/>{Matthew}<br/>{John}</span></pre><p id="d729" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，每种数据类型都用相同的函数打印出来。耶！</p><h1 id="02d6" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">限制</h1><p id="cd19" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">有一种方法可以通过使用约束来限制我们的泛型函数可以接受的数据类型。例如，我们可能希望将允许的类型限制为可以转换为字符串的数据类型。为此，我们用函数<code class="fe ni nj nk mt b">String() string</code>创建一个接口<code class="fe ni nj nk mt b">Stringer</code>，并创建通用数据类型<code class="fe ni nj nk mt b">T Stringer</code>。这样，该函数将只接受实现了<code class="fe ni nj nk mt b">String() string</code>函数的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9623" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">控制台输出:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ca01" class="mx lw iq mt b gy my mz l na nb">Matthew Johnson<br/>John Johnson</span></pre><h2 id="88c6" class="mx lw iq bd lx nn no dn mb np nq dp mf la nr ns mh le nt nu mj li nv nw ml nx bi translated">可比约束</h2><p id="1658" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们可以声明一个<code class="fe ni nj nk mt b">comparable</code>泛型类型，将参数限制为可以与操作数<code class="fe ni nj nk mt b">==</code>和<code class="fe ni nj nk mt b">!=</code>一起使用的数据类型。让我们创建一个通用函数，它计算数组中某个值的出现次数，然后用一个string数组和一个int数组执行它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1c2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">控制台输出:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3a2b" class="mx lw iq mt b gy my mz l na nb">3<br/>2<br/>2<br/>3</span></pre><h2 id="04e5" class="mx lw iq bd lx nn no dn mb np nq dp mf la nr ns mh le nt nu mj li nv nw ml nx bi translated">几种类型</h2><p id="2adc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们可以声明一个只接受特定数据类型的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="53ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">控制台输出:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="cd85" class="mx lw iq mt b gy my mz l na nb">6<br/>14.3</span></pre><p id="1481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以用一系列数据类型声明一个接口:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5194" class="mx lw iq mt b gy my mz l na nb">type Addable type {<br/>  int | int32 | int64 | float32 | float64 | uint | uint32 | uint64<br/>}</span></pre><p id="fe08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果我们在可添加数据类型和别名之间执行加法</p><p id="2cbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9bdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们得到以下错误:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="093f" class="mx lw iq mt b gy my mz l na nb">./main.go:17:17: myInt does not implement Addable (possibly missing ~ for int in constraint Addable)</span></pre><p id="a784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如错误消息所说，我们可以简单地通过在<code class="fe ni nj nk mt b">Addable</code>接口中的<code class="fe ni nj nk mt b">int</code>数据类型声明之前添加<code class="fe ni nj nk mt b">~</code>来解决这个问题。这样任何别名类型的<code class="fe ni nj nk mt b">int</code>都实现了Addable。这适用于我们想要实现Addable的任何别名。例如，如果我们想要用一个别名<code class="fe ni nj nk mt b">float64</code>来实现Addable，我们应该在<code class="fe ni nj nk mt b">float64</code>数据类型声明之前添加<code class="fe ni nj nk mt b">~</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="220d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在成功了:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="2872" class="mx lw iq mt b gy my mz l na nb">9</span></pre><h2 id="940b" class="mx lw iq bd lx nn no dn mb np nq dp mf la nr ns mh le nt nu mj li nv nw ml nx bi translated">混合的</h2><p id="21d2" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">约束也可以在新的界面中混合在一起</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="6fdf" class="mx lw iq mt b gy my mz l na nb">type ComparableStringer interface {<br/>     comparable     <br/>     String() string <br/>}</span></pre><p id="3f96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，通用数据类型<code class="fe ni nj nk mt b">T ComparableStringer</code>将只接受实现<code class="fe ni nj nk mt b">String() string</code>方法并且是<code class="fe ni nj nk mt b">comparable</code>的类型。</p><p id="c924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我省略了一些关于Go泛型的主题，以使这成为一篇轻松的阅读，所以请确保您继续学习它们！</p><p id="6b64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编码快乐！</p></div></div>    
</body>
</html>