<html>
<head>
<title>Introducing GridPad — Jetpack Compose Layout for Grid-Based UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍GridPad — Jetpack为基于网格的UI构建布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gridpad-jetpack-compose-layout-for-grid-based-ui-fef161d42d5b?source=collection_archive---------9-----------------------#2022-12-19">https://betterprogramming.pub/gridpad-jetpack-compose-layout-for-grid-based-ui-fef161d42d5b?source=collection_archive---------9-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5902" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GridPad是一个Jetpack Compose库，有助于更自然、更方便地创建基于网格的UI</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bfd7b50b5253c05a9a7fe05b9e965c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0Z_-gdRpGyTiwNbpJFglw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的图片</p></figure><p id="7f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很可能，每个开发人员都面临着实现基于网格的组件的任务，比如pin pads、calendar cells等等。当然，标准的Jetpack Compose库允许您通过<code class="fe lr ls lt lu b">Row</code>和<code class="fe lr ls lt lu b">Column</code>的组合来实现您需要的一切。<code class="fe lr ls lt lu b">Row</code>和<code class="fe lr ls lt lu b">Column</code>组合的问题是对行和列大小的不自然的控制。</p><p id="2dce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，使用<code class="fe lr ls lt lu b">Row</code>和<code class="fe lr ls lt lu b">Column</code>扳手可能不太方便。为了避免引起注意的问题，我们让GridPad — Jetpack为基于网格的UI编写布局。所以，让我们来看看<code class="fe lr ls lt lu b">GridPad</code>的行动。</p><h1 id="912d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">开始</h1><p id="1338" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">首先，将下面的依赖项添加到模块的<code class="fe lr ls lt lu b">build.gradle</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a5e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要实现最简单的网格，您需要做的就是编写几行代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bad1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码初始化一个3x4的网格，行和列的权重等于1。这意味着<code class="fe lr ls lt lu b">GridPad</code>获取父边界，并在行和列之间平均分配它们。因此，<code class="fe lr ls lt lu b">GridPad</code>必须从两方面进行限制:水平和垂直。不允许将其放入无限布局中。上面代码的结果将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71b711c45d3a91f33d51f1f100dfca02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkxYQwsmxiA43PZHgQvkQg.png"/></div></div></figure><p id="c2ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要将内容放入单元格，您应该用<code class="fe lr ls lt lu b">item</code>包装它。可以显式和隐式放置<code class="fe lr ls lt lu b">GridPad</code>中的项目。在上面的例子中，项目是隐式放置的。隐式放置将该项目放置在同一行中最后放置的项目(包括跨度大小)旁边。第一名将位于位置<code class="fe lr ls lt lu b">[0;0]</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5dbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当一个项目被放置在一行的最后一列时，下一个项目被放置在从第一列开始的下一行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc16f7378610cc5b50cd642980c6a9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vq6XuaXtuUWmvdHPtu_w3Q.png"/></div></div></figure><h1 id="b715" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">定义网格</h1><p id="3ed9" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">需要指定精确的网格大小，但是指定每行和每列的大小是可选的。要定义行或列的特定大小，您需要使用<code class="fe lr ls lt lu b">GridPadCells.Builder</code> API。下面是如何做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3315" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该库支持两种类型大小:</p><ul class=""><li id="d42b" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><code class="fe lr ls lt lu b">GridPadCellSize.Fixed</code>—DP中的固定尺寸，当<code class="fe lr ls lt lu b">GridPad</code>的边界改变时不变。</li><li id="a43a" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><code class="fe lr ls lt lu b">GridPadCellSize.Weight</code> <strong class="kx ir"> </strong> —相对，取决于其他权重、放置固定尺寸后的剩余空间以及<code class="fe lr ls lt lu b">GridPad</code>边界。</li></ul><p id="bdd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码将绘制以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f1701916e5acdec592850352750ecb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PloExO_c03nO1YhwG0l_xQ.png"/></div></div></figure><p id="1af4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在单元格之间分配可用空间的算法:</p><ol class=""><li id="166c" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq ni na nb nc bi translated">从可用空间中减去所有固定(<code class="fe lr ls lt lu b">GridPadCellSize.Fixed</code>)值。</li><li id="6756" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq ni na nb nc bi translated">剩余空间根据其权重值在剩余单元格之间分配(<code class="fe lr ls lt lu b">GridPadCellSize.Weight</code>)。</li></ol><h1 id="c56d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">放置物品</h1><p id="8447" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">为了更灵活地控制绘制顺序和位置，每个单元格的内容都应该用一个项目包装起来。要显式放置一个项目，需要在项目中指定属性<code class="fe lr ls lt lu b">row</code>和<code class="fe lr ls lt lu b">column</code>中的一个或两个。当定义<code class="fe lr ls lt lu b">row</code>和<code class="fe lr ls lt lu b">column</code>属性时，也可以将所有项目以不同的顺序放置，而不考虑实际位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9e3c0f60b9a1a428debdaebd9e9c8b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9Ix0LbbM1a8pP5ybt3fIA.png"/></div></div></figure><blockquote class="nj nk nl"><p id="b195" class="kv kw nm kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">如果位置到达最后一行和最后一列，将忽略以下项目。不允许将项目放置在网格之外。</p></blockquote><p id="3620" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当指定时，只有<code class="fe lr ls lt lu b">row</code>和<code class="fe lr ls lt lu b">column</code>属性之一，逻辑将如下:</p><ul class=""><li id="1abf" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated">如果跳过<code class="fe lr ls lt lu b">row</code>属性，该行将等于最后放置的项目的行。</li><li id="1eda" class="mu mv iq kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">如果跳过<code class="fe lr ls lt lu b">column</code>属性，该行将是最后一个放置的项目之后的下一行(包括跨度大小)。当最后一项放在一行的最后一列时，下一项放在从第一列开始的下一行。</li></ul><blockquote class="nj nk nl"><p id="33fb" class="kv kw nm kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">一个单元格可以包含多个项目。抽取顺序将与放置顺序相同。<code class="fe lr ls lt lu b"><em class="iq">GridPad</em></code>当子项具有明确的大小时，不限制该项的大小。这意味着该项可以超出单元格边界。</p></blockquote><h1 id="7436" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">跨度</h1><p id="591d" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">默认情况下，每个项目的跨度为1x1。要更改它，请指定该项目的<code class="fe lr ls lt lu b">rowSpan</code>和<code class="fe lr ls lt lu b">columnSpan</code>属性中的一个或两个。重叠元素也是允许的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f7be422fbc7408e702687435a31447d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCOqOvB8UFtgal-nvmBrMQ.png"/></div></div></figure><p id="3370" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当某个项目的范围超出网格时，该项目将被跳过，并且不会进行绘制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><blockquote class="nj nk nl"><p id="68f7" class="kv kw nm kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">当您有一个复杂的结构时，强烈建议使用一种明确的方法来放置所有的项目，以避免在放置项目时出现不可预测的行为和错误。</p></blockquote><h1 id="3330" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="5d7e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">现在您知道了一个使您的开发更有成效的库。您可以在库存储库中的示例应用程序中找到更多示例:</p><div class="nq nr gp gr ns nt"><a href="https://github.com/touchlane/gridpad-android" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">GitHub—touch lane/grid pad-Android:grid pad Jetpack撰写布局</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">GridPad是一个Jetpack Compose库，它允许您将UI元素放置在预定义的网格中，管理二维范围，…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kp nt"/></div></div></a></div></div></div>    
</body>
</html>