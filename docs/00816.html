<html>
<head>
<title>Using Docker-Compose to Hook up a React/TypeScript/MongoDB Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker-Compose连接React/TypeScript/MongoDB应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-docker-compose-to-hook-up-a-full-stack-application-react-node-typescript-mongodb-fa66b96369a1?source=collection_archive---------1-----------------------#2019-07-17">https://betterprogramming.pub/using-docker-compose-to-hook-up-a-full-stack-application-react-node-typescript-mongodb-fa66b96369a1?source=collection_archive---------1-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6dcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Docker简化您的开发体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/237fb0c7188302bc55bb1813c61ab8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fd5JCT7Uo1vDnmY08DzGYA.jpeg"/></div></div></figure><h1 id="1b0b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">目标</h1><p id="03fc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我将概述如何使用<code class="fe mi mj mk ml b">docker-compose</code>在您的机器上建立一个本地开发环境，以编排一个技术堆栈的各个部分，该技术堆栈包括:</p><ul class=""><li id="b5b0" class="mm mn it lo b lp mo ls mp lv mq lz mr md ms mh mt mu mv mw bi translated">前端(客户端)</li><li id="cf14" class="mm mn it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">GraphQL API (API)</li><li id="681b" class="mm mn it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">数据库</li></ul><p id="8799" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">我们的目标是能够将应用程序的每个部分容器化，并使用一个简单的命令运行整个程序:<code class="fe mi mj mk ml b">docker-compose up</code>。</p><p id="b9ad" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">我想指出的是<code class="fe mi mj mk ml b">docker</code>和<code class="fe mi mj mk ml b">docker-compose</code>的文档非常详细。我强烈建议您阅读Docker官方主页上的<a class="ae nf" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">入门指南</a>。一旦您对基础知识感到满意，请回来继续学习，我会帮助您设置一个实用的基本全栈应用程序。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="8745" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">为什么要用Docker？</h1><p id="5a56" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可能会问，“Docker把它引入回购协议有什么好处？没有它，我也能创建和维护web应用程序！”</p><p id="b91d" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这个问题问得好！有许多简单的web应用程序只包含一个web应用程序或一个托管静态内容的服务器。然而，一旦你有了许多移动的部分和与你一起工作的队友，像Docker这样的工具可以使你的项目工作有一个一致的流程，不管你用的是谁的电脑。具体到我们的例子，它消除了在本地安装MongoDB之类的工作。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="bd60" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">入门指南</h1><p id="4420" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae nf" href="https://gitlab.com/msholty-fd/medium-react-typescript-mongo-example" rel="noopener ugc nofollow" target="_blank">在本地克隆该存储库以开始使用</a>。</p><p id="3d7e" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><strong class="lo iu">注意:</strong><code class="fe mi mj mk ml b">master</code>分支是跟踪本文的理想选择。<code class="fe mi mj mk ml b">docker</code>分支将添加必要的Docker相关文件，以便Docker按预期工作。</p><p id="1474" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这个项目有为你编写的前端和API，你可以自己启动它们。关于如何启动<code class="fe mi mj mk ml b">client</code>和<code class="fe mi mj mk ml b">api</code>的说明在<code class="fe mi mj mk ml b">README.md</code>中。</p><p id="8e87" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">有几个问题:</p><ul class=""><li id="78b4" class="mm mn it lo b lp mo ls mp lv mq lz mr md ms mh mt mu mv mw bi translated">您需要在运行应用程序之前全局安装<code class="fe mi mj mk ml b">mongodb</code>。Mongo数据库可以有不同的版本，如果您在一台机器上维护多个项目，这会使事情变得很复杂。</li><li id="7066" class="mm mn it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">您需要运行两个独立的命令来启动应用程序，如果您需要记住启动您的本地<code class="fe mi mj mk ml b">mongodb</code>，那么还需要更多。</li><li id="9477" class="mm mn it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">您将需要其他依赖项来确保应用程序正确运行。常见的有<code class="fe mi mj mk ml b">node</code>、<code class="fe mi mj mk ml b">yarn</code>、<code class="fe mi mj mk ml b">npm</code>。是的，在没有Docker的情况下在您的机器上安装这些是完全合理的，但这些只是一些可能会略有变化的示例，从而使您的开发环境与另一个略有不同，从而导致意外问题。这些类型的依赖关系不是从<code class="fe mi mj mk ml b">package.json</code>内部强制实施的。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f4f8" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">API的docker文件</h1><p id="84fe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，让我们将API容器化。我们需要在<code class="fe mi mj mk ml b">api</code>目录下创建一个名为<code class="fe mi mj mk ml b">Dockerfile</code>的文件。记住，<code class="fe mi mj mk ml b">Dockerfile</code>不会像<code class="fe mi mj mk ml b">.txt</code>那样以扩展名结尾。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6353" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这是一个小文件，所以我们在这里讨论所有的部分。</p><p id="12ad" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">首先，我们需要定义一个<code class="fe mi mj mk ml b">FROM</code>，这样Docker就知道这个<code class="fe mi mj mk ml b">Dockerfile</code>图像基于什么图像。这看起来很神奇，但是简单地定义我们的图像<code class="fe mi mj mk ml b">FROM node:12.6.0</code>给了我们的图像大量现成的功能！</p><p id="76ae" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">请记住，Docker映像是一个虚拟化的环境，与普通的Linux计算机没有太大的不同，因此它有自己的文件系统，与我们的计算机分开。我们使用<code class="fe mi mj mk ml b">WORKDIR</code>命令来定义Docker文件应该在哪里工作。与您自己的机器一样，您通常不会在您计算机的根目录中安装项目，所以让我们告诉Docker导航到<code class="fe mi mj mk ml b">/usr/src/app</code>。</p><p id="d380" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><code class="fe mi mj mk ml b">COPY . .</code>会将Docker文件所在目录下的所有文件和文件夹复制到Docker映像中的工作目录下。</p><p id="6f8e" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">乍一看，<code class="fe mi mj mk ml b">EXPOSE 4000</code>似乎公开了端口，因此您可以在容器外部访问它。然而，<a class="ae nf" href="https://docs.docker.com/engine/reference/builder/#expose" rel="noopener ugc nofollow" target="_blank">根据docker文档</a>，它只是为您和其他开发人员提供关于运行时应该公开哪个端口的文档。稍后将详细介绍这一点！</p><p id="8ee3" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><code class="fe mi mj mk ml b">RUN yarn</code>将简单地在我们的Docker容器中安装所有的依赖项，这样当你运行容器时，所有的依赖项都在那里。</p><p id="a9e1" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><code class="fe mi mj mk ml b">CMD ["yarn", "watch"]</code>将在这个容器中运行<code class="fe mi mj mk ml b">yarn watch</code>命令。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="500b" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">客户的文档</h1><p id="4a03" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们前端项目的<code class="fe mi mj mk ml b">Dockerfile</code>不会有太大的不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b2ca" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">这里的主要区别是，我们声明应该公开端口1234，因为这是默认端口，<code class="fe mi mj mk ml b">parcel</code>用它来服务web应用程序。此外，应用程序通过命令<code class="fe mi mj mk ml b">yarn start</code>启动。注意，我们在这里也使用了一个<code class="fe mi mj mk ml b">node:12.6.0</code>图像。你可能会想，“也许有一个针对前端开发优化的Docker映像？可能是React或打字稿图像？”</p><p id="ea1c" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">虽然我不怀疑有，但要明白这根本没有必要。我们只需要有一个可用的节点环境，我们主要在前端应用程序上与之交互的所有其他工具都是通过<code class="fe mi mj mk ml b">package.json</code>安装的。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4fea" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">建立我们的形象</h1><p id="0b2c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一旦我们为每个应用程序定义了<code class="fe mi mj mk ml b">Dockerfile</code>,我们就需要构建我们的映像，以便它们在本地可用。本节的最终结果是，当我们使用命令<code class="fe mi mj mk ml b">docker images ls</code>时，我们将看到显示的适当图像。</p><p id="eadb" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">构建映像非常简单。从项目根目录，运行命令<code class="fe mi mj mk ml b">docker build -t client ./client</code>构建前端，运行<code class="fe mi mj mk ml b">docker build -t api ./api</code>构建GraphQL API。</p><p id="154b" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">一旦这些命令完成，您应该会看到命令<code class="fe mi mj mk ml b">docker image ls</code>的一些输出，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/468750092f1e5322ca5c04cd80e32679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnjwiTGC94mmEzi6UuIoaw.png"/></div></div></figure><p id="c260" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">可以看到有一张<code class="fe mi mj mk ml b">api</code>和<code class="fe mi mj mk ml b">client</code>的图像，也有一张<code class="fe mi mj mk ml b">node</code>的图像。这是因为我们的两个映像是基于那个映像的，Docker需要在为另外两个映像构建映像之前准备好那个映像。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b4d5" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">运行我们的应用</h1><p id="e8ce" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一旦成功构建了这些映像，从技术上讲，您可以使用<code class="fe mi mj mk ml b">docker run</code>命令运行它们中的每一个，但是我们想采取下一步，使用<code class="fe mi mj mk ml b">docker-compose</code>将这些容器编排在一起。此外，我们仍然缺少我们的数据库！</p><p id="43cd" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">让我们在项目的根目录下创建一个<code class="fe mi mj mk ml b">docker-compose.yml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1fd6" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">在这个文件中，您将看到一些熟悉的配置。这里我们定义了三个服务，它们需要协同工作才能使我们的应用程序工作。<code class="fe mi mj mk ml b">api</code>和<code class="fe mi mj mk ml b">client</code>应该不会带来太大的惊喜——我们已经在本地构建了这些映像，上面的配置只是告诉<code class="fe mi mj mk ml b">docker-compose</code>使用这些映像。</p><p id="8da6" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated"><code class="fe mi mj mk ml b">mongo</code>的配置很有意思。我们在这个repo中没有一个<code class="fe mi mj mk ml b">mongo</code>文件夹或项目，那么这是怎么回事呢？类似于当你安装一个包时在<code class="fe mi mj mk ml b">npm</code>上有不同版本的依赖关系，<a class="ae nf" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank"> Docker已经将每个版本的mongodb内置在一个映像中</a>供你下载和使用。</p><p id="7f40" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">一旦添加了这个文件，就可以用命令<code class="fe mi mj mk ml b">docker-compose up</code>运行应用程序。您应该会看到类似如下的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/8559fabcefb4c760cbbdc3d6adbf2962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCr1Rz05e_9dHfITwcrTkA.png"/></div></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3204" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">几个音符</h1><p id="f11f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您可以使用命令<code class="fe mi mj mk ml b">docker exec &lt;image&gt; &lt;command&gt;</code>在Docker容器中运行任意命令。要查找容器的名称，您可以键入<code class="fe mi mj mk ml b">docker ps</code>，所有当前运行的Docker容器将会显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/680226950de31a6ee996b78000356b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3cwJcaiEM-t6sxt8EwE2g.png"/></div></div></figure><p id="9d77" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">当引用容器时，可以使用<code class="fe mi mj mk ml b">CONTAINER ID</code>或<code class="fe mi mj mk ml b">NAMES</code>列。在我们的例子中，这个名字很长，因为我给回购协议起的名字很长。</p><p id="a0ee" class="pw-post-body-paragraph lm ln it lo b lp mo ju lr ls mp jx lu lv nc lx ly lz nd mb mc md ne mf mg mh im bi translated">试运行<code class="fe mi mj mk ml b">docker exec &lt;id for api&gt; ping 0.0.0.0:27017</code>。这就像从<code class="fe mi mj mk ml b">api</code>容器中运行<code class="fe mi mj mk ml b">ping 0.0.0.0:27017</code>。注意它是如何找不到任何监听该端口的东西的！这是因为每个容器都是一个独立的映像，所以mongo当然不是从<code class="fe mi mj mk ml b">api</code>服务运行的。如果您确实想按计划ping mongo容器，您可以运行<code class="fe mi mj mk ml b">docker exec &lt;id for api&gt; ping mongo</code>。注意你如何得到成功的回应！</p></div></div>    
</body>
</html>