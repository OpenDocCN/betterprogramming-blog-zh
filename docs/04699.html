<html>
<head>
<title>How to Add Optional Methods to Swift Protocols?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift协议中添加可选方法？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-optional-methods-in-swift-protocols-91f00007cfd0?source=collection_archive---------10-----------------------#2020-04-30">https://betterprogramming.pub/how-to-add-optional-methods-in-swift-protocols-91f00007cfd0?source=collection_archive---------10-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="18e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么我建议在协议中避免可选方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a4f7e330015342644f4413587b4d083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZWGhsg4yyk1gLPgg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@jipy32?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">让-菲利普·德尔伯格</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8e32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能遇到过想要在Swift协议中添加可选方法的情况。当使用协议将方法强制到类、结构和枚举中时，这是一个非常常见的情况。在这篇文章中，我们将看到如何实现可选的方法行为，以及为什么我反对它。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5e16" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题是</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mw b">Elephant</code>类必须符合<code class="fe mt mu mv mw b">walk()</code>和<code class="fe mt mu mv mw b">run()</code>，即使我们知道大象不会跑。让我们解决这个问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7872" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案1: ObjC方法</h1><p id="ff4c" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">一种方法是用<code class="fe mt mu mv mw b">@objc</code>标记协议和功能，如下图。你会注意到我们已经从<code class="fe mt mu mv mw b">Elephant</code>类中移除了<code class="fe mt mu mv mw b">run()</code>方法，操场没有抱怨。</p><p id="211a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我们来理解一下我们做了什么:</p><ol class=""><li id="ac0a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们在<code class="fe mt mu mv mw b">run()</code>方法前面添加了可选的<code class="fe mt mu mv mw b">@objc</code>。</li><li id="cdda" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们在协议声明前面加了<code class="fe mt mu mv mw b">@objc</code>。</li><li id="f986" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们让<code class="fe mt mu mv mw b">Elephant</code>类继承了<code class="fe mt mu mv mw b">NSObject</code>类。</li><li id="2fe2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们从<code class="fe mt mu mv mw b">Elephant</code>类中移除了<code class="fe mt mu mv mw b">run()</code>方法。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这是一种Objective-C方法，你必须让我们的类继承自<code class="fe mt mu mv mw b">NSObject </code>——没有人喜欢这样。但这是我们的选择之一。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6485" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案2:快速方法</h1><p id="2a19" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们回到Swift和dump <code class="fe mt mu mv mw b">@objC</code>。下面是我们所做的:</p><ol class=""><li id="280d" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们移除了<code class="fe mt mu mv mw b">NSObject</code>和<code class="fe mt mu mv mw b">@objC</code>痕迹。</li><li id="b4cf" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们用一个空的<code class="fe mt mu mv mw b">run()</code>方法体在<code class="fe mt mu mv mw b">Animal</code>协议上添加了一个扩展。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d94d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。对于所有符合<code class="fe mt mu mv mw b">Animal</code>协议的类、结构和枚举来说，<code class="fe mt mu mv mw b">run()</code>方法现在是可选的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3b8d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么这样不好？</h1><p id="3241" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当您将任何协议方法设为可选时，您就做出了一个糟糕的设计决策，因为协议不应该这样使用。</p><blockquote class="nq"><p id="8ba4" class="nr ns iq bd nt nu nv nw nx ny nz lr dk translated">一个<em class="oa">协议</em>定义了适合特定任务或功能的方法、属性和其他需求的蓝图— <a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank"> Swift的官方文档</a></p></blockquote><p id="598e" class="pw-post-body-paragraph kw kx iq ky b kz ob jr lb lc oc ju le lf od lh li lj oe ll lm ln of lp lq lr ij bi translated">我们应该做的是将<code class="fe mt mu mv mw b">Animal</code>协议分解成两个不同的协议:一个是<code class="fe mt mu mv mw b">WalkableAnimal</code>，另一个是<code class="fe mt mu mv mw b">RunnableAnimal</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，我们将协议分解成许多更小的协议，并使我们的代码更易于阅读。我相信这是使用协议并最终走向面向协议编程的更好方式。</p><p id="1ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以使用<code class="fe mt mu mv mw b">Protocol</code>继承。像<a class="og oh ep" href="https://medium.com/u/3c86fa45b598?source=post_page-----91f00007cfd0--------------------------------" rel="noopener" target="_blank"> mmalc Crawford </a>在这里建议的:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/@mmalc/alternatively-you-could-keep-animal-and-make-a-fast-animal-a-specialisation-e86fe329668" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">或者，你可以饲养动物，并使快速动物成为一个专业。</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">礼仪动物{</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="abe5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="8ddb" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">感谢您的阅读。我很乐意在评论区听到你的意见。</p></div></div>    
</body>
</html>