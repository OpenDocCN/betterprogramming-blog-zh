<html>
<head>
<title>JSON Parsing in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的JSON解析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/json-parsing-in-swift-2498099b78f?source=collection_archive---------0-----------------------#2018-02-10">https://betterprogramming.pub/json-parsing-in-swift-2498099b78f?source=collection_archive---------0-----------------------#2018-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="676b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Swift 5.1中的可编码协议处理JSON响应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/669b7ae7e4394ad97453c2688f517c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9jexfdw-5u9_52UHzB_vQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<a class="ae ky" href="http://genchi.info/image/best-wallpaper-18.jpg" rel="noopener ugc nofollow" target="_blank">根奇壁纸</a>)</p></figure><p id="31d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经常使用JSON来发送和接收来自web服务的数据。借助Swift，我们可以轻松做到这一点。</p><p id="e57b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数应用程序都完全基于JSON。如果您的应用程序与一个web服务API通信，它将向<code class="fe lv lw lx ly b">Dictionary(Object)</code>、<code class="fe lv lw lx ly b">Array</code>、<code class="fe lv lw lx ly b">String</code>、<code class="fe lv lw lx ly b">Bool</code>或<code class="fe lv lw lx ly b">Number</code>返回一个响应。</p><p id="ee2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建模型类之前，我们需要记住来自web服务的响应类型。我们将根据响应创建<code class="fe lv lw lx ly b">Model</code>类。本主题将涵盖从初级到高级的大部分与零件相关的解析。</p><p id="c4ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我很难理解JSON解析。但随着时间的推移，我意识到它实际上非常容易使用。你只需要了解响应类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bcff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">网络请求入门，URLSession</h1><p id="9b16" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在开始我们的代码之前，我们需要通过在浏览器中键入以下内容来检查我们的web API:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/2bc5d9f8af8f29542e8514d0ae11a07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-LSxa-trIRQHwae6UXV4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JSON响应</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="0119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经在web浏览器中获得了响应，让我们用Xcode进行一些编码。为JSON解析创建一个新项目。</p><ul class=""><li id="dcba" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">在项目的<code class="fe lv lw lx ly b">plist</code>中，导航到Open As，然后导航到Source Code。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d537a8a30b7c4eed2b73a19afffab9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zrvd_NLro2wP0WdTc8i5Wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打开您的项目列表</p></figure><ul class=""><li id="3234" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">将<a class="ae ky" href="https://stackoverflow.com/a/30732693" rel="noopener ugc nofollow" target="_blank"> App传输安全</a>代码粘贴到项目的<code class="fe lv lw lx ly b">plist</code>中。</li></ul><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="6c62" class="ns mh it ly b gy nt nu l nv nw">&lt;key&gt;<strong class="ly iu">NSAppTransportSecurity</strong>&lt;/key&gt;<br/>&lt;<strong class="ly iu">dict</strong>&gt;<br/>  &lt;key&gt;<strong class="ly iu">NSAllowsArbitraryLoads</strong>&lt;/key&gt;<br/>  &lt;true/&gt;<br/>&lt;/<strong class="ly iu">dict</strong>&gt;</span></pre><ul class=""><li id="7c12" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">现在用URLSession <strong class="lb iu"> </strong>向您的web API发出一个网络请求。</li></ul><p id="b859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们请求web API处理数据和错误，这是我们将在它的响应中看到的。在这里，我使用JSONSerialization内置的基础框架。它将把JSON数据转换成一个基础对象。</p><p id="3ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分，我使用了来自<a class="ae ky" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>的测试API:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="4457" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">guard</strong> let <strong class="ly iu">url</strong> = <strong class="ly iu">URL</strong>(string: "<a class="ae ky" href="https://jsonplaceholder.typicode.com/todos" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos</a>") <strong class="ly iu">else</strong> {<strong class="ly iu">return</strong>}<br/>let <strong class="ly iu">task</strong> = <strong class="ly iu">URLSession</strong>.shared.<strong class="ly iu">dataTask</strong>(with: <strong class="ly iu">url</strong>) <strong class="ly iu">{</strong> (<strong class="ly iu">data</strong>, response, <strong class="ly iu">error</strong>) in<br/><strong class="ly iu">guard</strong> let dataResponse = <strong class="ly iu">data</strong>,<br/>          <strong class="ly iu">error</strong> == nil <strong class="ly iu">else</strong> <strong class="ly iu">{</strong><br/>          <strong class="ly iu">print</strong>(<strong class="ly iu">error</strong>?.localizedDescription ?? "Response Error")<br/>          <strong class="ly iu">return }</strong>  <br/>    <strong class="ly iu">do{ <br/>        </strong>//<em class="nx">here </em><strong class="ly iu"><em class="nx">dataResponse </em></strong><em class="nx">received from a network request </em><br/>        <strong class="ly iu">let</strong> jsonResponse = try <strong class="ly iu">JSONSerialization</strong>.jsonObject(with:<br/>                               <strong class="ly iu">dataResponse</strong>, options: <strong class="ly iu">[]</strong>) <br/>        <strong class="ly iu">print</strong>(jsonResponse) <strong class="ly iu">//</strong><em class="nx">Response result</em> <br/>     <strong class="ly iu">}</strong> <strong class="ly iu">catch</strong> let <strong class="ly iu">parsingError</strong> <strong class="ly iu">{</strong><br/>        <strong class="ly iu">print</strong>("Error", <strong class="ly iu">parsingError</strong>) <br/>   <strong class="ly iu">}</strong><br/><strong class="ly iu">}</strong><br/><strong class="ly iu">task</strong>.resume<strong class="ly iu">()</strong></span></pre><ul class=""><li id="04e6" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">JSON格式的web API的响应如下所示。现在我们需要从响应中获取值。这里我们的响应来自我们的JSON数组。</li></ul><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="98f2" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">[</strong><br/>  {<br/>    "userId": 1,<br/>    "id": 1,<br/>    "title": "delectus aut autem",<br/>    "completed": false<br/>  },<br/>  {<br/>    "userId": 1,<br/>    "id": 2,<br/>    "title": "quis ut nam facilis et officia qui",<br/>    "completed": false<br/>  }<br/><strong class="ly iu">]</strong></span></pre><ul class=""><li id="d63d" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">现在，我们来处理JSON响应<strong class="lb iu"> </strong>的对象:</li></ul><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="5465" class="ns mh it ly b gy nt nu l nv nw">guard <strong class="ly iu">let</strong> jsonArray = <strong class="ly iu">jsonResponse</strong> as? [[String: Any]] <strong class="ly iu">else</strong> {<br/>      return <br/>}<br/><strong class="ly iu">print</strong>(jsonArray)</span><span id="a258" class="ns mh it ly b gy ny nu l nv nw">//<em class="nx">Now get title value </em><br/>guard let <strong class="ly iu">title</strong> = <strong class="ly iu">jsonArray</strong>[<strong class="ly iu">0</strong>]["title"] as? String <strong class="ly iu">else</strong> { return } print(<strong class="ly iu">title</strong>) //<em class="nx">compiler outout</em> -  delectus aut autem</span></pre><p id="0822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着打印出所有的标题键值。</p><p id="3bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们的JSON响应是一个字典数组(<code class="fe lv lw lx ly b">[[String: Any]]</code>)。所以我们在<code class="fe lv lw lx ly b">for</code> <code class="fe lv lw lx ly b">loop</code>的帮助下从数组的每个索引中获取字典(我们在让<code class="fe lv lw lx ly b">Dictionary</code>用键访问值之后这样做)。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="5bd8" class="ns mh it ly b gy nt nu l nv nw">for <strong class="ly iu">dic</strong> in <strong class="ly iu">jsonArray{</strong><br/>    guard let <strong class="ly iu">title</strong> = <strong class="ly iu">dic</strong>["title"] as? String <strong class="ly iu">else</strong> { return }  <br/>    print(<strong class="ly iu">title</strong>) //Output<br/><strong class="ly iu">}</strong></span></pre><p id="c016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以为数据处理创建一个<code class="fe lv lw lx ly b">User</code>结构。作为响应，基于我在响应管理的模型结构中选择的值，我们将得到不同类型的值，例如<code class="fe lv lw lx ly b">Int</code>、<code class="fe lv lw lx ly b">String</code>和<code class="fe lv lw lx ly b">Boolean</code>。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="aba2" class="ns mh it ly b gy nt nu l nv nw">struct <strong class="ly iu">User</strong> <strong class="ly iu">{</strong><br/>      var <strong class="ly iu">userId</strong>: Int<br/>      var <strong class="ly iu">id</strong>: Int<br/>      var <strong class="ly iu">title</strong>: String<br/>      var <strong class="ly iu">completed</strong>: Bool</span><span id="6abd" class="ns mh it ly b gy ny nu l nv nw"><strong class="ly iu">init</strong>(_ dictionary: <strong class="ly iu">[</strong>String: Any<strong class="ly iu">]</strong>) {<br/>      self.<strong class="ly iu">userId</strong> = dictionary["userId"] as? <strong class="ly iu">Int</strong> ?? 0<br/>      self.<strong class="ly iu">id</strong> = dictionary["id"] as? <strong class="ly iu">Int</strong> ?? 0<br/>      self.<strong class="ly iu">title</strong> = dictionary["title"] as? <strong class="ly iu">String</strong> ?? ""<br/>      self.<strong class="ly iu">completed</strong> = dictionary["completed"] as? <strong class="ly iu">Bool</strong> ?? false<br/>    }<br/><strong class="ly iu">}</strong></span></pre><p id="c9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">model</code>来处理JSON响应:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="2e3d" class="ns mh it ly b gy nt nu l nv nw">var <strong class="ly iu">model</strong> = [<strong class="ly iu">User</strong>]() //Initialising Model Array<br/><strong class="ly iu">for</strong> dic in <strong class="ly iu">jsonArray</strong>{<br/>    <strong class="ly iu">model</strong>.append(<strong class="ly iu">User</strong>(dic)) // adding now value in <strong class="ly iu">Model</strong> array<br/>}<br/>//Printing first value for the output<br/>print(<strong class="ly iu">model</strong>[0].<strong class="ly iu">userId</strong>) // 1211</span></pre><p id="32af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷毙了。现在您对JSON解析有所了解了，对吗？</p><p id="f117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<a class="ae ky" href="https://developer.apple.com/documentation/swift/array/2903427-flatmap" rel="noopener ugc nofollow" target="_blank"> FlatMap </a>使同样的代码更加快速地互补:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="0b65" class="ns mh it ly b gy nt nu l nv nw">var <strong class="ly iu">model</strong> = [<strong class="ly iu">User</strong>]()<br/><strong class="ly iu">model</strong> = jsonArray.<strong class="ly iu">flatMap</strong>{ (dictionary) <strong class="ly iu">in</strong><br/>            return <strong class="ly iu">User</strong>(dictionary)<br/>        }<br/>print(<strong class="ly iu">model</strong>[0].<strong class="ly iu">userId</strong>)</span><span id="8c06" class="ns mh it ly b gy ny nu l nv nw">//make more simple<br/><strong class="ly iu">model</strong> = jsonArray.<strong class="ly iu">flatMap</strong>{ return <strong class="ly iu">User</strong>($0)}</span><span id="c03b" class="ns mh it ly b gy ny nu l nv nw">//One more time <br/><strong class="ly iu">model</strong> = jsonArray.<strong class="ly iu">flatMap</strong>{<strong class="ly iu">User</strong>($0)}</span><span id="f12c" class="ns mh it ly b gy ny nu l nv nw">//Or <br/><strong class="ly iu">model</strong> = jsonArray.<strong class="ly iu">flatMap</strong>(<strong class="ly iu">User</strong>.init)</span><span id="3571" class="ns mh it ly b gy ny nu l nv nw">//Output<br/>print(<strong class="ly iu">model</strong>[0].<strong class="ly iu">userId</strong>) // 1211</span></pre><p id="5bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错，但是让我们做更多的事情。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c90e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可编码协议</h1><p id="5144" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">苹果在Swift 4中引入的新协议提供了内置的<code class="fe lv lw lx ly b">Encodable</code>和<code class="fe lv lw lx ly b">Decodable</code>功能。这使得JSON解析更加容易。它可以把自己转换成外部的表现。</p><p id="87ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可编码模型如下所示。这很容易理解，我们可以用很少的代码来管理它。</p><p id="8de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是示例可编码模型。你需要根据你的JSON响应制作自己的结构模型。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="2a6b" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">struct</strong> User: <strong class="ly iu">Codable</strong>{<br/>       var <strong class="ly iu">userId</strong>: Int<br/>       var <strong class="ly iu">id</strong>: Int<br/>       var <strong class="ly iu">title</strong>: String<br/>       var <strong class="ly iu">completed</strong>: Bool<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="719c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用JSONDecoder解析JSON</h1><p id="4d75" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">发出网络请求后，将web应用程序响应原始数据转换成您的阵列模型。</p><p id="0dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个过程，JSON网络请求的其余部分将是相同的。然而，我们需要为JSONDecoder处理网络响应数据。该协议不需要重大改变。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="32f0" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">do</strong> <strong class="ly iu">{</strong><br/>    //<em class="nx">here </em><strong class="ly iu"><em class="nx">dataResponse </em></strong><em class="nx">received from a network request<br/>    </em>let <strong class="ly iu">decoder</strong> = <strong class="ly iu">JSONDecoder</strong>()<br/>    let <strong class="ly iu">model</strong> = try <strong class="ly iu">decoder</strong>.decode([<strong class="ly iu">User</strong>].<strong class="ly iu">self</strong>, from:<br/>                 <strong class="ly iu">dataResponse</strong>) //Decode JSON Response Data <br/>    print(<strong class="ly iu">model</strong>)<br/><strong class="ly iu">}</strong> <strong class="ly iu">catch</strong> let <strong class="ly iu">parsingError</strong> <strong class="ly iu">{</strong><br/>    print("Error", <strong class="ly iu">parsingError</strong>)<br/><strong class="ly iu">}</strong></span></pre><p id="53d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了模型<code class="fe lv lw lx ly b">[User].self</code>,因为我们得到了数组格式的响应。如果您的响应将进入<code class="fe lv lw lx ly b">Dictionary</code>，那么网络请求的输出将如下所示:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="f5bc" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">{</strong><br/>    "userId": 1,<br/>    "id": 1,<br/>    "title": "delectus aut autem",<br/>    "completed": false<br/> <strong class="ly iu">}</strong></span></pre><p id="0ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">Dictionary</code>响应，我们需要将模型类设置为<code class="fe lv lw lx ly b">User.self</code>:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="7685" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">do</strong> <strong class="ly iu">{</strong><br/>    //<em class="nx">here </em><strong class="ly iu"><em class="nx">dataResponse </em></strong><em class="nx">received from a network request<br/>    </em>let <strong class="ly iu">decoder</strong> = <strong class="ly iu">JSONDecoder</strong>()<br/>    //Decode JSON Response Data<br/>    let <strong class="ly iu">model</strong> = try <strong class="ly iu">decoder</strong>.decode(<strong class="ly iu">User</strong>.<strong class="ly iu">self</strong>, <br/>                                   from: <strong class="ly iu">dataResponse</strong>) <br/>    print(<strong class="ly iu">model.userId</strong>) //<strong class="ly iu">Output</strong> - 1221<br/><strong class="ly iu">}</strong> <strong class="ly iu">catch</strong> let <strong class="ly iu">parsingError</strong> <strong class="ly iu">{</strong><br/>    print("Error", <strong class="ly iu">parsingError</strong>)<br/><strong class="ly iu">}</strong></span></pre><h2 id="9e5c" class="ns mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">自定义键名</h2><p id="bc36" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以用定制的字符串键来修改我们的可编码键，但是它们应该与您的JSON响应键相匹配。否则，您会得到一条错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/da959e101a63e858bb90e1607db87c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*a7CrBGrWlsEJnm1jj4BTzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">底部的错误消息</p></figure><p id="109f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何为<code class="fe lv lw lx ly b">Codable</code>型号添加自定义键:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="8e76" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">struct</strong> User: <strong class="ly iu">Codable</strong>{<br/>       var <strong class="ly iu">userId</strong>: Int<br/>       var <strong class="ly iu">id</strong>: Int<br/>       var <strong class="ly iu">title</strong>: String<br/>       var <strong class="ly iu">completed</strong>: Bool</span><span id="296a" class="ns mh it ly b gy ny nu l nv nw"><strong class="ly iu">//<em class="nx">Custom Keys</em> <br/>       enum</strong> CodingKeys: <strong class="ly iu">String</strong>, <strong class="ly iu">CodingKey</strong> {<br/>           case <strong class="ly iu">userId </strong><br/>           case <strong class="ly iu">id </strong>= "serviceId"  //Custom keys<br/>           case <strong class="ly iu">title </strong>= "titleKey" //Custom keys<br/>           case <strong class="ly iu">completed</strong><br/>       }<br/>}</span></pre><p id="4023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们让代码更加快捷友好。我在这里通过模型的扩展做了一个初始化的过程。<code class="fe lv lw lx ly b">CodingKeys</code> enum将使用<code class="fe lv lw lx ly b">CodingKey</code>协议进行确认。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="6aea" class="ns mh it ly b gy nt nu l nv nw"><strong class="ly iu">struct</strong> User: <strong class="ly iu">Codable </strong>{<br/>       var <strong class="ly iu">userId</strong>: Int<br/>       var <strong class="ly iu">id</strong>: Int<br/>       var <strong class="ly iu">title</strong>: String<br/>       var <strong class="ly iu">completed</strong>: Bool<br/>}</span><span id="3fcd" class="ns mh it ly b gy ny nu l nv nw"><strong class="ly iu">extension</strong> User{<br/>   <strong class="ly iu">enum</strong> CodingKeys: <strong class="ly iu">String</strong>, <strong class="ly iu">CodingKey</strong> {<br/>           case <strong class="ly iu">userId</strong><br/>           case <strong class="ly iu">id</strong><br/>           case <strong class="ly iu">title</strong><br/>           case <strong class="ly iu">completed</strong><br/>   }<br/>}</span></pre><h2 id="b0d7" class="ns mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">使用可编码协议进行复杂的JSON解析</h2><p id="7a79" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有一个复杂的JSON文件<strong class="lb iu">，</strong>，它有一个<code class="fe lv lw lx ly b">Dictionary</code>数组:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="c89c" class="ns mh it ly b gy nt nu l nv nw">{<br/>  "branch": {<br/>    "subject": 5,<br/>    "total_students": 110,<br/>    "total_books": 150<br/>  },<br/>  "Subject": [<br/>    {<br/>      "subject_id": 301,<br/>      "name": "EMT",<br/>      "pratical": false,<br/>      "pratical_days": <strong class="ly iu">[</strong><br/>        "Monday",<br/>        "Friday"<br/>      <strong class="ly iu">]<br/></strong>    },<br/>    {<br/>      "subject_id": 302,<br/>      "name": "Network Analysis",<br/>      "pratical": true,<br/>      "pratical_days": <strong class="ly iu">[</strong><br/>        "Tuesday",<br/>        "Thursday"<br/>      <strong class="ly iu">]</strong><br/>    }<br/>  ]<br/>}</span></pre><p id="1ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为JSON响应编写了如下的<code class="fe lv lw lx ly b">Struct</code>模型:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="880d" class="ns mh it ly b gy nt nu l nv nw">struct <strong class="ly iu">Students</strong> : Codable <strong class="ly iu">{</strong><br/>       struct <strong class="ly iu">Branch</strong> : Codable <strong class="ly iu">{</strong><br/>              let <strong class="ly iu">subject</strong>: Int<br/>              let <strong class="ly iu">totalStudents</strong>: Int<br/>              let <strong class="ly iu">totalBooks</strong>: Int<br/>           private enum <strong class="ly iu">CodingKeys</strong> : String, CodingKey <strong class="ly iu">{</strong><br/>              case <strong class="ly iu">subject</strong><br/>              case <strong class="ly iu">totalStudents</strong> = "total_students"<br/>              case <strong class="ly iu">totalBooks</strong> = "total_books"<br/>          <strong class="ly iu"> }</strong><br/>       <strong class="ly iu">}</strong><br/>     struct <strong class="ly iu">Subject</strong> : Codable <strong class="ly iu">{</strong><br/>             let <strong class="ly iu">subject_id</strong>: Int<br/>             let <strong class="ly iu">name</strong>: String<br/>             let <strong class="ly iu">pratical</strong>: Bool<br/>             let <strong class="ly iu">pratical_days</strong>: [<strong class="ly iu">String</strong>]<br/>      <strong class="ly iu">}</strong><br/>   let branch: <strong class="ly iu">Branch</strong><br/>   let subject: [<strong class="ly iu">Subject</strong>]<br/><strong class="ly iu">}</strong></span></pre><p id="ad85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想让上面的<code class="fe lv lw lx ly b">model</code>更复杂。为了便于理解，我把一切都简化了。</p><h2 id="1a61" class="ns mh it bd mi nz oa dn mm ob oc dp mq li od oe ms lm of og mu lq oh oi mw oj bi translated">解析来自JSON响应的数据</h2><p id="4450" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们这里的<code class="fe lv lw lx ly b">struct</code>型号是<code class="fe lv lw lx ly b">Student</code>。</p><p id="90c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是向web API发出网络请求后的样子。我们通过可编码模型直接处理网络响应数据。这里没有什么大的区别。</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="815f" class="ns mh it ly b gy nt nu l nv nw">do <strong class="ly iu">{<br/>   // <em class="nx">data</em> </strong><em class="nx">we are getting from network request</em><strong class="ly iu"><br/></strong>   let decoder = <strong class="ly iu">JSONDecoder</strong>()<br/>   let response = <strong class="ly iu">try</strong> decoder.<strong class="ly iu">decode</strong>(<strong class="ly iu">Students</strong>.self, from: <strong class="ly iu">data</strong>)<br/>   print(<strong class="ly iu">response.subject</strong>[<strong class="ly iu">0</strong>].<strong class="ly iu">name</strong>) //<strong class="ly iu">Output</strong> - EMT<br/><strong class="ly iu">} </strong>catch <strong class="ly iu">{</strong> print(error) <strong class="ly iu">}</strong></span></pre><p id="d46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们已经完成了JSON解析。对于在代码中处理任何网络响应数据或JSON对象数据来说，这是一个非常简单的过程。它将允许您基于响应数据来处理您的UI。我们需要根据需求从响应中映射所有需要的值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="20a2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="3219" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们现在理解了JSON解析——从web服务网络请求到基于响应的数据处理。</p><p id="f5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我介绍了如何为JSON响应创建模型，以便在您的iOS应用程序中正确管理JSON响应。</p><p id="d4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为使用普通模型<code class="fe lv lw lx ly b">Struct</code>和<code class="fe lv lw lx ly b">Codable</code>协议是管理任何JSON响应的最简单的方法。您可以根据自己的需求自行管理。可编码协议是基础库中的一个强大特性。</p><p id="b9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人建议您设置SDK，在Swift中提出网络请求。这将有助于在您的应用程序中启动一个令人敬畏的网络请求。</p><p id="ba27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<a class="ae ky" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank"> Alamofire </a>在您的应用程序中发出网络请求。这是一个非常有用的HTTP网络库，并且很容易使用。如果您想在项目中实现更高级的功能，这完全取决于您。</p><p id="5a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在<a class="ae ky" href="https://quicktype.io/" rel="noopener ugc nofollow" target="_blank"> quicktype </a>的帮助下轻松创建您的模型类。您将能够轻松地生成您的Swift代码。</p><p id="981a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个。感谢阅读！</p></div></div>    
</body>
</html>