<html>
<head>
<title>A Practical Guide to Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript高阶函数实用指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/higher-order-functions-in-javascript-4c9b40119ba6?source=collection_archive---------3-----------------------#2021-08-24">https://betterprogramming.pub/higher-order-functions-in-javascript-4c9b40119ba6?source=collection_archive---------3-----------------------#2021-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="332b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个骰子游戏理解JavaScript函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06df467668b183a375ff42f5c01a4f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*njHhQ7cqI1Ag8bwj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@introspectivedsgn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克·麦克莱恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9c71" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">何必呢？</h1><p id="c650" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一个伟大的“啊哈！”学习编码的时刻是循环结构的引入。它们给程序员提供了对代码块重复任意次数的控制，这种控制非常强大，一旦完全掌握，就很容易变得依赖。这可能是高阶函数看起来复杂的一个原因。事实上，它们并没有给程序员提供任何他们用一个简单的循环已经无法实现的东西，所以学习它们的动力充其量是微弱的。然而，代码的清晰性弥补了它们在附加功能上的不足。</p><blockquote class="mn mo mp"><p id="a266" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">“的确，花在阅读和写作上的时间比远远超过10比1。作为编写新代码工作的一部分，我们不断地阅读旧代码。…[因此，]让它易于阅读会让它更易于书写。”</p><p id="c0b2" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated"><em class="it"> ―罗伯特·c·马丁，干净的代码:敏捷软件工艺手册</em></p></blockquote><p id="d5ca" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如上所述，在编写代码时，对读者来说清晰是最重要的——即使读者很可能是你未来的自己。</p><p id="b743" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">当使用高阶函数而不是更“简单”的循环表亲时，读者真正获得了多少清晰度？这要由个人来决定，但希望在阅读完本指南后，你会觉得他们提高了代码的可读性，从而提高了代码的可维护性。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="d6e6" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">掷骰子</h1><p id="53d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们的实际例子，我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Yacht_(dice_game)" rel="noopener ugc nofollow" target="_blank">游艇</a>游戏，这是一个骰子游戏，后来成为更著名的Yahtzee的基础。在Yacht游戏中，一名玩家掷出5个骰子，并可以根据自己的选择保留任意多或少的骰子，同时最多再掷两次。第三次掷骰子的目的是在保留的骰子和刚刚掷出的骰子之间有一个点数组合。得分的方式有很多，但很大程度上它们类似于人们可能更熟悉的扑克手牌:满堂彩、四张同花顺、顺子等。“游艇”得分最高，即所有5个骰子显示相同的数字。</p><p id="78c4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">JavaScript的高阶函数的任务是帮助我们发现玩家有资格采用哪些得分组合(如果有的话)。</p><p id="4aee" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这5个骰子将被称为一个<code class="fe nl nm nn no b">hand</code>，并被编码为一个由<code class="fe nl nm nn no b">rollDice()</code>函数生成的数字数组(我们将在后面讨论)。</p><h2 id="d436" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">array . prototype . foreach()</a></h2><p id="e091" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们希望能够做的第一件事是将手中的每个骰子记录到控制台(或者理想情况下在窗口中以吸引人的方式呈现它们)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用熟悉的for循环，这可以很容易地实现。</p></figure><p id="5e5c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">对于这样一个简单的例子，作者的意图是显而易见的。然而，即使在如此简单的情况下，我们的第一个高阶函数也可以提高代码的清晰度。</p><p id="0c0f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这个函数的行为与上面的for循环非常相似。它遍历一个数组，并依次对每个元素应用一些代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面的for循环可以用forEach调用重写，如下所示。</p></figure><p id="c319" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这里forEach函数是针对我们的手数组调用的。然后通过名称<code class="fe nl nm nn no b">die</code>访问每个元素(尽管任何合法的变量名都可以)，然后为每个<code class="fe nl nm nn no b">die</code>执行<code class="fe nl nm nn no b">=&gt;</code>之后的代码。</p><p id="06ad" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这段代码的意图更加明确。它读起来几乎像一个英语句子。但也许你还没有被说服。</p><h2 id="d855" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> Array.prototype.map() </a></h2><p id="de66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然后让我们回到我们在上面使用的<code class="fe nl nm nn no b">rollDice()</code>函数，但是没有检查和看看它是如何编写的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">也许是这样的？</p></figure><p id="f3d1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这很有效，所以你可能会想就此打住。然而，那些看下面的人肯定会看到一个更优雅的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">优雅。</p></figure><p id="1625" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">创建一个我们需要的大小的数组，然后用值' null '填充它，即<code class="fe nl nm nn no b">const arr = [null, null, null, null, null]</code>，然后应用我们的映射函数。在这种情况下，它获取每个元素(这里没有命名，因为我们不使用它),然后在<code class="fe nl nm nn no b">=&gt;</code>返回一个新数组后将代码映射到它。</p><p id="5e2f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">旁注:我们不是先用<code class="fe nl nm nn no b">null</code>填充数组，然后简单地使用<code class="fe nl nm nn no b">fill</code>吗，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这可能不是你想要的。</p></figure><p id="8de3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们会返回相同随机数的5个副本。有时这可能是想要的行为。但是，对于任何可变的数据类型(即对象和数组)，都要特别小心，因为返回的数组将填充5个对同一对象或数组的引用。变异一个会产生变异另一个的效果。</p><h2 id="b9ec" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">array . prototype . filter()</a></h2><p id="5013" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们想象一下，现在我们有一个单独的数组，其中包含布尔值，指示我们的<code class="fe nl nm nn no b">hand</code>数组中的等效位置是否要保留用于下一次掷骰子，即<code class="fe nl nm nn no b">const retain = [false, true, false, false, true]</code>，我们需要编写一个函数来查看要保留哪些位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用for循环查看要保留哪些数字。</p></figure><p id="ce86" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这乍一看，并不清楚。当然，可以包含一些注释来说明发生了什么以及为什么会发生，但是，由于高阶函数可读性很强，所以对于简单的函数，我们几乎不需要它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">像我们希望写的任何评论一样清楚。</p></figure><p id="57ce" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们对我们的<code class="fe nl nm nn no b">hand</code>数组应用一个过滤器，它接受每个元素(按照惯例命名为<code class="fe nl nm nn no b">_</code>，因为我们不会使用它)及其索引，并返回一个元素数组，这些元素在<code class="fe nl nm nn no b">retain</code>中的等价索引是<code class="fe nl nm nn no b">true</code>。</p><p id="04aa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一旦你开始对高阶函数的语法越来越熟悉，它们就会变得清晰得多。</p><h2 id="b5ea" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> Array.prototype.reduce() </a></h2><p id="f61f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">《游艇》中的一个得分类别被命名为“选择”。为此，玩家得分等于所持骰子总数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对数组中的值求和对于可靠的for循环来说是小菜一碟。</p></figure><p id="27af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这很好，但是当一些更简单的东西要写(更重要的是要读)的时候，没有必要把它分成几行。)可以取代它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">易于阅读=易于维护</p></figure><p id="3a93" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这里要减少的第一个参数是累加器的(程序员选择的)名称，第二个参数是每个元素的(程序员选择的)名称。在<code class="fe nl nm nn no b">=&gt;</code>之后是一个表达式，当下一个元素被调用时(或者当操作最后一个元素时返回)，该表达式将计算出用于累加器的值。显然，可以执行比简单求和更复杂的运算，但是，即使在这种简单的情况下，这种高阶函数的效用也应该是清楚的。</p><h2 id="5252" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank">array . prototype . every()</a></h2><p id="2f92" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">游艇的最高得分类别被恰当地称为“游艇”,幸运的玩家可以获得高达50分的分数。每个骰子必须具有相同的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对于for循环来说微不足道。</p></figure><p id="2c7d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">对我来说，这读起来很糟糕。要返回50分，需要满足什么条件一目了然。</p><p id="f242" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">另一方面，对于高阶函数(双关语)，我们只需解析一个有点生硬的英语句子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加奖金<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>。</p></figure><p id="1d7f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">它不仅相当短，而且希望你开始同意它也更容易阅读。如果你在两周后回到这篇文章时已经忘记了如何给“游艇”打分，如果你和我一样的话，你会发现高阶函数比for循环提供的解释更简洁明了。</p><h2 id="1d58" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank"> Array.prototype.some() </a></h2><p id="cef9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个函数的行为与<code class="fe nl nm nn no b">Array.Prototype.every()</code>非常相似，唯一的区别是，如果有任何元素满足条件，它将返回<code class="fe nl nm nn no b">true</code>(如果没有元素满足条件，则返回<code class="fe nl nm nn no b">false</code>)。</p><p id="e40a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">对于我们的游艇示例，它没有明显的用例，但是希望通过理解<code class="fe nl nm nn no b">Array.Prototype.every()</code>函数，用法应该是清楚的。</p><h2 id="dd35" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noopener ugc nofollow" target="_blank">array . prototype . find()</a>T20<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank">array . prototype . find index()</a></h2><p id="24c6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="mq">我将这两个功能组合在一起，因为它们的操作相同；第一个提供值，第二个提供索引。</em></p><p id="5543" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这些函数将返回满足传递给它的函数的数组的第一个元素或第一个元素的索引。如果没有找到，那么<code class="fe nl nm nn no b">undefined</code>(在<code class="fe nl nm nn no b">find()</code>的情况下)或<code class="fe nl nm nn no b">-1</code>(在<code class="fe nl nm nn no b">findIndex()</code>的情况下)。</p><p id="7b81" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这些函数有助于根据设定的标准检查一个元素的存在，但不会给出满足它的元素的完整列表(为此，请使用<code class="fe nl nm nn no b">filter()</code>)。所以，事实上，我们在当前的程序中也没有这个函数的用例。不过，希望潜在的用例是显而易见的。任何时候你想用一个<code class="fe nl nm nn no b">break</code>来缩短一个循环，并在循环中使用这个迭代的值(或索引),都可以用这些函数中的一个来代替。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="09aa" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">从此一帆风顺</h1><p id="c22c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经探讨了这些功能，希望您能够在您可能参与的任何项目中找到它们的位置。相对于for循环所提供的内容，我认为您可以体会到语法的简单性。</p><p id="0dd3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">然而，高阶函数并非没有反对者。一个主要的批评，也是一个有效的批评，是它们在技术上不如for循环的等效物有效。上面给出的所有例子在语法更加冗长和不清楚的情况下会运行得更快。因此，在性能和可读性之间有一个折衷。我向您推荐的策略如下:尽可能使用高阶函数，只有当性能开始下降并且需要进行优化时，您才应该重构使用for循环。在项目的早期阶段，当您可能会多次浏览相同的区域时，这提供了可读性的所有好处。此外，如果编写了一套全面的测试，当任何函数被转换为for-loop语法时，测试应该会继续通过。</p><p id="e93c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后，我们浏览了高阶函数，以及它们如何应用于现实生活中的例子。对于任何跟随并对最终结果感兴趣的人来说，Yacht的一个可玩版本使用了上面描述的功能(稍微修改的版本),在这里可以得到。</p></div></div>    
</body>
</html>