<html>
<head>
<title>Knock as an Authentication Solution for Your Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Knock作为Rails API的认证解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/knock-as-an-authentication-solution-for-rails-api-acfaef5b25?source=collection_archive---------3-----------------------#2020-06-29">https://betterprogramming.pub/knock-as-an-authentication-solution-for-rails-api-acfaef5b25?source=collection_archive---------3-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Rails令牌认证实现指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45d5e3a57ec69e05a7cf497cdecced7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gL68xVKi7-KzZr6v"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克·科诺诺夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bef1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">背景</strong></h1><p id="1a19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我将向您介绍如何在您的Rails应用程序中安装和运行knock gem的详细步骤。本文的想法源于这样一个事实，即我找不到关于如何实现Rails API令牌认证的定义良好的最新资源。对于本教程，我将使用最新版本(6.0)的Ruby on Rails。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="aabd" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated"><strong class="ak">设置</strong></h1><p id="2e12" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，让我们生成一个新的Rails应用程序:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d19e" class="ne la it na b gy nf ng l nh ni">$ rails new JWTapp --api -d=postgresql -T<br/>$ cd JWTapp<br/>$ rails db:create<br/>$ rails db:migrate</span></pre><h2 id="452c" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak"> CORS </strong></h2><p id="8131" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们取消对Cors gem的注释，以允许访问API:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fa17" class="ne la it na b gy nf ng l nh ni">gem ‘rack-cors’<br/>$ bundle install</span></pre><p id="fb7e" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">在cors.rb中编写以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="48f8" class="ne la it na b gy nf ng l nh ni"># config/initializers/cors.rb<br/>Rails.application.config.middleware.insert_before 0, Rack::Cors do<br/> allow do<br/>    origins ‘<a class="ae ky" href="http://localhost:3000'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000'</a></span><span id="2113" class="ne la it na b gy nz ng l nh ni">    resource ‘*’,<br/>    headers: :any,<br/>    methods: [:get, :post, :put, :patch, :delete, :options, :head]<br/> end<br/>end</span></pre><h2 id="3c01" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak"> Bcrypt &amp;敲宝石</strong></h2><p id="c49d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Bcrypt是一种用于密码哈希和Knock的哈希算法，主要用于JWT认证。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4cd6" class="ne la it na b gy nf ng l nh ni">gem ‘bcrypt’<br/>gem ‘knock’</span></pre><p id="3b4a" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">我们跑吧:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fe50" class="ne la it na b gy nf ng l nh ni">$ bundle install</span></pre><h2 id="db70" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">用户模型和控制器</strong></h2><p id="12c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们将使用脚手架生成器创建一个用户。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="01f8" class="ne la it na b gy nf ng l nh ni">$ rails generate scaffold User username:string email:string password_digest:string</span></pre><p id="20f9" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">在你的用户模型中包括这一点。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dc9e" class="ne la it na b gy nf ng l nh ni"># app/models/user.rb </span><span id="dc34" class="ne la it na b gy nz ng l nh ni">class User &lt; ApplicationRecord<br/>   has_secure_password<br/>   validates :username, presence: true<br/>   VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i.freeze<br/>   validates :email, presence: true,uniqueness: true, format: { with: VALID_EMAIL_REGEX }<br/>end</span></pre><p id="bbbb" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">脚手架生成的用户控制器给了我们一个名为<em class="oa"> password_digest </em>的字段。但是Bcrypt除了哈希密码之外，还把<em class="oa"> password_digest </em>变成了两个字段，<em class="oa"> password </em>和<em class="oa"> password_confirmation </em>。所以我们需要将允许的参数从<em class="oa"> password_digest </em>改为这两个字段。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a897" class="ne la it na b gy nf ng l nh ni"># app/controllers/users_controller.rb</span><span id="e418" class="ne la it na b gy nz ng l nh ni"><br/>def user_params<br/> params.permit(:username, :email, :password, :password_confirmation)<br/>end</span></pre><p id="64f8" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">我们先去掉create方法中的'<strong class="lt iu"> <em class="oa">位置:@user' </em> </strong>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="733e" class="ne la it na b gy nf ng l nh ni"># app/controllers/users_controller.rb</span><span id="1bfe" class="ne la it na b gy nz ng l nh ni">def create<br/>   <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a> = User.new(user_params)</span><span id="b618" class="ne la it na b gy nz ng l nh ni">if <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a>.save<br/>     render json: <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a>, status: :created<br/>   else<br/>     render json: <a class="ae ky" href="http://twitter.com/user" rel="noopener ugc nofollow" target="_blank">@user</a>.errors, status: :unprocessable_entity<br/>   end<br/> end</span></pre><p id="c4a3" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">通过运行迁移数据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aad7" class="ne la it na b gy nf ng l nh ni">$ rails db:migrate</span></pre><p id="884c" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">让我们使用rails控制台创建一个用户。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4faa" class="ne la it na b gy nf ng l nh ni">$ rails c</span><span id="ac40" class="ne la it na b gy nz ng l nh ni">User.create(username: “Danny”, email: “<a class="ae ky" href="mailto:dan@ymail.com" rel="noopener ugc nofollow" target="_blank">dan@ymail.com</a>”, password: “enemona”, password_confirmation: “enemona”)</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a745" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated"><strong class="ak">爆震配置</strong></h1><p id="3156" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，让我们配置敲门宝石:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a589" class="ne la it na b gy nf ng l nh ni">$ rails g knock:install</span></pre><p id="28c5" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">这将在<em class="oa">config/initializer/knock . Rb</em>中创建一个包含默认配置的初始化文件。</p><p id="7810" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">您可能会收到这样的错误:<em class="oa">无法加载生成器“generators/knock/install _ generator”。</em>跳到下一步(默认敲门信号)。这是Rails 6自动加载器Zeitwerk造成的。我们可以通过切换自动装弹机来避免这个错误。点击阅读更多关于Zeitwerk <a class="ae ky" href="https://medium.com/cedarcode/understanding-zeitwerk-in-rails-6-f168a9f09a1f" rel="noopener">的信息。</a></p><p id="ddef" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">现在我们将退化敲门信号并再次生成它——一旦我们将下面的代码行包含到<em class="oa"> application.rb </em>中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="078f" class="ne la it na b gy nf ng l nh ni">$ rails d knock:install</span></pre><p id="8d1c" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">让我们将它包含在<em class="oa"> application.rb </em>文件中:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="88a2" class="ne la it na b gy nf ng l nh ni"># config/application.rb <br/>config.load_defaults 6.0 and config.autoloader = :classic</span><span id="f476" class="ne la it na b gy nz ng l nh ni">$ rails g knock:install</span></pre><p id="3b8a" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">默认情况下，敲门信号设置为24小时后过期。如果我们取消下面这行的注释，我们就可以调整它，并按照我们想要的方式调整它。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="11fb" class="ne la it na b gy nf ng l nh ni"># config/initializers/knock.rb <br/>config.token_lifetime = 1.day</span></pre><p id="0ebc" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">生成一个供用户登录的控制器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f117" class="ne la it na b gy nf ng l nh ni">$ rails generate knock:token_controller user</span></pre><p id="504d" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">这会生成一个名为<code class="fe ob oc od na b"><em class="oa">user_token_controller</em></code>的控制器。它从<code class="fe ob oc od na b"><em class="oa">Knock::AuthTokenController</em></code>继承而来，后者带有一个默认的创建动作，在登录时会创建一个JWT。</p><p id="4a18" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated"><strong class="lt iu">注意</strong> : <code class="fe ob oc od na b"><em class="oa">user_token_controller</em></code>是签到的意思，与<code class="fe ob oc od na b"><em class="oa">users_controller</em></code>不同。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2972" class="ne la it na b gy nf ng l nh ni"># app/controllers/user_token_controller.rb<br/>class UserTokenController &lt; Knock::AuthTokenController<br/>end</span></pre><p id="fcaa" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">生成器还在<code class="fe ob oc od na b">routes.rb</code>文件中插入一条路线，作为登录的API端点。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5e63" class="ne la it na b gy nf ng l nh ni"># app/config/routes.rb<br/>post ‘user_token’ =&gt; ‘user_token#create’</span></pre><p id="a595" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">现在让我们在你的<code class="fe ob oc od na b"><em class="oa">application_controller</em></code> <em class="oa"> </em>文件中插入<code class="fe ob oc od na b"><em class="oa">include Knock::Authenticable</em></code>模块。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="80e8" class="ne la it na b gy nf ng l nh ni"># app/controllers/application_controller.rb <br/>class ApplicationController &lt; ActionController::API<br/> include Knock::Authenticable<br/>end</span></pre><p id="e587" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">你就快到了，朋友。在过滤要保护的控制器之前添加一个<code class="fe ob oc od na b"><em class="oa">authenticate_user</em></code>。在这里，我打算首先将它添加到<code class="fe ob oc od na b"><em class="oa">users_controller</em></code> <em class="oa"> </em>中，并免除<code class="fe ob oc od na b"><em class="oa">create</em></code>方法，以便使用户能够注册。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f852" class="ne la it na b gy nf ng l nh ni"># app/controllers/users_controller.rb <br/>before_action :authenticate_user,except: [:create]</span></pre><p id="4758" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">如果您使用的是Rails 5.2或更高版本，您需要再执行两个步骤。</p><ul class=""><li id="2577" class="oe of it lt b lu nu lx nv ma og me oh mi oi mm oj ok ol om bi translated">首先，由于默认情况下<code class="fe ob oc od na b"><em class="oa">protect_from_forgery</em></code>包含在<code class="fe ob oc od na b"><em class="oa">ActionController::Base</em></code>中，现在您需要在我们为从前端登录而生成的敲门控制器中跳过它。因为我们将后端视为一个API，所以我们应该禁用标准的Rails真实性令牌。</li></ul><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c0fa" class="ne la it na b gy nf ng l nh ni"># app/controllers/user_token_controller.rb<br/>class UserTokenController &lt; Knock::AuthTokenController<br/> skip_before_action :verify_authenticity_token, raise: false<br/>end</span></pre><ul class=""><li id="50eb" class="oe of it lt b lu nu lx nv ma og me oh mi oi mm oj ok ol om bi translated">Rails不再使用<code class="fe ob oc od na b"><em class="oa">config/secrets.yml</em></code>来保存用于各种安全特性的<code class="fe ob oc od na b">secret_key_base</code>，包括使用Knock gem生成jwt。Rails现在使用一个名为<code class="fe ob oc od na b"><em class="oa">config/credentials.yml.enc</em></code>的编码文件。将下面一行添加到Knock配置文件中。</li></ul><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cf34" class="ne la it na b gy nf ng l nh ni"># config/initializers/knock.rb <br/>config.token_secret_signature_key = -&gt; { Rails.application.credentials.secret_key_base }</span></pre><h2 id="1a26" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">当前用户</strong></h2><p id="f403" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您也可以直接访问<code class="fe ob oc od na b"><em class="oa">current_user</em></code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cae1" class="ne la it na b gy nf ng l nh ni">def index<br/> if current_user<br/>  # do something<br/> else<br/>  # do something else<br/> end<br/>end</span></pre><h2 id="0d05" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">路线</strong></h2><p id="d277" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用范围添加API命名空间。这一次，让我们为所有API路由添加一个“auth/”范围。这会将“auth”添加到路径中，但不会添加到控制器或模型中。我把默认路线编辑到了<code class="fe ob oc od na b">`user_token controller`</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4d96" class="ne la it na b gy nf ng l nh ni"># config/routes.rb <br/>scope ‘/auth’ do<br/> post ‘/signin’, to: ‘user_token#create’<br/> post ‘/signup’, to: ‘users#create’<br/>end</span></pre><h2 id="279c" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">测试</strong></h2><p id="ab48" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，让我们用失眠来测试API。您也可以使用Postman或Curl命令行工具。</p><p id="0f2b" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">运行服务器。愿机会永远对你有利。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="311d" class="ne la it na b gy nf ng l nh ni">$ rails s</span></pre><p id="706a" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">登录详细信息应包含在<code class="fe ob oc od na b"><em class="oa">auth</em></code>中，因为它包含登录表单字段名称和值:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2508" class="ne la it na b gy nf ng l nh ni">{<br/> “auth”: {<br/> “email”: “<a class="ae ky" href="mailto:dan@ymail.com" rel="noopener ugc nofollow" target="_blank">dan@ymail.com</a>”,<br/> “password”: “enemona”<br/> }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6d92fe327c91e4e804ff42edcffdd06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLcfDJ4lxiulv3yX1o9fJw.png"/></div></div></figure><h2 id="d974" class="ne la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">奖金</strong></h2><p id="c2e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们通过注册端点创建一个用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d4b7888ccea652d4d6b2d9a92039164e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0hCed_zsPr7c_CxIZ3UzQ.png"/></div></div></figure><p id="ac77" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">请访问我的GitHub库获取源代码:</p><p id="298c" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">https://github.com/kobiyoyo/RailsJWTToken<a class="ae ky" href="https://github.com/kobiyoyo/RailsJWTToken" rel="noopener ugc nofollow" target="_blank"/></p><p id="d0d1" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">感谢您的阅读。有关本指南中实现的资源的更多信息，请参考<a class="ae ky" href="https://github.com/nsarno/knock" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>