<html>
<head>
<title>Setting Swift Free on the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在网络上释放Swift</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setting-swift-free-on-the-web-94e1f3f68d88?source=collection_archive---------19-----------------------#2019-10-14">https://betterprogramming.pub/setting-swift-free-on-the-web-94e1f3f68d88?source=collection_archive---------19-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8448" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用服务器端，让任何人都能从浏览器上享受Swift</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a987b289e878e04a83f5076a7a23d9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__Ce7VjKktvCaH3obf8jGA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="7b53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我参加2016年WWDC时，我记得我参加了名为“<a class="ae lu" href="https://developer.apple.com/videos/play/wwdc2016/415/" rel="noopener ugc nofollow" target="_blank">借助Swift开源软件</a> <em class="lv">走向服务器端”的会议</em>最初，我对苹果与IBM的新合作关系感到吃惊，然后，我对服务器端Swift的概念感到惊讶。当我回家做一些研究时，我发现很多开发人员都渴望它，甚至到了乞求苹果公司采纳有助于萌芽中的开源服务器框架的建议的程度。</p><p id="c93c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，服务器端Swift社区仍然充满热情。目前有多种框架，其中最流行的是<a class="ae lu" href="https://perfect.org/" rel="noopener ugc nofollow" target="_blank">完美</a>、<a class="ae lu" href="https://www.kitura.io/" rel="noopener ugc nofollow" target="_blank">基图拉</a>和<a class="ae lu" href="https://vapor.codes/" rel="noopener ugc nofollow" target="_blank">蒸汽</a>。可能最明显的目的是为用Swift编写的应用程序编写一个Swifty后端，特别是使用共享代码来节省时间，消除重写错误，并减少无关的数据处理。然而，也有一些开发者对Swift充满热情，他们在Swift中建立了完整的网站和API，而没有任何Swift客户端使用它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3b7b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">分享是关怀</h1><p id="36fc" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">最近，我正在为iOS (Swift)和Android (Kotlin)做一个移动项目。因为Swift和Kotlin实际上非常相似，所以它们允许两个版本之间的架构和设计非常相似。由于Swift版本总是略微领先，我发现了一个名为<a class="ae lu" href="https://github.com/angelolloqui/SwiftKotlin" rel="noopener ugc nofollow" target="_blank"> SwiftKotlin </a>的开源Mac应用程序，它被证明是一个非常有用的转换工具。</p><p id="7397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我玩得开心的时候，我的一些同事有点嫉妒——主要是因为我碰巧有一台可以运行该工具的Mac，而他们在Windows环境中却不能。我开始主动提出接更多的翻译工作，但这成了一个瓶颈。但愿Swift能够跨平台运行，而我的同事无需下载和安装任何工具集、语言或依赖项。</p><p id="f6bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我为服务器端Swift项目设计用例的方式。因为SwiftKotlin是开源的，所以转换框架很容易获得。然后，我的计划是写一个基本的网站，任何人都可以下载Swift代码，让它通过SwiftKotlin框架运行，并获得转换后的Kotlin代码。</p><p id="5804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:虽然这是一个特定的用例，但是这个概念适用于大多数框架/包/pods。如果您心中有一个，您仍然可以遵循这些说明，将我的例子换成您的用例。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2bc6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">建造我的蒸汽发动机</h1><p id="61d1" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">您将需要Xcode、终端和Vapor。就是这样！你可以从<a class="ae lu" href="https://github.com/dbolella/SwiftKotlinOnline" rel="noopener ugc nofollow" target="_blank">这个回购</a>中提取我的代码。</p><p id="6ff4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个项目，我决定使用Vapor，因为它是前面提到的三个项目中唯一一个我还没有尝试过的。最后，事情变得相当简单，我对结果非常满意。要进行设置，只需遵循<a class="ae lu" href="https://docs.vapor.codes/3.0/install/macos/" rel="noopener ugc nofollow" target="_blank">安装指南</a>。</p><p id="5436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从终端，我们将使用web模板启动一个新的Vapor项目。这样，我们的Windows同事可以简单地从他们选择的浏览器进行转换。为此，请运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="23ec" class="nf me it nb b gy ng nh l ni nj">vapor new SwiftKotlinOnline — template=web</span></pre><p id="6193" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将建立一个已经建立了叶框架的项目。Leaf是一种编写模板化网页的方式，也可以链接到Swift功能。我们稍后会深入探讨这一点。</p><p id="e8db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们想引入SwiftKotlin作为一个Swift包并转换(一个助手包)。打开新项目目录中的<code class="fe nk nl nm nb b">Package.swift</code>文件，并添加这些依赖项:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c3ce" class="nf me it nb b gy ng nh l ni nj">.package(url: “<a class="ae lu" href="https://github.com/yanagiba/swift-transform" rel="noopener ugc nofollow" target="_blank">https://github.com/yanagiba/swift-transform</a>", .exact(“0.18.10”)),<br/>.package(url:”<a class="ae lu" href="https://github.com/angelolloqui/SwiftKotlin.git" rel="noopener ugc nofollow" target="_blank">https://github.com/angelolloqui/SwiftKotlin.git</a>", .revision(“e993ad55276531e5f723b0ede47d0619ea734dcf”))</span></pre><p id="6bff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后将它们添加到我们的应用目标:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8c93" class="nf me it nb b gy ng nh l ni nj">.target(name: “App”, dependencies: [“Vapor”, “Leaf”, “SwiftKotlinFramework”, “swift-transform”]),</span></pre><p id="130c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了引入这些依赖项并创建我们的Xcode项目，我们现在可以运行<code class="fe nk nl nm nb b">vapor xcode</code>。完成后，系统会提示您输入<code class="fe nk nl nm nb b">y</code>自动打开Xcode。Xcode启动后，我们的项目启动了，点击Run以确保到目前为止一切正常。在控制台中，您最终会看到应用程序在<code class="fe nk nl nm nb b">localhost:8080</code>运行。将该链接复制并粘贴到浏览器中，并确保您看到它可以工作。如果是这样的话，我们就成功了！</p><h2 id="4348" class="nf me it bd mf nn no dn mj np nq dp mn lh nr ns mp ll nt nu mr lp nv nw mt nx bi translated">路线</h2><p id="706b" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">到此为止，我们可以快速检查一些东西。首先，看一下<code class="fe nk nl nm nb b">routes.swift</code>。这就是我们的服务器如何决定如何处理来自web的请求，并建立我们决定建立的任何连接。您将看到“welcome”被设置为默认<code class="fe nk nl nm nb b">get</code>路线。当我们准备好路线的时候，我们会回到这里。现在，让我们跳到<code class="fe nk nl nm nb b">welcome.leaf</code>来看看什么是树叶，我们需要渲染什么。</p><h2 id="2813" class="nf me it bd mf nn no dn mj np nq dp mn lh nr ns mp ll nt nu mr lp nv nw mt nx bi translated">离开</h2><p id="9d69" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">你会看到一些<code class="fe nk nl nm nb b">#</code>标记以及一些熟悉的<code class="fe nk nl nm nb b">&lt;div&gt;</code>和<code class="fe nk nl nm nb b">&lt;img&gt;</code>标签。在Lead中，<code class="fe nk nl nm nb b">#set</code>告诉Leaf对于某个变量(例如，title ),将在引用它们的地方插入以下内容。在底部，我们看到<code class="fe nk nl nm nb b">#embed</code>，它告诉Leaf这些值将被插入到指定的模板中(例如，base)。如果我们跳到<code class="fe nk nl nm nb b">base.leaf</code>，我们会看到一个更完整的HTML主体，但是在我们希望那些值被嵌入它的其他叶子插入的地方插入了<code class="fe nk nl nm nb b">#get</code>。这是对Leaf如何工作的高度概括，尽管我建议查看<a class="ae lu" href="https://docs.vapor.codes/3.0/leaf/overview/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="c72c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这是我们制作UI的方式，我们将在这里开始构建我们的站点。现在，我不是一个熟练的web UI开发人员，所以我们在这里只做两个简单的叶子。其中一个将有一个文本字段，将Swift代码放入其中，使用Javascript将其放入表单进行处理，然后发送到我们的服务器。另一片叶子将获取翻译结果，并使用<code class="fe nk nl nm nb b">&lt;pre&gt;</code>和<code class="fe nk nl nm nb b">&lt;code&gt;</code>标签简单地显示它们。两者都简单地嵌入<code class="fe nk nl nm nb b">base.leaf</code>来构建它们周围的HTML。</p><p id="b462" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要点如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="ab7f" class="nf me it bd mf nn no dn mj np nq dp mn lh nr ns mp ll nt nu mr lp nv nw mt nx bi translated">控制器</h2><p id="931f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">蒸汽的最后一个区域是蒸汽控制器。简而言之，它们允许我们对自定义Swift功能进行分组，并编写方法来处理请求和响应以及代码。</p><p id="f08d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我们来说，这也是我们通过在控制器中实现SwiftKotlin框架开始编码的地方。参考它在作者的应用程序实现中的使用方式，我们将从中提取基础知识来设置翻译。然后我们将编写一个方法，它接受Vapor <code class="fe nk nl nm nb b">Request</code>参数并返回一个<code class="fe nk nl nm nb b">Future&lt;View&gt;</code>。</p><p id="8921" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了继续，我在下面贴了我的代码的要点，这样我可以带我们浏览一下。您将看到<code class="fe nk nl nm nb b">store</code>接受请求，从中提取Swift代码，并处理请求过程中放入的一些字符串垃圾。然后，我们确保我们甚至有代码要处理。否则，设置一个默认值(实际上是为了测试)。然后，我们调用<code class="fe nk nl nm nb b">translate</code>(取自原始代码)并将结果存储在一个变量中。最后，我们从我们的<code class="fe nk nl nm nb b">routes.swift</code>文件中返回看起来像一行的东西。我们所说的是渲染<code class="fe nk nl nm nb b">transfer.leaf</code>(我们马上就要做)并把翻译作为一个名为<code class="fe nk nl nm nb b">output</code>的参数传递。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="559b" class="nf me it bd mf nn no dn mj np nq dp mn lh nr ns mp ll nt nu mr lp nv nw mt nx bi translated">所有的路都通向我们的路线</h2><p id="d018" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我们最后回到<code class="fe nk nl nm nb b">routes.swift</code>，在这里我们将配置我们的两个页面并使用我们的控制器。对于输入，我们可以简单地将第一个路径中的“欢迎”替换为“输入”，因为它只是一个<code class="fe nk nl nm nb b">GET</code>，我们希望它成为我们的默认页面。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9e30" class="nf me it nb b gy ng nh l ni nj">router.get { req <strong class="nb iu">in<br/>  return</strong> <strong class="nb iu">try</strong> req.view().render(“input”)<br/>}</span></pre><p id="9dc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后对于我们的翻译叶和控制器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7362" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let</strong> translateController = TranslateKotlinController()<br/>router.post(“translate”, use: translateController.store)</span></pre><p id="f8b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先设置我们的控制器的实例，然后告诉路由器，对于转换路由，<code class="fe nk nl nm nb b">use</code>我们的<code class="fe nk nl nm nb b">store</code>以请求作为参数运行。</p><h2 id="bf6e" class="nf me it bd mf nn no dn mj np nq dp mn lh nr ns mp ll nt nu mr lp nv nw mt nx bi translated">结果！</h2><p id="df67" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">现在我们再次点击Run，转到<code class="fe nk nl nm nb b">localhost:8080</code>，试一试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0d186ff583fe73abd36f3eb9ebbfab0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNJweI3mzkmPeQLsbX5NPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的两片叶子和我们转换后的Swift代码，现在在科特林！</p></figure><p id="aeb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，用户界面可以进行大规模的翻新，但重要的是(至少对我和我的团队来说)我们现在在浏览器上有了我们的功能！现在，我的同事可以高兴了，因为他们也可以简单有效地享受这样一个强大的Swift框架。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c4db" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">处处迅捷！</h1><p id="7b6d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">正如我前面提到的，这是一个非常具体的用例。无论如何，无论上下文如何，获取Swift包裹并将其包装到网上的概念是相同的。知道它是多么简单和容易理解，我希望它至少能吸引您考虑如何也能把swift的实施扩展到全世界！</p><p id="e5bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在GitHub上看到:<a class="ae lu" href="https://github.com/dbolella/SwiftKotlinOnline" rel="noopener ugc nofollow" target="_blank">https://github.com/dbolella/SwiftKotlinOnline</a></p></div></div>    
</body>
</html>