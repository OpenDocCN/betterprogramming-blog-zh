# 登录 Apple:面向 iOS 开发人员的 Node.js 后端实现

> 原文：<https://betterprogramming.pub/sign-in-with-apple-node-js-backend-implementation-for-ios-developers-25a54b79aa68>

## 将 Apple 的新登录功能添加到您的应用程序和服务器

![](img/540ce28fa9c7708e6d106bb5cf0faf73.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

iOS 13(最近的主要版本)最有趣的一个方面是，它给了我们一个工具来为我们的 iOS 应用程序创建我们自己的基于授权的后端服务器。当然，我们有“登录脸书、谷歌等”以前，但是对于一个独立项目来说，“登录苹果”更容易和更快地实现——无论是在客户端还是服务器端。

让我们以下面的场景为例(当然是基于我的经验):你是一个 iOS 开发人员，有一个以你自己的名字发布的小应用。您想添加一个依赖于服务器的特性，但是您要么还没有后端，要么只有一个简单的后端，没有用户管理系统。您的功能需要用户管理。您希望保留与应用程序用户相关的特定项目。您不希望创建一个基于用户/密码的系统，不希望管理 jwt，并且希望将 iOS 代码保持在最少。

这是没人谈论的。“登录 Apple”正是基于这一特定的使用案例而创建的。

首先，让我们弄清楚一些方面:在本文中，我们不会讨论 iOS 实现。这在无数的文章和教程中都有涉及。我花了不到八个小时的时间在 SwiftUI 应用中编写客户端代码。[Raywenderlich.com](https://www.raywenderlich.com/4875322-sign-in-with-apple-using-swiftui)应该提供你需要的一切。它也不包括部署 Node.js 后端。你可以在谷歌上找到很多教程。使用 Express 部署一个节点服务器只需 10 分钟。这里有一个例子。

我们将在您准备好 iOS 代码，并且 iOS APIs 为您提供了用户的电子邮件以及 Apple 的用户标识符和认证 JWT 之后继续。

让我们先创建一条新路线，`/authenticate`:

```
app.post('/authenticate', async (req, res) => {
   const { token, email, apple_id } = req.body;
});
```

稍后，我们将探讨为什么我们称之为`/authenticate`并且有一个单一的路线，而不是`/register`和`/login`。

我们已经从请求体中提取了`token`、`email`和`apple_id` 变量。

# 登录流程

我们要做的第一件事是查询我们的数据库，看我们是否有那个用户:

我们现在在数据库上调用`getUser`,回调要么传递给我们一个用户，要么传递给我们一个错误。错误完全出在 DB 通信中。我通过将它返回给客户机来处理它。客户端将显示一个弹出窗口给用户，他们可以截屏，并发送给我进行调试。这是我的选择。你想怎么处理都行。这并不意味着我们没有用户。意味着查询数据库失败。

你可以看到我只把`apple_id` 传递给了`fakeDB`而不是整个用户。这与“登录苹果*”的隐私功能之一有关*如果您已经编写了客户端实现，您应该已经看到并读到了这一点，即 [SiwA 仅在用户第一次使用您的应用时提供用户凭证](https://forums.developer.apple.com/thread/121496#379297)。

这非常重要，重要的原因是因为这一点，您需要编写一些特定的逻辑来使用户的凭证与服务器和客户端同步。这适用于电子邮件和姓名(如果您向 Apple 请求)。

如果我们有一个用户，我们跳到下一步。我们现在检查是否收到了包含我们请求的电子邮件:

```
if (**email** ...)
```

这又是 SiwA 的一个怪癖或边缘案例。请这样想:

1.  用户第一次使用你的 app。SiwA 为您提供用户的电子邮件。你坚持下去。
2.  用户卸载你的应用。
3.  用户再次安装您的应用程序，并再次登录 Apple。SiwA 不向您提供电子邮件。

如果您通过用户的`apple_id` 在数据库中找到了该用户，而这次您没有收到包含您的请求的电子邮件，那么您需要将当前电子邮件从您的数据库发送到客户端。

那个`if`中的下一个验证检查当前请求的电子邮件是否与我们存储在数据库中的相同:

```
if (... **email !== user.email**)
```

同样，边缘情况:

1.  用户第一次使用你的 app。SiwA 为您提供用户的真实邮箱。你坚持下去。
2.  用户进入 iCloud 并从登录中移除您的应用程序。
3.  用户打开您的应用程序，并决定再次登录。
4.  当 SiwA 提示用户时，他们选择隐藏他们的电子邮件。您现在收到的是 gibberish@appleservices.com，而不是之前收到的 first.lastname@gmail.com。

此时，你需要尊重用户的选择。他们决定隐藏他们的电子邮件。您现在需要在客户端和服务器端更新它。

如果验证失败:

```
if (email && email !== user.email)
```

我们需要在数据库中更新用户的电子邮件:

```
fakeDB.updateUser(req.body);
```

然后将用户作为响应发送回来:

这是登录流程。我们在数据库中有一个提供了苹果标识符的用户，如果需要，我们更新他们的个人信息，一旦完成，我们发送一个成功的响应。

# 注册流程

如果我们在数据库中没有找到用户，这意味着这是用户第一次登录我们的应用程序，因此我们需要处理令牌验证并在数据库中创建用户:

首先，我在一个不同的文件中创建了一个令牌服务。它的职责是验证在请求体中收到的 JWT 令牌。为此，我们将需要`jose`和`request` npm 模块:

```
npm -i jose
npm -i request
```

我不打算深入探究 JWT 验证是如何工作的，但是你可以在 Sarun 上找到一个很好的解释[。](https://sarunw.com/posts/sign-in-with-apple-3/)

我的验证服务实现如下:

如果验证失败，我们会将错误返回给用户(您希望如何处理这是您的选择)。

如果验证通过，我们现在可以使用指定的`apple_id` 和电子邮件将用户添加到我们的数据库中。

在成功地将他们添加到数据库中后，我们将用户发送回带有所提供的`apple_id` 和电子邮件的客户端。

就是这样！此时，您的用户身份验证已经实现。你的后端现在只需从你的 iOS 应用程序中给`/authenticate`打一个电话就可以登录或注册用户。

如果你有一些问题，我准备了一些在开发过程中困扰我的问题的答案。

## **我的授权和刷新令牌在哪里？**

好吧，如果你打算只支持 SiwA，他们是不需要的。苹果在 iOS 上提供了一个简单的 API，可以直接在应用中检查会话。根据[官方文件](https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/verifying_a_user):

> “验证身份令牌后，您的应用负责管理用户会话。您可以将会话的生存期与 Apple 设备上成功的 getCredentialState(for userid:completion:)调用联系起来。这是一个本地的、廉价的、非网络呼叫，由 Apple ID 系统启用，该系统将设备上的 Apple ID 状态与 Apple 服务器保持同步。
> 
> 每当请求新的身份令牌时，都需要用户交互。用户会话在设备上是长期存在的，因此在每次启动时调用新的身份令牌，或者一天调用一次以上，可能会导致您的请求由于限制而失败。
> 
> 如果用户的 Apple ID 在系统中发生了变化，调用 getCredentialState(for userid:completion:)表示用户发生了变化。假设不同的用户已经登录并注销应用程序当前已知的用户。
> 
> 对于在其他系统上运行的应用程序，使用刷新令牌的定期成功验证来确定用户会话的生存期。"

这意味着当你的应用程序完成启动时，你可以(也应该)使用`getCredentialState`来验证相同的用户登录到设备上，并且他们没有撤销你的应用程序的 SiwA。如果他们撤销了，您应该在设备上执行注销流程(比如从设备上删除保存的用户凭证和`apple_id`),并在需要时显示正确的 SiwA 屏幕。

## 为什么只调用一次/authenticate，而不是分别调用/login 和/register？

因为原则在这里不适用。和上面的答案一样，您可以使用本地的`getCredentialState` API 来验证当前用户，因此不需要对后端进行新的调用。这意味着您需要执行登录的唯一用例是用户在设备上手动注销之后。

当然，您可以创建`/login`和`/register`，并在后端的两个端点中将逻辑从`/authenticate`中分离出来，但是您会在客户端的两个方法中复制相同的代码——一个调用登录端点，另一个调用`register`。你还需要在客户端检查用户是否第一次登录苹果。我们在服务器端做过检查，记得吗？

## 为什么我必须将用户从服务器传递回客户端？

你不知道。我在应用程序的屏幕上显示用户的电子邮件。这就是我坚持的原因。如果用户退出，重新登录，并从 SiwA 中选择另一个电子邮件地址，我希望在屏幕上显示正确的地址(就像他们上次使用 SiwA 时一样)。如果您不需要电子邮件或用户的电子邮件，就没有必要将它们保存在客户端或后端。

也就是说，用从 JWT 令牌解码的邮件来验证来自请求主体的邮件是一个很好的实践，也更安全。因此，如果用户第一次登录，或者是在他们撤销你的应用程序后的后续登录，我的建议是将电子邮件发送到你的后端进行验证。

## 如何测试注册流程？

你需要撤销对你的应用程序的访问权限。

在您的 iOS 设备上，前往 iCloud >密码与安全> Apple ID 登录> *您的应用* >停止使用 Apple ID。

# 结论

正如你所看到的，苹果设置了一个系统，对于你想要一个没有密码或其他第三方认证提供者的简单登录系统的用例非常有益，我们应该使用它。在我看来，它打开了许多大门。

编码快乐！