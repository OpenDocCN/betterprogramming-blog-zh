<html>
<head>
<title>Write Your Own HTTP Server (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的HTTP服务器(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-your-own-http-server-implementing-wsgi-97706588ac20?source=collection_archive---------19-----------------------#2020-01-03">https://betterprogramming.pub/writing-your-own-http-server-implementing-wsgi-97706588ac20?source=collection_archive---------19-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0fb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使您的HTTP服务器符合WSGI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c335d158292e565d24fb698ebc3ec354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCjZINeOSTnzsuy8T23Zcw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊利亚·巴甫洛夫在<a class="ae ky" href="https://unsplash.com/s/photos/create?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="5556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这是“编写自己的HTTP服务器”系列的第三部分你可以在这里找到</em> <a class="ae ky" href="https://medium.com/@vaibhav_sinha/writing-your-own-http-server-introduction-b2f94581268b" rel="noopener"> <em class="lv"> Part 1 </em> </a> <em class="lv">和</em><a class="ae ky" href="https://medium.com/@vaibhav_sinha/writing-your-own-http-server-thread-based-implementation-40bce0142df9" rel="noopener"><em class="lv">Part 2</em></a><em class="lv">。</em></p><p id="4207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们已经构建了一个工作的HTTP服务器，它可以接受来自客户端的连接，解析请求，并发回一个伪响应。唯一剩下的事情是能够加载由我们的服务器的最终用户开发的应用程序，以便我们调用应用程序的请求处理程序并获得有用的响应。</p><p id="8968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载某人的应用程序应该没那么难。Python中有<code class="fe lw lx ly lz b">importlib</code>,它允许我们在运行时动态导入用户的应用程序。用户只需要告诉我们应用程序代码在磁盘上的什么地方。这可以使用配置文件来完成。更难的部分是知道如何与该应用程序通信，即调用哪个函数，使用什么参数，然后预期什么样的回复。这就是WSGI的用武之地。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="7995" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Web服务器网关接口</h1><p id="08e0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当我们开发web应用程序时，我们希望能够将它们部署在我们选择的任何服务器上。稍后我们可能会决定选择一个完全不同的web服务器。这样做不应该要求我们对应用程序进行任何更改。我们的应用程序应该不知道哪个服务器将用来托管它。只有当所有服务器决定以相同的方式与应用程序通信时，这才是可能的。这就是Web服务器网关接口(WSGI)试图实现的目标。</p><p id="4972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WSGI定义了任何web服务器将如何调用应用程序，它将发送什么参数，以及它期望什么结果。<a class="ae ky" href="https://www.python.org/dev/peps/pep-3333/" rel="noopener ugc nofollow" target="_blank"> PEP 3333 </a>，WSGI的规范，详细描述了它，以及实现的代码样本。我们将简要讨论该规范，感兴趣的读者可以阅读PEP中的所有细节。</p><p id="f1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WSGI要求导入的应用程序对象是可调用的。因此它可以是一个函数，一个方法，或者一个定义了<code class="fe lw lx ly lz b">__call__</code>方法的类或对象。每次有请求进来，服务器都会调用这个可调用的。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="2f45" class="ni mi it lz b gy nj nk l nl nm">result = application(environ, start_response)</span></pre><p id="d4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调用它的时候，它会传入两个参数:</p><ul class=""><li id="a7bf" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">环境:</strong>这是一个字典，包含描述HTTP请求的CGI风格的环境变量。这本字典的一些关键字是<code class="fe lw lx ly lz b">REQUEST_METHOD</code>、<code class="fe lw lx ly lz b">SCRIPT_NAME</code>、<code class="fe lw lx ly lz b">PATH_INFO</code>、<code class="fe lw lx ly lz b">QUERY_STRING</code>、<code class="fe lw lx ly lz b">CONTENT_TYPE</code>和<code class="fe lw lx ly lz b">CONTENT_LENGTH</code>、<em class="lv">。</em>这就是被解析的HTTP请求被发送到应用程序的方式。还会有特定于WSGI的键，比如<code class="fe lw lx ly lz b">wsgi.version</code>、<code class="fe lw lx ly lz b"> wsgi.url_scheme</code>、<code class="fe lw lx ly lz b">wsgi.inpu</code> t、<code class="fe lw lx ly lz b">wsgi.multithread</code>等<em class="lv"> c. </em>这些额外的元数据是为了让应用程序知道它将如何被调用。例如，如果<code class="fe lw lx ly lz b">wsgi.multithread</code>设置为<em class="lv">真</em>，那么应用程序将同时被多个线程调用，因此需要是线程安全的。</li><li id="e6dc" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><strong class="lb iu">回调函数:</strong>提供的第二个参数是callable。一旦应用程序想要开始发送响应，就必须调用它。应用程序发送给它的第一个参数是HTTP响应状态代码，比如<em class="lv"> 200 OK。第二个参数是发送回客户端的响应头的字典。第三个参数与错误处理有关，我们不会在这里讨论。</em></li></ul><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="803a" class="ni mi it lz b gy nj nk l nl nm">start_response(status, response_headers, exc_info=None)</span></pre><p id="4f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为调用的结果，应用程序必须返回字节字符串的iterable。这将是发送回客户端的响应正文。服务器需要遍历返回的iterable并将字节串发送到套接字。当迭代完成时，响应结束，服务器可以关闭到客户端的连接。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f048" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">履行</h1><p id="f67a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们已经了解了需要实现的接口，让我们开始吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将请求委托给WSGI类的工作器</p></figure><p id="85c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经更改了worker，使其具有我们接下来要创建的类WSGI的实例。这个类将实现WSGI接口，并根据提供的配置加载用户的应用程序。当一个新的请求到达时，服务器将解析它，然后将它委托给这个类。WSGI类负责将它委托给加载的应用程序。让我们看看WSGI类的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WSGI实现</p></figure><p id="a346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到，WSGI类使用配置文件中提供的细节，使用<code class="fe lw lx ly lz b">importlib</code>来导入应用程序。要加载应用程序，我们需要知道三件事:模块在磁盘上的路径、模块的名称和模块中应用程序的名称。使用这些，WSGI类首先从给定的路径加载模块，然后从模块中提取应用程序。当请求到达时，这个类的process方法被解析的请求和一个callable调用，通过它可以将任何数据发送到客户端。在流程方法中，我们根据WSGI规范创建参数，然后用这些参数调用加载的应用程序。</p><p id="13d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦应用程序返回，我们已经知道要响应的HTTP状态代码和要发送的所有响应头。我们首先发送它们，然后遍历应用程序返回的结果，并将所有这些作为响应体发送。</p><p id="9355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个端到端的流程，请求到达服务器，传递给应用程序，然后应用程序产生的结果作为响应发送回来。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="57eb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">最后的边疆</h1><p id="4037" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在服务器做好了，我们写一个可以使用这个服务器的应用程序怎么样？但是等等，这意味着应用程序必须处理所有这些WSGI的东西。在我们的日常工作中，这不是应用程序开发人员要处理的事情。那谁知道呢？网络框架。</p><p id="51f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续编写应用程序之前，我们为什么不先编写一个简单的web框架。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="74b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们称我们的框架为PyDev。PyDev的工作方式很像Django。它要求您有一个设置模块，该模块的路径在一个环境变量中设置。框架动态加载模块。这个模块定义了建立框架所需的所有东西。</p><p id="4239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这个模块给我们的唯一东西是一个URL到函数映射的字典，这样当请求进入一个特定的URL时，框架知道调用应用程序的哪个函数。该框架还定义了自己的请求和响应类，因此应用程序不需要处理服务器基于WSGI规范提供的环境字典。</p><p id="fad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该框架有一个WSGIHandler，它实际上是服务器将调用的应用程序。然后，它的<code class="fe lw lx ly lz b">__call__</code>方法会根据请求路径将请求代理给适当的应用程序函数。它理解WSGI接口，并相应地与服务器通信，从而从应用程序开发人员那里抽象出整个过程。</p><p id="9a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用这个框架构建的应用程序。</p><p id="91bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序将有三个文件:一个对应于视图(即响应被请求的URL而调用的函数)，一个用于PyDev框架所需的设置，另一个是传递给服务器的应用程序模块。</p><h2 id="3cee" class="ni mi it bd mj od oe dn mn of og dp mr li oh oi mt lm oj ok mv lq ol om mx on bi translated">风景</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的视图功能</p></figure><p id="b5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只有一个查看功能，用于应用程序的健康检查。接下来，我们希望将这个函数绑定到一个特定的URL。这将发生在设置文件中。</p><h2 id="4d40" class="ni mi it bd mj od oe dn mn of og dp mr li oh oi mt lm oj ok mv lq ol om mx on bi translated">设置</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置了URL_CONF的设置文件</p></figure><p id="0936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将<code class="fe lw lx ly lz b">both /</code>和<code class="fe lw lx ly lz b">/health</code>映射到同一个视图。您可以想象一个应用程序有许多逻辑非常复杂的视图函数。对于框架来说，唯一重要的是URL和相应的视图函数。</p><h2 id="65b2" class="ni mi it bd mj od oe dn mn of og dp mr li oh oi mt lm oj ok mv lq ol om mx on bi translated">WSGI应用模块</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WSGI应用程序模块</p></figure><p id="3a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个模块中，我们将<code class="fe lw lx ly lz b">PYDEV_SETTINGS_MODULE</code>环境变量设置为指向应用程序中的正确模块。然后我们通过调用PyDev框架的<code class="fe lw lx ly lz b">get_wsgi_application</code>函数创建一个名为<code class="fe lw lx ly lz b">application</code>的属性。该函数返回WSGIHandler类的一个实例。这个<code class="fe lw lx ly lz b">application</code>对象将被服务器用来与我们的应用程序交互。在Django中，这个文件是在运行<code class="fe lw lx ly lz b">startapp</code>时自动生成的。</p><p id="6557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的配置文件在服务器上部署这个应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经创建了一个实现WSGI规范的HTTP服务器，并开发了一个框架，可用于构建部署在该服务器上的应用程序。就这样，真的。服务器和框架就是这么写的。如果你去看看<a class="ae ky" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>的源代码，你会发现很多类似的代码。类似地，<a class="ae ky" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>也有一些类似的代码。</p><p id="a612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为应该可以部署我们在Gunicorn上构建的这个应用程序。类似地，应该可以在我们的服务器上部署Django应用程序。由于我们没有完全实现WSGI规范，所以这里或那里可能会有一些问题。但是这应该让您对如何通过定义和实现标准接口来实现互操作有了足够好的了解。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="fca5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">收场白</h1><p id="2f86" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们已经从零开始成功地构建了一个Python web服务器。如果你看看其他的网络服务器，不管它们是用哪种语言编写的，它们都以同样的方式工作。它们都公开了一些相同的配置参数。因此，现在可以回到这些著名服务器的文档中，真正理解不同配置的含义，然后决定哪种配置最适合我们的应用。</p></div></div>    
</body>
</html>