# 算法:找到第一个副本

> 原文：<https://betterprogramming.pub/algorithms-find-the-first-duplicate-eb7ab30d7da8>

## 在 Python 列表中搜索第一个重复值

![](img/33dd86379cf65f19a0276f6e3ebb9197.png)

钱德勒·希尔肯在 [Unsplash](https://unsplash.com/s/photos/double?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

# 挑战

编写一个函数来查找值列表中的第一个重复项。这些值可以是介于 1 和列表长度之间的整数。如果没有找到重复值，则返回-1。

以下是一些有效和无效的示例列表，并附有解释。

```
[1,2,3] # valid, no duplicate
[1,2,3,3,2,1] # valid, 3 is the first duplicate
[0,1,2] # invalid, 0 is less than 1
[1,2,4] # invalid, 4 is greater than the list's length
```

让我们看看第二个例子，它有一个重复的值。第一个重复值不是恰好有重复值的第一个值(即 1)，而是与列表中的前一个值重复的第一个值(即 3)。

既然我们理解了挑战，我鼓励你自己去尝试。

如果您已经尝试过，或者您想跳过前面的步骤，那么让我们来看看解决方案吧！

# 亚军

该算法利用了集合——一种只包含唯一值的可变数据类型。

解决方案的前提是遍历列表，向集合中添加新值。在添加每个值之前，我们检查当前值是否存在于集合中。如果它确实存在，那么它是第一个副本，将被返回。

关于上述解决方案的几点注意事项:

*   空集不能用花括号定义。Python 会将其解释为空字典。
*   这个算法也适用于字符串和其他可迭代对象。
*   虽然该解决方案的时间复杂度为 *O(n)* ，这对于该挑战是线性的和最优的，但是该算法占用了额外的存储器来创建集合。

# 最优解

挑战的最佳算法利用了列表中的值必须在 1 和列表长度之间的规定。这很重要，因为通过将列表中的任何值移位-1，我们可以保证移位后的值是有效的索引。

该算法的基础在于利用每个值作为列表中的索引，并标记值以表示它们已经被访问过。我们将把这个值转换成负值，这样就保留了它的原始值。

我们第一次遇到负值时，我们知道它以前被访问过，因此是我们的第一个副本。

关于上述解决方案的几点注意事项:

*   我们将值移动-1，因为索引是从零开始的，等于列表长度的值会超出界限。
*   由于绝对值先前已被标记，因此将返回该值。
*   这种解决方案具有相同的时间复杂度 *O(n)，*，但是不占用使用 set 会占用的额外空间。

# 结论

我第一次尝试这个挑战时，我使用了一个`for`循环来跟踪当前值，一个嵌套的`for`循环来查找重复项，一个变量来跟踪重复项的最低索引。成功了吗？是的。它有效率吗？号码

你过得怎么样？你最初的解决方案是什么？下面分享一下你的经历吧！

特别感谢[尼克·怀特](https://www.youtube.com/watch?v=XSdr_O-XVRQ)对这个算法的解释！