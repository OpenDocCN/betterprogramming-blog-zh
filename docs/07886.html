<html>
<head>
<title>A Look Into Automatic Reference Counting in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的自动引用计数研究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-into-automatic-reference-counting-b17e9539d34f?source=collection_archive---------4-----------------------#2021-03-02">https://betterprogramming.pub/a-look-into-automatic-reference-counting-b17e9539d34f?source=collection_archive---------4-----------------------#2021-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="481c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高效管理应用的内存使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33243f745e50f433d9e8d9e7e89cbfcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MurKdiBYOpqLkrx5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tomstanislavsky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托马什·斯坦尼斯拉夫斯克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b9cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自动引用计数(ARC)是一种内存管理解决方案，它确保为您创建的不同对象和函数正确分配和释放内存，以便运行代码的设备不会耗尽内存。</p><p id="e2ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解ARC，让我们通过理解我们作为程序员所做的事情来给这个讨论一个框架。</p><p id="fcea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在编写代码时定义变量和函数。这些变量和函数需要存储在设备的内存中，以便我们可以使用它们，一旦我们不再需要它们，它们就会从内存中删除，或者换句话说，它们需要有一个生命周期。当我们希望它们存在时，它们就会存在。然后，它们执行自己的任务，当不再被使用时就死去，这样它们占用的内存就可以被释放出来，让新的变量和函数出现。</p><p id="d4e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创作部分很简单。你通常<code class="fe ls lt lu lv b">init</code>这些函数和变量，但是你怎么决定它们应该什么时候死呢？</p><p id="ae85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种方法可以指定这些变量和函数应该何时终止:</p><ol class=""><li id="9814" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">作为一名程序员，你说他们什么时候到了生命的尽头，什么时候需要死去。</li></ol><p id="1145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.你让某人为你管理它。</p><p id="1545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是使用一个叫做<em class="mf">引用计数</em>的进程完成的，第二个叫做<em class="mf">垃圾收集。</em></p><p id="9523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将重点关注本文中的第一个问题。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b116" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">什么是引用计数？</h1><p id="979e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">引用计数是维护对特定实例的强引用计数的过程(稍后将详细介绍，但现在只需记住它们是强引用)。</p><p id="51ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，无论何时创建一个实例，都会得到一个引用计数为1的实例，这基本上意味着指向该实例的变量在说，“嘿！我是这个实例的所有者，在我不再允许它被释放之前，它需要保持活动状态”</p><p id="efbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以当你开始让不同的强变量指向它时，它的引用计数就增加1。当引用被设置为<code class="fe ls lt lu lv b">nil</code>时，该引用类型的实例的引用计数减1。</p><p id="7508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>一旦引用计数变为0，就调用该特定实例的<code class="fe ls lt lu lv b">deinit</code>。</p><p id="f993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">CFGetRetainCount</code>功能检查变量的引用计数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="45f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>引用计数只是为了管理引用类型(如类和闭包)的内存。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="58cb" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">背景:手工-保留-发布管理</h1><p id="e632" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在上一节中，我们了解到有一个计数是根据对特定实例的引用数量来维护的。</p><p id="27ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，第一个观察是，在我们的日常生活中，无论何时我们创建一个实例(即，在它的<code class="fe ls lt lu lv b">init</code>中)或当它被设置为<code class="fe ls lt lu lv b">nil</code>时减少它，我们都不会编写代码来增加任何计数。因此，我们应该得出结论，系统必须为我们管理所有这一切。</p><p id="06b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然所有这些现在都过时了，但它会帮助你理解为什么事情会这样。你不必完全记住下面的部分，但一定要浏览一下。</p><p id="e055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，让我们回到我们的问题:这是如何发生的？</p><p id="b42e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要回答这个问题，我们需要回到Objective-C是iOS/macOS代码库的唯一编程语言的时候。在ARC之前，曾经有一个叫<em class="mf">手动引用计数的东西，</em>程序员要自己写“<em class="mf">引用计数</em>”递增/递减代码。</p><p id="36e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们使用以下命令实现了这一点:</p><ul class=""><li id="f301" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nm mc md me bi translated"><code class="fe ls lt lu lv b">alloc init</code>、<code class="fe ls lt lu lv b">new</code>、<code class="fe ls lt lu lv b">copy</code>:创建一个引用计数为1的新对象</li><li id="4626" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated"><code class="fe ls lt lu lv b">retain</code>:引用计数加1，返回对象本身</li><li id="a7e0" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated"><code class="fe ls lt lu lv b">release</code>:将引用计数减1并返回nil</li><li id="4657" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated"><code class="fe ls lt lu lv b">autorelease</code>:当该实例的池将被清空时，将该实例标记为自动释放</li></ul><p id="20b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在手动引用计数管理世界中，作为一名程序员，你有责任确保在你创建的每个类中实现了一个<code class="fe ls lt lu lv b">dealloc</code>方法(对于所有Swift开发人员，想象一下为你创建的每个类编写一个<code class="fe ls lt lu lv b">deinit</code>函数)。</p><p id="f02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您必须确保您在该类的每个实例变量上调用了<code class="fe ls lt lu lv b">release</code>，以确保那些变量的引用计数被减少——否则，那些变量占用的内存将永远不会被释放，并且您会以僵尸对象结束(也称为<em class="mf">内存泄漏</em>)。</p><p id="9ef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还必须处理其他样板代码。例如:</p><ul class=""><li id="5e2d" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nm mc md me bi translated">您必须为每个必须更改的变量实现setters。在setter中，您必须<code class="fe ls lt lu lv b">release</code>先前的值并设置这个新变量。</li><li id="6c0e" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated">如果一个特定的变量要在函数本身的范围内使用，那么你必须在函数结束之前<code class="fe ls lt lu lv b">release</code>它——否则，就会有内存泄漏(除非变量被标记为<code class="fe ls lt lu lv b">autorelease</code>，并且你的方法在一个<code class="fe ls lt lu lv b">autoreleasepool</code>内)。</li></ul><blockquote class="ns nt nu"><p id="58e9" class="kw kx mf ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">为了确保事情顺利运行，程序员必须遵守一套规则，以确保你的代码在内存方面是高性能的。</p></blockquote></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2a40" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">手工发放保留管理规则</h1><h2 id="1ed7" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated">你拥有你创造的对象</h2><p id="9dfa" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如果您在任何类或实例上调用<code class="fe ls lt lu lv b">alloc init</code>、<code class="fe ls lt lu lv b">new</code>或<code class="fe ls lt lu lv b">copy</code>，您将获得一个引用计数为1的新实例，现在您拥有该特定实例的所有权。</p><p id="2762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，这是Obj-C世界中使用的惯例——即使你创建了一个<code class="fe ls lt lu lv b">init</code>函数，你也必须确保该特定类实例中的所有变量都被正确地<code class="fe ls lt lu lv b">init</code>或<code class="fe ls lt lu lv b">retain</code>处理。</p><p id="13e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你必须假设任何不遵守这个命名约定的函数都应该是一个<code class="fe ls lt lu lv b">autorelease</code>对象；否则，它可以随时<code class="fe ls lt lu lv b">release</code>它，这可能是不安全的。</p><p id="df7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果你把它放在一个<code class="fe ls lt lu lv b">autoreleasepool</code>中是可以的，或者如果你想在任何地方使用它，你可以使用下面提到的规则2来获得它的所有权，这样即使原始类在对象上调用<code class="fe ls lt lu lv b">release</code>，你也可以继续安全地使用它。</p><h2 id="d72b" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">你可以通过使用</strong> <code class="fe ls lt lu lv b"><strong class="ak">'retain'</strong></code>获得对象的所有权</h2><p id="49a8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">假设您想在<code class="fe ls lt lu lv b">ClassB</code>的实例中使用一个类<code class="fe ls lt lu lv b">ClassA</code>中的变量。理想情况下，您可以对变量调用<code class="fe ls lt lu lv b">retain</code>来获得该对象的所有权。</p><h2 id="d8bd" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">你必须拥有</strong> <code class="fe ls lt lu lv b"><strong class="ak">release'</strong></code> <strong class="ak">对象</strong></h2><p id="e243" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">你应该只在两种类型的对象上调用<code class="fe ls lt lu lv b">release</code>。</p><ul class=""><li id="17a6" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nm mc md me bi translated">您已经使用<code class="fe ls lt lu lv b">alloc init</code>、<code class="fe ls lt lu lv b">copy</code>或<code class="fe ls lt lu lv b">new</code>创建了一个实例</li><li id="6ddd" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated">你实际上已经在一个特定的引用上调用了<code class="fe ls lt lu lv b">retain</code></li></ul><h2 id="45ae" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">你不应该在你不拥有的对象上调用'</strong> <code class="fe ls lt lu lv b"><strong class="ak">release’</strong></code> <strong class="ak"/></h2><p id="3a3d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这种情况基本上是说，你不应该对从不以<code class="fe ls lt lu lv b">alloc init</code>、<code class="fe ls lt lu lv b">copy</code>或<code class="fe ls lt lu lv b">new</code>开头的函数中检索到的对象调用<code class="fe ls lt lu lv b">release</code>(也就是说，这些函数完全遵循规则1中前面提到的约定)，唯一的原因是你不拥有它们。如果你想管理他们的所有权，你必须给他们打电话<code class="fe ls lt lu lv b">retain</code>。</p><p id="8a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里还要注意的一点是，如果你正在编写一个返回一个对象的函数，而不想转移该对象的所有权，你需要<code class="fe ls lt lu lv b">alloc init</code>该对象并将其标记为<code class="fe ls lt lu lv b">autorelease.</code></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="44c9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">自动释放和<code class="fe ls lt lu lv b">@autoreleasepool</code></h1><p id="c3fc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">正如我前面提到的，在进行手动-保留-释放管理时，有一些惯例需要遵循，比如确保在对象上调用<code class="fe ls lt lu lv b">release</code>或者<code class="fe ls lt lu lv b">alloc init</code>或者<code class="fe ls lt lu lv b">retain</code>。或者通过确保您从不以<code class="fe ls lt lu lv b">alloc init</code>开头的方法返回的计算对象，等等。是自动释放的，并且您不会对它们调用<code class="fe ls lt lu lv b">retain</code>,因为调用者不会是返回实例的所有者。</p><p id="532e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong><code class="fe ls lt lu lv b">autorelease</code>的基本定义是，你正在标记一个你正在创建但不会释放的对象(这违背了我们最初的规则)。你是在把责任或者把那个对象交给别人。</p><p id="031f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">@autoreleasepool</code>是一个块，它在完成时将<code class="fe ls lt lu lv b">release</code>所有创建时带有<code class="fe ls lt lu lv b">autorelease</code>的对象。不会释放在池外创建的自动释放对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="63aa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">人工保留-释放管理的缺点</h1><p id="12be" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">从上面的解释中可以看出，以这种方式编写的代码充满了程序员必须记住的约定，如果他们忘记了不正确地使用<code class="fe ls lt lu lv b">retain</code>、<code class="fe ls lt lu lv b">release</code>或<code class="fe ls lt lu lv b">autorelease</code>对象，他们会有两种结局:</p><ol class=""><li id="6988" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">内存泄漏——当你调用了<code class="fe ls lt lu lv b">retain</code>或者创建了一个对象却忘了调用<code class="fe ls lt lu lv b">release</code>时就会发生这种情况。它们会一直存在，直到你真正关闭应用程序。</li><li id="f343" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr mb mc md me bi translated">悬空指针——如果你拥有不属于你的对象，你最终会创建悬空指针，当被其他真正的所有者访问时，会导致访问失败— <code class="fe ls lt lu lv b">EXC_BAD_ACCESS</code>。</li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b79a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">自动引用计数</h1><p id="16a1" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">因此，我们现在知道，整个计数递增/递减过程是一个手动过程，如果管理不当，会在内存方面产生严重后果，尽管您可能已经注意到，所有这些都是在每个程序员都必须遵守的一组规则内完成的。</p><p id="d187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在一个晴朗的日子里，我们决定将编写<code class="fe ls lt lu lv b">retain</code>、<code class="fe ls lt lu lv b">release</code>和<code class="fe ls lt lu lv b">autorelease</code>的过程自动化，并在代码编译期间完成。</p><p id="5354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在编译期间</strong>，编译器会根据几个“关键字”在适当的地方进行这些调用，这些关键字会标识如何引用该引用类型。</p><blockquote class="ns nt nu"><p id="a497" class="kw kx mf ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">因此，如果有人问你ARC是运行时进程还是编译时进程，你应该明确地回答它是两者的混合。引用计数“关键字”是在编译时放入的，但实际的计数和内存分配/取消分配是在运行时进行的</p></blockquote></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="0eab" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">参考类型</h1><p id="ce5a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">用最基本的术语来说，引用类型(例如类和闭包)告诉编译器需要如何管理变量的引用计数。Swift中有三种参考类型:</p><ol class=""><li id="fdcd" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">strong</code>:每当一个新的引用指向它时，引用计数就加1——例如，当你添加一个新的变量指向一个引用时，编译器就添加一个<code class="fe ls lt lu lv b">retain</code>调用</li><li id="1020" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr mb mc md me bi translated"><code class="fe ls lt lu lv b">weak</code>:不增加参考计数</li><li id="40f7" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr mb mc md me bi translated"><code class="fe ls lt lu lv b">unowned</code>:不增加参考计数</li></ol><p id="7ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当您用这些标识符指定变量时，编译器在将代码实际编译成机器码之前，会在代码中放入所需的<code class="fe ls lt lu lv b">retain</code>和<code class="fe ls lt lu lv b">release</code>调用。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="293c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><code class="fe ls lt lu lv b">'strong'</code></h1><p id="9161" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">关键字<code class="fe ls lt lu lv b">strong</code>声明每当一个强变量引用一个引用类型，该实例的引用计数就增加1。</p><blockquote class="ns nt nu"><p id="4e4b" class="kw kx mf ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">当没有指定任何内容时，这是任何变量的默认引用类型。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="eb69" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">参考周期</h1><p id="1380" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当两个强变量指向对方时，就会出现参考循环。这会导致这两个变量的实例保持活动状态，即使它们在理想情况下不应该保持活动状态。让我们举个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="edf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，你可以看到在第20行之后，<code class="fe ls lt lu lv b">a</code>和<code class="fe ls lt lu lv b">b</code>都应该被取消分配，因为我们已经使它们都成为了<code class="fe ls lt lu lv b">nil</code>，但是彼此之间的内部引用创建了一个引用循环，禁止系统调用它们的<code class="fe ls lt lu lv b">deinit</code>方法，因此造成了内存泄漏。</p><p id="7112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有时对象的引用计数永远不会达到零；在启用ARC的项目中，唯一可能发生这种情况的情况是存在引用周期。</p><p id="33c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经展示了一种解决引用循环的方法(第21-24行)。解决引用循环的另一种方法是确保你可以引用一个变量而不增加它的引用计数，这就引出了我们的其他关键词:<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unowned</code>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e250" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><code class="fe ls lt lu lv b">'weak’</code>和<code class="fe ls lt lu lv b">'unonwned'</code></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cbc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将其中一个变量设为<code class="fe ls lt lu lv b">weak</code>(或<code class="fe ls lt lu lv b">unowned</code>)变量可以解决参考循环问题。</p><p id="3816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unowned</code>都没有增加它们所指向的对象的引用计数，所以问题自然出现了:为什么我需要两个关键字？</p><p id="2f38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unowned</code>有一个微妙的区别，即<code class="fe ls lt lu lv b">weak</code>变量用于指向在持有对象/原始引用的生命周期内不需要可用的对象，而<code class="fe ls lt lu lv b">unowned</code>变量用于指向在持有对象/原始引用的整个生命周期内必须可用的变量。</p><p id="ba6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong><code class="fe ls lt lu lv b">weak</code>变量总是可选的，而<code class="fe ls lt lu lv b">unowned</code>变量可以是可选的(+隐式展开可选)或者非可选的。</p><p id="44ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就实现而言，这意味着当一个<code class="fe ls lt lu lv b">weak</code>变量的引用变成<code class="fe ls lt lu lv b">nil</code>时，<code class="fe ls lt lu lv b">weak</code>变量本身也变为零。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而在<code class="fe ls lt lu lv b">unowned</code>的情况下，如果引用变成<code class="fe ls lt lu lv b">nil</code>，那么<code class="fe ls lt lu lv b">unowned</code>变量仍然可用，但是指向一个<code class="fe ls lt lu lv b">nil</code>内存地址，这可能会导致崩溃或不可预测的行为等问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fcbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">unowned</code>有两种口味:</p><ol class=""><li id="4aef" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">unonwed(safe)</code>:当你试图使用引用一个已释放变量的<code class="fe ls lt lu lv b">unonwed</code>变量时，这确实会使程序崩溃</li><li id="968b" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr mb mc md me bi translated"><code class="fe ls lt lu lv b">unonwed(unsafe)</code>:当引用一个取消分配的变量时，这不会可靠地使应用崩溃，并且可能导致不可预知的行为。我认为这种情况仍然存在于Swift中的原因可能是因为LLVM中仍然存在<code class="fe ls lt lu lv b">__unsafe_unretained</code>所有权。这基本上意味着你需要手动管理这些变量的内存，因为它们不是由编译器管理的。</li></ol><p id="0506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在这里澄清几个问题，让我们更好地理解<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unowned</code>:</p><h2 id="a071" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak"/><code class="fe ls lt lu lv b"><strong class="ak">'weak'</strong></code><strong class="ak">和</strong> <code class="fe ls lt lu lv b"><strong class="ak">'unowned'</strong></code> <strong class="ak">选装件有什么区别？</strong></h2><p id="bcde" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">答案并不简单。可选性基本上意味着变量可以是<code class="fe ls lt lu lv b">nil</code>。但是在<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unowned</code>可选变量的情况下，有一个微妙的区别，如下面的代码片段所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="788a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果变量<code class="fe ls lt lu lv b">b</code>是<code class="fe ls lt lu lv b">weak</code>而不是<code class="fe ls lt lu lv b">unowned</code>，那么任何一个<code class="fe ls lt lu lv b">print</code>语句都不会崩溃。</p><p id="7705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给我们带来了一个解释，即<code class="fe ls lt lu lv b">weak</code>选项可以是<code class="fe ls lt lu lv b">nil</code>，访问它们不会引起任何问题。另一方面，<code class="fe ls lt lu lv b">unowned</code> optionals也可以是<code class="fe ls lt lu lv b">nil</code>，但是不能指向变成<code class="fe ls lt lu lv b">nil</code>的引用。</p><h2 id="e901" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">你什么时候会用</strong> <code class="fe ls lt lu lv b"><strong class="ak">'unowned'</strong></code> <strong class="ak">胜过</strong> <code class="fe ls lt lu lv b"><strong class="ak">weak’</strong></code> <strong class="ak">？</strong></h2><ul class=""><li id="ac12" class="lw lx iq ky b kz nf lc ng lf ok lj ol ln om lr nm mc md me bi translated">当你希望一个变量不是可选的，但又不想要一个<code class="fe ls lt lu lv b">retain</code>循环时</li><li id="1253" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated">您希望确保持有者和被持有者的寿命相互匹配。例如:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c4e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们将<code class="fe ls lt lu lv b">person</code>设为变量<code class="fe ls lt lu lv b">unonwed</code>，因为<code class="fe ls lt lu lv b">ID</code>需要与<code class="fe ls lt lu lv b">Person</code>一起存在。如果一个<code class="fe ls lt lu lv b">Person</code>实例存在，那么它的<code class="fe ls lt lu lv b">ID</code>一定存在，但是当<code class="fe ls lt lu lv b">Person</code>实例被解除分配后，对应于那个<code class="fe ls lt lu lv b">Person</code>的<code class="fe ls lt lu lv b">ID</code>也应该不存在了。</p><p id="ca4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果当<code class="fe ls lt lu lv b">Person</code>对象被释放时，你试图访问<code class="fe ls lt lu lv b">ID</code>的<code class="fe ls lt lu lv b">Person</code>，你的程序会崩溃。您可以在开发阶段推断出这种情况正在发生，并且需要修复。</p><h2 id="8507" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">你什么时候会使用可选的</strong> <code class="fe ls lt lu lv b"><strong class="ak">'unowned’ </strong></code> <strong class="ak">变量？</strong></h2><p id="15ae" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当您想要避免<code class="fe ls lt lu lv b">retain</code>循环，并且想要确保当它所指向的引用被移除时，变量被正确地设置为<code class="fe ls lt lu lv b">nil</code>，以便两个实例的生命周期相互匹配。</p><h2 id="c574" class="ny mo iq bd mp nz oa dn mt ob oc dp mx lf od oe mz lj of og nb ln oh oi nd oj bi translated"><strong class="ak">一个隐式展开的</strong> <code class="fe ls lt lu lv b"><strong class="ak">'weak'</strong></code> <strong class="ak">可选变量和一个可选的</strong> <code class="fe ls lt lu lv b"><strong class="ak">'unowned'</strong></code> <strong class="ak">变量有什么区别，如果两个变量都为‘nil’时会崩溃？</strong></h2><p id="fcef" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这里又有一个微妙的区别。非可选的在被访问时总是会崩溃，但是可选的<code class="fe ls lt lu lv b">unowned</code>只有当它的引用变成<code class="fe ls lt lu lv b">nil</code>时才会崩溃，而不是当它本身被设置为<code class="fe ls lt lu lv b">nil</code>时。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="246f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">闭包中的参考循环</h1><p id="3cd5" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Swift中的闭包也是引用类型。因此，您在一个闭包内使用的任何引用类型变量都被那个特定的闭包强引用，如果那些变量也引用这个闭包，这可能会导致一个引用循环。</p><p id="b43e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">避免闭包中引用循环的答案是一个捕获列表。在这些捕获列表中，您指定将要使用的变量为<code class="fe ls lt lu lv b">strong</code>、<code class="fe ls lt lu lv b">weak</code>或<code class="fe ls lt lu lv b">unowned</code>，这样编译器就可以正确地管理它们。</p><p id="7c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用引用类型的相同规则也适用于这里。理想情况下，你应该尽量避免<code class="fe ls lt lu lv b">strong</code>，因为那会产生一个参考循环。基于被引用变量的生命周期，你应该使用<code class="fe ls lt lu lv b">weak</code>或<code class="fe ls lt lu lv b">unowned</code>。捕获列表示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有另一个例子来更好地理解它。如果需要，将这段代码复制并粘贴到操场上，并应用断点来运行代码以更好地理解它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e71b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里值得一提的是，捕获列表对于值类型的作用略有不同(尽管本文主要是关于引用类型)。</p><p id="e244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在闭包中捕获一个值类型，就会创建该变量的新副本，对原始值的任何更改都不会反映在这个新副本中。但是如果您没有捕获原始变量，但仍然在闭包中使用它(即，没有在捕获列表中指定它)，那么编译器实际上会持有对它的引用。对原始值的任何更改也会反映在闭包内的变量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="6e4c" class="mn mo iq bd mp mq on ms mt mu oo mw mx jw op jx mz jz oq ka nb kc or kd nd ne bi translated">你如何识别参考周期？</h1><p id="6d9b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">假设我们现在知道了引用循环以及它们如何影响每个值类型和引用类型，那么当我们查看一些代码时，我们必须知道如何找出引用循环。</p><p id="dfa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个技巧——虽然令人困惑——实际上非常简单。绘制链接！</p><p id="4fc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试几个例子来更好地理解它:</p><ol class=""><li id="645c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">简单的参考循环</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.让我们看一个包含闭包的引用类型的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d83e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.值类型中的引用循环🤔</p><p id="beae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多信息<a class="ae kv" href="https://neelbakshi.medium.com/classes-vs-structs-basics-and-memory-management-4707714d82e7" rel="noopener">请阅读此处</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b1b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.一个更真实的例子——实际上没有<strong class="ky ir">参考循环！</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="03ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上述所有例子中，解决引用循环的答案是，如果变量是引用类型，就将它们捕获为<code class="fe ls lt lu lv b">weak</code>或<code class="fe ls lt lu lv b">unonwed</code>，如果它们是值类型，就捕获变量本身。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="681d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使用<code class="fe ls lt lu lv b">'weak’ </code>和<code class="fe ls lt lu lv b">'unowned'</code>的性能影响</h1><p id="39e0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">除了仅仅是语义上的原因之外，是否还有其他原因可以解释为什么应该使用其中一个而不是另一个？当您知道<code class="fe ls lt lu lv b">unowned</code>变量的生命周期≤原始参考的生命周期时，使用<code class="fe ls lt lu lv b">unowned</code>会带来一些微妙的性能优势。原因是管理<code class="fe ls lt lu lv b">weak</code>引用的方式。</p><p id="7dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">weak</code>引用实际上是一个叫做<strong class="ky ir"> <em class="mf">归零弱引用</em> </strong> <em class="mf">的东西。</em>这意味着运行时使用一个表跟踪你对一个引用(原始引用)的所有弱引用。当原始引用变成<code class="fe ls lt lu lv b">nil</code>时，所有这些其他的<code class="fe ls lt lu lv b">weak</code>引用就在取消分配它之前变成<code class="fe ls lt lu lv b">nil</code>。这样，当你试图调用一次<code class="fe ls lt lu lv b">weak </code>引用上的东西时，原始引用将被设置为<code class="fe ls lt lu lv b">nil</code>。它将是安全的，并且根据它是否是可选的来表现。</p><p id="ef52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">unowned</code>的情况下，不需要做这种事情。对于<code class="fe ls lt lu lv b">unowned(safe)</code>，可能需要一个检查来确保它引发异常，但是对于<code class="fe ls lt lu lv b">unowned(unsafe)</code>，不需要这种检查，因为它的行为是不可预测的。</p><p id="0ba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以看到，正确使用<code class="fe ls lt lu lv b">weak</code>和<code class="fe ls lt lu lv b">unonwed</code>可能会带来某种性能影响。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="72c8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">来源</h1><ul class=""><li id="62c9" class="lw lx iq ky b kz nf lc ng lf ok lj ol ln om lr nm mc md me bi translated"><a class="ae kv" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH" rel="noopener ugc nofollow" target="_blank">内存管理规则</a></li><li id="9398" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated"><a class="ae kv" href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html#semantics" rel="noopener ugc nofollow" target="_blank">铿锵电弧文件</a></li><li id="8d66" class="lw lx iq ky b kz nn lc no lf np lj nq ln nr lr nm mc md me bi translated"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">迅捷的弧线</a></li></ul></div></div>    
</body>
</html>