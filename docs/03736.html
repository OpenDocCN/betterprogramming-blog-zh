<html>
<head>
<title>React Hooks Slider: How to Build an Image Slider With Smooth Transitions and Automatic Resizing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks Slider:如何构建一个具有平滑过渡和自动调整大小的图像滑块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-hooks-slider-how-to-build-an-image-slider-with-smooth-transitions-automatic-resizing-8a99859ac471?source=collection_archive---------5-----------------------#2020-03-02">https://betterprogramming.pub/react-hooks-slider-how-to-build-an-image-slider-with-smooth-transitions-automatic-resizing-8a99859ac471?source=collection_archive---------5-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc23" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第三部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95ae4d94d1c82987ced1cb2437cb792b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puTQH_5ai4IXCcZJis-Ldw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="9905" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React Hooks滑块系列的第三部分中，我们将解决它的最后两个缺点:</p><ul class=""><li id="6d68" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">当从最后一张幻灯片转到第一张幻灯片时，以及当从第一张幻灯片转到最后一张幻灯片时，消除了在中间幻灯片之间循环的必要性</li><li id="435a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">不适应浏览器大小调整</li></ul><p id="8167" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在本文末尾提供了本系列第一部分和第二部分的链接、包含代码和工作示例的资源库以及视频教程。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="be4d" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">快速回顾</h1><p id="b719" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在第2部分的结尾，这是我们在<code class="fe nj nk nl nm b">Slider</code>组件中结束的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="36d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">利用<code class="fe nj nk nl nm b">useRef</code>和<code class="fe nj nk nl nm b">useEffect</code>钩子创建自动播放功能非常简单。为了解决我上面列出的问题，我们将使用完全相同的方法。</p><p id="7a7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们进入任何代码之前，我们需要先从概念上解决问题。让我们从如何渲染幻灯片开始吧。</p><p id="a68f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便告诉你，我决定把我们的<code class="fe nj nk nl nm b">activeIndex</code> <em class="np"> </em>变量的名字改成<code class="fe nj nk nl nm b">activeSlide</code>。我觉得更有道理。如果你是从零开始编写代码，确保重命名<code class="fe nj nk nl nm b">Dots</code>组件上的prop。从现在开始，任何代码片段都将使用新的变量名。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="7071" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">一次只能呈现三张幻灯片</h1><p id="4f10" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">现在，我们的滑块不是很有效，并把每张幻灯片都呈现到DOM中。我认为这违背了React方式，而且在此基础上，需要在我们的<code class="fe nj nk nl nm b">nextSlide</code>和<code class="fe nj nk nl nm b">prevSlide</code> <em class="np"> </em>函数中编写一些令人困惑的逻辑。</p><p id="5304" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了方便起见，我们将一次呈现三张幻灯片。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1e99" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">创建一个数组来存储三张幻灯片</h1><p id="4620" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">为了做到这一点，我们将从props中取出整个幻灯片数组，并设置一个名为<code class="fe nj nk nl nm b">_slides</code>的内部状态变量，以包含初始渲染时的第一张幻灯片、第二张幻灯片和最后一张幻灯片。</p><p id="4f3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，我们不会按这个顺序存储它们。相反，我们将按照以下顺序存储它们:</p><p id="b2c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nj nk nl nm b">[Last Slide, First Slide, Second Slide]</code></p><p id="1634" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，浏览器中当前显示的幻灯片将始终是我们在阵列中间看到的幻灯片。如果这让你感到困惑，请允许我解释。</p><p id="f685" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了获得良好的来回切换效果，我们需要在浏览器中当前活动幻灯片的左侧和右侧各有一张幻灯片。因此，由三张幻灯片组成的数组(幻灯片存储在中间，作为显示的幻灯片)是有意义的。</p><p id="ea19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们还没有完成。我们需要将初始翻译值设置为浏览器的当前宽度，而不是像现在这样设置为0。这确保了我们在阵列的中间显示幻灯片。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="856c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">更新阵列以包含正确的幻灯片</h1><p id="3b91" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">当我们向右或向左移动时，幻灯片的排列需要改变。我们可以创建一个函数来处理这个问题，但是在此之前，让我们思考一下这个函数到底需要做什么。</p><p id="4174" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想出了三种可能的情况，一旦滑块被使用，我们不再处于原始的初始渲染状态，我们需要考虑这三种情况。</p><ol class=""><li id="7c41" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nq lx ly lz bi translated">正在播放第一张幻灯片吗？</li><li id="0efe" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nq lx ly lz bi translated">正在播放最后一张幻灯片吗？</li><li id="c354" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nq lx ly lz bi translated">上面的幻灯片都没有显示吗？</li></ol><p id="1783" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">如果第一张幻灯片正在显示</strong>，更新数组以反映我们在初始渲染时设置的内容:</p><p id="92cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nj nk nl nm b">[Last Slide, First Slide, Second Slide]</code></p><p id="25e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">如果正在显示最后一张幻灯片</strong>，将数组设置为:</p><p id="5d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nj nk nl nm b">[Second To Last Slide, Last Slide, First Slide]</code></p><p id="5b9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">如果正在显示的幻灯片既不是第一张也不是最后一张</strong>，则将数组设置为:</p><p id="e9f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nj nk nl nm b">[Previous Active Slide, Active Slide, Active Slide + 1]</code></p><p id="4e68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">处理所有这三种情况应该会涵盖我们。但是，我也想清楚地表明，每当我们更新这个数组时，我们并不引用当前在<code class="fe nj nk nl nm b">_slides</code>中的任何值来更新它:我们总是使用props中的数组来这样做。</p><p id="056a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经对如何完成这一部分有了一个很好的想法，让我们在下一节实现这个函数</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="a7f8" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">处理和禁用过渡</h1><p id="5311" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">为了在幻灯片之间有一个很好的平滑过渡，我们需要确保在每张幻灯片过渡到视图之前，我们不会更新<code class="fe nj nk nl nm b">_slides</code>数组。幸运的是，我们可以设置一个侦听器，每当它检测到转换完全完成时，就会触发我们的函数。</p><p id="455b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用<code class="fe nj nk nl nm b"><a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/transitionend_event" rel="noopener ugc nofollow" target="_blank">transitionend</a></code>事件。要做到这一点，我们可以创建一个ref，就像我们对autoplay特性所做的那样。让我们创建这个ref并添加事件监听器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9d3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将看到我们将转换引用设置为一个名为<code class="fe nj nk nl nm b">smoothTransition</code>函数。因为我们已经触及了我们的函数所涵盖的所有场景，这应该是有意义的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中一个棘手的部分是，当我们更新数组时，我们需要暂时消除过渡效果。如果我们不这样做，我们会得到一个奇怪的效果，当前幻灯片过渡到当前幻灯片。</p><p id="f598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们正在更新数组，并在每次单击鼠标左键或右键时重置平移，所以我们不想得到我上面描述的效果。因此，我们可以通过在更新阶段将其值设置为0来禁用转换，然后立即重置。</p><p id="2f76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以在更新后通过创建一个简单的<code class="fe nj nk nl nm b">useEffect</code>调用来重置translate，该调用可以观察转换变量是否在重新渲染时发生变化。如果转换是0，在我们更新了<code class="fe nj nk nl nm b">smoothTransition</code>中的<code class="fe nj nk nl nm b">_slides</code>数组之后，它将是0，只需将它设置回它的初始值。</p><pre class="kg kh ki kj gt ns nm nt nu aw nv bi"><span id="e416" class="nw mn iq nm b gy nx ny l nz oa">useEffect(() =&gt; { <br/>  if (transition === 0) setState({ …state, transition: 0.45 }) <br/>}, [transition])</span></pre><p id="5876" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看更新后的<code class="fe nj nk nl nm b">Slider</code> <em class="np"> </em>组件的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1437" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这些，我们就完成了过渡功能，可以进入最后一部分，处理浏览器的大小调整。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="2369" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">处理浏览器大小调整</h1><p id="4d24" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">这比你想象的要简单得多。我们只需要为<code class="fe nj nk nl nm b"><a class="ae nr" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event" rel="noopener ugc nofollow" target="_blank">resize</a></code>事件设置一个监听器，并编写一个小函数，在resize事件结束时设置适当的translate值。为此，我们将创建另一个引用，并添加到一些现有的代码中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="88c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们在这里也将过渡设置为0。这是必要的，因为每次调整浏览器大小时，当前显示的幻灯片将需要适应并转换到适当的位置。如果有一个过渡集…你现在应该知道了。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="0a33" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">啊哦…我们的滑块里有一个Bug</h1><p id="bb94" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">我们的调整大小功能非常棒！但是等等——当我们悬停在箭头上时，我们不是使用了过渡效果吗？这将导致一个非常有趣的副作用，如果我们悬停在箭头上(我们甚至不需要点击箭头)，我们将触发更新我们的<code class="fe nj nk nl nm b">_slides</code>数组的函数。恐怖啊！</p><p id="9126" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">别担心，我的朋友们。我们可以在我们的<code class="fe nj nk nl nm b">useEffect</code> <em class="np"> </em>调用中用一些简单的条件逻辑和对我们的<code class="fe nj nk nl nm b">SliderContent</code>组件的一些快速重构来解决这个问题。每当<code class="fe nj nk nl nm b">transitionend</code>事件触发我们的<code class="fe nj nk nl nm b">smoothTransition</code>函数时，我们将检查触发它的元素是否是<code class="fe nj nk nl nm b">SliderContent</code> <em class="np"> </em>组件。</p><p id="0189" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面我包含了对我们的<code class="fe nj nk nl nm b">SliderContent</code>组件的重构。请注意它与我们之前的版本有什么不同。我这样做是因为情绪是如何在引擎盖下运作的。如果您不使用库的styled <em class="np"> </em>部分，而是自己创建一个div，它会自动将一个带有您的组件名称的类添加到幕后的div<em class="np">。</em>这使得检查触发<code class="fe nj nk nl nm b">transitionend</code>事件的元素是否是<code class="fe nj nk nl nm b">SliderContent</code> <em class="np">变得容易。</em></p><p id="e602" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你自己编码，不使用情感，只要确保给你的<code class="fe nj nk nl nm b">SliderContent</code>组件添加一个<code class="fe nj nk nl nm b">SliderContent</code>的<code class="fe nj nk nl nm b">className</code>即可。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="14d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">准备好之后，让我们检查滑块的最终代码。检查一下我们谈到的条件语句的<code class="fe nj nk nl nm b">useEffect</code>调用中的<code class="fe nj nk nl nm b">smooth</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="7bce" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">React Hooks图像滑块摘要</h1><p id="9a26" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">我们走吧，伙计们。我们已经到达了图像滑块旅程的终点，并将在不久的将来开始一些同样有趣的事情。</p><p id="d898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很想听听你对下一步想看什么的建议。</p><p id="acca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="3bd9" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">链接</h1><p id="df89" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">第一部分。<a class="ae nr" href="https://medium.com/better-programming/build-an-image-slider-with-react-es6-264368de68e4" rel="noopener"> React挂钩滑块:如何用React挂钩构建图像滑块</a></p><p id="1703" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二部分。<a class="ae nr" href="https://medium.com/p/c94deaf763c4/edit" rel="noopener"> React Hooks Slider:如何用Autoplay构建图像滑块</a></p><p id="052b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nr" href="https://github.com/DZuz14/react-hooks-image-slider" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob no l"/></div></figure></div></div>    
</body>
</html>