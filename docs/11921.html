<html>
<head>
<title>Flow Navigation With SwiftUI 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI 3进行流程导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flow-navigation-with-swiftui-revisited-791f89421923?source=collection_archive---------4-----------------------#2022-04-27">https://betterprogramming.pub/flow-navigation-with-swiftui-revisited-791f89421923?source=collection_archive---------4-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe46" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在你的代码库中有效地实现屏幕流导航</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0f5d0a35e8589b7cb4fd5740fe6d13a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xIEdjuneEuX2bC6x6koyw.jpeg"/></div></div></figure><p id="0819" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">【<em class="ln">swift ui 4和NavigationStack实现注意事项参见</em> <a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/flow-navigation-with-swiftui-4-e006882c5efa"> <em class="ln">此处</em></a><em class="ln">】</em></p><p id="f8eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是对之前几篇关于创建解耦导航流的文章的回顾(<a class="ae lo" href="https://medium.com/swlh/flow-with-swiftui-and-mvvm-7cc394440ab8" rel="noopener">第1部分</a>和<a class="ae lo" href="https://medium.com/@nicmcconn/flow-with-swiftui-and-mvvm-part-2-viewmodels-905ecc05f1c5" rel="noopener">第2部分</a>)，它们与最初的SwiftUI 1.0相关。时代变了，SwiftUI (3.0)、NavigationView和我自己的视角现在都不同了(也更简单了！)所以觉得值得重新评估。</p><p id="b205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最近一直在用SwiftUI审查我的多屏幕入职流程。与所有的多屏数据输入流一样，它们通常代表了一个有趣的问题，即如何分离数据、视图和导航逻辑。</p><p id="1db7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，是什么造就了一个伟大的多屏数据输入流程呢？这是我想到的。由于缺少一个不那么宏大的术语，我称它为我的“屏幕流动宣言”我在这里使用“屏幕”而不是视图，因为我们明确地指的是全屏导航。</p><ol class=""><li id="0c04" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">屏幕不应该有“父”知识，也不应该负责导航进出。</li><li id="e7c9" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">每个屏幕都有单独的视图模型。</li><li id="759a" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">总体流控制逻辑与UI实现相分离，并且可以在没有UI的情况下进行测试。</li><li id="767c" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">灵活，允许在流程中分支到不同的屏幕。</li><li id="173d" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">尽可能简单，但可组合和可扩展。</li></ol><h1 id="7436" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">航行</h1><p id="6d6b" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">因此，onboarding可能很简单，可能两三个屏幕询问用户一些简单的个人信息。“下一步”按钮将使用户在流程中向前移动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/3218fe3e6cd30b6cf7ef2b2265b07de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*xsppo7bUIGvpjDjlmD30JA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">简单屏幕流</p></figure><p id="e6da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，通常更典型的是带有分支的更复杂的流程。可能用户还没有准备好分享所有这些细节，或者可能需要更多的细节，这取决于之前的回复。所以，也许这更有代表性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/aaf3e160a92e6b93dc1ce853ef788962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*m0R8rq9raeU_CS27tcE_4Q.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">带分支的屏幕流</p></figure><p id="5e6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显然，任何解决方案都需要处理上述内容的任意组合，并且根据宣言第1点，要在屏幕本身之外处理这些内容。还应该注意，我们可能希望在每个屏幕条目的末尾进行一些数据查找，因为我们不希望视图本身控制导航(宣言点3)。</p><p id="ede9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们身处SwiftUI的世界，我建议使用<code class="fe ng nh ni nj b">@ViewBuilder</code>的力量。这是SwiftUI视图的<code class="fe ng nh ni nj b">body</code>里面的“肉”。ViewBuilders是一种生成复杂泛型类型的强大方法——这是SwiftUI声明性本质背后的东西(但超出了本文的范围)。</p><p id="29d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那会是什么样子呢？好的，一个好的开始是SwiftUI相当于<code class="fe ng nh ni nj b">UINavigationController</code>也就是<code class="fe ng nh ni nj b">NavigationView</code>。在这里，我们添加了一个ViewBuilder树结构的等效物来表示导航节点和边:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2b3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好，这真的是伪代码。完全披露——没那么简单😀。</p><p id="a8fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这仍然是“声明性的”，因为它是预定义的，而不是完全编程的，而是动态的，路径由编程逻辑驱动。您仍然需要预先定义每个导航“边缘”。如果你的流程是完全动态的，没有特定的路径，那么这可能不适合你。</p><p id="f7d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也就是说，让我们试着接近这个方法的实现。使用嵌入类型，我们可以从上面创建一个好的分支流程图的声明性定义。它满足了宣言的第一点，也许还有第五点。那么，让我们看看我们是否能实现这样的东西。</p><p id="ffd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">NavigationView</code>与<code class="fe ng nh ni nj b">NavigationLink</code>配对，让我们能够进行“传统的”推送导航。有几个不同的用法，但是我专注于完全程序化的用法:</p><pre class="kg kh ki kj gt nm nj nn no aw np bi"><span id="d159" class="nq me iq nj b gy nr ns l nt nu">NavigationLink(destination: Destination, isActive: Binding&lt;Bool&gt;) { Label }</span></pre><p id="2aa2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里做了一些实验(并对缺乏文档感到沮丧)之后，这里列出了使用<code class="fe ng nh ni nj b">NavigationLink</code>的注意事项:</p><ol class=""><li id="e1a4" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">需要嵌入到诸如<code class="fe ng nh ni nj b">VStack</code>的分组中。</li><li id="fb30" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">如果我们想要一个简单的活动链接来控制导航，那么<code class="fe ng nh ni nj b">Label</code>通常是<code class="fe ng nh ni nj b">Text</code>。然而，在我们的例子中，我们不想要导航的外部编程控制的视图，所以我们使用<code class="fe ng nh ni nj b">EmptyView</code>。</li><li id="ed21" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">装订很容易出错。如果您想要导航的外部控制(我们也是这样)，为每个导航使用带有标志的较新的<code class="fe ng nh ni nj b">@StateObject</code>(而不是<code class="fe ng nh ni nj b">@ObservedObject</code>——见下文)效果很好。</li><li id="854f" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">我不喜欢这个命令。对我来说，导航的触发器如果在目的地之前，读起来会更好。</li></ol><p id="e2a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这改进了<code class="fe ng nh ni nj b">NavigationLink</code>的封装:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="43bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这封装了一些<code class="fe ng nh ni nj b">NavigationLink</code>用法的复杂性。我们可以传入一个绑定标志来允许我们从外部控制导航。需要使用<code class="fe ng nh ni nj b">VStack</code>和<code class="fe ng nh ni nj b">EmptyView</code>的管道工作已经为我们完成。它还利用了<code class="fe ng nh ni nj b">@ViewBuilder</code>来制作一个可读性更好的NavigationLink变体。</p><p id="ee3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看一个简单的三屏流程的运行情况。我们引入了一个可观察的对象来封装导航标志(更多内容将在后面介绍)。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ac84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">屏幕1和2都包含三种类型:显示屏幕名称的<code class="fe ng nh ni nj b">Text</code>，下一个动作的<code class="fe ng nh ni nj b">Button</code>，以及导航的<code class="fe ng nh ni nj b">Flow</code>。我们存储每个导航的流状态，内部函数执行实际的导航(<code class="fe ng nh ni nj b">didTapNext1</code>等)。</p><p id="6352" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是可行的，但是如果下一个按钮自己直接导航的话，可能会有些过头了。其他形式的<code class="fe ng nh ni nj b">NavigationLink</code>或许也能扮演这个角色。然而，作为宣言第3部分的一部分，我们希望从视图外部控制我们的导航。</p><p id="a5e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该注意的是，导航应该基于当前活动的屏幕来激活——当用户在屏幕3上时将<code class="fe ng nh ni nj b">navigateTo3</code>设置为<code class="fe ng nh ni nj b">true</code>将导致一些“奇怪”的结果(它确实导航，但是是即时的，没有动画)。</p><p id="f139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向后导航到前一个屏幕(包括根屏幕)可以通过将最初将用户从该目的屏幕移开的标志设置为<code class="fe ng nh ni nj b">false</code>来实现。在上述情况下，通过设置<code class="fe ng nh ni nj b">navigateTo2 = false</code>从屏幕2编程返回屏幕1。</p><p id="c6d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注:iOS 15中的一个新功能允许你使用<code class="fe ng nh ni nj b">@Environment(\.dismiss)</code>。然而，这只是返回一个屏幕，不允许更大的向后跳转(或弹出到根)。使用激活标志允许更完整的控制。</p><h1 id="a998" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">查看模型和绑定</h1><p id="4f1c" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">继续宣言第2点——每个屏幕都有独立的视图模型。在这里，视图模型的使用和实现可能会有所不同，我已经听到了对SwiftUI中过度使用MVVM设计模式的担忧。这肯定不是苹果官方使用的术语。</p><p id="737f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想要的是视图的非UI表示，这样我可以干净地封装非UI逻辑，在没有视图的情况下对其进行单元测试，当然，也可以轻松地绑定到视图(两种方式)。它还应该是特定于视图的，这样视图就可以四处移动，并且不依赖于任何外部事物(例如，可组合的——声明点5)。它是视图与应用程序其余部分的接口。我称之为视图模型。</p><p id="ea89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SwiftUI <code class="fe ng nh ni nj b">ObservableObject</code>(实际上是Combine的一部分)是一个很好的视图模型，支持双向视图绑定。然而，在<code class="fe ng nh ni nj b">View</code>本身中使用<code class="fe ng nh ni nj b">@ObservedObject</code>可能会有问题，并导致不必要的视图模型重建。使用<code class="fe ng nh ni nj b">@StateObject</code>的新方法创建了一个稳定的视图模型，仅在需要时才被延迟加载。这是对使用变通方法的旧方法的重大改进。</p><p id="d28c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还要注意，在这个版本的视图模型中，UI事件也被从视图传递到视图模型中，并且任何特定于视图的逻辑(例如，网络调用)可以从那里被触发(例如，通常向下调用API层)。</p><p id="50d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了模拟这一点，我们有一个流视图模型(<code class="fe ng nh ni nj b">FlowVM</code>)来管理屏幕到屏幕的导航。它不知道视图，并且被设计成可测试的。它本身可能需要API调用来确定要遵循的路径。这类似于一个“协调器”，但对我来说是导航的模型，因此我使用了“视图模型”这个术语</p><p id="a388" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个屏幕也有单独的视图模型。这些屏幕视图模型处理UI事件和屏幕逻辑。最终(例如，在“下一个”点击之后完成所有屏幕逻辑时)，我们将控制从屏幕视图模型传递回流视图模型，以最终决定导航到哪里。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/057101c480f793e177eb86699d9ffe97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I87_gYdffKaiNDEaXSc3SQ.png"/></div></div></figure><p id="296b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了完成，从屏幕视图模型返回到流视图模型，我们可以使用各种技术。委托和回调都是有效的实现，但是我喜欢使用Combine的<code class="fe ng nh ni nj b">PassthroughSubject</code>来传递对屏幕视图模型本身的引用。</p><p id="408f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以屏幕视图模型和<code class="fe ng nh ni nj b">view</code>会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b212" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并连接到流程视图模型中，使用<code class="fe ng nh ni nj b">sink</code>监听如下完成事件，并将其存储在<code class="fe ng nh ni nj b">subscription</code>中。您会注意到这里处理了创建屏幕视图模型的工厂函数，它还添加了事件监听。该工厂函数由屏幕视图初始化中的流视图调用。</p><p id="5687" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">sink</code>直接调用一个方法来处理任何逻辑(在这种情况下，它只是简单地设置导航标志)并将订阅存储在附加到<code class="fe ng nh ni nj b">vm</code>的<code class="fe ng nh ni nj b">Set </code>中(它可用于所有订阅)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="1402" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">将它整合在一起</h1><p id="f58f" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">让我们看看，在加入我们的五屏分支流程后，整体看起来如何。您会注意到每个导航边缘都有一个单独的导航标志。您还会注意到，屏幕3视图模型需要两个<code class="fe ng nh ni nj b">didTap()</code>函数和两个<code class="fe ng nh ni nj b">PassthroughSubjects</code>函数来处理分支逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0fa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看<a class="ae lo" href="https://github.com/nickm01/NavigationFlow" rel="noopener ugc nofollow" target="_blank">回购</a>的完整代码。这也包括向后导航的例子(包括回到根目录或屏幕二等)。</p><h1 id="2ffe" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试</h1><p id="d2d6" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们设计的很大一部分是为了提高可测试性，并允许独立于UI的导航流的单元测试(宣言点3)。现在有了视图模型，这很容易做到。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们能够触发“下一步”按钮点击，然后检查导航逻辑是否被触发——所有这些都不需要实际的UI。</p><p id="1f99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这显然是一个简单的实现。如果视图模型有API调用，我们将不得不考虑一些注入来模拟这些调用。另外，这显然不是UI测试。</p><p id="0952" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可能还想添加一些UI测试(可能使用快照测试)，但这超出了本文的范围。</p><h1 id="06e3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后…</h1><p id="915d" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我希望这有意义！这绝对是一次尝试理解如何使用导航的旅程，我很乐意分享。导航最近有所改进，我真的希望苹果继续改进它。以下是一些建议:</p><ol class=""><li id="f19f" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">当导航超出简单的情况时，有太多的方法会出错——而文档太少。比如使用<code class="fe ng nh ni nj b">@ObservedObject</code>，在错误的时间使用错误的激活标志等等。我在大量的帖子和自定义库中看到了这一点。</li><li id="e0c0" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">允许以这样一种方式导航，即不必从正确的屏幕指定和处理每个导航边缘，而只是从任何屏幕声明导航到一个屏幕。</li><li id="cfcb" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">为向后导航创建一个更简单的API(pop to root，等等)。</li><li id="9e5a" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">而不是UIKit更灵活(例如，自定义推送导航动画等。)，使SwiftUI导航至少同样灵活…甚至可能更好。</li></ol><p id="8096" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的代码可以在https://github.com/nickm01/NavigationFlow/tree/swiftui3 T2找到。</p></div></div>    
</body>
</html>