<html>
<head>
<title>State Unmanagement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">国家失控</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/state-unmanagement-a2b1e2442163?source=collection_archive---------2-----------------------#2022-12-31">https://betterprogramming.pub/state-unmanagement-a2b1e2442163?source=collection_archive---------2-----------------------#2022-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3918" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用DOM避免管理状态</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0945a79eafecca865218784c581977f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*snHjZrhJK5_6Qx62"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凯利·西克玛在<a class="ae kv" href="https://unsplash.com/photos/377gw1wN0Ic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="96d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当React问世时，它是第一个明确向大众推销“作为国家功能的视图”的框架。无论如何，这个想法并不新颖，但是React无疑使它普及了。虽然可以使用较低层次的可观察对象，比如在<a class="ae kv" href="https://knockoutjs.com/" rel="noopener ugc nofollow" target="_blank"> KnockoutJS </a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Virtual_DOM" rel="noopener ugc nofollow" target="_blank">、</a>中使用的那些，但似乎更适合这个想法，随后，我们今天知道的大多数框架都是在某种形式的VDOM之上实现的。不过，也有非VDOM图书馆，如Svelte和Solid，体现了相同的基本思想。</p><p id="fdb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，V(S)(视之为国家职能)在我们的行业中根深蒂固，对大多数人来说，似乎没有其他办法。当然，至少有一个。</p><p id="b3db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探索另一种方法，我还将展示一些实现它的代码。虽然这种方法无论如何都不是灵丹妙药，也没有明确的宗教信仰，但它解决了开发UI时可能遇到的大多数问题，而且代码更少，更重要的是复杂性更低。</p><p id="83c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给你的旅程做好准备，我会马上做好三件事。</p><p id="f53e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一，我是<strong class="ky ir">不是</strong>在说React 中<a class="ae kv" href="https://medium.com/@hayavuk/react-forms-d49ec73cc84a" rel="noopener">不受控制的组件。我说的是完全不同的东西，甚至是用React(或任何V(S)库)都做不到的东西。如果在读完本文后，您仍然认为这是关于不受控制的组件，请仔细考虑下一段。</a></p><p id="4fd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，如果你不想亲自尝试这些东西，也不要指望完全理解这篇文章。本文描述了这些概念并提供了一些背景知识，但这还不够。为了完全理解一个新概念，你必须实践它。这篇文章中的信息实际上是实践，什么食谱的蛋糕是它的味道。我们这样做是为了吃的体验，而不是关于烹饪的知识！</p><p id="a7fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，祝你新年快乐，我亲爱的读者！愿2023年带给你许多个月的快乐和发现！</p><h1 id="c817" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">当状态定义视图时</h1><p id="cb00" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在V(S)中，是状态定义了视图。这个想法是，我们有一个普通JavaScript对象形式的视图的抽象表示，然后我们有一个将这个状态同步到DOM的机制。</p><p id="a58e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使在切换到vanilla之后，有一段时间，我仍然在变量中管理应用程序状态，并手动将其同步到DOM，这主要是出于惯性。我会在变量中保存一些值，然后我会先修改变量，然后在一个单独的过程中将它们与DOM同步。这样做的话，将值与DOM同步的代码不需要关心<em class="mp">值是如何</em>修改的。这看起来是一个巧妙的技巧，从精神上来说，仍然是V(S)。关注点的分离等等。</p><p id="58f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那个数字变了，所以我需要改变这个节点的<code class="fe mq mr ms mt b">textContent</code>，但是我不在乎是什么改变了数字。这个列表发生了变化，所以我需要更新那些表格行和这里的摘要文本，但是我不关心列表是如何被修改的。诸如此类。</p><p id="229d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，这帮助我敏锐地意识到所涉及的额外成本。<em class="mp">知道</em>这件事是一回事。虽然在简单的视图中手工实现了整个机器(双关语，无意)，但我开始觉得这是一种非常浪费的方法。</p><p id="fa7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我开始质疑这种间接性的整个概念。为什么这是必要的？更重要的是，我们真的需要它吗？如果您正在使用框架，您可能甚至不知道，或者没有选择，因为这些细节总是对您隐藏的(这是抽象的一点)，但是它仍然存在。</p><h1 id="2cfe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">状态二元性</h1><p id="a030" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">DOM是有状态的。这是显而易见的，但是当我们对V(S)投入如此之深，尤其是使用工具使这一事实变得不可见和/或显得无关紧要时，它可能会躲避我们很多年。从我开始接触JavaScript的时候我就知道DOM是有状态的，但是后来我又学会了如何忽略这一点，并且忽略了很多年。</p><p id="34c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在输入中键入内容，输入会保留文本。如果我们激活一个选择列表，它会一直打开。如果我们选中一个复选框，它将保持选中状态。我们可以修改各种属性的值，这些值会保持不变，直到节点被删除。这是所有的状态。</p><p id="ad6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们做V(S)时，我们基本上是在处理两种状态，一种在应用程序中，一种在DOM中。为了得到视图是状态的严格函数的错觉，我们需要确保状态的变化总是反映在DOM中，这就需要对DOM进行微观管理。</p><p id="793f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果DOM是有状态的，并且我们正在开发接口——这意味着DOM是这个节目的真正明星，状态/数据只是在那里支持它——为什么我们不使用DOM作为事实的单一来源并将应用程序状态存储在其中呢？</p><h1 id="a282" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在DOM中存储状态</h1><p id="b2bd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我解释一下我所说的“在DOM中存储状态”是什么意思。上面我举了几个例子，但是这里有一些具体的代码。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="df45" class="my lt iq mt b be mz na l nb nc">// Element text<br/>let $output = document.getElementById('output')<br/>$output.textContent<br/><br/>// Element values and properties as state<br/>let $input = document.querySelector('input[name=email]')<br/>$input.value = 'test'<br/>$input.disabled<br/><br/>// Attributes and data attributes<br/>let $th = document.querySelector('th[aria-sort]')<br/>$th.getAttribute('aria-sort')<br/>$th.dataset.active = true</span></pre><p id="299b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过访问各种属性从DOM中读取状态。我们通过设置属性来设置状态。是啊，我知道。完全没有戏剧性。这才是重点。这项功能在浏览器中，是免费的，使用起来也并不困难。</p><p id="a169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与普遍的看法相反，这一点也不慢。根据手头的问题，这可能不总是最快的方法，但绝对不会慢。我将在最后讨论一些注意事项。</p><p id="0279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当从DOM中读取状态时，除了少数情况下的，一般不会有太多的开销<a class="ae kv" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="noopener ugc nofollow" target="_blank">。当写入DOM节点属性时，可能会有开销，也可能没有，这取决于您所写的内容(例如，许多属性需要反映在属性中，因此这显然与在普通对象上分配属性不完全相同)。如果您使用非标准属性，这本质上与在任意随机对象上为任意属性赋值是一样的，因此没有额外的开销。记住，DOM节点只是对象。他们不是什么神奇的野兽，如果你碰他们，他们会咬掉你的头！</a></p><p id="41d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还有一个仅在会话期间相关的临时状态。例如，用于优化的缓存值。我们也可以使用非标准属性将这些值存储在DOM节点上。例如:</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="e14a" class="my lt iq mt b be mz na l nb nc">let <br/>  $input = document.querySelector('input[name=email]'),<br/>  markTouched = () =&gt; $input.__touched = true<br/><br/>$input.addEventListener('change', markTouched, { once: true })</span></pre><p id="e59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">__touched</code>属性是非标准的(我用双下划线作为前缀，以避免与未来的标准属性发生冲突)。因为它代表了某种短暂的状态，这种状态只在用户真正接触界面时才相关，所以以一种不能在服务器端序列化为HTML的方式存储它是很好的。</p><p id="11c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这种类型的状态也可以使用数据属性来存储，如果状态会影响样式，这可能是一种更好的方法，因为数据属性像任何其他属性一样可以在CSS中选择。</p><h1 id="dd8e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">DOM状态和CSS</h1><p id="23c2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当使用DOM状态作为应用程序状态时，我们也更习惯于在CSS中使用各种属性作为选择器。例如，我们可以有这样的选择器:</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="11f2" class="my lt iq mt b be mz na l nb nc">input[value],<br/>input:checked,<br/>th[aria-sort=ascending]::before,<br/>button:disabled,<br/>...</span></pre><p id="7d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不是直接使用DOM state所特有的，而是这种方法的一个更自然的伴侣。</p><p id="08d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中，也没有什么可以阻止任何人这样做。只是当开发人员可以访问变量中的状态时，他们倾向于设置类，可能还有一小部分其他属性，比如<code class="fe mq mr ms mt b">disabled</code>。</p><h1 id="ad47" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">比较</h1><p id="88c8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我在托管和非托管状态之间做一个简单的直接比较。我将使用普通的DOM API来做这件事，没有框架。</p><p id="8975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们构建一个简单的有三个选择的生日选择器。HTML将由三个选择列表组成，一个包含可用年份的范围，一个包含12个月，一个包含31天。由于并非所有可能的组合都是有效的日期，我们将根据选择修改可用的月份和日期。</p><p id="4adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两种情况下，HTML都将使用如下所示的代码在服务器端或客户端呈现:</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="848b" class="my lt iq mt b be mz na l nb nc">let <br/>  today = new Date(),<br/>  validYears = (() =&gt; {<br/>    let years = []<br/>    for (let i = 1970; i &lt; today.getFullYear(); years.push(i++)) {}<br/>    return years<br/>  })(),<br/>  validMonths = (() =&gt; {<br/>    let<br/>      months = [],<br/>      maxMonth = today.getMonth()<br/>    for (let i = 0; i &lt;= maxMonth; i++)<br/>      months.push([<br/>        i, <br/>        new Date(year, i, 1)<br/>          .toLocaleDateString(navigator.language, { month: 'long' })<br/>      ])<br/>    return months<br/>  })(),<br/>  validDays = (() =&gt; {<br/>    let<br/>      days = [],<br/>      lastDay = today.getDate()<br/>    for (let i = 1; i &lt;= lastDay; days.push(i++)) {}<br/>    return days<br/>  })(),<br/>  html = `<br/>    &lt;select name="year" &gt;<br/>      ${validYears.map(n =&gt; `&lt;option value="${n}"&gt;${n}&lt;/option&gt;`)}<br/>    &lt;/select&gt;<br/>    &lt;select name="month"&gt;<br/>      ${validMonths.map(([n, name]) =&gt; `&lt;option value="${n}"&gt;${name}&lt;/option&gt;`)}<br/>    &lt;/select&gt;<br/>    &lt;select name="day"&gt;<br/>      ${validDays.map(n =&gt; `&lt;option value="${n}"&gt;${n}&lt;/option&gt;`)}<br/>    &lt;/select&gt;<br/>  `<br/></span></pre><p id="9922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从托管版本开始。这段代码有意全部是手动的，以便稍后清楚地显示与非托管版本的区别。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="02dd" class="my lt iq mt b be mz na l nb nc">let<br/>  today = new Date(),<br/>  selectedYear = 1990,<br/>  selectedMonth = 0, // 0-based, just like the Date object<br/>  selectedDay = 1,<br/><br/>  $year = document.querySelector('select[name=year]'),<br/>  $month = document.querySelector('select[name=month]'),<br/>  $day = document.querySelector('select[name=day]'),<br/><br/>  adjustDay = () =&gt; {<br/>    if (new Date(selectedYear, selectedMonth, selectedDay).getMonth() !== selectedMonth)<br/>      $day.value = selectedDay = new Date(selectedYear, selectedMonth + 1, -1)<br/>  },<br/>  updateMonths = () =&gt; {<br/>    let lastMonthToShow = selectedYear &lt; today.getFullYear() ?<br/>      11 : today.getMonth()<br/>    for (let $ of $month.children) <br/>      $.hidden = $.value &gt; lastMonthToShow<br/>  },<br/>  updateDates = () =&gt; {<br/>    let lastDayToShow = new Date(Math.min(<br/>      new Date(selectedYear, selectedMonth + 1, -1)<br/>      today<br/>    )).getDate()<br/>    for (let $ of $day.children)<br/>      $.hidden = $.value &gt; lastDayToShow<br/>  }<br/><br/>$year.onchange = () =&gt; {<br/>  selectedYear = Number($year.value)<br/>  adjustDay()<br/>  updateMonths()<br/>  updateDates()<br/>}<br/>$month.onchange = () =&gt; {<br/>  selectedMonth = Number($month.value)<br/>  adjustDay()<br/>  updateDates()<br/>}<br/>$date.onchange = () =&gt; {<br/>  selectedDay = Number($day.value)<br/>}</span></pre><p id="ed9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在同样的东西以非托管格式出现。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="55f2" class="my lt iq mt b be mz na l nb nc">let <br/>  today = new Date(),<br/><br/>  $year = document.querySelector('select[name=year]'),<br/>  $month = document.querySelector('select[name=month]'),<br/>  $day = document.querySelector('select[name=day]'),<br/><br/>  adjustDay = () =&gt; {<br/>    if (new Date($year.value, $month.value, $day.value).getMonth() !== $month.value)<br/>      $day.value = new Date($year.value, Number($month.value) + 1, -1)<br/>  },<br/>  updateMonths = () =&gt; {<br/>    let lastMonthToShow = $year.value &lt; today.getFullYear() ?<br/>      11 : today.getMonth()<br/>    for (let $ of $month.children) <br/>      $.hidden = $.value &gt; lastMonthToShow<br/>  },<br/>  updateDates = () =&gt; {<br/>    let lastDayToShow = new Date(Math.min(<br/>      new Date($year.value, Number($month.value) + 1, -1)<br/>      today<br/>    )).getDate()<br/>    for (let $ of $day.children)<br/>      $.hidden = $.value &gt; lastDayToShow<br/>  }<br/><br/>$year.onchange = () =&gt; {<br/>  adjustDay()<br/>  updateMonths()<br/>  updateDates()<br/>}<br/>$month.onchange = () =&gt; {<br/>  adjustDay()<br/>  updateDates()<br/>}</span></pre><p id="b63d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两段代码非常相似，但肯定有一些不同之处。在第二个版本中:</p><ul class=""><li id="93c5" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">我们不再有代表当前所选选项值的三个变量</li><li id="3b7f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们直接使用选择列表的值</li><li id="d938" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们只是有选择地对值进行类型转换，并且主要依靠运行时来强制转换(从技术上讲，这也是您在托管版本中可以做的事情，但是由于管理状态的全部目的是为了促进松散耦合，所以您不会这样做，因为您不知道何时以及如何使用这些值)</li><li id="b008" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们少了一个事件处理程序</li><li id="74a9" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们不再需要将输入值赋给变量</li></ul><p id="45e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们能够删除40行代码中的8行(不包括空格)，所以大约每五行中就有一行。我们真的不能就代码占用空间的潜在节省得出结论，因为这取决于编码风格、所解决的问题等等。不过，一般来说，代码量的差异随着应用程序的大小而增加。换句话说，回报不会减少——而是增加——后面会有一些警告。</p><h1 id="6450" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">比较反应</h1><p id="b40e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">作为一个有趣的练习(或者不是)，让我们也做一个反应版本。现在我的反应有点迟钝了，所以我可能做这些事情的效率比他们应该做的要低一些，但是我保证我不会试图增加它的几率。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="9a64" class="my lt iq mt b be mz na l nb nc">import React from 'react'<br/><br/>let<br/>  today = new Date(),<br/>  validYears = (() =&gt; {<br/>    let years = []<br/>    for (let i = 1970; i &lt; today.getFullYear(); years.push(i++)) {}<br/>  })(),<br/>  getValidMonths = (year, month) =&gt; {<br/>    let<br/>      months = [],<br/>      maxMonth = Math.min(month, today.getMonth())<br/>    for (let i = 0; i &lt;= maxMonth; i++)<br/>      months.push([<br/>        i, <br/>        new Date(year, i, 1)<br/>          .toLocaleDateString(navigator.language, { month: 'long' })<br/>      ])<br/>    return months<br/>  }<br/>  getValidDays = (year, month, day) =&gt; {<br/>    let<br/>      days = [],<br/>      lastDay = new Date(Math.min(<br/>        new Date(year, month, day),<br/>        today<br/>      )).getDate()<br/>    for (let i = 1; i &lt;= lastDay; i++) <br/>      days.push(i)<br/>    return days<br/>  }<br/>  BirthdaySelect = class extends React.Component {<br/>    constructor(props) {<br/>      super(props)<br/>      this.state = {<br/>        // Actual state we are interested in<br/>        selectedYear: 1990,<br/>        selectedMonth: 0,<br/>        selectedDay: 1,<br/><br/>        // Abstract representation of the UI required for VDOM<br/>        selectableMonths: [],<br/>        selectableDays: [],<br/>      }<br/>    }<br/><br/>    handleYear = ev =&gt; {<br/>      let year = Number(ev.target.value)<br/>      this.setState(state =&gt; ({<br/>        selectedYear: year,<br/>        selectableMonths: this.getValidMonths(year, state.selectedMonth),<br/>        selectableDays: this.getValidDays(<br/>          year, <br/>          state.selectedMonth, <br/>          state.selectedDay,<br/>        ),<br/>      })<br/>    }<br/>    handleMonth = ev =&gt; {<br/>      let month = Number(ev.target.value)<br/>      this.setState(state =&gt; ({<br/>        selectedMonth: month,<br/>        selectableDays: this.getValidDays(<br/>          year, <br/>          state.selectedMonth, <br/>          state.selectedDay,<br/>        )<br/>      })<br/>    }<br/>    handleDay = ev =&gt; {<br/>      this.setState(() =&gt; ({ <br/>        selectedDay: Number(ev.target.value),<br/>      })<br/>    }<br/><br/>    render() {<br/>      return (<br/>        &lt;&gt;<br/>          &lt;select <br/>            name="year" <br/>            value={this.state.selectedYear} <br/>            onChange={this.handleYear}<br/>            &gt;<br/>            {validYears.map(n =&gt; <br/>              &lt;option value={n} key={n}&gt;{n}&lt;/option&gt;}<br/>          &lt;/select&gt;<br/>          &lt;select <br/>            name="month"<br/>            value={this.state.selectedMonth}<br/>            onChange={this.handleMonth}<br/>            &gt;<br/>            {this.state.selectableMonths.map(([n, label]) =&gt;<br/>              &lt;option value={n} key={n}&gt;{label}&lt;/option&gt;}<br/>          &lt;/select&gt;<br/>          &lt;select <br/>            name="day"<br/>            value={this.state.selectedDay}<br/>            onChange={this.handleDay}<br/>            &gt;<br/>            {this.state.selectableDays.map(n =&gt;<br/>              &lt;option value={n} key={n}&gt;{n}&lt;/option&gt;}<br/>          &lt;/select&gt;<br/>        &lt;/&gt;<br/>      )<br/>    }<br/></span></pre><p id="ecb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React做的事情有点不同，首先它需要自己创建DOM节点，而不是让浏览器来处理。</p><p id="b06f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了呈现DOM节点，我们还需要计算与UI结构匹配的状态导数，这样我们就可以很好地将它们映射到节点上。<code class="fe mq mr ms mt b">getValidMonths()</code>和<code class="fe mq mr ms mt b">getValidDays()</code>函数复制了前两个例子中相似的功能，所以我们不一定把它们算作特定于React的。一个显著的区别是，每当底层数据发生变化时，我们都必须调用这些函数。这是需要使用数据表示UI而不是直接使用DOM的结果。为了方便起见，我们还将选择的有效值存储在组件状态中，以避免为了迂腐而必须实现记忆化和类似的技巧。无论哪种方式，我们都无法避免额外的代码。从这个意义上说，这些确实代表了额外的开销。不是一个大的，当然，但仍然开销。</p><p id="0b7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码的其余部分或多或少类似于托管状态的普通示例——如果你仔细观察的话——类似于我们在那里看到的cruft。</p><p id="a4cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，React甚至没有为我们提供任何其他方式的选项，这意味着我们注定会遇到解决方案不是最佳的和/或比它本来可能的更复杂的情况。</p><h1 id="52e9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">管理或取消管理</h1><p id="7b60" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我希望我听起来不像非托管状态是银弹。虽然我确实认为非托管状态在大多数情况下是一种很好的默认方法，但显然在某些情况下这是行不通的。</p><p id="0f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您要处理成千上万的数据点，并希望将其绘制成图表或转换成其他形式供人们使用，那么您显然不能将所有这些数据点存储在一个HTML表中，并将其称为“非托管状态”。这将是非常低效和浪费的，因为任何包含数万个内容的东西都不会被最终用户使用(甚至是可用的)，即使这样做没有性能问题——当然有。</p><p id="742b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然使用DOM作为应用程序状态通常会导致代码更简单，但也不总是这样。除了我们已经提到的关于数据量和数据使用方式的内容，将状态作为JavaScript对象进行管理有时比在DOM中做任何事情都更好。有时，在将更改应用到DOM之前，有必要首先抽象地计算预期的结果。不是很经常，但是有一些这样的情况。</p><p id="becd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，虽然只使用DOM对表行进行排序和过滤可以大大简化代码，但是如果这两个操作总是结合在一起执行，那么首先在数据中执行<em class="mp">可以</em>减少DOM操作的数量(取决于您如何执行)。在最坏的情况下，您不会注意到差异，但在最好的情况下，托管方法最终可能会快一倍或更多，这取决于机器的性能和其他因素。在这些情况下，试图优化只使用DOM的代码的性能通常会导致代码比管理状态的代码更加<em class="mp">复杂，这违背了不管理状态的目的，不值得。</em></p><p id="dc24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们没有节点来存储状态这种明显的情况呢？比如说，在处理画布的时候。对于非托管状态，这也不是一个很好的用例。</p><p id="0536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我还要提醒你，这不是一个非此即彼的问题。根据具体情况，这两种方法各有优势，并且可以在同一个应用程序中愉快地共存。我们也可以采用混合方法，在这种方法中，国家处于半管理状态——这可能是下一次的主题。只有当我们别无选择时(例如，当我们使用专门用于托管状态的库，如React和其他V(S)库)或做出错误选择时，我们才会遇到问题。</p><h1 id="d66d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例代码</h1><p id="c93a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以在我的GitHub简介中找到一些国家失控的例子。</p><ul class=""><li id="1c87" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/foxbunny/vanilla-todo" rel="noopener ugc nofollow" target="_blank">普通的TODO应用程序</a>，它使用一个表单来表示应用程序的所有状态</li><li id="73ba" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://github.com/foxbunny/vanilla-ui-patterns/tree/master/table-sorting-filtering" rel="noopener ugc nofollow" target="_blank">表格排序和过滤示例</a>在我的<a class="ae kv" href="https://github.com/foxbunny/vanilla-ui-patterns" rel="noopener ugc nofollow" target="_blank">普通UI模式</a> repo中</li><li id="983e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">在<a class="ae kv" href="https://github.com/foxbunny/vanilla-ui-patterns" rel="noopener ugc nofollow" target="_blank">普通UI模式</a> repo中的<a class="ae kv" href="https://github.com/foxbunny/vanilla-ui-patterns/tree/master/benchmarks" rel="noopener ugc nofollow" target="_blank">基准测试部分</a>包含了三个与状态管理相关的基准测试，展示了一个受管状态优于非受管状态的边缘案例(但是不要据此得出一概而论的结论！)</li></ul></div></div>    
</body>
</html>