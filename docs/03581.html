<html>
<head>
<title>An Overview of Docker Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker体系结构概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-overview-to-docker-architecture-15407c482c52?source=collection_archive---------1-----------------------#2020-02-19">https://betterprogramming.pub/an-overview-to-docker-architecture-15407c482c52?source=collection_archive---------1-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2677" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解最常用的开发技术之一背后的底层组件和系统的基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ebe2ba62bf9ce110c73f0b4f2af354aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*ILZB70Q-FZ03g7m8.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:<a class="ae ku" href="https://www.docker.com/company/newsroom/media-resources" rel="noopener ugc nofollow" target="_blank"> Docker标识和照片</a></p></figure><p id="2839" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你最近刚进入容器的奇妙世界，或者你已经在这里呆了一段时间，那么理解底层系统和元素一起工作来提供<a class="ae ku" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>的巨大好处可能是个不错的主意。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5f80" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">了解基础知识</h1><h2 id="0b3a" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">图像还是容器？</h2><p id="6dcc" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">重要的事情先来。对基本术语有一个清晰的认识从来没有伤害过任何人。看起来一个<em class="nh">图像</em>和一个<em class="nh">容器</em>是等价的术语——难道它们不是同一个东西吗？我的意思是，我用这两个工具把我的应用程序放到某个服务器、PaaS或其他什么东西上。</p><h2 id="f00e" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">嗯，是的，但实际上不是</h2><p id="0131" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">就软件开发而言，容器可以被描述为映像的实例。这种说法有一些含义:</p><ul class=""><li id="78d4" class="ni nj it kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">从同一个图像中可以产生无限多的容器。</li><li id="08b3" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">图像中的资源将出现在它的所有派生容器中。哪种类型的资源？任何:文件、服务、二进制文件、cron作业等。</li><li id="bf8c" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">删除容器后，其所有内容都会丢失。稍后，我们将学习如何处理数据持久性。</li></ul><h2 id="c14a" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">实际的图像容器差异</h2><p id="dcb4" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">我们已经知道容器是某种图像实例。了解基本区别就够了。但是为了提高我们的Docker技能，我们需要更深入地了解图像概念。</p><p id="f4fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图像是一堆层。那么什么是层呢？<strong class="kx iu">层是相对于前一层的一组差异</strong>。<code class="fe nw nx ny nz b">Dockerfile</code>是定义如何构建图像的文件。该文件中的每个指令代表图像的一个层。<strong class="kx iu">层被缓存</strong>以更快地构建图像，所以一个好的<code class="fe nw nx ny nz b">Dockerfile</code>实现真的可以在<strong class="kx iu">构建时间</strong>和<strong class="kx iu">图像大小</strong>上产生差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/140ae49087e2807e2cef9090322f2ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*BhpiQOr3OEJjSUsK.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers" rel="noopener ugc nofollow" target="_blank">docs.docker.com</a>解释的图像层</p></figure><p id="5d61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是真正的交易。当生成一个容器时，我们获取图像的层堆栈并在顶部生成一个可写层，即<strong class="kx iu">容器层</strong>。容器生命周期中生成的任何更改都会写入该层。因此当删除容器时，<strong class="kx iu"> <em class="nh"> </em>容器层数据会丢失</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/40a44476412797b21adf288ea8d193e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rt-bytx5pv5_Jx8H.jpg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自同一个图像的多个容器，<a class="ae ku" href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers" rel="noopener ugc nofollow" target="_blank">docs.docker.com</a></p></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="577f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Docker架构101</h1><h2 id="93b2" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">码头引擎</h2><p id="1d25" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">你试过安装Docker吗？你可能已经注意到，你不仅需要安装Docker，还需要安装一个叫做<code class="fe nw nx ny nz b">dockerd</code>的东西。</p><p id="4c5f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是因为Docker是一个客户端-服务器应用程序。您必须拥有在您的计算机上运行Docker应用程序的两个部分。这种客户机-服务器串联被称为<strong class="kx iu"> docker引擎</strong>。</p><p id="6675" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> docker客户端</strong>只是一个针对<strong class="kx iu"> REST API </strong>发出请求的CLI工具，REST API负责与<strong class="kx iu"> docker守护进程</strong>或<code class="fe nw nx ny nz b">dockerd</code>进行交互。<code class="fe nw nx ny nz b">dockerd</code>将处理操作系统，以确保集装箱的正确行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dfe007a91ccc719a9aec82bdf6494aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*zRkIlb8LvOQHP01u.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://docs.docker.com/engine/docker-overview/#docker-engine" rel="noopener ugc nofollow" target="_blank">docs.Docker.com</a>解释的docker引擎</p></figure><p id="6156" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">等等，你是不是提到了客户机-服务器？这是否意味着我可以将请求扔给一个远程Docker守护进程？嗯，你现在可能意识到像Kubernetes、OpenShift和Docker Swarm这样的<strong class="kx iu">编排服务</strong>是如何工作的。</p><h2 id="b666" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">整体情况</h2><p id="9aca" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">现在我们已经清楚地了解了Docker的主要元素，它们是如何协同工作的呢？</p><p id="c449" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每当在Docker客户机中创建一个请求时，它都会被发送到Docker守护进程，并执行所需的操作。</p><p id="f3e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们以运行redis容器为例。我们通过运行指令<code class="fe nw nx ny nz b">docker run redis</code>来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi oh"><img src="../Images/df02f312ae0cdb73b33e5807c055b4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zj9m4XSk9Ls3UuhGkBRVA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Docker建筑，<a class="ae ku" href="https://docs.docker.com/engine/docker-overview/#docker-architecture" rel="noopener ugc nofollow" target="_blank">docs.docker.com</a></p></figure><p id="3e62" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们的计算机将向已配置的docker主机API发出请求，该API将与Docker守护进程进行交互。</p><p id="d855" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此时，守护程序知道它必须做什么。它将在主机注册表上查找redis映像。如果它不存在，将进行新的查找，这次是针对配置的映像注册表(Docker Hub、ECR、ACR、GCR等)并提取(下载)。然后，它将基于下载的图像生成一个容器。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6e5e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">其他关键码头零件</h1><h2 id="f1d8" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">持久性问题</h2><p id="b551" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">如果由于某种原因，我们的<code class="fe nw nx ny nz b">postgres</code>容器崩溃并且不能再次启动，我们可能需要移除容器并运行另一个。然而，容器层的数据将会丢失，就像我们之前讨论的那样，我们不想丢失所有的数据，不是吗？</p><p id="db21" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为持久性问题提供的两个解决方案是<strong class="kx iu">卷</strong>和<strong class="kx iu">绑定挂载</strong>。有了这两者，我们可以将正在运行的容器的文件系统持久化到我们的主机中。</p><p id="efc0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一方面，卷在主机中存储数据，只有<code class="fe nw nx ny nz b">dockerd</code>可以修改这个文件系统。这是通常首选的数据存储方式。</p><p id="0bb2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">另一方面，使用绑定挂载，我们不仅可以将目录挂载到容器中，还可以挂载具体的文件。此外，绑定挂载允许挂载任何<strong class="kx iu">主机目录或文件</strong>。这意味着我们可以将数据从我们的主机插入到容器中。这对配置文件来说是巨大的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/05302f3989c526c6ff8da9fec5d8aa74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*gt6wGH38z7EKbhmm.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Docker提供不同的数据存储，<a class="ae ku" href="https://docs.docker.com/storage/#choose-the-right-type-of-mount" rel="noopener ugc nofollow" target="_blank">docs.docker.com</a></p></figure><p id="91a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">还有第三种数据挂载模式，<strong class="kx iu"> tmps </strong>，这种模式在Linux主机中用于持久存储我们不希望<strong class="kx iu">写入容器层或主机文件系统</strong>的数据，比如机密。该数据保存在<strong class="kx iu">主机存储器中。</strong></p><h2 id="0acd" class="mq lz it bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为什么我的容器不能ping Google？</h2><p id="521d" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">也许你想在你的电脑里运行你的神奇的网络应用程序，与世隔绝。然而，这不是Docker的主要用例，因此在编排Docker容器时，网络扮演着重要的角色。</p><p id="4435" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Docker提供了将不同类型的<strong class="kx iu">网络驱动</strong>附加到运行的容器的可能性，从而实现容器和另一个容器、Docker主机和/或互联网之间的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c1d4f8fddf303a77dce5b2726405d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*9LCqBOtkjxA-DeNs.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://docs.docker.com/v17.09/engine/userguide/networking/#user-defined-networks" rel="noopener ugc nofollow" target="_blank">docs.docker.com</a>提供的桥接网络示例</p></figure><p id="9989" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于容器本身并不真正需要深入的网络知识，我们将把这个主题留给另一篇文章。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ff71" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">去玩吧！</h1><p id="1611" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">现在您应该对不同的Docker资源如何协同工作有了更清晰的认识。现在，您至少应该能够理解“容器世界”中讨论的大多数概念的表面</p><p id="cb4c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我邀请你做你自己的研究，更深入地研究这些主题，并构建和部署你的容器化应用。以下是一些想法:</p><ul class=""><li id="2a3a" class="ni nj it kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">尝试不同的卷/网络模式。</li><li id="d7dc" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">测试层缓存与无缓存的构建时间。</li><li id="c9a9" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">尝试多步构建。</li><li id="8032" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">尽情享受美妙的<code class="fe nw nx ny nz b">docker-compose</code>。</li></ul></div></div>    
</body>
</html>