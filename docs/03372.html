<html>
<head>
<title>The 7 Facets of Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件的7个方面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-007-the-facets-of-w3c-web-components-e76798ab7b29?source=collection_archive---------14-----------------------#2020-02-05">https://betterprogramming.pub/2020-007-the-facets-of-w3c-web-components-e76798ab7b29?source=collection_archive---------14-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">封装、隔离、分离、模块化、分发、定制和记录</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ac1a3cb3a72db31975b5ae88b1c1586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiZ2j9z0ZCab1zTTuwcdnA.png"/></div></div></figure><p id="ed42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Web组件为开发人员带来了好处，它提供了一种设计应用程序各个部分的方法，而不会产生冲突。</p><p id="cd0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于组件，首先要理解的是，它们不是主要的设计问题。也就是说，它们不是用户问题的技术解决方案。</p><p id="6e2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，首先考虑UI/UX是一种干扰。相反，它们是软件开发人员关心的问题，为软件开发人员面临的问题提供解决方案。</p><p id="9760" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设计良好的组件有七个不同的方面，它们独立于任何框架(React、Vue、Angular ),并严格遵守W3C web标准:</p><ol class=""><li id="b979" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><em class="lz">封装</em>定制的HTML元素，这样它们就可以作为一个单元来对待。</li><li id="0216" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><em class="lz">隔离</em> CSS规则，防止特异性泄露。</li><li id="241e" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">将模板、修饰和控制的工作分成web的三种核心语言。</li><li id="a957" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><em class="lz">模块化</em>组件以提供内部范围。</li><li id="47be" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><em class="lz">分发</em>成品，以便与他人分享。</li><li id="9958" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><em class="lz">定制</em>发布的产品在不同设置下工作。</li><li id="fca8" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><em class="lz">记录</em>所有部件是如何组合在一起的。</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="53c5" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">1.包装</h1><p id="7fdd" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">web组件最容易理解的概念之一是，文档的各个部分是从整体中分离出来的，并被视为一个单元。这是使用<em class="lz">定制元素</em>完成的，这是一种<a class="ae nj" href="https://www.w3.org/" rel="noopener ugc nofollow" target="_blank"> W3C </a>技术。</p><p id="00d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自定义元素的规范描述了它的生命周期，从浏览器将它添加到文档中开始，到它被删除为止。浏览器发送给自定义元素的生命周期事件可以被截获，并用于构造、反应和破坏。</p><p id="624d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这提供的范围意味着开发人员可以清理他们的文档级<code class="fe nk nl nm nn b">onLoad</code>和<code class="fe nk nl nm nn b">onUnload</code>回调。</p><p id="cc24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，对定制元素属性的更改可以以类似的方式做出反应。这允许本地化所有事件侦听器，将它们与组件的其余代码放在一起。</p><p id="3b84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">定义定制元素是一个简单的单行程序:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="e268" class="ns mn it nn b gy nt nu l nv nw">customElements.define('my-component', MyComponent);</span></pre><p id="e2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，第一个参数是定制元素名称，第二个参数是定义组件行为的JavaScript类。</p><p id="c332" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这条语句，自定义元素名称现在与HTML的预定义标记处于同等地位，可以像任何其他元素一样使用。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="22b0" class="ns mn it nn b gy nt nu l nv nw">&lt;body&gt;<br/>    &lt;h1&gt;Hello World!&lt;/h1&gt;<br/>    &lt;my-component&gt;&lt;/my-component&gt;<br/>&lt;/body&gt;</span></pre><p id="b4df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新组件的内部工作封装在这个标签中。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c7bd" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">2.隔离</h1><p id="0206" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">几年来，我忽略了组件革命，没有充分理解W3C发布的影子DOM(T21)规范。也许是这个不熟悉的名字，带有“曾经被移除”的含义。</p><p id="b530" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我现在认识到它是一种作用域技术，并充分肯定它为我最棘手的问题之一:CSS特异性规则提供了解决方案。</p><p id="0314" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">过去，我曾感叹过这样一个事实:再聪明的命名也不能帮助我写出正确定位元素的CSS。我在<a class="ae nj" href="https://medium.com/swlh/tws-017-why-the-hardest-part-of-css-is-specificity-75cf8bb1c44c" rel="noopener"> <em class="lz">为什么CSS最难的部分是特异性</em> </a>中详细探讨了这个问题。</p><p id="a5e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当时，似乎我声明的每个新CSS规则都会对完全不相关的元素产生一些意想不到的副作用。</p><p id="f52e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使我完全掌握了特异性的概念，我仍然发现很难找到没有副作用的解决方案。对我来说，设计牢不可破的CSS解决方案的能力还没有实现。</p><p id="e856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是暗影DOM适合它的地方。它在作用于<code class="fe nk nl nm nn b">document</code>的元素和自定义元素中定义的元素之间提供了防火墙。好处是既安全又简单。</p><p id="345d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我在组件中声明了超链接显示的特殊规则，这些规则不会泄露并覆盖组件外的超链接。</p><p id="3c19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">样式规则可以直接在<em class="lz">元素类型</em>上声明，简单如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干净的代码。我不再需要使用类名或标识符来定位组件中的元素。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="0413" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">3.分离</h1><p id="840f" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Web组件使用三种不同的语言:HTML用于模板化元素，CSS用于修饰元素，JavaScript用于控制与用户的交互。</p><p id="d44c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数开发人员都知道从<em class="lz">关注点分离</em>中获得的好处，所以没有必要在这里重复。奇怪的是，近年来，这一设计原则被公然忽视了。</p><p id="5361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是当坚持使用时，一个简单的模式出现了，使这三种语言和谐相处。</p><ul class=""><li id="5933" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nz lw lx ly bi translated">结构化标记被写成HTML <code class="fe nk nl nm nn b">template</code>，并保存到一个<code class="fe nk nl nm nn b">.html</code>文件中。</li><li id="c5e6" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated">装饰是使用CSS规则声明的，CSS规则保存在一个单独的<code class="fe nk nl nm nn b">.css</code>文件中。</li><li id="1583" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated">控制用户交互的脚本是用JavaScript编写的，保存在自己的<code class="fe nk nl nm nn b">.js</code>文件中。</li></ul><p id="0016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个模式中，组件的初始化放在<code class="fe nk nl nm nn b">.js</code>文件中，当定制元素被添加到DOM中时，由浏览器调用。</p><p id="9b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，JavaScript代码使用HTTP动态获取HTML模板和CSS规则，将它们添加到一个影子根:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。这三种语言是和谐的，关注点的分离保持不变。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5640" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">4.模块化</h1><p id="3277" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">定义本地名称空间是每一种主流编程语言都必须解决的一个共同需求。</p><p id="efeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript通过<code class="fe nk nl nm nn b">import/export</code>语句来实现这一点。这种语言特征消除了全球环境污染。好处是函数名可以短而甜。没有更多的<code class="fe nk nl nm nn b">initABC</code>和<code class="fe nk nl nm nn b">initXYZ</code>时，平原老<code class="fe nk nl nm nn b">init</code>就行了。</p><p id="2000" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我在这里特别谈论的是ES模块，而不是老派的<code class="fe nk nl nm nn b">require</code>语句。如果使用得当，组件的动态部分可以按需出现，只在需要时加载。</p><p id="3698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在HTML文档中使用它，请遵循这个新模式，确保指定了<code class="fe nk nl nm nn b">type='module'</code>属性:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="ff2d" class="ns mn it nn b gy nt nu l nv nw">&lt;head&gt;<br/>    &lt;script src='/my-component.js' type='module'&gt;&lt;/script&gt;<br/>&lt;/head&gt;</span></pre><p id="a0e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这样做时，组件的每一部分都会自动获得HTTP提供的缓存和压缩好处。这与捆扎机提供的一体化合并形成了对比。</p><p id="6f49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于这方面的更多信息，我在<a class="ae nj" href="https://medium.com/better-programming/2020-004-the-rollout-of-modules-is-complete-d25f04870284" rel="noopener"> <em class="lz">中探索了在ES模块的新世界中对捆绑机的需求日益减少的情况。模块的展示已经完成</em> </a>。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a98a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">5.分配</h1><p id="91b1" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">当组件完成时，可以在npm上发布，供网站应用程序使用。Npm是一个公共包管理器，最初是为Node.js库设计的，但它也适用于web组件。</p><p id="1415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个简单的<code class="fe nk nl nm nn b">package.json</code>文件足以描述组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="ac2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了安装组件，使用<code class="fe nk nl nm nn b">npm init</code>命令在网站的根目录下创建一个单独的<code class="fe nk nl nm nn b">package.json</code>文件。</p><p id="331c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">命令<code class="fe nk nl nm nn b">npm install my-component</code>用于下载组件并将其放在网站的<code class="fe nk nl nm nn b">node_modules</code>目录中。为了简洁起见，省略了设置npm、发布软件包和安装软件包的完整机制。</p><p id="6132" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好处是:组件创建者容易发布，更广泛地分发到JavaScript社区，以及组件消费者的语义版本化。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="1aed" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">6.用户化</h1><p id="1170" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">大多数组件将提供满足原始创建者需求的默认样式。这很少是组件消费者想要的。</p><p id="654a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件开发人员可以通过预测哪些CSS声明可能会引起反对并更改声明以从CSS变量中提取值来适应这些消费者。</p><p id="c823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最常见的定制类型与配色方案、组件定位和组件大小有关。明智地使用一般命名的变量效果最好。</p><p id="0043" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，因为shadow DOM隔离了元素，所以不需要创建像<code class="fe nk nl nm nn b">--my-component-width</code>这样的前缀名称。像<code class="fe nk nl nm nn b">--width</code>这样简单的名字就可以了。</p><p id="7c6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变量名应该用默认值声明，在组件的CSS文件中，在<code class="fe nk nl nm nn b">:host</code>选择器中，然后使用<code class="fe nk nl nm nn b">var()</code>语法应用到组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9be3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做时，使用者只需在应用程序的CSS中定位自定义元素名称并定义新的变量值，就可以覆盖这些默认值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8e91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">消费者受益于不必仅仅为了风格上的改变而放弃回购。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="584f" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">7.证明文件</h1><p id="d1b1" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">必须向消费者提供足够的说明、示例和参考资料，以便按预期使用组件。发布的<code class="fe nk nl nm nn b">readme </code>文件应该有这些部分:</p><ul class=""><li id="b933" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nz lw lx ly bi translated"><em class="lz">动机。</em>组件解决什么问题的陈述。</li><li id="a0f7" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">特色。</em>组件如何解决该问题的描述。</li><li id="c037" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">安装。</em>获取组件的链接，以及放置组件的位置。</li><li id="d511" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">配置。</em>描述如何使用向消费者公开的每个属性。</li><li id="77f0" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">举例。</em><code class="fe nk nl nm nn b">Hello World</code>演示如何让组件在HTML页面上工作。</li><li id="d438" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">定制。</em>可以被覆盖的所有CSS变量的列表。</li><li id="b801" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nz lw lx ly bi translated"><em class="lz">事件。</em>组件发出或消耗的事件列表及其在生命周期中的位置。</li></ul><p id="7b5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个列表中的前两项是描述性的:它们是卖点。接下来的三个是自然教程:一步一步的傻瓜指南。</p><p id="f909" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后两个是参考资料，因此用户不必阅读代码就能知道发生了什么。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="9777" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简洁起见，上面的代码示例一定是不完整的。对于感兴趣的读者，您可以在这些开源的符合W3C的web组件中看到所有七个方面的作用。</p><p id="4a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当开发除了最简单的<em class="lz"> Hello World之外的任何软件时！</em>对于应用程序，开发者必须想办法防止无关的代码干扰手头的任务。</p><p id="04c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这已经成为我们为自己创造的许多基本编码策略的催化剂，即:函数、对象、模块、局部变量和其他类似的作用域模式。</p><p id="965f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Web组件正好适合这个领域。</p></div></div>    
</body>
</html>