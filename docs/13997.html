<html>
<head>
<title>A Test-Driven-Development Implementation Using React, Jest, TypeScript, and Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React、Jest、TypeScript和Node的测试驱动开发实现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/surely-youre-joking-something-said-in-jest-76f512d66483?source=collection_archive---------7-----------------------#2022-10-24">https://betterprogramming.pub/surely-youre-joking-something-said-in-jest-76f512d66483?source=collection_archive---------7-----------------------#2022-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="013b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以搜索框组件为例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c2eda4f359edb4f6cf58d0a1c81c1933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YytSl1q0BKJTpPW_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帕特里克·托马索在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">学习通过TDD开发组件是令人畏惧的——所以让我们做一个快速的TDD实现，红绿重构，谈论实现的进展，一些问题，以及我们如何用一个真实的例子来解决它们。通常，我们将深入研究React、Jest、React-Testing-Library、Typescript和Node。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="bb3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们考虑一个相当无害的请求，请求一个类似于google搜索栏的React组件。我们将有少量的静态选择，所以我们不需要将它连接到后端API或进行API端过滤。</p><p id="4ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们需要一个简单的输入，允许您开始输入文本，并从后端API返回的值列表中弹出一个相关选项的悬挂列表。要做到这一点，用户应该能够点击其中一个来“选择”它，然后发出一个事件来影响应用程序的其余部分。我们将为这个实现使用缓存，并从失败的测试到实现构建它。如果我们要获得这个组件的用户故事，它可能看起来像这样:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="d58e" class="me mf iq ma b gy mg mh l mi mj">I am a user<br/>I want to see a list of options for country as I type in to the search bar<br/>So that I can select the correct country for me</span><span id="9e1d" class="me mf iq ma b gy mk mh l mi mj">given I am filling out a form<br/>when I click on the country textbox and type "Un"<br/>then a list of filtered countries should appear with "United Arab Emirates", "United Kingdom", and "United States" as options</span><span id="e3cb" class="me mf iq ma b gy mk mh l mi mj">given I am filling out the form, have typed in "Un", and am seeing the list of filtered countries<br/>when I click on a country<br/>then it should lock in my selection</span><span id="f27c" class="me mf iq ma b gy mk mh l mi mj">given I am filling out the form and have locked in a country selection<br/>when I click on the locked in selection<br/>then it should reset the selection and allow me to search again</span></pre><p id="f8ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们必须创建我们的测试文件和组件文件，以开始处理这些代码。我们称之为<code class="fe ml mm mn ma b">FilteredSearch.tsx</code>，在同一个文件夹里有一个好友<code class="fe ml mm mn ma b">FilteredSearch.test.tsx</code>。我将在这里添加一个基本的测试，它将无法启动我们(这是红绿重构中的“红色”)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，我们有了一个好的开始。我们有一个<code class="fe ml mm mn ma b">FilteredSearch</code>组件和一个失败测试的测试文件，但是等等，当我们的测试失败时，为什么会是一个好的开始呢？这是TDD的主要方法——红绿重构是在我们编写代码之前验证预期的一种方式。</p><p id="9492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们探索一下重构部分——下一步是相对简单的一步，添加一些具有“文本框”aria角色的东西，让我们通过测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经通过了测试，我们可能应该开始考虑我们可以对组件进行的下一个增量更改，以及如何测试它。因为我们知道我们的实现将过滤一组数据，并允许用户输入部分文本，所以我们应该有一些在用户输入文本后出现的列表，当没有文本时消失。让我们更新我们的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们已经开发了一些失败的测试(主要是因为options prop还没有实现),用来测试用户输入后应该出现的过滤列表。当options prop被实现时，这些测试中的一个将立即成功——当没有输入任何内容时，该测试确认元素不存在。</p><p id="ad4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了节省空间和促进重用，我已经先发制人地将<code class="fe ml mm mn ma b">options</code>列表定义移到了文件的顶部。现在我们需要重构组件，以便测试成功:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f98f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，为了方便我们新的<code class="fe ml mm mn ma b">options</code>列表，我们做了一些改动。我将为台词谈论他们，从新的<code class="fe ml mm mn ma b">option</code>道具的道具解构开始。</p><ul class=""><li id="8a78" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">我们需要那个<code class="fe ml mm mn ma b">options</code> prop来接收一个字符串列表，当用户输入他们的搜索时，这个列表将被过滤和显示</li><li id="3bb3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">然后我们需要储存一些<code class="fe ml mm mn ma b">searchText</code></li><li id="f742" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">能够管理用户输入文本时的状态</li><li id="4b64" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">我们也可以存储一些记忆化的内容；一个变量，指示是否存在一些搜索文本，这样我们就可以在列表出现时显示<code class="fe ml mm mn ma b">options</code>列表，以及一个div数组，该数组与文本后过滤选项相关联</li><li id="6c5a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">之后，我们通过将值设置为我们的<code class="fe ml mm mn ma b">searchText</code>状态来控制输入</li><li id="449a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">处理<code class="fe ml mm mn ma b">onChange</code>事件来捕获键入的文本</li><li id="7fc7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">当检测到搜索文本时，添加<code class="fe ml mm mn ma b">options</code>列表div。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进步很大！我们的搜索列出了一些选项，这些选项可以作为一个API调用(或者一个静态资源)的道具发送进来，并在用户输入文本时进行过滤。但是，我们已经注意到，这种经历是一种可怕的UX，因为缺乏更好的词。当用户在搜索框中键入内容时，我们添加的div会在高度上扩展，并将页面上的所有其他内容都推到它的下方，当选项被添加/删除时，它们的闪烁会非常分散注意力。</p><p id="dabc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里偶然发现了一些东西——如果我们让这个搜索组件管理悬停元素，它似乎有很多责任。似乎我们需要另一个组件来处理这些需求，将一个绝对定位的组件锚定在另一个组件之下，并将其从DOM流中移除，以便它可以出现在其他元素之上。</p><p id="5a90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还从其他关于该系统的会议中了解到，这种浮动内容在其他地方也是一种需求。听起来我们提前感受到了痛苦！让我们找到一个解决方案，为我们节省一些时间。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入挂钩和组件设计！</p><p id="7779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们负责确定一个元素在页面上的什么位置被绑定到一个钩子上，这个钩子接受一些子元素和一个引用。之后，它将决定我们的位置。让我们写一个测试，看看我们的钩子是否可以通过<code class="fe ml mm mn ma b">getBoundingClientRect()</code>检索元素的正确x和y:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="90ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经为上面所有重要的实现细节模拟了一个ref，并将元素定位在ref元素的top + height，然后是左边界。从这里开始，实现变得非常容易:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们为这里的需求添加一套测试。我们将从当前的<code class="fe ml mm mn ma b"> &lt;FilteredSearch /&gt;</code>实现中借用一个，因为我们想要呈现一个div并检查“文档”角色。我们还将检查它是否呈现了发送到其中的孩子。最后，它的位置是正确的(感谢<code class="fe ml mm mn ma b">useLocation</code>钩！):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，我们将首先模拟钩子，这样我们就不用担心底层的实现细节。我们将在ref存在的情况下测试锚的渲染，锚正在显示，但如果<code class="fe ml mm mn ma b">show</code>为假或目标ref为空，它也不会渲染。我们还将检查子元素是否被渲染，以及“顶部”和“左侧”样式属性是否被设置为基于被模仿的<code class="fe ml mm mn ma b">useLocation</code>钩子的正确值。</p><p id="555b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要实现组件本身:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="87b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过测试后，我们可以通过将当前的<code class="fe ml mm mn ma b">options</code>列表包装在<code class="fe ml mm mn ma b">&lt;FloatingAnchor /&gt;</code>组件中来修复<code class="fe ml mm mn ma b">&lt;FilteredSearch /&gt;</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，随着测试的通过，我们终于可以确信，我们的新组件集在我们当前的站点中可以如预期的那样运行了！运行代码会产生一个相当无害的输入，可以键入该输入来显示满足类型化过滤器的国家的锚定浮动列表。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fb91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要能够与过滤选项列表进行交互。让我们通过单击列表中的一个选项进行简单的测试来实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="93f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们在一个名为<code class="fe ml mm mn ma b">onOptionSelected</code>、<code class="fe ml mm mn ma b">fireEvent</code>的新事件处理程序道具上添加了一个事件间谍，用于键入初始文本，我们在过滤搜索中找到并单击目标选项文本。这将失败，因为我们还没有设置事件处理程序属性<code class="fe ml mm mn ma b">onOptionSelected</code>，也没有连接<code class="fe ml mm mn ma b">onClick</code>事件来使用它。让我们在主要组件中实现它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存后，我们就可以通过测试，将选中的选项事件发送给包含它的react代码，对它进行必要的处理。最有可能的是，这些数据存储在某个状态值中，用来确认“表单”是完整的，但是我们不做任何假设。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="2f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们只需要构建最后一个功能:选择“锁定”。当我使用这个控件搜索一个选项并单击它时，它应该显示我选择的值，如果再次单击选择的值，我应该能够更改它。这应该是一个非常简单的实现，所以让我们开始红绿重构，对我们在这里添加的函数进行额外的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试现在查找具有“note”角色的元素和所选元素的文本。如果两者都存在，我们就可以开始了！现在要修复组件的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="636d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个要实现的函数。当我们点击新添加的“锁定”选项时，我们需要能够选择一些新的东西。现在让我们来实现它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e74c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的组件满足了所有要求！另一个增加的功能是当锁定的选择被点击时清除搜索文本，或者其他UX的改进，比如CSS样式，使它不那么粗糙和容易。但是由于我们只是在讨论红绿重构的TDD过程和用例，我们就此打住。</p><p id="a5eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。敬请关注更多内容。</p></div></div>    
</body>
</html>