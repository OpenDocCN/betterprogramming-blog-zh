<html>
<head>
<title>An Intermediate Guide to RegEx in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中正则表达式的中级指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-intermediate-users-guide-to-regex-533bf5a67c03?source=collection_archive---------6-----------------------#2021-12-22">https://betterprogramming.pub/an-intermediate-users-guide-to-regex-533bf5a67c03?source=collection_archive---------6-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="622c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解原始字符串、方法调用模式、分组及其特征</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/584f418b369b7ec36d264123028406e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hss9Kla7SaHRfI6i"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@gautamarora1991?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gautam Arora </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="87f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的目标读者是:</p><ul class=""><li id="07af" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">理解编程的基本概念——对象、变量、函数</li><li id="f6d9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">理解Python语法—字符串、列表、循环</li><li id="ae7c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">熟悉正则表达式和简单正则元字符的用法，如<code class="fe mg mh mi mj b">*</code>、<code class="fe mg mh mi mj b">?</code>和<code class="fe mg mh mi mj b">\d</code></li><li id="70df" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">并且希望将他们的正则表达式工具包扩展到基本模式之外</li></ul><h1 id="2264" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">文章动机</h1><p id="133c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">经过几年的专业编码，我在堆栈溢出和代码库中遇到了许多正则表达式模式，但是直到最近我才完全理解了核心正则表达式的概念。</p><p id="207d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我经常在其他人的代码中看到一个构造，但是我以前完全没有想到，这个构造就是<code class="fe mg mh mi mj b">(?:…)</code>。</p><p id="7f0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在知道这被称为非捕获组，更重要的是，我应该什么时候使用它。</p><p id="63c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为我(以及我的同行)无知的原因是，大量在线正则表达式教程讨论的是特定用例的解决方案，比如检测名称或日期，而不是构建基础知识。</p><p id="3522" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我决定研究RegEx，并对它进行深入的实验…本文试图记录我的学习成果，并与社区中的其他人分享。</p><p id="abbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nh">(剧透)</em>:解锁RegEx很多强大功能的主要成分是<code class="fe mg mh mi mj b">Grouping</code>，正确理解它对你大有裨益。我将在本文中讨论这一点以及更多。</p><p id="bfbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我回顾一下与RegEx相关的一些基础概念，您可能知道也可能不知道。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="de85" class="mk ml iq bd mm mn np mp mq mr nq mt mu jw nr jx mw jz ns ka my kc nt kd na nb bi translated">1.原始字符串</h1><p id="44c5" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Python中的“原始字符串”是通过在字符串前面加上<code class="fe mg mh mi mj b">r</code>或<code class="fe mg mh mi mj b">R</code>来创建的，比如:<code class="fe mg mh mi mj b">r”Hello world”</code>。</p><p id="e1af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常规字符串和原始字符串的区别在于，原始字符串将反斜杠(<code class="fe mg mh mi mj b">'\’</code>)视为文字字符。</p><p id="93e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在常规的Python字符串中，反斜杠用于表示转义序列，如<code class="fe mg mh mi mj b">\n</code>(换行符)、<code class="fe mg mh mi mj b">\r</code>(回车符)或<code class="fe mg mh mi mj b">\t</code>(制表符)。</p><p id="ea6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以当我们想要创建一个包含反斜杠的字符串，并且不想让它被当作转义字符时，我们使用原始字符串。</p><p id="3ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们使用原始字符串在Python中创建正则表达式字符串。因为RegEx引擎以一种特殊的方式解释反斜杠，而我们不希望Python因为自己对反斜杠的解释而修改字符串。</p><p id="1cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自Python的官方文档:</p><blockquote class="nu nv nw"><p id="44b3" class="kw kx nh ky b kz la jr lb lc ld ju le nx lg lh li ny lk ll lm nz lo lp lq lr ij bi translated">正则表达式使用反斜杠字符(<code class="fe mg mh mi mj b">'\'</code>)来表示特殊形式，或者允许使用特殊字符而不调用它们的特殊含义。这与Python在字符串文字中出于相同目的使用相同字符的做法相冲突；例如，要匹配一个文字反斜杠，可能必须将<code class="fe mg mh mi mj b">'\\\\'</code>写成模式字符串，因为正则表达式必须是<code class="fe mg mh mi mj b">\\</code>，并且每个反斜杠必须在一个常规Python字符串文字中表示为<code class="fe mg mh mi mj b">\\</code>。另外，请注意，Python在字符串中使用反斜杠时，任何无效的转义序列现在都会生成一个<code class="fe mg mh mi mj b"><a class="ae kv" href="https://docs.python.org/3/library/exceptions.html#DeprecationWarning" rel="noopener ugc nofollow" target="_blank">DeprecationWarning</a></code>，将来它会变成一个<code class="fe mg mh mi mj b"><a class="ae kv" href="https://docs.python.org/3/library/exceptions.html#SyntaxError" rel="noopener ugc nofollow" target="_blank">SyntaxError</a></code>。即使它是正则表达式的有效转义序列，也会发生这种行为。</p></blockquote><p id="e213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">要点:</strong>虽然没有必要使用原始字符串来创建Python中的正则表达式模式，但是强烈建议这样做。你会看到很多程序员使用Python中的原始字符串创建正则表达式模式。</p><h1 id="72d6" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">2.<code class="fe mg mh mi mj b">re</code>中方法调用的两种模式</h1><p id="766c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">首先，Python的RegEx模块<code class="fe mg mh mi mj b">re</code>中只有4个匹配函数。我所说的匹配函数是指在正则表达式模式和目标字符串之间执行实际模式匹配的函数:</p><ol class=""><li id="02ab" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">match(...)</code> —返回目标字符串中的第一个匹配子字符串，作为<code class="fe mg mh mi mj b">re.Match</code>对象(如果在字符串的开头找到)</li><li id="55e3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">search(...)</code> —返回目标字符串中的第一个匹配子字符串，作为一个<code class="fe mg mh mi mj b">re.Match</code>对象，可在字符串中的任何位置找到</li><li id="1fc4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">findall(...)</code> —以字符串列表的形式返回目标字符串中所有匹配的子字符串</li><li id="4b40" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">finditer(...)</code> —返回目标字符串中所有匹配子字符串的<code class="fe mg mh mi mj b">re.Match</code>对象的迭代器</li></ol><p id="581e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe mg mh mi mj b">re</code>模块实际上允许您以两种等价的方式调用所有4个匹配的函数——或者</p><ol class=""><li id="f974" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated">通过编译正则表达式模式字符串(<code class="fe mg mh mi mj b">p = re.compile(regex_pattern)</code>)创建的<code class="fe mg mh mi mj b">re.Pattern</code>对象，或者</li><li id="f505" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated">通过模块级函数(<code class="fe mg mh mi mj b">re.search()</code>举例)</li></ol><p id="4a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法1的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模式级调用</p></figure><p id="d03c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法2的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模块级调用</p></figure><p id="fcef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个模块中调用方法的两种方式都会产生相同的结果。为了美观，你可能更喜欢其中一个，但仅此而已。</p><p id="e598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">性能也相当，因为<code class="fe mg mh mi mj b">re</code>模块缓存了您的模式对象。因此，重复调用模块级函数并不比对同一个RegEx字符串使用预编译的模式对象更糟糕。</p><p id="feb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">要点:</strong>在Python的RegEx模块中有两种使用匹配函数的等效方法。你会在栈溢出和代码库中看到这两种类型的代码，但是不要强调这两种类型的区别，因为它们是等价的。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="4563" class="mk ml iq bd mm mn np mp mq mr nq mt mu jw nr jx mw jz ns ka my kc nt kd na nb bi translated">分组</h1><p id="84b9" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">最后，让我们分组讨论。</p><p id="f40f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在正则表达式模式中，组是由圆括号括起来的任何东西。</p><p id="6012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，在<code class="fe mg mh mi mj b">(</code>和<code class="fe mg mh mi mj b">)</code>元字符之间的任何东西都是一个组。</p><p id="98d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从概念上讲，它们的解释方式与数学表达式中圆括号表达式的解释方式相同。</p><p id="fb79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当你在一个代数表达式中看到<code class="fe mg mh mi mj b">(2+3)*5</code>时，你知道<code class="fe mg mh mi mj b">2+3</code>是它自己的实体，或者一个组，根据BODMAS法则，它在其他任何东西之前被求值。</p><p id="22ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，在RegEx模式<code class="fe mg mh mi mj b">r”(ab)c”</code>中，<code class="fe mg mh mi mj b">ab</code>是一个组。</p><p id="bce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用组有很多好处。首先，正则表达式组可以单独检索，也可以与其他组一起检索。</p><p id="ce59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还可以与其他元字符如<code class="fe mg mh mi mj b">*</code>结合起来创建有意义的模式。</p><p id="b0bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如,<code class="fe mg mh mi mj b">r”(ab)*c”</code>将捕捉表达式，其中有0个或多个组<code class="fe mg mh mi mj b">ab</code>的实例，后跟一个<code class="fe mg mh mi mj b">c</code>。</p><p id="5694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，<code class="fe mg mh mi mj b">r”(ab)?c”</code>将捕获为<code class="fe mg mh mi mj b">"c"</code>或<code class="fe mg mh mi mj b">"abc"</code>的字符串(允许组<code class="fe mg mh mi mj b">ab</code>的0或1个实例)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e088" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是团队。现在让我们看看RegEx中一些重要的分组特性:</p><h2 id="ec43" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated">分组特征#1</h2><p id="fb5b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">一旦将包含组的正则表达式模式与目标字符串匹配，就可以通过调用<code class="fe mg mh mi mj b">re.Match</code>对象上的<code class="fe mg mh mi mj b">.group()</code>或<code class="fe mg mh mi mj b">.groups()</code>来分别或共同检索匹配中的单个组(存储在<code class="fe mg mh mi mj b">re.Match</code>对象中)。</p><p id="64df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我上面提到的，通过调用<code class="fe mg mh mi mj b">re</code>模块的4个匹配函数之一，返回一个<code class="fe mg mh mi mj b">re.Match</code>对象。</p><p id="e92b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="586a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们检索了正则表达式模式中的第一个，也是唯一的一个组。是的，组的索引从1开始，而不是0。</p><p id="2c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上<code class="fe mg mh mi mj b">m.group(0)</code>是一个特例，因为它返回整个匹配的字符串，而不是任何单独的组。上例中，那就是<code class="fe mg mh mi mj b">abc</code>。</p><p id="e48a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe mg mh mi mj b">m.group(0)</code>相当于说<code class="fe mg mh mi mj b">m.group()</code>，或者不向方法传递任何参数，因为默认参数是0。</p><p id="8a71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能就是为什么组的索引从1开始——<code class="fe mg mh mi mj b">re</code>的开发者想为这个特殊函数保留0？</p><p id="83c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，当你在Stackoverflow上看到RegEx代码时，大多数时候，匹配的字符串是通过在match对象上调用<code class="fe mg mh mi mj b">.group()</code>返回的。</p><h2 id="22c8" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated">分组功能#2</h2><p id="f08f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">分组的第二个重要特性是，以后可以在相同的正则表达式模式中引用一个组。</p><p id="b625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使您可以动态地引用目标字符串中的子字符串，而无需事先确切知道它是什么。</p><p id="1f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将反斜杠与组索引结合使用。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe mg mh mi mj b">\1</code>与组<code class="fe mg mh mi mj b">ab</code>匹配，因为它是正则表达式模式中的第一个组。</p><h2 id="c5c4" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated">分组功能#3 —非捕获组</h2><p id="a384" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在我们来看看文章开头提到的特征——非捕获组。</p><p id="52f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您的小组以问号和冒号<code class="fe mg mh mi mj b">?:</code>开头时，它被称为非捕获小组。</p><p id="e20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以将之前的RegEx模式修改为<code class="fe mg mh mi mj b">r”(?:ab)c”</code>，以指示组<code class="fe mg mh mi mj b">ab</code>为“非捕获”。</p><p id="23fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，您是在告诉RegEx引擎不要费心记住这个组，因为您对以后引用它或单独检索它不感兴趣。</p><p id="a98e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看实际情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">试图引用非捕获组</p></figure><p id="6b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将返回一个错误，因为我们试图在表达式的后面用<em class="nh">引用</em>一个组，但是没有要引用的捕获组。</p><p id="452e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看另一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尝试检索非捕获组</p></figure><p id="d5b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次我们得到了一个错误，因为我们试图从匹配的对象中检索第一个组(索引从1开始)，但是和以前一样，没有捕获的组。</p><p id="2012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于大型复杂的正则表达式模式很有用，在这种情况下，您可能有许多不同的组，但是您只对引用或检索其中的一些感兴趣。</p><p id="8d92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python中RegEx组的一个相关特性是命名组，您可以给组命名，然后通过名称引用它们。</p><p id="3396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。这就是核心的分组逻辑和一些重要的分组特性。如果您想练习一些正则表达式代码，现在是暂停并消化上述概念的好时机。</p><p id="5b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的其余部分讨论了更多利用组的正则表达式特性，我认为它们也非常有用。</p><p id="0f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将它们称为中间特性，但我知道这是主观的，所以请不要全信。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="b423" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated">m组()与m组()</h2><p id="3d83" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这是两个非常常见的正则表达式方法，一旦你理解了组，就很容易理解，但是为了全面起见，提到它们是很重要的。</p><ol class=""><li id="1931" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">m.groups()</code>给出正则表达式和目标字符串匹配的所有捕获组的列表。可以想象，非捕获组不包括在内。</li><li id="dd3f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">m.group([group1, …])</code>给出对应于索引参数的特定组。如果您指定多个组索引，您将获得一个相应组字符串的元组。如前所述，<code class="fe mg mh mi mj b">m.group()</code>或<code class="fe mg mh mi mj b">m.group(0)</code>将返回整个匹配的字符串。</li></ol><p id="fb07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看实际情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们分析一下上面的RegEx模式中发生了什么。该模式希望目标字符串包含以下内容:</p><ul class=""><li id="63b5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">开始时应该至少有1个<code class="fe mg mh mi mj b">ab</code>，但是可以有很多个，一个接一个(这就是元字符<code class="fe mg mh mi mj b">+</code>的含义)。另外，<code class="fe mg mh mi mj b">ab</code>是第一个捕获组</li><li id="90fe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">这后面应该是字母<code class="fe mg mh mi mj b">c</code></li><li id="bcb2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">这后面应该是<code class="fe mg mh mi mj b">de</code>，这是我们的第二个捕捉组</li><li id="e538" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接下来应该是我们的第一个捕获组</li><li id="9da0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">最后，这后面应该跟一个<code class="fe mg mh mi mj b">f</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="adf6" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated"><code class="fe mg mh mi mj b">findall()</code> vs. finditer()</h2><p id="aea0" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这是另一个重要的二分法，它让我困惑了很久:</p><ol class=""><li id="7a44" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe mg mh mi mj b">findall()</code>:顾名思义，这将返回一个RegEx模式和目标字符串之间所有匹配的列表，按照它们被找到的顺序。但是实际上有三种不同的场景使用这个函数，每一种都给出不同类型的结果。首先，让我们定义一个目标字符串，我们将根据它来匹配正则表达式模式:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="10c2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">场景1 </strong>:如果您的正则表达式中没有使用任何捕获组，<code class="fe mg mh mi mj b">findall()</code>将返回与整个正则表达式模式匹配的所有子字符串的列表。简单。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="d4f1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">场景2 </strong>:如果您在正则表达式中使用1个捕获组，<code class="fe mg mh mi mj b">findall()</code>将返回一个列表，列出所有<em class="nh">匹配该组</em>的子字符串(不是全部匹配的子字符串)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，这只返回<code class="fe mg mh mi mj b">['ab', 'ab', 'ab']</code>，而不是<code class="fe mg mh mi mj b">['ab c', 'ab c', 'ab c']</code>。</p><p id="2547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这里还有另一个微妙之处——子串<code class="fe mg mh mi mj b">ab test</code>不会被捕获，因为其中没有<code class="fe mg mh mi mj b">ab c</code>。</p><p id="c8b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为在这种情况下,<code class="fe mg mh mi mj b">.findall()</code>返回的是所有<code class="fe mg mh mi mj b">ab</code>出现的列表，你可能认为答案中会有4个<code class="fe mg mh mi mj b">ab</code>。</p><p id="6dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但事实并非如此，因为正则表达式模式<code class="fe mg mh mi mj b">r"(ab) c"</code>与<code class="fe mg mh mi mj b">"ab test"</code>不匹配。</p><ul class=""><li id="cc5b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">场景3 </strong>:如果在正则表达式模式中使用多个捕获组(多于1个)，<code class="fe mg mh mi mj b">findall()</code>将返回所有匹配的所有组的元组列表，格式为<code class="fe mg mh mi mj b">[..(&lt;group 1&gt;, &lt;group 2&gt;…, &lt;group m&gt;)..]</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来如此。</p><p id="fa34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，在我阅读它的文档之前，我经常被这个函数绊倒，我仍然不知道它的有效用例。</p><p id="0ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将它包含在这里只是为了消除它的神秘性，但我不会在我的代码中使用它。</p><p id="5353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我想要一个字符串中正则表达式模式的所有匹配，我使用<code class="fe mg mh mi mj b">finditer()</code>函数，解释如下:</p><p id="9e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe mg mh mi mj b">finditer()</code>:这个函数返回一个迭代器(read: Lazy Evaluation)来迭代目标字符串中RegEx模式的所有匹配(不管RegEx模式中有多少个组)。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代器对象中的对象类型是<code class="fe mg mh mi mj b">re.Match</code>，可以用来访问整个匹配的子串(<code class="fe mg mh mi mj b">m.group()</code>)，或者访问特定的组，比如so <code class="fe mg mh mi mj b">m.group(1, 2)</code>。</p><h2 id="11e8" class="od ml iq bd mm oe of dn mq og oh dp mu lf oi oj mw lj ok ol my ln om on na oo bi translated">使用格式化字符串创建正则表达式模式</h2><p id="97ba" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如果您想动态地创建正则表达式，也许是为了将用户输入合并到模式中，您可以将格式化的字符串传递给Python中的RegEx引擎。</p><p id="dde7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所知，格式化的字符串，用<code class="fe mg mh mi mj b">f"..."</code>表示，计算花括号<code class="fe mg mh mi mj b">{…}</code>中的表达式，并将结果插入字符串中。</p><p id="2f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以如果<code class="fe mg mh mi mj b">variable1 = "world”</code>，那么格式化字符串<code class="fe mg mh mi mj b">f“Hello {variable1}”</code>的值就是<code class="fe mg mh mi mj b">“Hello world”</code>。</p><p id="f8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将格式化字符串传递给RegEx引擎并不奇怪，因为格式化字符串实际上就是一个字符串。</p><p id="3ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，你可能不知道你可以做一个格式化的原始字符串！例如<code class="fe mg mh mi mj b">a = fr"Hello {variable1} \d"</code>也是一个有效的字符串。</p><p id="b89c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果没有细微的差别，这一部分将会很无聊，所以这里是这样的:当你想在你的正则表达式模式中使用花括号<code class="fe mg mh mi mj b">{}</code>时会发生什么，它表示正则表达式引擎中的重复限定符？</p><p id="aa86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，花括号在格式化字符串中有特殊的用途，所以它们将由格式化字符串构造来解释，而您的最终字符串实际上没有花括号。</p><p id="2750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe mg mh mi mj b">r"hello{1,4}"</code>作为RegEx模式意味着匹配字符串至少需要有<code class="fe mg mh mi mj b">1</code> <code class="fe mg mh mi mj b">hello</code>，并且可以有多达<code class="fe mg mh mi mj b">4</code> <code class="fe mg mh mi mj b">hello</code>的重复。但是对于一个格式化的字符串，它意味着别的东西。</p><p id="8cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<code class="fe mg mh mi mj b">fr"hello{1,4}"</code>实际上等于<code class="fe mg mh mi mj b">“hello(1, 4)”</code>，因为Python中的格式化字符串结构将<code class="fe mg mh mi mj b">1,4</code>解释为一个元组。</p><p id="f177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">回答:</strong>为了保留被求值的字符串中的花括号，需要用双花括号对其进行转义！所以构建这个模式的正确方法是<code class="fe mg mh mi mj b">fr"hello{{1,4}}"</code>，会翻译成<code class="fe mg mh mi mj b">"hello{1,4}"</code>。</p><p id="0552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。这是我目前所有的正则表达式内容。希望您能从这篇文章中获得一些有用的东西。</p></div></div>    
</body>
</html>