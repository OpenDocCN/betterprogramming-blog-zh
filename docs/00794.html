<html>
<head>
<title>UICollectionView With Autosizing Cells Based on Texts or Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于文本或图像自动调整单元格大小的UICollectionView</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uicollectionview-with-autosizing-cell-based-on-items-text-image-814cc0e93302?source=collection_archive---------5-----------------------#2019-07-15">https://betterprogramming.pub/uicollectionview-with-autosizing-cell-based-on-items-text-image-814cc0e93302?source=collection_archive---------5-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0fb4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">源代码和调整单元格高度的说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08e887787d5894e39f8ed5b61930020e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qmBczD1HjiLKR9OV-z9nA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pemmax?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Przemyslaw Marczynski </a>在<a class="ae ky" href="https://unsplash.com/search/photos/ios?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bf47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:该方法已经在iOS以上版本上使用基础SDK </em>进行了测试</p><p id="e153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经使用了默认的流布局UIKit提供的一个布局类，它由一个基本的网格布局和一些定制组成——但是您也可以实现您自己的定制布局，以您喜欢的任何方式排列视图。这就是集合视图如此灵活和强大的原因。</p><p id="36b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可能使用了自动布局，并在单元格的宽度上添加了<strong class="lb iu"> </strong>约束<strong class="lb iu"> </strong>，或者从单元格中的最后一个元素到底部锚定单元格。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="b94d" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">介绍</h2><p id="76cf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在这篇文章中，我将讨论使用<em class="lv">自定义视图布局</em> <strong class="lb iu">来调整单元格的大小。我在想如何让单元格尽可能地多用途，以便它们完全依赖于我们放在那里的数据，例如图片或文本。由于图片的一切都要简单得多，我们可以从属性中识别它的高度，例如<code class="fe nb nc nd ne b">UIImageView.size.height</code>，但是文本要复杂得多，因为它取决于字体的类型、一行中单元格的数量、边距和填充。因为我们“硬编码”<em class="lv"/>单元的高度，我决定在构建它们时缓存我的<code class="fe nb nc nd ne b">customLayout</code>单元属性。我们开始吧！</strong></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f07a" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">创建自定义集合视图布局</h1><p id="85e7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">创建令人惊叹的集合视图的第一步是为您的项目创建一个自定义布局类。</p><p id="8d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们创建了一个实现了<code class="fe nb nc nd ne b">UICollectionViewLayout</code>的类之后，在这里是<code class="fe nb nc nd ne b">AdaptiveCollectionLayout</code>，在xCode中将它添加到<code class="fe nb nc nd ne b">collectionView</code>中。如果您构建并运行您的应用程序，您将看到一个空的收藏视图。信不信由你，这是一个好兆头。这意味着集合视图正在使用您的自定义布局类。单元格还没有显示出来，因为<code class="fe nb nc nd ne b">AdaptiveCollectionLayout</code>类还没有实现布局过程中涉及的任何方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bc91" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">核心布局流程</h1><p id="d39b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">花点时间思考一下集合视图布局过程，这是集合视图和布局对象之间的协作。当集合视图需要布局信息时，它会要求您的布局对象通过以特定顺序调用某些方法来提供这些信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2bc246bff2d54509971839b84be3d9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/0*yqohckgJwOeWN5og.png"/></div></figure><p id="6db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布局子类必须实现以下方法:</p><ul class=""><li id="3ef6" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe nb nc nd ne b">collectionViewContentSize</code>:该方法返回集合视图内容的宽度和高度。您必须覆盖它，然后返回整个集合视图内容的高度和宽度，而不仅仅是可见内容。集合视图在内部使用此信息来配置其滚动视图的内容大小。</li><li id="5fb1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nb nc nd ne b">prepare()</code>:每当一个布局操作将要发生时，这个方法被调用。这是您准备和执行确定集合视图的大小和项目位置所需的任何计算的机会。</li><li id="54b4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nb nc nd ne b">layoutAttributesForElements(in:)</code>:在这个方法中，您需要返回给定矩形内所有项目的布局属性。您将属性作为一个数组<code class="fe nb nc nd ne b">UICollectionViewLayoutAttributes</code>返回给集合视图。</li><li id="60fe" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nb nc nd ne b">layoutAttributesForItem(at:)</code>:该方法为集合视图提供按需布局信息。您需要覆盖它，并在请求的<code class="fe nb nc nd ne b">indexPath</code>返回项目的布局属性。</li></ul><p id="db39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，那么你知道你需要实现什么——但是你如何着手计算这些属性呢？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cd06" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">计算布局属性</h1><p id="4c8b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">对于这种布局，您需要动态计算每个项目的高度，因为您事先不知道照片的高度或文本的长度。我们将声明一个协议，在<code class="fe nb nc nd ne b">AdaptiveCollectionLayout</code>需要时提供这些信息。</p><p id="c2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码声明了<code class="fe nb nc nd ne b">AdaptiveCollectionLayoutDelegate</code>协议，它有一个请求单元格高度的方法。您将很快在<code class="fe nb nc nd ne b">YourViewController</code>中实现这个协议。</p><p id="3ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现布局方法之前，还有一件事要做；您需要声明一些有助于布局过程的属性。</p><blockquote class="of og oh"><p id="cd13" class="kz la lv lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">在我们开始之前。让我们创建一个配置swift文件来定义属性，其中一个基础结构</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这段代码定义了一些属性，您稍后将需要这些属性来提供布局信息。</p></figure><p id="7ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们计算集合视图项目的属性，现在它将由框架组成。要理解这是如何工作的，请看下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3f5661e930ea2f8b59215ea1d61864c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/0*NhepxOFtS5wfedqB.png"/></div></figure><p id="aa29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将根据每一项的列(由<code class="fe nb nc nd ne b">xOffset</code>跟踪)和同一列中前一项的位置(由<code class="fe nb nc nd ne b">yOffset</code>跟踪)来计算每一项的帧。</p><p id="41fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算水平位置，我们将使用项目所属列的起始X坐标，然后添加单元格填充。垂直位置是该列中前一项的起始位置加上前一项的高度。项目的总高度是图像高度和内容填充的总和。</p><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将在<code class="fe nb nc nd ne b">prepare()</code>中这样做，在这里我们为布局中的每个项目计算一个<code class="fe nb nc nd ne b">UICollectionViewLayoutAttributes</code>实例。</p><p id="a57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:检查代码中的注释。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您可以看到您的布局运行之前，您需要实现布局委托。例如<code class="fe nb nc nd ne b">MyCollectionAdapter</code>在计算属性框架的高度时，依靠这个来提供文本注释高度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="of og oh"><p id="c95b" class="kz la lv lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">注意:不要忘记为你的布局添加代理</p></blockquote><p id="f183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候看看事情是如何发展的了！构建并运行您的应用程序。您会看到单元格根据文本的长度正确定位和调整大小:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/ecc6d500099eb7bf11796923cfb31538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwXVdxkn5YNQKzCL-qkYIw.png"/></div></div></figure></div></div>    
</body>
</html>