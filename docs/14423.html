<html>
<head>
<title>Stop Using Implicit Inputs and Outputs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用隐式输入和输出</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-implicit-inputs-and-outputs-in-python-970d9d271057?source=collection_archive---------2-----------------------#2022-12-13">https://betterprogramming.pub/stop-using-implicit-inputs-and-outputs-in-python-970d9d271057?source=collection_archive---------2-----------------------#2022-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="57f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高代码可测试性和可重用性的一个简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b17d838ee29cd1b238e865e03ffb3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbsKJynoTbfW0gTNgm3onw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由goodstudio通过Canva.com提供</p></figure><p id="f92e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与Python开发者相处足够长的时间，你会听到所有关于Tim Peter的关于Python的<em class="lu">禅。</em></p><p id="7740" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在Python REPL中执行<code class="fe lw lx ly lz b">import this</code>，你可以<a class="ae lv" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">方便地阅读</a>的<em class="lu">禅</em>，它展示了Python设计背后的20条指导原则中的19条。最近，我开始更欣赏一句格言:“明确的比含蓄的好。”</p><p id="470e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我见过的最常见的解释是，冗长的代码比简洁的代码更好，因为显而易见，冗长是可读性的关键……或者其他什么。</p><p id="9f31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，使用更好的变量名和用命名的常量(或者在Python中是“常量”)替换<a class="ae lv" href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="noopener ugc nofollow" target="_blank">幻数</a>都是很棒的事情。但是你上一次在代码中找到隐式输入并使它们显式化是什么时候？</p><h1 id="8fd2" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">如何识别隐含的输入和输出</h1><p id="269b" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">下列函数有多少输入和输出？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2b61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lw lx ly lz b">find_big_numbers()</code>没有参数，总是返回<code class="fe lw lx ly lz b">None</code>。如果你看不到函数体，不能访问<a class="ae lv" href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)" rel="noopener ugc nofollow" target="_blank">标准输出流</a>，你会相信这个函数做了什么吗？</p><p id="b6fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，<code class="fe lw lx ly lz b">find_big_numbers()</code>除了<code class="fe lw lx ly lz b">None</code>还有两个输入和一个输出:</p><ul class=""><li id="8d09" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated"><code class="fe lw lx ly lz b">numbers.txt</code>是隐式输入。没有它函数就不行，但是不读函数体是不可能知道文件是需要的。</li><li id="1c14" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">第6行的幻数<code class="fe lw lx ly lz b">100</code>是一个隐式输入。没有它你不能定义一个“大数”，但是不读函数体也没办法知道那个阈值。</li><li id="2b8c" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">数值可能会也可能不会打印到<code class="fe lw lx ly lz b">stdout</code>，这取决于<code class="fe lw lx ly lz b">numbers.txt</code>的内容。这是一个隐式输出，因为该函数不返回这些值。</li></ul><p id="d4b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">隐性输出通常被称为副作用。</p><h2 id="f85c" class="nn mb it bd mc no np dn mg nq nr dp mk lh ns nt mm ll nu nv mo lp nw nx mq ny bi translated">你自己试试</h2><p id="cb16" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在下面的代码片段中确定<code class="fe lw lx ly lz b">is_adult</code>函数的所有输入和输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8182" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">为什么应该避免隐式输入和输出</h1><p id="f416" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">一个很好的理由是他们倾向于违反最小惊喜原则。</p><p id="8c82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，并不是所有的隐性投入和产出都是不好的。Python文件对象使用类似于<code class="fe lw lx ly lz b">.write()</code>的方法将数据写入文件，该方法有一个隐式输出:文件。没有办法消除。但这并不奇怪。写入文件是关键所在。</p><p id="afdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，前面代码片段中类似于<code class="fe lw lx ly lz b">is_adult()</code>的函数做了很多令人惊讶的事情。不那么极端的例子比比皆是。</p><blockquote class="nz oa ob"><p id="216d" class="ky kz lu la b lb lc ju ld le lf jx lg oc li lj lk od lm ln lo oe lq lr ls lt im bi translated"><strong class="la iu">提示:</strong>在GitHub上通读一些你最喜欢的库的代码，看看你是否能发现隐含的输入和输出，这是一个很好的练习。问问你自己:他们中有让你吃惊的吗？</p></blockquote><p id="8d66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">避免隐式输入和输出也提高了代码的可测试性和可重用性。为了了解如何实现，让我们重构前面的<code class="fe lw lx ly lz b">find_big_numbers()</code>函数。</p><h1 id="560e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">如何移除隐式输入和输出</h1><p id="373a" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">这里又是<code class="fe lw lx ly lz b">find_big_numbers()</code>，所以你不必向上滚动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前面，我们确定了两个隐式输入，即<code class="fe lw lx ly lz b">numbers.txt</code>文件和数字<code class="fe lw lx ly lz b">100</code>，以及一个隐式输出，即打印到<code class="fe lw lx ly lz b">stdout</code>的值。让我们先处理输入。</p><p id="4d0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将文件名和阈值移动到函数的参数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="03a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经极大地提高了可测试性和可重用性。如果您想在不同的文件上尝试，请将路径作为参数传递。(另外，该文件现在可以放在计算机上的任何地方。)如果需要，您还可以更改“大数字”的阈值。</p><p id="0477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是输出很难测试。</p><p id="6095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道函数产生了正确的值，你需要截取<code class="fe lw lx ly lz b">stdout</code>。有可能。但是为什么不返回所有值的列表呢:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ea91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在<code class="fe lw lx ly lz b">find_big_numbers()</code>有了一个显式的<code class="fe lw lx ly lz b">return</code>语句，返回在文件中找到的大数字列表。</p><p id="f63d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以测试<code class="fe lw lx ly lz b">find_big_numbers()</code>,方法是使用已知内容的文件路径调用它，并将返回的列表与正确值列表进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1443" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lw lx ly lz b">find_big_numbers()</code>现在也更加可重用了。您不限于将数字打印到<code class="fe lw lx ly lz b">stdout</code>。你可以把那些大数字送到任何你想去的地方。</p><h1 id="c915" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">让我们回顾一下:</h1><p id="2fc3" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">隐式输入是函数或程序使用的数据，它们不作为参数显式传递。您可以通过将隐式输入重构为参数来消除它们。</p><p id="eedd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">隐式输出是发送到函数或程序外部的数据，这些数据不会显式返回。您可以通过用合适的返回值替换显式输出来移除它们。</p><p id="5372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并不是所有的隐式输入和输出都可以避免，比如目的是从文件和数据库中读取或写入数据或者发送电子邮件的函数。尽管如此，尽可能多地消除隐式输入和输出可以提高代码的可测试性和可重用性。</p><p id="a389" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以这里有一个带回家的问题:我们是否从<code class="fe lw lx ly lz b">find_big_numbers()</code>中移除了所有隐含的输入和输出？</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="3f9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">好奇Python的禅宗里第二十行怎么了？互联网上流传着各种各样的理论。</em> <a class="ae lv" href="https://stackoverflow.com/questions/4504487/the-zen-of-python-distils-the-guiding-principles-for-python-into-20-aphorisms-bu/24814971#24814971" rel="noopener ugc nofollow" target="_blank"> <em class="lu">这一个</em> </a> <em class="lu">在我看来相当有可能。</em></p><p id="9709" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">本文最初发表在《好奇的代码》时事通讯上。</em> <a class="ae lv" href="https://davidamos.dev/curious-about-code-newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="lu">订阅此处</em> </a> <em class="lu">抢先看每期。</em></p></div></div>    
</body>
</html>