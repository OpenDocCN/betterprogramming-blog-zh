# 围棋中的轻量级模式

> 原文：<https://betterprogramming.pub/the-flyweight-pattern-in-go-a0712764195a>

## 通过与其他对象共享数据来最小化内存使用

![](img/88e71c113b32f0a04277ceb39a91ec05.png)

罗伯特·克里斯在 [Unsplash](https://unsplash.com/s/photos/fly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

[定义](https://en.wikipedia.org/wiki/Flyweight_pattern):

> Flyweight 是一种软件设计模式。flyweight 是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象；当简单的重复表示会使用不可接受的内存量时，这是一种大量使用对象的方法。—维基百科

在下面，我将在 [Go](https://golang.org/) 中用两个例子演示 flyweight 模式。首先，我将优化依赖于相同底层数据的两个基于内存的缓存，然后我将优化另一个包含重复数据的缓存。

我们开始吧。所有的例子都是用 Golang 写的，完整的例子在附录中提供。

# 序文

对于这两个示例，请考虑以下类型:

玩家定义。

游戏平台上的玩家。这有点做作，但对我们的目的来说相当简单。示例:

一号玩家。

# 第一个例子:一个缓存，三种查找方法

假设我们希望将应用程序中的每一个`Player`都缓存在内存中以便快速访问，我们需要能够通过`ID`、`Handle`和国家`Code`来查找它们。第一个(简单的)实现可能如下所示:

包含相同玩家的三个数据结构。

通过循环遍历各个表行，用数据库中的数据填充它们，对于每一行，用每行中的字段填充一个`Player`实例，并将其添加到每个地图中。

使用映射进行查找是因为它们*高效*:当您已经有了键时，您不需要每次都遍历整个数据结构——一个 *O(n)* 操作——而是可以在常量时间内进行直接查找， *O(1)* 。

当有数千或数百万玩家时，这是一个重要的优化。

让我们快速看一下上面每一项的查找函数:

重构前查找函数。

相当简单。

但是有一个问题:*每个玩家存在三次*，占用了三倍于必要的内存。

让我们回到我们的缓存声明，并通过指定一个地图作为“事实的基础”，或者“参考点”来解决这个问题。

使用播放器`ID`的声明看起来很合适，原因有二:因为`ID`作为*主键，*以及因为`uint32`比播放器的`Handle`占用的空间少得多，T3 是一个任意长度的字符串。让我们重构为:

重构的数据结构。

现在，`playerCountryMap`和`playerHandleMap`都作为到`playerIDMap`的*参考。显然，我们需要稍微重构一下我们的查找函数:*

重构的查找函数。

注意，第一个函数`FindPlayerByID`没有改变。第二个函数`FindPlayerByHandle`现在将检索播放器`ID`而不是`Player`，并继续调用`FindPlayerByID`来完成查找。

由于两次查找，复杂度现在是 *O(2)* 而不是 *O(1)* ，这仍然是常数时间，因此这两种方法之间的性能差异可以忽略不计。

第三个函数更有趣一点。我们创建一个用第一次查找得到的`ID`片的大小初始化的片，然后循环遍历`ID`，同时单独查找它们并将`Player`添加到该片。

我们不需要检查`ID`的存在，因为*我们*在控制缓存；我们知道它的存在。由于循环，复杂度是 *O(n+1)* ，或者仅仅是 *O(n)* 。

这比直接查找更糟糕，因此这里有两种策略:

1.  继续这种实现方式，虽然速度稍慢，但可以节省内存，或者:
2.  坚持原来的实现，它需要更多的内存，但是查找速度更快。

你可以——也应该——根据具体情况混合搭配这两种策略；始终选择适合情况的策略。

作为这个例子的最后一点，你也可以使用指针来引用而不是使用`uint32` s。概念是相同的，你可以坚持总是使用引用原始结构的指针，而不是进行多次相互依赖的查找。

但是请记住，拥有一个包含成千上万个指针的缓存也会相应地增加 GC 必须管理的指针数量，这会对 GC 暂停时间产生负面影响。

当您不需要更改数据时，最好使用值。

# 第二个示例:数据复制

让我们假设一个场景，我们仍然在缓存`Player` s，但对于应用程序的这个特定部分，我们可以绝对肯定地说，他们都玩了完全相同的游戏。

也许是因为视频游戏发行商之一 CrashyGames，Inc .要求提供一份本地可管理的列表，列出该平台上所有玩过他们所有游戏的玩家——也许是为了向他们道歉，说明他们的游戏质量有问题？

我们可以立即看到，通过不为每个`Player`存储字段`Games`，我们可以节省大量内存。因为我们仍然需要该字段作为数据类型的一部分，所以我们将单独存储它，然后在请求时将它添加到一个 ad-hoc `Player`中。

为此，我们需要第二种数据类型，我们称之为`cachedPlayer`:

cachedPlayer 的定义。

你可能注意到了，名字以小写的“c”开头；我们不会导出这种类型，而只是在缓存范围内内部使用。

这是我们的缓存，我们的游戏列表:

缓存和游戏列表。

这次我们就直接用`ID`来查，用`uint32`来表示。但 CrashyGames 拥有数百万玩家，这种优化是值得的。

所以，让我们深入一些代码。这不需要太多工作。首先，我们将在`cachedPlayer`上声明一个方便的方法，将它转换成常规的`Player`:

cacedPlayer 的转换器方法。

现在我们可以实现缓存查找了:

FindPlayerByID 的实现。

我保持了方法`cachedPlayer.convertWith`的纯洁性，将额外的字段作为参数，而`FindPlayerByID`是变量`games`的闭包，它只是存储在包级变量中，但是您可以按照自己喜欢的方式实现它。

瞧！现在我们将所有内容存储一次。如果有许多重复的名字，你甚至可以把它带到下一个层次，把`Player`名字保存在一个单独的数据结构中。

但是要注意执行名称比较的开销，以及用名称增加数据结构的开销。只有在确实可以节省开支的时候，才这样做。

# 结论

轻量级模式是你的朋友，但是和大多数事情一样，需要找到一个平衡点；优化太多，你会引入不必要的复杂性——优化太少，你的应用会变得笨拙而缓慢。

在决定使用 flyweight 模式之前，考虑数据结构的大小，以及对代码可读性和应用程序可维护性的影响。记住唐纳德·克努特的一句老话:

> "过早优化是万恶之源."

现在去优化你的代码吧！

# 附录

应用 flyweight 模式后的示例一。

应用 flyweight 模式后的示例二。