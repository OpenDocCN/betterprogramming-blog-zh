<html>
<head>
<title>Giving Firebase Dynamic Links macOS Support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给予Firebase动态链接macOS支持</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/giving-firebase-dynamic-links-macos-support-fc8e9672180f?source=collection_archive---------11-----------------------#2022-09-28">https://betterprogramming.pub/giving-firebase-dynamic-links-macos-support-fc8e9672180f?source=collection_archive---------11-----------------------#2022-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3968" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对Firebase iOS SDK进行反向工程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1deb75bead4cf6f186bb940150817385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hjdcehTCxjoHmCXVJCY0w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ce67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据他们的文档，Firebase动态链接<a class="ae lr" href="https://firebase.google.com/docs/dynamic-links/ios/create?hl=en&amp;authuser=0#create-a-dynamic-link-from-parameters" rel="noopener ugc nofollow" target="_blank">只在iOS </a>上受支持。我将向您展示我如何通过逆向工程Firebase iOS SDK来添加macOS对动态链接的支持。</p><p id="76b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很高兴使用Firebase构建我的iOS和macOS跨平台应用程序，直到我了解到Firebase动态链接只适用于iOS。我想将在线会话集成到我的应用程序中，我使用动态链接作为其他用户加入会话的方式。</p><p id="24b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，发现macOS不支持动态链接令人失望。但我必须核实一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e875420b3cf2efc559fc535330917974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEDiMfboHrkP4DECdCPMUQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Firebase动态链接目标仅在iOS上受支持。</p></figure><p id="2e0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">证据就在Firebase的包里，swift:动态链接目标只支持iOS。真扫兴。</p><p id="9fe5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这让我想到…为什么？SDK中Firebase动态链接库的核心特性是</p><ul class=""><li id="35ef" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">从深层链接创建动态链接</li><li id="d9ae" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">向动态链接添加回退URL、社交参数、最低版本和其他说明符</li><li id="4b6c" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">缩短动态链接</li><li id="eec4" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">以及处理完成的链接。</li></ul><p id="bdc5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，看起来应该由Firebase来处理这些事情。我们信任他们在SDK中开发的东西；它一定会成功的！</p><p id="0768" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是是什么阻止了我们开发自己的API来解决macOS的问题呢？来自几个Firebase端点的几个URL请求；一些手动的URL解析和创建…这还不算太糟糕！</p><p id="4783" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是在深入研究代码之前，让我们先了解一下动态链接是如何工作的。</p><h1 id="a532" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">Firebase动态链接:复习</h1><p id="34a4" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">好了，你已经阅读了动态链接文档，但是现在是时候快速复习一下相关词汇了。像“深度链接”、“通用链接”、“回退URL”等行话。会让人困惑。所以，我们先明确一下Google是什么意思。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/4a36ebd5ddea574ba65e3721637a8a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDnn-L6SdgnbiGRoSxkxvw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快速概述深层动态链接和简短动态链接之间的主要区别。</p></figure><ul class=""><li id="b95e" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">在<a class="ae lr" href="https://en.wikipedia.org/wiki/Mobile_deep_linking" rel="noopener ugc nofollow" target="_blank">移动上下文</a>中，深度链接使用统一资源标识符(URI)链接到移动应用程序中的特定位置，而不是简单地启动应用程序。例如，如果您的应用程序没有安装，它可以用来打开应用程序商店。</li><li id="89d8" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">动态链接是由Firebase托管和管理的链接。它包含关于您的应用的信息(如捆绑包ID和应用商店ID)、社交元参数等。动态链接最大的卖点是跨平台的兼容性，可以兼容很多平台，比如iOS、Android、Flutter等。你的动态链接的有效载荷就是你的深层链接。</li><li id="1864" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">通用链接是指<em class="nf">可以</em>成为你的动态链接，并由你的应用程序处理的链接。Firebase将尝试将通用链接解析为动态链接，这样它就可以给你真正的有效负载:深度链接。</li></ul><p id="0a2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动态链接是用URL前缀生成的。在Firebase中，默认情况下，您的URL前缀被生成为<code class="fe ng nh ni nj b">your-firebase-project.page.link</code>。</p><p id="50bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果使用自定义域，可以创建一个URL前缀，比如<code class="fe ng nh ni nj b">my-website.com/link</code>。</p><ul class=""><li id="ecf3" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">短动态链接是您的动态链接的缩短版本。像普通的动态链接一样，它以你的URL前缀开始。但是，动态链接中的查询参数被缩短为4个(或更多)字符的随机字符串。</li></ul></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="a38e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些不同的链接类型看起来很棒。现在让我们回顾一下动态链接是如何工作的:</p><h2 id="ee1f" class="nr mi iq bd mj ns nt dn mn nu nv dp mr le nw nx mt li ny nz mv lm oa ob mx oc bi translated"><strong class="ak">创建链接</strong></h2><ol class=""><li id="bdbf" class="lt lu iq kx b ky mz lb na le od li oe lm of lq og lz ma mb bi translated">首先，我们需要建立我们的<strong class="kx ir">深层链接</strong>。</li><li id="6083" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">获取你网站的域名。比如，我会用<code class="fe ng nh ni nj b">app.com</code>。</li><li id="d37e" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">为您的内容选择路径。我想链接到我的用户模型，所以我的路径将是<code class="fe ng nh ni nj b">/user</code>。路径是可选的，你可以随心所欲地定制应用内处理。</li><li id="bf87" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">为额外的应用内处理添加查询参数。例如，我使用<code class="fe ng nh ni nj b">?id=ABCDEFG</code>来指定我将获取ID为“ABCDEFG”的用户。</li><li id="d24b" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">你现在有你的深度链接有效载荷。在我的例子中，这是<code class="fe ng nh ni nj b"><a class="ae lr" href="https://app.com/user?id=ABCDEFG." rel="noopener ugc nofollow" target="_blank">https://app.com/user?id=ABCDEFG</a></code> <a class="ae lr" href="https://app.com/user?id=ABCDEFG." rel="noopener ugc nofollow" target="_blank">。</a></li><li id="e545" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">接下来，抓住你的域名网址前缀。我就用<code class="fe ng nh ni nj b">app.page.link</code>。</li><li id="a73e" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">从这里开始，您使用Firebase iOS SDK创建一个“长”动态链接，其中包含附加参数，如所需的最低应用程序版本，或您的应用程序的应用程序商店ID:</li></ol><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="0888" class="nr mi iq nj b gy ol om l on oo">guard let link = URL(string: "https://app.com/user?id=ABCDEFG") else { return }<br/>let dynamicLinksDomainURIPrefix = "https://app.page.link"<br/>let linkBuilder = DynamicLinkComponents(link: link, domainURIPrefix: dynamicLinksDomainURIPRefix)<br/>linkBuilder.iOSParameters = DynamicLinkIOSParameters(bundleID: "com.example.ios")<br/>linkBuilder.androidParameters = DynamicLinkAndroidParameters(packageName: "com.example.android")</span><span id="2517" class="nr mi iq nj b gy op om l on oo">guard let longDynamicLink = linkBuilder.url else { return }<br/>print("The long URL is: \(longDynamicLink)")</span></pre><p id="dc49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">8.通常情况下，你的长动态链接会…很长…你需要缩短它:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="c186" class="nr mi iq nj b gy ol om l on oo">DynamicLinkComponents.shortenURL(url: longDynamicLink, options: nil) { url, warnings, error in<br/>  guard let url = url, error != nil else { return }<br/>  print("The short URL is: \(url)")<br/>}</span></pre><p id="0231" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">9.一旦缩短，你就有了可分享的动态链接。我的长得像<code class="fe ng nh ni nj b"><a class="ae lr" href="https://app.page.link/ABCD." rel="noopener ugc nofollow" target="_blank">https://app.page.link/ABCD</a></code> <a class="ae lr" href="https://app.page.link/ABCD." rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="0e5d" class="nr mi iq bd mj ns nt dn mn nu nv dp mr le nw nx mt li ny nz mv lm oa ob mx oc bi translated"><strong class="ak">办理环节</strong></h2><ol class=""><li id="fb76" class="lt lu iq kx b ky mz lb na le od li oe lm of lq og lz ma mb bi translated">好了，我们已经打开了应用程序中的URL。在SwiftUI中，这看起来像:</li></ol><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="4db8" class="nr mi iq nj b gy ol om l on oo">MyView()<br/>.onOpenURL { url in<br/>  // Handle universal url here.<br/>}</span></pre><p id="0103" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.我们使用SDK来处理(通用)URL以解析动态链接:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="5501" class="nr mi iq nj b gy ol om l on oo">DynamicLinks.dynamicLinks().handleUniversalLink(url)<br/>{ dynamicLink, error in<br/>  // Dynamic link passed here<br/>}</span></pre><p id="e8a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.我们从动态链接中获得深层链接URL:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="be3a" class="nr mi iq nj b gy ol om l on oo">let deepURL: URL? = dynamicLink?.url</span></pre><p id="f966" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.如前所述，深层链接包含我们的有效负载。例如，我可以打开一个用户的个人资料页面:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="5a0d" class="nr mi iq nj b gy ol om l on oo">// deepURL = "https://app.com/user?id=ABCDEFG"</span><span id="246f" class="nr mi iq nj b gy op om l on oo">if deepURL.path == "/user" {<br/>  let components = URLComponents(string: deepURL.absoluteString)<br/>  let userID = components?.queryItems.first?.value<br/>  // Handle opening user ID here<br/>}</span></pre><p id="4d3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嘣。我们完了。创建和处理的链接。</p><h1 id="ce7c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">远离SDK</h1><p id="0f7a" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">但这些在macOS上都不起作用。这是一个问题，因为我希望能够<em class="nf">至少</em>从我的桌面应用程序(或任何其他Swift-running平台)创建链接。</p><p id="33d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，让我们看看我们是否能挑出<code class="fe ng nh ni nj b">firebase-ios-sdk</code>和Firebase文档来完成我们的目标。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="c401" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从创建链接开始。最好从Firebase的<a class="ae lr" href="https://firebase.google.com/docs/dynamic-links?authuser=0" rel="noopener ugc nofollow" target="_blank">动态链接文档</a>开始。通常，我们会去iOS区。然而，你是否注意到文档中的另一部分可以帮助我们将动态链接引入macOS？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a33f6aa523468666479d67a550751e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*jtxcEAXBOmuaP5IyX5UDKQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你能在这里找到帮助我们在任何设备上创建动态链接的部分吗？</p></figure><p id="17b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是<strong class="kx ir">手动URL构建</strong>。我在浏览文档时发现了这个页面，它最初给了我这样的希望，即这种努力在macOS上是可能的。</p><p id="3881" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://firebase.google.com/docs/dynamic-links/create-manually?authuser=0" rel="noopener ugc nofollow" target="_blank">检查一下</a>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/b40a871311a787229f02e2a27b8e2f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wsh2EjpgHxm5v3_Mwe71Uw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Firebase文档向我们展示了动态链接可以手动构建。</p></figure><p id="adb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用典型的URL前缀和查询参数，我们可以嵌入我们的深度链接有效负载(<code class="fe ng nh ni nj b">?link=</code>)和我们的所有元数据(即<code class="fe ng nh ni nj b">&amp;apn=</code> <strong class="kx ir">、</strong> <code class="fe ng nh ni nj b">&amp;amv=</code> <strong class="kx ir">、</strong> <code class="fe ng nh ni nj b">&amp;afl=</code>)，全部在本地:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="4a4c" class="nr mi iq nj b gy ol om l on oo">var builder = URLComponents()<br/>builder.scheme = "https"<br/>builder.host = "app.page.link"<br/>builder.queryItems = [<br/>  .init(name: "link", value: "<a class="ae lr" href="https://app.com/user?id=ABCDEFG" rel="noopener ugc nofollow" target="_blank">https://app.com/user?id=ABCDEFG</a>"),<br/>  .init(name: "ibi", value: "com.myapp.bundleid"),<br/>  // add other items, like "isi", "imv", "ofl", "st", "sd"...<br/>]<br/>let longDynamicLink: URL? = builder.url</span></pre><p id="20fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Swift的<code class="fe ng nh ni nj b">URLComponents</code>将会光荣地把它转换成一个适当格式的URL，这就是我们的长动态链接。</p><p id="7674" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，是时候缩短我们漫长的动态链接了。这是我们自己做休息工作将真正发光的地方。</p><p id="32f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们知道SDK提供的shorten方法有一个转义完成处理程序，这意味着一定有与后端相关的事情正在进行。</p><p id="9654" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，正是如此:一个POST请求被调用。该请求包含关于新URL的长动态链接和期望的缩短链接的信息。</p><p id="6798" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">跳到Firebase SDK的<code class="fe ng nh ni nj b">shortenURL</code>方法的定义，我们可以看到在第518行发出了一个URL请求:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/2f89d1c3e2316a4dd7a6ea7253f77163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeqsLrBhsIC5-QsYKY2r0Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Firebase iOS SDK在第518行发出URL请求。</p></figure><p id="a26a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">深入挖掘，我们看到“缩短请求”其实是一个啰嗦的POST请求……叫它！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/089e6f6f1abb77dc7e61284663368f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIW3ay0mLabuAmLJj1SSRQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第661–663行给了我们一些信息，我们需要这些信息来创建一个POST请求来缩短链接。</p></figure><p id="0a97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">探索这种方法给了我们一些关键信息:</p><ul class=""><li id="cfa6" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">主持人:<code class="fe ng nh ni nj b"><a class="ae lr" href="https://firebasedynamiclinks.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://firebasedynamiclinks.googleapis.com</a></code></li><li id="e44d" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">路径:<code class="fe ng nh ni nj b">/v1/shortLinks</code></li><li id="54d2" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">查询:<code class="fe ng nh ni nj b">?key=</code>(这是您在<code class="fe ng nh ni nj b">GoogleService_Info.plist</code>中找到的API键)</li><li id="338e" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">请求正文(JSON):</li></ul><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="e799" class="nr mi iq nj b gy ol om l on oo">{<br/>  "longDynamicLink": longDynamicLink,<br/>  "suffix": ["option": "SHORT"]<br/>}</span></pre><ul class=""><li id="a74a" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">当然，这个方法是POST with JSON content type。</li></ul><p id="6c40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经做了调查，所以现在是时候作弊看看文件了。转到创建动态链接中的REST部分向我们展示了如何通过REST缩短一个长的动态链接<a class="ae lr" href="https://firebase.google.com/docs/dynamic-links/rest?authuser=0#create_a_short_link_from_a_long_link" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/729bb2e0086de758c9a6fb6246e5cd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GvO5-n7W-Zyml8Wo0tgog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Firebase文档向我们展示了如何通过REST缩短一个长的动态链接。</p></figure><p id="3984" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太棒了。这与我们刚刚设置的相匹配。</p><h1 id="26d5" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">应用我们的挖掘来处理URL</h1><p id="d97d" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">遗憾的是，这是文档所能告诉我们的。当谈到在我们的设备上处理URL时，没有关于使用URL请求从缩短的动态链接中解析深度链接或任何其他信息的信息。</p><p id="c10f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好消息是什么？我们知道如何挖掘SDK。让我们检查一下<code class="fe ng nh ni nj b">DynamicLinks.dynamicLinks().handleUniversalLink(_:)</code>，看看我们能发现什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/23165bdd055b5d146a471dfcd92044b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alpZTdlolDju7mUogfB3mQ.png"/></div></div></figure><p id="1859" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来像是<code class="fe ng nh ni nj b">handleUniversalLink</code>在第467行调用了另一个方法<code class="fe ng nh ni nj b">resolveShortLink</code>。跳到第490行的<code class="fe ng nh ni nj b">resolveShortLink</code>的定义，我们收集了更多信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/2bd53fe214a7347482145a04bbfabf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LR7OY3ABdKiKH9PYpQnnTQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第183行给出了关于我们调用的API端点的信息。</p></figure><p id="d274" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，检查“/reopen attribute”，<code class="fe ng nh ni nj b">kiOSReopenRestBaseUrl</code>和<code class="fe ng nh ni nj b">FIRDynamicLinkAPIKeyParameter(_APIKey)</code>都用于形成处理我们的动态链接所需的基本API端点:</p><ul class=""><li id="2077" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">端点:<code class="fe ng nh ni nj b"><a class="ae lr" href="https://firebasedynamiclinks.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://firebasedynamiclinks.googleapis.com</a></code></li><li id="8139" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">路径:<code class="fe ng nh ni nj b">/v1/reopenAttribution</code></li><li id="c5cb" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">查询:<code class="fe ng nh ni nj b">?key=</code>(与之前相同的API键)</li></ul><p id="6f12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至于POST请求正文，让我们向下滚动一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/8bd823ede465e8f5d7290285e81dd3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52FGdYizYfxM-jMoeCg0vA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第142–146行告诉我们POST请求主体。</p></figure><p id="474a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到POST主体的形式是:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="7264" class="nr mi iq nj b gy ol om l on oo">{<br/>  "requestedLink": url.absoluteString,<br/>  "bundle_id": "com.app.bundleid",<br/>  "sdk_version": "9.0.0"<br/>}</span></pre><p id="a0c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">来自URL请求的回调JSON为我们提供了深层链接URL:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="a56d" class="nr mi iq nj b gy ol om l on oo">URLSession.shared.dataTask(with: request) { data, response, error in<br/>  guard<br/>    let data = data,<br/>    let dict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],<br/>    let deepLink = dict["deepLink"] as? String,<br/>    let url = URL(string: deepLink)<br/>  else {<br/>    completion(nil)<br/>    return<br/>  }<br/>  // Handle your deep link URL here<br/>}.resume()</span></pre><p id="c492" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，在macOS上，处理应用程序中打开的URL的选项是有限的，所以这里有一个快速的解决方法建议:</p><ol class=""><li id="9f93" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq og lz ma mb bi translated">如果用户使用的是macOS设备，让您的营销网站打开一个基于您的深度链接URL的备用URL。这里，回退URL将包含像用户ID这样的有效负载信息。</li><li id="8bd9" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">使用JavaScript处理URL并准备要打开的自定义URL方案。URL方案是运行在macOS上的原生应用可以处理的东西，比如<code class="fe ng nh ni nj b">my app://additional-information</code>。</li><li id="11ac" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq og lz ma mb bi translated">处理应用程序中的URL方案，直接访问有效载荷数据并处理您的业务。</li></ol><h1 id="8cfc" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">总结</h1><p id="505d" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">总之，重要的是要记住，作为开发人员，解决我们自己的问题并为我们自己和我们的同行开辟一条道路是我们的责任。</p><p id="35c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给macOS动态链接支持曾经似乎很困难，但是通过耐心和一点挖掘，我们设法克服了这个问题。</p><p id="e913" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为一名开发人员，对自己的学习和研究能力保持积极的心态是拥有解决难题的信心的关键。所以，保持耐心，尽力而为！反正那样你会学到更多。</p><h1 id="5eef" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">额外收获:这在Swift包中提供</h1><p id="1178" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">如果你读过我的文章，你会知道我正在开发EasyFirebase，这是一个让Firebase更容易使用的Swift包。在开箱即用的包中支持iOS和macOS的动态链接，所以如果你<a class="ae lr" href="https://github.com/Flowductive/easy-firebase" rel="noopener ugc nofollow" target="_blank">使用我的包</a>，你不必自己实现这一切。</p><p id="36b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，您可以创建如下链接:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="45f5" class="nr mi iq nj b gy ol om l on oo">EasyLink.urlPrefix = "https://app.page.link"</span><span id="d5a3" class="nr mi iq nj b gy op om l on oo"><strong class="nj ir"><em class="nf">var</em></strong> link = EasyLink(host: "app.com", path: "/user", query: ("id", "ABCDEFG"))</span></pre><p id="4823" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后像这样缩短它:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="0132" class="nr mi iq nj b gy ol om l on oo">link.shorten { url in<br/>  // ...<br/>}</span></pre><p id="3911" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样处理它:</p><pre class="kg kh ki kj gt oh nj oi oj aw ok bi"><span id="c9ef" class="nr mi iq nj b gy ol om l on oo">EasyLink.handle(url) { easyLink in<br/>  guard let easyLink = easyLink else { return }<br/>  if easyLink.path == "/user" {<br/>    if let id = easyLink.query["id"] {<br/>      // Handle user ID here.<br/>    }<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>