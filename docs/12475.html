<html>
<head>
<title>The Perfect Message Queue Solution Based on the Redis Stream Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Redis流类型的完美消息队列解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-perfect-message-queue-solution-based-on-the-redis-stream-type-ccf273554178?source=collection_archive---------1-----------------------#2022-06-08">https://betterprogramming.pub/the-perfect-message-queue-solution-based-on-the-redis-stream-type-ccf273554178?source=collection_archive---------1-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松构建自己的系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dcc1b88bee0e4d1c2655227b611caf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ckt3CHvgoqC48X4L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗雷迪·卡斯特罗在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="678b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redis 5.0带来了流类型。从字面上看，它是一个流类型，但实际上，从功能的角度来看，它应该是Redis对于消息队列(MQ，Message Queue)的完美实现。</p><p id="5d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何使用Redis作为消息队列的人都知道，基于Reids的消息队列有许多实现，例如:</p><ul class=""><li id="6ddb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">发布/订阅、订阅/发布模型。</li><li id="2e9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">基于列表的LPUSH+BRPOP的实现。</li><li id="6770" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">基于有序集的实现。</li></ul><p id="d8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个实现都有典型的特征和问题。</p><p id="59db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redis 5.0中发布的流类型也用于实现典型的消息队列。流类型的出现几乎满足了消息队列的所有内容，包括但不限于:</p><ul class=""><li id="2679" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">消息ID的序列化生成。</li><li id="732c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">消息遍历。</li><li id="f1db" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">消息的阻塞和非阻塞读取。</li><li id="35ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">消息的数据包消耗。</li><li id="cb78" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理未完成的消息。</li><li id="d7ac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">消息队列监控。</li></ul><p id="1973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息队列有生产者和消费者。让我们体验一下流类型的美妙。</p><h1 id="2173" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">生产新闻</strong></h1><p id="3340" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">XADD</code>命令用于将消息追加到流(流数据)中，如下所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="dd3f" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XADD memberMessage * user reggie msg Hello<br/>"1553439850328-0"<br/>127.0.0.1:6379&gt; XADD memberMessage * user dwen msg World<br/>"1553439858868-0"</span></pre><p id="831c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法格式为:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="1e1e" class="no mk it nj b gy np nq l nr ns">XADD key ID field string [field string ...]</span></pre><p id="f7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要提供<code class="fe ng nh ni nj b">key</code>、消息<code class="fe ng nh ni nj b">ID</code>方案和消息内容，其中消息内容为<code class="fe ng nh ni nj b">key-value</code>数据。</p><ul class=""><li id="9bd5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">ID</code>，最常用的<code class="fe ng nh ni nj b">*</code>，表示消息ID由Redis生成，这也是强烈推荐的方案。</li><li id="7507" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">field string</code>【字段字符串】，是当前消息的内容，由一个或多个键值组成。</li></ul><p id="2ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，消息user <code class="fe ng nh ni nj b">reggie</code> msg <code class="fe ng nh ni nj b">Hello</code>被添加到键<code class="fe ng nh ni nj b">memberMessage</code>中。</p><p id="d007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redis使用毫秒时间戳和序列号生成消息id。此时，消息队列中有一条消息可用。</p><h1 id="0366" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">消费信息</strong></h1><p id="971e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">XREAD</code>，从流中读取消息，演示如下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="330c" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XREAD streams memberMessage 0<br/>1) 1) "memberMessage"<br/>   2) 1) 1) "1553439850328-0"<br/>         2) 1) "user"<br/>            2) "reggie"<br/>            3) "msg"<br/>            4) "Hello"<br/>      2) 1) "1553439858868-0"<br/>         2) 1) "user"<br/>            2) "dwen"<br/>            3) "msg"<br/>            4) "World"</span></pre><p id="31c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令是从消息队列<code class="fe ng nh ni nj b">memberMessage</code>中读取所有消息。</p><p id="1724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">XREAD</code>支持许多参数，语法格式为:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="109c" class="no mk it nj b gy np nq l nr ns">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span></pre><ul class=""><li id="60ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">COUNT count</code>用于限制获取的消息数量。</li><li id="eee4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">BLOCK milliseconds</code>用于设置<code class="fe ng nh ni nj b">XREAD</code>为阻塞模式，默认为非阻塞模式。</li><li id="abb3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">ID</code>用于设置从哪个消息ID开始读取。使用<code class="fe ng nh ni nj b">0</code>从第一条消息开始。本例中使用了<code class="fe ng nh ni nj b">0</code>，这里需要注意的是，消息队列ID是单调递增的，所以通过设置起点，可以向后读取。在阻塞模式下，<code class="fe ng nh ni nj b">$</code>可以用来表示最新的消息ID。<code class="fe ng nh ni nj b">$</code>在非阻塞模式下没有意义。</li><li id="de34" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">XREAD</code>读取消息时分为阻止和非阻止模式。BLOCK选项可用于指示阻塞模式，并且需要设置阻塞持续时间。在非阻塞模式下，它在读取后立即返回(即使没有消息)，而在阻塞模式下，如果没有内容可以读取，它将阻塞并等待。</li></ul><p id="60df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的阻塞模式用法是:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="0cbf" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XREAD block 1000 streams memberMessage $<br/>(nil)<br/>(1.07s)</span></pre><p id="7609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用阻塞模式，用<code class="fe ng nh ni nj b">$</code>作为<code class="fe ng nh ni nj b">ID</code>，读取最新的消息，如果没有消息，命令将阻塞。在等待过程中，其他客户端将消息添加到队列中，这些消息将被立即读取。</p><p id="dc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，典型的队列是用<code class="fe ng nh ni nj b">XREAD</code>块完成的<code class="fe ng nh ni nj b">XADD</code>。<code class="fe ng nh ni nj b">XADD</code>负责生成消息，<code class="fe ng nh ni nj b">XREAD</code>负责消费消息。</p><h1 id="9e77" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">消息ID描述</strong></h1><p id="4ea0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">XADD</code>生成的<code class="fe ng nh ni nj b">1553439850328–0</code>是Redis生成的消息ID，由两部分组成:时间戳-序列号。</p><p id="7352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间戳以毫秒为单位，是生成消息的Redis服务器的时间。它是一个64位整数(int64)。</p><p id="8d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">序列号是该毫秒时间点的报文的序列号，也是64位整数。说真的，序列号可能会溢出，但真的可能吗？</p><p id="d79c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">序列号的增量可以通过多批次处理来验证:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9538" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; MULTI<br/>OK<br/>127.0.0.1:6379&gt; XADD memberMessage * msg one<br/>QUEUED<br/>127.0.0.1:6379&gt; XADD memberMessage * msg two<br/>QUEUED<br/>127.0.0.1:6379&gt; XADD memberMessage * msg three<br/>QUEUED<br/>127.0.0.1:6379&gt; XADD memberMessage * msg four<br/>QUEUED<br/>127.0.0.1:6379&gt; XADD memberMessage * msg five<br/>QUEUED<br/>127.0.0.1:6379&gt; EXEC<br/>1) "1553441006884-0"<br/>2) "1553441006884-1"<br/>3) "1553441006884-2"<br/>4) "1553441006884-3"<br/>5) "1553441006884-4"</span></pre><p id="f5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Redis命令的执行速度非常快，因此可以看出，在相同的时间戳内，消息由递增的序列号表示。</p><p id="854e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保消息有序，Redis生成的id按顺序单调递增。由于id包含时间戳部分，为了避免服务器时间错误导致的问题(比如服务器时间延迟)，Redis的每个流类型数据都维护了一个<code class="fe ng nh ni nj b">latest_generated_id</code>属性，用来记录最后一条消息的ID。</p><p id="4d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果发现当前时间戳是后向的(小于<code class="fe ng nh ni nj b">latest_generated_id</code>记录的)，则采用时间戳不变，序列号递增的方案作为新的消息ID(这也是序列号使用int64的原因，以保证有足够的序列号)，从而保证ID的单调递增性质。</p><p id="3799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议使用Redis方案来生成消息ID，因为这种时间戳+序列号的单调递增的ID方案几乎可以满足您的所有需求。</p><p id="e296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但同时要记住，id是可定制的，别忘了！</p><h1 id="f685" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">消费群体模型</strong></h1><p id="e0b5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当多个消费者同时消费一个消息队列时，可以重复消费同一条消息，即消息队列中有十条消息，三个消费者都可以消费这十条消息。</p><p id="95d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有时，我们需要多个消费者合作消费同一个消息队列，即消息队列中有十条消息，三个消费者分别消费其中的一部分。</p><p id="14de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，消费者A消费消息<code class="fe ng nh ni nj b">1,2,5,8</code>，消费者B消费消息<code class="fe ng nh ni nj b">4,9,10</code>，消费者C消费消息<code class="fe ng nh ni nj b">3,6,7</code>。</p><p id="1620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即三个消费者合作完成对消息的消费，在消费能力不足，即消息处理程序效率不高的情况下可以使用这种模式。</p><p id="2ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式就是消费群体模式。如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/df1ec4c4bade9d6d71382d3c1fd034f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLbFpzkEBUIkY0y-HjQQuQ.png"/></div></div></figure><p id="2de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对消费者组模式的支持主要通过两个命令来实现:</p><ul class=""><li id="0ffb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">XGROUP</code>，用于管理消费群，提供创建群、销毁群、更新群启动消息id等操作。</li><li id="6095" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">XREADGROUP</code>，集团消费消息操作。</li></ul><p id="834a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于演示，演示中使用了五条消息。这个想法是创建一个流消息队列，生产者生成五条消息。</p><p id="ddbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在消息队列上创建一个使用者组，该组中有三个使用者使用消息:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4427" class="no mk it nj b gy np nq l nr ns"># <!-- -->Producer generates 5 messages<br/>127.0.0.1:6379&gt; MULTI<br/>127.0.0.1:6379&gt; XADD mq * msg 1<br/>127.0.0.1:6379&gt; XADD mq * msg 2<br/>127.0.0.1:6379&gt; XADD mq * msg 3<br/>127.0.0.1:6379&gt; XADD mq * msg 4<br/>127.0.0.1:6379&gt; XADD mq * msg 5<br/>127.0.0.1:6379&gt; EXEC<br/> 1) "1553585533795-0"<br/> 2) "1553585533795-1"<br/> 3) "1553585533795-2"<br/> 4) "1553585533795-3"<br/> 5) "1553585533795-4"<br/><br/># <!-- -->Create a consumer group<!-- --> mqGroup<br/>127.0.0.1:6379&gt; XGROUP CREATE mq mqGroup 0 # <!-- -->Create a consumer group mgGroup for message queue mq<br/>OK<br/><br/># <!-- -->Consumer A, Consumption Article 1<br/>127.0.0.1:6379&gt; XREADGROUP group mqGroup consumerA count 1 streams mq &gt; <!-- -->#Consumer A in the consumer group reads a message from the message queue mq<br/>1) 1) "mq"<br/>   2) 1) 1) "1553585533795-0"<br/>         2) 1) "msg"<br/>            2) "1"<br/># <!-- -->Consumer A, Consumption Article 2<br/>127.0.0.1:6379&gt; XREADGROUP group mqGroup consumerA COUNT 1 STREAMS mq &gt; <br/>1) 1) "mq"<br/>   2) 1) 1) "1553585533795-1"<br/>         2) 1) "msg"<br/>            2) "2"<br/># <!-- -->Consumer B, Consumption Article 3<br/>127.0.0.1:6379&gt; XREADGROUP group mqGroup consumerB COUNT 1 STREAMS mq &gt; <br/>1) 1) "mq"<br/>   2) 1) 1) "1553585533795-2"<br/>         2) 1) "msg"<br/>            2) "3"<br/># <!-- -->Consumer A, Consumption Article 4<br/>127.0.0.1:6379&gt; XREADGROUP group mqGroup consumerA count 1 STREAMS mq &gt; <br/>1) 1) "mq"<br/>   2) 1) 1) "1553585533795-3"<br/>         2) 1) "msg"<br/>            2) "4"<br/># <!-- -->Consumer C, Consumption Article 5<br/>127.0.0.1:6379&gt; XREADGROUP group mqGroup consumerC COUNT 1 STREAMS mq &gt; <br/>1) 1) "mq"<br/>   2) 1) 1) "1553585533795-4"<br/>         2) 1) "msg"<br/>            2) "5"</span></pre><p id="20e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上例中，同一组<code class="fe ng nh ni nj b">mqGroup</code>消费消息中的三个消费者A、B、C(消费者可以在消费时指定，无需提前创建)时，具有互斥原理。消耗计划是，A- &gt; 1，A- &gt; 2，B- &gt; 3，A- &gt; 4，C- &gt; 5。</p><p id="6ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">XGROUP create mq mqGroup 0</code>用于在消息队列<code class="fe ng nh ni nj b">mq</code>上创建一个消费组<code class="fe ng nh ni nj b">mqGroup</code>。最后一个参数是<code class="fe ng nh ni nj b">0</code>，表示该组从第一条消息开始消费。意思和<code class="fe ng nh ni nj b">XREAD</code>的<code class="fe ng nh ni nj b">0</code>一致)。</p><p id="c9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了支持创建，还支持<code class="fe ng nh ni nj b">SETID</code>设置起始ID、<code class="fe ng nh ni nj b">DESTROY</code>销毁群、<code class="fe ng nh ni nj b">DELCONSUMER</code>删除群内消费者等操作。</p><p id="45d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">XREADGROUP group mqGroup consumerA count 1 streams mq &gt;</code>，用于组mqGroup中的consumerA在队列<code class="fe ng nh ni nj b">mq</code>中消费，参数<code class="fe ng nh ni nj b">&gt;</code>表示组中未消费的开始消息，参数count 1表示获取一个。</p><p id="8f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法基本和<code class="fe ng nh ni nj b">XREAD</code>一样，只是增加了组的概念。</p><p id="fe78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组内消费的基本原理是，流类型将为每个组记录一个最后处理(传递)的消息ID (last_delivered_id)，这样当在组内消费时，您可以从这个值的后面开始读取，以确保没有重复消费。</p><p id="015a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是消费群的基本操作。</p><p id="4b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当一个消费者群体消费时，还有一个必须考虑的问题，即如果一个消费者消费了一个消息，但没有成功处理它(例如，消费者进程宕机)，则该消息可能会因为该群体中的其他消费者无法再次消费该消息而丢失。</p><p id="1143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面继续讨论该解决方案。</p><h1 id="a980" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">等待消息列表</strong></h1><p id="2d5f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了解决群内消息读取过程中消费者崩溃导致的消息丢失问题，STREAM设计了一个Pending list来记录已读取但未处理的消息。</p><p id="f4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令<code class="fe ng nh ni nj b">XPENDING</code>用于获取消费者内部的消费者组或消费者的未处理消息。演示如下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4e45" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XPENDING mq mqGroup<br/>1) (integer) 5 # <!-- -->5 messages read but not processed<br/>2) "1553585533795-0" # begin ID<br/>3) "1553585533795-4" # end ID<br/>4) 1) 1) "consumerA" # consumer A have 3 messages<br/>      2) "3"<br/>   2) 1) "consumerB" # consumer B have 1message<br/>      2) "1"<br/>   3) 1) "consumerC" # consumer C have 1message<br/>      2) "1"<br/><br/>127.0.0.1:6379&gt; XPENDING mq mqGroup - + 10 # <!-- -->Use the start end count option for details<br/>1) 1) "1553585533795-0" # Message ID<br/>   2) "consumerA" # consumer<br/>   3) (integer) 1654355 # <!-- -->It has been 1654355ms from reading to now, IDLE<br/>   4) (integer) 5 # <!-- -->The message was read 5 times<!-- -->，delivery counter<br/>2) 1) "1553585533795-1"<br/>   2) "consumerA"<br/>   3) (integer) 1654355<br/>   4) (integer) 4<br/># <!-- -->A total of 5, the remaining 3 omitted<!-- --> ...<br/><br/>127.0.0.1:6379&gt; XPENDING mq mqGroup - + 10 consumerA # <!-- -->Add the consumer parameter to get the Pending list of a specific consumer<br/>1) 1) "1553585533795-0"<br/>   2) "consumerA"<br/>   3) (integer) 1641083<br/>   4) (integer) 5<br/># <!-- -->A total of 3, the remaining 2 omitted<!-- --> ...</span></pre><p id="4786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个待定消息有四个属性:</p><ul class=""><li id="731d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">Message-ID</code></li><li id="376a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">consumer</code></li><li id="8b38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">IDLE</code>，时间流逝</li><li id="1954" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">传递计数器，邮件被阅读的次数</li></ul><p id="fa23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的结果可以看出，我们之前读取的消息都被记录在Pending list中，说明所有读取的消息都没有被处理，只是读取。</p><p id="7af5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，它如何表明消费者已经完成了对消息的处理呢？</p><p id="751c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令<code class="fe ng nh ni nj b">XACK</code> completion来告知消息处理完成。</p><p id="d15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示如下:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="c346" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XACK mq mqGroup 1553585533795-0 # <!-- -->Notify message processing end, identified by message ID<br/>(integer) 1<br/><br/>127.0.0.1:6379&gt; XPENDING mq mqGroup # <!-- -->Check the Pending list again<br/>1) (integer) 4 # <!-- -->The messages read but not processed have become 4<br/>2) "1553585533795-1"<br/>3) "1553585533795-4"<br/>4) 1) 1) "consumerA" # <!-- -->Consumer A, there are 2 message processing<br/>      2) "2"<br/>   2) 1) "consumerB"<br/>      2) "1"<br/>   3) 1) "consumerC"<br/>      2) "1"<br/>127.0.0.1:6379&gt;</span></pre><p id="7d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样的挂起机制，就意味着在消费者读取消息但不处理它之后，消息不会丢失。</p><p id="c429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待消费者再次上线后，可以读取待处理列表，继续处理消息，确保消息有序，不丢失。</p><p id="b39f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时候还有一个问题，就是如果一个消费者下线后没有办法上线，就需要把这个消费者的待处理消息转移给其他消费者进行处理，这就是消息转移。</p><h1 id="f6ac" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">消息传送</strong></h1><p id="9948" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在消息传输操作期间，消息被传输到它自己的挂起列表中。</p><p id="eafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用语法<code class="fe ng nh ni nj b">XCLAIM</code>，需要设置组、目标消费者和传输的消息ID，还需要提供IDLE(已读取的时间长度)。只有在这个时间长度之后，它才能被转移。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="93f0" class="no mk it nj b gy np nq l nr ns"># <!-- -->The message currently belonging to consumer A is 1553585533795-1, which has been unprocessed for 15907,787ms<br/>127.0.0.1:6379&gt; XPENDING mq mqGroup - + 10<br/>1) 1) "1553585533795-1"<br/>   2) "consumerA"<br/>   3) (integer) 15907787<br/>   4) (integer) 4<br/><br/># <!-- -->Transfer message 1553585533795-1 over 3600s to consumer B's Pending list<br/>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB 3600000 1553585533795-1<br/>1) 1) "1553585533795-1"<br/>   2) 1) "msg"<br/>      2) "2"<br/><br/># <!-- -->Message 1553585533795-1 has been transferred to Consumer B's Pending.<br/>127.0.0.1:6379&gt; XPENDING mq mqGroup - + 10<br/>1) 1) "1553585533795-1"<br/>   2) "consumerB"<br/>   3) (integer) 84404 # <!-- -->IDLE, it's reset<br/>   4) (integer) 5 # <!-- -->The number of reads is also accumulated by 1</span></pre><p id="97d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码完成了一个消息传输。除了指定ID，转账还需要指定<code class="fe ng nh ni nj b">IDLE</code>，以保证转账长时间不被处理。</p><p id="21f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已传输消息的<code class="fe ng nh ni nj b">IDLE</code>将被重置，以确保不会被重复传输。据认为，可能存在同时向多个消费者传输过期消息的并发操作。如果设置了<code class="fe ng nh ni nj b">IDLE</code>，则可以避免后续的传送。会成功，因为<code class="fe ng nh ni nj b">IDLE</code>不满足条件。</p><p id="c785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如下面连续两次转账，第二次就不会成功。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="ac60" class="no mk it nj b gy np nq l nr ns">127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerB 3600000 1553585533795-1<br/>127.0.0.1:6379&gt; XCLAIM mq mqGroup consumerC 3600000 1553585533795-1</span></pre><p id="75df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一次信息传递。到目前为止，我们已经使用了待处理消息的ID、消费者的属性和它所属的<code class="fe ng nh ni nj b">IDLE</code>,另一个属性是消息被读取的次数、传递计数器。该属性的功能是计算消息被读取的次数，包括传输的次数。</p><p id="92fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该属性主要用于判断是否是错误数据。</p><h1 id="729c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">死信问题</strong></h1><p id="22c7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如上所述，如果一个消息不能被消费者处理，也就是不能被XACKed，那么它将在待定列表中呆很长时间，即使它被反复地转移给各个消费者。</p><p id="70da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时候消息的投递计数器就会累加(上一节的例子可以看到)，当累加到我们预设的某个阈值时，我们就认为是坏消息(也叫死信、死信、无法投递)。新闻)，因为判断条件的原因，我们可以只处理坏消息，删除。</p><p id="b318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除消息，使用<code class="fe ng nh ni nj b">XDEL</code>语法，如下所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="3da8" class="no mk it nj b gy np nq l nr ns"># <!-- -->delete message from queue<br/>127.0.0.1:6379&gt; XDEL mq 1553585533795-1<br/>(integer) 1<br/># <!-- -->Check that there is no more message in the queue<br/>127.0.0.1:6379&gt; XRANGE mq - +<br/>1) 1) "1553585533795-0"<br/>   2) 1) "msg"<br/>      2) "1"<br/>2) 1) "1553585533795-2"<br/>   2) 1) "msg"<br/>      2) "3"</span></pre><p id="9c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在此示例中，未删除待处理的邮件，因此如果您查看待处理的邮件，邮件仍在那里。可以执行XACK来标记它的完成！</p><h1 id="3f5a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">信息监控</strong></h1><p id="733d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Stream提供<code class="fe ng nh ni nj b">XINFO</code>来监控服务器信息，可以查询:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9bd1" class="no mk it nj b gy np nq l nr ns"># <!-- -->View queue information<br/>127.0.0.1:6379&gt; xinfo stream mq<br/>...</span><span id="7707" class="no mk it nj b gy nu nq l nr ns"># <!-- -->Consumer group information<br/>127.0.0.1:6379&gt; xinfo groups mq<br/>...</span><span id="6a61" class="no mk it nj b gy nu nq l nr ns"># <!-- -->Consumer Group Member Information<br/>127.0.0.1:6379&gt; xinfo consumers mq mqGroup<br/>...</span></pre><p id="7cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，消息队列的操作描述大体结束。</p><p id="ad38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Golang来实现一个Redis流消息队列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="b4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oe">感谢您阅读这篇文章。</em></p><p id="ce3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oe">敬请期待更多。</em></p></div></div>    
</body>
</html>