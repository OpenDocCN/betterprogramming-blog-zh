<html>
<head>
<title>Implementing Multiple Window Support in iPadOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iPadOS中实现多窗口支持</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-multiple-window-support-in-ipados-5b9a3ceeac6f?source=collection_archive---------4-----------------------#2019-10-23">https://betterprogramming.pub/implementing-multiple-window-support-in-ipados-5b9a3ceeac6f?source=collection_archive---------4-----------------------#2019-10-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="593d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">AppDelegate退居二线。SceneDelegate接管。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4d5e5f1f38c2079f346de2cf6f697b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ziGpv89dW2jLWE9jiumOg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Pic演职员表:<a class="ae kz" href="https://undraw.co/search" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="9ea7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iPadOS 13在WWDC 2019期间推出。最后，iPad有一个独立的操作系统。</p><p id="9ea3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在iPadOS中引入多窗口支持是一个改变游戏规则的举措。它允许我们同时打开一个应用程序的多个实例。</p><p id="5e97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当查看多条消息、电子邮件、比较笔记和地图路线时，这个令人惊叹的功能非常有用。这也会让照片和视频编辑的生活更加轻松。我相信多窗口支持将很快带来有趣的多人游戏！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f301" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">我们今天的目标</h1><ul class=""><li id="0725" class="mv mw iu lc b ld mx lg my lj mz ln na lr nb lv nc nd ne nf bi translated">了解多窗口支持如何改变应用程序的生命周期。</li><li id="25c4" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">鸟瞰一下<code class="fe nl nm nn no b">UIScene</code> API。</li><li id="50db" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">以两种不同的方式实现多窗口支持——使用用户输入的<em class="np"/>和使用拖放的<em class="np"/>。我们将开发一个基于iOS和iPadOS的照片编辑应用程序，它在蜘蛛侠图像上使用<code class="fe nl nm nn no b">CIFilters</code>！</li></ul><p id="646d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">别再浪费时间了，让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="51bb" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">启用多窗口支持</h1><p id="9f92" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">很简单，只需跳转到项目导航器，常规设置，并确保<em class="np">支持多窗口</em>复选框被启用。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/d5fd6bb9b11befbe8e9a81f5e43b8710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hoFUVFmOYOeD1ud7.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">这一项检查改变了生命周期的工作方式！</p></figure><p id="348a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完成后，在<code class="fe nl nm nn no b">info.plist</code>中设置多窗口支持布尔属性。在我们深入研究API的变化和实现之前，让我们先来解决这个问题。</p><h2 id="24c0" class="nu me iu bd mf nv nw dn mj nx ny dp mn lj nz oa mp ln ob oc mr lr od oe mt of bi translated"><strong class="ak">多窗口支持不支持分屏</strong></h2><p id="ed92" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">iOS 9中引入了分屏支持，允许在一个窗口中查看不同的应用程序，而多窗口支持允许一次查看单个应用程序的多个实例。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/5154038c9c046bc16c229e11e42852b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lJ1dKoVjKQNkInbg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">iOS 13允许显示一个应用的多个窗口(场景)</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="53c2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">AppDelegate和应用生命周期的变化</h1><p id="cf9f" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">多窗口支持给<code class="fe nl nm nn no b">AppDelegate</code>类带来了重大改变。现在轻多了。所有的重担都由<code class="fe nl nm nn no b">SceneDelegate</code>级完成。如果你偷看任何iOS 13 Xcode项目中的<code class="fe nl nm nn no b">AppDelegate</code>，你会发现它只有很少的方法。</p><p id="5d9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn no b">UIApplicationDelegate</code>在iOS 13及以上版本中，应用从后台进出时不被通知。</p><p id="a270" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个新引入的协议<code class="fe nl nm nn no b">UIWindowSceneDelegate</code>，处理一个应用程序的多个窗口的通知。</p><p id="e165" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在不推荐使用<code class="fe nl nm nn no b">UIApplication</code>类的以下属性:</p><ul class=""><li id="8890" class="mv mw iu lc b ld le lg lh lj oh ln oi lr oj lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">statusBarStyle</code></li><li id="1369" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">statusBarHidden</code></li><li id="0af2" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">statusBarOrientation</code></li><li id="2637" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">open(_:options:completionHandler:)</code></li><li id="e816" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">keyWindows</code></li></ul><p id="6489" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于多窗口支持，窗口现在是场景！所以从iPadOS 13开始，你在应用切换器里看到的一切都是一个独立的场景。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8cb2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">UIScene API:鸟瞰</h1><p id="d901" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">多窗口支持使用<code class="fe nl nm nn no b">UIScene</code> API。这个API的两个最基本的类是:</p><ul class=""><li id="aba3" class="mv mw iu lc b ld le lg lh lj oh ln oi lr oj lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">UIWindowScene</code> —负责管理一个应用程序的多个窗口。</li><li id="b771" class="mv mw iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe nl nm nn no b">UISceneSession</code> —这表示场景的持续状态。多个<code class="fe nl nm nn no b">UIScene</code>在那里存储特定的信息，比如场景会话中的角色和用户信息。</li></ul><p id="3940" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn no b">NSUserActivity</code>用于捕捉场景的状态。该状态用于恢复先前使用的场景或使用当前观看内容创建新场景。</p><p id="3027" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn no b">UIWindowSceneDelegate</code>由<code class="fe nl nm nn no b">SceneDelegate</code>实现。该协议是应用程序的新条目，因为它保存了对<code class="fe nl nm nn no b">UIWindow</code>的引用。</p><p id="6b22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn no b">UIWindow</code>现在包含对<code class="fe nl nm nn no b">UIWindowScene</code>的引用。如果你使用故事板，<code class="fe nl nm nn no b">UIWindow</code>属性会自动附加到场景中。</p><p id="e392" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">不用故事板？</strong>您需要在<code class="fe nl nm nn no b">SceneDelegate</code>类中手动将<code class="fe nl nm nn no b">UIWindow</code>附加到场景，如下所示:</p><pre class="kk kl km kn gu ok no ol om aw on bi"><span id="8f12" class="nu me iu no b gz oo op l oq or">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {<br/>guard let windowScene = (scene as? UIWindowScene) else { return }        window = UIWindow(frame: windowScene.coordinateSpace.bounds)        window?.windowScene = windowScene<br/>}</span></pre><p id="aff4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果上面的东西没有太多意义，下一节中的实际实现肯定会更加清晰。让我们开始吧！</p><p id="3918" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:不要使用多窗口支持来跨场景扩展功能。或者通过在另一个场景中显示一个场景的输出。每个场景都应该具有应用程序的全部功能。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4f1f" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">履行</h1><p id="67d3" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">我们将创建一个基于照片编辑的应用程序，允许在不同的场景中使用不同的过滤器查看图像。当你需要确定哪种滤镜在图像上看起来最好时，这很方便！</p><h2 id="97d0" class="nu me iu bd mf nv nw dn mj nx ny dp mn lj nz oa mp ln ob oc mr lr od oe mt of bi translated">铺设用户界面</h2><p id="d649" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">以下代码片段以编程方式向屏幕添加了一个<code class="fe nl nm nn no b">UIImageView</code>:</p><pre class="kk kl km kn gu ok no ol om aw on bi"><span id="65ed" class="nu me iu no b gz oo op l oq or">let VCActivityType = "VCKey"<br/>func setupImageView(){</span><span id="26d9" class="nu me iu no b gz os op l oq or">photo = UIImageView(frame: .zero)<br/>photo?.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(photo!)</span><span id="5964" class="nu me iu no b gz os op l oq or">NSLayoutConstraint.activate([<br/>photo!.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: marginConstant),<br/>photo!.bottomAnchor.constraint(equalTo: self.stackView!.topAnchor, constant: -marginConstant),<br/>photo!.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: marginConstant),<br/>photo!.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -marginConstant),<br/>])<br/>}</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="84d3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">在用户点击时创建新场景</h1><p id="9c0c" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">要创建应用程序的新场景，请在按钮上添加以下代码:</p><pre class="kk kl km kn gu ok no ol om aw on bi"><span id="00c0" class="nu me iu no b gz oo op l oq or">let activity = NSUserActivity(activityType: VCActivityType) UIApplication.shared.requestSceneSessionActivation(nil, userActivity: activity, options: nil, errorHandler: nil)</span></pre><p id="e8a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn no b">requestSceneSessionActivation</code>负责激活现有场景或创建新场景。</p><p id="ff4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是来自iPad应用程序的一个屏幕截图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/5cb5b4cf8eb938bdd5f7f7fe13199639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/1*7fc0_NSBt1Qc5drGdip7dQ.gif"/></div></figure><p id="695e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这很简单。现在，让我们跳到拖放机制上，看看需要做些什么。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="732c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用拖放创建新场景</h1><p id="523d" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">我们可以通过在<code class="fe nl nm nn no b">DragItem</code>的<code class="fe nl nm nn no b">NSItemProvider</code>中传递<code class="fe nl nm nn no b">NSUserActivity</code>来使用<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener ugc nofollow" target="_blank">拖放API </a>。</p><p id="a700" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您拖动UI组件时，系统会自动提供放置点(通常在屏幕边缘)。在这些点上放下会导致一个新场景的创建。</p><p id="a3b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要使用<code class="fe nl nm nn no b">UIImageView</code>的拖放创建一个新场景，我们必须注意三件事:</p><h2 id="e915" class="nu me iu bd mf nv nw dn mj nx ny dp mn lj nz oa mp ln ob oc mr lr od oe mt of bi translated">1.符合<code class="fe nl nm nn no b">UIDragInteractionDelegate</code></h2><p id="363d" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">我们需要在<code class="fe nl nm nn no b">UIImageView</code>上设置拖拽交互。</p><pre class="kk kl km kn gu ok no ol om aw on bi"><span id="648e" class="nu me iu no b gz oo op l oq or">photo?.isUserInteractionEnabled = true photo?.addInteraction(UIDragInteraction(delegate: self))</span></pre><h2 id="ee72" class="nu me iu bd mf nv nw dn mj nx ny dp mn lj nz oa mp ln ob oc mr lr od oe mt of bi translated">2.实现拖动功能</h2><p id="8f96" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">在下面的代码片段中，我们将<code class="fe nl nm nn no b">imageView</code>传递给<code class="fe nl nm nn no b">NSItemProvider</code>，并用它注册<code class="fe nl nm nn no b">NSUserActivity</code>。</p><pre class="kk kl km kn gu ok no ol om aw on bi"><span id="24c4" class="nu me iu no b gz oo op l oq or">extension ViewController : UIDragInteractionDelegate{<br/>    func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] {<br/>        if let imageView = interaction.view as? UIImageView {<br/>            guard let image = imageView.image else { return [] }<br/>            let provider = NSItemProvider(object: image)<br/>            <br/>            let userActivity = NSUserActivity(activityType: VCActivityType)<br/>            provider.registerObject(userActivity, visibility: .all)<br/>            let item = UIDragItem(itemProvider: provider)<br/>            return [item]<br/>        }<br/>        return []<br/>    }<br/>}</span></pre><h2 id="c122" class="nu me iu bd mf nv nw dn mj nx ny dp mn lj nz oa mp ln ob oc mr lr od oe mt of bi translated">3.在<code class="fe nl nm nn no b">Info.plist</code>中添加活动类型</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/aae0faa02e643e339bf8ffa2c80dd429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/0*h_zgbsYZEr_JunNv.png"/></div></figure><p id="6bbd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的iPad应用程序现在可以通过拖动支持多窗口了。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/2d37992e24c976b8b4d03b15feee2bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/1*FmIUffxepo5CdufNPJ3ZDw.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4549068" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kz" href="https://pixabay.com/users/gabyobs-13938287/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4549068" rel="noopener ugc nofollow" target="_blank"> Gaby OBS </a>拍摄的蜘蛛侠图像</p></figure><p id="704a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在图像上设置了<code class="fe nl nm nn no b">CIFilters</code>来比较不同滤镜下的同一幅图像。</p><p id="b7f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多窗口支持也与<a class="ae kz" href="https://developer.apple.com/mac-catalyst/" rel="noopener ugc nofollow" target="_blank"> Mac Catalyst </a>兼容。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="da18" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="4409" class="pw-post-body-paragraph la lb iu lc b ld mx jv lf lg my jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">所以，就这样了！我们看到了<code class="fe nl nm nn no b">AppDelegate</code>如何退居二线，让<code class="fe nl nm nn no b">SceneDelegate</code>通过处理大多数生命周期事件来完成主要任务。</p><p id="0adb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们实现了多窗口支持，在不同的场景中以不同的色调看到了我们友好的邻居。</p><p id="c437" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章的完整源代码可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/iPadOSMultiWindowExample" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="ae8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的部分中，我们将处理状态恢复和在iPadOS中跨多个窗口同步数据。</p><p id="1d12" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。我希望你喜欢它。</p></div></div>    
</body>
</html>