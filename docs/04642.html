<html>
<head>
<title>A Custom Alternative to ARKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ARKit的定制替代方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-custom-alternative-to-arkit-c07961a38d2a?source=collection_archive---------9-----------------------#2020-04-27">https://betterprogramming.pub/a-custom-alternative-to-arkit-c07961a38d2a?source=collection_archive---------9-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果ARKit不适合你，为什么不自己制作呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d37c033739623900ed65546af6b07e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjwdf08e_u804-NreGkQbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="67f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嘿！在我开始之前，我想指出，我的选择绝不是高度抛光，极其准确，非常现实的<a class="ae lu" href="https://developer.apple.com/documentation/arkit" rel="noopener ugc nofollow" target="_blank"> ARKit </a>的替代品。它甚至不能与之相提并论——完全不能——而且在前提条件方面有很大的限制。它也仅用于放置2D对象，并且需要尽可能频繁地提供对象的位置。</p><p id="d97e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我的替代方案<em class="lv">是</em>，一个非常快速、高效、不占用内存的程序，是我的<a class="ae lu" href="https://apps.apple.com/app/find-command-f-for-camera/id1506500202" rel="noopener ugc nofollow" target="_blank">应用</a>的支柱。它非常简单，您可以根据自己的需求轻松定制。感兴趣吗？请继续阅读…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们会做什么！</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="95bb" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">一些背景信息</h1><p id="ee45" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我的应用程序中，主要功能是使用手机摄像头查找文本的能力。界面很简单——屏幕顶部的一个文本字段、一些按钮和一个摄像头视图。</p><p id="1dab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了查找文本，我在相机视图上大约每秒执行一次苹果的<code class="fe nc nd ne nf b">VNRecognizeTextRequest</code> OCR，这将返回一组<code class="fe nc nd ne nf b">VNRecognizedText</code>对象。这些<code class="fe nc nd ne nf b">VNRecognizedText</code>对象包括找到的文本的边框和文本本身。然后，我遍历这个数组，检查它们是否与用户在文本字段中输入的文本相匹配。<strong class="la iu">如果找到任何匹配，该应用程序应该在现实世界中放置一个“突出显示”。</strong></p><p id="112b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我如何在现实世界中放置东西呢？这正是增强现实所做的。</p><p id="b689" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我第一次开始制作我的应用程序时，ARKit的<code class="fe nc nd ne nf b">ARWorldTrackingConfiguration</code>听起来是个好主意——有很多教程可用，它让你在现实中放置模型，这正是我想要的。你甚至可以绕着它走，晃动相机，这个模型看起来会粘在它所在的任何表面上。</p><p id="c3b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我试了一下——但是速度太慢了。非常慢。用户需要挥动手机大约五秒钟，直到ARKit可以检测到一架飞机(你放置物体的地方)。我的应用程序完全是为了提高效率——它在现实世界中寻找文本，为你节省时间——但如果它花了5秒钟来初始化，那对你一点帮助也没有。</p><p id="fac6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，现在激光雷达出来了，ARKit快多了——但是激光雷达只适用于新的iPad Pro和iPhone 12(贵！).不幸的是，我的钱包也没了——没钱了。</p><p id="705a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是撇开速度不谈，更糟糕的是它并不总是准确的。为了放置我的立方体，我使用了<a class="ae lu" href="https://codelabs.developers.google.com/codelabs/ar-with-webxr/#4" rel="noopener ugc nofollow" target="_blank"> <em class="lv">点击测试</em> </a>。因为<code class="fe nc nd ne nf b">VNRecognizedText</code>给了我检测到的文本的边界框(如2D xy坐标和大小，相对于设备屏幕，原点在左上角)，我使用点击测试将2D坐标转换成现实生活中的3D。但有时，2D坐标不会“击中”任何检测到的飞机，导致击中测试失败。</p><p id="5950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我尝试了寻找图像而不是平面的<code class="fe nc nd ne nf b">ARImageTrackingConfiguration</code>，而不是<code class="fe nc nd ne nf b">ARWorldTrackingConfiguration</code>。你给ARKit一些图像，配置扫描现实世界。但这很容易出错，因为我需要动态更新参考图像，根据调试控制台的说法，其中许多图像“没有足够的对比度”或“太小”。结果，我的应用程序一直死机，变得无法使用。</p><p id="21c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我研究了ARKit的其他配置，剩下的唯一有希望的选项是<code class="fe nc nd ne nf b">AROrientationTrackingConfiguration</code>。我试了一下——而且很快。几乎成功了。但是它几乎没有被记录，当我试图控制我的立方体在世界上的位置时，我不知道如何去做。我不能把点转换成米，我不能左右移动立方体，我不知道要移动多少。</p><p id="769f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我意识到苹果的ARKit对我的应用程序来说太过了。它是为放置复杂的3D模型而设计的，而不是2D矩形。它使用了超过300兆字节的内存。加载时间太长。要是ARKit更聪明，能够根据模型的复杂性进行自我调整就好了。也许那会在未来到来。</p><p id="8ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我决定打造自己的AR引擎。一个是为处理简单的2D模型而设计的。子弹上膛很快的子弹。一个如此简单的东西，它甚至真的不是一个引擎。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7999" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">本文的目标</h1><p id="7730" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">到本文结束时，我们将制作一个应用程序:</p><ol class=""><li id="a4fc" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">使用相机搜索单词“ARKit”</li><li id="a64e" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">在任何找到的匹配项上放置一个2D矩形</li><li id="c87c" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">根据加速器和陀螺仪数据调整矩形的位置，消除设备抖动</li></ol><p id="b030" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，我们将创建一个使用相机执行Command+F (Mac &gt; PC)的应用程序，并突出显示所有匹配。这是另一个视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7b3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以让我们开始吧！首先，你应该打印出我写的这个测试器文档(即使你不打印它，它也会工作得很好，但如果你打印它，就不会有眩光或<a class="ae lu" href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern" rel="noopener ugc nofollow" target="_blank">莫尔条纹</a>)。这是对查尔斯·狄更斯《双城记》的滑稽模仿。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu lx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链接到<a class="ae lu" href="https://drive.google.com/file/d/1RpJsl_NucRn9gncbHLTVF77kJ1IYmuqs/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">样本文本</a></p></figure><p id="f198" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有，<a class="ae lu" href="https://github.com/aheze/AlternativeARKit/tree/master/StarterProject" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">这里是启动项目</strong> </a>。<strong class="la iu"> </strong>到目前为止，我已经设置了摄像头和Vision的<code class="fe nc nd ne nf b">VNRecognizeTextRequest</code>来尽可能频繁地查找文本，通常大约是每秒一次。</p><h2 id="f1ab" class="nv mg it bd mh nw nx dn ml ny nz dp mp lh oa ob mr ll oc od mt lp oe of mv og bi translated">我会很快检查一下视力</h2><p id="b217" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在starter项目中，首先，我们制作一个<code class="fe nc nd ne nf b">VNRecognizeTextRequest</code> (VisionFiles → <code class="fe nc nd ne nf b">VisionOCR.swift</code>),并用完成处理程序初始化它。当Vision完成扫描时，这个处理程序被调用，它返回给我们一个<code class="fe nc nd ne nf b">VNRecognizedText</code>对象，其中包含检测到的文本及其边界框。</p><p id="8d41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是<code class="fe nc nd ne nf b">VNRecognizedText</code>返回多个单词，比如一个句子。我很确定它尽可能多地将单词串在一起，但是对于本文，我们对句子不感兴趣。相反，一个<code class="fe nc nd ne nf b">if</code>语句检查<code class="fe nc nd ne nf b">VNRecognizedText</code>以查看它是否包含单词<em class="lv"> ARKit </em>。如果是这样，我有一个方便的函数返回数组中所有出现的ARKit及其索引。</p><p id="87ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遍历该数组，我们打印出它的边界框以及它所在的句子，如下所示:</p><pre class="kj kk kl km gt oh nf oi oj aw ok bi"><span id="bd48" class="nv mg it nf b gy ol om l on oo">"throne of ARKit" | Position: x: 35<!-- -->, y: 68, width: 68, height: 9</span></pre><p id="94f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经做了一些转换——通常，边界框由左上角、右上角、右下角和左下角组成。它们被写成一个百分比(比如设备屏幕高度的0.3339873485394%)，原点在左下方。</p><h2 id="e32e" class="nv mg it bd mh nw nx dn ml ny nz dp mp lh oa ob mr ll oc od mt lp oe of mv og bi translated">所以第一步已经完成了！现在回到增强现实</h2><p id="5dc9" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">现在我们已经得到了匹配文本的2D坐标，我们想要<strong class="la iu">在它上面放置一个2D矩形</strong>。这将是一个<code class="fe nc nd ne nf b">UIView</code>。我将这个矩形称为highlightComponent。</p><p id="6c35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们想在“现实生活”中放置一个2D矩形真的，比听起来容易多了。转到VisionFiles → <code class="fe nc nd ne nf b">ARFunctions.swift</code>。您将看到一个名为<code class="fe nc nd ne nf b">placeHighlights(atTheseLocations rectangles: [CGRect])</code>的空函数。替换为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="9a19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，<code class="fe nc nd ne nf b">CGRect</code>数组由匹配文本的边界框组成。这将是我们从<code class="fe nc nd ne nf b">VNRecognizedText</code>中得到的。我们将遍历该数组，每次执行以下操作:</p><ol class=""><li id="5edc" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">创建新的<code class="fe nc nd ne nf b">UIView</code></li><li id="3da3" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">创建新的<code class="fe nc nd ne nf b">CAShapeLayer</code></li><li id="483e" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">在<code class="fe nc nd ne nf b">CAShapeLayer</code>中画一个矩形</li><li id="7dcb" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">将其添加到新的<code class="fe nc nd ne nf b">UIView</code></li><li id="d185" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">添加新的<code class="fe nc nd ne nf b">UIView</code>作为<code class="fe nc nd ne nf b">drawingView</code>(也是<code class="fe nc nd ne nf b">UIView</code>)的子视图</li></ol><p id="ef07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在我们进行任何循环之前，我们首先需要移除所有现存的<code class="fe nc nd ne nf b">drawingView</code>子视图，这样类似的事情就不会发生了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e6af15ec8a5d924efb02ca8c6233281e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*tq78K7KGKK912dY4LqU_Iw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哎呀…</p></figure><p id="9110" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，回到<code class="fe nc nd ne nf b">VisionOCR.swift</code>，我们将需要实际调用这个函数！首先，做一个新的<code class="fe nc nd ne nf b">CGRects</code>数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="f164" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并将print语句替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每当我们找到一个匹配，我们把它附加到CGRect数组</p></figure><p id="71bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…然后最后用<code class="fe nc nd ne nf b">CGRect</code>数组调用函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="ce90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建并运行应用程序，然后将您的手机悬停在tester文档上。到目前为止，我们对ar有了一个像样的错觉，第二步已经完成了一半！应用程序应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/eac9be9d32bfbb9f29f12269286d6c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6TPSPVv5F3sIuBBJHoPsYg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">到目前为止，一切顺利！</p></figure><p id="52ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，高亮组件淡入淡出，有点快——这没关系，但现在我们将制作动画！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="dd58" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">重用旧的高光并制作动画</h1><p id="4b75" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">它是这样工作的:我们将制作一个包含前面的highlight组件的<code class="fe nc nd ne nf b">UIView</code>数组。</p><pre class="kj kk kl km gt oh nf oi oj aw ok bi"><span id="9765" class="nv mg it nf b gy ol om l on oo">/// In ViewController.swift, add this:</span><span id="2763" class="nv mg it nf b gy os om l on oo">var previousHighlightComponents = [UIView]()</span></pre><p id="6614" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每次视觉扫描后，我们不会淡出任何现有的highlight组件，而是首先在<code class="fe nc nd ne nf b">previousHighlightComponents</code>上<strong class="la iu">循环，并检查任何现有的(先前的)highlight组件与当前highlight组件的距离是否小于15点。是的，15分是一个神奇的数字，但有时你必须成为一名巫师！</strong></p><p id="e0e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">&gt;如果有一个距离小于15磅，我们不会添加一个新的highlightComponent，而是将旧的组件重用并动画到新组件的位置。</p><p id="683f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有，我们就淡入新的。</p><p id="c22d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<code class="fe nc nd ne nf b">placeHighlights(atTheseLocations:)</code>替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="b7d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在构建并再次运行应用程序。这种错觉会更加真实，因为我们是在制作动画而不是渐变。<strong class="la iu">步骤2现已全部完成。</strong>这是应用程序的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a293105b74d97b3dc6014020c380561a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CoU_Iu61Vif2pMtKivRgiQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">好多了！</p></figure><p id="a52c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，还记得<code class="fe nc nd ne nf b">AROrientationTrackingConfiguration</code>，那个几乎对我有效的选项吗？实际上，它所做的只是获取设备的加速度计数据。我们可以使用<code class="fe nc nd ne nf b">CMMotionManager</code>轻松做到这一点。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="78e0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用加速度计和陀螺仪消除手抖</h1><p id="210e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">苹果已经为我们做了很多工作，很容易就能知道设备的方位。设备的偏航/俯仰/滚动值是可用的，但是我们只对俯仰和滚动感兴趣(比如向前/向后和向左/向右倾斜设备)。</p><p id="12f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能已经在苹果的Measure应用程序(或iOS 13之前的Compass)中遇到过<code class="fe nc nd ne nf b">CMMotionManager</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/70749781dec61e67e6a9ffb6c355ad50.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Qmt3btceNgOCtRD5phsUTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">很酷的设计，对吧？</p></figure><p id="e835" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但无论如何，我们将使用核心运动来稳定我们的高光，以防设备抖动太多。让我们首先将这一行添加到<code class="fe nc nd ne nf b">ViewController.swift</code>和<code class="fe nc nd ne nf b">ARFunctions.swift</code>的顶部:</p><pre class="kj kk kl km gt oh nf oi oj aw ok bi"><span id="faf6" class="nv mg it nf b gy ol om l on oo"><strong class="nf iu">import</strong> CoreMotion</span></pre><p id="6a9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将导入<code class="fe nc nd ne nf b">CoreMotion</code>框架，以便我们可以实际使用它。然后，回到<code class="fe nc nd ne nf b">ViewController.swift</code>，添加一个新的<code class="fe nc nd ne nf b">CMMotionManager</code>对象和一些属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="7aee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们将在<code class="fe nc nd ne nf b">viewDidLoad</code>中设置运动管理器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="77f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们将覆盖<code class="fe nc nd ne nf b">viewDidLayoutSubviews()</code>并获得当前的态度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="205c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么<code class="fe nc nd ne nf b">attitude</code>是什么，为什么要放在<code class="fe nc nd ne nf b">viewDidLayoutSubviews()</code>里？非常简单:<code class="fe nc nd ne nf b">attitude</code>是一个包含设备相对于参考框架的方向的类。每隔0.03秒，我们将比较设备的当前姿态和初始姿态，以查看设备旋转的方向。</p><p id="7178" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该初始参考帧将由<code class="fe nc nd ne nf b">viewDidLayoutSubviews()</code>中的<code class="fe nc nd ne nf b">initialAttitude</code>设置，因为当设备完成UI布局时会调用<code class="fe nc nd ne nf b">viewDidLayoutSubviews()</code>——这通常也是设备的姿态首次可用的时候。</p><p id="d0e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们需要创建每0.03秒调用一次的函数。</p><p id="6a3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将此复制到VisionFiles → <code class="fe nc nd ne nf b">ARFunctions.swift</code>，在<code class="fe nc nd ne nf b">placeHighlights(atTheseLocations rectangles: [CGRect])</code>上方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op lx l"/></div></figure><p id="e699" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建并运行。摇动设备，但不要太多！考虑到设备抖动，高光会稍微移动！<strong class="la iu">第三步完成，app也完成了。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/90ce719add98f4ea4d2d82a8e54fc67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o5GoLf9k58xiPW0ajG-_sw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">很酷，对吧？</p></figure><p id="32ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是完成的应用程序的<a class="ae lu" href="https://github.com/aheze/AlternativeARKit/tree/master/FinishedProject/AlternativeARKit" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="62e0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">总结</h1><p id="2c23" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">到目前为止，你已经有了一个应用程序，它可以找到文本，然后在它上面放置一个高亮显示。如果你轻轻摇晃手机，高光将会调整以抵消抖动(当然，不要过度摇晃手机，否则Vision将无法执行OCR)！</p><p id="5ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与ARKit不同，这个程序只能放置2D物体，并需要不断更新的数据源——例如，视觉每半秒扫描一次——所以它也需要相当多的前提条件。</p><p id="dfa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，它的使用案例没有任何限制。以下是一些开始:</p><ul class=""><li id="8a0a" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt ou nm nn no bi translated">二维码扫描仪，显示检测到的二维码周围的框架(苹果在相机应用程序中实现了这一功能)</li><li id="5970" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt ou nm nn no bi translated">像谷歌翻译的即时相机翻译的文本翻译</li><li id="4720" class="ng nh it la b lb np le nq lh nr ll ns lp nt lt ou nm nn no bi translated">对象检测器，在检测到的对象周围绘制一个框架</li></ul><p id="419c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，几乎所有这些代码都来自我的应用程序Find！如果你想下载，这里有:</p><div class="ov ow gp gr ox oy"><a href="https://apps.apple.com/app/find-command-f-for-camera/id1506500202" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">查找:相机的Command+F</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">使用手机摄像头，同时查找单个单词甚至多个单词。</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">apps.apple.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><p id="e94a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对Vision和ARKit感兴趣，这里有一些链接可供进一步阅读:</p><div class="ov ow gp gr ox oy"><a href="https://bendodson.com/weblog/2019/06/11/detecting-text-with-vnrecognizetextrequest-in-ios-13/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">在iOS 13中使用VNRecognizeTextRequest检测文本</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在2017年WWDC上，苹果在iOS 11的同时推出了Vision框架。Vision旨在帮助开发人员分类…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">bendodson.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://nshipster.com/cmdevicemotion/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">CMDeviceMotion</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在每部iPhone的光滑玻璃下，一组传感器坐落在逻辑板上，发送稳定的…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">nshipster.com</p></div></div><div class="ph l"><div class="po l pj pk pl ph pm ks oy"/></div></div></a></div><p id="55c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！编码快乐！</p></div></div>    
</body>
</html>