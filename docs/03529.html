<html>
<head>
<title>Functional Programming With Java: Immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程:不变性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-with-java-immutability-8dc748e85f9e?source=collection_archive---------3-----------------------#2020-02-16">https://betterprogramming.pub/functional-programming-with-java-immutability-8dc748e85f9e?source=collection_archive---------3-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具有不可变状态的更好的数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79e7ebf21a9b4146b8ffa6b73ddfb7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmfyJKskTRdKjfg9vXuc9Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@zoltantasi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Zoltan·塔斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/rock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="15b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener">的第一篇文章</a>中所阐述的，不变性是函数式编程的核心概念之一。真正的函数式编程语言通过设计在语言层面上支持它。但是在Java和大多数非函数式语言中，我们需要自己在代码级设计和实现它。</p><p id="0a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不变性背后的基本思想很简单:如果我们想改变一个数据结构，我们需要创建一个新的副本，而不是改变原始的数据结构。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5c87" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么不变性很重要</h1><p id="a562" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为什么我们要采取额外的步骤来改变一个值呢？因为使用不可变的数据结构，我们获得了很多优势:</p><ul class=""><li id="23d1" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">数据不会“在我们背后”改变</li><li id="f218" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">一经核实，将无限期有效。</li><li id="bcaf" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">没有隐藏的副作用。</li><li id="3c67" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">没有“半初始化”的对象，通过不同的方法直到完成。这将解耦方法，有希望使它们成为纯粹的函数。</li><li id="76d2" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">线程安全:不再有<a class="ae ky" href="https://en.wikipedia.org/wiki/Race_condition#Computing" rel="noopener ugc nofollow" target="_blank">竞争条件</a>。如果一个数据结构从不改变，我们可以安全地在多线程中使用它。</li><li id="5711" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">更好的缓存性能。</li><li id="7223" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">可能的优化技术，如<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731#984c" rel="noopener">参考透明度</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fdbb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Java不变性的状态</h1><p id="0408" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从设计上来说，Java不是一种具有不可变性的语言，但是它为我们提供了自己创建不可变数据结构所需的所有部分。</p><h2 id="276d" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">内置不可变类型</h2><p id="9cd2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">JDK中有各种不可变类型。这里有一些你可能已经遇到过的:</p><ul class=""><li id="b15b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">原始包装器(<code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html" rel="noopener ugc nofollow" target="_blank">java.lang.Integer</a></code>、<code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html" rel="noopener ugc nofollow" target="_blank">java.lang.Boolean</a></code>等)。)</li><li id="13bb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">java.lang.String</code>(除了一个<a class="ae ky" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/jdk/src/java.base/share/classes/java/lang/String.java#L1512" rel="noopener ugc nofollow" target="_blank">懒惰计算的</a>哈希码)</li><li id="0079" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">数学类型(<code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html" rel="noopener ugc nofollow" target="_blank">java.math.BigInteger</a></code>、<code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html" rel="noopener ugc nofollow" target="_blank">java.math.BigDecimal</a></code>)</li><li id="918a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">枚举</li><li id="3fea" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Locale.html" rel="noopener ugc nofollow" target="_blank">java.util.Locale</a></code></li><li id="b70c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html" rel="noopener ugc nofollow" target="_blank">java.util.UUID</a></code></li><li id="da01" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" rel="noopener ugc nofollow" target="_blank"> Java 8日期/时间API </a></li></ul><h2 id="40e4" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">“最终”关键字</h2><p id="6d15" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Final_(Java)" rel="noopener ugc nofollow" target="_blank">final</a></code>用于定义一个只能赋值一次的变量。起初这听起来像是不变性，但实际上不是。</p><p id="6cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是创建一个不可变的数据结构，只有对它的引用是不可变的。这只能确保一个变量总是指向内存中的同一个点，它对内存内容本身没有任何影响。</p><h2 id="9145" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">Java 14</h2><p id="21f9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">2020年3月，JDK 14将发布<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank">记录</a>预览:浅不可变数据的“数据持有者”。希望我们可以用记录替换许多JavaBean类型，尽管与传统类相比有多种限制。它们将使记录使用起来更安全，但我们可能不得不重新思考如何构建我们的数据结构。</p><p id="6d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于包括我自己在内的许多开发人员来说，Java 14是遥远的未来。我用的是Java 8，希望很快会是Java 9。因此，现在让我们看看实现不变性的其他选择。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="610f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如何变得不可改变</h1><p id="d506" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有两种方法可以有效地创建不可变的数据结构而不需要Java 14记录:我们自己做，或者使用第三方框架。</p><h2 id="32b3" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">DIY永恒</h2><p id="8e5e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">考虑一个典型的JavaBean:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a1b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaBeans被设计成带有getters和setters的T2，因此它们可以用于各种场景。许多框架，如ORM或GUI设计器，都是基于反射的T4。它们分析类来识别getter和setter，通过反射直接使用字段，因此大多与不可变设计不兼容。</p><p id="70fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个陷阱可能是副作用。设置器可能不只是设置一个值，它们可能跟踪一个“脏状态”或设置多个值。这不是一个好的实践，但它总是发生。</p><p id="d454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种特殊的JavaBean设计并不是必须的或固定的规则。这是我们经常使用的惯例，因为<a class="ae ky" href="https://medium.com/better-programming/habit-driven-development-and-finding-your-own-style-32786e1eb8c8" rel="noopener">习惯驱动开发</a>，而不是因为我们实际上需要那个特定的设计。</p><p id="e1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打破传统的bean设计，让它成为不可变的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真的很简单，我们得到了更短、更简洁的代码。现在我们的数据结构一旦初始化就不会发生意外的变化。</p><p id="f485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非我们添加更多可变类型的字段…</p><p id="1039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可变数据结构的每个字段都必须是不可变的。它的类型的每个字段也必须是不可变的。对于单一的可变类型，甚至可能是深度嵌套的，不可变的所有好处都将被破坏。</p><p id="f908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集合也是有问题的类型。不可修改的集合从Java 7开始就存在了。在Java 9中，增加了易于使用的<a class="ae ky" href="https://docs.oracle.com/en/java/javase/11/core/creating-immutable-lists-sets-and-maps.html#GUID-DD066F67-9C9B-444E-A3CB-820503735951" rel="noopener ugc nofollow" target="_blank">工厂方法</a>。但是，就像<code class="fe oa ob oc od b">final</code>一样，这只意味着集合本身不可修改，而不是包含的对象不可修改。所以请确保只在其中保存已经不可变的数据结构。</p><h2 id="be34" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">构建器模式</h2><p id="6ece" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们确保所有的字段都是不可变的，不管它们嵌套得有多深。但是我们还有一个问题:<em class="lv">如何构建数据结构</em>。</p><p id="6db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有字段都必须在初始化时设置，所以我们需要一个包含所有字段的构造函数。但是如果我们不需要设置所有的字段呢？我们应该提供多个构造函数还是静态构造方法？我们如何确保设置了所有必需的字段并且结果对象是有效的？</p><p id="7c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="lv">构建器模式</em> </a>。</p><p id="9f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个额外的类来封装构建不可变数据结构的复杂过程。通过将创建过程与表示分离，我们获得了对数据结构组装过程的精细控制，甚至可以添加验证。但这也意味着我们引入了一个可变的构建器，所以我们可以有一个不可变的数据结构。</p><p id="6edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个更复杂的用户类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字段<code class="fe oa ob oc od b">active</code>和<code class="fe oa ob oc od b">lastLogin</code>是可选的——默认情况下，用户在明确声明之前是不活动的，并且从未登录过。要么在每次创建用户时提供参数，要么添加额外的构造函数来匹配不同的参数组合。</p><p id="4227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是类型越复杂，我们需要的构造函数就越多。相反，我们创造了一个<code class="fe oa ob oc od b">builder</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用流畅的API来构建用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="198f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以分多个步骤来构建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使我们的构建器更好，我们可以向方法或构造器添加验证—例如空检查，或电子邮件/密码验证—并抛出一个适当的异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将builder类作为静态嵌套类<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" rel="noopener ugc nofollow" target="_blank">直接放入相应的类型中来增加封装性是一个很好的做法。这样我们就可以一直使用类型名<code class="fe oa ob oc od b">Builder</code>:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们成功地创建了一个不可变类型和一个相应的构建器。但是这是一大堆样板文件，每次我们引入一个新的类型时都很麻烦。我们写的每一段代码都可能引入错误。</p><p id="f99b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么使用第三方框架是一种真正的解脱，省去了键入所有代码，并提供了许多方便的方法和验证。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bcd5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">第三方框架</h1><p id="76c0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以使用第三方框架，专注于数据结构的设计和建模，而不是自己编写所有代码。有了第三方框架，生成的代码不容易出错，得到的数据结构也更简洁。</p><h2 id="c563" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">不变的</h2><p id="c575" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如项目“<a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank">不变的</a>”所描述的那样:</p><blockquote class="og"><p id="b287" class="oh oi it bd oj ok ol om on oo op lu dk translated"><em class="oq"> Java注释处理器生成简单、安全和一致的值对象。不要重复自己，试试Immutables，这个领域最全面的工具！</em></p></blockquote><p id="bf46" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">创建一个不可变类型就像创建一个抽象类型一样简单，要么是一个<code class="fe oa ob oc od b">abstract class</code>要么是一个<code class="fe oa ob oc od b">interface</code>，然后添加正确的注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注释处理器在幕后生成实际的实现，包括:</p><ul class=""><li id="886f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">序列化支持。</li><li id="e877" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">生成器类。</li><li id="0a6d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">需求验证。</li><li id="b75f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">方便复制的方法等。</li><li id="b1b8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">equals</code>、<code class="fe oa ob oc od b">hashCode</code>和<code class="fe oa ob oc od b">toString</code></li></ul><p id="c4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用提供的构建器创建一个不可变的用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f0d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于使用了<code class="fe oa ob oc od b"><a class="ae ky" href="https://immutables.github.io/immutable.html#default-attributes" rel="noopener ugc nofollow" target="_blank">@Value.Default</a></code>注释和<code class="fe oa ob oc od b">Optional</code>类型，我们在调用<code class="fe oa ob oc od b">build()</code>时自动得到验证。如果没有满足所有的要求，抛出一个<code class="fe oa ob oc od b">IllegalStateException</code>。</p><p id="f12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架提供的另一个便利是添加助手方法来创建不可变的副本，而无需重置所有值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以找一个新的建筑商合作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是冰山一角，功能列表很全面:</p><ul class=""><li id="98f0" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/immutable.html#strict-builder" rel="noopener ugc nofollow" target="_blank">严格构建器</a>:每个构建器只允许使用一次构建器方法。</li><li id="a109" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/immutable.html#derived-attributes" rel="noopener ugc nofollow" target="_blank">派生属性</a>:从其他属性派生的只读值。</li><li id="5636" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/immutable.html#precondition-check-method" rel="noopener ugc nofollow" target="_blank">前提条件</a>:增加前提条件检查，如交叉验证。</li><li id="8105" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/immutable.html#auxiliary-attributes" rel="noopener ugc nofollow" target="_blank">辅助属性</a>:从<code class="fe oa ob oc od b">equals</code>、<code class="fe oa ob oc od b">hashCode</code>、<code class="fe oa ob oc od b">toString</code>中排除一个属性。</li><li id="f2c3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/style.html" rel="noopener ugc nofollow" target="_blank">风格定制</a>:可以定制生成代码的很多方面。</li><li id="9879" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/json.html" rel="noopener ugc nofollow" target="_blank"> JSON支持</a> : <a class="ae ky" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank">杰克森</a>和<a class="ae ky" href="https://github.com/google/guava" rel="noopener ugc nofollow" target="_blank">芭乐</a>。</li><li id="c64b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">…以及更多</li></ul><h2 id="d4c8" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">龙目岛项目</h2><p id="0dcf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://projectlombok.org" rel="noopener ugc nofollow" target="_blank"> Project Lombok </a>是一个全面的工具，试图减少常见Java样板代码的数量，如<a class="ae ky" href="https://projectlombok.org/features/GetterSetter" rel="noopener ugc nofollow" target="_blank">getter和setter</a>、<a class="ae ky" href="https://projectlombok.org/features/NonNull" rel="noopener ugc nofollow" target="_blank"> null checks </a>、<a class="ae ky" href="https://projectlombok.org/features/EqualsAndHashCode" rel="noopener ugc nofollow" target="_blank"> equals/hashCode </a>或<a class="ae ky" href="https://projectlombok.org/features/ToString" rel="noopener ugc nofollow" target="_blank"> toString </a>。</p><p id="c0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然还有<a class="ae ky" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank">不变的</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="228f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注释<code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank">@Value</a></code>相当于使用这些不言自明的注释:</p><ul class=""><li id="d947" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/GetterSetter" rel="noopener ugc nofollow" target="_blank">@Getter</a></code></li><li id="1968" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b">@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)</code></li><li id="c4e6" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/constructor" rel="noopener ugc nofollow" target="_blank">@AllArgsConstructor</a></code></li><li id="3423" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/EqualsAndHashCode" rel="noopener ugc nofollow" target="_blank">@EqualsAndHashCode</a></code></li><li id="db5f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/ToString" rel="noopener ugc nofollow" target="_blank">@ToString</a></code></li></ul><p id="e219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一缺少的是<code class="fe oa ob oc od b"><a class="ae ky" href="https://projectlombok.org/features/Builder" rel="noopener ugc nofollow" target="_blank">@Builder</a></code>，它给我们的例子增加了<code class="fe oa ob oc od b">User.builder()</code>。</p><p id="c8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">龙目岛项目是减少样板文件的好工具。但是对于构建灵活的不可变数据结构，我会推荐<a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank">不可变</a>。两个项目有不同的目标，我认为一个名为“Immutables”的项目在不变性方面有更好的特性是不言而喻的！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ab0c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="1129" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不变性对于许多种类的软件项目都是一个好主意，不仅仅是没有内置支持的语言。即使对于数据存储，它也能提供优势，例如版本控制系统Git。它使用不可变提交来确保完整性。</p><p id="3c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这并不意味着每个问题都可以用不可变的数据结构来解决。可变状态本身并不是一件坏事。我们只需要确定何时使用它，并意识到改变状态的陷阱。</p><p id="5a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个缺点是，至少在一开始，要让你的代码库适应新的数据结构。改变它们并不是一个简单的替代。但它有助于我们创建一个更可预测的数据流，具有容易观察到的状态变化。</p><h2 id="29c5" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">我们现实世界的例子</h2><p id="7e45" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们决定开始使用不变量来简化会话管理。对于深度嵌套的非不可变数据结构，检测“脏”会话可能很困难。并且为每个请求保留每个会话会产生大量不必要的开销。</p><p id="9768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了我们新的会话数据结构，它只包含不可变类型作为字段，检测已更改的会话要简单得多:如果字段被更新，会话就是脏的。不再背着我们修改嵌套的对象。</p><p id="1b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们并没有止步于会话管理。我们已经开始用不变量替换越来越多的类型，以消除许多微妙的错误，比如无效的状态或竞争条件。如果一个数据结构在它的生命周期中没有太大的变化，我们试图使它不可变。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ow od ox bn oy oz bi"><span id="2632" class="pa me it od b be pb pc l pd pe"><strong class="od iu">You like my ramblings about Java? Check out my upcoming book!</strong><br/><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="a331" class="md me it bd mf mg pf mi mj mk pg mm mn jz ph ka mp kc pi kd mr kf pj kg mt mu bi translated">资源</h1><ul class=""><li id="7785" class="na nb it lb b lc mv lf mw li pk lm pl lq pm lu nf ng nh ni bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html" rel="noopener ugc nofollow" target="_blank"> Java教程</a></li><li id="22c3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank">爪哇记录(预览)</a> (JEP 359)</li></ul><h2 id="9f02" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">图书馆</h2><ul class=""><li id="422b" class="na nb it lb b lc mv lf mw li pk lm pl lq pm lu nf ng nh ni bi translated"><a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank">一成不变的</a></li><li id="fa7d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">龙目岛项目</a></li></ul><h2 id="5c35" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">文章</h2><ul class=""><li id="58ec" class="na nb it lb b lc mv lf mw li pk lm pl lq pm lu nf ng nh ni bi translated"><a class="ae ky" href="https://www.baeldung.com/immutables" rel="noopener ugc nofollow" target="_blank">不变量介绍</a> (Baeldung)</li><li id="eaf5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://www.baeldung.com/intro-to-project-lombok" rel="noopener ugc nofollow" target="_blank">龙目岛项目介绍</a> (Baeldung)</li><li id="20e0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://reflectoring.io/java-immutables/" rel="noopener ugc nofollow" target="_blank">为什么不变量是更好的对象，以及如何实现它们</a>(反射)</li></ul><div class="pn po gp gr pp pq"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">Java函数式编程:流</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">最佳实践概述</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">medium.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ks pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://medium.com/better-programming/functional-programming-with-java-whats-in-the-box-4c0ee20035af" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">Java函数式编程:盒子里是什么</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">JDK中可用的不同种类的功能接口</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">medium.com</p></div></div><div class="pz l"><div class="qf l qb qc qd pz qe ks pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">Java函数式编程:简介</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">Java从来就不是函数式语言，但这并不意味着我们不能尝试</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">medium.com</p></div></div><div class="pz l"><div class="qg l qb qc qd pz qe ks pq"/></div></div></a></div></div></div>    
</body>
</html>