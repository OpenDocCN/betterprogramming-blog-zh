<html>
<head>
<title>Prisma vs. TypeORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Prisma vs. TypeORM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/prisma-vs-typeorm-60d02f9dac64?source=collection_archive---------0-----------------------#2020-09-01">https://betterprogramming.pub/prisma-vs-typeorm-60d02f9dac64?source=collection_archive---------0-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fbd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Node.js/TypeScript生态系统中数据库工具的实际应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/587f95f164d72be1aa9ef2ff289b4809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MgonBQhxLNUHgEqw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托拜厄斯·菲舍尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用数据库是后端开发人员不可避免的一部分。</p><p id="9d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，服务器端JavaScript生态系统提供了无数的库，旨在减轻这项任务的痛苦。一些最受欢迎的包括:</p><ul class=""><li id="391a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://www.npmjs.com/package/sequelize" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Sequelize</strong></a><strong class="lb iu"/>(一个对象关系映射器，或ORM，库)</li><li id="7337" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.npmjs.com/package/pg" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">pg</strong></a><strong class="lb iu">/</strong><a class="ae ky" href="https://www.npmjs.com/package/mysql" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">MySQL</strong></a><strong class="lb iu"/>(用于与特定数据库接口的JavaScript客户端)</li><li id="b333" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.npmjs.com/package/knex" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Knex.js </strong> </a>(通用查询生成器)</li></ul><p id="f537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些库各有优缺点。</p><p id="f498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用像pg这样的低级库可以提供显著的性能优势，但代价是维护起来很困难(当您编写原始SQL查询时)。尽管如此，使用这些库可能会让新开发人员感到困惑，因为他们需要对SQL有很强的理解。</p><p id="f507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，像Sequelize这样的ORM提供了方便的抽象，通常简化了数据库的工作。然而，它们是以性能为代价的，因为生成的底层SQL通常不如有经验的程序员编写的SQL高效。</p><p id="5d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Knex.js这样的查询构建器旨在比ORM更简单、更高效，但比原始SQL更易于使用和维护。尽管有这个目标，他们仍然需要很好地理解SQL，以便在大多数情况下使用。</p><blockquote class="mj mk ml"><p id="46c1" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">“任何傻瓜都能写出计算机能理解的代码。优秀的程序员会写出人类能理解的代码。”—马丁·福勒</p></blockquote><p id="1b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，没有完美的工具来处理数据库。然而，TypeScript和Node.js的日益流行导致了几个旨在提供改进的开发人员UX、简化的代码和可接受的性能的库的发展。其中两个是<a class="ae ky" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>和<a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>。</p><p id="1ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几节中，我们将看一下每个工具的高级概述，浏览一些常见的开发人员场景，并从开发人员的角度对每个场景进行评估。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a245" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">大局</h1><h2 id="3059" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">Prisma概述</h2><p id="d13b" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在本文中，我们将关注Prisma 2.x。虽然Prisma与JavaScript兼容，但以下所有示例都将使用TypeScript。</p><p id="6c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，最常见的问题之一是，“<em class="mm">Prisma是ORM吗？</em>“虽然它与ORM有一些共同的特征，但深入观察就会发现它是不同的。</p><blockquote class="mj mk ml"><p id="9387" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated">ORM是将数据库中的表映射到编程语言中的类的库。另一方面，Prisma是一个数据库工具包。该工具包包括Prisma Client，这是一个自动生成的查询生成器，可以显示为您的模型定制的查询<em class="it">。所有Prisma客户端查询都返回普通的旧JavaScript对象。— <a class="ae ky" href="https://www.prisma.io/docs/understand-prisma/prisma-in-your-stack/is-prisma-an-orm" rel="noopener ugc nofollow" target="_blank"> Prisma文档</a></em></p></blockquote><p id="858f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解上述引文，Prisma将自己标榜为“数据库工具包”其中的三个主要组成部分是:</p><ul class=""><li id="70bc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Prisma客户端</strong> </a> <strong class="lb iu"> </strong>(生成应用程序代码中使用的客户端)</li><li id="edbf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-migrate" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Prisma Migrate</strong></a><strong class="lb iu"/>(允许你改变数据库模式)</li><li id="405d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-studio" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Prisma工作室</strong> </a> <strong class="lb iu"> </strong>(一个可视化的数据库编辑器)</li></ul><p id="e555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在写这篇文章的时候，Prisma Migrate和Prisma Studio还处于实验阶段。有关开发时间表的详细信息，请参见产品路线图<a class="ae ky" href="https://www.notion.so/Prisma-public-roadmap-50766227b779464ab98899accb98295f" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="6daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma和ORM的一个显著区别是它的集中式模式文件和模式语言。Prisma将数据库模型从代码中分离出来，而不是在应用程序中将类映射到数据库实体。</p><p id="006d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Prisma CLI使用此模式文件自动生成一个客户端，该客户端可在您的TypeScript代码中使用，以便与数据库进行交互。这种范式与ORM略有不同，在ORM中，模型类的实例扮演这个角色。</p><h2 id="d3f5" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">类型概述</h2><p id="82d5" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated"><strong class="lb iu">注意:</strong>演示TypeORM的代码示例将使用存储库、查询构建器和TypeScript(尽管支持普通的JavaScript)。</p><p id="e5a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM是Node.js的开源ORM，它利用了现代JavaScript特性，并鼓励使用TypeScript。看它的语法和结构，很明显它从其他编程语言/框架中的成功ORM中获得了灵感，比如<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/entity-framework" rel="noopener ugc nofollow" target="_blank">实体框架</a>(。NET)和<a class="ae ky" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/" rel="noopener ugc nofollow" target="_blank"> Hibernate </a> (Java)。</p><p id="8265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从较高的层面来看，TypeORM包含了一些特性，比如迁移、事务、CLI以及与应用程序数据模型中定义的实体进行交互的多种方式。实体是TypeORM的核心组件之一，和其他ORM一样，它们是映射到数据库表的类。</p><p id="3708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM更强大的特性之一是如何在代码中处理实体。具体来说，TypeORM支持<a class="ae ky" href="https://en.wikipedia.org/wiki/Active_record_pattern" rel="noopener ugc nofollow" target="_blank">活动记录</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_mapper_pattern" rel="noopener ugc nofollow" target="_blank">数据映射器</a>模式。</p><p id="03fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高层次上，活动记录模式涉及数据库功能(创建、读取、更新、删除等。)直接在模型类上定义。例如，如果我们有一个company类，那么每个类实例都在它的方法集中包含像<code class="fe og oh oi oj b">create</code>这样的数据库函数。同样，TypeORM将此实现为在任何扩展内置<code class="fe og oh oi oj b"><a class="ae ky" href="https://typeorm.delightful.studio/classes/_repository_baseentity_.baseentity.html" rel="noopener ugc nofollow" target="_blank">BaseEntit</a>y</code>类的实体类上定义的数据库操作。</p><p id="3259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看看数据映射器模式，它与活动记录模式有细微的不同。特别是，数据映射器模式包含了与定义数据库功能的实体相分离的类(有时称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_access_object" rel="noopener ugc nofollow" target="_blank">数据访问对象</a>)。在这种范式中，实体是定义其属性的简单数据结构，而数据映射器类公开了与数据库交互所需的实际功能。TypeORM提供了两个抽象，允许您应用这个模式，<a class="ae ky" href="https://typeorm.io/#/working-with-repository" rel="noopener ugc nofollow" target="_blank">存储库</a>和<a class="ae ky" href="https://typeorm.io/#/working-with-entity-manager" rel="noopener ugc nofollow" target="_blank">实体管理器</a>。这两者之间的根本区别在于，存储库只对单一实体类型进行操作，也就是说，一个<code class="fe og oh oi oj b">Company</code>实体对应一个<code class="fe og oh oi oj b">CompanyRepository</code>。相比之下，实体管理器是所有存储库的集合。</p><p id="14f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM提供了另一种处理数据库的方法，称为<a class="ae ky" href="https://typeorm.io/#/select-query-builder" rel="noopener ugc nofollow" target="_blank">查询构建器</a>。这个特性将Knex.js之类的查询构建库集成到TypeORM中。它对于复杂的查询特别有用，使用SQL比其他类型的抽象(存储库、实体管理器等)公开的API更简单。).我们将在后面的章节中研究如何有效地应用这个工具。</p><p id="4a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概述结束后，让我们通过基于代码的示例深入一些使用每种技术的常见开发人员场景。</p><p id="0925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:以下示例的完整/工作源代码可以在<a class="ae ky" href="https://github.com/nmchenry01/prisma-typeorm-blog" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5c0a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">设置Prisma</h1><p id="a439" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">要设置Prisma，我们需要一些依赖项。具体来说，<a class="ae ky" href="https://www.npmjs.com/package/@prisma/client" rel="noopener ugc nofollow" target="_blank"> Prisma客户端</a>和<a class="ae ky" href="https://www.npmjs.com/package/@prisma/cli" rel="noopener ugc nofollow" target="_blank"> Prisma CLI </a>。</p><p id="d312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦这些都在我们的<code class="fe og oh oi oj b">package.json</code>中，我们还需要一个Prisma模式文件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Prisma模式文件示例</p></figure><p id="4fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到了几个Prisma构造，包括生成器、数据源和模型。</p><p id="84b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器块提供了我们运行CLI <code class="fe og oh oi oj b">prisma generate</code>命令时将创建的客户端的详细信息。在这个特殊的例子中，我们指定我们想要创建一个JavaScript客户机。值得注意的是，Prisma还支持一个<a class="ae ky" href="https://github.com/prisma/prisma-client-lib-go" rel="noopener ugc nofollow" target="_blank"> Go </a>客户端。</p><p id="233f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据源<strong class="lb iu"> <em class="mm"> </em> </strong>块定义了数据库连接。在上面的实例中，我们使用由下面所示的<code class="fe og oh oi oj b">.env</code>文件提供的URL连接到本地Postgres实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">答。定义URL的env文件</p></figure><p id="e50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型块表示作为应用程序域一部分的表。我们有三张桌子，包括<code class="fe og oh oi oj b">Company</code>、<code class="fe og oh oi oj b">Product</code>和<code class="fe og oh oi oj b">Customer</code>。使用Prisma模式语言(PSL)，我们可以简洁地定义表之间的关系(<a class="ae ky" href="https://en.wikipedia.org/wiki/One-to-many_(data_model)" rel="noopener ugc nofollow" target="_blank">一对多</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Many-to-many_(data_model)" rel="noopener ugc nofollow" target="_blank">多对多</a>等)。)、主键、唯一性约束等等。</p><p id="64a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在产品和客户之间定义多对多关系的情况下，我们不需要在模式中显式声明一个连接表。为此，我们使用Prisma的<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#implicit-many-to-many-relations" rel="noopener ugc nofollow" target="_blank">隐式多对多</a>关系特性。这个特性仍然在底层数据库中创建一个连接表，但是允许我们从代码中抽象出来。</p><p id="c9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得更多的细节和更深入地了解PSL的可能性，我鼓励你查看一下官方规格<a class="ae ky" href="https://github.com/prisma/specs/tree/master/schema" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="20cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了在我们的应用程序代码中使用Prisma客户机，我们需要为我们的数据模型生成一个客户机，并应用数据库模式。我们通过CLI运行<code class="fe og oh oi oj b">prisma generate</code>和<code class="fe og oh oi oj b">prisma migrate save --experimental &amp;&amp; prisma migrate up --experimental</code>来实现这一点。</p><p id="b3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，我们的应用程序的模式将被应用到本地数据库，并且在我们的<code class="fe og oh oi oj b">node_modules/@prisma/client</code>目录中会生成一个定制的Prisma客户端。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="206a" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">设置类型表单</h1><p id="94dd" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">要安装TypeORM，我们还需要安装一些依赖项。值得注意的是，我们需要<a class="ae ky" href="https://www.npmjs.com/package/typeorm" rel="noopener ugc nofollow" target="_blank">类型的表单包</a>、<a class="ae ky" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank">反射元数据</a>，以及一个数据库驱动程序(在我们的例子中，是<a class="ae ky" href="https://www.npmjs.com/package/pg" rel="noopener ugc nofollow" target="_blank"> pg </a>)。</p><p id="016d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦这些都在我们的<code class="fe og oh oi oj b">package.json</code>中，我们将需要一个如下所示的配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TypeORM的配置文件</p></figure><p id="03ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在配置文件中，我们做了各种事情，包括:</p><ul class=""><li id="80a6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">为我们的本地Postgres数据库定义连接细节</li><li id="ef19" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将<code class="fe og oh oi oj b">synchronize</code>选项设置为true，这样无论何时连接，我们的应用程序和数据库之间的数据模型都是一致的(在生产中应该是关闭的)</li><li id="2574" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在我们的实体被传送后指向它们的位置</li></ul><p id="7852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，TypeORM支持JSON以外的配置文件格式。更多详细信息，请参见此处的<a class="ae ky" href="https://typeorm.io/#/using-ormconfig" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是定义属于应用程序域的实体。我们将使用与Prisma安装时相同的工具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">公司实体</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品实体</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户实体</p></figure><p id="cd53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的模型中，我们创建了与前面相同的列、关系和约束。为了定义所有这些，TypeORM利用了TypeScript<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">decorator</a>。这样做的结果是一个清晰的语法，易于阅读和理解。关于TypeORM装饰器的完整列表，请看这里的<a class="ae ky" href="https://typeorm.io/#/decorator-reference" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="d295" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">创造</h1><h2 id="714e" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="63c5" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">首先，我们将在下面插入一家公司:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建公司(Prisma)</p></figure><p id="6f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熟悉GraphQL的开发人员会很快熟悉Prisma的语法。在上面的代码中，我们使用了<code class="fe og oh oi oj b">create</code>函数来插入一个新的数据库记录。我们通过在<code class="fe og oh oi oj b">data</code>字段中提供创建新公司所需的字段来实现这一点(只有<code class="fe og oh oi oj b">name</code>属性是必需的<em class="mm">)。</em></p><p id="150f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，Prisma的一个很酷的特性是它还可以生成健壮的类型脚本类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">公司实体的自动生成类型之一</p></figure><p id="553b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的结果是一个直观的开发人员UX，使它直截了当地理解我们的自定义Prisma客户端的API。</p><p id="922d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看涉及关系的更复杂的用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建产品并将其链接到公司(Prisma)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个客户并将其链接到多个产品(Prisma)</p></figure><p id="4031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面，我们做了几件事，包括:</p><ul class=""><li id="8992" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在我们的数据库中创建了新产品和客户</li><li id="4156" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过公司的<code class="fe og oh oi oj b">name</code>领域将新产品与现有公司联系起来(多对一/一对多关系)</li><li id="cd80" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过他们的<code class="fe og oh oi oj b">name</code>字段将一个新客户链接到几个现有产品(多对多关系)</li></ul><p id="69be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma提供的另一个很酷的特性是为有关系的实体执行<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/relation-queries#nested-writes" rel="noopener ugc nofollow" target="_blank">嵌套写</a>的能力。这意味着能够一次创建多个相关实体，同时作为一个事务进行操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套写入的示例(Prisma)</p></figure><h2 id="f8e0" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">现在让我们做同样的一系列创建操作，但是使用TypeORM。同样，我们将创建一个具有相同属性的公司:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建公司(类型)</p></figure><p id="803f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用存储库模式，我们检索特定于我们的数据库模型之一的存储库，并使用它通过<code class="fe og oh oi oj b">create</code>方法创建该模型的实例。然后我们通过调用<code class="fe og oh oi oj b">save</code>将它持久化到数据库中。</p><p id="bcb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看一些使用产品和客户实体的更复杂的创建示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建产品并将其链接到公司(TypeORM)</p></figure><p id="e450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创造新产品的情况下，我们需要<code class="fe og oh oi oj b">ProductRepository</code>和<code class="fe og oh oi oj b">CompanyRepository</code>。</p><p id="bd2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">CompanyRepository</code>用于在数据库中查找与产品相关的公司。然后使用<code class="fe og oh oi oj b">ProductRepository</code>创建一个新产品，包括它与公司实体的外键关系。</p><p id="0b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次使用<code class="fe og oh oi oj b">save</code>操作将产品持久化到数据库中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个客户并将其链接到几个产品(TypeORM)</p></figure><p id="54c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的例子类似，我们使用多个存储库来创建一个新客户。在上面的例子中，我们找到一个客户消费的所有产品，创建一个新客户(包括外键)，最后保存这个新客户。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="d29f" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">阅读</h1><h2 id="dcc4" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="c4ba" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">从一个简单的例子开始，按名称查找单个公司如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按名称查找公司(Prisma)</p></figure><p id="487e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到我们已经看到的语法，这应该是有意义的，并使用一个过滤条件通过特定字段来查找公司。</p><p id="30bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来看一个更复杂的例子。例如，如果我们想找到所有消费特定公司产品的客户，该怎么办？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找公司客户的用户名(Prisma)</p></figure><p id="d3d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面，我们利用<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/field-selection" rel="noopener ugc nofollow" target="_blank">字段选择</a>和<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/sorting" rel="noopener ugc nofollow" target="_blank">排序</a>。具体来说，我们只按降序返回相关客户的<code class="fe og oh oi oj b">username</code>字段。</p><p id="1cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe og oh oi oj b">some</code>操作符的使用表明我们正在寻找一个或多个记录与所提供的标准相匹配的产品(至少有一个产品需要与名为“Acme”的公司相关)。</p><p id="c53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个查询也可以从关系的另一端实现(从<code class="fe og oh oi oj b">Company</code>开始查询，并使用关系的另一端)。</p><p id="bac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个例子，Prisma也支持使用<a class="ae ky" href="https://gist.github.com/nmchenry01/7000b1048191123aab11d2d39afd8df1" rel="noopener ugc nofollow" target="_blank">多重过滤条件</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">寻找制造汽车或炸药的公司(Prisma)</p></figure><h2 id="279a" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="c2ea" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我们将从按名称查找公司开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按名称查找公司(类型)</p></figure><p id="7306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们使用了<code class="fe og oh oi oj b">CompanyRepository</code>和它的<code class="fe og oh oi oj b">findOne</code>方法来基于一个条件(在这个例子中是<code class="fe og oh oi oj b">name</code>属性)检索一个公司。</p><p id="d208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看下一个案例，让我们找到一个特定公司的所有客户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找公司客户的用户名(TypeORM)</p></figure><p id="e1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是TypeORM变得更有趣的地方。</p><p id="8574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试图在上面的查询中执行不仅仅是基本的查找操作。鉴于此，利用TypeORM的查询构建器是有意义的(因为使用存储库API执行相同的操作很麻烦)。</p><p id="62f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，查询构建器是一个TypeORM特性，允许您使用直观的API构建和执行SQL查询。</p><p id="e083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe og oh oi oj b">CustomerRepository</code>，我们首先为客户表创建一个查询构建器实例。然后，我们执行连接操作，选择与我们的客户消费的产品相关的所有公司，然后过滤出符合特定条件的公司(company <code class="fe og oh oi oj b">name</code>属性)。最后，我们只选择用户名，并按降序排列输出。</p><p id="4f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为查询构建器的另一个应用，下面是一个示例，说明如何找到生产一组特定产品的所有公司:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">寻找制造汽车或炸药的公司</p></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="eb15" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">更新</h1><h2 id="08da" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="ff04" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">用Prisma更新数据库记录使用的语法类似于create和read示例。更新产品描述如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新产品描述(Prisma)</p></figure><p id="0429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们在<code class="fe og oh oi oj b">where</code>字段(<code class="fe og oh oi oj b">name</code>属性)中提供一个搜索条件，然后在<code class="fe og oh oi oj b">data</code>属性(<code class="fe og oh oi oj b">description</code>属性)中包含要更新的字段。</p><h2 id="b76c" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="f73b" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">使用与上面相同的示例，更新TypeORM中的产品描述如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新产品描述(类型)</p></figure><p id="1809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是一个相对简单的查询，我们在<code class="fe og oh oi oj b">ProductRepository</code>上使用了<code class="fe og oh oi oj b">update</code>函数。这个函数有两个对象，第一个是搜索条件，第二个是要更新的字段/值。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="56ec" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">删除</h1><h2 id="f7cd" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="9d41" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我们将在Prisma中看到的下一个常见开发人员场景是删除数据库条目。例如，按特定筛选条件删除客户如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按用户名删除客户(Prisma)</p></figure><p id="bf54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">delete</code>操作支持与上一节所示的<code class="fe og oh oi oj b">findOne</code>和<code class="fe og oh oi oj b">findMany</code>操作相同的过滤能力。</p><p id="97e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe og oh oi oj b">delete</code>操作只删除一个数据库条目。对于批量删除，使用<code class="fe og oh oi oj b">deleteMany</code>。</p><h2 id="2c64" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="ddc5" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">按用户名删除客户如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按用户名删除客户(类型)</p></figure><p id="67cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">CustomerRepository</code>上的<code class="fe og oh oi oj b">delete</code>操作接受一个带有搜索条件的对象作为参数，可用于删除一个或多个数据库条目。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="d577" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">处理</h1><h2 id="c6aa" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="d5b4" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我们已经展示了一种使用Prisma执行事务的方法。具体来说，无论何时创建相关实体作为<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/relation-queries#nested-writes" rel="noopener ugc nofollow" target="_blank">嵌套写</a>的一部分，都有一个事务保证(意味着操作作为一个单元成功或失败)。</p><p id="723a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，还有一种执行事务的方法。它使用实验性的<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/transactions#bulk-operations-experimental" rel="noopener ugc nofollow" target="_blank">事务API </a>，如图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交易API (Prisma)</p></figure><p id="9cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们创建了一个公司和客户作为同一个事务的一部分。当不相关的实体需要事务保证时，这是很有用的，尽管在撰写本文时这个特性还没有准备好投入生产。</p><h2 id="99f6" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="4d8a" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">TypeORM还提供了一个用于执行事务的API，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事务API(类型)</p></figure><p id="3cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM中的事务依赖于实体管理器上的<code class="fe og oh oi oj b">transaction</code>方法。反过来，该方法将一个函数作为参数，该参数提供一个新的实体管理器，该管理器必须用于事务中的所有操作。</p><p id="3645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的示例中，我们使用特定于事务的实体管理器创建了一个公司和用户。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7bc2" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">原始SQL</h1><h2 id="8a65" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="48e2" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">Prisma提供了使用原始SQL执行查询的能力，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始SQL (Prisma)</p></figure><p id="8e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个缺点是，您失去了Prisma客户端自动生成的类型的类型安全性。尽管如此，编写SQL查询有时是必要的，您可以编写自定义类型定义来恢复类型安全。</p><h2 id="8c64" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="6cc6" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">同样，TypeORM可以执行原始SQL查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始SQL(类型)</p></figure><p id="2c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很大程度上，查询构建器特性可以用来避免编写原始SQL(尽管有这个选项还是很方便的)。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b36f" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">估价</h1><h2 id="dd33" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">普里斯马</h2><p id="fc70" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">与Prisma合作后，我的印象是它有很大的潜力。从开发人员的角度来看，使用它非常简单，尤其是与其他流行的数据库工具如<a class="ae ky" href="https://www.npmjs.com/package/sequelize" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>相比。</p><p id="3eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Prisma <a class="ae ky" href="https://www.prisma.io/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>使得快速建立并运行一个例子变得不那么痛苦。我在使用它时遇到的唯一问题是使用隐式的多对多特性。具体来说，需要多次尝试才能使表命名约定正确，并使用Prisma CLI的<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/introspection" rel="noopener ugc nofollow" target="_blank">自省</a>功能(这会将现有的数据库模式转换为Prisma模式文件)。</p><p id="5979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然此功能的限制和要求已被<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#conventions-for-relation-tables-in-implicit-m-n-relations" rel="noopener ugc nofollow" target="_blank">很好地记录下来</a>，但这可能很难在生产环境中使用，需要一种变通方法。</p><p id="4247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然Prisma还有很长的路要走，但它已经取得了巨大的进步，并有可能成为Node.js和TypeScript的首选数据库工具。</p><p id="3e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="eae4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">易于使用和直观的语法</li><li id="51bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在利用GraphQL的堆栈中表现出色</li><li id="ab04" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">惊人的类型脚本支持</li><li id="2aa8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Prisma模式语言(PSL)既简单又强大</li><li id="81b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">由专门的开发人员团队和风险投资资金支持</li></ul><p id="5de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="2848" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">还有一段路要走，许多功能仍在开发中</li><li id="6203" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">迁移功能(<a class="ae ky" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-migrate" rel="noopener ugc nofollow" target="_blank"> Prisma Migrate </a>)仍处于试验阶段</li><li id="86e7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">没有长时间运行的事务</li><li id="50a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">无法访问底层数据库连接</li><li id="2b11" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">隐含的多对多关系特性有点脆弱</li></ul><h2 id="58ad" class="np my it bd mz nq nr dn nd ns nt dp nh li nu nv nj lm nw nx nl lq ny nz nn oa bi translated">字体</h2><p id="e9d5" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">在很多项目中使用过TypeORM之后，我一直发现它是一个强大的数据库工具，涵盖了日常用例。值得注意的是，对于用其他ORM很难实现的更困难的查询，查询构建器总是很方便。</p><p id="3222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，TypeORM非常有效地使用了TypeScript装饰器。这样做的结果是实体类更具表现力，更易于阅读。</p><p id="c8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM也继续在开发者中流行，在撰写本文时，该软件包在NPM上每周下载量超过了<a class="ae ky" href="https://www.npmjs.com/package/typeorm" rel="noopener ugc nofollow" target="_blank">35万次。然而，TypeORM的主要缺点是它在Github上有许多未解决的问题和同样多的已知bug。</a></p><p id="3eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于该项目没有像Prisma这样的全职开发人员，支持和修复已知问题的速度相对较慢。随着时间的推移，这可能会导致TypeORM的受欢迎程度下降，并限制企业的采用。</p><p id="70f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="6582" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">适用于TypeScript和JavaScript</li><li id="d5b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">大量的特性，并支持多种关系数据库</li><li id="0765" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">查询生成器功能增加了灵活性和功能</li><li id="920c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">有效地使用装饰者</li><li id="4e85" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">迁移功能运行良好/比Prisma更成熟</li></ul><p id="024c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="60a8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">大量的bug和未解决的问题<a class="ae ky" href="https://github.com/typeorm/typeorm/issues" rel="noopener ugc nofollow" target="_blank"/></li><li id="2714" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank">文档</a>不适合高级用例</li><li id="d296" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">来自<a class="ae ky" href="https://github.com/typeorm/typeorm" rel="noopener ugc nofollow" target="_blank"> Github </a>维护者的部分支持</li><li id="b5f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不够成熟/支持不够好，不适合企业采用</li><li id="7198" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">没有大量资金支持</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="68c0" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">结束语</h1><p id="dea2" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">TypeORM和Prisma都提供了优秀的开发者UX和特性集。从短期来看，我预计TypeORM会比Prisma更受欢迎。这是因为TypeORM已经在受欢迎程度上<a class="ae ky" href="https://www.npmtrends.com/@prisma/cli-vs-typeorm" rel="noopener ugc nofollow" target="_blank">明显领先于Prisma，并且在成熟度方面也有优势(例如，迁移)。</a></p><p id="42a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从长远来看，Prisma很有可能超越TypeORM，因为它有强大的资金支持和全职核心开发人员团队致力于开发新功能。此外，TypeORM可能会受到Github公开问题/错误和缺乏全职维护人员支持的拖累。</p><p id="3bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管结果如何，这两种工具都提供了巨大的希望，看到它们如何随着时间的推移而发展将是令人兴奋的。</p><p id="d1b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我希望听到任何关于Prisma/TypeORM的想法，它们在Node.js生态系统中的位置，以及真实世界的用例！下次见，感谢阅读。</p><h1 id="1337" class="mx my it bd mz na om nc nd ne on ng nh jz oo ka nj kc op kd nl kf oq kg nn no bi translated">参考</h1><ul class=""><li id="95d8" class="lv lw it lb b lc ob lf oc li or lm os lq ot lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/nmchenry01/prisma-typeorm-blog" rel="noopener ugc nofollow" target="_blank">文章源代码</a></li><li id="fb9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.prisma.io/docs/" rel="noopener ugc nofollow" target="_blank"> Prisma文档</a></li><li id="b510" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank">字体文件</a></li></ul></div></div>    
</body>
</html>