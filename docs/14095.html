<html>
<head>
<title>Spring Boot, Kafka, Non-Blocking Retries — A Hands-on Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot，卡夫卡，非阻断重试——实践教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spring-boot-kafka-non-blocking-retries-a-hands-on-tutorial-a0c425acc3dd?source=collection_archive---------2-----------------------#2022-11-05">https://betterprogramming.pub/spring-boot-kafka-non-blocking-retries-a-hands-on-tutorial-a0c425acc3dd?source=collection_archive---------2-----------------------#2022-11-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7b7f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Spring Boot应用程序中使用RetryableTopic的Kafka中的非阻塞失败消息处理</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a2b27b1069f171bb9da5bb4c52caeb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S5O1g5kTNMnI7Zen"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3f4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有时，当我们处理来自卡夫卡主题的消息时，会发生错误。例如，消费者服务或其他基础设施可能会关闭。我们希望确保不会丢失任何数据，并尝试处理失败的消息。</p><p id="92bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认的Kafka失败处理行为会无限重试处理消息。这不是有益的，因为一些致命的错误无法修复，我们不应该重新处理它们。</p><p id="52c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用<code class="fe lw lx ly lz b"><a class="ae kz" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/annotation/RetryableTopic.html" rel="noopener ugc nofollow" target="_blank">RetryableTopic</a></code>注释来配置更健壮的策略来处理失败的消息，而不是依赖默认的实现。例如，我们可以将失败的消息发送到<a class="ae kz" href="https://en.wikipedia.org/wiki/Dead_letter_queue" rel="noopener ugc nofollow" target="_blank">死信队列</a>，限制重试次数，定义超时，排除致命异常再处理等。</p><p id="3f98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本教程中，我将向您展示如何通过几个简单的步骤在Spring Boot应用程序中实现<code class="fe lw lx ly lz b">RetryableTopic</code>。</p><p id="10ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们开始吧！</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c780" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">可重试主题介绍和优势</h1><p id="3eb8" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">首先，让我们理解阻塞和非阻塞消息重试的区别。假设您在Kafka配置中配置了一个<code class="fe lw lx ly lz b">@Bean</code>，尝试重新处理N次失败的消息。例如，考虑以下代码摘录:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">修正了Kafka监听器工厂Bean的回退策略</p></figure><p id="0e3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">消费者试图实时连续地重新处理失败的消息。主话题会被屏蔽。这里我们有一个<code class="fe lw lx ly lz b"><a class="ae kz" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/backoff/FixedBackOff.html" rel="noopener ugc nofollow" target="_blank">FixedBackOff</a></code>策略，尝试3次，恢复间隔为5秒。</p><p id="eb04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果所有重试尝试都失败，消息将被发送到死信队列(DLT)。在此之前，所有其他传入的消息都将被阻止，直到前面的消息得到处理。</p><p id="52be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这可能很危险，尤其是在重试间隔太长的情况下。</p><p id="4942" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是我们如何通过使用<code class="fe lw lx ly lz b">RetryableTopic</code>来改善这种情况:</p><ul class=""><li id="668b" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">主话题不屏蔽，其他消息可以处理。</li><li id="6ce5" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">失败的消息被发送到带有回退时间戳的重试主题。</li><li id="5cff" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">如果失败的消息无法处理，它将被发送到下一个重试主题。</li><li id="7870" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">如果所有重试主题的处理都失败，消息将被转发到DLT。</li><li id="4b0e" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">来自DLT的消息可以通过被发送回第一个重试主题来重试。</li></ul></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="5e34" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">准备项目</h1><p id="0e42" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们将使用HTTP <code class="fe lw lx ly lz b">Get</code>请求生成消息，并使用Kafka消费消息。Kafka监听器将使用<code class="fe lw lx ly lz b">RetryableTopic</code>注释。</p><p id="452e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经为这个演示通过<a class="ae kz" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a>创建了一个框架Spring Boot项目。</p><h2 id="4c70" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">添加依赖项</h2><p id="fe01" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我使用Maven作为构建工具。我们需要<code class="fe lw lx ly lz b">pom.xml</code>中的以下依赖项:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">项目相关性</p></figure><ul class=""><li id="2f59" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated"><code class="fe lw lx ly lz b">spring-boot-starter-web</code>依赖关系支持web应用程序的创建。</li><li id="5f82" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated"><code class="fe lw lx ly lz b">spring-kafka</code>依赖项用于Kafka操作。</li><li id="423c" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated"><code class="fe lw lx ly lz b">lombok</code>依赖消除了样板代码的使用。</li></ul><h2 id="dcf5" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">准备基础设施</h2><p id="566c" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">要在本地运行Kafka，让我们创建一个<code class="fe lw lx ly lz b">docker-compose.yml</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">码头工人为卡夫卡作曲</p></figure><ul class=""><li id="56be" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">我们有两个服务— <code class="fe lw lx ly lz b">zookeeper</code>，是<code class="fe lw lx ly lz b">kafka</code>所需要的。</li></ul><h2 id="80ba" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">配置Kafka属性</h2><p id="1c75" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">让我们配置一下<code class="fe lw lx ly lz b">application.yml</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">应用程序的属性</p></figure><ul class=""><li id="64cc" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">我们要听的题目的名字叫做<code class="fe lw lx ly lz b">my-topic</code>。</li><li id="f241" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">卡夫卡消费群体的名字叫<code class="fe lw lx ly lz b">my-group</code>。</li><li id="2ec2" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">我们已经为序列化和反序列化配置了<code class="fe lw lx ly lz b">KafkaProducer</code>和<code class="fe lw lx ly lz b">KafkaConsumer</code>属性。</li><li id="8d04" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">我们使用在<code class="fe lw lx ly lz b">docker-compose.yml </code>文件中定义的Kafka引导服务器的<code class="fe lw lx ly lz b">29092</code>端口。</li></ul><h2 id="4cba" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">添加一个卡夫卡监听器</h2><p id="0f1c" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">让我们创建一个卡夫卡式的听众:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><ul class=""><li id="76ef" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">我们使用<code class="fe lw lx ly lz b">@ Component</code>注释在Spring Boot应用程序中注册Bean。</li><li id="9d87" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">我们有一个方法<code class="fe lw lx ly lz b">handleMessage()</code>，在这里我们定义我们的Kafka监听器并使用<code class="fe lw lx ly lz b">@RetryableTopic</code>。</li><li id="4cf5" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">当所有重试尝试都用尽时，消息被转发到<code class="fe lw lx ly lz b">handleDlt()</code>方法，由<code class="fe lw lx ly lz b">@DltHandler</code>注释指示。DLT主题的默认名称是<code class="fe lw lx ly lz b">my-topic-dlt</code>。</li><li id="296e" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">注意<code class="fe lw lx ly lz b">throw new RuntimeException("Test exception")</code>零件是测试所必需的。</li></ul><p id="1f06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是一些基本属性:</p><ul class=""><li id="4c96" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">属性定义了我们想要重试的次数。在这种情况下，我们将对原始主题进行4次重试加1次。</li><li id="004c" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">该应用程序将自动创建以索引值命名的后缀主题。例如，<code class="fe lw lx ly lz b">my-topic-retry-1</code>。命名策略由<code class="fe lw lx ly lz b">topicSuffixingStrategy</code>属性定义。</li><li id="5908" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated"><code class="fe lw lx ly lz b">backoff</code>属性指示应用程序在1秒钟内重试失败的消息。我们有一个乘数<code class="fe lw lx ly lz b">2.0</code>。这意味着第二次尝试将在2秒后发生，第三次将在4秒后发生，依此类推。</li><li id="8f2d" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">属性让我们配置不想重试的异常。例如，忽略致命异常是一个很好的做法，比如<code class="fe lw lx ly lz b">DeserializationException</code>。有关不可恢复故障的完整列表，请查看<a class="ae kz" href="https://docs.spring.io/spring-kafka/reference/html/#backoff-handlers" rel="noopener ugc nofollow" target="_blank">文档</a>。</li></ul><p id="8738" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">RetryableTopic</code>提供了其他强大的选项。如果您想查看它们，请访问<a class="ae kz" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/annotation/RetryableTopic.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="55e5" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">添加静止控制器</h2><p id="dc91" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">为了简单起见，让我们添加一个<code class="fe lw lx ly lz b">RestController</code>来生成主题消息:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">RestController为Kafka主题生成消息</p></figure><ul class=""><li id="d302" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated"><code class="fe lw lx ly lz b">produceMessage()</code>方法将向我们的Kafka主题发送消息。</li><li id="8cc2" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">默认情况下，<code class="fe lw lx ly lz b">kafkaTemplate</code>是自动连线的。当然，如果我们需要自定义实现，我们可以配置自己的Bean。</li></ul><h2 id="f482" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">创建主应用程序</h2><p id="4b52" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">主应用程序如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">主要应用程序</p></figure><h2 id="7e2c" class="nu mi iu bd mj nv nw dn mn nx ny dp mr lj nz oa mt ln ob oc mv lr od oe mx of bi translated">测试应用程序</h2><p id="74c9" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">现在，是测试的时候了！</p><ol class=""><li id="bd01" class="ng nh iu lc b ld le lg lh lj ni ln nj lr nk lv og nm nn no bi translated">通过运行以下命令启动本地基础架构:</li></ol><pre class="kk kl km kn gu oh lz oi oj aw ok bi"><span id="3d21" class="nu mi iu lz b gz ol om l on oo">docker-compose up</span></pre><p id="137a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2.运行主类- <code class="fe lw lx ly lz b">KafkaErrorHandlingApplication.java</code>。</p><p id="b0d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">3.通过控制器发送测试信息。例如:</p><pre class="kk kl km kn gu oh lz oi oj aw ok bi"><span id="cbb9" class="nu mi iu lz b gz ol om l on oo">GET <a class="ae kz" href="http://localhost:8090/produce/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/produce/hello</a></span></pre><p id="e15e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该在应用程序的控制台中看到监听器收到了消息。由于我们抛出了一个<code class="fe lw lx ly lz b">RuntimeException</code>，消息将被转发到重试主题，并最终转发到DLT。</p><p id="7ca7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">日志如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/60ef5d5718ab00badd3312e4d5b3f6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQfHeqUZyOQqnaw4LVEZEQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">spring boot应用程序的控制台日志</p></figure><p id="ecbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完美！检查屏幕截图上的时间戳，查看重试尝试是否按照<code class="fe lw lx ly lz b">BackOff</code>策略的配置进行。</p><p id="7972" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，DLT按预期工作:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oq"><img src="../Images/bb52eae1c15c2d224a3c94bf4db668f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5wg8pv2woeI01OrSog0Aw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由DLT处理的消息</p></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="45b9" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="f828" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在本教程中，您学习了如何使用<code class="fe lw lx ly lz b">RetryableTopic</code>注释来实现非阻塞的失败消息处理。我们看到了一些配置属性示例。</p><p id="e9cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个注释为我们提供了一个健壮的错误处理解决方案。但是，请记住，根据官方文档，目前它有一些限制:</p><blockquote class="or os ot"><p id="6b4d" class="la lb ou lc b ld le jv lf lg lh jy li ov lk ll lm ow lo lp lq ox ls lt lu lv in bi translated">通过使用这个策略，你就失去了卡夫卡对那个主题的排序保证。</p><p id="b6c2" class="la lb ou lc b ld le jv lf lg lh jy li ov lk ll lm ow lo lp lq ox ls lt lu lv in bi translated">目前，该功能不支持类级<code class="fe lw lx ly lz b">@KafkaListener</code>注释。</p></blockquote><p id="55b9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在下面的<strong class="lc iv">参考资料</strong>部分找到这个演示的完整源代码的链接。</p><p id="df5c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你能从这篇文章中学到一些新的东西。如果你喜欢这个教程，你可能也会喜欢我的其他卡夫卡相关的文章:</p><div class="oy oz gq gs pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/kafka-streams-how-to-process-a-csv-file-to-perform-calculations-173758da117d"><div class="pc ab fp"><div class="pd ab pe cl cj pf"><h2 class="bd iv gz z fq pg fs ft ph fv fx it bi translated">Kafka Streams:如何处理CSV文件以执行计算</h2><div class="pi l"><h3 class="bd b gz z fq pg fs ft ph fv fx dk translated">处理一个大的CSV文件，并根据历史天气记录计算日平均温度</h3></div><div class="pj l"><p class="bd b dl z fq pg fs ft ph fv fx dk translated">better编程. pub</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kt pb"/></div></div></a></div><div class="oy oz gq gs pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-process-notifications-with-kafka-minio-and-python-8a288b12854"><div class="pc ab fp"><div class="pd ab pe cl cj pf"><h2 class="bd iv gz z fq pg fs ft ph fv fx it bi translated">如何用Kafka、MinIO和Python处理通知</h2><div class="pi l"><h3 class="bd b gz z fq pg fs ft ph fv fx dk translated">通过Kafka发送存储桶通知，并使用Python处理记录</h3></div><div class="pj l"><p class="bd b dl z fq pg fs ft ph fv fx dk translated">better编程. pub</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp kt pb"/></div></div></a></div><p id="2f82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读，祝您编码愉快！</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="896a" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">参考</h1><ul class=""><li id="11e5" class="ng nh iu lc b ld mz lg na lj pr ln ps lr pt lv nl nm nn no bi translated"><a class="ae kz" href="https://github.com/kirshiyin89/kafka-retryabletopic-demo" rel="noopener ugc nofollow" target="_blank">我的GitHub资源库</a></li><li id="1594" class="ng nh iu lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated"><a class="ae kz" href="https://docs.spring.io/spring-kafka/reference/html/#retry-topic" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-Kafka/reference/html/# retry-topic</a></li></ul></div></div>    
</body>
</html>