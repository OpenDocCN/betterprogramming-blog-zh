<html>
<head>
<title>Learn Object-Oriented Programming Through R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过R学习面向对象编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-object-oriented-programming-through-r-d35a877c22a4?source=collection_archive---------15-----------------------#2022-04-05">https://betterprogramming.pub/learn-object-oriented-programming-through-r-d35a877c22a4?source=collection_archive---------15-----------------------#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a80f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">面向对象系统简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a5501b13a2361ccd27c9bb65b23f8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hU2VtXgoJ17zWJvg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卢克·埃利斯-克雷文在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b8f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于许多原因，r是一种很棒的编程语言。但是绝大多数R用户并不知道R给他们带来的所有好处。</p><p id="39f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">面向对象编程是R用户经常忽略的好处中的第一个。部分原因是R生态系统非常适合快速进入编程，这种适合性导致R社区低估了面向对象软件设计。</p><p id="1e8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">面向对象编程和过程编程是软件世界中两种广泛使用的编程范例之一。我们不会试图从零开始教授面向对象编程，我们将假设读者对面向对象编程的基本概念有一些熟悉，如类、封装、继承和多态。</p><p id="bca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与Python、Java和C++等其他面向对象的语言相比，R有着截然不同的语法，但基本概念保持不变。在R中应用面向对象有两个主要的类系统，即S3和S4。我们将详细研究它们。我们开始吧！</p><h1 id="03e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">S3班级</h1><p id="a57d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这里我们创建一个简单的线性模型，并根据下面的例子讨论S3类的结构:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="67f5" class="mu lt iq mq b gy mv mw l mx my">v1 &lt;- rnorm(n = 5 , mean = 100 , sd = 10)<br/>v2 &lt;- v1 + rnorm(n = 5 , mean = 0 , sd = 10)<br/>reg &lt;- lm(v2 ~ v1)<br/>class(reg)</span><span id="e9d5" class="mu lt iq mq b gy mz mw l mx my">## [1] "lm"</span></pre><p id="0f64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，当我们取消一个对象的分类时，它本质上是一个列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7b1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了了解为什么<code class="fe nc nd ne mq b">print()</code>函数在分类和未分类的线性模型上工作不同，我们稍微深入地检查一下<code class="fe nc nd ne mq b">print()</code>函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2732" class="mu lt iq mq b gy mv mw l mx my">print</span><span id="eeef" class="mu lt iq mq b gy mz mw l mx my">## function (x, ...) <br/>## UseMethod("print")<br/>## &lt;bytecode: 0x0000000013082240&gt;<br/>## &lt;environment: namespace:base&gt;</span></pre><p id="3e11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了查看所有与<code class="fe nc nd ne mq b">print()</code>函数相关的类方法，我们运行下面的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="552f" class="mu lt iq mq b gy mv mw l mx my">methods(print)</span><span id="42ad" class="mu lt iq mq b gy mz mw l mx my">##   [1] print.acf*                                          <br/>##   [2] print.AES*                                          <br/>##   [3] print.anova*                                        <br/>...                                  <br/>## [133] print.lm*                                           <br/>...                             <br/>## [228] print.xgettext*                                     <br/>## [229] print.xngettext*                                    <br/>## [230] print.xtabs*                                        <br/>## see '?methods' for accessing help and source code</span></pre><p id="00e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">截至我现在使用的R 4.0.2版本，有230个类方法带有<code class="fe nc nd ne mq b">print()</code>函数。第133名是<code class="fe nc nd ne mq b">print.lm*</code>。但是星号(<code class="fe nc nd ne mq b"> \*</code>)符号意味着<code class="fe nc nd ne mq b">print.lm()</code>的内容并不能像我们上面做的那样，只需输入不带括号的内容就能直接看到。为此我们使用了<code class="fe nc nd ne mq b">getAnywhere()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e39d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看所有通用函数，只需执行以下操作:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e7ec" class="mu lt iq mq b gy mv mw l mx my">methods(  class = 'default')</span><span id="5525" class="mu lt iq mq b gy mz mw l mx my">##   [1] add1            aggregate       AIC             all.equal      <br/>....        <br/>## [157] wilcox.test     window          with            xtfrm          <br/>## see '?methods' for accessing help and source code</span></pre><p id="6d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经看到了S3类如何使用方法和属性。现在是时候构建我们自己的S3类了。第一步很简单，创建一个包含属性元素的列表。然后，我们运行<code class="fe nc nd ne mq b">class()</code>函数，其中包含一个对象列表，并手动命名该类。到那时，我们将完成整个过程。这可能看起来很奇怪，因为我们首先创建对象，然后创建类，因为在其他著名的面向对象语言中，情况正好相反。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="349e" class="mu lt iq mq b gy mv mw l mx my">student1 &lt;- list(name="Ugurcan", semester = 3 , statStudent = T)<br/>student2 &lt;- list(name="Mark", semester = 7 , statStudent = F)</span><span id="b8c9" class="mu lt iq mq b gy mz mw l mx my">class(student1) &lt;- 'student'<br/>class(student2) &lt;- 'student'</span></pre><p id="6791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们首先以列表的形式创建了两个实例，然后通过直接命名来创建它们的类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们打印它们时会发生什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3a09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们提到的，print是一个通用函数，没有对应的类方法。这就是为什么当我们在这两个实例上调用print时，它们会像列表一样被打印出来。让我们为通用函数<code class="fe nc nd ne mq b">print()</code>创建我们的类方法。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8259" class="mu lt iq mq b gy mv mw l mx my">print.student &lt;- function(student) {<br/>  cat(student$name , "\n")<br/>  cat("semester" , student$semester , "\n")<br/>  cat("Is he\\she a Statistics student ?" , student$statStudent , "\n")<br/>}</span></pre><p id="05c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面让我们来看看它是否有效:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="46f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。我们有两个具有适当属性的实例，一个类和一个类方法。</p><p id="ffd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继承是一个重要的话题，它的实现与其他语言有很大的不同。为了创建一个继承类，我们首先再次创建实例，但是不是传递一个字符串作为类名，而是传递一个字符串向量，其中向量的每个元素都分层给出类名。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="438e" class="mu lt iq mq b gy mv mw l mx my">student3 &lt;- list(name="Lauren", semester = 6 , statStudent = F , dorm = T)<br/>class(student3) &lt;- c("dormStudents" , "student")<br/>print(student3)</span><span id="1739" class="mu lt iq mq b gy mz mw l mx my">## Lauren <br/>## semester 6 <br/>## Is he\she a Statistics student ? FALSE</span></pre><p id="b0f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经为已经存在的通用函数创建了类方法。当您处理大型项目时，您可能还需要创建通用函数。这是我们S3的方式。</p><p id="a8b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe nc nd ne mq b">UseMethod()</code>创建调用自身的函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e1f2" class="mu lt iq mq b gy mv mw l mx my">advance &lt;- function(x , ...) {<br/>  UseMethod(generic = "advance" )<br/>}</span></pre><p id="8359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。我们有一个通用函数。现在我们为这个通用函数编写一个类方法。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="907a" class="mu lt iq mq b gy mv mw l mx my">advance.student &lt;- function(x) {<br/>  x$semester = (x$semester +1)<br/>  return(x)<br/>}</span></pre><p id="7aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们把<code class="fe nc nd ne mq b">student1</code>提前了一个学期。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="02e1" class="mu lt iq mq b gy mv mw l mx my">student1 &lt;- advance(student1)<br/>student1</span><span id="2e20" class="mu lt iq mq b gy mz mw l mx my">## Ugurcan <br/>## semester 4 <br/>## Is he\she a Statistics student ? TRUE</span></pre><h1 id="0ab4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">S4班级</h1><p id="f17c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">S4类是r中另一种类型的面向对象系统。S3和S4之间的差异应该从语言的历史发展角度来解释。</p><p id="3bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">r受到另一种语言S的启发，后者是在20世纪70年代由贝尔实验室开发的。S3的类系统来自于S语言。但随着时间的推移，随着新的面向对象语言的崛起，S3类开始显得过时，因为它们缺乏一定程度的健壮性和安全性，而其他语言在当时也是如此。</p><p id="e3d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为对此的回应，S4班级诞生于防止拼写错误和误认的需要，而S3班级很容易出现这种情况。</p><p id="33c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用函数<code class="fe nc nd ne mq b">setClass()</code>定义了一个S4类。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8847" class="mu lt iq mq b gy mv mw l mx my">setClass(Class = "student" , representation = list(<br/>                                              name = "character",<br/>                                              semester = "numeric" ,<br/>                                              statStudent = "logical"<br/>)<br/>         )</span></pre><p id="b021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与S3不同，这里我们首先创建了类，然后创建了实例。每个实例都是用<code class="fe nc nd ne mq b">new()</code>函数创建的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，S4类的属性称为插槽。访问它们的一种方法是使用<code class="fe nc nd ne mq b">@</code>符号，而不是像我们在S3课上做的那样使用<code class="fe nc nd ne mq b">$</code>。访问S4属性的第二种方法是使用<code class="fe nc nd ne mq b">slot()</code>函数。在下面的示例中，您可以看到这两种方式:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a86e" class="mu lt iq mq b gy mv mw l mx my">student1@semester</span><span id="1d51" class="mu lt iq mq b gy mz mw l mx my">## [1] 3</span><span id="6d23" class="mu lt iq mq b gy mz mw l mx my">slot(object = student1 , name = "name")</span><span id="2b24" class="mu lt iq mq b gy mz mw l mx my">## [1] "Uğurcan"</span></pre><p id="2be7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们犯了任何拼写错误或其他编程错误，S4类会阻止我们这样做。另一方面，S3类只是美化了的列表。</p><p id="1beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在S4类上实现一个类方法，我们使用了<code class="fe nc nd ne mq b">setMethod()</code>函数。我们将为通用函数<code class="fe nc nd ne mq b">show()</code>创建一个类方法，它是S3的<code class="fe nc nd ne mq b">print()</code>的S4等价物。正如我们可能猜测的那样，当我们在控制台上键入一个对象的名称时<code class="fe nc nd ne mq b">show()</code>就会起作用。事实上，我们只要使用<code class="fe nc nd ne mq b">show()</code>就会得到相同的输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们如何使用<code class="fe nc nd ne mq b">setmethod()</code>来创建S4类方法:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="eccb" class="mu lt iq mq b gy mv mw l mx my">setMethod("show" , "student" , function(object) {<br/>  cat(object@name , "\n")<br/>  cat("semester" , object@semester , "\n")<br/>  cat("Is he\\she a Statistics student ?" , object@statStudent , "\n")<br/>})</span></pre><p id="3e00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它是否有效。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1321" class="mu lt iq mq b gy mv mw l mx my">show(student1)</span><span id="a608" class="mu lt iq mq b gy mz mw l mx my">## Uğurcan <br/>## semester 3 <br/>## Is he\she a Statistics student ? TRUE</span></pre><p id="e46e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了继承S4中的另一个类，我们将超类的名称传递给<code class="fe nc nd ne mq b">setClass()</code>函数中的<code class="fe nc nd ne mq b">contains</code>参数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="62d4" class="mu lt iq mq b gy mv mw l mx my">setClass(Class = "dormStudents"  ,<br/>         representation = list(dorm = "logical" ) ,<br/>         contains = "student" )</span></pre><p id="0dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为子类创建一个新实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="75b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在S4系统中创建通用函数类似于S3。我们创建一个通过<code class="fe nc nd ne mq b">standardGeneric()</code>调用自身的函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3098" class="mu lt iq mq b gy mv mw l mx my">advance &lt;- function(object , ...){<br/>  standardGeneric("advance")<br/>}</span></pre><p id="2984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们为这个通用函数创建一个类方法。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0bfb" class="mu lt iq mq b gy mv mw l mx my">advance.student &lt;- setMethod(f = "advance" ,<br/>                             signature = "student" ,<br/>                             definition = function(object) {<br/>                               object@semester &lt;- (object@semester + 1)<br/>                               return(object)<br/>                             })</span></pre><p id="c006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很有效。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6698" class="mu lt iq mq b gy mv mw l mx my">student1 &lt;- advance(student1)<br/>student1</span><span id="88dd" class="mu lt iq mq b gy mz mw l mx my">## Uğurcan <br/>## semester 4 <br/>## Is he\she a Statistics student ? TRUE</span></pre><p id="1c73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用S3语法创建一个S4通用函数。注意我们只把<code class="fe nc nd ne mq b">$</code>改成了<code class="fe nc nd ne mq b">@</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="df1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">r是会上瘾的。如果您只是通过编写简单的脚本开始R编程，这并不奇怪。随着项目的增长，您将需要面向对象设计的武器来对抗混乱和非结构化的代码。或者，谁知道呢，也许你会开始你自己的R库。到那时，我希望这篇文章能对你有所帮助。</p></div></div>    
</body>
</html>