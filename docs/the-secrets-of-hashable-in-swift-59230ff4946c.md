# Swift 中 Hashable 的秘密

> 原文：<https://betterprogramming.pub/the-secrets-of-hashable-in-swift-59230ff4946c>

## 在 Swift 的最近几个版本中，*hasb able*协议发生了怎样的变化，到底发生了什么

![](img/eda822505ebcef17179707ecf0831a37.png)

由 [Unsplash](https://unsplash.com/s/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的[émile Perron](https://unsplash.com/@emilep?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)拍摄。

“磕磕碰碰？我为什么要关心它？我肯定不会用，”一个年轻的、没有经验的开发者说。然而，你肯定至少遇到过一次。你甚至可能每天都在使用它而没有注意到它。

在这篇文章中，我想讨论什么是 hash*、*它在 Swift 中是如何工作的、*、*以及它在最近几年是如何变化的*。*

# 什么是哈希？

哈希是唯一的字符串或数字，当您想要识别或比较事物而不是比较原始形式的数据时，这非常方便。它们是通过哈希函数获得的，哈希函数是一种数学函数，它将任意长度的输入值转换为固定长度的数值或字符串，即哈希或哈希值。

哈希函数由两个不同的属性定义:

*   唯一性:不同的数据有不同的哈希值(在本文后面你会看到这并不总是正确的)。
*   不可逆:没有回头路。你不能从它的散列中得到数据。

输出的长度取决于哈希算法。最流行的算法(SHA-1，SHA-256，MD5 等。)生成长度在 160-512 字节范围内的散列。如果你对数学感兴趣，你可以阅读[这篇教程](https://www.tutorialspoint.com/cryptography/cryptography_hash_functions.htm)。

散列函数的一些实际用途是:

*   签名生成和验证
*   密码验证和保护
*   数据完整性
*   区块链

“好吧，但我不明白为什么我还需要它们。我的应用程序没有涵盖这些话题。”

嗯，也许这是对的，但是试着想象一下，你有一书架的书，但是你懒得去订。每次你需要某本书的时候，你都要迭代所有的书，直到找到正确的那本。如果你有几百或几千本书，那就特别烦人！如果你已经知道每本书的确切位置不是更好吗？这就是散列发挥作用的地方！

![](img/fa493c5f2c640aa6a72e3434704091d7.png)

照片由[阿尔方斯·莫拉莱斯](https://unsplash.com/@alfonsmc10?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/library?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄。

现在让我们尝试一个类似的编程实例，其中有一个对象列表，每个对象都可以进行比较。如果你想在列表中找到一个特定的对象，你必须迭代所有的元素直到你找到它，这是一个线性操作( *O(n)* )。如果列表很大(成百上千个对象)，可能会影响性能。

现在我们试着用一套。它不是按顺序存储对象，而是根据对象的内容计算散列作为索引。所以如果你必须寻找它，你只需要计算一个新的散列，在那里寻找对象。这意味着 *O(1)* 的恒定时间！很大的进步，你不觉得吗？

这正是集合和字典在 Swift 中的工作方式，也是它们表现如此出色的原因。实际上，存在两个不同的值产生相同散列的情况。这叫做碰撞。当插入发生冲突时，它存储在该地址的列表中。对象之间的冲突率越高，哈希集合的性能就越线性，因为您又回到了以前的情况。这就是为什么拥有一个好的散列函数很重要。否则，过多的碰撞会降低应用程序的速度。

# Swift 中散列的历史

我不只是向您展示如何在 Swift 5 中使用哈希，而是简要概述哈希机制在 Swift 最近几个版本中的变化。我认为每个开发人员都应该知道事情在幕后是如何工作的，以便以正确的方式使用它们，而理解语言为什么遵循当前的方向是第一步。

## 开始

在 Swift 的第一个版本中，使用散列的唯一方式是实现`Hashable`协议并提供`hashValue`属性的实现。

例如:

这有两个主要问题:

*   开发人员必须负责根据情况提供正确的哈希值。
*   每次您想要符合`Hashable`协议时，提供正确的哈希值都需要大量的样板文件。此外，每次添加属性时，都需要记住保持更新。这很容易出错。

`Equatable`协议也有同样的问题。由于这个原因，Tony Allevato 提出了通过自动合成复杂类型的等价性和散列性来删除所有这些样板文件的建议。

> 开发人员必须编写大量的样板代码来支持复杂类型的等价性和可散列性。这个提议为编译器提供了一种自动合成对`Equatable`和`Hashable`的一致性的方法，以减少这种样板文件，在一个子集的场景中，生成正确的实现是可能的。

## 神奇的合成器— Swift 4.1

这是一个巨大的进步。开发人员可以删除数百行代码并减少错误，但这还不够，因为它只修复了两个主要问题中的一个。为此，提出了建议 [SE-0206](https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md) :

> 有理由期待一个实现自定义类型的有经验的程序员能够识别哪些部分需要被散列。另一方面，实现一个好的散列函数需要仔细考虑和专业知识。期望 Swift 程序员投入时间和精力为每一种`Hashable`类型做好这件事是不合理的。

这导致了`Hasher`的出现。

## 散列器— Swift 4.2

Swift 4.2 引入了`[Hashe](https://developer.apple.com/documentation/swift/hasher)r`，这是一个基于集合和字典使用的 [SipHas](https://en.wikipedia.org/wiki/SipHash) 的通用哈希函数。它可用于将任意字节序列映射到整数值。您可以通过多次调用`combine`函数向散列器提供数据，当您完成时，可以通过调用`finalize()`来检索散列。

这意味着开发人员可以只关注哪些数据应该提供给哈希函数，但是实际的转换是在幕后进行的。

输入字节序列的微小变化通常会在输出中产生剧烈的变化，但是`Hasher`保证了如果输入没有变化，输出仍然是相同的——至少在程序的相同执行过程中。

实际上，如果您想要一个定制的实现，您甚至不需要创建`Hasher`和调用`finalize`方法，因为`Hashable`为您提供了方法`hash(into:)`。所以您只需要通过调用`combine(_:)`来决定应该给哈希函数提供什么。

# 副作用

我之前告诉过你，一个`Hasher`的输出仍然是相同的——至少在你的程序的同一个执行过程中。这是因为`Hasher`在每次应用程序启动时都会生成随机的种子值，使得哈希值更加不可预测(主要是出于安全原因)。

实际上，你可以强迫 Swift 使用一个可预测的散列函数，但只是为了测试。唯一要做的是将环境变量`SWIFT_DETERMINISTIC_HASHING` 设置为 1，Swift 将使用一个常量种子值而不是随机值。

请记住，这在生产中是行不通的！你应该只把它用于特定的测试。

# 让我们玩哈希吧

在这最后一节，我想给你看几个例子，以确保你真正理解如何使用散列，因为它很容易出错。

假设您想在字典中保存一个带有自定义键的数字，这个自定义键有一个`id`和一个`title`。

为了能够将我们的密钥用作字典的密钥，我们需要符合`Hashable`协议。我决定只给`id`喂食`Hasher`。

不出所料，字典有两个值，`key1 == key2`是`false`。

我们试着把第二个键的`id`改成`1`。我希望它们现在有相同的散列，这意味着字典会将`key2`的值替换为`key1`。这意味着`dictionary`的元素总数将为 1。

“咦，怎么还是 2？怎么了?现在不应该是一样的哈希吗？”

嗯，没错。如果打印`key1.hashValue == key2.hashValue`就是`true`，实际上`key1 == key2`还是`false`。元素的数量是 2，因为字典执行一些检查并知道两个键是不同的，它将两个相等的散列视为冲突。

来自[官方文件](https://developer.apple.com/documentation/swift/never/3237025-hash):

> 用于哈希的组件必须与您的类型的` == '运算符实现中比较的组件相同。对每个组件调用“hasher.combine(_:)”。

这意味着要解决这个问题，我们还必须用与`hash(:into)`相同的逻辑实现`Equatable`协议。

当然，这不是强制性的——除非你真的知道自己在做什么。否则，这两个实现应该总是相同的。

# 结论

我希望你喜欢这次对世界的短暂探索。如果你有任何问题让我知道。我很乐意帮助你。