<html>
<head>
<title>The State of Piping in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中管道的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-state-of-piping-in-javascript-ccbead18b971?source=collection_archive---------7-----------------------#2020-10-27">https://betterprogramming.pub/the-state-of-piping-in-javascript-ccbead18b971?source=collection_archive---------7-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管道如何提高代码的可读性，以及我们目前对原生管道支持的立场</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3b3dac1f1d1b220fd5b99f19aa24606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-6qSNlPYhzaDm5Ja"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@er1end?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erlend Ekseth </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9f0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，函数组合是将简单函数组合在一起以创建更复杂功能的行为。每个函数的结果作为参数传递给下一个函数，最后一个函数的结果成为整个合成的结果。以这种方式组合在一起的功能通常被称为管道，这类似于物理管道，因为信息在管道中单向流动，就像水在物理管道中流动一样。</p><p id="7b3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，在JavaScript 中将函数链接在一起已经成为可能。这里有一个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1ea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不坏——我们已经将代码分解成三个可重用的组件，然后依次调用它们来创建期望的结果。一个函数的结果作为参数传递给下一个函数，最后一个函数的结果是我们的最终结果——本质上，我们有自己的管道。不过，这个例子在可读性方面有其局限性。这个序列中的功能执行是<code class="fe lu lv lw lx b">repeat</code>，接着是<code class="fe lu lv lw lx b">capitalize</code>，最后是<code class="fe lu lv lw lx b">exclaim</code>——基本上是从右到左。然而，拉丁语言(比如英语)是从左向右读的，这使得我们的管道有些违反直觉。</p><p id="1f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给我们带来了一个提议的新操作符，它可能在将来使事情更可读。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="f252" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">管道运营商提案</h1><p id="3156" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">为了更好地以可读和功能的方式支持链式函数调用，有一个开放的<a class="ae kv" href="https://github.com/tc39/proposal-pipeline-operator" rel="noopener ugc nofollow" target="_blank"> TC39提案</a>引入了管道操作符。管道操作符<code class="fe lu lv lw lx b">|&gt;</code>的灵感来自函数式语言中的等价操作符，如<a class="ae kv" href="https://en.wikibooks.org/wiki/F_Sharp_Programming/Higher_Order_Functions#The_.7C.3E_Operator" rel="noopener ugc nofollow" target="_blank"> F# </a>和<a class="ae kv" href="https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2" rel="noopener ugc nofollow" target="_blank">elixin</a>以及常规的Unix管道。</p><p id="0999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用建议的管道操作符，我们可以解决上一个示例的可读性问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="5120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好多了——现在我们有了可重用的组件，我们可以以一种可读的方式从左到右(或者从上到下，如上面的例子)组合它们。</p><p id="2ce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常基本的例子，每个函数使用一个参数。让我们看另一个有多个参数的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这还不算太糟。我们使用管道操作符的例子比最后一行没有管道操作符的等价例子更易读。不过，处理管道中多个参数所必需的箭头函数增加了噪音，使代码更难阅读。</p><p id="5c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决可读性问题，我们转向另一个<a class="ae kv" href="https://github.com/tc39/proposal-partial-application" rel="noopener ugc nofollow" target="_blank"> TC39提案</a>——即部分应用提案。在程序设计中，部分应用是将许多参数固定到一个函数上，产生另一个具有较少参数的函数的行为。根据该提案:</p><blockquote class="nc nd ne"><p id="694b" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">这个提议引入了一种新的语法，在参数列表中使用了<code class="fe lu lv lw lx b">?</code>标记，这允许您通过充当参数的占位符，将参数列表部分地应用于调用表达式。</p></blockquote><p id="384e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用部分应用程序语法，我们可以提高多参数管道的可读性，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是令人满意的——移除箭头函数极大地提高了我们示例的可读性。现在多参数管道读起来几乎和我们的单参数管道一样容易。</p><p id="4233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切看起来很有希望，但你可能会想，这其中有什么猫腻？不幸的是，事实证明有一些。</p><p id="c4ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，管道运营商和部分应用的提案仍处于第一阶段，这通过<a class="ae kv" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39流程</a>意味着，“委员会期望投入时间来检查问题空间、解决方案和交叉关注点。”在这一阶段，无论如何也不能保证提案能够达到标准。</p><p id="620d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，对于管道运营商来说，目前有两种竞争方案——<a class="ae kv" href="https://github.com/valtech-nyc/proposal-fsharp-pipelines/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">F #管道</a>和<a class="ae kv" href="https://github.com/js-choi/proposal-smart-pipelines/blob/master/readme.md" rel="noopener ugc nofollow" target="_blank">智能管道</a>。本文不会详细介绍这两种方案的不同之处。两个提议都有一些基本的共同点，比如使用<code class="fe lu lv lw lx b">|&gt;</code>作为管道操作符。它们在如何处理同步一元函数的最基本用例上也有重叠，就像我们的第一个例子，函数采用单个参数。然而，这些提议在许多事情上确实不同，比如如何处理异步函数、部分应用程序等等。</p><p id="0c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这些提案，它们已经存在了将近三年，但还没有进入第二阶段。问题之一是委员会还未能就推进哪项提案达成一致。GitHub 上有一个长期的<a class="ae kv" href="https://github.com/tc39/proposal-pipeline-operator/issues/167" rel="noopener ugc nofollow" target="_blank">讨论，是关于用一个最小的提议向前推进的想法，但不幸的是，这似乎现在也停滞不前了。</a></p><p id="eacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标准委员会通过共识运作，考虑到决策对语言的影响，这是合理的。正如一位TC39委员会成员<a class="ae kv" href="https://github.com/tc39/proposal-pipeline-operator/issues/167#issuecomment-622421783" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上所说:</p><blockquote class="nc nd ne"><p id="52ad" class="kw kx nf ky b kz la jr lb lc ld ju le ng lg lh li nh lk ll lm ni lo lp lq lr ij bi translated">我们在TC39中的风格倾向于更保守一点，我们试图推迟到一个特性“完成”之后</p></blockquote><p id="cd35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，当委员会未能就如何推进达成共识时，提案(如管道运营商)就有被卡住的风险。</p><p id="910f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我希望委员会能够同意提出一个最低限度的建议，以便开始行动。最低提案本身就是对语言的一个巨大贡献，在未来提案的基础上有所建树有望有助于推进该特性的发展。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="faf6" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">今天做什么</h1><p id="3583" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果你正在使用一个面向函数式编程的库，比如<a class="ae kv" href="https://lodash.com/docs/4.17.15#flow" rel="noopener ugc nofollow" target="_blank"> lodash </a>、<a class="ae kv" href="https://ramdajs.com/docs/#pipe" rel="noopener ugc nofollow" target="_blank"> ramda </a>、<a class="ae kv" href="https://rxjs.dev/api/index/function/pipe" rel="noopener ugc nofollow" target="_blank"> rxjs </a>或者类似的库，你已经拥有了管道功能。然而，创建一个定制的管道函数就像一行代码一样简单。</p><p id="a22e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数式编程语言中，函数组合可以表示为一个高阶函数，本质上是指一个函数至少接受一个函数作为参数，或者返回一个函数作为结果，或者两者兼有。本文不打算进一步阐述高阶函数，但是已经有很多关于JavaScript中高阶函数的文章——这里有一篇<a class="ae kv" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">文章</a>可以帮助您入门。</p><p id="ce7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这一点，我们的管道函数只不过是一个将其他函数列表作为参数的函数，返回另一个函数，即我们的管道。我们返回的函数将初始值作为输入，然后依次运行我们的管道函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a0be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了用我们的管道支持多个参数，我们可以依靠通常被称为函数currying的东西。如果你想要一篇关于curried函数和组成的深入文章，<a class="nj nk ep" href="https://medium.com/u/c359511de780?source=post_page-----ccbead18b971--------------------------------" rel="noopener" target="_blank"> Eric Elliott </a>有一篇<a class="ae kv" href="https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983" rel="noopener">的好文章</a>给你。简而言之，curried函数允许您将参数固定到一个需要多个参数的函数，将它变成一个我们可以在管道中使用的一元函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以继续在此基础上构建，但是我们已经用一个非常简单的自定义管道函数走了很长的路。可读性不如管道操作符，但也不差。</p><p id="ee81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是一个TypeScript用户，你可能也有兴趣知道有一个开放的<a class="ae kv" href="https://github.com/microsoft/TypeScript/pull/38305" rel="noopener ugc nofollow" target="_blank"> pull request </a>关于为管道操作符添加TypeScript支持的最小提议。如果您使用TypesScript并认为管道操作符会为您的代码增加价值，那么值得关注。</p><p id="c9a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>