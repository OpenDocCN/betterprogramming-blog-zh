<html>
<head>
<title>Convert Swift Facades Into async/await Syntax With Continuations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Swift Facades转换为带有延续的异步/等待语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/convert-your-swift-facades-to-the-new-async-await-syntax-using-continuations-d4a7bda4611b?source=collection_archive---------1-----------------------#2021-12-27">https://betterprogramming.pub/convert-your-swift-facades-to-the-new-async-await-syntax-using-continuations-d4a7bda4611b?source=collection_archive---------1-----------------------#2021-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="18a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在转换回调或基于委托的API时，利用延续的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3329685f4a592b20f5ca510a55a1d930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7rI2CKxDkIfcMDmn4IReg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="6dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与Swift 5.5一起发布的新的<code class="fe ls lt lu lv b">async/await</code> Swift concurrency API终于在去年6月的WWDC 21上亮相。这一新架构满足了我们iOS开发者的所有期望，自2014年Swift首次发布以来，我们就一直在热切地等待这一天的到来，2017年克里斯·拉特纳本人的<a class="ae kv" href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782#part-1-asyncawait-beautiful-asynchronous-apis" rel="noopener ugc nofollow" target="_blank"> Swift并发宣言</a>更是提振了我们的希望。</p><p id="5e47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在推出的所有新API和工具中，新的<code class="fe ls lt lu lv b">async/await</code>语法、参与者和任务吸引了Swift社区的大部分注意力。确实如此，这些新增加的功能大大提高了异步代码的可读性，以及确保应用程序中线程安全的容易程度。</p><p id="ddc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当时引入了另一种机制，尽管它们在与async/await: Continuations一起工作时非常强大，但并没有引起太多的注意。</p><h1 id="de0e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么是延续？</h1><p id="b9d8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">根据<a class="ae kv" href="https://developer.apple.com/documentation/swift/checkedcontinuation" rel="noopener ugc nofollow" target="_blank">文档</a>，延续是同步和异步代码之间的接口机制，记录正确性违规。</p><p id="09f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更准确地说，延续是一个在给定点捕获程序状态的对象，能够在需要时继续它。</p><p id="ce3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这听起来可能仍然很抽象，但是当我们考虑到苹果公司到目前为止是如何实现异步代码的，以及回调和委托模式时，我们可以更深入地理解它。</p><p id="dc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延续在使用这两种模式时大放异彩:它们通过帮助创建新的异步函数来支持旧的模式，从而充当旧世界(回调和委托)和新世界(<code class="fe ls lt lu lv b">async/await</code>以获得更具可读性和结构化的代码)之间的桥梁。</p><p id="f049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在facade包含这些模式的第三方库或Apple APIs时很有帮助，正如我们今天将看到的情况。</p><h1 id="b948" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">用延续来修饰基于委托的类</h1><p id="dacd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在我们的iOS团队中，我们喜欢将一些苹果或第三方开发者的组件与我们自己的组件一起展示。这种模式的目的是多方面的，但有三点非常突出:</p><ul class=""><li id="f688" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">我们用一个更简单的API来提高组件的可读性和可用性，这个API隐藏了一个更复杂的API的细节</li><li id="d57e" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们让模仿变得更容易，从而提高了代码的可测试性</li><li id="ac16" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果我们想使用一项新技术，更松散的耦合使得替换那个facaded组件变得容易</li></ul><p id="e951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我们的<code class="fe ls lt lu lv b">LocationManager</code>班为例。如前所述，我们希望简化并隐藏苹果的<code class="fe ls lt lu lv b">CLLocationManager</code>的复杂性，它是通过<code class="fe ls lt lu lv b">CLLocationManagerDelegate</code>协议的委托模式实现的。</p><p id="f518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更简单地说，我们在给定时刻只获取一次用户位置，而不需要一直监听位置变化。</p><p id="0bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，我们并不反对代表模式本身；我们把它作为我们工具集中的另一个强大的工具，可能对正确的情况非常有用。</p><p id="277f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们的例子，重要的是要注意，因为我们只需要位置一次(启动并忘记)，我们可以将我们的API转换为<code class="fe ls lt lu lv b">async/await</code>，就像我们之前使用承诺一样。</p><p id="b285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要在用户位置发生变化时进行更新，我们仍然需要使用某种反应式编程范例，如Combine或RxSwift，因为需要观察连续的流程。</p><h1 id="bba5" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">快速并发进化</h1><p id="fda3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LocationManager</code>文件的git历史是追踪Swift和我们团队并发性发展的一个非常有趣的来源。</p><p id="417b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在短暂地使用了原始的委托Apple API之后，我们开始使用回调对它进行facading，通过闭包将新的位置传递给客户机。</p><p id="e289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那之后，我们发现了承诺的力量，并创建了我们自己的light Promises开源库来实现它们。(同样，如果需要持续更新，我们会使用更具反应性的方法)。</p><p id="7bae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后Combine出现了，我们用Combine对应库替换了第三方Promises库。最后，时间到了，据说会停留很长时间，当返回的出版商可以被踢出去，并由<code class="fe ls lt lu lv b">await</code>关键字取代。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/f885fdba11dfb4a52ee5c690dc1827b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxBkcVaUHU1vrhpKgpruGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Swift异步代码在WELT iOS中针对位置管理器的演变</p></figure><h1 id="8f5d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">组合立面</h1><p id="7ca6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如前所述，我们的LocationManager在<code class="fe ls lt lu lv b">async/await</code>之前的最后一个版本是在Combine的出版商和承诺的帮助下实现的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="88a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，在promise实例属性的帮助下，通过保留返回的发布者并在更新时做出反应，我们能够在获得位置时让该类成为客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="ac99" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">从合并到异步/等待继续</h1><p id="ae31" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这种方法实现了我们在创建外观时的目标:它隐藏了苹果的<code class="fe ls lt lu lv b">CoreLocation</code>实现细节，并提供了一个更容易处理的API。</p><p id="4c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在我们对改进的贪得无厌的渴望中，我们意识到通过将API转换成<code class="fe ls lt lu lv b">async/await</code>，它仍然可以更简单、更易读。我们如何将CoreLocation异步委托模式与它联系起来呢？在我们新朋友的帮助下，检查继续。</p><p id="1ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以类似于我们通过promise属性返回发布者的方式，我们现在将使用检查的延续来在调用<code class="fe ls lt lu lv b">updateLocation</code>时保持程序状态，以便在检索到位置后继续:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里我们:</p><ul class=""><li id="9a1f" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">为我们的延续类型创建一个<code class="fe ls lt lu lv b">typealias</code>,使它和我们的类一起更具可读性</li><li id="9660" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在该类型的属性中保留位置延续</li><li id="958e" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">当位置被请求时，我们开始继续请求<code class="fe ls lt lu lv b">CLLocationManager</code>更新位置。该延续引用保存在我们的属性中，因此当获得正确的值时，它可以被恢复。(或有错误)</li><li id="7679" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">以这种方式，当我们用更新的位置得到核心位置委托回调时，我们用那个值继续我们的继续。这将恢复原始函数的执行。相反，如果我们得到一个错误，我们继续抛出它。</li></ul><p id="78bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，调用我们经理的代码就简单多了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，由于新的<code class="fe ls lt lu lv b">async/await</code>语法，现在获取位置的调用是多么简单明了。</p><p id="41ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，continuation应该只被调用一次来恢复。</p><p id="57a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不恢复它，函数客户端将永远等待，无限期地持有资源</p><p id="e66d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们这样做不止一次“ala反应流”你的应用程序将崩溃。这里没有选择。</p><p id="bbb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们必须特别小心，以避免这些灾难。在我们的案例中，我们通过以下方式避免它:</p><ul class=""><li id="2391" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">当<code class="fe ls lt lu lv b">CoreLocation</code>返回错误时恢复继续。这样，我们确信它将至少恢复一次。</li><li id="aeb9" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在继续后立即将继续设置为零。这样我们就可以确定它不会被调用多次。如果再次需要该位置，它将被重新创建。</li></ul><h1 id="7833" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">检查过还是不安全？</h1><p id="67d1" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Apple提供了两种类型的延续可以使用:已检查的和不安全的。顾名思义，从<a class="ae kv" href="https://developer.apple.com/documentation/swift/checkedcontinuation" rel="noopener ugc nofollow" target="_blank">文档</a>来看:</p><blockquote class="nk nl nm"><p id="d9e9" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">CheckedContinuation</code>对缺失或多个恢复操作执行运行时检查。<code class="fe ls lt lu lv b">UnsafeContinuation</code>避免在运行时强制执行这些不变量，因为它旨在成为一种低开销的机制，用于将Swift任务与事件循环、委托方法、回调和其他非<code class="fe ls lt lu lv b">async</code>调度机制进行交互。然而，在开发过程中，验证测试中的不变量的能力是很重要的。因为这两种类型具有相同的接口，所以在大多数情况下，您可以用一种替换另一种，而无需进行其他更改。</p></blockquote><p id="6655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您想使用不安全的延续，您必须:</p><ul class=""><li id="3058" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">要确保你的延续会一直继续下去</li><li id="069c" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">分析你的应用程序，验证伴随检查延续而来的额外检查是否导致了一些性能下降</li></ul><p id="e672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果以上任何一点对你来说都不是真的，考虑到错过或多次恢复操作的代价，我建议留在安全的区域使用检查过的延续。</p><h1 id="c4ba" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">夺回</strong></h1><p id="3b2e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在本文中，我们承认了延续在新的Swift并发模型中的作用，以及它与我们相关的原因。</p><p id="9c92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在简要回顾了Facade如何对实现干净的代码和我们应用程序中并发性的历史至关重要之后，我们继续在Continuations的帮助下将我们的核心位置Facade从Combine Promises迁移到一个异步语法API。</p><p id="38a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们陈述了不继续我们的延续或者不止一次继续的后果，以及何时选择不安全的延续而不是检查过的延续。</p><p id="e31f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望现在您的工具箱中有了延续作为另一个强大的工具，可以在从回调或委托模式迁移到async/await时使用。如果您有任何问题、意见或建议，请告诉我。</p><p id="a6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！！</p></div></div>    
</body>
</html>