<html>
<head>
<title>Social Media — On Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">社交媒体——在轨道上</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/social-media-on-rails-e4b88f3d64e9?source=collection_archive---------5-----------------------#2019-08-26">https://betterprogramming.pub/social-media-on-rails-e4b88f3d64e9?source=collection_archive---------5-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b361" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">潜入友谊的红宝石中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3a5f697a045c410eba44447ff5ab47cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J_lEWgV8l5YRht4C"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚瑟·普林<a class="ae kv" href="https://unsplash.com/@barchpou?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="0419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">社交媒体改变了人们与网络应用的互动方式。</p><p id="4475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与其他用户联系和社交的能力使应用程序变得令人愉快、引人入胜和受欢迎——那么为什么不是所有的应用程序都采用这一特性呢？</p><p id="ad56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然开发者会选择反对“友谊功能”的原因有很多，但其中一个主要因素是<em class="ls">难度</em>。</p><p id="c3af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">友谊关系的实现可能令人生畏，但是你可以用处理编程中任何其他问题的同样方式来处理这个挑战——通过熟悉它。</p><p id="fc3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些例子将使用带有活动记录关系的Ruby on Rails，但是其他技术也可以使用类似的解决方案。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ed82" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">快速而强大的解决方案</h1><p id="b2fd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在为最近的Rails项目工作时，我无意中发现了由Sung Won Cho和他的贡献团队创造的出色的Ruby gem。</p><p id="ce02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始和这颗宝石建立友谊关系吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d3d8a34947c7f4d0549ad5bc53313e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*C3UbQHLDncFMXbmDKJCusA.gif"/></div></figure><ol class=""><li id="1394" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">创建一个属性为<code class="fe mx my mz na b">has_friendship</code>的<code class="fe mx my mz na b">User</code>类。</li><li id="753f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">和所有宝石一样，将<code class="fe mx my mz na b">gem “has_friendship”</code>添加到你的<a class="ae kv" href="https://bundler.io/gemfile.html" rel="noopener ugc nofollow" target="_blank">宝石文件</a>中，然后运行<code class="fe mx my mz na b">bundle</code>。</li><li id="de3e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">安装并运行提供的活动记录迁移。</li></ol><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="1576" class="nu mb iq na b gy nv nw l nx ny">$ rails has_friendship_engine:install:migrations<br/>$ rails db:migrate</span></pre><p id="b30b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个简单的设置，<code class="fe mx my mz na b">“has_friendship”</code>已经建立了复杂的自引用连接表，并为您提供了许多优秀的方法来访问它们。</p><p id="18f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户被分成四类，每一类都不同:</p><ul class=""><li id="0ada" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nz ni nj nk bi translated"><code class="fe mx my mz na b">requested_friends</code></li><li id="4692" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nz ni nj nk bi translated"><code class="fe mx my mz na b">pending_friends</code></li><li id="be4c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nz ni nj nk bi translated"><code class="fe mx my mz na b">blocked_friends</code></li><li id="23bc" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nz ni nj nk bi translated"><code class="fe mx my mz na b">friends</code></li></ul><p id="d9f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用这个gem的同时，我们还可以编程一个过滤方法来寻找所有零关联的用户。</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="2486" class="nu mb iq na b gy nv nw l nx ny">def strangers<br/>   users = []<br/>   User.all.each do |user|<br/>      if(self.friends_with?(user) != true &amp;&amp; self != user &amp;&amp;       self.friends.include?(user) != true &amp;&amp; self.pending_friends.include?(user) != true &amp;&amp; self.requested_friends.include?(user) != true)<br/>      users &lt;&lt; user<br/>      end<br/>   end<br/>   users<br/>end</span></pre><p id="79e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得调用<code class="fe mx my mz na b">@user.strangers</code>并接收一组各方面都不相关的用户成为可能(并排除我们调用方法的用户实例)。</p><p id="b62a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您正在设计一个处理大量用户的应用程序，那么您可能希望设计更复杂的过滤方法来减少计算时间。</p><p id="c4c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个激动人心的冒险中，我们的下一步是制作一个<code class="fe mx my mz na b">FriendsController</code>，它可以为我们应用程序的当前用户动态地处理这些关系。</p><ul class=""><li id="cab3" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nz ni nj nk bi translated">您的<code class="fe mx my mz na b">index</code>动作可以显示所有当前用户<code class="fe mx my mz na b">requested_friends</code>、<code class="fe mx my mz na b">pending_friends</code>和<code class="fe mx my mz na b">friends</code>。</li><li id="2db6" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nz ni nj nk bi translated">你的<code class="fe mx my mz na b">create</code>动作可能包括<code class="fe mx my mz na b">@user.friend_request(User.find_by(id: params[:id]))</code>。</li><li id="d62f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nz ni nj nk bi translated">你的<code class="fe mx my mz na b">destroy</code>动作可能包括<code class="fe mx my mz na b">@user.remove_friend(User.find_by(id: params[:id]))</code>。</li></ul><p id="314c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我添加了两个定制动作，<code class="fe mx my mz na b">add</code>和<code class="fe mx my mz na b">reject</code>，以便轻松运行<code class="fe mx my mz na b">accept_request</code>和<code class="fe mx my mz na b">decline_request</code>方法。</p><p id="8fc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些控制器动作，您就可以使用Ruby on Rails编写一个全功能的社交媒体平台了！</p><p id="5711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望通过这个例子，您也看到了Ruby gems的惊人威力和开源软件的不可思议的价值。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7368" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">更深层次的理解</h1><p id="5ecd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">与任何编程主题一样，当您跳下抽象层时，一切都会变得令人生畏。</p><p id="75ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，伴随着高复杂性而来的是巨大的回报，愿意深入抽象的程序员将会对他们的项目产生广泛的控制。</p><p id="e77e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过活动记录使社交媒体行为成为可能的主要因素是<em class="ls">自我参照关系。</em></p><p id="174b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟我们用<code class="fe mx my mz na b">“has_friendship”</code> gem实现的一些行为，我们将创建两个迁移。</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="593e" class="nu mb iq na b gy nv nw l nx ny">def change<br/>   create_table :friendships do |t|<br/>      t.references :friender, foreign_key: false<br/>      t.references :friended, foreign_key: false<br/>end</span><span id="ffe1" class="nu mb iq na b gy oa nw l nx ny">def change<br/>   create_table :friend_requests do |t|<br/>      t.references :requester, foreign_key: false<br/>      t.references :requested, foreign_key: false<br/>end</span></pre><p id="04cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为简单起见，我将<code class="fe mx my mz na b">foreign_key</code>设置为<code class="fe mx my mz na b">false</code>。如果你希望建立正确的外键关系，请看<a class="ae kv" href="https://stackoverflow.com/questions/50614670/activerecordstatementinvalid-sqlite3sqlexception-no-such-table" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出帖子的顶部答案。</a></p><p id="752e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以创建两个相应的模型。</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="d734" class="nu mb iq na b gy nv nw l nx ny">class Friendship &lt; ApplicationRecord<br/>  belongs_to :friender, class_name: 'User'<br/>  belongs_to :friended, class_name: 'User'<br/>end</span><span id="9d84" class="nu mb iq na b gy oa nw l nx ny">class FriendRequest &lt; ApplicationRecord<br/>  belongs_to :requester, class_name: 'User'<br/>  belongs_to :requested, class_name: 'User'<br/>end</span></pre><p id="0eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些模型中，您让活动记录知道标签，比如<code class="fe mx my mz na b">:requester</code>和<code class="fe mx my mz na b">:requested</code>，都引用用户id。</p><p id="26e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建立了这种关系后，我们就有了初始设置的最后一步。</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="6b38" class="nu mb iq na b gy nv nw l nx ny">class User &lt; ApplicationRecord<br/>   has_many :friended_users, foreign_key: :friended_id, class_name: 'Friendship'<br/>   has_many :frienders, through: :friended_users</span><span id="40f3" class="nu mb iq na b gy oa nw l nx ny">has_many :friender_users, foreign_key: :friender_id, class_name: 'Friendship'<br/>   has_many :friendeds, through: :friender_users</span><span id="d7e6" class="nu mb iq na b gy oa nw l nx ny">has_many :requested_users, foreign_key: :requested_id, class_name: 'FriendRequest'<br/>   has_many :requesters, through: :requested_users</span><span id="3403" class="nu mb iq na b gy oa nw l nx ny">has_many :requester_users, foreign_key: :requester_id, class_name: 'FriendRequest'<br/>   has_many :requesteds, through: :requester_users</span><span id="ba36" class="nu mb iq na b gy oa nw l nx ny">end</span></pre><p id="d338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我使用了一个荒谬的命名方案来强调与连接表保持一致的重要性。</p><p id="2523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要觉得有义务完全复制这种语法，但是由于连接表中不正确的命名而导致的错误是常见的。</p><p id="4d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们的代码变得越来越密集，让我们仔细检查我们的理解:</p><ol class=""><li id="9466" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们有两个连接表:<code class="fe mx my mz na b">friendships</code>、<strong class="ky ir">、<strong class="ky ir">、</strong>、<code class="fe mx my mz na b">friend_requests</code>。</strong></li><li id="04f2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">这些表使用外键来建立关系，但是我们告诉它们在所有情况下都要寻找<code class="fe mx my mz na b">user_ids</code>。</li><li id="7466" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当一个用户发起关系时，与另一个用户的对立关系被创建。</li></ol><p id="e3bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="a254" class="nu mb iq na b gy nv nw l nx ny">ted = User.create(name: "Ted")<br/>amy = User.create(name: "Amy")</span><span id="95e6" class="nu mb iq na b gy oa nw l nx ny">ted.requesteds &lt;&lt; amy<br/>                           <em class="ls">ActiveRecord magic<br/></em>amy.requesters.first.name<br/>#=&gt; "Ted"</span></pre><p id="670d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦正确设置了这两种关系，您就可以使用sweet活动记录方法，例如:</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="dc33" class="nu mb iq na b gy nv nw l nx ny">Friendship.new(friender: ted, friended: amy)<br/>#=&gt; &lt;Friendship id: 1, friender_id: 1, friended_id: 2&gt;</span></pre><p id="9bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！如果您能够运行这两个代码块，那么您已经成功地创建了两个自引用连接表来处理朋友请求和友谊。</p><p id="f319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在就看你了，程序员，使用这些工具来获得强大的好处。起初，处理朋友接纳和拒绝的逻辑可能很棘手，但你不是第一个经历这种斗争的人。</p><p id="3878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两个示例方法:<code class="fe mx my mz na b">friend_request</code>和<code class="fe mx my mz na b">accept_request</code>。</p><pre class="kg kh ki kj gt nq na nr ns aw nt bi"><span id="be16" class="nu mb iq na b gy nv nw l nx ny">...in User model</span><span id="1df3" class="nu mb iq na b gy oa nw l nx ny">def friend_request(user)<br/>   FriendRequest.create(requester: self, requested: user)<br/>end</span><span id="0dac" class="nu mb iq na b gy oa nw l nx ny">def accept_request(user)<br/>   FriendRequest.find_by(requester: self, requested: user).destroy<br/>   Friendship.create(friender: self, friended: user)<br/>end</span></pre><p id="dc0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，您在Rails项目中建立了一个完全可定制的社交媒体平台。</p><p id="8cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，为Rails项目建立社交媒体关系有更高级的方法(像这样的<a class="ae kv" href="https://github.com/aasm/aasm" rel="noopener ugc nofollow" target="_blank">)但是理解自引用连接表总是至关重要的。</a></p><p id="ee19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">社交媒体已经成为人类互动的核心元素。</p><p id="be84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望您已经了解了我们这个社会时代数据库管理背后的一些错综复杂的东西，并且您可以应用这些知识来开发有助于将人们聚集在一起的应用程序。</p></div></div>    
</body>
</html>