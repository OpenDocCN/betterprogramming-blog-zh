<html>
<head>
<title>3 Strategies to Address Node.js’s Event Loop Blocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决Node.js事件循环阻塞的3种策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/three-strategies-to-address-node-jss-event-loop-blocking-9dedd0a233ac?source=collection_archive---------2-----------------------#2022-12-19">https://betterprogramming.pub/three-strategies-to-address-node-jss-event-loop-blocking-9dedd0a233ac?source=collection_archive---------2-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aae7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">任务划分、工作线程和集群Express APIs</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e2b87672c4aad0fb3133a609c241b4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AA6u_VXY8EGFGT4H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/it/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解Node.js事件循环是如何工作的，对于改进我们编写打算在这个引擎上运行的JavaScript代码是至关重要的。了解事件循环所经历的不同堆栈和阶段，以及每一个堆栈和阶段中发生的事情，只是实现我们的代码应该如何构建以在该架构上平稳运行的基础。</p><p id="cd7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅仅是另一个Node.js事件循环指南(你可以很容易地在互联网上找到)，在本文中，我将试图让你大致了解阻止Node.js事件循环意味着什么，我们将看到克服它的三个最常用的策略。</p><h1 id="8918" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">陈述问题:事件循环阻塞示例</h1><p id="0354" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们从一个简单的阻塞应用程序的Express API示例开始。看一下下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="387d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简单的API包含一个计算前N-1个整数的平方和的端点:</p><ul class=""><li id="1d85" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><code class="fe na nb nc nd b">GET /calculate/2</code>会给我们<code class="fe na nb nc nd b">{ “result": 1 }</code></li><li id="20a5" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">GET /calculate/5</code>会给我们<code class="fe na nb nc nd b">{ “result": 30 }</code></li><li id="2ef4" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">GET /calculate/10</code>会给我们<code class="fe na nb nc nd b">{ "result": 285 }</code></li></ul><p id="1779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了使用这个端点，假设我们编写了一个客户端，它并行发送多个请求，并测量每个请求完成所需的时间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5e97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们运行<code class="fe na nb nc nd b">node index.js</code>和<code class="fe na nb nc nd b">node client.mjs</code>。以下是输出结果:</p><pre class="kg kh ki kj gt nj nd nk bn nl nm bi"><span id="c06b" class="nn lt iq nd b be no np l nq nr">node client.mjs<br/>sending request #1 with n=4<br/>sending request #2 with n=5<br/>sending request #3 with n=1000000<br/>sending request #4 with n=10<br/>sending request #5 with n=1000000000<br/>sending request #6 with n=10000<br/>finished request #1, result for n=4 is 14, computed in 56 ms<br/>finished request #2, result for n=5 is 30, computed in 36 ms<br/>finished request #3, result for n=1000000 is 333332833333127550, computed in 37 ms<br/>finished request #4, result for n=10 is 285, computed in 37 ms<br/>finished request #5, result for n=1000000000 is 3.333333328333552e+26, computed in 1357 ms<br/>finished request #6, result for n=10000 is 333283335000, computed in 1362 ms</span></pre><p id="089e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe na nb nc nd b">n=10K</code>的要求#6。它不应该比<code class="fe na nb nc nd b">n=1M</code>(请求#3)花费的时间更长，那么，发生了什么？</p><h2 id="3331" class="ns lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">事件循环阻塞</h2><p id="3248" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当一个新的请求到达我们的Express API时，在事件循环中发出一个事件，一个新的回调实例被推送到回调栈。这个回调实例将进行平方和计算。由于只能同时运行一个回调函数(默认情况下，Node.js只有一个执行线程)，其余的回调函数会排队等待，直到正在运行的回调函数结束。</p><p id="bbfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的端点执行一个CPU密集型任务(不建议Node.js回调使用)。因此，回调实例可能需要很长时间才能完成，就像请求#5那样。当请求#5正在执行时，请求#6正在等待下一个事件循环迭代，这在请求#5的回调实例完成之前永远不会发生。</p><p id="2494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了在运行客户端脚本五次后，使用这种方法时每个请求的平均执行时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/d8a44dec9f3993e53b50356c0b969c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrGCwsOxMa8w8otmn6nLuw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示每个请求的平均执行时间的图表，以毫秒为单位(对数刻度)。</p></figure><p id="cfc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在真实的场景中，请求#6可能代表一个关键的API客户端，它不应该等待很长时间才能得到响应。因此，我们希望通过使它们相互独立来最小化每个请求的执行时间。有几个策略可以实现这一点。我将重点介绍三种最常用的方法。</p><h1 id="dff3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.任务划分</h1><p id="827e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当N是一个很大的数字时，处理请求回调必须经过大量的工作才能计算出最终的结果。当这个计算完全占用主Node.js执行线程时，它不能用于任何其他任务。然而，任务划分方法允许我们将大量CPU密集型工作分成一组工作块。</p><p id="5f6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个工作块在一次事件循环迭代中执行，因此允许主线程在完成每个块后执行其他排队的回调。当最后一块工作完成时，最终结果计算也就完成了。每个工作块都为下一次循环迭代安排下一个块的执行，从而允许主线程从队列中弹出回调实例，这些实例需要在运行的迭代中执行。</p><p id="3ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这个版本的API的代码片段。我们将进一步了解它的工作原理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">calculateResultPartitioned</code>函数返回一个<code class="fe na nb nc nd b">Promise</code>，其中包含给定<code class="fe na nb nc nd b">N</code>的最终计算结果。它定义了功能<code class="fe na nb nc nd b">computePartial</code>和<code class="fe na nb nc nd b">fn</code>。</p><ul class=""><li id="4d1a" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><code class="fe na nb nc nd b">computePartial</code>通过计算<code class="fe na nb nc nd b">[0, N)</code>范围内的100k个数字来部分计算结果。</li><li id="b2fe" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">fn</code>只是一个调度功能。它首先调用<code class="fe na nb nc nd b">computePartial</code>函数，然后使用<code class="fe na nb nc nd b">setImmediate</code>钩子调度下一次执行(计算下一个块)。一旦计算完所有的块(通过查看<code class="fe na nb nc nd b">previous</code>变量的值我们知道)，它就解析主<code class="fe na nb nc nd b">Promise</code>。</li></ul><p id="7368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能已经猜到的，尽管这种方法非常流行，但由于它给代码带来的复杂性，它是最不可取的方法。但是，使用同一客户端执行此版本的API会返回以下输出:</p><pre class="kg kh ki kj gt nj nd nk bn nl nm bi"><span id="ab37" class="nn lt iq nd b be no np l nq nr">node client.mjs<br/>sending request #1 with n=4<br/>sending request #2 with n=5<br/>sending request #3 with n=1000000<br/>sending request #4 with n=10<br/>sending request #5 with n=1000000000<br/>sending request #6 with n=10000<br/>finished request #1, result for n=4 is 14, computed in 59 ms<br/>finished request #2, result for n=5 is 30, computed in 39 ms<br/>finished request #4, result for n=10 is 285, computed in 40 ms<br/>finished request #6, result for n=10000 is 333283335000, computed in 46 ms<br/>finished request #3, result for n=1000000 is 333332833333127550, computed in 80 ms<br/>finished request #5, result for n=1000000000 is 3.333333328333552e+26, computed in 16437 ms</span></pre><p id="fc41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一方面，请求#6比请求#5更早更快地被执行和完成，这是所希望的。另一方面，request #5现在比原始版本需要更长的时间来完成。请注意这是如何影响平均执行时间的，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f4d1ec2ae6e3cd17358d3ad9a2582a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_MrlFmB6HDydh8mQEFQ1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示每个请求的平均执行时间的图表，以毫秒为单位(对数刻度)。</p></figure><p id="04e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于在<code class="fe na nb nc nd b">N=1000000000</code>迭代中包含的100k大小的工作块的数量，请求#5需要那么长时间才能完成。每次循环迭代都必须调度、排队和弹出回调，这给主线程增加了额外的开销，使它运行得更慢。请注意，您可以通过尝试不同大小的工作块来获得更平滑的结果(这里，我尝试100k)。</p><h1 id="dd02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.工作线程</h1><p id="3714" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Node.js <a class="ae kv" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank"> Worker Threads </a>是一个现代特性，允许你轻松地并行运行任务。我们可以使用它，每次请求时启动一个新线程。该线程将专门用于计算特定值<code class="fe na nb nc nd b">N</code>的最终结果。Node.js的子进程可以类似地使用。在这里，我更喜欢工作线程，因为它们是更简单、更轻量级的解决方案。</p><p id="ea67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用工作线程，我们首先需要定义一个负责启动每个<code class="fe na nb nc nd b">worker</code>线程实例的<code class="fe na nb nc nd b">solveOperationAsync</code>函数。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常简单的模块，它遵循两条执行路径，这取决于它是从父进程还是从worker执行:</p><ul class=""><li id="3e47" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">当由父进程执行时，它创建一个新的工作线程实例，发送<code class="fe na nb nc nd b">N</code>值，并用最终结果解析一个<code class="fe na nb nc nd b">Promise</code></li><li id="9a71" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated">当由工作线程执行时，它只接收<code class="fe na nb nc nd b">N</code>值并计算结果，在完成之前将结果发送回父线程</li></ul><p id="8f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们的Express API将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ecb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，请求处理发生在父进程中，因此每次收到新请求时都会启动一个新的工作线程。由于我们使用了一个<code class="fe na nb nc nd b">Promise</code>来进行计算，它将在解决前一个请求的同时监听新的即将到来的请求，因此不会阻塞其他客户端。</p><p id="3ade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，应该使用工作线程池创建工作线程，限制运行线程的数量，从而防止我们的基础设施超出其资源限制。</p><p id="9c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法比前一种快得多。看看我得到的结果:</p><pre class="kg kh ki kj gt nj nd nk bn nl nm bi"><span id="e8f3" class="nn lt iq nd b be no np l nq nr">node client.mjs<br/>sending request #1 with n=4<br/>sending request #2 with n=5<br/>sending request #3 with n=1000000<br/>sending request #4 with n=10<br/>sending request #5 with n=1000000000<br/>sending request #6 with n=10000<br/>finished request #1, result for n=4 is 14, computed in 139 ms<br/>finished request #2, result for n=5 is 30, computed in 119 ms<br/>finished request #4, result for n=10 is 285, computed in 118 ms<br/>finished request #6, result for n=10000 is 333283335000, computed in 119 ms<br/>finished request #3, result for n=1000000 is 333332833333127550, computed in 124 ms<br/>finished request #5, result for n=1000000000 is 3.333333328333552e+26, computed in 1601 ms</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/1d90a533e6c72965086731ffa4f235df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhSufvL8r9z3mB0Tj4W6sA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示每个请求的平均执行时间的图表，以毫秒为单位(对数刻度)。</p></figure><p id="1c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，每个请求根据其N值完成(值越小，完成得越早)，但是由于某种原因，现在需要更长时间来计算<code class="fe na nb nc nd b">N</code>何时是<code class="fe na nb nc nd b">4</code>、<code class="fe na nb nc nd b">5</code>或<code class="fe na nb nc nd b">10</code>。这可能是由于在执行之前设置每个工作线程需要额外的工作。</p><h1 id="9bb7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.集群Express API</h1><p id="8ad4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://nodejs.org/api/cluster.html#cluster" rel="noopener ugc nofollow" target="_blank"> Node.js集群</a>特性允许您拥有同一个Node.js进程的多个并行实例，这些实例将根据应用程序的需求进行负载分配。与工作线程不同，集群进程相互隔离，因此有自己的调用堆栈、内存空间和线程。这使它们成为一个更健壮、更强大、更快速的解决方案。</p><p id="77a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将Node.js集群添加到我们的API中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d5a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码非常类似于worker threads方法，因为我们也有两条执行路径，这取决于执行它的进程。注意<code class="fe na nb nc nd b">cluster.schedulingPolicy = cluster.SCHED_RR</code>这一行，这在我的Windows上是必要的，因为它一开始使用了不同的策略，这使得它很慢。这告诉Node.js引擎在负载平衡时使用循环策略。</p><p id="3581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个版本的API似乎比其他版本快得多。看一看结果:</p><pre class="kg kh ki kj gt nj nd nk bn nl nm bi"><span id="65ff" class="nn lt iq nd b be no np l nq nr">node client.mjs<br/>sending request #1 with n=4<br/>sending request #2 with n=5<br/>sending request #3 with n=1000000<br/>sending request #4 with n=10<br/>sending request #5 with n=1000000000<br/>sending request #6 with n=10000<br/>finished request #1, result for n=4 is 14, computed in 45 ms<br/>finished request #2, result for n=5 is 30, computed in 27 ms<br/>finished request #4, result for n=10 is 285, computed in 26 ms<br/>finished request #6, result for n=10000 is 333283335000, computed in 27 ms<br/>finished request #3, result for n=1000000 is 333332833333127550, computed in 33 ms<br/>finished request #5, result for n=1000000000 is 3.333333328333552e+26, computed in 1490 ms</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1a3ec0f6241c336cbb4c0afa489491f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnP9jFKGurOWBSFWDL5WXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示每个请求的平均执行时间的图表，以毫秒为单位(对数刻度)。</p></figure><p id="6a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到，这种方法正是我们所寻求的:</p><ul class=""><li id="e8d8" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">具有低值<code class="fe na nb nc nd b">N</code>的请求几乎立即完成，不到50毫秒</li><li id="59df" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated">具有大值<code class="fe na nb nc nd b">N</code>的请求可能需要更长的时间才能完成，不会阻塞后面的请求，这些请求由不同的进程处理</li></ul><h1 id="78b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="5f81" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用Node.js时，作为第一种工作方法，尽可能避免阻塞事件循环。要么避免高CPU使用率任务，要么使用工作环境完全异步地执行它们。这样做将消除采用任何这些模式的需要。</p><p id="fe79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集群方法似乎是本文介绍的所有策略中最好的。如果并行进程需要互相通信，你最好试试worker threads。这两种策略都允许您控制进程/线程如何被发送垃圾邮件，这可以通过实现按需创建和删除它们的池策略来解决。</p><p id="5c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务划分方法似乎是最复杂和无用的方法。我建议不要使用它，因为它使事情更难理解。如果您不需要/不想发送比主进程更多的额外进程，并且API不太可能同时接收多个请求，请使用它。此外，还要考虑响应时间问题，因为这可能会使一些请求花费更长的时间。</p><p id="fac1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望本文通过具体的实例阐明了一些最常用的处理Node.js事件循环阻塞的策略。</p><p id="88a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>