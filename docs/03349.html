<html>
<head>
<title>Recursive Render in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的递归呈现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursive-render-in-javascript-25269594bad?source=collection_archive---------22-----------------------#2020-02-04">https://betterprogramming.pub/recursive-render-in-javascript-25269594bad?source=collection_archive---------22-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f50f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的渲染以获得更好的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9cb9c0ef729e4606a53437560615c9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqUHc3GKy64Ih_c5gskbkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@luddelorentz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢德·洛伦兹</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，递归是一个函数在自己体内调用自己的概念。请看下面的代码，由<a class="ae ky" href="https://javascript.info/recursion" rel="noopener ugc nofollow" target="_blank"> Javascript.info </a>提供。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="14f9" class="ma mb it lw b gy mc md l me mf">function pow(x, n) {<br/>  let result = 1;<br/>  // multiply result by x n times in the loop<br/>  for (let i = 0; i &lt; n; i++) {<br/>    result *= x;<br/>  }<br/>  return result;<br/>}<br/><br/>alert( pow(2, 3) ); // 8</span></pre><p id="3451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的目标是将<code class="fe mg mh mi lw b">x</code>乘以自身<code class="fe mg mh mi lw b">n</code>倍。在上面的例子中，<code class="fe mg mh mi lw b">pow(2, 3)</code>看起来像2*2*2，结果是<code class="fe mg mh mi lw b">8</code>。</p><p id="2bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数是一个<em class="mj">迭代</em>方法的例子，使用一个<code class="fe mg mh mi lw b">for</code>循环并在每次迭代中应用重复的逻辑。这里可以采用的另一种方法是<em class="mj">递归</em>方法，我们将建立一个可以在需要时调用自身的流程。参见下面的递归函数，也是由Javascript.info提供的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0240" class="ma mb it lw b gy mc md l me mf">function pow(x, n) {<br/>   if (n == 1) {<br/>      return x;<br/>   } else {<br/>      return x * pow(x, n — 1);<br/>   }<br/>}</span><span id="75b8" class="ma mb it lw b gy mk md l me mf">alert( pow(2, 3) ); // 8</span></pre><p id="19c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数不使用<code class="fe mg mh mi lw b">for</code>循环，而是检查<code class="fe mg mh mi lw b">n</code>的值。如果<code class="fe mg mh mi lw b">n</code>等于<code class="fe mg mh mi lw b">1</code>，只需返回<code class="fe mg mh mi lw b">x</code>，因为任何一个的幂都等于它本身。这就是所谓的<em class="mj">基础案例</em>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="8911" class="ms mb it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基础案例</h1><p id="e335" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在递归中，基本情况是结果是直接的，并且是递归停止的情况。</p><p id="e74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有它，我们将简单地无限期地继续调用函数。函数的下一种情况出现在else语句中——这是<em class="mj">递归情况。</em></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="226e" class="ms mb it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">递归情况</h1><p id="4968" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">递归的情况是函数调用自己。</p><p id="5839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，直到<code class="fe mg mh mi lw b">n</code>等于<code class="fe mg mh mi lw b">1</code>，这将满足我们的基本情况并结束递归，我们将<code class="fe mg mh mi lw b">x</code>乘以递归函数，其中<code class="fe mg mh mi lw b">n</code>的值递减1。这确保了我们最终会到达我们的基地，同时，算法会相应地执行。</p><p id="0c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以把递归想象成吃奥利奥。你买了一整套奥利奥(好吃)，然后一直吃到一点不剩(嗯，至少我会。说到饼干我是毫无节制的)。一旦没有了(哭丧着脸)，就停止吃。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6c32" class="ma mb it lw b gy mc md l me mf">function eatOreos(oreos) {<br/>  if (oreos === 0) {<br/>     return oreos;<br/>   } else {<br/>     dunk()<br/>     eat()      <br/>     return eatOreos(oreos-1);<br/>   }<br/>}</span><span id="907c" class="ma mb it lw b gy mk md l me mf">eatOreos(oreos)</span></pre><p id="686f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，递归方法比迭代方法简单，因为我们所做的只是检查<code class="fe mg mh mi lw b">oreos</code>的值，除非它等于<code class="fe mg mh mi lw b">0</code>，否则我们再次调用相同的逻辑，同时将<code class="fe mg mh mi lw b">oreos</code>减少<code class="fe mg mh mi lw b">1</code>。对于迭代方法，我们必须遍历集合，并在每次迭代中执行我们的功能(<code class="fe mg mh mi lw b">dunk</code>和<code class="fe mg mh mi lw b">eat</code>)。</p><p id="e34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，递归不仅仅是一个简单的解决方案。这对我的功能来说是必不可少的。这里有一点背景。</p><p id="614b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个数组，姑且称之为<code class="fe mg mh mi lw b">company</code>，它包含一个在公司工作的人的列表，这些人是按照权限级别组织的。下面是人民对象的样子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d0c" class="ma mb it lw b gy mc md l me mf">{name: 'Amanda', role: 'President (2019-Present)', authority: [...]}</span></pre><p id="d15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">authority</code>数组包含当前人员有权管理的人员列表。那些人也有一个<code class="fe mg mh mi lw b">authority</code>数组，可以包含更多的人(在某些情况下没有)。这个过程对每个人重复进行。</p><p id="dd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在假设我们需要呈现列表中的所有人。每个人代表一个<code class="fe mg mh mi lw b">li</code>项目。如果那个人的<code class="fe mg mh mi lw b">authority</code>值中有更多的人，我们需要将这些人呈现为<code class="fe mg mh mi lw b">ul</code>元素下的<code class="fe mg mh mi lw b">li</code>元素。重复此过程，直到我们列出了<code class="fe mg mh mi lw b">company</code>中的每个人。如果你确切地知道有多少层，那么你可以采取迭代的方法。</p><p id="5cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您确定有三个级别，并且您需要检查每个人的<code class="fe mg mh mi lw b">authority</code>数组中的所有人，那么您需要编写三个嵌套循环来检查他们的<code class="fe mg mh mi lw b">authority</code>值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fff0" class="ma mb it lw b gy mc md l me mf">const renderCompany = (company) =&gt; {<br/>  company.forEach(person=&gt;{    <br/>    //create li, render person<br/>      if (person.authority.length &gt; 0){ <br/>        //create ul, render people in person.authority<br/>        person.authority.forEach(x=&gt;{<br/>          //create li, render person          <br/>          if (x.authority.length &gt; 0){ <br/>            //create ul, render people in person.authority<br/>            x.authority.forEach(y=&gt;{<br/>               //create li, render person<br/>            })<br/>          }<br/>        })<br/>      } <br/>   })<br/>}</span><span id="20b9" class="ma mb it lw b gy mk md l me mf">renderCompany(company)</span></pre><p id="de5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">且不说这是多余的，就<a class="ae ky" href="https://open4tech.com/time-complexity-of-algorithms/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">时间复杂度</em> </a> <em class="mj">而言，这是非常低效的。</em>对于那些不熟悉时间复杂度的人来说，时间复杂度本质上是相对于集合来说完成一项任务所需的时间。线性时间用<em class="mj"> O(n) </em>来表示，基本上就是说随着你的集合规模的增加，你的函数执行的时间也会成比例的增加。</p><p id="6a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://open4tech.com/time-complexity-of-algorithms/" rel="noopener ugc nofollow" target="_blank"> Open4Tech </a>:</p><blockquote class="no np nq"><p id="e9ce" class="kz la mj lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">“如果一个算法的运行时间与输入的平方成正比，则称该算法具有二次时间复杂度。”当您在循环中执行循环时就是这种情况，您需要在原始循环的每次迭代中遍历集合。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/452446afdaeea987a33334d8dbb973e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65XeKVURgCAEzKQy6nFcbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://open4tech.com/time-complexity-of-algorithms/" rel="noopener ugc nofollow" target="_blank"> Open4Tech </a></p></figure><p id="c984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在上面的函数中使用了三个<code class="fe mg mh mi lw b">for</code>循环，所以它所代表的时间复杂度为<em class="mj"> O(n)。</em>这是非常低效的。除了效率低之外，这只能在假设我们知道数据集嵌套有多深的情况下才能工作。如果我们不知道它的嵌套程度，上面的函数就不会有效。</p><p id="7c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然迭代方法不足以完成我们在<code class="fe mg mh mi lw b">company</code>中呈现人物的任务，但是我们仍然可以使用递归来完成我们的目标。首先让我们确定基本情况。记住，基本情况是，我们想要停止函数时，满足的条件。对于<code class="fe mg mh mi lw b">renderCompany</code>，我们想在<code class="fe mg mh mi lw b">authority</code>中没有人时停止该功能。相反，我们的递归案例是当这个人的<code class="fe mg mh mi lw b">authority</code>数组中有一群人时我们想要执行的案例。</p><p id="29cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它分解成伪代码。</p><p id="df24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.通过<code class="fe mg mh mi lw b">company</code>循环。</p><p id="69c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.在<code class="fe mg mh mi lw b">company</code>中为每个人创建一个<code class="fe mg mh mi lw b">li</code>元素。</p><p id="27ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.检查当前迭代中的人是否有<code class="fe mg mh mi lw b">authority</code>中的人。</p><p id="d889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.如果<code class="fe mg mh mi lw b">authority</code>中有人员，则创建一个<code class="fe mg mh mi lw b">ul</code>元素，将其附加到人员的<code class="fe mg mh mi lw b">li</code>元素中，并对<code class="fe mg mh mi lw b">authority</code>重复上述逻辑以代替<code class="fe mg mh mi lw b">company</code>。否则，什么都不做。</p><p id="d415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.将为<code class="fe mg mh mi lw b">company</code>创建的所有<code class="fe mg mh mi lw b">li</code>元素追加到<code class="fe mg mh mi lw b">DOM</code>中。</p><p id="ff2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在说说代码。下面是我们的递归<code class="fe mg mh mi lw b">renderCompany</code>函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cfb6" class="ma mb it lw b gy mc md l me mf">const renderCompany = (arr, node) =&gt;{<br/>  return arr.map(x=&gt;{<br/>    var newListItem = document.createElement("li")<br/>    newListItem.innerText = x.role + ': ' + x.name   <br/>    if (x.authority.length &gt; 0){<br/>       var newSubList = document.createElement("ul")<br/>       newListItem.appendChild(newSubList)       <br/>       renderCompany(x.authority, newSubList)<br/>    }<br/>    if (node){<br/>      node.appendChild(newListItem)<br/>    }<br/>    return newListItem<br/>  })<br/>};</span></pre><p id="e2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个参数是数组。我们第一次调用这个函数的时候，<code class="fe mg mh mi lw b"> arr</code>是<code class="fe mg mh mi lw b">company</code>，是我们在公司的人员集合。我们不为<code class="fe mg mh mi lw b">node</code>传递一个论点。对于<code class="fe mg mh mi lw b">arr</code>中的每一项，我们使用JavaScript的<a class="ae ky" href="https://www.w3schools.com/jsref/met_document_createelement.asp" rel="noopener ugc nofollow" target="_blank"> create-element </a>函数创建带有行<code class="fe mg mh mi lw b">var newListItem = document.createElement("li")</code>的<code class="fe mg mh mi lw b">li</code>元素。我们将人的角色和他们的名字分配给<code class="fe mg mh mi lw b">newListItem</code>的<code class="fe mg mh mi lw b">innerText</code>。</p><p id="209a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们返回这个列表项之前，我们用行<code class="fe mg mh mi lw b">if (x.authority.length &gt; 0)…</code>检查这个人是否拥有对任何人的权限。如果是这样，我们创建一个子列表，并把它附加到<code class="fe mg mh mi lw b">newListItem</code>中。</p><p id="a92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们执行递归，这次将<code class="fe mg mh mi lw b">x.authority</code>作为数组和新创建的子列表节点传递。由于<code class="fe mg mh mi lw b">x.authority</code>只是一个人的集合(正如<code class="fe mg mh mi lw b">company</code>一样)，前面的逻辑可以用同样的方式重复。创建一个<code class="fe mg mh mi lw b">li</code>条目，给它的<code class="fe mg mh mi lw b">innerText</code>赋值，检查它的<code class="fe mg mh mi lw b">authority</code>中是否有任何人，最后，检查<code class="fe mg mh mi lw b">node</code>是否被定义。如果是，这意味着我们需要给它附加一个<code class="fe mg mh mi lw b">newListItem</code>。</p><p id="3041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了元素的集合，我们就可以将它们添加到我们的根节点<code class="fe mg mh mi lw b">DOM</code>中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0298" class="ma mb it lw b gy mc md l me mf">var container = document.getElementById('parentList')</span><span id="7f00" class="ma mb it lw b gy mk md l me mf">var items = renderCompany(company)</span><span id="a39a" class="ma mb it lw b gy mk md l me mf">for (var i = 0; i &lt; items.length; ++i){<br/>  container.appendChild(items[i])<br/>}</span></pre><p id="23f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们呈现的<code class="fe mg mh mi lw b">company</code>中的人以及他们有权管理的人的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/08bc302d76637743704d45f3c94695e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQFnBc1XBpaUnUmCyL63GQ.png"/></div></div></figure><p id="136a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用递归，我们的函数保持干燥、相对高效，而且最重要的是动态的。因为只要有嵌套数据，它就调用相同的逻辑，所以我们不需要指定要执行多少次循环。它将继续执行递归步骤，直到我们到达我们的基本情况:这个人在<code class="fe mg mh mi lw b">authority</code>中没有人。</p><p id="38b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码，包括<code class="fe mg mh mi lw b">company</code>数组，都可以在这个<a class="ae ky" href="https://codepen.io/macro6461/pen/gObNjBK" rel="noopener ugc nofollow" target="_blank">代码笔</a>中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="1a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此  <em class="mj">将您的免费媒体会员升级为付费会员，每月只需5美元，您就可以收到来自各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="2a8b" class="ms mb it bd mt mu ny mw mx my nz na nb jz oa ka nd kc ob kd nf kf oc kg nh ni bi translated">参考</h1><div class="od oe gp gr of og"><a href="https://javascript.info/recursion" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">递归和堆栈</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">编辑描述</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">javascript.info</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://open4tech.com/time-complexity-of-algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">算法的时间复杂度</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">算法无处不在，几乎应用于我们生活的方方面面。选择正确的算法来执行…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">open4tech.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://dzone.com/articles/is-your-code-dry-or-wet" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">你的代码是干的还是湿的？-赞恩·德沃普斯</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">不要重复你自己(DRY)是一个软件开发原则，它的主要目的是减少代码的重复…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">dzone.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>