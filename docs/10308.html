<html>
<head>
<title>Building a Word Cloud in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中构建单词云</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/word-cloud-in-swiftui-eee3d69f7d22?source=collection_archive---------0-----------------------#2021-12-25">https://betterprogramming.pub/word-cloud-in-swiftui-eee3d69f7d22?source=collection_archive---------0-----------------------#2021-12-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7897" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SwiftUI界面中调整单词的大小和位置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bac6c8c3de4aeb8240e91cee1740f640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-jc1IPZt7M9B42DsD6hNA.png"/></div></div></figure><p id="4efb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">词云(也称为文本云或标签云)是以不同大小描绘的词的集合或集群。最理想的是提取出文本数据中最相关的部分。</p><p id="1753" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有相当多的GitHub资源库展示了如何使用JavaScript、Python等生成word cloud。但是当我玩SwiftUI的时候。我发现没有多少有用的信息。</p><h1 id="73a8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">基本思想</h1><ul class=""><li id="7961" class="mi mj it kw b kx mk la ml ld mm lh mn ll mo lp mp mq mr ms bi translated">词云是由词串的集合构成的。</li><li id="3b86" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">每个单词可能有不同的字体，不同的字体大小，甚至不同的颜色。</li><li id="b149" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">每个单词不能与其他单词重叠。</li><li id="2f93" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">他们倾向于彼此靠近。</li></ul><p id="bbcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般的方法是从中心开始，放入第一个单词，然后开始将下一个单词放在它周围，尽可能靠近，不要与前面的所有单词重叠。这一节中棘手的部分是如何有效地找到单词的正确位置，我将在后面介绍。</p><h1 id="d832" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">不令人满意的方法</h1><p id="399a" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">几年前，我在做我的业余爱好项目的时候有了第一次尝试。我的方法是生成一个单词云图像，然后将其放入SwiftUI视图中。</p><p id="cb65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我使用<code class="fe nc nd ne nf b">(NSString).size(withAttributes attrs:)</code>来估计字符串的图形大小，在画布中找到一个安全的位置，然后使用<code class="fe nc nd ne nf b">String.draw(in rect:, withAttributes attrs:)</code>将每个字符串渲染到基于位图的<code class="fe nc nd ne nf b">UIGraphic</code>的<code class="fe nc nd ne nf b">UIImage</code>。</p><p id="7a4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后使用SwiftUI的<code class="fe nc nd ne nf b">Image(uiImage: )</code>来实现它。源代码有点像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="48e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能已经注意到了，这并不是一个快捷的方法。我对结果不满意，因为这是一张普通的图片，我不能添加像<code class="fe nc nd ne nf b">.onTapGesture</code>或<code class="fe nc nd ne nf b">NavigationLink</code>这样的SwiftUI事件处理程序来允许用户与每个单词进行交互。</p><h1 id="36c1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">以斯威夫特的名义</h1><p id="623d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我试了几次才最终得到它。</p><h2 id="a8e4" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">估算尺寸</strong></h2><p id="dd36" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">起初，我试图在放置它们之前估计每个字符串的大小。但是，这并不像听起来那么简单。SwiftUI不断地重新计算每个元素的大小，使它们能够组合在一起，有时甚至会按下、截断、扩展或收缩一点。所以每个元素的精确大小是不可预测的。</p><p id="1f82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，<code class="fe nc nd ne nf b">(NSString).size(withAttributes attrs:)</code>估计大小也有一个性能损失，我觉得放在我的代码中并不完美。</p><p id="4b0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的一个方法是把<code class="fe nc nd ne nf b">GeometryReader</code>放在每个单词的外面。但我也发现它带来的问题比解决的问题还多。而且，代码看起来很恶心。</p><p id="aee9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢我不知道是谁，有一个SwiftUI hack可以通过使用透明视图作为背景来获得元素的大小。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7ce8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的高效、出色的性能、清晰的代码，解决了构建SwiftUI word cloud的第一个障碍。</p><h2 id="2311" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">更少的状态变量和</strong> <code class="fe nc nd ne nf b"><strong class="ak">WordSizeGetter</strong></code></h2><p id="0d3b" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在我早期的SwiftUI实验中，我倾向于将所有的变化放入一个状态变量中。一般不管怎样都管用。但是当我再次尝试编写纯SwiftUI版本的<code class="fe nc nd ne nf b">WordCloudView</code>时，我终于注意到了性能损失。由于每次状态值改变时，视图都会使其外观无效并重新计算所有内容，因此我们必须小心不要放置可能与视图外观无关的变量。</p><p id="7490" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了抽象出哪些输入对于计算所有单词的位置是必要的，我发现只需要2个状态变量来生成单词云。</p><p id="7b37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个是画布的大小，或者换句话说，是<code class="fe nc nd ne nf b">WordCloudView</code>的整个区域。另一个是每个字的大小。只是渲染的大小。每个单词的其他属性，甚至单词本身都不应该是状态变量，因为它们是预先确定的，一旦给定就不会改变。</p><p id="2497" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用与<code class="fe nc nd ne nf b">RectGetter</code>类似的方法，我们可以得到每个单词的大小。你可能还会注意到，如果这是SwiftUI第一次尝试渲染视图，由于<code class="fe nc nd ne nf b">canvasRect</code>仍然是一个空的CGRect，<code class="fe nc nd ne nf b">calcPositions</code>将跳过计算，将所有内容放在零点，这似乎每个单词都将在默认中心重叠。但是由于<code class="fe nc nd ne nf b">RectGetter</code>和我们新的<code class="fe nc nd ne nf b">WordSizeGetter</code>将设置状态变量所需的大小信息，所有的东西都将在下一个渲染帧中就位。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="e691" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">计算仓位—野蛮强行</strong></h2><p id="e8e0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">有几种方法可以计算每个单词的位置。最简单的方法是尝试随机放置每个单词，检查它是否与所有已经放置的单词重叠，直到找到一个有效的位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="48e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看出这是简单的暴力。不用说，这不是一个最优解。</p><h2 id="9407" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">计算位置—螺旋</strong></h2><p id="3a00" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">更好的解决方法，也是常见的一种，就是从第一个单词开始，用这个公式慢慢旋出或者遵循一个螺旋路径:<code class="fe nc nd ne nf b"><a class="ae nb" href="https://www.wolframalpha.com/input/?i=plot+x%3Dt*cos%28t%2F10%29%2C+y%3Dt*sin%28t%2F10%29+from+t%3D0+to100" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">x=t*cos(t/10), y=t*sin(t/10)</strong></a><strong class="kw iu"> </strong></code> <strong class="kw iu">。</strong></p><p id="b119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个公式中，t是到中心的长度，或者在我们的例子中，是离第一个单词的中心有多远。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e4cb9c853bc2fe2ef5b657bb3eedaa10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yc29yG4NiDdxvKf7"/></div></div></figure><p id="29e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以对公式进行更多的调整。例如，添加一个比例因子，使其更加椭圆，以便在水平方向上容纳更多的单词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="6529" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">缓存结果</strong></h2><p id="8de7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">当然，我们不应该每次重新渲染视图时都重新计算。因此，我在视图中添加了缓存存储。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在当前视图中<code class="fe nc nd ne nf b">WordCloudPositionCache</code>必须是类而不是结构或成员变量的原因是因为SwiftUI视图是不可变的。我们不想在这里使用状态变量，因为我们也不想触发rerender。</p><h2 id="e30c" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">最后的陷阱</strong></h2><p id="c054" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">就像我之前说的，SwiftUI可能会按下、截断、扩展和收缩一个元素。这是因为SwiftUI不断地在每个元素和约束之间协商位置和大小。其中一个缺陷是，每一个的大小会在没有明显原因的情况下发生微小的变化。大多数时候，它可能只会移动不到0.01磅，但它会导致视图出现毛刺，并重新计算所有单词的位置，这是不必要的。</p><p id="6dba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是最后一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，正如函数名所示，如果单词的大小变化小于0.01磅，我们将认为它们是相似的，跳过重新计算单词位置的过程并返回缓存的结果。</p><h2 id="5d14" class="ni lr it bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated"><strong class="ak">进一步优化</strong></h2><p id="47c0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">当然，还有很多可以优化的地方。比如使用二分搜索法算法来查找每个单词的下一个可用位置，而不是像演示代码那样只是线性搜索。但是在SwiftUI中生成word cloud的所有有趣的部分都已经在这里了。</p><p id="82f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还把完整的演示回购放在了Github。<a class="ae nb" href="https://github.com/tomasen/WordCloudDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/tomasen/WordCloudDemo</a>。玩得开心。</p></div></div>    
</body>
</html>