<html>
<head>
<title>The 6 Benefits of Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入的6个好处</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-6-benefits-of-dependency-injection-7802b207ec69?source=collection_archive---------5-----------------------#2020-02-04">https://betterprogramming.pub/the-6-benefits-of-dependency-injection-7802b207ec69?source=collection_archive---------5-----------------------#2020-02-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ec91" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">编写可读性更强、更易测试的代码</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c0212954c13fd7d63768d5c91e82c3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FKDiM1upycBU-GjH"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Clem Onojeghuo 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="8032" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:本文是我关于依赖注入系列的第四篇文章。你可以在这里阅读前三个:</p><ul class=""><li id="010e" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><a class="ae kz" href="https://medium.com/better-programming/what-is-dependency-injection-b2671b1ea90a" rel="noopener">什么是依赖注入？</a></li><li id="a860" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://medium.com/better-programming/five-principles-of-dependency-injection-5bd0cca9cb04" rel="noopener">依赖注入的5个原则</a>。</li><li id="ea6b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://medium.com/better-programming/the-3-types-of-dependency-injection-141b40d2cebc" rel="noopener">依赖注入的3种类型</a>。</li></ul><p id="9ff6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您已经阅读了上面的三篇文章，您可能理解了依赖注入的“是什么”和“如何”——它是什么以及它是如何工作的。</p><p id="9cba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是你可能会问:“我们为什么要做这些？”为什么要大费周章地按照依赖注入原则所要求的特定方式来安排我们的代码呢？</p><p id="8e7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯，因为有好处。让我们谈一谈这些好处，因为它们很多，而且很有吸引力。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="5a0f" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">1.可维护性</h1><p id="4f9e" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">依赖注入的主要好处可能是可维护性。如果您的类是松散耦合的，并且遵循单一责任原则——使用DI的自然结果——那么您的代码将更容易维护。</p><p id="ead2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">简单、独立的类比复杂、紧密耦合的类更容易修复。</p><p id="a2cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可维护代码的总拥有成本较低。维护成本通常会超过构建代码的成本，所以任何提高代码可维护性的东西都是好东西。我们都想节省时间和金钱，对吗？</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="8dd8" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">2.易测性</h1><p id="f2e4" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">与可维护性相同的是可测试性。易于测试的代码会更频繁地被测试。更多的测试意味着更高的质量。</p><p id="d34e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只做一件事的松耦合类——同样，使用DI的自然结果——非常容易进行单元测试。通过使用依赖注入，您可以更加直接地创建测试替身(通常称为“模拟”)。</p><p id="b817" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您将依赖项传递给类，那么传递一个test double实现是非常简单的。如果依赖项是硬编码的，就不可能为那些依赖项创建测试副本。</p><p id="7da8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实际被测试的可测试代码是质量代码。或者至少，它比未测试的代码质量更高。</p><p id="17f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我发现很难接受单元测试是浪费时间的观点。它们对我来说总是值得花时间的。(当然，我不是唯一一个对这一点存在争议感到奇怪的人？)</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="7aa4" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">3.可读性</h1><p id="00d6" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">使用DI的代码更简单。它遵循单一责任原则，因此产生了更小、更紧凑、更切题的类。</p><p id="5175" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构造函数并不杂乱，也不充满逻辑。类的定义更加清晰，公开声明它们需要什么。正因为如此，基于DI的代码可读性更好。可读性更强的代码更容易维护。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="dc93" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">4.灵活性</h1><p id="ea85" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">松散耦合的代码——再一次，使用依赖注入的结果——更加灵活，可以以不同的方式使用。做一件事的小类可以更容易地在不同的情况下重新组装和重用。</p><p id="19d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">小班就像乐高积木——它们可以很容易地拼凑成各种各样的东西，这与Duplo积木相反，后者体积更大，灵活性更差。能够重用代码可以节省时间和金钱。</p><p id="193b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所有的软件都需要能够改变和适应新的需求。使用依赖注入的松散耦合代码非常灵活，能够适应这些变化。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="8793" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">5.展开性</h1><p id="a814" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">使用依赖注入的代码会产生更具可扩展性的类结构。通过依赖抽象而不是实现，代码可以很容易地改变给定的实现。</p><p id="f995" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你针对抽象进行编码时，你可以抱着这样的想法进行编码，即你正在做的事情的更好的实现就在眼前。</p><p id="faac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">灵活的小类可以很容易地通过继承或组合来扩展。</p><p id="3631" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">应用程序的代码库从来都不是静态的，随着代码库的增长和新需求的出现，您很可能需要添加新的特性。可扩展代码能够应对这一挑战。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="eda3" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">6.团队能力</h1><p id="13b2" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">如果你在一个团队中，这个团队需要在一个项目中一起工作(什么时候不是这样？)，那么依赖注入会促进团队开发。(即使你是一个人在工作，你的工作将来也很可能会传给别人)。</p><p id="89a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">依赖注入要求你针对抽象而不是实现进行编码。</p><p id="fcc4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你有两个团队一起工作，每个团队都需要另一个团队的工作，你可以在实现之前定义抽象。然后每个团队可以使用抽象编写他们的代码，甚至在实现编写之前。</p><p id="d046" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，由于代码是松散耦合的，这些实现不会相互依赖，因此它们很容易在团队之间分开。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="0cb7" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="ed5b" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">所以，你有它。依赖注入产生可维护的、可测试的、可读的、灵活的和可扩展的代码，这些代码很容易在团队成员之间传播。似乎很难想象有哪个开发者不想要这一切。</p></div></div>    
</body>
</html>