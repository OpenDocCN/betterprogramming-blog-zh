<html>
<head>
<title>Reactive Programming Patterns for Asynchronous APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步API的反应式编程模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-patterns-emerging-from-stackoverflow-asynchronous-api-calls-as-streams-in-the-real-world-ef636c9af19a?source=collection_archive---------9-----------------------#2020-03-15">https://betterprogramming.pub/rxjs-patterns-emerging-from-stackoverflow-asynchronous-api-calls-as-streams-in-the-real-world-ef636c9af19a?source=collection_archive---------9-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="166e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">堆栈溢出的真实场景</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/927520eae35c90e38fc788118b5a5fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8eFjmVTyjtQ7KNKd4clGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="3047" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反应式编程越来越受欢迎，对<a class="ae lu" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>库的使用也是如此。越来越多的人开始使用这种范式，并且在他们的学习道路上经常面临类似的问题。相似的问题需要相似的解决方案，这就是模式。</p><p id="9d4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解现实问题的一个有趣来源是堆栈溢出。我前段时间开始关注围绕RxJS的问题，我注意到了一些反复出现的主题和人们必须应对的类似情况。</p><p id="029f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个流行的主题是异步API调用；换句话说，如何处理现实世界中的HTTP请求。例如:</p><ul class=""><li id="d754" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">如何顺序调用多个异步API，每个都依赖于前一个的结果？</li><li id="c3f7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">如何将参数数组转换成异步调用数组并控制它们的执行？</li><li id="f21d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">即使我们无法预测每个请求需要多长时间才能返回，如何以预定义的频率随时间递归调用API？</li></ul><p id="1b96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何处理这种情况。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="62c8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">顺序调用许多异步API来完成工作</h1><p id="c3d0" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">调用一些REST APIs。对于许多人来说，这是RxJS的第一个问题。REST APIs本质上是异步的，可以建模为只有一个值的流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c292f083b69349b860b64b7d50910445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYurOMJhHuoUMVu7hEDzXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为可观察对象的HTTP请求</p></figure><p id="9f92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在实际场景中，我们经常需要发出不同的API调用来完成工作。这里有一些如何处理这些情况的例子。</p><h2 id="002a" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated"><strong class="ak">合并顺序发射的可观测结果</strong></h2><p id="e69b" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">通常我们需要连续地打几个电话来得到我们想要的东西。例如，假设我们有两个API，一个返回雇员的详细信息，给定他们的ID，另一个返回部门的详细信息，同样给定其ID:</p><ul class=""><li id="99e1" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe oa ob oc od b">getEmployee(id: string) : Observable&lt;Employee&gt;</code></li><li id="c921" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">getDepartment(id: string) : Observable&lt;Department&gt;</code></li></ul><p id="f5af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">Employee</code>包含了<code class="fe oa ob oc od b">departmentId</code>他们工作的地方。我们需要做的是一起返回员工及其部门的详细信息。</p><p id="85e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的关键是按顺序进行这两个调用，即使两个调用都是异步的，然后合并两个结果。这是一种可能的方法:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f89d" class="no mr it od b gy oi oj l ok ol">getEmployee(employeeId).pipe(<br/>  <strong class="od iu">concatMap</strong>(employee =&gt; getDepartment(employee.deptId).pipe(<br/>    <strong class="od iu">map</strong>(department =&gt; ({employee, department}))<br/>  ))<br/>)</span></pre><p id="88d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe oa ob oc od b">concatMap</code>，我们保证<code class="fe oa ob oc od b">getEmployee</code>在我们移动到下一个可观察对象之前完成，这是由<code class="fe oa ob oc od b">getDepartment</code>返回的。一旦<code class="fe oa ob oc od b">getDepartment</code>发出，我们就使用<code class="fe oa ob oc od b">map</code>操作符转换发出的值，该操作符直接在<code class="fe oa ob oc od b">getDepartment</code>之后通过管道传输。注意到<code class="fe oa ob oc od b">employee</code>在<code class="fe oa ob oc od b">map</code>操作符所在的闭包内是很重要的，所以它可以在传递给它的函数内使用。这就成功了。</p><p id="f0f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不能在最外部的管道中使用<code class="fe oa ob oc od b">map</code>操作符，因为根据JavaScript闭包的可见性规则，<code class="fe oa ob oc od b">employee</code>变量是不可见的。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="06be" class="no mr it od b gy oi oj l ok ol">getEmployee(employeeId).pipe(<br/>  concatMap(employee =&gt; getDepartment(employee.deptId)),<br/>  // <strong class="od iu">employee variable is not visible here</strong><br/>  map(department =&gt; ({employee, department})) // <strong class="od iu">would not compile</strong><br/>)</span></pre><p id="394f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为旁注，短语法<code class="fe oa ob oc od b">department =&gt; ({employee, department})</code>相当于<code class="fe oa ob oc od b">department =&gt; {return {employee, department}}</code>。</p><p id="e5a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引起我注意这个问题的堆栈溢出问题是<a class="ae lu" href="https://stackoverflow.com/questions/52225197/how-can-i-get-the-value-of-the-first-observable-in-a-chain-of-observables-relati" rel="noopener ugc nofollow" target="_blank">这个问题</a>和<a class="ae lu" href="https://stackoverflow.com/questions/52271612/how-to-merge-static-observable-with-dynamic-in-rxjs-6" rel="noopener ugc nofollow" target="_blank">这个问题</a>。</p><h2 id="76b0" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated"><strong class="ak">沿着一条长长的运算符管道传递一个值</strong></h2><p id="3d76" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这个例子与调用异步API没有严格的关系，但是经常与调用异步API联系在一起。</p><p id="afd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑一个类似的例子。我们需要计算员工家庭住址和办公地点之间的距离。像以前一样，我们需要获取雇员详细信息来获得雇员地址，然后获得部门详细信息。不过，这一次，为了读取办公地点的地址，我们需要调用第三个API，将部门ID作为参数。一旦我们有了两个地址，我们就可以调用最后一个服务来获得两个地址之间的距离。</p><p id="0395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们当然可以扩展以前使用的相同方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="01cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这种风格很容易变得乏味。传递雇员数据的需要使代码变得混乱。我们希望找到一种更简单的方法来做到这一点，JavaScript闭包再次派上了用场，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f101" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，关键点是创建一个函数，在我们的例子中是一个名为<code class="fe oa ob oc od b">closureF</code>的箭头函数，它需要一个参数<code class="fe oa ob oc od b">employee: Employee</code>。由于这是一个函数的参数，它在整个函数中都是可用的，所以<code class="fe oa ob oc od b">closureF</code>函数中的任何操作符都可以直接访问它。</p><p id="e1ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便提一下，在<code class="fe oa ob oc od b">concatMap(closureF)</code>中，我们使用了一个相当于<code class="fe oa ob oc od b">concatMap(employee =&gt; closureF(employee))</code>的紧凑语法。</p><p id="aa91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子启发我的堆栈溢出问题是<a class="ae lu" href="https://stackoverflow.com/questions/51578014/sane-way-to-pass-keep-a-value-throwout-a-long-pipe" rel="noopener ugc nofollow" target="_blank">这个问题</a>和<a class="ae lu" href="https://stackoverflow.com/questions/60533679/removing-side-effect-from-observable-implementation/60535164#60535164" rel="noopener ugc nofollow" target="_blank">这个问题</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="13c9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从进行异步调用数组所需的参数数组开始</h1><p id="7280" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">假设我们有一个产品代码列表，我们需要通过调用一个异步API来获取每个产品的详细信息。有时我们没有接受一系列代码的API，而只有一个接受单一产品代码的API。在这种情况下，我们的代码列表被转换成一系列API调用。</p><p id="83a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们可能会面临不同的需求。我们可能被要求让调用以与产品代码的初始数组相同的顺序返回结果。我们可能被要求设置并发调用的数量限制，以控制API服务器上的负载。我们可能被要求并行运行所有调用，并在所有调用完成后立即返回所有结果。</p><p id="32f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何使用RxJS操作符来处理这些情况。</p><h2 id="e55d" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated"><strong class="ak">从一个参数数组开始调用一堆API</strong></h2><p id="2700" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这是最简单的场景。我们只需要调用API的次数和数组中参数的数量一样多。然后我们处理结果，忽略了结果可能以不同的顺序返回的事实。为了使这个例子更容易绘制，我们假设我们的远程服务器提供了一个对数字求平方的REST API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1857b7962f03bc674c7211379fd63ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9y1qCcVyd1GFM384etQBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务器被多次调用，结果以不同的顺序返回</p></figure><p id="06d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的解决方案是通过使用<code class="fe oa ob oc od b">mergeMap</code>操作符，也就是<code class="fe oa ob oc od b">flatMap</code>来提供的。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2814" class="no mr it od b gy oi oj l ok ol">from([1, 2, 3, 4]).pipe(<br/>   <strong class="od iu">mergeMap</strong>(n =&gt; squareMe(n))<br/>)</span></pre><p id="a58b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的大理石图显示了一段时间内的行为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/67b550aa5a9293eeb7eb7944c63998a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFwYlisWi7bjDcAsd1LNdg.png"/></div></div></figure><p id="6790" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想保证返回值的顺序不变呢？嗯，在这种情况下，我们使用<code class="fe oa ob oc od b">concatMap</code>而不是<code class="fe oa ob oc od b">mergeMap</code>，生活将对我们有利。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7925" class="no mr it od b gy oi oj l ok ol">from([1, 2, 3, 4]).pipe(<br/>   <strong class="od iu">concatMap</strong>(n =&gt; squareMe(n))<br/>)</span></pre><p id="e2b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保证所有可观察的事物将按照它们被创建的顺序被处理；更准确地说，只有当第一个观察完成时，我们才能转向下一个观察。</p><h2 id="0ca3" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated">限制服务器上的并发点击次数</h2><p id="2690" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在前面的示例中，我们将多次并发访问服务器。我们无法控制针对它发出多少并行调用。不过，有时我们可能不得不控制这个数字。服务器能够为单个客户机管理的并发请求有一个限制，我们可能不想超过这个限制。</p><p id="f3d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们可以再次使用<code class="fe oa ob oc od b">mergeMap</code>，指定第二个可选参数<code class="fe oa ob oc od b">concurrency</code>。该参数允许我们设置在<code class="fe oa ob oc od b">mergeMap</code>内可同时处理的最大观察值，更准确地说是<em class="oq">订阅的</em>。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c3ec" class="no mr it od b gy oi oj l ok ol">from([1, 2, 3, 4]).pipe(<br/>   <strong class="od iu">mergeMap</strong>(n =&gt; squareMe(n), 2)<br/>)</span></pre><p id="4b44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子显示了我们如何确保最多同时有两个HTTP请求在运行。</p><p id="61b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把<code class="fe oa ob oc od b">concurrency</code>设为1会发生什么？这意味着我们一次只有一个请求，这意味着我们连接所有的请求，这意味着<code class="fe oa ob oc od b">concatMap</code>相当于<code class="fe oa ob oc od b">mergeMap</code>设置为1。</p><h2 id="849c" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated">并行运行所有API，并在所有API都完成(或出现一个错误)时返回</h2><p id="c55f" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们要考虑的最后一种情况是，当我们希望有许多请求并行运行，并在所有请求都完成或其中一个请求出错时得到通知。</p><p id="a68a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，操作员要查看的是<code class="fe oa ob oc od b">forkJoin</code>。<code class="fe oa ob oc od b">forkJoin</code>接受一个观察值数组作为输入，并返回一个数组，该数组包含作为输入传递的每个观察值发出的最后值。</p><p id="430e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到我们的例子，这意味着我们必须首先构建一个可观测量数组，然后将它传递给<code class="fe oa ob oc od b">forkJoin</code>，就像这样:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3130" class="no mr it od b gy oi oj l ok ol">const <strong class="od iu">arrayOfObservables</strong> = [1, 2, 3, 4].map(n =&gt; squareMe(n));<br/>forkJoin(<strong class="od iu">arrayOfObservables</strong>);</span></pre><p id="a72b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用大理石图来想象这种情况下会发生什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/8aae1c77db567dbf08bc6a509b3660e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWDAmhJ7W7YgA2iI3h12Cw.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dd5d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">随着时间的推移递归调用API</h1><p id="20e2" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">当我们需要随着时间的推移重复调用一些异步API时，一些有趣的问题就出现了。</p><h2 id="d94c" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated"><strong class="ak">在API自身返回的数据指定的到期时间后，刷新API中的数据</strong></h2><p id="35e1" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">假设我们有一个远程服务，可以通过REST API获取一组数据。作为此类数据的一部分，服务器返回一个到期时间，该时间指示数据可被视为有效的截止时间。</p><p id="dded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有效性一过期，我们就想获取新的有效数据。</p><p id="6a9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的是反复调用REST API，根据上一次调用的结果设置每次调用的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/17dcaaa30b74af83feb8ac22a85afec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EV5g3SLxKYyGofoAfIt82w.png"/></div></div></figure><p id="7f8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个递归问题，当我们看到递归时，我们需要考虑<code class="fe oa ob oc od b">expand</code>运算符。</p><p id="757a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在不涉及文档中可用的太多细节的情况下，我们可以说<code class="fe oa ob oc od b">expand</code>是一个接受函数作为其参数的操作符。这个函数需要返回一个可观察值。由源可观测值和由输入函数返回的可观测值通知的每条数据都作为输入传递回函数本身。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/9230956f2feae3263f1b74e910e2e8ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zy4S64nwGDLaTeB-ODCZDQ.png"/></div></div></figure><p id="09c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住这一点，我们可以在验证时间到期后处理调用API的问题，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="e1f5" class="no mr it od b gy oi oj l ok ol">fetchDataAndExpiry().pipe(<br/>   expand(({data, expiry}) =&gt; fetchDataAndExpiry().pipe(<br/>      delay(expiry)<br/>   ))<br/>)</span></pre><p id="e4ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要注意的是，传递给<code class="fe oa ob oc od b">delay</code>操作符的参数是前一个调用返回的<code class="fe oa ob oc od b">expiry</code>的值。</p><p id="da23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的解决方案忽略了远程调用本身引入的延迟。如果我们要考虑它，我们必须稍微复杂一些代码，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a37e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://stackoverflow.com/questions/49886776/rxjs-repeat-api-call-based-on-duration-specified-in-response" rel="noopener ugc nofollow" target="_blank">这个问题启发了</a>这个例子。</p><h2 id="6db0" class="no mr it bd ms np nq dn mw nr ns dp na lh nt nu nc ll nv nw ne lp nx ny ng nz bi translated"><strong class="ak">平均每分钟调用一个API N次</strong></h2><p id="8013" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这是另一个有趣的例子。还有一个远程服务器为客户端提供REST API。不过，这一次，平均而言，客户有权在某个时间间隔内调用该服务一定的次数。例如，他们可以每分钟调用API十次，即每六秒一次。通常，API在该时间间隔内响应，但有时可能需要更长时间。在这种情况下，您有权在返回后立即调用API，因为您将保持在为您设置的平均值范围内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/df4d88e4490cf6779ea357df59e470d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNcN73FxhkOcciqWoFEWEQ.png"/></div></div></figure><p id="7693" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这种情况，我们可以使用<code class="fe oa ob oc od b">interval</code>和<code class="fe oa ob oc od b">concatMap</code>的组合，就像这样”</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2cde" class="no mr it od b gy oi oj l ok ol">interval(throttleTime).pipe(<br/>   concatMap(() =&gt; callAPI())<br/>);</span></pre><p id="afc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">throttleTime</code>是我们平均必须遵守的时间间隔，以毫秒表示。所以，如果我们每分钟可以发出十个API调用，<code class="fe oa ob oc od b">throttleTime</code>就是60 / 10 = 6.000毫秒<em class="oq">。</em> <code class="fe oa ob oc od b">interval</code>然后创建一系列事件，每六秒触发一次。这是我们调用服务器的节奏。</p><p id="7ffa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe oa ob oc od b">concatMap</code>，我们将这样的事件转换成另一个可观察的流，即通过调用<code class="fe oa ob oc od b">callAPI()</code>函数返回的可观察的流。<code class="fe oa ob oc od b">concatMap</code>还确保这些新的可观测量按顺序订阅，即它们被连接。因此，如果一个调用的返回时间超过6秒，那么下一个调用必须等待它完成后才能被触发。</p><p id="bf9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是<a class="ae lu" href="https://stackoverflow.com/questions/52289312/how-to-make-repeated-http-requests-not-more-than-every-n-seconds-with-rxjs" rel="noopener ugc nofollow" target="_blank">激发这个例子</a>的问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="54ae" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="2e5d" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这些是我们在读取堆栈溢出问题时发现的一些常见问题的例子。其他主题也有待研究。如果您喜欢这种方法，我们可以继续研究其他模式。</p></div></div>    
</body>
</html>