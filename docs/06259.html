<html>
<head>
<title>Elasticsearch: Text vs. Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索:文本与关键词</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/elasticsearch-text-vs-keyword-2ccb99ec72ae?source=collection_archive---------0-----------------------#2020-09-15">https://betterprogramming.pub/elasticsearch-text-vs-keyword-2ccb99ec72ae?source=collection_archive---------0-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cfab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们之间的差异以及它们的行为方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9824f6b5a9faa660bfdb56c08546f412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hYQUyVjpTQj2A0Nq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="699f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多刚开始学习Elasticsearch的人经常混淆<code class="fe lv lw lx ly b">Text</code>和<code class="fe lv lw lx ly b">Keyword</code>字段数据类型。它们之间的区别很简单，但非常关键。在这篇文章中，我将谈论它们的区别，如何使用它们，它们如何工作，以及在两者之间使用哪一个。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ae9b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">差异</h1><p id="aeed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">它们之间的关键区别在于，Elasticsearch会在将<code class="fe lv lw lx ly b">Text</code>存储到倒排索引之前对其进行分析，而不会分析<code class="fe lv lw lx ly b">Keyword</code>类型。分析与否将影响它在被查询时的行为。</p><p id="8de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你刚开始学习Elasticsearch，还不知道什么是倒排索引和分析器，我推荐你先看一本<a class="ae ky" href="https://codecurated.com/blog/basics-of-elasticsearch-for-developer/" rel="noopener ugc nofollow" target="_blank">elastic search基础指南</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d421" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何使用它们</h1><p id="41a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您将包含字符串的文档索引到Elasticsearch，而之前没有定义到字段的映射，Elasticsearch将创建一个包含<code class="fe lv lw lx ly b">Text</code>和<code class="fe lv lw lx ly b">Keyword</code>数据类型的动态映射。但是，即使它与动态映射一起工作，我建议您在根据用例索引任何文档之前定义一个映射设置，以节省空间和提高编写速度。</p><p id="4771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是<code class="fe lv lw lx ly b">Text</code>和<code class="fe lv lw lx ly b">Keyword</code>类型的映射设置的例子，注意我将使用一个名为“text-vs-keyword”的索引，这是我之前为这个例子创建的。</p><p id="23d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键字映射</strong></p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ed97" class="nh mh it ly b gy ni nj l nk nl">curl --request PUT \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_mapping" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_mapping</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "properties": {<br/>  "keyword_field": {<br/>   "type": "keyword"<br/>  }<br/> }<br/>}'</span></pre><p id="5fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文本映射</strong></p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="116c" class="nh mh it ly b gy ni nj l nk nl">curl --request PUT \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_mapping" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_mapping</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "properties": {<br/>  "text_field": {<br/>   "type": "text"<br/>  }<br/> }<br/>}'</span></pre><p id="7179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多领域</strong></p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a1cb" class="nh mh it ly b gy ni nj l nk nl">curl --request PUT \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_mapping" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_mapping</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "properties": {<br/>  "text_and_keyword_mapping": {<br/>   "type": "text",<br/>   "fields": {<br/>    "keyword_type": {<br/>     "type":"keyword"<br/>    }<br/>   }<br/>  }<br/> }<br/>}'</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="abd6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">它们是如何工作的</h1><p id="6584" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在倒排索引中，这两种字段类型的索引是不同的。索引过程的不同会影响你对Elasticsearch的查询。</p><p id="a359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们为一个文档编制索引:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e5d2" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc</a>/example \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "keyword_field":"The quick brown fox jumps over the lazy dog",<br/> "text_field":"The quick brown fox jumps over the lazy dog"<br/>}'</span></pre><p id="98e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行了上面的<code class="fe lv lw lx ly b">curl</code>命令之后，如果您得到了索引中的所有文档，那么您应该得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f2c8" class="nh mh it ly b gy ni nj l nk nl">[<br/>      {<br/>        "_index": "text-vs-keyword",<br/>        "_type": "_doc",<br/>        "_id": "example",<br/>        "_score": 1.0,<br/>        "_source": {<br/>          "keyword_field": "The quick brown fox jumps over the lazy dog",<br/>          "text_field": "The quick brown fox jumps over the lazy dog"<br/>        }<br/>      }<br/>    ]</span></pre><h2 id="8db4" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">关键字</h2><p id="9345" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">先说简单一点的，<code class="fe lv lw lx ly b">Keyword</code>。Elasticsearch不会分析<code class="fe lv lw lx ly b">Keyword</code>数据类型，这意味着您索引的字符串将保持原样。</p><p id="1b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，在上面的例子中，字符串在倒排索引中会是什么样子呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/54e6e47cdf68650bf5eca94e8fcc0ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*qfZMzJQSKm92K7Qv1eoYew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">倒排索引中的关键字示例</p></figure><p id="692d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你说得对，这和你写的完全一样。</p><h2 id="81d4" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">文本</h2><p id="14cd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与<code class="fe lv lw lx ly b">Keyword</code>字段数据类型不同，索引到Elasticsearch的字符串在存储到倒排索引之前将经过分析器处理。默认情况下，Elasticsearch的标准分析器会拆分并降低我们索引的字符串。您可以在<a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/analysis-standard-analyzer.html" rel="noopener ugc nofollow" target="_blank"> Elasticsearch的文档</a>中了解更多关于标准分析仪的信息。</p><p id="52d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch有一个API来检查文本在分析过程后的样子，我们可以用它来试试:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8a69" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_analyze" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_analyze</a>?pretty \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/>  "analyzer": "standard",<br/>  "text": "The quick brown fox jumps over the lazy dog"<br/>}'</span></pre><p id="3333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，根据上面的响应，这是倒排索引对于<code class="fe lv lw lx ly b">text_field</code>字段的外观</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/412b18f32995218b5a44fcdcee1e4cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*FPaGUHkqqbWLAqzJMA8JMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">倒排索引中的示例文本</p></figure><p id="b318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe lv lw lx ly b">keyword</code>的只有一点点不同，对吗？但是您需要注意它在倒排索引中存储了什么，因为它将主要影响查询过程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1643" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">查询文本和关键字</h1><p id="c126" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经了解了<code class="fe lv lw lx ly b">text</code>和<code class="fe lv lw lx ly b">keyword</code>在被索引时的行为，让我们了解一下它们在被查询时的行为。</p><p id="de0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须知道有两种类型的字符串查询:</p><ul class=""><li id="ddf7" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">匹配查询</li><li id="e1bd" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">术语查询</li></ul><p id="bf56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">Text</code>和<code class="fe lv lw lx ly b">Keyword</code>相同，<code class="fe lv lw lx ly b">Match Query</code>和<code class="fe lv lw lx ly b">Term Query</code>的区别在于<code class="fe lv lw lx ly b">Match Query</code>中的查询会先被分析成术语，而<code class="fe lv lw lx ly b">Term Query</code>中的查询不会。</p><p id="7c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询Elasticsearch的工作原理是将被查询的词与倒排索引中的词进行匹配，被查询的词和倒排索引中的词必须完全相同，否则将无法匹配。这意味着索引和查询结果中经过分析的字符串和未经分析的字符串将产生非常不同的结果。</p><h2 id="93f1" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">使用术语查询来查询关键字字段</h2><p id="968b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">因为字段数据类型和查询都不会被分析，所以它们需要完全相同才能产生结果。</p><p id="8e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试完全相同的查询:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="84dc" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?size=0'" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?size=0'</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "term": {<br/>   "keyword_field": "The quick brown fox jumps over the lazy dog"<br/>  }<br/> }<br/>}'</span></pre><p id="a813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch将返回一个结果:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="613d" class="nh mh it ly b gy ni nj l nk nl">{<br/>        "_index": "text-vs-keyword",<br/>        "_type": "_doc",<br/>        "_id": "example",<br/>        "_score": 0.2876821,<br/>        "_source": {<br/>          "keyword_field": "The quick brown fox jumps over the lazy dog",<br/>          "text_field": "The quick brown fox jumps over the lazy dog"<br/>        }<br/>      }<br/>}</span></pre><p id="cf94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试一些不精确的东西，即使在倒排索引中有这个词:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a584" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?size=0'" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?size=0'</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "term": {<br/>   "keyword_field": "The"<br/>  }<br/> }<br/>}'</span></pre><p id="4d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它没有返回任何结果，因为查询中的术语与倒排索引中的任何术语都不匹配。</p><h2 id="4667" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">使用匹配查询查询关键字字段</h2><p id="b272" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们首先尝试用<code class="fe lv lw lx ly b">Match Query</code>到<code class="fe lv lw lx ly b">keyword_mapping</code>查询相同的字符串“快速的棕色狐狸跳过懒惰的狗”,看看会发生什么:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7a69" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "match": {<br/>   "keyword_field": "The quick brown fox jumps over the lazy dog"<br/>  }<br/> }<br/>}'</span></pre><p id="7b2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果应该是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="79a0" class="nh mh it ly b gy ni nj l nk nl">{<br/> "_index": "text-vs-keyword",<br/> "_type": "_doc",<br/> "_id": "example",<br/> "_score": 0.2876821,<br/> "_source": {<br/>  "keyword_field": "The quick brown fox jumps over the lazy dog",<br/>  "text_field": "The quick brown fox jumps over the lazy dog"<br/> }<br/>}</span></pre><p id="4e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，它不应该产生任何结果，因为分析查询产生的术语与倒排索引中的“快速的棕色狐狸跳过懒惰的狗”不完全匹配，但是为什么它会产生结果呢？</p><p id="ba73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错，分析查询是因为我们使用了<code class="fe lv lw lx ly b">Match Query</code>，但是Elasticsearch使用了<code class="fe lv lw lx ly b">index-time</code>分析器，它被映射到<code class="fe lv lw lx ly b">Keyword</code>字段数据类型，而不是标准分析器。由于使用<code class="fe lv lw lx ly b">Keyword</code>字段数据类型映射的分析器是术语分析器，因此Elasticsearch在查询中没有改变任何内容。</p><p id="ef81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们用一个标准分析仪来试试:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2277" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url <a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "match": {<br/>   "keyword_field": {<br/>    "query": "The quick brown fox jumps over the lazy dog",<br/>    "analyzer":"standard"<br/>   }<br/>  }<br/> }<br/>}'</span></pre><p id="b150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不会产生任何结果，因为它是按术语分析查询的，而且没有与倒排索引中的术语完全匹配的术语。</p><h2 id="3c59" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">使用术语查询查询文本类型</h2><p id="9f5f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">文本类型的索引文档将有许多术语，正如我们在上一节中看到的。为了展示查询如何与倒排索引中的术语匹配，让我们尝试两个查询，第一个查询将整个句子发送给Elasticsearch</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3bad" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?pretty='" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?pretty='</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "term": {<br/>   "text_field": "The quick brown fox jumps over the lazy dog"<br/>  }<br/> }<br/>}'</span></pre><p id="90b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个只有“这个”</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c5ea" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?pretty='" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?pretty='</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "term": {<br/>   "text_field": "The"<br/>  }<br/> }<br/>}'</span></pre><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个查询都没有结果。</p><p id="8c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个查询没有产生结果，因为在倒排索引中，我们从来没有存储整个句子，索引过程只存储已经从文本中分块的术语。</p><p id="55b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个查询也没有结果。在索引的文档中有一个“the ”,但是记住分析器是小写的，所以在倒排索引中，它被存储为“The”</p><p id="4d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用“the”再次尝试术语查询:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cfba" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?pretty='" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?pretty='</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "term": {<br/>   "text_field": "the"<br/>  }<br/> }<br/>}'</span></pre><p id="7718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错。它产生一个结果，因为查询的“the”与倒排索引中的“the”完全匹配。</p><h2 id="c76f" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">使用匹配查询查询文本类型</h2><p id="5ab7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在是用<code class="fe lv lw lx ly b">Match Query</code>输入文本的时候了，因为它分析了两种类型，所以很容易让它们产生结果。让我们先尝试两个查询</p><p id="d2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个查询将把“The”发送给Elasticsearch，我们知道使用<code class="fe lv lw lx ly b">term query</code>不会产生任何结果，但是<code class="fe lv lw lx ly b">match query</code>呢？</p><p id="52f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个查询将发送“LAZ狗绊倒了快速的棕色狗”，一些单词在倒排索引中，一些没有，弹性搜索会从中产生任何结果吗？</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9aa1" class="nh mh it ly b gy ni nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?pretty='" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?pretty='</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "match": {<br/>   "text_field": "The"<br/>  }<br/> }<br/>}'</span><span id="ff32" class="nh mh it ly b gy on nj l nk nl">curl --request POST \<br/>  --url '<a class="ae ky" href="http://localhost:9200/text-vs-keyword/_doc/_search?pretty='" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/text-vs-keyword/_doc/_search?pretty='</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/> "query": {<br/>  "match": {<br/>   "text_field": "the LAZ dog tripped over th QUICK brown dog"<br/>  }<br/> }<br/>}'</span></pre><p id="74ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错。他们俩都产生了一个结果</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fc5f" class="nh mh it ly b gy ni nj l nk nl">{<br/>        "_index": "text-vs-keyword",<br/>        "_type": "_doc",<br/>        "_id": "example",<br/>        "_score": 0.39556286,<br/>        "_source": {<br/>          "keyword_field": "The quick brown fox jumps over the lazy dog",<br/>          "text_field": "The quick brown fox jumps over the lazy dog"<br/>        }<br/>      }</span></pre><p id="f96b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个查询产生了一个结果，因为查询中的“the”经过分析后变成了与倒排索引中的“The”完全匹配的“The”。</p><p id="5a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个查询虽然不是所有的术语都在倒排索引中，但仍然会产生一个结果。Elasticsearch将返回一个结果，即使查询的术语中只有一个与倒排索引中的术语完全匹配。</p><p id="3a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意结果，有一个<code class="fe lv lw lx ly b">_score</code>字段。查询中有多少项与倒排索引中的项完全匹配是影响分数的因素之一，但是让我们把计算分数的工作留到以后再说。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d90f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">何时使用一个或另一个</h1><p id="026f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">keyword</code>字段数据类型，如果:</p><ul class=""><li id="c605" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">您想要精确匹配查询</li><li id="e195" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">你想让Elasticsearch像其他数据库一样工作</li><li id="f759" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">您希望将它用于通配符查询</li></ul><p id="af93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下使用文本字段数据类型:</p><ul class=""><li id="4bc6" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">您想创建一个自动完成功能</li><li id="6ea1" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">你想创建一个搜索系统</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6e59" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="3db6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">理解<code class="fe lv lw lx ly b">text</code>和<code class="fe lv lw lx ly b">keyword</code>字段数据类型是如何工作的，这是你在Elasticsearch中想要学习的东西之一，区别看起来很简单，但却很重要。</p><p id="3570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要了解并选择适合您的用例的字段数据类型，如果您需要两种字段数据类型，则可以在创建映射时使用多字段功能。</p><p id="646f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我希望这篇文章能帮助你学习Elasticsearch，理解Elasticsearch中文本和关键字字段数据类型的区别。感谢阅读！</p></div></div>    
</body>
</html>