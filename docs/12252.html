<html>
<head>
<title>My First CRUD App With Fast API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个带有快速API的CRUD应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-first-crud-app-with-fast-api-74ac190d2dcc?source=collection_archive---------0-----------------------#2022-05-23">https://betterprogramming.pub/my-first-crud-app-with-fast-api-74ac190d2dcc?source=collection_archive---------0-----------------------#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c86a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">循序渐进的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4058e8feadd7d764fc4dc9f1d6a89c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKVqR6YKg8m02e4hWnbc3Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="40e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是我fast API直播的前一天。我决定为这个流创建一个指南，并把它变成一篇博文。所以，在这里。</p><p id="40ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">流结构:</p><ul class=""><li id="219b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">快速API vs Django</li><li id="2eca" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">装置</li><li id="8d75" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">创建第一个应用程序和路线</li><li id="3151" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Swagger UI</li><li id="654d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">路径参数</li><li id="a7de" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">发布、上传和删除请求</li><li id="ad19" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据库和模型</li><li id="4f87" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">带有新数据库的CRUD</li></ul><h1 id="9a30" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">快速API vs. Django</h1><p id="37a4" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">很多人可能知道我是姜戈。毕竟，我的频道充斥着Django项目和课程。上周我去了加州北部的沙斯塔湖，像往常一样，我厌倦了太多空闲时间，所以我决定学点新东西。</p><p id="837a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我一次又一次地被问到我对新框架的看法，以及它与Django相比如何，直到现在，我一直保持沉默，因为，嗯，我对它了解不多。</p><p id="d5bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个星期后，我仍然不太了解它，但我已经学会了如何创建一个简单的CRUD应用程序，并开始形成自己的观点。老实说，这种观点并不固定，随着我越来越多地使用fast API，它会发生变化。</p><p id="996f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我截至2022年5月22日的结论。Django仍然是更强大的框架，也将是我的首选。尽管快速API很酷。对我来说，fast API真正突出的一个方面是对异步的支持，并且不必不断地序列化我的数据。老实说，我讨厌为了呈现一个简单的对象或列表而必须序列化数据。</p><p id="3ed1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快速API设置起来既快又容易，但你最终会为此付出代价。这就是为什么我通常不喜欢Flask和Fast API这样的轻量级框架。Django给了我一个易于配置的数据库、ORM、认证等等。</p><p id="6e68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，我的意见说够了。让我们从指南开始吧。</p><h1 id="4177" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">装置</h1><p id="229e" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我可能已经假设了这一点，但是如果您还没有，请确保您的机器上已经安装了Python。快速API需要Python 3.6及更高版本。</p><p id="a418" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦安装了Python，就可以用一个简单的pip命令来安装Fast API</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6995" class="nh mg iq nd b gy ni nj l nk nl">pip install fastapi</span></pre><h1 id="d04e" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">创建第一个应用程序和路线</h1><p id="d5f5" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">让我们首先创建一个简单的应用程序和route，它以JSON数据的形式返回一个项目列表。</p><p id="8dfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要创建您的第一个项目，只需在您的计算机上创建一个新文件夹。我将它添加到我的桌面上，并将其命名为<code class="fe nm nn no nd b">myapi</code>。</p><p id="a4f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用您选择的文本编辑器(对我来说是VS代码)打开这个文件夹，创建一个名为<code class="fe nm nn no nd b">main.py</code>的文件。这将是把我们的应用程序联系在一起的主要文件。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="a189" class="nh mg iq nd b gy ni nj l nk nl">myapi<br/>   main.py</span></pre><p id="628c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nm nn no nd b">main.py</code>文件中，首先导入FastAPI类，设置app变量，并创建您的第一条路线。下面是实现这一点的代码:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="522e" class="nh mg iq nd b gy ni nj l nk nl">#main.py<br/>from fastapi import FastAPI</span><span id="ac36" class="nh mg iq nd b gy np nj l nk nl">app = FastAPI()</span><span id="38f8" class="nh mg iq nd b gy np nj l nk nl">@app.get("/")<br/>def getItems():<br/>    return ['Item 1', 'Item 2', 'Item 3']</span></pre><p id="b85b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为了看到这个输出，让我们安装uvicorn，它是一个ASGI服务器。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="fd26" class="nh mg iq nd b gy ni nj l nk nl">pip install uvicorn</span></pre><p id="2528" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，要运行服务器，请确保您在项目根目录中，并运行以下命令:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="044e" class="nh mg iq nd b gy ni nj l nk nl">uvicorn main:app --reload</span><span id="d4b4" class="nh mg iq nd b gy np nj l nk nl">#Output<br/>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)<br/>INFO:     Started reloader process [28720]<br/>INFO:     Started server process [28722]<br/>INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.</span></pre><p id="9793" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">main</code>是文件名，<code class="fe nm nn no nd b">app</code>是我们的应用程序变量的名称，<code class="fe nm nn no nd b">— reload</code>将在我们对代码进行更改时重启我们的服务器，并且只应用于开发中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/13c35b072ab9a794f366a94f116c06c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aEwIVO1nFQ6r37_d896rlw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作为JSON数据的FastAPI输出列表</p></figure><h1 id="b3ed" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">Swagger UI</h1><p id="2dea" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">Fast API提供了一个由<a class="ae nr" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> swagger UI </a>带给我们的交互式API。我就不解释swagger UI了，如果你想看的话，我会提供一个链接，但是相信我，这很酷。</p><p id="8e19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要查看它的运行情况，请将<code class="fe nm nn no nd b">/docs#</code>添加到我们为第一条路线设置的URL的末尾。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="244a" class="nh mg iq nd b gy ni nj l nk nl"><a class="ae nr" href="http://127.0.0.1:8000/docs#" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/docs#</a></span></pre><p id="6b05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将为您提供一个很酷的用户界面，这样您就可以与您的API进行交互，并获得更多的信息，而不仅仅是一些数据。这将列出您添加的所有路线。</p><p id="2af9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要进行测试，请单击当前可用的路线，然后单击“尝试”，然后单击“执行”</p><p id="4a68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您将看到数据的格式如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/52abcd3af59828a275bd716bf7f9f8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTo5mQ09ceJqIOaW4Jtkvg.png"/></div></div></figure><p id="a15f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在进入下一节之前，让我们创建一个表示数据库的对象。我们最终将开始使用SQLite数据库，但这将使我们在以后前进之前更容易开始。</p><p id="001f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的第一条路线上方创建这个对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/27e87654fe513dbe4a9c68008b7af9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*VQmUGXTfDNQlRiyOtPsLrQ.png"/></div></figure><p id="7c32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并在第一条路线中呈现项目:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9b71813f5994a64519fb4ef21397fd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*V1wbry7mXKADgHiqyIIVDg.png"/></div></figure><h1 id="93b9" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">路径参数</h1><p id="dd8d" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">接下来，我想创建一些动态路由来从数据库中检索特定的对象。为此，我们将创建一个带有路径参数的新路由，然后在视图函数中指定我们需要的参数类型。</p><p id="650b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这实际上非常简单，使用下面的代码:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8519" class="nh mg iq nd b gy ni nj l nk nl">@app.get("/{id}")<br/>def getItem(id:int):<br/>    return fakeDatabase[id]</span></pre><p id="d3bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该路由期望一个整数作为<code class="fe nm nn no nd b">id</code>值的路径参数。然后，我们将获取该参数并查询具有该特定id的项目。测试时，确保使用数据库中存在的id。</p><p id="42f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是输出结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/aa33eac9561da59f18eb2c9c6e14904b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpDpnL5f50n6D7fd-T8FqQ.png"/></div></div></figure><h1 id="a288" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">发布、放置和删除请求</h1><p id="5ff1" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">是时候发送一些<code class="fe nm nn no nd b">POST</code>、<code class="fe nm nn no nd b">PUT</code>和<code class="fe nm nn no nd b">DELETE</code>请求了，这样我们就可以修改我们的假数据库了。</p><p id="d4aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单回顾一下，POST请求用于添加数据，PUT请求通常用于更新数据，DELETE请求用于删除数据。</p><p id="de55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从我们向数据库添加新条目的POST请求开始，我们有几种方法可以做到这一点，所以我将测试三个选项。</p><p id="87dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们需要创建的路线。下面我来分解一下。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="512d" class="nh mg iq nd b gy ni nj l nk nl">#Option # 1<br/>@app.post("/")<br/>def addItem(task:str):<br/>    newId = len(fakeDatabase.keys()) + 1<br/>    fakeDatabase[newId] = {"task":task}<br/>    return fakeDatabase</span></pre><p id="59e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将在“文档”用户界面中看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/44cf042637687bf01011c84906184d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oy0mA0k820WJWtGIbMrKwg.png"/></div></div></figure><p id="9ab0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">app.post</code> —我们将此路由的HTTP请求类型指定为post请求。</p><p id="176c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">/</code> —这是与<code class="fe nm nn no nd b">getItems</code>相同的路线。<code class="fe nm nn no nd b">addItems</code>将处理所有发送到这里的post请求，而<code class="fe nm nn no nd b">getItems</code>将处理所有get请求。</p><p id="37e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数参数——在函数中，我们指定请求体中有一个<code class="fe nm nn no nd b">task</code>,数据类型必须是字符串。</p><p id="e313" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们明确指定所需的参数时，这将在docs UI中反映为一个表单字段，如上图所示。很整洁，是吧？</p><p id="d3a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，假设我们需要在请求体中发送多个值。我们可以将每个字段作为参数添加到函数中，但这会变得非常混乱。</p><p id="ba49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下这样的情况:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e2ab" class="nh mg iq nd b gy ni nj l nk nl">addItem(“task”:str, “priority”:”str”, “rank”:int, ..........)</span></pre><p id="2083" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能会永远持续下去，变得一团糟！</p><p id="2459" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将使用pydantic来设计我们的数据方案，并简单地传入一个指定所需数据的对象。这样会让事情干净很多。</p><p id="89ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们将首先安装pydantic，然后创建一个名为<code class="fe nm nn no nd b">schemas.py</code>的新文件，并添加以下代码:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6164" class="nh mg iq nd b gy ni nj l nk nl">pip install pydantic</span></pre><p id="7241" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建<code class="fe nm nn no nd b">schemas.py</code>文件</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="f6fa" class="nh mg iq nd b gy ni nj l nk nl">myapi<br/>   main.py<br/>   schemas.py</span></pre><p id="cecc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">schemas.py</code></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2166" class="nh mg iq nd b gy ni nj l nk nl">from pydantic import BaseModel</span><span id="80a6" class="nh mg iq nd b gy np nj l nk nl">class Item(BaseModel):<br/>    task: str</span></pre><p id="0d9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们将把我们的模式导入到我们的<code class="fe nm nn no nd b">main.py</code>文件中，并更新我们的addItem route，如下所示。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="047a" class="nh mg iq nd b gy ni nj l nk nl">from fastapi import FastAPI<br/>import schemas</span><span id="7658" class="nh mg iq nd b gy np nj l nk nl">…………</span><span id="9d98" class="nh mg iq nd b gy np nj l nk nl">#Option # 2<br/>@app.post("/")<br/>def addItem(item:schemas.Item):<br/>    newId = len(fakeDatabase.keys()) + 1<br/>    fakeDatabase[newId] = {"task":item.task}<br/>    return fakeDatabase</span></pre><p id="07cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的文档的用户界面应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/6c46231421737888c25e5943b24be900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDBiWFfcHOCVZ0-cp4KkCw.png"/></div></div></figure><p id="4d5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好的，选项1和2工作得很好，但是你们中的一些人可能不知道要立即发送什么数据，或者你们可能只是想访问发送的整个请求体，并根据需要提取每个项目。我将向您展示如何做为选项3。</p><p id="54a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，我们将修改addItem路由，但这次我们需要从<code class="fe nm nn no nd b">main.py</code>中的Fast API导入<code class="fe nm nn no nd b">Body</code></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9f7a" class="nh mg iq nd b gy ni nj l nk nl">from fastapi import FastAPI, Body</span></pre><p id="f710" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将使用<code class="fe nm nn no nd b">Body</code>类，并将其作为参数添加到我们的路由中。一旦我们将其作为参数添加，我们就可以将请求体作为字典来访问，并提取出<code class="fe nm nn no nd b">task</code>的值。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9086" class="nh mg iq nd b gy ni nj l nk nl">#Option #3<br/>@app.post("/")<br/>def addItem(body = Body()):<br/>   newId = len(fakeDatabase.keys()) + 1<br/>   fakeDatabase[newId] = {"task":body['task']}<br/>   return fakeDatabase</span></pre><p id="e2f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！</p><p id="f02a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法的缺点是不能在docs UI中指定字段。您将看到的只是一个字符串值，因此您必须自己创建整个请求正文。老实说，这不是什么大问题，因为你通常必须在前端创建请求体，但这是需要考虑的事情。此外，确保您使用的是双引号，而不是单引号。这将确保字符串能够在接收端被解析。</p><h1 id="b185" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">更新数据</h1><p id="f944" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在<code class="fe nm nn no nd b">main.py</code>中，我们添加以下更新数据的路径:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="b0a6" class="nh mg iq nd b gy ni nj l nk nl">@app.put("/{id}")<br/>def updateItem(id:int, item:schemas.Item):<br/>    fakeDatabase[id]['task'] = item.task <br/>    return fakeDatabase</span></pre><p id="784a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用与<code class="fe nm nn no nd b">getItem</code>相同的URL路径，但是这个路由将专门处理<code class="fe nm nn no nd b">put</code>请求。您可以使用我们用于post请求的三个选项之一。在我的例子中，我决定走pydantic路线(选项2)。</p><h1 id="76df" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">删除数据</h1><p id="35dc" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">让我们再添加一条路由，这条路由将处理发送到<code class="fe nm nn no nd b">/{id}</code>的删除请求。我们需要的唯一参数是<code class="fe nm nn no nd b">id</code>,因为我们所做的就是找到我们需要的商品并将其从数据库中删除。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="b973" class="nh mg iq nd b gy ni nj l nk nl">@app.delete("/{id}")<br/>def deleteItem(id:int):<br/>    del fakeDatabase[id]<br/>    return fakeDatabase</span></pre><h1 id="88bc" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">数据库和模型</h1><p id="7925" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">好了，我们完成了占位符数据库。是时候建立真正的联系，建立我们的<code class="fe nm nn no nd b">models</code>档案了。在这个例子中，我们将使用SQLite作为我们的数据库。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9f63" class="nh mg iq nd b gy ni nj l nk nl">pip install sqlalchemy</span></pre><p id="2dca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们首先添加一个<code class="fe nm nn no nd b">database.py</code>文件来建立连接，然后在新文件中添加以下代码。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="696d" class="nh mg iq nd b gy ni nj l nk nl">myapi<br/>   main.py<br/>   schemas.py<br/>   database.py</span></pre><p id="1085" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">database.py</code></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="86de" class="nh mg iq nd b gy ni nj l nk nl">from sqlalchemy import create_engine<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy.orm import sessionmaker</span><span id="085f" class="nh mg iq nd b gy np nj l nk nl">#Create sqlite engine instance<br/>engine = create_engine("sqlite:///todo.db")</span><span id="a7c4" class="nh mg iq nd b gy np nj l nk nl">#Create declaritive base meta instance<br/>Base = declarative_base()</span><span id="2c2b" class="nh mg iq nd b gy np nj l nk nl">#Create session local class for session maker<br/>SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)</span></pre><p id="4679" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们配置了数据库连接，我们将需要创建数据库模型来表示我们的db表。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="66bf" class="nh mg iq nd b gy ni nj l nk nl">myapi<br/>   main.py<br/>   schemas.py<br/>   database.py<br/>   models.py</span></pre><p id="811c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nm nn no nd b">models.py</code></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1dc3" class="nh mg iq nd b gy ni nj l nk nl">from sqlalchemy import Column, Integer, String<br/>from database import Base</span><span id="5d2b" class="nh mg iq nd b gy np nj l nk nl">class Item(Base):<br/>    __tablename__ = 'items'<br/>    id = Column(Integer, primary_key=True)<br/>    task = Column(String(256))</span></pre><p id="83b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们在<code class="fe nm nn no nd b">main.py</code>中初始化数据库，这样我们就可以开始使用它了。</p><p id="0c6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nr" href="https://gist.github.com/BetterProgramming/83edee29166269f0e622f81ca85e6a1f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/better programming/83 edee 29166269 f0e 622 f 81 ca 85 E6 a1f</a></p><h1 id="4a53" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">使用我们的数据库</h1><p id="d329" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">好，让我们进行第一次数据库查询。</p><p id="5a0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们更新我们的<code class="fe nm nn no nd b">getItems</code>视图，查询我们数据库中的所有条目，如下所示:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0073" class="nh mg iq nd b gy ni nj l nk nl">@app.get("/")<br/>def getItems(session: Session = Depends(get_session)):<br/>    items = session.query(models.Item).all()<br/>    return items</span></pre><p id="32e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将以JSON列表的形式返回所有项目。此时，我们没有任何条目，所以让我们通过更新我们的<code class="fe nm nn no nd b">addItem</code>视图来改变这一点。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="c5f8" class="nh mg iq nd b gy ni nj l nk nl">@app.post("/")<br/>def addItem(item:schemas.Item, session = Depends(get_session)):<br/>    item = models.Item(task = item.task)<br/>    session.add(item)<br/>    session.commit()<br/>    session.refresh(item)<br/>    return item</span></pre><p id="e716" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在检索单个项目。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="fb34" class="nh mg iq nd b gy ni nj l nk nl">@app.get("/{id}")<br/>def getItem(id:int, session: Session = Depends(get_session)):<br/>    item = session.query(models.Item).get(id)<br/>    return item</span></pre><p id="6e6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和更新项目。S</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1099" class="nh mg iq nd b gy ni nj l nk nl">@app.put("/{id}")<br/>def updateItem(id:int, item:schemas.Item, session = Depends(get_session)):<br/>    itemObject = session.query(models.Item).get(id)<br/>    itemObject.task = item.task<br/>    session.commit()<br/>    return itemObject</span></pre><p id="dbbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，删除一个项目。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="cec4" class="nh mg iq nd b gy ni nj l nk nl">@app.delete("/{id}")<br/>def deleteItem(id:int, session = Depends(get_session)):<br/>    itemObject = session.query(models.Item).get(id)<br/>    session.delete(itemObject)<br/>    session.commit()<br/>    session.close()<br/>    return 'Item was deleted'</span></pre><p id="60ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，就这样吧！</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="9aa0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae nr" href="https://github.com/divanov11/Fast-API-CRUD-App-Live-Stream-Code" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码或者在这里观看视频:<a class="ae nr" href="https://www.youtube.com/watch?v=FOZNYBu8u18" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=FOZNYBu8u18</a></p></div></div>    
</body>
</html>