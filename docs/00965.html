<html>
<head>
<title>A Brief Introduction to Closures and Lexical Scoping in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中闭包和词法范围的简要介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-brief-introduction-to-closures-and-lexical-scoping-in-javascript-8a5866496232?source=collection_archive---------2-----------------------#2019-08-01">https://betterprogramming.pub/a-brief-introduction-to-closures-and-lexical-scoping-in-javascript-8a5866496232?source=collection_archive---------2-----------------------#2019-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ce6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“用ECMAScript语言编写而不理解闭包，就像编写Java而不理解类一样”——道格拉斯·克洛克福特，JSON之父</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cab8d808061a8e50c224cb8e20a305cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckWxE4b3zxi1bgZoJFFxOw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/search/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="90f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论JavaScript中的闭包和词法范围。理解闭包有助于更好地理解编程本身。如果你打算成为一名职业程序员，关于闭包及其应用的问题会在技术面试中被广泛问到，并且会对你很有帮助。</p><p id="7c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是一名JavaScript开发人员，很可能您已经在使用闭包，只是不知道而已。有太多复杂的例子让你在学习闭包时感到困惑，所以我将使用我能找到的最简单的例子，到本文结束时，你应该对什么是闭包有了基本的理解。让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9330" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">词法范围</h1><p id="063d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在讨论闭包之前，我们应该对作用域和词法作用域有一个基本的了解。JavaScript具有带函数作用域的词法作用域，这意味着每个函数创建一个新的作用域。</p><blockquote class="mz"><p id="931e" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">什么是函数作用域？</p></blockquote><p id="7898" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">基本上，在JavaScript中，有全局范围和局部范围。</p><blockquote class="no np nq"><p id="8e13" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated"><strong class="lb iu">全局作用域</strong>:一个Javascript文档中只有一个全局作用域，即所有函数之外的区域，你如何识别全局作用域就是定义在全局作用域中的变量可以在代码中的任何地方被访问。</p><p id="a25f" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated"><strong class="lb iu">局部作用域</strong>:在函数内部声明的变量是函数的局部变量，并且被绑定到相应的局部作用域。这些变量不能在函数之外访问。</p></blockquote><p id="6bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全球和本地范围</p></figure><p id="a1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe nx ny nz oa b">iHaveGlobalScope</code> <strong class="lb iu"> </strong>是在全局范围内声明的，因此甚至可以从函数<code class="fe nx ny nz oa b">localScope()</code>内访问，但是当我试图在函数外或局部范围外控制台记录变量<code class="fe nx ny nz oa b">iHaveLocalScope</code>时，它在运行时抛出一个<code class="fe nx ny nz oa b">Reference Error</code>。</p><p id="caac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">局部作用域可以进一步分为函数作用域和块作用域。ES6引入了块范围的概念，以及声明变量的新方法— <code class="fe nx ny nz oa b">const</code>和<code class="fe nx ny nz oa b">let</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8735" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">功能范围和块范围</strong></h1><p id="7ef5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当你在函数内部声明一个变量，这个变量就被绑定在函数内部，你不能在函数外部访问它。<code class="fe nx ny nz oa b">var</code>是定义函数范围可访问性变量的关键字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能会问，如果即使你使用<code class="fe nx ny nz oa b">let</code>或<code class="fe nx ny nz oa b">const</code>它也会给出一个错误，为什么只有<code class="fe nx ny nz oa b">var</code>与函数作用域相关联？事情是这样的，<strong class="lb iu"> </strong> <code class="fe nx ny nz oa b">let</code>和<code class="fe nx ny nz oa b">const</code>是用来定义块范围的，而在ES6之前，JavaScript没有块范围或者<strong class="lb iu"> </strong> <code class="fe nx ny nz oa b">let</code> <strong class="lb iu"> </strong>和<code class="fe nx ny nz oa b">const</code>。</p><blockquote class="no np nq"><p id="f89a" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">块范围是在<code class="fe nx ny nz oa b">if</code>、<code class="fe nx ny nz oa b">switch</code>条件或<code class="fe nx ny nz oa b">for</code>和<code class="fe nx ny nz oa b">while</code>循环内的区域。简单来说，只要看到{花括号}，就是块。</p></blockquote><p id="9754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可能认为日志命令都不应该工作，但是正如您所看到的那样，var的情况并非如此，在<code class="fe nx ny nz oa b">if</code>、<code class="fe nx ny nz oa b">switch</code>条件或<code class="fe nx ny nz oa b">for</code>和<code class="fe nx ny nz oa b">while</code>循环中用var定义的变量可以被全局访问，并且是全局作用域的一部分，因此最好将<code class="fe nx ny nz oa b">let</code>和<code class="fe nx ny nz oa b">const</code>与它们一起使用。</p><h2 id="5584" class="ob md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated"><strong class="ak">词法范围</strong></h2><p id="4bcd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我们达到了这篇文章的真正目的。好吧，我可以跳过关于作用域的冗长讨论，但就我个人而言，我认为如果不知道围绕它的关键组件，你就无法理解词法作用域。</p><p id="decf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次强调，需要记住的一点是:Javascript的词法作用域是函数作用域。</p><p id="7c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这意味着子作用域可以访问父作用域中定义的变量。例如，如果我要定义一个函数，并在其中声明一个变量，在同一个函数中，定义另一个函数，那么由于词法范围，我应该能够在内部函数中使用该变量。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从例子中可以看出，<strong class="lb iu"> <em class="nr"> </em> </strong> <code class="fe nx ny nz oa b">outerFunction()</code>中声明的变量被<code class="fe nx ny nz oa b">innerfunction()</code>访问，这就是词法作用域。</p><p id="f347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量的范围由它们在代码中的位置定义。为了解析变量，JavaScript从最内部的范围开始向外搜索，直到找到它要寻找的变量。在上面的例子中，Javascript首先在<code class="fe nx ny nz oa b">innerFunction()</code> <strong class="lb iu"> <em class="nr"> </em> </strong>内搜索变量，如果没有找到，它就在<code class="fe nx ny nz oa b">outerFunction()</code>外搜索</p><p id="25e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">词法作用域更好，因为我们可以很容易地从代码中计算出变量的值，而在动态作用域中，变量的含义可以在运行时改变，这使得理解起来很复杂。</p><p id="e22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们已经成功地理解了什么是词法范围，现在让我们看看闭包实际上使用了词法范围。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> Mozilla开发网络(MDN) </a>:</p><blockquote class="no np nq"><p id="21dc" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">闭包是一种特殊的对象，它结合了两件事:一个函数，以及创建该函数的环境。环境由创建闭包时范围内的所有局部变量组成。”</p></blockquote><p id="6913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从一个简单的例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的要点认为是<code class="fe nx ny nz oa b">outerFunction()</code>返回<code class="fe nx ny nz oa b">innerFunction()</code>，所以<strong class="lb iu"><em class="nr"/></strong><code class="fe nx ny nz oa b">newFunction()</code><strong class="lb iu"><em class="nr"/></strong>实际上是<strong class="lb iu"> <em class="nr"> </em> </strong> <code class="fe nx ny nz oa b">innerFunction()</code>，但是我们没有返回<code class="fe nx ny nz oa b">variable1</code>。尽管如此，它还是<code class="fe nx ny nz oa b">newFunction()</code>的一部分，所以如果<code class="fe nx ny nz oa b">outerFunction()</code>已经返回，即执行完毕，那么<code class="fe nx ny nz oa b">variable1</code>的值从何而来。</p><blockquote class="no np nq"><p id="1d35" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">这种对直接作用域之外的变量的访问将导致闭包。</p></blockquote><p id="7fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nx ny nz oa b">variable1</code>是创建<code class="fe nx ny nz oa b">innerFunction()</code>的词法环境的一部分，<strong class="lb iu"><em class="nr"/></strong><code class="fe nx ny nz oa b">innerFunction()</code><strong class="lb iu"><em class="nr"/></strong>将可以访问它。</p><p id="453c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="acf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅供参考，这是一个广泛使用的闭包示例，您可能会在许多教程中找到它，这里我们定义了带参数x的函数<code class="fe nx ny nz oa b">add()</code>，它返回另一个带参数y的函数，后者返回x和y的和。</p><p id="6235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们创建新的函数<code class="fe nx ny nz oa b">addFive()</code>和<code class="fe nx ny nz oa b">addTen()</code>，通过在<code class="fe nx ny nz oa b">add()</code> <strong class="lb iu"> <em class="nr"> </em> </strong>函数内部传递参数，这些<strong class="lb iu"> <em class="nr"> </em> </strong> <code class="fe nx ny nz oa b">addTen()</code>和<code class="fe nx ny nz oa b">addFive()</code>实际上是闭包，虽然它们有相同的函数体定义，但是它们存储不同的词法环境。在<code class="fe nx ny nz oa b">addFive()</code>词法环境中，x是5，而在<code class="fe nx ny nz oa b">addTen()</code>词法环境中，x是10。</p><p id="459b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包是编程中非常重要的一部分，不仅在JavaScript中如此，在所有编程语言中都是如此。它们有如此多的实际应用，如对象数据隐私、事件处理程序和回调函数，以及其他函数式编程模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="eac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望现在你已经对JavaScript的作用域有了一个基本的了解，我们已经在这篇文章中简要介绍了词法作用域和闭包。在下一篇文章中，我们将详细讨论闭包及其实际应用，如数据隐私、<code class="fe nx ny nz oa b">call()</code>、<code class="fe nx ny nz oa b">bind()</code>、<code class="fe nx ny nz oa b">apply()</code>、事件处理程序等。通过各种例子。</p></div></div>    
</body>
</html>