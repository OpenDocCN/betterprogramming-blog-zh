<html>
<head>
<title>Build a SwiftUI Animal Crossing Application (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建SwiftUI动物穿越应用程序(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-swiftui-animal-crossing-application-part-1-aaf3528c1df?source=collection_archive---------4-----------------------#2020-05-07">https://betterprogramming.pub/build-a-swiftui-animal-crossing-application-part-1-aaf3528c1df?source=collection_archive---------4-----------------------#2020-05-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9009" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">组合、服务、模型和环境对象</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/29e40ee4e337ee461ba44f57064530bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUocOak5Ptn7gz1VqaSwpQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者照片。</p></figure><p id="c283" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个新的系列文章中，我将指导你完成我最新的<a class="ae lv" href="https://github.com/Dimillian/ACHNBrowserUI" rel="noopener ugc nofollow" target="_blank">开源项目</a>。</p><p id="5d7d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这又是一个完全开源、完全SwiftUI的应用程序。</p><p id="7721" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">而这一次，它甚至可以在App Store上使用！这证明了我的观点，即您可以在生产中使用SwiftUI代码。</p><div class="lw lx gq gs ly lz"><a href="https://apps.apple.com/us/app/ac-helper/id1508764244?ls=1" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">交流助手</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">AC Helper是《动物穿越:新视野》的配套app。你将获得所有你需要的信息来捕捉…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">apps.apple.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="2c29" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但与MovieSwiftUI不同的是，它没有使用Redux架构，而是使用了我过去已经介绍过的SwiftUI内置数据流的核心。如果你需要介绍或复习，你应该阅读<a class="ae lv" href="https://medium.com/better-programming/understanding-swiftui-data-flow-79429a49ae35" rel="noopener">这篇文章</a>。</p><p id="3674" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我使用了视图、视图模型和一些环境对象的组合。通过阅读这一系列文章，您将能够完全掌握一个非常简单而有效的SwiftUI应用程序架构。</p><p id="945a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们从服务和模型层开始，因为为了让应用程序有趣，我们首先需要收集、计算和获取一些数据，放入我们的数据源。我们将使用Combine，这是苹果公司的一个新的(WWDC 19)框架，它允许用户以一种反应的方式漂亮地处理数据。</p><div class="lw lx gq gs ly lz"><a href="https://developer.apple.com/documentation/combine" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">结合</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">Combine框架提供了一个声明性的Swift API，用于随时处理值。这些值可以代表许多…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">developer.apple.com</p></div></div></div></a></div><p id="276b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于不熟悉<em class="mo">动物穿越</em>的人来说，这个游戏就是每天玩一点。游戏使用实时时钟来进行。它是关于收集物品，家具来装饰你的房子和岛屿，还捕捉小动物，鱼，昆虫和化石。那取决于一天中的时间和日期。</p><p id="1b22" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这就是说<em class="mo">动物穿越</em>是制作应用程序的完美游戏，因为它以信息、图像等形式拥有大量数据(超过5000个项目可供分类、显示和玩)。这是一个很好的候选，可以用来制作一个漂亮有趣的应用程序，而不仅仅是一个美化了的REST客户端。</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><h1 id="b1d1" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">结合部分</h1><p id="e710" class="pw-post-body-paragraph kz la iu lb b lc no jv le lf np jy lh li nq lk ll lm nr lo lp lq ns ls lt lu in bi translated">所以先从数据说起。社区做了令人难以置信的工作，直到今天，它仍然在转储、组织和编辑主电子表格。这是一个不可思议的工作，包含了游戏的所有数据。电子表格对于应用程序来说并不方便，所以Nook Plaza的所有者做了一个很棒的管道来将电子表格转换成一个非常简单的JSON API。</p><p id="84b1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后我转储了这个API，并将<a class="ae lv" href="https://github.com/Dimillian/ACHNBrowserUI/tree/master/ACHNBrowserUI/Resources/json" rel="noopener ugc nofollow" target="_blank"> JSON直接放在Xcode </a>项目中。它将允许我们使用Swift的<a class="ae lv" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">可编码</a>协议直接将JSON实例化为本地Swift对象。</p><p id="d570" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，让我们首先创建读取JSON并将其解码为对象的服务:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="5c47" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该函数返回一个发布者，您可以订阅该发布者以获得解码结果。对象的最终类型由该函数的用户来推断。在JSON中处理您需要的任何类型都是通用的。我们只需要知道泛型类型符合<code class="fe nv nw nx ny b">Codable</code>。我们甚至可以指定Decodable，因为我们不需要把它编码回来(目前)。</p><p id="1a96" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果我们阅读联合收割机链，它看起来像这样:</p><ol class=""><li id="5376" class="nz oa iu lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">首先，我们尝试从包资源中获取JSON URL。</li><li id="8006" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">然后我们试着把它读入<code class="fe nv nw nx ny b">Data</code>。</li><li id="d8d0" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">然后我们使用我们的静态<code class="fe nv nw nx ny b">JSONDecoder</code>将对象解码成类型。</li><li id="84ee" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果我们在上面的代码中得到任何错误，我们会将错误发布到一个已知的<code class="fe nv nw nx ny b">APIError</code>类型中，并附上消息。</li><li id="b564" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">最后，我们希望一旦订户开始工作，所有这些都在特定的后台队列中发生。</li></ol><p id="2230" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我认为这看起来比没有联合收割机时要干净得多。即使在这种情况下使用Combine并不完全合理，但这与其说是充分发挥它的潜力，不如说是一次熟悉它的练习。</p><p id="1cbd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在让我们来看一下消费者类别，将使用该服务的前端，以及我们将如何使用它。我们仍将使用Combine，这将是我们的第一个<code class="fe nv nw nx ny b">EnvironmentObject</code>——它存储那些JSON文件中的所有项目(所有解码的对象):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="c4df" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">数据被分成不同的类别，所以我们将在一个枚举中引用它。在应用程序中，这个枚举有很多功能(例如，为用户界面返回正确的标签和图标)。</p><p id="95dd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里也是我们的<code class="fe nv nw nx ny b">Codable</code>对象的摘录，它代表了存储在我们的JSON文件中的内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="b648" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后是<code class="fe nv nw nx ny b">Items</code>类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="a04d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是我们的<code class="fe nv nw nx ny b">Items</code>类，它将按类别存储所有项目。这是一个拥有一处<code class="fe nv nw nx ny b">Published</code>房产的<code class="fe nv nw nx ny b">ObservableObject</code>。SwiftUI视图将能够订阅该对象，并在更新时重新加载其主体。</p><p id="e793" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个类中，我们消费我们的API服务，并为每个类别调用<code class="fe nv nw nx ny b">fetch</code>函数。我们现在不想处理这个错误，所以我们用一个空的<code class="fe nv nw nx ny b">ItemResponse</code>来替换它。然后我们只提取结果(Item对象的数组)。我们指定希望接收主队列中的最终数据。这很重要，因为我们将更新我们发布的属性，因此很可能会更新UI。你不能在后台线程上这样做。记住，我们指定我们的服务应该在后台队列中完成所有的工作。</p><p id="fd63" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我们使用<code class="fe nv nw nx ny b">sink</code>，它允许我们在订阅者收到最终转换后的值时获得一个闭包。然后，我们将解码后的项目列表存储到相应的类别中。</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><h1 id="3a97" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">SwiftUI部分</h1><p id="def4" class="pw-post-body-paragraph kz la iu lb b lc no jv le lf np jy lh li nq lk ll lm nr lo lp lq ns ls lt lu in bi translated">现在我们已经准备好在应用程序中使用我们的项目，让我们使它们对UI可用。因为我们将在各种视图中重用这些项目，因为我们希望它们在任何地方都可用。所以我们将使用<code class="fe nv nw nx ny b"><a class="ae lv" href="https://developer.apple.com/documentation/swiftui/environmentobject" rel="noopener ugc nofollow" target="_blank">EnvironmentObject</a></code>，一个SwiftUI属性包装器，它允许我们从环境中恢复一个对象。</p><p id="a8ea" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了将我们的项目添加到应用程序环境中，我们需要将它附加到视图层次结构的根视图中。最好的地方是在<code class="fe nv nw nx ny b">SceneDelegate</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="ac8a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在第7行，当我们创建我们的<code class="fe nv nw nx ny b">TabbarView</code>时，我们向环境中添加了一个<code class="fe nv nw nx ny b">Items</code>的实例。只要我们的应用程序进程还活着，这个实例就会一直存在。然后我们使用<code class="fe nv nw nx ny b">TabbarView</code>作为应用程序的根视图(第11行)。</p><p id="3b84" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在让我们构建一个这些物品类别的列表和一个来自这个<code class="fe nv nw nx ny b">EnvironmentObject</code>的物品列表。</p><p id="9d77" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们先来看看我们的根视图，<code class="fe nv nw nx ny b">TabbarView</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="4520" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为你的<code class="fe nv nw nx ny b">Tab</code>建立一个枚举是一个很好的实践。由于SwiftUI中的<code class="fe nv nw nx ny b">TabView</code>需要一个绑定，您将需要一个<code class="fe nv nw nx ny b">@State</code>属性包装器来存储您当前选择的选项卡。它会随着你触摸Tabbar的标签而改变。这是一条双行道，所以以后您可能会想要一种UIState，将选中的选项卡作为一个<code class="fe nv nw nx ny b">@Published</code>属性，然后将它存储在一个<code class="fe nv nw nx ny b">EnvironmentObject</code>中。它允许你在应用程序的任何地方以编程的方式交换标签。</p><p id="866a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是我在整个项目中实际做的，但是我想在本文中简化它。</p><p id="ef14" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我们的<code class="fe nv nw nx ny b">TabedView</code>现在只有一个标签。这是<code class="fe nv nw nx ny b">HomeView</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="2287" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如我们之前看到的，我们使用<code class="fe nv nw nx ny b">@EnvironmentObject</code>属性包装器读取我们的Items环境对象。</p><p id="f7cd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后我在视图(categories)上做了一个方便的动态属性，它返回一个tuple ( <code class="fe nv nw nx ny b">(Category, Items)</code>)。这和SwiftUI的<code class="fe nv nw nx ny b">ForEach</code>一起使用会容易很多。</p><p id="f80d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你看一下我们的<code class="fe nv nw nx ny b">HomeView</code>的主体，我们有一个<code class="fe nv nw nx ny b">List</code>，对于每个类别，我们将创建一个包含十个项目的滚动<code class="fe nv nw nx ny b">HStack</code>部分。</p><p id="396d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">瞧！</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj on"><img src="../Images/2511cd01a40df0497d94ed60125d8f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*scJhp_OuuliQR1eAGpN6Fg.png"/></div></figure><p id="4346" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这并不漂亮，但我们有一个SwiftUI应用程序的原型。而且功能齐全。它使用各种SwiftUI数据流属性包装器来读取和发布实时后端数据到您的应用程序中。</p><p id="815e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是应用程序对类别和项目的外观:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/f96d50697d89290b4ae0e7420733f50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*UH_G3U8DuppG5Ar0945zgg.png"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/4d8a583bc3f156a7c68e0fe84062710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_A9MLp6iD59P4wb1z1MBPQ.png"/></div></figure><p id="a618" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当然，在这篇文章中，我把它简化了很多。如果我想向您展示完整的应用程序，那么要嵌入的代码太多了。但是您可以在这里查看完整的存储库并自己构建它:</p><div class="lw lx gq gs ly lz"><a href="https://github.com/Dimillian/ACHNBrowserUI" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">迪米利安/阿欣布罗斯鲁伊</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">这是一个完全在SwiftUI中的全功能动物穿越助手应用程序。仪表板跟踪你的鱼，虫子…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">github.com</p></div></div><div class="mi l"><div class="op l mk ml mm mi mn kt lz"/></div></div></a></div><p id="b960" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我还想谈一件事:视图模型。视图模型是基本SwiftUI应用程序的重要组成部分。它是后端服务、原始模型和视图之间的一层。它允许你把所有不应该在你的视图中的业务逻辑放进去，只暴露你的视图所需要的。您不希望在SwiftUI视图的主体中直接包含繁重的计算或类似的内容。</p><p id="3dd9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里是对<code class="fe nv nw nx ny b">ItemsViewModel</code>的一个观察，它是处理一个项目列表的视图模型(正如你在上面的截图中看到的):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="1499" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如屏幕有各种功能一样，这种视图模型也有。它将包含一个条目列表，还包含我们直接绑定在作为搜索栏的<code class="fe nv nw nx ny b">TextField</code>中的搜索文本(搜索的条目等)。).</p><p id="75cb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是我们在当前流程中的使用方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="6007" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">类别列表将打开一个<code class="fe nv nw nx ny b">ItemsListView</code>，其中的<code class="fe nv nw nx ny b">ItemsViewModel</code>作用于所选的类别。现在你知道了！</p><p id="50ac" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这稍微复杂一点，但是它可以让您了解在实际应用程序中可以做什么的要点。</p><p id="1a61" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我知道你对新系列的第一篇文章的看法。我尽量保持简单，嵌入所有的代码，这样你就可以自己做一些工作，而不用过多地查看存储库。对于本系列的其余部分，您想要更深入的内容还是更多的代码来让它自己工作？</p><p id="c817" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你想有所贡献，我们非常欢迎。我们已经有一些贡献者，如果你想尝试SwiftUI，这真的是一个很棒的项目。所以克隆它，打开你的第一个PR。我们不会咬人的！</p></div><div class="ab cl mp mq hy mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="in io ip iq ir"><h1 id="bf96" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">结论</h1><p id="1830" class="pw-post-body-paragraph kz la iu lb b lc no jv le lf np jy lh li nq lk ll lm nr lo lp lq ns ls lt lu in bi translated">感谢您阅读本文！</p><p id="93b8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我希望您喜欢这第一部分，我们将在第二部分再见，在第二部分我们将更深入地研究视图模型和视图。我们将尝试构建更复杂的视图、一些动画，并探索内部状态管理。</p><div class="lw lx gq gs ly lz"><a href="https://medium.com/better-programming/build-a-swiftui-animal-crossing-application-part-2-82b4ac6695e6" rel="noopener follow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">构建SwiftUI动物穿越应用程序(第2部分)</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">对视图和视图模型的深入研究</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">medium.com</p></div></div><div class="mi l"><div class="oq l mk ml mm mi mn kt lz"/></div></div></a></div></div></div>    
</body>
</html>