<html>
<head>
<title>Data Interchange Techniques for Web Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web应用的数据交换技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-interchange-techniques-for-web-applications-c64ec600a1fc?source=collection_archive---------21-----------------------#2022-06-14">https://betterprogramming.pub/data-interchange-techniques-for-web-applications-c64ec600a1fc?source=collection_archive---------21-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0451" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者，API或者文件，或者两者都有？什么最有效？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/549b60a4b9fa43f0169b1e2a8d68f695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rTS0zR13De496PNS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">戴维·布鲁诺·席尔瓦在<a class="ae kv" href="https://unsplash.com/s/photos/file?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="416e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您已经开发了一个令人难以置信的web应用程序(或概念！)，现在您想标准化数据交换协议，以便合作伙伴和客户可以发送和接收来自您的数据。很久以前，开发人员需要<em class="ls">从你的HTML页面中抓取数据</em>，或者客户需要<em class="ls">通过电子邮件将文件</em>发送给数据管理员。</p><p id="4814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正处于基于JSON的REST APIs解决所有数据交换问题的辉煌时代，对吗？<strong class="ky ir">错了！REST APIs并不是我们所希望的万灵药。当然，它们非常适合许多常见的数据交换需求:搜索结果、获取详细的对象、CRUD操作等等，但是它们并不完美，本文将试图解释其中的原因，以及可能的解决方案。</strong></p><p id="7227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们研究一些目前(仍然)使用的常见数据交换格式。</p><h1 id="971c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据交换的数据格式</h1><h2 id="396a" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">分隔文件</h2><p id="579d" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">以及某种程度上的固定宽度文件(bleh)。</p><p id="ee6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，不起眼的制表符分隔或逗号分隔的文件(CSV)今天仍然非常常用，而且理由充分。</p><p id="f17d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，由于它们在计算生态系统中的寿命，它们非常容易从各种客户端创建。Excel很容易创建它们(尽管有令人讨厌的细微差别)，SQL GUIs很容易导出到它们，并且它们很容易从PHP或Node.JS等脚本语言创建。</p><p id="ad60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，它们并不臃肿。即使它们包含一个“标题行”，它们仍然只是数据。您的应用程序可以使用一行又一行的纯数据，并具有可预测的位置。</p><p id="5e3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下这个例子——如此简单！</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="5c3e" class="ml lu iq nd b gy nh ni l nj nk">UPC Quantity<br/>842365214741 45</span></pre><p id="0c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人欣慰的是，如今固定宽度的文件不像过去那么常见了(EDI <em class="ls">过去是，现在也是</em>物流的通用数据交换格式)，但它们与定界文件具有相同的好处，因为它们基本上<em class="ls">只是数据</em>。解析它们更加困难，因为应用程序需要知道每个数据元素的开始和结束位置，然后清除多余的空白。这就是我在本文中要提到的关于固定宽度文件的全部内容，因为我认为在当今世界中没有它们的位置，如果您需要使用它们，请接受我的慰问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6f7e9b40806a0157fe3502b05e73e2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/0*D3lDJv6LwaluHVSY.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">EDI是未来！说是1992年。</p></figure><h2 id="e48e" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">可扩展标记语言</h2><p id="e37f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在某种程度上，还有肥皂(bleh)。</p><p id="2d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经长大了，足以记得XML风靡世界的时候，天哪，我真的相信了。XML文档是将数据封装和逻辑嵌套到子数据中的文件或字符串。XML代表可扩展标记语言，这里的关键是<strong class="ky ir">可扩展</strong>。XML中的数据可以通过路径进行解析和访问，即使结构随时间变化，只要路径仍然有效，程序仍然可以可靠地提取数据。这完全改变了游戏规则，毫无疑问，为什么XML今天仍然被大量使用。</p><p id="1dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的XML示例:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2fc0" class="ml lu iq nd b gy nh ni l nj nk">&lt;inventory&gt;<br/> &lt;item&gt;<br/>  &lt;UPC&gt;842365214741&lt;/UPC&gt;<br/>  &lt;Quantity&gt;45&lt;/Quantity&gt;<br/> &lt;/item&gt;<br/>&lt;/inventory&gt;</span></pre><p id="9378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SOAP(及其同类产品)试图添加结构和方法来调用远程web服务器上的功能，即使是为了纯粹的数据交换目的，您今天仍然可以看到很多这样的例子。它的核心基本上是XML，但是更加粗糙和复杂。如果你今天还在用肥皂工作，我再次向你表示哀悼。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b84e6e55e1346238d115bada6e3fc8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/0*UNMAyAXPgwkB5LLE.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">谢谢你谷歌这个。</p></figure><h2 id="6868" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">JSON</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9308412e77ebaf09a91e4482d529eff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*DyTsb0aUmHfUW9In.jpeg"/></div></figure><p id="9c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像XML牢牢掌握了现代计算数据交换协议一样，随着JSON的出现，全世界都认为它很有意义。JSON代表JavaScript Object Notation，它本质上是JavaScript数据对象可以以人类可读和机器可读的方式表示的方式，没有任何额外的东西。另一个gamechanger，因为任何编程语言都可以轻松地将JSON解析成该语言的本机数据/对象格式，包括基本类型(XML中的数据只是一个字符串，除非您使用定义文件来解析类型)。这很重要，因为字符串是字符串，数字是数字，十进制是十进制，等等。</p><p id="eec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最棒的是，数组就是数组。XML(没有定义文件)在传达元素重复方面非常糟糕。如果您编写了一个从深层XML节点中提取数据的程序，并且您不知道多个匹配元素是可能的，那么您将面临崩溃，或者至少在大约6个月后会出现意想不到的结果。</p><p id="8d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的JSON示例:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="f562" class="ml lu iq nd b gy nh ni l nj nk">[{<br/> "UPC": "842365214741",<br/> "Quantity": 45<br/>}]</span></pre><p id="36ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON是当今所有新的web应用程序的事实上的数据格式，因为它使与其他语言的集成变得如此容易(令人耳目一新),还因为浏览器可以本地创建和解析JSON。您的应用程序可以使用HTTP API调用我的端点，并以您的应用程序语言的本机格式获得结果数据！万岁。</p><h1 id="6a7c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用分隔文件进行数据交换</h1><p id="7b44" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">等等，什么？我以为我们都认为JSON APIs是正确的选择！我为什么要回去推文件呢？</p><p id="ea8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">信不信由你，把文件推来推去还是有好处的。为了清楚起见，在文档的这一部分，我讨论的是使用(S)FTP服务器来推和拉文件，而不是API，尽管这里也有选项(我将在后面谈到)。</p><h2 id="f743" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">巨大的文件</h2><p id="e808" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们面对它，XML和JSON文件有一些膨胀。他们需要，因为他们描述了他们所展示的数据。在XML的例子中，这是一个很大的膨胀。每个元素都有一个开始标签和结束标签。当你在一个XML文档中有几十万个<code class="fe no np nq nd b">&lt;custom-attribute&gt;bla bla bla&lt;/custom-attribute&gt;</code>标签时(我正看着你，Salesforce)，进入数千兆的数据相对容易。甚至JSON也有一些膨胀。每个数据元素仍然有一个“开始标记”。</p><p id="9c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统可以解析的文档大小有上限，是的，有很多方法可以处理大型结构化文件，但是它们可能会变得很复杂。事实是，分隔文件是大文件辩论的赢家。我职业生涯的大部分时间都在从事电子商务工作，需要传递库存数据是很常见的事情，有成千上万的SKU和相应的数量。带有UPC + <code class="fe no np nq nd b">(tab)</code> + Quantity + <code class="fe no np nq nd b">(line break)</code>的制表符分隔的文件是最小的，也是最容易处理的。它可以快速可靠地加载到数据库系统中，并且很容易解析，即使有100k+行。</p><p id="1a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">带分隔符的文件可以快速轻松地工作，因为<em class="ls">馈送数据</em>可以进入工作流，由系统批量处理。工作<em class="ls">“快速轻松”</em>是<em class="ls">“可靠”</em>的别名，因为快速轻松<em class="ls"/>发生的进程不太可能由于内存问题或锁定而失败。技术上的事实是，一个进程运行的时间越长，就越有可能被什么东西打断。尽可能缩短您的流程。</p><h2 id="7634" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">人类可读性</h2><p id="d33e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">JSON将人类的可读性发挥到了极致，但是一个简单的制表符分隔的文件对于我们人类来说是非常可读的。需要查找某个值是从哪里来的？简单，在你最喜欢的文本编辑器中打开文件，Ctrl+F并找到它。</p><h2 id="c396" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">内置审计日志</h2><p id="3fef" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当您严格使用REST/JSON API时，您的应用程序和远程应用程序实时传递数据，直接对数据库进行插入和更新，除非您(或远程应用程序开发人员)已经实现了一个全面的变更跟踪系统，否则很难跟踪特定变更的来源。</p><p id="60d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有一个顾客问，“为什么这个SKU有14个库存？我们几个月前就卖完了！”，您可以随时回到原始提要(假设您保留了它)，并回答这个问题。实时API在设计中没有这种固有的好处，它是一个真正的救星。</p><h2 id="88a7" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">缺乏灵活性</h2><p id="4503" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">分隔文件并不完美，它们失宠是有原因的。它们绝对不灵活。数据必须在位置的<em class="ls">中，并且不能移动。这使得<em class="ls">迭代和快速发布新特性</em>成为一个问题。如果您想向XML或JSON有效负载添加一个新字段，您可以相对轻松地完成。如果您想在分隔文件中添加一个新字段，您需要让所有相关方参与进来，并确保他们为更改做好准备，并且您很可能需要与您的客户/合作伙伴协调推广。如果这是你关心的问题，考虑一个结构化文档。</em></p><h2 id="2ae0" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">不是实时的</h2><p id="73c4" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当你使用SFTP服务器推送文件时，操作一般是<em class="ls">而不是实时</em>。最有可能的是，远程应用程序将定期检查该服务器的内容，并查看是否有新的文件要获取和处理。这可能会给流程增加几分钟到几小时的延迟，如果您正在处理时间敏感的数据，如库存数量，您可能会给应用程序的数据带来有问题的不准确性。</p><p id="adfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为该过程不是实时的，所以您推送的数据中的任何错误都不会自动报告给您。有了实时API，远程应用程序可以立即响应一条关于数据格式的错误消息。对于文件，各种过程是异步的，需要有另一个过程来报告状态和错误，无论是审计日志还是电子邮件警报。然后，您将需要在您的应用程序中提供修复和重新发送数据。</p><h2 id="b365" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">我对分隔文件的建议</h2><p id="d8ae" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您已经阅读了这一部分，并且您仍然在考虑项目的分隔文件，让我向您推荐制表符分隔文件，而不是逗号分隔文件(CSV)。CSV是<em class="ls">怪</em>。分隔符(，)是数据中常见的字符串(想想产品描述)，因此在CSV中必须用双引号括起来。双引号(另一种常见的字符串)的转义序列很奇怪:必须将双引号括起来才能正确转义。所有这些奇怪的格式规则导致文件可读性差得多，您的CSV解析器也必须能够考虑所有这些细微差别。另一方面，制表符分隔的文件基本上避免了这些缺陷。你也可以用烟斗，但是看在上帝的份上，尽可能避免使用CSV。</p><h1 id="d5e4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用HTTP APIs进行数据交换</h1><p id="100e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">是的，这是大多数用例的最佳选择。好了，我说了。HTTP APIs的好处很多，但是就像生活中的其他事情一样，它们也有权衡。</p><p id="5dc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><h2 id="5492" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">实时</h2><p id="5eaa" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这一点怎么强调都不为过。在需要时获取或接收所需的数据是一回事，但能够对错误做出反应也同样重要，无论这些错误是与验证相关的(您传递或接收了一些错误数据)还是与正常运行时间相关的(服务中断)。不仅如此，你还可以让客户在你的应用程序之上构建丰富的功能<em class="ls">。</em></p><h2 id="1911" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">轻量级选手</h2><p id="2138" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">因为您的客户可以查询您的数据，根据请求获得更详细的单元级数据，进行更新和插入，并且通常使用来自您的应用程序的少量数据，所以HTTP API可以是非常轻量级的。小请求和小响应。如果您需要提供潜在的大型数据集，您可以提供分页的结果(在每个响应有效负载的X个页面中分割的结果)。</p><h2 id="35bd" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">一致性</h2><p id="705f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您已经构建了自己的用户界面(UI ),使得它只通过HTTP JSON APIs与应用程序的数据进行交互，那么您就不需要编写更多的代码来为您的客户提供相同的API。你甚至可以编写一个原生的移动应用程序，重新利用相同的API。像这样的应用程序通常被称为<em class="ls"> API优先</em>应用程序，因为API优先，然后是ui。这使得你的应用程序通过UI的行为和你的客户使用的API之间达到了令人难以置信的一致性。</p><h2 id="19ca" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">可量测性</h2><p id="6784" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">既然我们在谈论web服务器是信息流的仲裁者，它们提供了与网站相同的可伸缩性选项。您可以跨web服务器对API流量进行负载平衡，以减少每台服务器上的负载。您可能需要处理与数据库规模相关的问题，但是根据您的使用情况，有许多解决数据库负载问题的解决方案。</p><h2 id="0846" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">易用性</h2><p id="fd38" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们不要忘记，今天的开发人员在连接到HTTP APIs并与之交互方面非常有能力。如今，JSON是互联网的通用语言，而且JSON API实际上是<em class="ls">期望</em>存在的。</p><h2 id="2350" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">文件问题</h2><p id="f502" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">你在web应用程序中处理过文件上传吗？当然，你有。每个应用程序至少需要一个用户头像上传功能。令人惊讶的是，JSON API规范在上传应该如何发生上存在分歧。客户端应该像以前一样发出多部分上传请求吗？这不太符合JSON的风格。客户端base-64应该对文件内容进行编码并将其包含在POST主体的JSON参数中吗？现在您将遇到JSON解析大小限制，这是为了防止您的web服务器受到DDOS攻击。我过去使用的一种技术是执行多个请求:首先，将文件作为一个多部分请求上传，让服务器用一个唯一的文件ID进行响应，然后，让客户端将该ID与另一个请求一起发送，<em class="ls">将该文件附加到数据库中的对象。这些都不是完美的，我认为公平地说，HTTP JSON APIs还没有一个优雅的解决方案来解决这个问题。</em></p><h2 id="5d50" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">庞大的数据</h2><p id="f087" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">您需要从客户那里接收大量数据吗？如果是这样的话，HTTP JSON API可能无法一次接受它。正如我上面提到的，web服务器通常对它们可以接受和解析的有效负载的大小有限制。这是因为将JSON(或XML)字符串解析为本机对象需要CPU资源，如果服务器试图解析一个非常大的字符串，它可能会使服务器崩溃。如果您需要接受大量数据到一个HTTP API中，您可能需要您的客户将其分割成易于管理的块。</p><h1 id="af20" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">混合模型</h1><p id="92ef" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们已经讨论了文件和HTTP APIs的优缺点，认为它们各有利弊。那么，为什么不考虑一个混合模式，利用两个世界的优点呢？</p><p id="b360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为亚马逊用他们的SP-API(销售合作伙伴API)和之前的版本MWS(商业网络服务)做得很好。</p><p id="1460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在他们的API中，Amazon有效地发布了一个HTTP JSON API。然而，在他们希望客户上传大量数据的情况下，比如带有跟踪号或库存数量的装运状态，他们提供了专用的<em class="ls"> feed API </em>。上传由多个请求处理:首先，您调用一个API来创建一个文档引用，接下来您执行文件数据的HTTP上传，然后您执行另一个API调用来指示Amazon<em class="ls">与提供数据的</em>一起工作。然后，您可以调用另一个API来检查这个提要的状态，因为Amazon异步处理这个提要。是的，需要做更多的准备工作。但是，它符合进程应该是短命的原则。每一个API调用都很快。您可以通过快速调用不断地回调Amazon，以查看提要是否已经被消费完。如果Amazon的feed-processor很忙，您可能需要等待一段时间，但是至少您的API调用不会超时。</p><p id="c054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，Amazon提供了一个用于产生大量数据输出的<em class="ls">报告API </em>。在这个模型中，您调用一个API来请求一个报告，然后调用另一个API来检查报告请求的状态，当它完成时，您下载生成的报告数据。每个请求都是快速可靠的。即使Amazon花了一些时间来生成报告，也没有请求超时。</p><p id="9a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用HTTP作为文件上传和交付的协议，而不是SFTP服务器，您不需要创建和管理任何额外的服务器或权限。</p><p id="b457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这真是两全其美。一个具有实时数据的API，但也提供了大量数据馈送(入站和出站)。</p><h1 id="a459" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">玩得开心</h1><p id="39d2" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我希望你能像我写这篇文章一样喜欢阅读，如果你已经读到这里，谢谢你。享受编写API和文件接口的乐趣，感谢您为您的开发伙伴们创造了一个更好的世界。</p></div></div>    
</body>
</html>