<html>
<head>
<title>Common Go Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的围棋陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/common-go-pitfalls-a92197cd96d2?source=collection_archive---------4-----------------------#2019-10-24">https://betterprogramming.pub/common-go-pitfalls-a92197cd96d2?source=collection_archive---------4-----------------------#2019-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2233" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些常见错误以及如何诊断和修复它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca6a91c4d965bf01fcbdf81769bb5197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XTRgJ-MFix4WF627cFCeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编写简单、可靠的Go代码时避免陷阱</p></figure><p id="dbbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢Golang有几个原因:</p><ul class=""><li id="91d0" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">这是一种超级小语种(它只有<a class="ae md" href="https://golang.org/ref/spec#Keywords" rel="noopener ugc nofollow" target="_blank">25个保留关键字</a></li><li id="aa2a" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">交叉编译轻而易举</li><li id="d961" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">本地支持创建可靠的HTTP(s)服务器</li></ul><p id="326f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从本质上来说，它是一种枯燥的语言，这可能就是为什么像<a class="ae md" href="https://github.com/avelino/awesome-go" rel="noopener ugc nofollow" target="_blank"> Docker和Kubernetes </a>这样的优秀项目是用它编写的，而像<a class="ae md" href="https://blog.cloudflare.com/tag/go/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>这样对性能和弹性要求高的公司也在使用它。</p><p id="3fe5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管它很容易使用，但Go确实需要注意细节。如果你不按预期使用语言，它可能会崩溃。很难诊断和修复错误。</p><p id="a3b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我在产品代码库中，在代码评审过程中，以及我自己所犯的一些常见错误。希望这能让你在遇到同样的问题时更容易诊断出来。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c93b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">HTTP超时</h1><p id="b5e8" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">第一期有一整篇关于它的文章<a class="ae md" href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779" rel="noopener"/>，但它仍然值得一提，因为最佳解决方案可能需要一些思考。它必须使用默认的HTTP客户端发出HTTP请求。</p><p id="0342" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明这个问题，这里有一个向google.com发出<code class="fe nn no np nq b">GET</code>请求的基本示例:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="731b" class="nv mr it nq b gy nw nx l ny nz">package main</span><span id="79cb" class="nv mr it nq b gy oa nx l ny nz">import (<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"<br/>)</span><span id="56af" class="nv mr it nq b gy oa nx l ny nz">var (<br/>    c = &amp;http.Client{}<br/>)</span><span id="5ebb" class="nv mr it nq b gy oa nx l ny nz">func main() {<br/>    req, err := http.NewRequest("GET", "google.com", nil)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="5088" class="nv mr it nq b gy oa nx l ny nz">    res, err := c.Do(req)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    defer res.Body.Close()<br/>    b, _ := ioutil.ReadAll(res.Body)<br/>    ...<br/>}<br/></span></pre><p id="7ea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如不要使用Go的默认HTTP客户端文章中指出的，默认客户端实际上没有超时。这意味着根据服务器的不同，代码可能会无限期挂起，或者直到应用程序重新启动。</p><p id="9964" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么解决这个问题的最好方法是什么呢？</p><p id="896a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然总是用合理的超时来定义HTTP客户端是一个好主意，但是<code class="fe nn no np nq b">&amp;http.Client{Timeout: time.Minute}</code>您也可以考虑为您的请求附加一个上下文，以获得一些额外的好处:</p><ul class=""><li id="f97a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">取消正在进行的请求的能力</li><li id="ba99" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">您可以针对特定请求调整超时</li></ul><p id="2562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个好处尤其重要，因为如果您知道有几个请求需要很长时间，比如说一个多小时，您不希望每个请求都等待一个小时才超时。</p><p id="795e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，添加一个上下文看起来像这样:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c48f" class="nv mr it nq b gy nw nx l ny nz">ctx, cancel := context.WithTimeout(context.Background(), time.Minute)<br/>defer cancel()</span><span id="2f55" class="nv mr it nq b gy oa nx l ny nz">req = req.WithContext(ctx)</span><span id="1f58" class="nv mr it nq b gy oa nx l ny nz">res, err := c.Do(req)<br/>...</span></pre><p id="0d28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果超过了分配的时间，对<code class="fe nn no np nq b">c.Do</code>的调用将导致一个<code class="fe nn no np nq b">DeadlineExceeded</code>错误，使得处理或重试变得容易。有关上下文包的更多信息，请查看<a class="ae md" href="https://golang.org/pkg/context/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7b5b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">数据库连接</h1><p id="0dbe" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在我参与的几乎每个Go项目中，我都遇到过数据库连接问题。我认为对于新的地鼠来说，难以理解的是,<code class="fe nn no np nq b">sql.DB</code>对象是一个并发安全的连接池，而不是单个数据库连接。这意味着，如果您忘记将连接返回到池中，您很容易耗尽连接的数量，并且您的应用程序可能会陷入停顿。</p><p id="ca27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，连接池既包含<code class="fe nn no np nq b">Open</code>连接，也包含<code class="fe nn no np nq b">Idle</code>连接，它们是通过以下方式配置的:</p><ul class=""><li id="f054" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nn no np nq b"><a class="ae md" href="https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime" rel="noopener ugc nofollow" target="_blank">SetConnMaxLifetime</a></code>:连接可以重复使用的最长时间</li><li id="9e6e" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b"><a class="ae md" href="https://golang.org/pkg/database/sql/#DB.SetMaxIdleConns" rel="noopener ugc nofollow" target="_blank">SetMaxIdleConns</a></code>:空闲连接池中的最大连接数</li><li id="3540" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b"><a class="ae md" href="https://golang.org/pkg/database/sql/#DB.SetMaxOpenConns" rel="noopener ugc nofollow" target="_blank">SetMaxOpenConns</a></code>:数据库的最大打开连接数</li></ul><p id="90ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，即使将最大打开连接数配置为200，应用程序仍会耗尽数据库将接受的打开连接数，从而导致必须关闭或重新启动。您需要检查数据库设置或与任何有权限的人协调，以确保您正确地设置了这些限制。</p><p id="56e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不配置限制，您的应用程序可以很容易地使用数据库将接受的所有连接。</p><p id="69ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到耗尽连接池。当查询数据库时，许多开发人员忘记关闭<code class="fe nn no np nq b">*sql.Rows</code>对象。这导致达到最大连接数限制，并导致死锁或高延迟。以下代码片段展示了这一点:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2c58" class="nv mr it nq b gy nw nx l ny nz">package main</span><span id="a929" class="nv mr it nq b gy oa nx l ny nz">import (<br/>    "context"<br/>    "database/sql"<br/>    "fmt"<br/>    "log"<br/>)</span><span id="e9a4" class="nv mr it nq b gy oa nx l ny nz">var (<br/>    ctx context.Context<br/>    db  *sql.DB<br/>)</span><span id="7777" class="nv mr it nq b gy oa nx l ny nz">func main() {<br/>    age := 27<br/>    ctx, cancel := context.WithTimeout(context.Background(), time.Minute)<br/>    defer cancel()</span><span id="31c9" class="nv mr it nq b gy oa nx l ny nz">    rows, err := db.QueryContext(ctx, "SELECT name FROM users WHERE age=?", age)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="5fc3" class="nv mr it nq b gy oa nx l ny nz">    for rows.Next() {<br/>        var name string<br/>        if err := rows.Scan(&amp;name); err != nil {<br/>            log.Fatal(err)<br/>        }<br/>        fmt.Println(name)<br/>    }<br/>    ...</span><span id="c9e2" class="nv mr it nq b gy oa nx l ny nz">}</span></pre><p id="52dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您会注意到，就像您可以向HTTP请求添加上下文一样，您也可以向数据库查询(或预准备语句的执行、ping等)添加带有超时的上下文。)但这不是问题。</p><p id="fab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所述，我们需要关闭rows对象以防止进一步枚举，并将连接释放回连接池:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="6c57" class="nv mr it nq b gy nw nx l ny nz">rows, err := db.QueryContext(ctx, "SELECT name FROM users WHERE age=?", age)<br/>if err != nil {<br/>    log.Fatal(err)<br/>}<br/>defer rows.Close()</span></pre><p id="9ad5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在函数和包之间传递开放的连接，这变得特别难以发现。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="93b9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Goroutine或内存泄漏</h1><p id="5e7f" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这里我要介绍的最后一个常见错误是Goroutine泄漏。这些可能很难检测，但通常是由用户错误造成的。</p><p id="d66b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种情况在使用通道时经常发生。例如:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="7c92" class="nv mr it nq b gy nw nx l ny nz">package main<br/></span><span id="2471" class="nv mr it nq b gy oa nx l ny nz">func main() {<br/>    c := make(chan error)<br/>    go func() {<br/>        for err := range c {<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>        }<br/>    }()</span><span id="4d18" class="nv mr it nq b gy oa nx l ny nz">    c &lt;- someFunc()<br/>    ...</span><span id="dc5a" class="nv mr it nq b gy oa nx l ny nz">}</span></pre><p id="1b0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不关闭通道c或者如果<code class="fe nn no np nq b">someFunc()</code>没有返回错误，我们已经初始化的Goroutine将会挂起，直到程序终止。</p><p id="1fda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我没有列举可能导致Goleaks的案例数量，而是使用了两种方法来检测和消除它们。</p><p id="e930" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一种方法是在测试中使用泄漏检测器，像<a class="ae md" href="https://github.com/uber-go/goleak" rel="noopener ugc nofollow" target="_blank">优步的goleak库</a>。实际上是这样的:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="f87c" class="nv mr it nq b gy nw nx l ny nz">func TestA(t *testing.T) {<br/>    defer goleak.VerifyNone(t)<br/>    // test logic here.<br/>}</span></pre><p id="2052" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将在30秒钟的宽限期(允许正常关闭)后验证在测试结束时没有意外的Goroutines运行。</p><p id="2d6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种方法是在应用程序的一个运行实例上使用<a class="ae md" href="https://blog.golang.org/profiling-go-programs" rel="noopener ugc nofollow" target="_blank"> Go profiler </a>，查看活动Goroutines的数量。一种方法是添加<code class="fe nn no np nq b"><a class="ae md" href="https://golang.org/pkg/net/http/pprof/" rel="noopener ugc nofollow" target="_blank">net/http/pprof</a></code> <a class="ae md" href="https://golang.org/pkg/net/http/pprof/" rel="noopener ugc nofollow" target="_blank">库</a>并点击Goroutine概要文件。</p><p id="4aab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过添加以下内容来启用它:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1eb3" class="nv mr it nq b gy nw nx l ny nz">import _ "net/http/pprof"</span><span id="b540" class="nv mr it nq b gy oa nx l ny nz">func someFunc() {<br/>    go func() {<br/>        log.Println(http.ListenAndServe("localhost:6060", nil))</span><span id="f590" class="nv mr it nq b gy oa nx l ny nz">    }<br/>}</span></pre><p id="23ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将启用端口6060上的<code class="fe nn no np nq b">pprof</code>。对于特别严重的泄漏，您可以刷新并看到goroutines的数量增加。对于更细微的泄漏，通读概要文件并寻找函数在不应该的时候滞留的实例。个人资料页面将如下所示:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="b72b" class="nv mr it nq b gy nw nx l ny nz">goroutine profile: total 39<br/>2 @ 0x43cf10 0x44ca6b 0x980600 0x46b301<br/>#	0x9805ff	database/sql.(*DB).connectionCleaner+0x36f	/usr/local/go/src/database/sql/sql.go:950<br/><br/>2 @ 0x43cf10 0x44ca6b 0x980b18 0x46b301<br/>#	0x980b17	database/sql.(*DB).connectionOpener+0xe7	/usr/local/go/src/database/sql/sql.go:1052<br/><br/>2 @ 0x43cf10 0x44ca6b 0x980c4b 0x46b301<br/>#	0x980c4a	database/sql.(*DB).connectionResetter+0xfa	/usr/local/go/src/database/sql/sql.go:1065</span><span id="1191" class="nv mr it nq b gy oa nx l ny nz">...</span></pre><p id="f3ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的应用程序处于空闲状态，并且您看到了大量的总Goroutine，这是一个很好的迹象，表明有什么地方出错了。在确定了泄漏的位置之后，我仍然建议在测试中使用泄漏检测器来确保问题得到解决。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2611" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="8033" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">希望了解和看到这些常见错误的一些例子将帮助您更快地识别和修复它们。显然还有许多其他常见的错误，例如:</p><ul class=""><li id="985a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">竞赛条件</li><li id="b179" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">僵局</li><li id="6256" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">吞咽错误</li></ul><p id="a0a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些可以通过类似的技术找到并修复，比如使用<a class="ae md" href="https://blog.golang.org/race-detector" rel="noopener ugc nofollow" target="_blank"> go race检测器、</a>编写测试，或者使用go profiler。</p></div></div>    
</body>
</html>