<html>
<head>
<title>Understanding Stored and Computed Properties in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Swift中存储和计算的属性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stored-and-computed-properties-in-swift-c5c256149e9f?source=collection_archive---------5-----------------------#2021-08-13">https://betterprogramming.pub/stored-and-computed-properties-in-swift-c5c256149e9f?source=collection_archive---------5-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于存储的和计算的属性，您需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fbdd79501ce32ecdc0af0f84aac682ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PVk34MALRt1SKP4-9Hjyg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有开发人员在开始Swift编程时都会遇到的一个概念就是属性。这个术语是人们在编程文章、书籍、课程或讨论中阅读、写作或谈论的最常见的术语之一。</p><p id="1565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，属性是存储值的变量和常量，我们在Swift类、结构和枚举中声明它们。但房产并不是Swift独有的。我们在每一种面向对象编程(OOP)语言中都遇到了它们。</p><p id="4a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，两个新术语很快就进入了游戏属性——<code class="fe lv lw lx ly b">stored</code><em class="lz"/>和<em class="lz"> </em> <code class="fe lv lw lx ly b">computed</code>。尽管两者都以某种方式解释了它们的意义，但只有在探索之后，人们才能意识到它们实际上是什么。</p><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经常有这样的情况，程序员在编写代码时甚至没有听说过这些概念的存在。事实上，我们可以在不知道任何细节的情况下编写整个应用程序。那么，为什么有必要了解它们呢？</p><p id="23db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，由于存储和计算的属性作为Swift语言中的概念存在，它们成为每个人都应该理解和掌握的必备知识。</p><p id="4e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，正如你将在这篇文章中发现的，这不是一个困难的话题。但除此之外，了解它们是什么以及它们在extend中必须提供什么，可以帮助我们改变编码方式并获得更好的编程习惯。</p><p id="c50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们一起深入了解Swift中存储和计算属性的更多细节，通过几个简单的例子和解释突出它们。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="186f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">存储的属性</h1><p id="9aaa" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">存储属性是将值存储到类或结构的实例中的变量或常量。尽管这听起来很明显，但赋给变量的值可以随时修改。相反，最初分配给常数的值以后不能改变。</p><p id="1323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们实现的程序的需要，我们可以将默认值分配给属性以及它们的声明。</p><p id="14c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有些属性只有它们的数据类型，没有默认值，也没有声明为可选的，那么在初始化它们所属类型的实例时应该提供初始值。</p><p id="dd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，对于存储的常量属性，默认值或初始值是该属性在实例的整个生存期内将包含的内容；常数是不可变的，不会改变。此外，我们可以将存储的属性声明为可选属性。</p><p id="ebb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段演示了所有这一切:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="79d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的程序员类中，声明了四个存储属性。<code class="fe lv lw lx ly b">name</code>属性是字符串类型，没有默认值。这意味着当我们初始化一个类的实例时，有必要提供一个。</p><p id="2eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">language</code>属性应该保持程序员所熟悉的编程语言，它是一个常量。与前一个类似，这个存储的属性将在实例初始化时获得它的值，但是相比之下，在那之后它不会改变。</p><p id="40a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">yearsOfExperience</code>属性是用默认值声明的。因为它是一个变量，我们可以在以后的任何时候修改它的值。还要注意，我们没有为属性设置显式类型，尽管如果我们这样做的话会非常好。它是从分配给它的原始值中自动推断出来的。</p><p id="d09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">secondLanguage</code>属性是可选的，它应该存储程序员熟悉的另一种编程语言。</p><p id="0d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，它们都是存储属性，因为它们可以存储属于类实例一部分的值。在上面的例子中，有一个混合属性，有和没有默认值，还有一个是可选的。</p><p id="3a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们保持上面的实现不变，那么前两个存储的属性会让Xcode显示一个错误，说这个类没有初始化器。在容器类型是一个类的情况下，需要实现一个自定义的初始化器，在这里我们将为这些属性分配初始值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个程序员实例，来看看上面存储的属性的运行情况。前两个属性将在初始化时获得一个值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">name</code>是一个变量，我们可以随时改变它:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="bb9e" class="nk mi it ly b gy nl nm l nn no">programmer.name = "Gabe"</span></pre><p id="e5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能对<code class="fe lv lw lx ly b">language</code>存储的属性做同样的事情。它是一个常数，所以它是不可变的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="412a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于另外两个存储的属性，我们可以在适当的时候给它们赋值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它们是变量，我们可以在必要时自由地改变它们。特别是最后一个也可以变成零；它被声明为可选变量。</p><h1 id="0d49" class="mh mi it bd mj mk np mm mn mo nq mq mr jz nr ka mt kc ns kd mv kf nt kg mx my bi translated">结构中存储的属性</h1><p id="a70a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">就在几行之前，我们初始化了一个<code class="fe lv lw lx ly b">Programmer</code>实例，并使用<code class="fe lv lw lx ly b">var</code>关键字将它赋给了一个变量。我们可以使用<code class="fe lv lw lx ly b">let</code>并将实例赋给一个常量——我们仍然可以使用所有存储的属性，如上所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果<code class="fe lv lw lx ly b">Programmer</code>是一个结构而不是一个类，事情就不一样了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，当<code class="fe lv lw lx ly b">Programmer</code>是一个结构时，一个默认的初始化器被自动提供——因此我们可以简单地跳过实现一个自定义的初始化器，就像前面用这个类演示的那样。</p><p id="1fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在初始化一个<code class="fe lv lw lx ly b">Programmer</code>实例并赋值给一个变量将会像预期的那样工作，没有任何问题。但是下面一行将实例赋给用<code class="fe lv lw lx ly b">let</code>关键字声明的常量会在Xcode中触发错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅因为<code class="fe lv lw lx ly b">Programmer</code>结构是值类型，它的所有存储属性也变成了与<code class="fe lv lw lx ly b">programmer</code>实例类似的常量。不管我们是否将它们中的大多数声明为变量，都会发生这种情况。</p><p id="0970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但对于类来说，情况并非如此；它们是引用类型，可以修改实例的变量，即使该实例已被赋值为常量。</p><p id="6efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，根据经验，将结构的实例分配给变量，以便改变存储的属性。另一方面，可以随意将类的实例赋给变量或常量。前者是强制性的，以防您希望在将来的某个时候使实例为零。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e4ac" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">计算属性</h1><p id="8806" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">与存储属性不同，计算属性不存储任何值。然而，它们所做的是返回并选择性地设置其他存储属性的值，通常是在一些计算之后。</p><p id="7cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，他们提供了<em class="lz">一个</em> getter <em class="lz">和</em> setter分别用于获取和存储值。为了说明这一点，看一下下面的结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8e21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Angle</code>结构有一个名为<code class="fe lv lw lx ly b">degrees</code>的存储属性，用于存储以度为单位的角度。但是我们也可以用弧度来表示角度，所以<code class="fe lv lw lx ly b">Angle</code>结构也定义了<code class="fe lv lw lx ly b">rads</code>属性。这不是存储属性，而是计算属性。</p><p id="2a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rads</code>属性中最引人注目的是它的getter和setter。在花括号定义的<code class="fe lv lw lx ly b">rads</code>体内，分别有一个<code class="fe lv lw lx ly b">get</code>和一个<code class="fe lv lw lx ly b">set</code>块。</p><p id="c920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个示例中，返回值是根据<code class="fe lv lw lx ly b">degrees</code>属性的当前值计算出来的弧度。在setter中，我们将给定的弧度值转换为度数，并将其存储到<code class="fe lv lw lx ly b">degrees</code>存储属性中。</p><p id="363a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，上面设置器中的弧度值是用<code class="fe lv lw lx ly b">newRads</code>名称表示的。然而，提供它并不是强制性的，因为有一个速记可以使用；我们可以省略它，在这种情况下，我们可以用默认名称<code class="fe lv lw lx ly b">newValue</code>访问新值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你能意识到的，我们在上面设法做的是用两种不同的方式来表示一个角度；包括度数和弧度。但是即使我们声明了两个属性，其中只有一个实际上存储了一个值。</p><p id="9fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个在运行中计算它的值，当设置时，提供的弧度被转换并存储为度。这清楚地展示了计算属性提供的便利和能力；为了将角度转换成弧度，或者相反，不需要进一步的附加动作。</p><h1 id="2699" class="mh mi it bd mj mk np mm mn mo nq mq mr jz nr ka mt kc ns kd mv kf nt kg mx my bi translated">只读计算属性</h1><p id="bbaa" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">实现计算属性的getter是强制性的。然而，为setter这样做是绝对可选的，并且它取决于我们定义的computed属性。</p><p id="1455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了看一个例子，假设我们有一个保存温度值的结构。为此，我们有一个数组和一个计算属性来获取平均温度值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里不存在setter，即使存在也没有意义。在上面这种没有设置器的情况下，计算出的属性叫做<em class="lz">只读</em>。</p><p id="9eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写只读计算属性的方式可以通过去掉一些东西来简化。第一个是<code class="fe lv lw lx ly b">get</code>的身体；因为没有setter，所以不再需要显式地编写它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="af79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使只读计算属性“更轻”的第二步是删除关键字<code class="fe lv lw lx ly b">return</code>。将它保存在单个语句中并不是强制性的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">computed属性现在更简单了，因为实现中缺少了显式getter和<code class="fe lv lw lx ly b">return</code>关键字。</p><h1 id="727b" class="mh mi it bd mj mk np mm mn mo nq mq mr jz nr ka mt kc ns kd mv kf nt kg mx my bi translated">计算属性而不是方法</h1><p id="bdc0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">只要不需要提供参数，用计算属性代替方法实现是很常见的。上图中的最后一个例子有助于说明这一点。</p><p id="a3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe lv lw lx ly b">average</code> computed属性在Temperatures结构中不存在。但是，获取平均温度的要求仍然存在。通常，我们会实现一个方法来获取该值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="84ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管语法上的差别很小，但获取平均温度作为计算属性可能比定义方法更方便、更简单。</p><p id="4e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这两种方式都是正确的，所以这主要是一个编码习惯的问题。但是由于计算出的属性通常可以得到与方法相同的结果，并且假设它们在语法上更简单，那么这里的收益将是更少、更清晰、更可读的代码。</p><p id="ed75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于计算属性，还有最后一点需要注意。类似于我们指定返回类型的方法，也有必要显式设置计算属性的类型。</p><p id="c2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储属性就不是这样了。如前所述，可以根据分配给属性的默认值来推断类型。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6250" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="54d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对存储属性和计算属性的探索到此结束，这篇文章总结了您需要了解的关于它们的几乎所有内容。</p><p id="b13d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使没有经验，你也很可能已经知道了许多介绍的主题；尤其是关于存储的属性，因为这是我们最常用的。</p><p id="da60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，计算属性也很有趣，因为除了它们最初的用途之外，还可以用来代替方法。我希望您今天在这里学到了一些新东西，尤其是如果您是Swift的新人。感谢您的阅读，敬请关注其他有趣的话题！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="18eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">最初发布于2021年8月13日</em><a class="ae ky" href="https://serialcoder.dev/text-tutorials/swift-tutorials/stored-and-computed-properties-in-swift/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://serial coder . dev</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>