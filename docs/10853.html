<html>
<head>
<title>Understanding React Lifecycles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解反应生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-lifecycle-in-react-34f76412e97d?source=collection_archive---------11-----------------------#2022-01-31">https://betterprogramming.pub/understanding-lifecycle-in-react-34f76412e97d?source=collection_archive---------11-----------------------#2022-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="77ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解React中的生命周期及其方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae8fd78c72ed20a76726c0586c15045f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aKf38C8i_fVjcZMQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·哈里森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单直接地说，生命周期指的是React组件在其存在期间所经历的3个阶段。</p><p id="673d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React中的每个组件都要经历三个阶段，即:</p><ol class=""><li id="2a12" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">增加</li><li id="a2d0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更新</li><li id="db85" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">卸载</li></ol><blockquote class="mg mh mi"><p id="7ca4" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><em class="iq">作为React开发人员，了解这三个阶段以及与每个阶段相关的方法是很重要的。这些方法可以在类组件中被覆盖，以执行副作用和管理组件的状态。</em></p></blockquote><p id="72fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看每个阶段的这些方法:</p><h1 id="8f44" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">增加</h1><p id="bae4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这是任何组件的初始阶段。它对应于组件将被插入DOM的时刻。也就是说，当它开始出现在你的浏览器屏幕上的时候。</p><p id="e7ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此阶段，有4种方法按以下顺序执行:</p><ol class=""><li id="3864" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">contructor()</code></li><li id="5cde" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">getDerivedStateFromProps()</code></li><li id="4786" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">render()</code></li><li id="4cf9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">componentDidMount()</code></li></ol><p id="f5e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些方法中，只有第三种(render)在创建类组件时是必需的。其他的由开发人员决定是否在他们的组件中实现。</p><p id="8c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是<code class="fe nk nl nm nn b">constructor</code>，在React组件中用来设置初始状态值。</p><p id="92b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法只用于一个目的:它允许一个组件通过改变属性来更新它的状态。这里的见其用法<a class="ae kv" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props) and [here](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change" rel="noopener ugc nofollow" target="_blank">的两个例子。在下面的例子中，我用prop中传递的值设置了计数器的状态。</a></p><p id="eab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三个也是唯一一个强制的是<code class="fe nk nl nm nn b">render</code>。被调用时，它必须检查this.props和this.state，并返回以下类型之一:React元素、门户、字符串、数字、布尔值或null值。render方法<em class="mj">应该保持纯</em>，也就是不要在其中产生副作用(比如API调用)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ad0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，您不再需要调用构造函数来初始化状态，这就消除了对它的需求。</p><p id="6886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">getDerivedStateFromProps</code>方法给我们的组件增加了一些复杂性，总的来说你不需要使用它。</p><p id="0bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" rel="noopener ugc nofollow" target="_blank">React博客上的这篇文章指出了为什么不使用派生状态</a></p><h1 id="f130" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">更新</h1><p id="3f8c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当组件覆盖了一些属性更改(即其父组件传递了新的属性)或当内部状态覆盖了一个更改(例如通过<code class="fe nk nl nm nn b">this.setState({})</code>)时，组件进入更新阶段。</p><p id="0103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像在组装阶段一样，将调用一个定义好的方法序列。它们是:</p><ol class=""><li id="b9e6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">getDerivedStateFromProps()</code></li><li id="0ed7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">shouldComponentUpdate()</code></li><li id="a5e0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">render()</code></li><li id="7f2d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">getSnapshotBeforeUpdate()</code></li><li id="50db" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">componentDidUpdate()</code></li></ol><p id="8318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法，<code class="fe nk nl nm nn b">getDerivedStateFromProps</code>我们已经知道并在组装阶段介绍过。在更新阶段，它的行为是相同的。</p><p id="503d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个方法<code class="fe nk nl nm nn b">shouldComponentUpdate</code>将决定序列中的方法是否被执行。也就是说，它将决定组件是否应该再次呈现。这种方法只是为了避免不必要的更新，从而优化应用程序的性能。</p><p id="1bbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果已经调用了<code class="fe nk nl nm nn b">this.forceUpdate()</code>方法，更新将不会调用shouldComponentUpdate，组件将会如其名被强制更新。</p><p id="d7b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在提交最近呈现的输出之前调用<code class="fe nk nl nm nn b"><strong class="ky ir">getSnapshotBeforeUpdate</strong></code>。它允许您的组件在DOM发生潜在变化之前从DOM中获取一些信息(例如，滚动位置)。</p><p id="7b8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个生命周期返回的任何值都将作为第三个参数传递给<code class="fe nk nl nm nn b">componentDidUpdate</code>方法，这个参数称为snapshot。</p><p id="fd4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着DOM的更新，最终调用了<code class="fe nk nl nm nn b"><strong class="ky ir">componentDidUpdate</strong></code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="6ba6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">卸载</h1><p id="d17e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当组件要通过改变状态或道具从DOM中移除时，我们就处于反汇编阶段。</p><p id="11e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们只有一种生命周期方法，那就是:</p><h2 id="3882" class="nq mo iq bd mp nr ns dn mt nt nu dp mx lf nv nw mz lj nx ny nb ln nz oa nd ob bi translated">1.componentWillMount()</h2><p id="5df9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">该方法在组件被移除之前执行。它用于删除条目和侦听器。一个例子是使用setInterval，即使组件被删除，它将继续运行，而不管调用它的组件是否存在。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="bc27" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">遗留方法</h1><p id="eb02" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">为了制造混乱和一些难以解决的错误，一些React生命周期方法正在被废弃。在版本17中，它们仍然可以在名字前面加上前缀<code class="fe nk nl nm nn b">UNSAFE\_ </code>。要了解更多关于它们为什么被弃用的信息，请看React博客上的<a class="ae kv" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a></p><ol class=""><li id="9b31" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">UNSAFE_componentWillMount()</code></li><li id="734e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">UNSAFE_componentWillReceiveProps()</code></li><li id="67ef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nk nl nm nn b">UNSAFE_componentWillUpdate()</code></li></ol><h1 id="a7fa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="6224" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我希望现在您对什么是生命周期有了更好的理解！这绝对是一个可以帮助你在未来构建更好、更可预测的UI的概念。</p><pre class="kg kh ki kj gt oc nn od oe aw of bi"><span id="572b" class="nq mo iq nn b gy og oh l oi oj"><strong class="nn ir">Want to Connect?</strong></span><span id="d2e7" class="nq mo iq nn b gy ok oh l oi oj">If you want to read more React stuff, do visit my website: <a class="ae kv" href="https://fernandobelotto.dev" rel="noopener ugc nofollow" target="_blank">https://fernandobelotto.dev</a></span></pre></div></div>    
</body>
</html>