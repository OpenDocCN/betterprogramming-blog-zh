<html>
<head>
<title>CUDA, SYCL, Codeplay, and oneAPI — Accelerators for Everyone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CUDA、SYCL、Codeplay和oneAPI——面向所有人的加速器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cuda-sycl-codeplay-and-oneapi-accelerators-for-everyone-4603fee0421?source=collection_archive---------4-----------------------#2022-07-01">https://betterprogramming.pub/cuda-sycl-codeplay-and-oneapi-accelerators-for-everyone-4603fee0421?source=collection_archive---------4-----------------------#2022-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2564" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">CUDA和SYCL——功能测试演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/35e6c414df8d157b3c41c36ca83f33af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h06RWkGI9BZVCjvjt0RmYw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pakata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae kv" href="https://unsplash.com/s/photos/computer-hardware?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="60a2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">简介</strong></h1><p id="1e91" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">世界上有越来越多的加速器。这就提出了一个问题，各种生态系统将如何进化，以允许程序员利用这些加速器。在更高的抽象层次上，像Tensorflow和PyTorch这样的领域特定层为底层硬件提供了很好的抽象。然而，对于那些维护没有这种抽象的与硬件对话的代码的开发人员来说，挑战仍然存在。多种底层硬件架构都支持的一种解决方案是C++和SYCL。以下是克罗诺斯集团<a class="ae kv" href="https://www.khronos.org/sycl/" rel="noopener ugc nofollow" target="_blank">网页</a>对SYCL的描述:</p><blockquote class="mk ml mm"><p id="28d5" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">SYCL(发音为“镰刀”)是一个免版税的跨平台抽象层，支持使用标准ISO C++编写异构处理器的代码，应用程序的主机和内核代码包含在同一个源文件中。</p></blockquote><p id="4a33" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">这听起来很不错，假设你:</p><ol class=""><li id="d92d" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">对学习类似C++的语言感到舒服吗</li><li id="f489" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">想要不受底层硬件供应商束缚的灵活性吗</li><li id="3c4e" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">您正在从头开始编写代码</li></ol><p id="1131" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">由于在栈的这个层次编程的人已经在使用C++，可以肯定地说第一个假设是合理的，如果你还在阅读，我也会假设第二个。然而，第三点往往不是这样。在本文的其余部分，我们将讨论如何获取CUDA代码，将其迁移到SYCL，然后在多种类型的硬件上运行，包括NVIDIA GPU。</p><p id="4f69" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">为了测试其可行性，我们将使用一系列免费工具，包括SYCLomatic、oneAPI Base Toolkit和Codeplay oneAPI for CUDA compiler。有关这些工具支持的CUDA版本的信息，请参阅<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/articles/release-notes/release-notes-for-intel-dpcpp-compatibility-tool.html" rel="noopener ugc nofollow" target="_blank">英特尔DPC++兼容性工具发行说明</a>和<a class="ae kv" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/GetStartedGuide.md#build-dpc-toolchain-with-support-for-nvidia-cuda" rel="noopener ugc nofollow" target="_blank"> oneAPI for CUDA入门指南</a>。</p><p id="e73c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">作为参考，我使用我个人的英特尔Alder Lake Core i9–12900 KF外星人R13系统和3080Ti GPU。我的软件栈是Windows 11 Pro系统，我正在利用Linux的Windows子系统(WSL)在Ubuntu 20.04中开发。</p><h1 id="bf3b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">将CUDA迁移到SYCL </strong></h1><p id="4f44" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">CUDA通常用于在GPU上进行通用计算编程。缺点是它只能在NVIDIA GPUs上运行。为了帮助从CUDA迁移到SYCL，我们将利用<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compatibility-tool.html" rel="noopener ugc nofollow" target="_blank">英特尔DPC++兼容性工具</a>。请注意，英特尔开源了DPC++兼容性工具背后的技术，以进一步提升将更多基于SYCL的应用移植到<a class="ae kv" href="https://github.com/oneapi-src/SYCLomatic" rel="noopener ugc nofollow" target="_blank"> SYCLomatic </a>项目中的能力。</p><p id="2bc7" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">Stackoverflow和英特尔开发人员专区上已经发布了一篇很好的文章，介绍了如何从cuda-samples GitHub存储库中获取jacobiCudaGraphs实现并迁移代码，因此我不需要重新键入，只需在此处链接即可。</p><div class="nk nl gp gr nm nn"><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/cuda-sycl-migration-jacobi-iterative-method.html" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">将Jacobi迭代法从CUDA移植到SYCL</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这个文档演示了一个用CUDA*编写的线性代数Jacobi迭代方法如何移植到SYCL*…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.intel.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kp nn"/></div></div></a></div><p id="e28d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">注意，如果你只是想看看Codeplay的oneAPI for CUDA编译器如何为SYCL代码工作，你可以跳过本教程，在GitHub上的oneAPI-Samples库中查看最终代码<a class="ae kv" href="https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC%2B%2B/DenseLinearAlgebra/jacobi_iterative" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="23bd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">在各种硬件上测试SYCL</strong></h1><p id="5ba7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦迁移到SYCL代码，您应该能够在各种硬件上运行它。让我们来测试一下，好吗？为了更容易地完成本演练，您可以查看oneAPI-samples目录，其中已经包含了迁移的代码:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/oneapi-src/oneAPI-samples" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">GitHub-oneapi-src/oneAPI-Samples:英特尔oneAPI工具包示例</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">oneAPI样本库为英特尔oneAPI工具包提供代码样本。我们建议查看特定的…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob kp nn"/></div></div></a></div><p id="6c32" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">有一点需要注意，在oneAPI-samples中，jacobi.h的NROWS值是1024，而不是512。如果您使用的是预装样品，您可能需要手动更新，以便进行比较。</p><p id="3c30" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">为了便于比较，下面是我按照<a class="ae kv" href="https://github.com/NVIDIA/cuda-samples/tree/master/Samples/3_CUDA_Features/jacobiCudaGraphs" rel="noopener ugc nofollow" target="_blank"> cuda-sample </a>指令构建并运行代码时的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/773975ab95e5f7d6d6730335d465c9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcBq9LkhDG4-oJhdxYJl6g.png"/></div></div></figure><h1 id="3f8b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">CPU上的SYCL</strong></h1><p id="1161" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">英特尔在oneAPI基础工具包中提供了一个基于SYCL的编译器，可从以下网址获得:</p><div class="nk nl gp gr nm nn"><a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit-download.html" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">下载英特尔oneAPI基础工具包</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">选择您的操作系统、分销渠道，然后下载您定制的英特尔oneAPI安装。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.intel.com</p></div></div><div class="nw l"><div class="oe l ny nz oa nw ob kp nn"/></div></div></a></div><p id="dae7" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">因为我用的是Ubuntu，所以我只是按照说明做了一个基于APT的安装。确保通过运行以下命令将编译器路径添加到您的工作区:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="3b2e" class="ok kx iq og b gy ol om l on oo">&gt; source /opt/intel/oneapi/setvars.sh</span></pre><p id="d845" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">然后，我转到oneAPI-samples/direct programming/dpc++/DenseLinearAlgebra/jacobi _ iterative/SYCL _ dpct _ migrated/src目录，并使用英特尔DPC++ SYCL编译器编译代码:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="0066" class="ok kx iq og b gy ol om l on oo">&gt; dpcpp -o jacobiSyclCPU main.cpp jacobi.cpp -I ../Common/</span></pre><p id="25db" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">请注意，的包含../Common来自SYCLomatic工作流，它创建了一些助手文件来支持我从CUDA到SYCL的迁移。在这种情况下，我的可执行文件是jacobiSyclCPU，所以让我们试一试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/5efbc89b5a1ef9f4db4e57f7c3fa11f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nf5DonEcV6xJDUvA0fNztg.png"/></div></div></figure><p id="4a75" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">查看输出时，需要考虑几个因素:</p><ol class=""><li id="e68e" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">SYCL版本的代码是用英特尔的DPC++编译器编译的，cuda示例代码是用GNU编译器编译的。</li><li id="1567" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">迁移后的SYCL代码最初是为GPU并行化的，现在运行在CPU上，比代码的序列化版本要慢。这是因为序列化版本不需要内存缓冲设置和同步。</li><li id="e6de" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">文本“GPU ***”是不正确的，因为我只是迁移了代码，并没有更改文本来反映我在这种情况下的目标是CPU。</li></ol><h1 id="b1db" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">NVIDIA GPU上的SYCL</strong></h1><p id="6222" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">既然我们已经看到我们可以在CPU上运行SYCL代码，让我们做一些更有趣的事情，看看我们是否可以在我的GPU上运行迁移后的代码。</p><p id="21bb" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">第一步是从Codeplay安装<a class="ae kv" href="https://www.codeplay.com/solutions/oneapi/for-cuda/" rel="noopener ugc nofollow" target="_blank"> oneAPI for CUDA编译器</a>。我按照他们的说明安装并构建了编译器，为了方便起见，这里做了内联:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="be5e" class="ok kx iq og b gy ol om l on oo">git clone <a class="ae kv" href="https://github.com/intel/llvm.git" rel="noopener ugc nofollow" target="_blank">https://github.com/intel/llvm.git</a> -b sycl<br/>cd llvm<br/>python ./buildbot/configure.py --cuda -t release --cmake-gen “Unix Makefiles”<br/>cd build<br/>make sycl-toolchain -j `nproc`<br/>make install</span></pre><p id="7b39" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> WSL2提示</strong></p><p id="93b1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">顺便提一下，在安装的时候，我注意到它运行得非常慢，有一点询问，问题是我是在Windows文件系统上运行我的WSL编译，而不是WSL ext4文件系统。移动到本地文件系统会使速度成倍提高，这是一个很好的技巧。要了解更多细节，请查看这里的一些WSL文件系统基准。它有点旧，但似乎仍然相关:</p><p id="71ff" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><a class="ae kv" href="https://vxlabs.com/2019/12/06/wsl2-io-measurements/" rel="noopener ugc nofollow" target="_blank">https://vxlabs.com/2019/12/06/wsl2-io-measurements/</a></p><h2 id="0224" class="ok kx iq bd ky oq or dn lc os ot dp lg lx ou ov li mb ow ox lk mf oy oz lm pa bi translated">【CUDA的编译和运行</h2><p id="9954" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">随着我的编译器安装，我准备编译运行在NVIDIA GPU上。由于迁移代码是如何生成的，我需要在我的路径中包含来自oneAPI DPC++编译器和Codeplay编译器的文件:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="dc12" class="ok kx iq og b gy ol om l on oo">&gt; source /opt/intel/oneapi/setvars.sh<br/>&gt; export PATH=/home/etmongko/llvm/build/bin:$PATH<br/>&gt; export LD_LIBRARY_PATH=/home/etmongko/llvm/build/lib:$LD_LIBRARY_PATH</span></pre><p id="145f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在，我运行Codeplay编译器来生成支持CUDA的二进制文件:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="e73f" class="ok kx iq og b gy ol om l on oo">&gt; clang++ -fsycl -fsycl-targets=nvptx64-nvidia-cuda -DSYCL_USE_NATIVE_FP_ATOMICS -o jacobiSyclCuda main.cpp jacobi.cpp -I ../Common/</span></pre><p id="afc4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">这生成了jacobiSyclCuda二进制文件。让我们试一试！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/01ac7063eddba96ef81e355827c7f9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYVLvSt9J9vfmIUWQ6pEJg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">嗯，不好</p></figure><p id="5cb4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">哎哟！一个分段错误，不是一个好的开始。好消息是，我稍微调试了一下就发现了这个问题。在我的路径中有oneAPI和Codeplay库，这导致了一些问题。为了解决这个问题，我打开了一个新的终端，然后简单地运行:</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="6556" class="ok kx iq og b gy ol om l on oo">&gt; export LD_LIBRARY_PATH=/home/etmongko/llvm/build/lib:$LD_LIBRARY_PATH</span></pre><p id="75e4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">只包含代码库。经过这个简单的调整，SYCL代码在我的GPU上运行没有任何问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/dc743827ac9e60f8ce31773b27c5615b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALUaZK5q_xvWYXeLaRX-yw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有用！</p></figure><p id="332a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">耶！我们可以看到，CPU时间与基准示例相似，GPU部分明显快于第二个示例中使用CPU作为加速器的情况。然而，性能与本地CUDA实现不太一样。这并不意外，因为这只是从CUDA到SYCL的简单迁移，没有任何优化。</p><h1 id="e77b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">结论</strong></h1><p id="752d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">带有SYCL代码的C++可以在多个后端编译运行。在这种情况下，我们通过CPU和NVIDIA GPU的例子，但SYCL的好处是它允许我们利用其他后端。作为预告，下周我将使用一台全新的基于英特尔Arc A370M的笔记本电脑测试开发人员工作流，因此我们将看到SYCL如何支持多个供应商后端。</p><p id="9c72" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">作为一名开发人员，我认为与硬件无关的解决方案的一致性最终会让我们的生活变得更容易，我们只需要实现这一点。从CUDA迁移到SYCL并不简单，但是有很多社区支持它，工具也在不断改进。</p><p id="89d8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">如果随着新硬件的出现，你可以在它上面运行你的代码，如果它碰巧更快、更节能或更经济的话，那不是很好吗？这是另一个时间和讨论的问题，但这是一个很好的想法。</p><pre class="kg kh ki kj gt of og oh oi aw oj bi"><span id="bdd0" class="ok kx iq og b gy ol om l on oo"><strong class="og ir">Want to Connect?</strong></span><span id="e523" class="ok kx iq og b gy pd om l on oo">If you want to see what random tech news I’m reading, you can <a class="ae kv" href="https://twitter.com/tonymongkolsmai" rel="noopener ugc nofollow" target="_blank">follow me</a> on Twitter.</span><span id="f66a" class="ok kx iq og b gy pd om l on oo">Tony is a Software Architect and Technical Evangelist at Intel. He has worked on several software developer tools and most recently led the software engineering team that built the data center platform which enabled Habana’s scalable MLPerf solution.</span><span id="a450" class="ok kx iq og b gy pd om l on oo">Intel, the Intel logo and other Intel marks are trademarks of Intel Corporation or its subsidiaries. SYCL is a trademark of the Khronos® Group. Other names and brands may be claimed as the property of others.</span></pre></div></div>    
</body>
</html>