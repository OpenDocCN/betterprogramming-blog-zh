<html>
<head>
<title>The Walrus Operator in Python 3.8: A Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.8中的Walrus算子:初级读本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-walrus-operator-in-python-3-8-a-primer-f0156ad80948?source=collection_archive---------5-----------------------#2021-09-07">https://betterprogramming.pub/the-walrus-operator-in-python-3-8-a-primer-f0156ad80948?source=collection_archive---------5-----------------------#2021-09-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e8ff" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">知道如何使用它</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8c83fb5220e281b485353e9e53823ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g6fngVpFSAPY7UAd"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@element5digital?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">元素5数码</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="133e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管作为2018年<a class="ae kz" href="https://docs.python.org/3/whatsnew/3.8.html" rel="noopener ugc nofollow" target="_blank"> Python 3.8 </a>版本中引入的最受关注的功能之一，walrus运算符(<code class="fe lw lx ly lz b">:=</code>)对许多Python程序员来说仍然相当陌生。</p><p id="673b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它独特的名字第一次引起了我的注意，我想进一步了解它。虽然理解它的概念相对简单，但我花了一些时间来思考如何在实际用例中应用它。</p><p id="de13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，主要的焦点是基于我以前的一些经验来分享walrus操作符的应用程序。希望你会发现它们对你的理解有用。</p><h1 id="3e5a" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">它是如何工作的？</h1><p id="bcc9" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在开始潜在的用例之前，让我先为那些不熟悉这个操作符的人简单介绍一下这个操作符。根据定义，walrus运算符<code class="fe lw lx ly lz b">:=</code>将值赋给变量，作为更大表达式的一部分。</p><p id="4947" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看它的实际应用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Walrus操作符，通过结合赋值和if表达式步骤。</p></figure><p id="ebd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意赋值步骤(<code class="fe lw lx ly lz b">n= len(list)</code>)和if表达式(<code class="fe lw lx ly lz b">n&lt;10</code>)是如何变成代码中的一个步骤的。这就是为什么它也被称为赋值表达式，以更好地反映其功能。</p><p id="5899" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:walrus操作符两边的括号非常重要！</p><pre class="kk kl km kn gu mz lz na nb aw nc bi"><span id="e2cb" class="nd mb iu lz b gz ne nf l ng nh">if n := len(lst) &lt; 10:   ## n= True</span></pre><p id="e9f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面没有括号的表达式中，<code class="fe lw lx ly lz b">n</code>保存的是<code class="fe lw lx ly lz b">True</code>的值，而不是列表的长度<code class="fe lw lx ly lz b">3</code>。</p><h1 id="eb56" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">如何使用Walrus运算符</h1><p id="4741" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">如前所述，让我们看一些如何使用walrus操作符的例子。</p><h2 id="733d" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">检查用户输入(if语句)</h2><p id="aab1" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">下面是另一个带有if语句的例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="0936" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，您可能会注意到，只允许一种猜测并不是一个很好的例子。</p><h2 id="2e1b" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">验证用户尝试(while-loop)</h2><p id="40a4" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在这个例子中，用户将得到提示，直到输入与<code class="fe lw lx ly lz b">valid_users</code>列表中的有效名称匹配。只有这样，才会打印出欢迎信息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="fc46" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意<code class="fe lw lx ly lz b">user_answer= input()</code>在我们的普通代码块中是如何重复的。我希望你会同意带<code class="fe lw lx ly lz b">:=</code>的第二块更干净。</p><p id="f1cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯…也许我应该限制尝试的次数？</p><h2 id="d2e2" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">读取文件</h2><p id="7d92" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">类似地，在<code class="fe lw lx ly lz b">while</code>循环中实现操作符可能如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="a1fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当读取一个文件并打印文件中的行时，你不需要在代码中重复<code class="fe lw lx ly lz b">line = fp.readline()</code>和<code class="fe lw lx ly lz b">while</code>循环的迭代。</p><h2 id="d77c" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">列表理解</h2><p id="d882" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在这个例子中，我们没有重复使用<code class="fe lw lx ly lz b">x**2</code>，而是将变量<code class="fe lw lx ly lz b">square</code>命名为<code class="fe lw lx ly lz b">x**2</code>，并重用<code class="fe lw lx ly lz b">square</code>作为存储在列表中的返回元素。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="a4cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们有一个很长的列表和一个复杂的函数(操作)时，这特别方便。</p><p id="a2cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设我们有一个计算量非常大的函数。在传统方法中，列表中的每个值将被计算两次:一次是针对条件，一次是针对列表中的返回值(如果满足条件)。</p><pre class="kk kl km kn gu mz lz na nb aw nc bi"><span id="26fd" class="nd mb iu lz b gz ne nf l ng nh">[complex_func(x) for x in numbers if complex_function(x) &gt; 100]</span></pre><p id="1383" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用赋值表达式，<code class="fe lw lx ly lz b">:=</code>被赋值的变量将只被计算一次。</p><h2 id="5053" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">字符串格式</h2><p id="d7f3" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">您可以使用赋值表达式作为函数<code class="fe lw lx ly lz b">format()</code>的参数的一部分，而不是预先赋值<code class="fe lw lx ly lz b">x=4</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="2585" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，有些人认为这实际上可能会降低可读性。我的观点是不要过度使用它，这样你的代码变得不可读。</p><h2 id="2d52" class="nd mb iu bd mc ni nj dn mg nk nl dp mk lj nm nn mm ln no np mo lr nq nr mq ns bi translated">正则表达式</h2><p id="bc86" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">在最后一个例子中，您可以将这个操作符与正则表达式(regex)一起使用来识别任何模式匹配。这里有一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><h1 id="bce0" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">摘要</h1><p id="9c98" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">walrus操作符<code class="fe lw lx ly lz b">:=</code>(赋值操作符)是一个帮助Python程序员的特性:</p><ul class=""><li id="6679" class="nt nu iu lc b ld le lg lh lj nv ln nw lr nx lv ny nz oa ob bi translated">避免重复的代码行</li><li id="ade8" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">重新使用计算开销很大的值</li><li id="5447" class="nt nu iu lc b ld oc lg od lj oe ln of lr og lv ny nz oa ob bi translated">用紧凑代码提高可读性(视情况而定。不要过度使用)</li></ul><p id="2486" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您花时间阅读我的文章。你可以在<a class="ae kz" href="https://www.linkedin.com/in/jia-wei-teh/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>