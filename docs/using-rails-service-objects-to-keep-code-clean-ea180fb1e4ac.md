# 使用 Rails 服务对象保持代码整洁

> 原文：<https://betterprogramming.pub/using-rails-service-objects-to-keep-code-clean-ea180fb1e4ac>

## 在本文中，我们将了解什么是 Rails 服务对象，以及如何使用它们来使您的应用程序更加整洁并保持可维护性。

![](img/4030a8303900d9757033948f8c0a6f9a.png)

如果您正在使用 Ruby on Rails 开发 web 应用程序，您可能已经知道 Rails 是一个 MVC(模型-视图-控制器)框架，这意味着您的模型负责数据，视图负责模板，控制器负责请求处理。

但是你的应用程序越大，它的功能就越多——你的商业逻辑就越多。问题来了，你把你的商业逻辑放在哪里？显然，不是视图应该处理它。控制器还是模型？这将使他们很快变得肥胖和不可读。这就是服务对象来救援的地方。在这篇文章中，我们将了解什么是服务对象，以及如何使用它们来使你的应用程序更加整洁和可维护。

假设您有一个处理出租车行程的项目，我们将看看特定的控制器动作，它更新行程记录。但是它不仅应该基于用户输入参数(例如，起始地址、目的地地址、乘客数量等)更新行程。)，但它也应该根据那些参数计算一些字段，并将其保存到数据库中。因此，我们有这样一个控制器动作:

这里的问题是，您已经向控制器添加了至少十行代码，但是这些代码并不真正属于控制器。此外，如果您想要更新另一个控制器中的行程，例如通过从 csv 文件导入它们，您将不得不重复并重写这段代码。或者您创建一个服务对象，即`TripUpdateService`，并在任何需要更新行程的地方使用它。

# 什么是服务对象？

基本上，服务对象是一个普通的老式 Ruby 对象(“PORO”)，一个返回可预测响应的 Ruby 类，被设计用来执行一个单一的动作。所以它封装了一部分业务逻辑。

服务对象的工作是封装功能，执行一项服务，并提供单点故障。使用服务对象还可以防止开发人员在应用程序的不同部分使用相同的代码时不得不反复编写代码。

所有的服务对象都应该有三样东西:

*   一种初始化方法
*   单一公共方法
*   执行后返回可预测的响应

让我们通过调用用于行程更新的服务对象来替换我们的控制器逻辑:

看起来干净多了，对吧？现在让我们来看看如何实现一个服务对象。

# 实现服务对象

在一个 Rails 应用程序中，有两个文件夹常用于存储服务对象:`lib/services`和`app/services`。

基本上你可以选择任何你想要的，但是在这篇文章中我们将使用`app/services`。

所以我们将在`app/services/trip_update_service.rb`中添加一个新的 Ruby 类(我们的服务对象):

好的，服务对象被添加，现在你可以在你的应用程序中的任何地方调用`TripUpdateService.new(trip, params).update_trip`，它将工作。Rails 会自动加载这个对象，因为它会自动加载`app/`文件夹下的所有内容。

这看起来已经很干净了，但我们实际上可以做得更好。我们可以让服务对象在被调用时自己执行，这样我们可以更短地调用它。如果我们想为其他服务对象重用这个行为，我们可以添加一个名为`BaseService`或`ApplicationService`的新类，并为我们的`TripUpdateService`继承它:

因此，这个名为`call`的类方法创建了一个服务对象的新实例，并向其传递参数或块，然后在该实例上调用`call`方法。然后我们需要让我们的服务继承`BaseService`并实现`call`方法:

然后，让我们更新控制器操作，以正确调用服务对象:

# 你应该把你的服务对象放在哪里

正如我们之前讨论的，存储服务对象的两个基本文件夹是:`lib/services`和`app/services`，你可以使用任何你想要的。存储服务对象的另一个好的实践是将它们存储在不同的名称空间下，也就是说，您可以有`TripUpdateService`、`TripCreateService`、`TripDestroyService`、`SendTripService`等等。

但它们的共同点是都与旅行有关。因此，我们可以将它们放在`app/services/trips`文件夹下，换句话说，放在`trips`名称空间下:

在调用这些服务时，不要忘记使用新的名称空间，即`Trips::TripUpdateService.call(trip, params)`、`Trips::SendTripService.call(trip, params)`。

# 将您的代码包装在一个事务中

如果您的服务对象要对不同的对象执行多次更新，您最好将其包装在一个事务块中。

在这种情况下，如果任何服务对象方法失败，Rails 将回滚事务(即所有执行的数据库更改)。这是一个很好的实践，因为它可以在出现故障时保持数据库的一致性。

这是一个在单个事务中更新多个记录的简单示例。如果任何更新因异常而失败(例如，无法归档路由，changelog 创建失败)，事务将回滚，数据库将处于一致状态。

# 向服务对象传递数据并返回响应

基本上你可以传递给你的服务对象几乎任何东西，取决于它们执行的操作:`ActiveRecord`对象、散列、数组、字符串、整数等等。但是您应该总是将最少量的数据传递给服务对象。

比如你要更新一个 trip，你要传递 trip 对象和 params hash，但是不要传递整个`params` hash，因为它会包含很多不必要的数据。所以你应该只传递你需要的数据，也就是`TripUpdateService.call(trip, trip_params)`。

服务对象可以执行复杂的操作。它们可以用来修改数据库中的记录、发送电子邮件、执行计算或调用 3d party APIs。所以在这些操作过程中很有可能会出错。这就是为什么从您的服务对象返回一个响应是一个好的做法。您可以返回一个布尔值，或者一个带有布尔值和一些附加数据的散列。例如，如果您想要更新一个行程，您可以返回一个布尔值来指示该行程是否被成功更新，您还可以返回 trip 对象本身，这样您就可以在您的控制器操作中使用它。

不过，您应该记住的是，来自服务对象的响应应该是可预测的。无论如何，它应该总是返回相同的响应。所以如果你返回一个布尔值，它应该总是返回一个布尔值，如果你返回一个散列，它应该总是返回一个具有相同键的散列。这将使您的服务对象更容易预测和测试。

# 使用服务对象有什么好处？

服务对象是将应用程序逻辑从控制器中分离出来的一个很好的方法。您可以使用它们来分离关注点，并在应用程序的不同部分重用它们。使用这种模式，您可以获得多种好处:

*   **清洁控制器。**控制者不应该处理业务逻辑。它应该只负责处理请求，并将请求参数、会话和 cookies 转换成传递给服务对象以执行操作的参数。然后根据服务响应执行重定向或呈现。
*   **更简单的测试。业务逻辑与服务对象的分离也允许你独立地测试你的服务对象和你的控制器。**
*   **可重用的服务对象。**可以从 app 控制器、后台作业、其他服务对象等调用服务对象。每当您需要执行类似的操作时，您可以调用服务对象，它将为您完成这项工作。
*   **关注点分离。** Rails 控制器只能看到服务，并使用它们与域对象进行交互。这种耦合性的降低使得可伸缩性变得更加容易，尤其是当您想要从整体服务转移到微服务时。您的服务可以很容易地提取出来，并以最小的修改转移到一个新的服务。

# 服务对象最佳实践

*   **给 rails 服务对象命名时，要让它们的功能显而易见。**服务对象的名称必须表明它是做什么的。以我们的 trips 为例，我们可以将服务对象命名为:`TripUpdateService`、`TripUpdater`、`ModifyTrip`等。
*   **服务对象应该有单独的公共方法。**其他方法必须是私有的，并且只能在特定的服务对象中访问。您可以按照自己的方式调用这个公共方法，只要保持一致并对所有服务对象使用相同的命名即可。
*   **在公共名称空间下对服务对象进行分组。如果你有很多服务对象，你可以把它们放在公共名称空间下。例如，如果您有很多与旅行相关的服务对象，您可以将它们分组到`Trips`名称空间下，即`Trips::TripUpdateService`、`Trips::TripDestroyService`、`Trips::SendTripService`等。**
*   **使用语法糖来调用你的服务对象。在你的`BaseService`或`ApplicationService`中使用 proc 语法，并在其他服务中继承它。然后你可以在你的服务对象类名上使用`.call`来执行一个动作，例如`TripUpdateService.call(trip, params)`**
*   **别忘了抢救异常。**当服务对象因异常而失败时，应对这些异常进行救助和妥善处理。它们应该不会向上传播到调用堆栈。如果在 rescue 块中无法正确处理异常，您应该引发特定于该特定服务对象的自定义异常。
*   **单一责任。试着对你的每个服务对象保持单一的责任。如果一个服务对象做了太多的事情，可以把它拆分成多个服务对象。**

# 结论

服务对象是将应用程序逻辑从控制器中分离出来的一个很好的方法。它们可以用来分离关注点，并在应用程序的不同部分重用它们。随着您添加越来越多的功能，这种模式可以使您的应用程序更易于测试和维护。

它还使您的应用程序更具可伸缩性，更容易从整体迁移到微服务。如果你以前没有用过服务对象，你一定要尝试一下。顺便说一下，Ruby on Rails 只用于这个例子，你可以在其他框架中使用相同的模式。

*最初发布于*[*https://ua leks . dev*](https://ualeks.dev/posts/service-objects/)