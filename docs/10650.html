<html>
<head>
<title>The Inelegant Part of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks的不雅部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-inelegant-part-of-react-hooks-d83a3052a8b?source=collection_archive---------2-----------------------#2022-01-20">https://betterprogramming.pub/the-inelegant-part-of-react-hooks-d83a3052a8b?source=collection_archive---------2-----------------------#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f98" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你真的喜欢它，你应该理解它的缺点。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3bb0094d4eb12586dc23ea7e5f20edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1n5hgvqW5-MD9QGQ85b6A.png"/></div></div></figure><p id="54c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从React 16.8版本正式发布钩子之后，React钩子在React生态系统中迅速流行起来。它解决了Mixins问题，并与功能组件和纤程架构实现了近乎完美的结合。</p><p id="3385" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是世界上没有十全十美的东西。无论你多么喜欢一个工具，你都必须了解这个工具的不足之处，以便更好地使用它。社区里已经有成吨的文章在赞美React Hooks，我不需要重复了。在这里，我将是坏人，谈论反应钩的不雅设计。</p><h1 id="8ed3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">不雅的命名规则</h1><p id="e38c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">先说一个简单的小问题，就是React要求我们在命名钩子的时候以<code class="fe mn mo mp mq b">use</code>开头。</p><p id="a40a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，这个要求是合理的，并且使得在我们的代码中区分钩子和普通函数更加容易。但在某些情况下会导致奇怪的命名，比如<code class="fe mn mo mp mq b">useAddToCart</code>、<code class="fe mn mo mp mq b">useFetchPosts</code>，不符合语法规则，读起来怪怪的。</p><h1 id="663f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">挂钩调用顺序的限制</h1><p id="b32c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在官方文档的钩子规则部分，我们被要求遵循这个规则:</p><blockquote class="mr ms mt"><p id="f61c" class="ku kv mu kw b kx ky ju kz la lb jx lc mv le lf lg mw li lj lk mx lm ln lo lp im bi translated">只调用顶层的钩子。不要在循环、条件或嵌套函数中调用钩子。</p></blockquote><p id="0d5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们可以编写这样的代码:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="8aef" class="nc lr it mq b gy nd ne l nf ng">const [name, setName] = useState('bytefish')<br/>const [age, setAge] = useState(30);<br/>const [job, setJob] = useState('frontend dev');</span></pre><p id="22d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们不应该这样写代码:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="d6d0" class="nc lr it mq b gy nd ne l nf ng">const [name, setName] = useState('bytefish')</span><span id="d1f0" class="nc lr it mq b gy nh ne l nf ng">if(Math.random() &gt; 0.5){<br/>  const [age, setAge] = useState(30);<br/>  const [job, setJob] = useState('frontend dev');<br/>}</span></pre><h2 id="f5b9" class="nc lr it bd ls ni nj dn lw nk nl dp ma ld nm nn mc lh no np me ll nq nr mg ns bi translated">它为什么会有这个规律？</h2><p id="d677" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">因为React在源代码中使用一个数组来存储组件的状态，并且每次组件被重新渲染时，它都按顺序读取这个数组。<br/> <br/>如果<code class="fe mn mo mp mq b">useState</code>在不同的重渲染中调用顺序不同，会导致变量和状态的不正确匹配。</p><p id="8904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，每次制作渲染器时，变量和状态都是这样匹配的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/99bc4ce3175261faac7505afddafecdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mN3Md2gxnJxz04Ery4g0UA.png"/></div></div></figure><p id="de3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果你像这样写代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d757" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在第一个渲染中，变量和状态如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5b2b8e2e0690e61867eb432b3b2fd8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAdlVaobbuNrrlAU7rTLJA.png"/></div></div></figure><p id="a2cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二次渲染时，由于判断语句的存在，变量的顺序发生了变化，但状态没有变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5e83cff7152cdccd00078cddf1b48e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UY02-2MgrkF838RL01c05A.png"/></div></div></figure><p id="54d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后错误发生了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b9ab57485507f69c04aa1be901244ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kr-I7TGgGh0wQdgakIXfNg.gif"/></div></div></figure><p id="7c7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现场演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx nv l"/></div></figure><h2 id="bf64" class="nc lr it bd ls ni nj dn lw nk nl dp ma ld nm nn mc lh no np me ll nq nr mg ns bi translated">不雅部分</h2><p id="0fe2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我说这个设计丑，主要是因为规则不直观。写JavaScript的时候，可以按照自己喜欢的任何顺序声明变量和赋值，不会影响最终结果。</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="f184" class="nc lr it mq b gy nd ne l nf ng">let age;<br/>let job;</span><span id="978a" class="nc lr it mq b gy nh ne l nf ng">if (Math.random() &gt; 0.5) {<br/>  age = 30<br/>  job = 'frontend dev'<br/>} else {<br/>  job = 'frontend dev'<br/>  age = 30;<br/>}</span><span id="3c3e" class="nc lr it mq b gy nh ne l nf ng">// it's ok</span></pre><p id="5932" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在React钩子中，突然要求我们按照固定的顺序调用钩子。</p><p id="2859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你去一个国家旅行，突然被当地警察逮捕。原因是:根据当地法律，人们不应该用左脚离开房子，而是用右脚。你因为先把左脚伸出门外而被捕。</p><p id="2395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会惊讶吗？如果当地法律不允许偷窃和抢劫，那么我们都可以理解，这是理所当然的。但是你能接受因为左脚踏出去而被逮捕吗？</p><p id="669c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到我们的问题。由于自身的设计缺陷，React Hook使得用户不得不依靠自己的经验来遵守这个奇怪的规则。</p><p id="d5cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，你可以使用类似<code class="fe mn mo mp mq b">eslint-plugin-react-hooks</code>这样的检查工具，但那终究没有解决底层问题。</p><p id="ce63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最理想的API应该是开发人员认知负担最小的。比如数学相关的函数，无论开发者调用什么环境，层次有多深，调用顺序是什么样的，只要参数符合要求，都可以正常工作。</p><blockquote class="ny"><p id="2e68" class="nz oa it bd ob oc od oe of og oh lp dk translated">React钩子已经失去了这种简单的美感。</p></blockquote><h1 id="b41f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz oi ka mc kc oj kd me kf ok kg mg mh bi translated">混淆使用效果</h1><p id="9c62" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">useEffect的传统写法是这样的:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="456d" class="nc lr it mq b gy nd ne l nf ng">const [value] =  useState(0)</span><span id="2cdd" class="nc lr it mq b gy nh ne l nf ng">React.useEffect(() =&gt; {</span><span id="c89c" class="nc lr it mq b gy nh ne l nf ng">  console.log("effect happen")</span><span id="a382" class="nc lr it mq b gy nh ne l nf ng">}, [value])</span></pre><p id="9485" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每次<code class="fe mn mo mp mq b">value</code>变化都会触发此效果。</p><p id="45e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我这样写呢？</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="c409" class="nc lr it mq b gy nd ne l nf ng">function App(){</span><span id="9342" class="nc lr it mq b gy nh ne l nf ng">  React.useEffect(() =&gt; {</span><span id="4b7c" class="nc lr it mq b gy nh ne l nf ng">    console.log("effect happen")</span><span id="5633" class="nc lr it mq b gy nh ne l nf ng">  }, [Date.now()])</span><span id="5dd6" class="nc lr it mq b gy nh ne l nf ng">  return &lt;div&gt;...&lt;/div&gt;<br/>}</span></pre><p id="1f03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你觉得这个效果什么时候会触发？我们知道时间总是在变化的，每次调用<code class="fe mn mo mp mq b">Date.now()</code>的返回值总是不同的。那么效果发生多少次会打印在控制台里呢？</p><p id="eb6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案是曾经。该效果在组件第一次渲染时触发一次，之后不会再触发。</p><p id="3bb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果你简单地把这个组件修改成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2433" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会发现，每点击一次按钮，上面的效果就会被触发一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/20727858d1a0ff08ffe66abb64a8a3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iUpk4XsNiFt-B7PAIY8wUw.gif"/></div></div></figure><p id="f915" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现场演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx nv l"/></div></figure><p id="34e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么会这样呢？这里其实有一个潜规则:只有组件被重新渲染，才有可能触发效果。</p><p id="2975" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一段代码中，初始渲染后不会触发重新渲染，因此效果不会再次触发。</p><p id="92bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二段代码中，如果我们点击按钮，<code class="fe mn mo mp mq b">count</code>会发生变化，会触发重新渲染，然后React会发现<code class="fe mn mo mp mq b">Date.now()</code>的返回值发生了变化，就会触发这个效果。</p><p id="3dde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是让我们看看这两段代码。其实<code class="fe mn mo mp mq b">useEffect</code>本身并没有被修改。唯一改变的是这个组件中是否存在另一个状态，但其行为不同。</p><p id="82c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种行为实际上很不自然:</p><ul class=""><li id="a0de" class="om on it kw b kx ky la lb ld oo lh op ll oq lp or os ot ou bi translated">首先，<code class="fe mn mo mp mq b">useEffect</code>的<code class="fe mn mo mp mq b">deps</code>参数允许我们在语法层面不使用state。但是当我们用普通变量作为它的<code class="fe mn mo mp mq b">deps</code>时，它不能及时感知因变量的变化。</li><li id="883a" class="om on it kw b kx ov la ow ld ox lh oy ll oz lp or os ot ou bi translated">然后，当<code class="fe mn mo mp mq b">useEffect</code>的主体保持不变，而我们只是改变了<code class="fe mn mo mp mq b">count</code>，却触发了效果。</li></ul><p id="d442" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我觉得这个设计很矛盾，很混乱。</p><p id="565b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bea6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里第二个效果不依赖于变量<code class="fe mn mo mp mq b">a</code>，但是<code class="fe mn mo mp mq b">a</code>的变化会导致第二个效果触发。虽然我们之前解释过这种行为，但是怎么说呢，还是显得有点奇怪。</p><p id="9228" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以从之前的CodeSanbox获得现场演示。</p><h1 id="55d6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">使用效果和组件安装</h1><p id="cd1f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">假设我们想在组件创建后向服务器请求一次数据，应该如何编写代码？</p><p id="6814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最直接的写法是这样的:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="10cc" class="nc lr it mq b gy nd ne l nf ng">const [data, setData] = useState(null)<br/>  <br/>function fetchData(){<br/>  console.log('suppose we are fetching data from server')<br/>  setData({<br/>    data: 'data from sever'<br/>  })<br/>}<br/>  <br/>fetchData()</span></pre><p id="5894" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是组件一直在重新渲染，所以这个函数会重复执行。为了避免这种情况，我们可以使用<code class="fe mn mo mp mq b">useEffect</code>。</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="69c7" class="nc lr it mq b gy nd ne l nf ng"><em class="mu">useEffect</em>(() =&gt; {<br/>  fetchData()<br/>}, [])</span></pre><p id="9c69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是问题又来了。这样写的话，效果的触发时机类似于componentDidMount，会在组件挂载后执行。<br/> <br/>但是如果组件渲染结构复杂，层次太深，DidMount会很晚，导致请求发送的很晚。</p><p id="75c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="62f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的测试中，效果等待了200毫秒才开始执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d58596cb8358b6d4f2ac1b357fda444a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_g0lKDbhUCAoiBOgL33Y4w.png"/></div></div></figure><p id="e494" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一些渲染逻辑复杂的项目中，延迟会更长。</p><p id="2f33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题的一个解决方案是使用<code class="fe mn mo mp mq b">useRef</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4e6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，可以快速发送请求，而不会导致重复调用的问题。</p><p id="e600" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我们最初的目的很简单:在组件创建后立即向服务器请求数据，但是您发现编写起来很不舒服。</p><p id="6e05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">useEffect，字面意思是当一个效果出现的时候就会被执行。同时，它可以依赖于某些状态，并在这些状态改变后被触发。看来我们可以用<code class="fe mn mo mp mq b">useEffect</code>作为状态监视器。但是在这里我们发现了它的另一种机制:当组件被挂载时，它将被触发一次。</p><p id="a2ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">状态的改变和组件生命周期应该是两回事，但是useEffect把这两个概念结合在了一起。这种设计也容易产生混乱。</p><h1 id="21e9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">最后的</h1><p id="f08b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这篇文章没有任何反对React钩子的意思。React挂钩有很多很棒的设计。事实上，我仍然在我的项目中大量使用钩子。</p><p id="80b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只是想和大家探讨一下Hooks中的一些问题，让大家更合理的使用。</p></div></div>    
</body>
</html>