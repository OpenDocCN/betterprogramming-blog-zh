<html>
<head>
<title>What Are *args and **kwargs in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的*args和**kwargs是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-args-and-kwargs-in-python-6aaf9e3cad73?source=collection_archive---------0-----------------------#2019-12-20">https://betterprogramming.pub/what-are-args-and-kwargs-in-python-6aaf9e3cad73?source=collection_archive---------0-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用可变长度的参数列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/702385e762cd457a21e0aac9003bffaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFRGP4jrkR0i9ODcI1Eaow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@headwayio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">车头时距</a>在<a class="ae ky" href="https://unsplash.com/s/photos/argument?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">挡泥板</a>上拍摄</p></figure><p id="43d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能就是生命，对吧？如果您是Python的新手——无论是全新的编码还是来自另一种语言——您将了解到函数定义中的参数数量与要传递的参数数量相匹配。</p><p id="d2a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是基础——它有助于理解这个世界。然而，一旦你在一个函数定义中看到<code class="fe lv lw lx ly b">*args</code>或<code class="fe lv lw lx ly b">**kwargs</code>，它也为你设置了早期的心理障碍。</p><p id="1df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要让语法吓到你。这些都不是超级特殊的参数。它们甚至没有那么花哨，我们将学习如何使用它们。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="56e5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">位置参数与关键字参数</h1><p id="3329" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了了解什么是<code class="fe lv lw lx ly b">*args</code>和<code class="fe lv lw lx ly b">**kwargs</code>，我们需要区分两个概念。</p><p id="2d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先是位置参数和关键字参数之间的区别。在最基本的函数中，我们玩一个匹配游戏——参数1和参数1一起使用，参数2和参数2一起使用，以此类推。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e3db" class="nh mh it ly b gy ni nj l nk nl">def printThese(a,b,c):<br/>   print(a, "is stored in a")<br/>   print(b, "is stored in b")<br/>   print(c, "is stored in c")</span><span id="fcb3" class="nh mh it ly b gy nm nj l nk nl">printThese(1,2,3)<br/>"""<br/>1 is stored in a<br/>2 is stored in b<br/>3 is stored in c<br/>"""</span></pre><p id="06e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个参数都是必需的。缺少一个将导致错误。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ecc0" class="nh mh it ly b gy ni nj l nk nl">def printThese(a,b,c):<br/>   print(a, "is stored in a")<br/>   print(b, "is stored in b")<br/>   print(c, "is stored in c")</span><span id="31bf" class="nh mh it ly b gy nm nj l nk nl">printThese(1,2)<br/>"""<br/>TypeError: printThese() missing 1 required positional argument: 'c'<br/>"""</span></pre><p id="e3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在函数定义中给一个参数一个默认值，那么它就变成可选的了。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dae9" class="nh mh it ly b gy ni nj l nk nl">def printThese(a,b,c=None):<br/>   print(a, "is stored in a")<br/>   print(b, "is stored in b")<br/>   print(c, "is stored in c")</span><span id="f9bd" class="nh mh it ly b gy nm nj l nk nl">printThese(1,2)<br/>"""<br/>1 is stored in a<br/>2 is stored in b<br/>None is stored in c<br/>"""</span></pre><p id="5e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这些可选参数也可以用关键字限定，这意味着您可以在函数调用中指定参数名来相应地映射它。</p><p id="f1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将所有三个变量都默认为<code class="fe lv lw lx ly b">None</code>，看看我们如何仍然可以映射它们，而不管它们的顺序如何。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b76a" class="nh mh it ly b gy ni nj l nk nl">def printThese(a=None,b=None,c=None):<br/>   print(a, "is stored in a")<br/>   print(b, "is stored in b")<br/>   print(c, "is stored in c")</span><span id="3b8f" class="nh mh it ly b gy nm nj l nk nl">printThese(c=3, a=1)<br/>"""<br/>def printThese(a=None,b=None,c=None):<br/>   print(a, "is stored in a")<br/>   print(b, "is stored in b")<br/>   print(c, "is stored in c")</span><span id="2b3b" class="nh mh it ly b gy nm nj l nk nl">printThese(c=3, a=1)<br/>"""<br/>1 is stored in a<br/>None is stored in b<br/>3 is stored in c<br/>"""</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3e00" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Splat运算符</h1><p id="23fd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我想说我喜欢这个操作符的名字——它太…直观了。<code class="fe lv lw lx ly b">*</code>通常与乘法相关联，但是在Python中，它还兼作splat操作符。</p><p id="fa80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这个操作者是一个piata。我已经将spread操作符——相当于splat的JavaScript描述为拆开一系列多米诺骨牌以形成一个更大的序列，但是splat需要一个更有力的类比。</p><p id="dc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的例子将使这一点更加清楚。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="172a" class="nh mh it ly b gy ni nj l nk nl">a = [1,2,3]<br/>b = [*a,4,5,6]</span><span id="50a2" class="nh mh it ly b gy nm nj l nk nl">print(b) # [1,2,3,4,5,6]</span></pre><p id="6291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码示例中，我们获取<code class="fe lv lw lx ly b">a</code>的内容并将其分散(解包)到新列表<code class="fe lv lw lx ly b">b</code>中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fda0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何使用*args和**kwargs</h1><p id="9ed1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">所以我们知道splat操作符解包多个值，并且有两种类型的函数参数。好吧，如果你到现在还没想明白，<code class="fe lv lw lx ly b">*args</code>是参数的简称，<code class="fe lv lw lx ly b">**kwargs</code>是关键字参数的简称。</p><p id="1805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一个都用于解包它们各自的参数类型，允许使用可变长度的参数列表进行函数调用。例如，让我们创建一个函数来打印学生的考试成绩。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="edb5" class="nh mh it ly b gy ni nj l nk nl">def printScores(student, *scores):<br/>   print(f"Student Name: {student}")<br/>   for score in scores:<br/>      print(score)</span><span id="4e63" class="nh mh it ly b gy nm nj l nk nl">printScores("Jonathan",100, 95, 88, 92, 99)<br/>"""<br/>Student Name: Jonathan<br/>100<br/>95<br/>88<br/>92<br/>99<br/>"""</span></pre><p id="0d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喔，等等。我没给它起名<code class="fe lv lw lx ly b">*args</code>？没错，“args”是一个标准约定，但仍然只是一个名称。在<code class="fe lv lw lx ly b">*args</code>中，这个秘密被揭示了，单个星号是真正的玩家，它创建了一个列表，其内容是函数调用中的位置参数——在那些被定义的参数之后。</p><p id="12c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完后，<code class="fe lv lw lx ly b">**kwargs</code>应该是个容易消化的东西。名称并不重要，但是双星号创建了一个字典，它的内容是来自函数调用的关键字参数(在那些定义之后)。</p><p id="842b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，让我们创建一个函数来打印一个人的宠物的名字。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c2b0" class="nh mh it ly b gy ni nj l nk nl">def printPetNames(owner, **pets):<br/>   print(f"Owner Name: {owner}")<br/>   for pet,name in pets.items():<br/>      print(f"{pet}: {name}")</span><span id="b542" class="nh mh it ly b gy nm nj l nk nl">printPetNames("Jonathan", dog="Brock", fish=["Larry", "Curly", "Moe"], turtle="Shelldon")</span><span id="e40c" class="nh mh it ly b gy nm nj l nk nl">"""<br/>Owner Name: Jonathan<br/>dog: Brock<br/>fish: ['Larry', 'Curly', 'Moe']<br/>turtle: Shelldon<br/>"""</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9df8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">离别赠言</h1><p id="f571" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一些有助于你避免常见陷阱和扩大知识面的智慧之言。</p><ul class=""><li id="fcc9" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">使用<code class="fe lv lw lx ly b">*args,</code> <code class="fe lv lw lx ly b">**kwargs</code>作为捕捉位置和关键字参数的标准约定</li><li id="ba77" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">不能将<code class="fe lv lw lx ly b">**kwargs</code>放在<code class="fe lv lw lx ly b">*args</code>之前，否则会出现错误</li><li id="d5b4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当心关键字参数和<code class="fe lv lw lx ly b">**kwargs</code>之间的冲突，这里的值应该作为<code class="fe lv lw lx ly b">**kwarg</code>传递，但却不知道是关键字参数的名称</li><li id="7431" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">您也可以在函数调用中使用splat运算符</li></ul></div></div>    
</body>
</html>