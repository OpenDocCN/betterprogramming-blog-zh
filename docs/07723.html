<html>
<head>
<title>5 Programming Languages You Can Learn in 10 Minutes-ish</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可以在10分钟左右学会5种编程语言</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-programming-languages-you-can-learn-in-10-minutes-ish-66f77e2f815b?source=collection_archive---------5-----------------------#2021-02-12">https://betterprogramming.pub/5-programming-languages-you-can-learn-in-10-minutes-ish-66f77e2f815b?source=collection_archive---------5-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要成为每一种语言的专家，但是理解基本原理肯定会有所帮助</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff696110cae8f2c0ed7abc4a07418123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO5XXRB5X4CUX04gutlTkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄的照片</p></figure><p id="0fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习不同的语言——即使你不打算主动使用它们——对任何开发人员来说都是很好的实践。这是因为如果你把大部分时间花在一项技术上，你将会错过在其他地方可能发现的任何潜在的改进。</p><p id="0194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我的意思:这并不是说要掌握每一种语言——这既不实际也不可能。但是谁能说你没有错过一些函数式编程实践，因为直到现在你只关注面向对象的选择？</p><p id="a93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，本着我最喜欢的<a class="ae ky" href="https://medium.com/pragmatic-programmers/table-of-contents-bf907a514a34" rel="noopener">编程书籍之一</a>的精神，我挑选了五种编程语言供你回顾。</p><p id="7fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使它们不适用于你的日常生活，也要检查一下，看看它们能做些什么。他们可能会让你大吃一惊。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce97" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Java Script语言</h1><p id="1dac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我选择了<a class="ae ky" href="https://www.javascript.com/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>作为第一个，因为不是每个人都在网络部门工作。即使在it内部，也不是每个后端开发人员都使用Node。</p><p id="ca39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript现在是一种非常流行的语言，因为随着时间的推移，它的社区已经为多种架构创建了不同的解释器和运行时。因此，虽然JavaScript主要因其在web开发行业中的作用而闻名，但它也可以用于:</p><ul class=""><li id="0550" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">AI和机器学习，得益于<a class="ae ky" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>等项目。</li><li id="a34b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">工具，感谢Node.js和Deno等无头运行时。</li><li id="ea45" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">移动应用，考虑到可用框架的数量(React，React Native，Ionic，其他)。</li><li id="767a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">游戏开发，感谢<a class="ae ky" href="https://blog.bitsrc.io/9-top-js-gaming-engines-and-libraries-for-2020-81707d9f095" rel="noopener ugc nofollow" target="_blank">这么多可用的引擎和库</a>。</li><li id="a806" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">物联网解决方案:感谢像<a class="ae ky" href="https://mongoose-os.com/docs/mongoose-os/quickstart/setup.md" rel="noopener ugc nofollow" target="_blank">mongose OS</a>这样的框架，你可以使用JavaScript来编写微控制器。</li></ul><h2 id="4042" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">JavaScript的主要特征</h2><p id="655a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript的一些最吸引人和有趣的特征是:</p><p id="0775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">动态打字</strong></p><p id="e173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript支持动态类型，这意味着您可以在运行时更改变量的内容，而无需考虑数据的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a0b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看上面的例子——显然这不是利用动态类型的方法，但是由于JavaScript的灵活性，这是完全可能的。</p><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态分型系统的主要优点是:</p><ul class=""><li id="5c58" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">你得到了一种更简单的语言，因为你不必太担心类型声明和定义。</li><li id="4d41" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">开发时间减少了，因为编写代码的复杂性降低了。</li><li id="97fc" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您的代码可能更容易阅读(假设您也遵循其他最佳实践)，因为样板文件和重复代码更少。</li></ul><p id="7999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多途径支持</strong></p><p id="d766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不像其他语言那样关注单一的编程范式，JavaScript试图将面向对象世界和函数世界的精华融合在一起。</p><p id="20db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该语言支持类、方法、方法覆盖以及公共和私有成员(至少，它很快会支持私有成员)。</p><p id="46bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而与此同时，JavaScript有函数作为一等公民的概念。这反过来意味着你可以组合函数，编写更多的声明性代码、currying函数和其他FP模式(比如<code class="fe ob oc od oe b">reduce</code>、<code class="fe ob oc od oe b">map</code>等等)。</p><p id="4dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">异步输入/输出</strong></p><p id="4b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步代码是JavaScript固有的，这意味着该语言本身为您提供了一些难以置信的构造，您可以使用它们来编写非阻塞I/O操作，而不必担心线程或其他复杂的机制。当然，我们说的是回调函数、承诺和<code class="fe ob oc od oe b">async</code> / <code class="fe ob oc od oe b">await</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">摘自Mozilla开发者网站的例子</p></figure><p id="65b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意上面的代码——它读起来很容易，您不必记住是谁发出了请求或何时收到了响应。<code class="fe ob oc od oe b">async</code> / <code class="fe ob oc od oe b">await</code>组合允许你编写异步代码，就像它是同步代码一样。</p><p id="9c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">对于解释型语言来说非常有性能</strong></p><p id="3588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于JavaScript的一个误解是，因为它没有被编译，所以它的性能不会很好。然而，大多数JS运行时实现了一个<a class="ae ky" href="https://blog.bitsrc.io/the-jit-in-javascript-just-in-time-compiler-798b66e44143" rel="noopener ugc nofollow" target="_blank">实时(JIT)编译器</a>，这使得它的执行速度非常快。事实上，代码运行的时间越长，JIT编译器优化执行的机会就越多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4003" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">木卫一</h1><p id="28cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Io 是一种纯面向对象的语言，从SmallTalk、Lisp和Lua等其他语言中汲取了一些灵感。和JavaScript(以及其他)一样，它有一个基于原型的对象模型，并且对区分类和对象不感兴趣。在木卫一中一切都是对象。</p><p id="169c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它运行在一个小型虚拟机上，这使得它非常适合可嵌入的用例。Io曾经被皮克斯用于他们的<a class="ae ky" href="https://renderman.pixar.com/resources/RenderMan_20/programming_it.html" rel="noopener ugc nofollow" target="_blank"> RenderMan </a>渲染管道——在他们转向Python之前。虽然作者被引用说它被谣传用作卫星的一部分，但我个人找不到任何证据。</p><p id="13f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，Io的模型非常有趣，因为它是基于消息和对象的。我说过，Io中的一切都是对象，消息只是你与它们交互的方式。我们来看一个基本的“你好，世界！”示例:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="3803" class="nn md it oe b gy oj ok l ol om">"hello there peeps!" print</span></pre><p id="f2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要一点时间来适应，特别是如果你来自其他类似C语言的语言，但是在这个例子中，我们将<code class="fe ob oc od oe b">print</code>消息传递给我们的string对象。</p><p id="8805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子，一个处理数字列表的例子:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="0f05" class="nn md it oe b gy oj ok l ol om">d := List clone append(30, 10, 5, 20)<br/>d print</span></pre><p id="a042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有趣的例子，因为它展示了消息传递的机制。上面可以这样理解:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="d98d" class="nn md it oe b gy oj ok l ol om">d := (List.clone()).append(30, 10, 5, 20)<br/>d.print()</span></pre><p id="3325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要做的是我们克隆列表，这就是在Io中创建新对象的方法。然后，在新实例上调用<code class="fe ob oc od oe b">append</code>方法。如何添加对<code class="fe ob oc od oe b">sort</code>方法的调用，以使最终结果正确排序？</p><p id="61f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="5188" class="nn md it oe b gy oj ok l ol om">d := List clone append(30, 10, 5, 20) sort<br/>d print</span></pre><h2 id="5d96" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">那么木卫一有什么特别之处呢？</h2><p id="797b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抛开特殊的语法不谈，Io有一些非常有趣的特征:</p><ul class=""><li id="29d8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">纯面向对象</strong>，用原型代替类。这意味着你要创建一个新的对象，你所要做的就是克隆一个现有的对象。这极大地简化了模型。</li><li id="12cb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">具有高阶功能</strong>。这允许使用函数式方法进行编程。这与JavaScript处理这个问题的方式非常相似。这基本上允许您使用函数，或者在Io中被称为属性的<em class="on">槽</em>，允许您组合和传递行为。这是这种语言具有巨大灵活性的众多特性之一。</li><li id="6710" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">自省与反省</strong>。在Io中，你可以获得任何方法的实际代码，并在执行过程中修改它。这反过来又允许通常所说的<a class="ae ky" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank"> <em class="on">元编程</em></a><em class="on"/>或者使用你的代码改变语言本身的能力。</li></ul><p id="b981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他的，比如懒惰评估、增量垃圾收集、异常处理等等。Io是一种完美的函数式语言，如果你想了解更多，你可以查看他们的文档。</p><p id="6a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对这个有趣样本的总结，我想让您一瞥它的元编程能力。这里我们将重新定义<code class="fe ob oc od oe b">+</code>操作数。这是非常基本的事情，很少有语言允许这样做。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="2915" class="nn md it oe b gy oj ok l ol om">originPlus := Number getSlot("+")<br/>Number + := method(i, if( i &lt; 10, self originPlus(i), "that's just crazy!"))<br/>(1+2) println<br/>(2 + 100) println</span></pre><p id="61de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是:</p><ol class=""><li id="112d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu oo nf ng nh bi translated">获取对<code class="fe ob oc od oe b">Number</code>对象的<code class="fe ob oc od oe b">+</code>方法的引用。</li><li id="414b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu oo nf ng nh bi translated">用接收变量<code class="fe ob oc od oe b">i</code>并返回<code class="fe ob oc od oe b">if</code>语句的动态方法覆盖<code class="fe ob oc od oe b">Number</code>对象的<code class="fe ob oc od oe b">+</code>方法。<code class="fe ob oc od oe b">if</code>语句检查<code class="fe ob oc od oe b">i</code>的值，并基于它决定做什么(并因此返回)。</li><li id="e4a8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu oo nf ng nh bi translated">最后两行只是测试我们的更改。</li></ol><p id="079a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，该脚本的输出是:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="2bf4" class="nn md it oe b gy oj ok l ol om">3<br/>that's just crazy!</span></pre><p id="b8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://tio.run/##y8z//1/JIzUnJ19HITy/KCdFUUmhoCgzr@T/fwA" rel="noopener ugc nofollow" target="_blank">实时REPL </a>上玩代码和更多Io。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0771" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">序言</h1><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prolog是我最喜欢的“未使用但将来可能非常有用”的语言之一。它背后的范例是如此充满潜力，以至于我对它没有更受欢迎感到困惑。我过去曾就此写过一篇完整的文章，但其背后的要点如下:</p><p id="da61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prolog是一种逻辑编程语言。这真的非常违背我们在It行业的大多数经验，我们知道我们需要做什么，所以我们告诉计算机做什么——在某些情况下，甚至如何做。</p><p id="5e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，Prolog有所不同。通过逻辑编程，你建立了一个宇宙，并向计算机解释你的现实是什么样子。然后，你向它提问。做什么和如何做取决于运行时。</p><p id="55e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很有趣，不是吗？</p><p id="2681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面的代码示例:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="3f8b" class="nn md it oe b gy oj ok l ol om">magicNumber(3)<br/>magicNumber(5)<br/>magicNumber(7)<br/>magicNumber(9)<br/>?- magicNumber(X), magicNumber(Y), plus(X, Y, 12)</span></pre><p id="19a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前四行是建立宇宙——我们告诉我们的解释者我们有四个幻数。然后我们在问一个问题:给定<code class="fe ob oc od oe b">X</code>中的一个幻数和<code class="fe ob oc od oe b">Y</code>中的一个幻数，如果我把它们加在一起，哪一个会返回<code class="fe ob oc od oe b">12</code>？</p><p id="672c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果当然是:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="9b7a" class="nn md it oe b gy oj ok l ol om">3, 9<br/>5, 7<br/>7, 5<br/>9, 3</span></pre><p id="cbdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我不必迭代它们，也不必寻找多种组合或任何其他逻辑。我只是问了个问题。</p><h2 id="af71" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">那么是什么让Prolog如此酷呢？</h2><p id="b9a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能不同意我的观点，但是使Prolog如此有趣并且是任何开发人员必须尝试的主要和最重要的特性是逻辑。</p><p id="6df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能在性格形成时期学过真值表，也可能见过一两件用逻辑证明数学问题的事情。但是如果你没有见过逻辑被应用于解决编程问题，那么你就错过了。</p><p id="84c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prolog用纯粹简单的逻辑为你解决一个问题。您不必编写解决方案，而是依靠Prolog来找到解决方案。</p><p id="050d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象以下场景:您必须对一组学生、教师和主题进行建模。每个学生可以学习几门课程，每个老师可以教授一门课程。</p><p id="2a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您要使用传统的编程技术对此建模，您可能会想到使用数据库并查询类似“学生X正在学习哪门课程？”或者“谁在学X学科？”</p><p id="99c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Prolog，如果您使用事实和规则对问题进行建模，您可以执行以下操作:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="4948" class="nn md it oe b gy oj ok l ol om">studies(charlie, csc135).<br/>studies(olivia, csc135).<br/>studies(charlie, csc1000).<br/>studies(jack, csc131).  <br/>studies(arthur, csc134).<br/> <br/>teaches(kirke, csc135).  <br/>teaches(collins, csc131). <br/>teaches(collins, csc171). <br/>teaches(juniper, csc134).</span><span id="2679" class="nn md it oe b gy op ok l ol om">professor(X, Y) :- teaches(X, C), studies(Y, C).</span></pre><p id="536e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>示例摘自<a class="ae ky" href="http://athena.ecs.csus.edu/~mei/logicp/prolog/programming-examples.html" rel="noopener ugc nofollow" target="_blank">http://Athena . ECS . csus . edu/~ mei/logi CP/prolog/programming-examples . html</a>。</p><p id="c7fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有事实说明谁在学什么，谁在教什么科目。最后一行是建立一个规则，规定学生<code class="fe ob oc od oe b">Y</code>的教授<code class="fe ob oc od oe b">X</code>是教授其他人学习的科目的人。</p><p id="3fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，你就完成了。这是您的新数据库，您可以像这样提问(或者说，查询):</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="c12e" class="nn md it oe b gy oj ok l ol om">studies(What, csc134). //who's studying 'csc135'<br/>=&gt; What=arthur<br/>professor(kirke, What). //who's professor Kirke teaching?<br/>=&gt; What=charlie<br/>=&gt; What=olivia</span></pre><p id="0b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，逻辑引擎负责重要的部分，你的工作基本上包括正确设置宇宙，这样你就可以问它正确的问题。</p><p id="6739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，这就是Prolog的奇妙之处，也是为什么它被用于人工智能项目，如IBM的Watson或GeneXus的代码生成工具。</p><p id="d62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用<a class="ae ky" href="https://swish.swi-prolog.org/" rel="noopener ugc nofollow" target="_blank">这个REPL </a>在线试用Prolog。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b17e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Clojure</h1><p id="3fde" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你想谈论看起来奇怪的语言，Clojure绝对是不二之选(当然，不会碰到深奥的语言)。</p><p id="729e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Clojure 是一种主要的函数式编程语言，它提供了很高水平的动态行为，以及对多线程的出色支持。</p><p id="1d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，它看起来与其他类C语言如此不同的一个主要原因是，因为它是基于Lisp的，所以一切都是列表。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="8f62" class="nn md it oe b gy oj ok l ol om">(def a "hello world")<br/>(print a)</span></pre><p id="c8e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码将输出<code class="fe ob oc od oe b">hello world</code>，但有趣的是，这只是两个列表。Clojure中两个括号之间的一切都是列表。正因为如此，列表的第一项总是被当作一个函数，这意味着如果你想实际声明一个值列表，你需要调用<code class="fe ob oc od oe b">list</code>函数:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="12eb" class="nn md it oe b gy oj ok l ol om">(list 1 2 3 4 5 6)<br/>'(1 2 3 4 5)</span></pre><p id="a188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行是一个简写符号，以避免使用明显的<code class="fe ob oc od oe b">list</code>函数。</p><p id="855b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Clojure需要知道的另一件有趣的事情是，与它的父Lisp不同，它运行在JVM之上，这意味着您可以访问Java。允许您在Clojure代码中混合Java类型、类和JVM的其他特性。这意味着你可以这样做:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="b78e" class="nn md it oe b gy oj ok l ol om">(new java.util.Date "2016/2/19")</span></pre><p id="2a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您实际上将获得一个有效的Java date对象来使用。</p><h2 id="c451" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">主要特征</h2><ul class=""><li id="e42b" class="mz na it lb b lc mu lf mv li oq lm or lq os lu ne nf ng nh bi translated"><strong class="lb iu">动态环境</strong>。同样，Clojure是另一种动态语言，允许您在运行时重新定义它的行为。这变成了一种非常强大的极简JVM语言。它混合了JVM的强大功能和Java开发人员未知的灵活性。</li><li id="d63d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">更轻松的并发</strong>。因为Clojure中的主要数据结构是不可变的，所以在线程之间共享它们更容易——您不必担心不必要的修改。使用Clojure，您可以忘记管理线程间的锁。</li><li id="243a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">功能编程</strong>。虽然Clojure不是完全纯粹的，但当它涉及到FP时，它非常倾向于函数式编程。就像这里的其他语言一样，它有作为一等公民的函数的概念，这意味着你可以四处传递它们，并组合它们来创建新的、更复杂的行为。</li><li id="c50e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">像Java但是更好</strong>。因为它运行在JVM之上，并且您可以访问它的所有特性，所以您可以熟练地做任何您能够用Java做的事情，甚至使用它自己的一些本机类型和类。这使得它成为Java开发人员的一个很好的目标，这些开发人员正在寻找一种更有趣的语言。</li></ul><p id="a52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Clojure正被各种规模和行业的数百家公司积极使用。</p><ul class=""><li id="63af" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">沃尔玛</strong>。他们使用Clojure创建了一个可以处理5，000多家商店的商店管理系统。他们在这里谈论这件事。</li><li id="2933" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">亚特兰蒂斯</strong>。他们使用Clojure构建实时协作功能。他们谈得很好，谈到了这个问题和他们在这里得到的结果。</li><li id="214f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu"> ThoughtWorks </strong>。他们使用<a class="ae ky" href="http://thoughtworks.github.io/p2/issue09/two-months-early/" rel="noopener ugc nofollow" target="_blank"> Clojure来减少开发时间</a>并加速现有的Java团队。这清楚地表明了这种语言的一个主要优点。由于它工作在JVM之上，让您的JAVA团队切换到Clojure意味着您可以避免更改项目的底层技术。</li></ul><p id="cea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这份清单还可以继续列下去——你可以在这里查看<a class="ae ky" href="https://clojure.org/community/success_stories" rel="noopener ugc nofollow" target="_blank">所有成功案例</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ef9a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">锈</h1><p id="e8b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，<a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>是我们整个旅程的最后一站。我想涵盖这一点，因为它显示了一些非常明显的区别。</p><p id="a2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust是在Mozilla研究项目中设计和开发的，考虑到了性能和安全性。从语法上来说，它看起来很像C++，和它一样，在执行之前需要编译。</p><p id="6ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，即使它在视觉上可能与C或C++非常相似，它也从其他语言中汲取了许多线索，使它变得独特而强大。例如:</p><ul class=""><li id="feed" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">《铁锈》中几乎所有的东西都是一种表达方式。这意味着您可以创建带有卷带的块，然后将其内容赋给一个变量，如下所示:</li></ul><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="cc2a" class="nn md it oe b gy oj ok l ol om">fn main() {<br/>   let x = 42;</span><span id="b952" class="nn md it oe b gy op ok l ol om">   let y = {<br/>        let x_squared = x * x;<br/>        let x_cube = x_squared * x;<br/>        x_cube + x_squared + x //this is the return value of the expression <br/>    };</span><span id="c231" class="nn md it oe b gy op ok l ol om">    println!("y is {:?}", y);<br/>}</span></pre><ul class=""><li id="c6ff" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">像用Lisp(和Clojure)一样，<strong class="lb iu">函数不需要使用</strong> <code class="fe ob oc od oe b">return</code> <strong class="lb iu">语句。函数的最后一行将定义它的返回值。</strong></li><li id="bd9a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">模式匹配</strong>。通过使用<code class="fe ob oc od oe b">match</code>关键字，您可以为您的变量定义不同的模式，并相应地进行匹配。以下代码将定义一个范围，您可以使用该范围来匹配变量的值，并在没有匹配的情况下默认为另一种行为:</li></ul><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="13ce" class="nn md it oe b gy oj ok l ol om">let x = 5;<br/>match x {<br/>    1..=5 =&gt; println!("one through five"),<br/>    _ =&gt; println!("something else"),<br/>}</span></pre><h2 id="a8cf" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">是什么让Rust这么酷？</h2><ul class=""><li id="088f" class="mz na it lb b lc mu lf mv li oq lm or lq os lu ne nf ng nh bi translated"><strong class="lb iu">静态分类与动态分类</strong>。在这一点上，Rust试图与两个世界友好相处。它不是强迫开发人员为所有东西编写和定义类型，而是只要求顶级变量(如函数参数和常数)声明它们的类型，然后在函数内部，允许类型推断。看看下面的例子，Rust可以推断出<code class="fe ob oc od oe b">result</code>的类型，因为它知道<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>的类型以及函数的返回类型。</li></ul><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="9198" class="nn md it oe b gy oj ok l ol om">fn simple_adder(a: i32, b: i32) -&gt; i32 {<br/>    let result = a + b;<br/>    result<br/>}</span></pre><ul class=""><li id="342d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">没有接口，也没有类——但是有一个选择。Rust没有提供经典的类+接口组合，而是将赌注压在了特征、实现和结构上。您可以用数据结构的字段定义一个结构，然后通过向它添加行为(例如，方法)来围绕它创建一个特定的实现。最后，您甚至可以创建特征，这些特征的行为就像抽象类或接口，它们声明了一组您必须实现的方法。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的工作示例展示了如何使用这些新的构造来解决面向对象的需求。你可以在这里用一个<a class="ae ky" href="https://repl.it/new/rust" rel="noopener ugc nofollow" target="_blank">在线REPL</a>试试上面的例子。</p><ul class=""><li id="9899" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">缺少垃圾收集器实际上有助于</strong>。Rust没有垃圾收集器。相反，它允许您决定在哪里存储数据(堆栈或堆)，然后决定何时不再需要该内存。这反过来又提供了更有效和高性能的内存利用。</li><li id="e0ae" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">嵌入式系统的理想选择</strong>。由于它的低级API和对硬件和内存的直接访问，Rust是使用现代语言在嵌入式系统上工作的理想选择。</li></ul><p id="5a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你来自静态类型的世界，或者只是比我们行业的其他部门更接近硬件，你可能想给Rust一个机会。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1392" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3911" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这就是我们对这些语言的快速概述。当然，还有很多其他的，我知道我可能已经把你最喜欢的排除在外了。然而，这样做的目的是为了涵盖不同编程范例的不同实现，向您展示语言的多功能性。</p><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我设法激起你对这些选项中至少一个的兴趣，那么我就认为我的工作完成了。</p></div></div>    
</body>
</html>