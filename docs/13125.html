<html>
<head>
<title>Learn Google’s Carbon Programming Language — A Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习谷歌的碳编程语言——教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/carbon-programming-language-tutorial-6d67b4cc16ae?source=collection_archive---------0-----------------------#2022-08-01">https://betterprogramming.pub/carbon-programming-language-tutorial-6d67b4cc16ae?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a41e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解开始使用的语法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3362b423e652ab0b5a39c28f85c2e9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6K__rjrg7Y28cEJT0X6z8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="57ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据谷歌开发者Chandler Carruth的说法，Carbon可以作为C++的后继语言。</p><p id="7ac3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang#why-build-carbon" rel="noopener ugc nofollow" target="_blank">文档</a>宣称Carbon“<em class="lv">是围绕与C++的互操作性以及现有C++代码库和开发人员</em>的大规模采用和迁移而设计的。</p><p id="ab77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将提供Carbon编程语言的实用编码介绍，但不会讨论为什么有人可能需要它。</p><h1 id="44a2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">入门指南</h1><p id="c106" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这个入门包括两个部分:工具和语言基础。</p><p id="6f1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你已经安装了Carbon，可以直接跳到语言基础，否则就从工具开始。</p><p id="d170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在工具部分，我们将讨论以下内容来设置我们的环境:</p><ol class=""><li id="085b" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">公司自产自用</li><li id="7b24" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">巴泽尔</li><li id="f9db" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">LLVM</li><li id="05e0" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">克隆碳语言</li><li id="67e9" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">运行浏览器</li></ol><p id="779c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在<a class="ae lu" href="https://github.com/carbon-language/carbon-lang#getting-started" rel="noopener ugc nofollow" target="_blank">入门</a>中找到相同的方法。</p><p id="0a21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我将为第一次接触这种语言和工具的人添加一些上下文和简短的解释。</p><p id="a0fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装完成后，我们将继续学习语言基础部分的一些实际例子。</p><h1 id="fe5a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">碳语言:工具</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/5374369b5b843cd72abad3ed3c2e045b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HEK4fbUGSg1oyjbs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡斯·桑托斯在Unsplash的照片</p></figure><h2 id="5894" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated"><strong class="ak"> 1。自制</strong></h2><p id="eff7" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated"><a class="ae lu" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>是一个软件包管理器，可能已经安装在你的电脑上了。运行<code class="fe nu nv nw nx b">brew --version</code>来检查您是否已经拥有它。</p><p id="ead9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不是这样，你可以<a class="ae lu" href="http://how-to-install-homebrew-on-mac-linux-windows" rel="noopener ugc nofollow" target="_blank">在macOS、Linux、Windows上安装Homebrew </a>(通过WSL)。</p><h2 id="df21" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated"><strong class="ak"> 2。巴泽尔</strong></h2><p id="8e2f" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">Bazel是一个开源的构建和测试工具，支持多语言和多平台项目。</p><p id="c1ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据<a class="ae lu" href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/contribution_tools.md#bazel-and-bazelisk" rel="noopener ugc nofollow" target="_blank">文档</a>，<em class="lv"> Bazel是Carbon的标准建造系统。建议使用Bazelisk安装Bazel </em>。</p><p id="94da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行以下命令来安装Bazel:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="fe9b" class="ni lx it nx b gy oc od l oe of">brew install bazelisk</span></pre><h2 id="1062" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated"><strong class="ak"> 3。LLVM </strong></h2><p id="6f59" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">你可以把<a class="ae lu" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM </a>看成一个低级虚拟机，但是“LLVM和传统虚拟机关系不大”。LLVM用于编译和链接Carbon，作为其构建的一部分。</p><p id="45db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行以下命令安装LLVM:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="beb2" class="ni lx it nx b gy oc od l oe of">brew install llvm</span></pre><p id="dac8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在macOS(不是Linux)上，您应该运行以下命令来<a class="ae lu" href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/contribution_tools.md#clang-and-llvm" rel="noopener ugc nofollow" target="_blank">更新</a> <code class="fe nu nv nw nx b"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/contribution_tools.md#clang-and-llvm" rel="noopener ugc nofollow" target="_blank">PATH</a></code>:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="d900" class="ni lx it nx b gy oc od l oe of">export PATH="$(brew --prefix llvm)/bin:${PATH}"</span></pre><h2 id="c76d" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">4.克隆碳语言</h2><p id="8126" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">从适当的文件夹中运行以下命令。</p><p id="00c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们会在本地克隆并下载Carbon语言代码。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="a0f1" class="ni lx it nx b gy oc od l oe of">$ git clone <a class="ae lu" href="https://github.com/carbon-language/carbon-lang" rel="noopener ugc nofollow" target="_blank">https://github.com/carbon-language/carbon-lang</a><br/>$ cd carbon-lang</span></pre><h2 id="f09e" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">5.运行浏览器</h2><p id="6272" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">最后，我们准备好构建和运行浏览器。</p><p id="5be4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码运行Bazel构建工具，从而触发浏览器代码:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="b3c7" class="ni lx it nx b gy oc od l oe of">$ bazel run //explorer -- ./explorer/testdata/print/format_only.carbon</span></pre><p id="af38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浏览器在指定位置运行文件中的实际代码:<code class="fe nu nv nw nx b"> ./explorer/testdata/print/format_only.carbon</code></p><p id="7c71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">扩展名<code class="fe nu nv nw nx b">.carbon</code>是让解释器知道文件包含carbon语言所必需的。</p><p id="a25c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终，您应该得到一个如下所示的漂亮的“Hello World”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5c54ca6f8ae3afee63830210c1154275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dc0n9fyPYJNs6YNc6hdyVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Carbon编程语言打印“Hello World”</p></figure><h1 id="544c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">碳语言:语言基础</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/72c16adb73f12feff1e5e67c34d42714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P6eRM_5k7GfLrq6_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@diomari?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Diomari Madulara </a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d4cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你熟悉C、C++和类似的语言，你也会熟悉Carbon语法。</p><p id="25a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">碳仍然是实验性的，有些事情可能会改变。<a class="ae lu" href="https://github.com/carbon-language/carbon-lang#carbon-language--an-experimental-successor-to-c" rel="noopener ugc nofollow" target="_blank">文件</a>本身声明“注意，碳还没有准备好使用”。然而，一些设计原则不太可能改变。</p><p id="4df7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从查看<code class="fe nu nv nw nx b">format_only.carbon</code>中的代码开始</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="c69e" class="ni lx it nx b gy oc od l oe of">package ExplorerTest api;</span><span id="f139" class="ni lx it nx b gy oi od l oe of">fn Main() -&gt; i32 {<br/>  var s: auto = "Hello world!";<br/>  Print(s);<br/>  return 0;<br/>}</span></pre><ul class=""><li id="5bb8" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated"><code class="fe nu nv nw nx b">package</code>关键字声明包。<br/>该文件构成默认库。</li><li id="e763" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated"><code class="fe nu nv nw nx b">fn</code>介绍者关键字声明函数。代码<code class="fe nu nv nw nx b">fn Main() -&gt; i32 {...}</code>声明了一个名为Main的函数。<code class="fe nu nv nw nx b">Main()</code>的返回类型为<code class="fe nu nv nw nx b">i32</code>，即整数。Main返回零。</li><li id="82a6" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">关键字<code class="fe nu nv nw nx b">var</code>引入了一个变量声明。<br/>在上面的代码中，<code class="fe nu nv nw nx b">s</code>是变量的名称，后面是冒号<code class="fe nu nv nw nx b">:</code>，以及类型。<code class="fe nu nv nw nx b">auto</code>用于自动推断变量类型。</li><li id="5249" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">可以使用关键字<code class="fe nu nv nw nx b">let</code>来声明常量。<br/>虽然这可能会让来自JavaScript的开发人员感到困惑，但对于来自Swift的开发人员来说，这将会很顺利。</li><li id="baef" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">最后可以通过加两个斜线<code class="fe nu nv nw nx b">//</code>来添加评论</li></ul><p id="bad8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个简单的文件给了我们一个关于Carbon语法的很好的概述。</p><p id="a3fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们添加一些其他的片段。</p><h2 id="cb3f" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">基本类型和值</h2><p id="fb2d" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在Carbon中，我们可以有以下原语:</p><ul class=""><li id="9038" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated"><strong class="la iu">布尔型。</strong>它有两个可能的值:真和假。</li><li id="2f24" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated"><strong class="la iu">整数。</strong>碳考虑有符号和无符号整数。<br/>有符号整数可以是i8、i16、i32、i64、i128或i256。无符号整数可以是u8、u16、u32、u64、u128和u256。</li><li id="22b5" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated"><strong class="la iu">浮动。</strong>可以使用f16、f32、f64和f128。</li><li id="2a74" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated"><strong class="la iu">字符串。</strong>一个<strong class="la iu"> </strong>字节序列。可以在字符串的开头和结尾使用双引号(")将字符串文字写在一行中。比如《榜样》。多行(或块字符串)文字以三个双引号(" ")开始和结束。可以通过在前面加上反斜杠(\)来使用转义序列。</li></ul><h2 id="a1e9" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">函数参数和返回类型</h2><p id="b3de" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">让我们扩展代码以包含另一个函数:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="2ee4" class="ni lx it nx b gy oc od l oe of">package ExplorerTest api;</span><span id="2608" class="ni lx it nx b gy oi od l oe of">// Return type is empty/void<br/>fn AgeLogger(var age: i32) {<br/>    Print("Carbon is {0} years old", age);<br/>}</span><span id="0ada" class="ni lx it nx b gy oi od l oe of">fn Main() -&gt; i32 {<br/>  var s: auto = "Hello world!";<br/>  Print(s);<br/>  AgeLogger(0);<br/>  return 0;<br/>}</span></pre><p id="a16d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">AgeLogger</code>函数接受一个名为<code class="fe nu nv nw nx b">age</code>的变量参数，类型为i32。</p><p id="7f44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，由于<code class="fe nu nv nw nx b">AgeLogger</code>不返回任何东西，我们可以简单地跳过返回类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/3cea3f1e4326ee18b334bca4c57e7a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbPAjdZyvzDLFV3F19DQTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Carbon编程语言中函数的返回</p></figure><p id="10cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，一般来说，碳函数的语法是:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="3117" class="ni lx it nx b gy oc od l oe of">fn FunctionName(var param: type, ...) -&gt; return type { ... }</span></pre><p id="074b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当返回为空或void时，可以忽略返回类型。</p><h2 id="3a8f" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">控制流:If/Else</h2><p id="8ada" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">如果你是来自C++或者很多其他语言，这并不是什么新鲜事。</p><p id="1576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">据报道，“if和else提供语句的条件执行”。</p><p id="fd17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们将这一部分添加到示例中:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="b314" class="ni lx it nx b gy oc od l oe of">fn AgeLogger(var age: i32) {<br/>  if(age == 0){<br/>   Print("Carbon is {0} years old", age);<br/>  } else {<br/>   Print("Carbon is not {0} years old", age);<br/>  }  <br/>}</span></pre><p id="e9e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过添加一些简单的控制流，语句块被有条件地执行。否则，语句块将按顺序执行。</p><h2 id="d041" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">控制流:While循环</h2><p id="ea02" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">当表达式为真时，循环继续。</p><p id="c064" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在<code class="fe nu nv nw nx b">AgeLogger</code>函数中的if/else语句之后包含下面这段代码。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="7343" class="ni lx it nx b gy oc od l oe of">var x: i32 = 0;<br/>while (not (x == 3)) {<br/>    Print("I am number {0}", x);<br/>    x = x + 1;<br/>}<br/>Print("Done!");</span></pre><p id="b003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我应该提到，在我的例子中，我既不能使用<code class="fe nu nv nw nx b">while(x &lt; 3)</code>也不能使用<code class="fe nu nv nw nx b">++x</code>。在这两种情况下，我都会得到一个错误，尽管在<a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#while" rel="noopener ugc nofollow" target="_blank">文档</a>中提出了该语法。</p><p id="2ffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我当时还不明白为什么！所以，如果你想通了，可以随意把原因加到评论里让大家知道。</p><p id="b0ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7ba16459f9e08b7192c2657c1a54d05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO9nybps9YkUwImpIlvqwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Carbon中使用While循环</p></figure><h2 id="8364" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">控制流:For循环</h2><p id="0888" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">根据文档，<code class="fe nu nv nw nx b">for</code>语句支持基于范围的循环。所提供的示例非常普通:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="3774" class="ni lx it nx b gy oc od l oe of">for (var name: String in names) {<br/>  Console.Print(name);<br/>}</span></pre><p id="2ae5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我不能让它工作:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="ed4a" class="ni lx it nx b gy oc od l oe of">var names: [String;3] = ("str1", "str2", "str3");<br/>  for (var name: String in names) {<br/>    Print(name);<br/>  }</span></pre><p id="af0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在尝试上面的代码时，我一直得到“语法错误，意外的VAR”，我无法理解关键字<code class="fe nu nv nw nx b">var</code>应该在那里！</p><p id="3991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，我在任何地方都找不到一个可行的例子。</p><h2 id="aa37" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">控制流:匹配</h2><p id="23cd" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">再说一次，如果你是从C或C+来的，这将是熟悉的。</p><p id="0393" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">match</code>根据case声明检查表达式的值。在下面的示例中，值2与case声明相匹配，并返回字符串“Matching two”。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="e7e3" class="ni lx it nx b gy oc od l oe of">fn TheMatcher() -&gt; String {<br/>  Print("I am here");<br/>  var x: i32 = 2;<br/>  match (x) {<br/>    case (0) =&gt; {<br/>      return "Matching zero";<br/>    }<br/>    case (1) =&gt; {<br/>      return "Matching one";<br/>    }<br/>    case (2) =&gt; {<br/>      return "Matching two";<br/>    }<br/>    default =&gt; {<br/>      return "Matching none";<br/>    }<br/>  }<br/>}</span></pre><p id="8f17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个模块是可选的<code class="fe nu nv nw nx b">default</code>模块。<code class="fe nu nv nw nx b">default</code>块可以添加在案例声明之后，如果没有案例声明匹配，它将被执行。</p><p id="2b3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在控制流的范围内，值得一提的是<code class="fe nu nv nw nx b">break</code>和<code class="fe nu nv nw nx b">continue</code>。简单来说:</p><ul class=""><li id="8c6e" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated"><code class="fe nu nv nw nx b">break</code>立即结束循环，碳“<em class="lv">将从循环范围</em>的末端开始继续。</li><li id="5500" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated"><code class="fe nu nv nw nx b">continue</code>立即进入下一个循环。</li></ul><h2 id="980b" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">复合类型</h2><p id="2164" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在签出复合类型之前，我创建了一个名为<code class="fe nu nv nw nx b">composite_types.carbon</code>的新文件，其中包含了从现在开始的所有代码。</p><p id="9e7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是新代码:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="bfb6" class="ni lx it nx b gy oc od l oe of">package ExplorerTest api;</span><span id="78db" class="ni lx it nx b gy oi od l oe of">fn Main() -&gt; i32 {<br/>  var s: auto = "Hello composite types!";<br/>  Print(s);<br/>  return 0;<br/>}</span></pre><p id="ac3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将把它作为一张白纸来尝试复合类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/30266cedffa80305babbc998ff340dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UVjpBsIgRsiClwnN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jan Kahánek 在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4ccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#tuples" rel="noopener ugc nofollow" target="_blank">元组</a>:元组是固定大小的值的集合，有时称为坐标，可以有不同的类型。可以通过使用它们的位置来访问值。<br/>以下代码在打印值ad index和3之前，将元组<code class="fe nu nv nw nx b">(0, 1, 2, "omega")</code>分配给<code class="fe nu nv nw nx b">x</code>。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="30f9" class="ni lx it nx b gy oc od l oe of">fn UseTuples() {<br/>  var x: (i32, i32, i32, String) = (0, 1, 2, "omega");<br/>  Print("At index 2: {0}", x[2]);<br/>  Print(x[3]);<br/>}</span><span id="02f9" class="ni lx it nx b gy oi od l oe of">// output: <br/>At index 2: 2<br/>omega</span></pre><p id="3321" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#struct-types" rel="noopener ugc nofollow" target="_blank">结构类型</a>:结构类型允许通过名称来标识成员，而不是使用它们的索引或位置。</p><ul class=""><li id="311b" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated">结构类型示例:<code class="fe nu nv nw nx b">{.name: String, .count: i32}</code></li><li id="d731" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">结构值示例:<code class="fe nu nv nw nx b">{.name = "John", .count = 4}</code></li></ul><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="ef7b" class="ni lx it nx b gy oc od l oe of">fn UseStruct() {<br/>  var data: auto = {.x_var = 3, .b_var = 2, .m_slope = 7};<br/>  var y: i32 = data.m_slope * data.x_var + data.b_var;<br/>  Print("y: {0}", y);<br/>}</span><span id="b0cd" class="ni lx it nx b gy oi od l oe of">// output: <br/>y: 23</span></pre><p id="89e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#pointer-types" rel="noopener ugc nofollow" target="_blank">指针类型</a>:和C和C++中一样，指针是一个变量，存储对象的内存地址。Carbon提供了两种指针操作:</p><ul class=""><li id="970e" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated">解引用:给定一个指针p，*p给出p指向的值作为l值。</li><li id="9eab" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">Address-of:给定一个l值x，<code class="fe nu nv nw nx b">&amp;x</code>返回一个指向x的指针。Carbon中没有空指针。</li></ul><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="72ff" class="ni lx it nx b gy oc od l oe of">fn Pointers() {<br/>  var x: i32 = 0;<br/>  Print("Initial x: {0}", x);<br/>  <br/>  x = 10;  // changes x to 10<br/>  Print("x is now {0}", x);<br/>  <br/>  var y: i32* = &amp;x;  // returns pointer to x<br/>  <br/>  *y = 5;  // changes x to 5<br/>  Print("x is now {0}", x);<br/>  Print("y = {0}", *y);</span><span id="6f85" class="ni lx it nx b gy oi od l oe of">}</span><span id="5b7a" class="ni lx it nx b gy oi od l oe of">// output:<br/>Initial x: 0<br/>x is now 10<br/>x is now 5<br/>y = 5</span></pre><ul class=""><li id="f034" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated"><a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#arrays-and-slices" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">数组和切片</strong> </a>:碳数组类型的通用语法是<code class="fe nu nv nw nx b">[type, number of values]</code>。<br/>下面的代码将类型和值赋给一个包含四个整数的数组。</li></ul><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="8c5b" class="ni lx it nx b gy oc od l oe of">var array: [i32; 4] = (0, 1, 2, 3);</span><span id="e8c0" class="ni lx it nx b gy oi od l oe of">// It is possible to omit the number of values <br/>// when the size of the array can be inferred<br/>var array: [i32;] = (0, 1, 2, 3);</span><span id="bfd9" class="ni lx it nx b gy oi od l oe of">// access elements using square brakets<br/>Print(array[0]);</span></pre><h2 id="7967" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">班级</h2><p id="88c4" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">使用类来定义数据结构是可能的。</p><p id="af7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在类名前使用<code class="fe nu nv nw nx b">class</code>关键字来定义一个类。</p><p id="82d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例类名为<code class="fe nu nv nw nx b">Widget</code>，包含三个字段，在字段名称前使用<code class="fe nu nv nw nx b">var</code>关键字声明。</p><p id="6e36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还需要声明每个字段的类型。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="f572" class="ni lx it nx b gy oc od l oe of">class Widget {<br/>  var x: i32;<br/>  var y: i32;<br/>  var payload: String;<br/>}</span></pre><p id="c8f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类还可以包含函数、方法、别名、常量和嵌套类。</p><p id="cbde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例扩展为添加一个返回两个整数字段之和的函数。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="ae5d" class="ni lx it nx b gy oc od l oe of">class Widget {<br/>  var x: i32;<br/>  var y: i32;<br/>  var payload: String;<br/>  <br/>  fn Sum[me: Self]() -&gt; i32 {<br/>      var total: i32 = me.x + me.y;<br/>      return total;<br/>  }<br/>}</span></pre><p id="2251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我扩展了这个类以包含一个sum函数。该函数将字段<code class="fe nu nv nw nx b">x</code>的值与字段<code class="fe nu nv nw nx b">y</code>的值相加，并返回总和。</p><p id="4028" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我更新了<code class="fe nu nv nw nx b">Main()</code>如下:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="4d3e" class="ni lx it nx b gy oc od l oe of">fn Main() -&gt; i32 {<br/>  var coolWidget: Widget = {.x = 6, .y = 7, .payload = "load"};<br/>  var total: i32 = coolWidget.Sum();<br/>  Print("Total sum {0}" , total);<br/>  return 0;<br/>}</span><span id="be2f" class="ni lx it nx b gy oi od l oe of">// output:<br/>Total sum 13</span></pre><h2 id="1618" class="ni lx it bd ly nj nk dn mc nl nm dp mg lh nn no mi ll np nq mk lp nr ns mm nt bi translated">无商标消费品</h2><p id="97a3" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">和其他语言一样，泛型“允许用编译时参数编写像函数和类这样的碳结构”。</p><p id="a5a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，<code class="fe nu nv nw nx b">T</code>用于定义一个可以是任何类型的泛型。</p><p id="9fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">官方文档提供了一个很好的例子。</p><p id="faff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们有一个<code class="fe nu nv nw nx b">Min</code>函数。该函数有一个类型参数<code class="fe nu nv nw nx b">T</code>，它可以是实现<code class="fe nu nv nw nx b">Ordered</code>接口的任何类型。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="3fcf" class="ni lx it nx b gy oc od l oe of">fn Min[T:! Ordered](x: T, y: T) -&gt; T {<br/>  return if x &lt;= y then x else y;<br/>}</span></pre><p id="2d17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，他们给变量<code class="fe nu nv nw nx b">a</code>和<code class="fe nu nv nw nx b">b</code>赋值。假设两个变量都是<code class="fe nu nv nw nx b">i32</code>类型，<code class="fe nu nv nw nx b">T</code>被推导为<code class="fe nu nv nw nx b">i32</code>。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="253e" class="ni lx it nx b gy oc od l oe of">var a: i32 = 1;<br/>var b: i32 = 2;<br/>Assert(Min(a, b) == 1);</span></pre><p id="6fd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，将字符串值赋给<code class="fe nu nv nw nx b">a</code>和<code class="fe nu nv nw nx b">b</code>会使<code class="fe nu nv nw nx b">T</code>成为类型字符串。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="63f1" class="ni lx it nx b gy oc od l oe of">var a: String = "abc";<br/>var b: String = "xyz";<br/>Assert(Min(a , b) == "abc");</span></pre><p id="b49d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在我的例子中，我在解析像<code class="fe nu nv nw nx b">&lt;=</code>这样的字符时遇到了问题。然而，一个更通用的测试，我们只把值传递给print就可以了。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="7b9f" class="ni lx it nx b gy oc od l oe of">fn TestGenerics[T:! Type](x: T) -&gt; T {<br/>  return x;<br/>}</span><span id="ba1f" class="ni lx it nx b gy oi od l oe of">// output:<br/>i32: 0<br/>String</span></pre><h1 id="7c5a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="0d68" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">鉴于我遇到的几次打嗝，可以肯定地说“注意，碳还没有准备好使用”。这与<a class="ae lu" href="https://github.com/carbon-language/carbon-lang#carbon-language--an-experimental-successor-to-c" rel="noopener ugc nofollow" target="_blank">文件</a>中声明的内容一致。</p><p id="565c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管有这些东西，玩一玩并测试一下还是很有趣的。这是特别有趣的，因为它是新的，仍然未经探索。</p><p id="7ea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你也有同感！</p><p id="949e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了保持这篇文章是一个介绍，我不得不省略部分。</p><p id="afe4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><ul class=""><li id="d1c4" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt oj mz na nb bi translated">整数文字和下划线，浮点类型，<code class="fe nu nv nw nx b">StringView</code>。</li><li id="22fa" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">Carbon编译器的行为取决于构建模式。Carbon有三种构建模式:<em class="lv">开发、性能、硬化。<br/> </em>一些编程错误将取决于构建模式。文档中对此进行了说明。</li><li id="c82f" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt oj mz na nb bi translated">其他人</li></ul><p id="2654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你需要这种程度的细节，我强烈推荐阅读文档中的<a class="ae lu" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#language-design" rel="noopener ugc nofollow" target="_blank">语言设计</a>页面。</p><p id="f69d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道更多关于为什么Carbon会成为C++在某些狭窄领域的继承者，请阅读我在Carbon 语言背后的要点。</p><p id="84c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">期待听到大家的意见！</p><div class="om on gp gr oo op"><a href="https://medium.com/@lorenzozar/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接加入Medium-Lorenzo Zarantonello</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">如果这个有价值，直接支持我！我的文章大多是免费的。考虑成为会员以示支持…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>