<html>
<head>
<title>Writing Distributed and Replicated State Machine in Golang Using Raft</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Raft编写Golang分布式复制状态机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-distributed-and-replicated-state-machine-in-golang-using-raft-dad79b58cd3a?source=collection_archive---------6-----------------------#2022-05-20">https://betterprogramming.pub/writing-distributed-and-replicated-state-machine-in-golang-using-raft-dad79b58cd3a?source=collection_archive---------6-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="936b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">嗯，你可能会听到很多关于“分布式系统”或者“raft”本身的说法。但是，你可能想知道如何使用它。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc4cf715db29685249afebb15d62d36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qgwLvGVgYIhEsMot"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约书亚·厄尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将讨论如何使用Golang和<a class="ae kv" href="https://github.com/shaj13/raft" rel="noopener ugc nofollow" target="_blank"> Raft库</a>处理以集群模式运行的kv数据库。本教程更侧重于代码和使用raft集群，而不是讨论raft算法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="38d2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">什么是筏？</strong></h1><p id="697c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Raft是一种协议，通过它，节点集群可以维护一个复制的状态机。</p><p id="a935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态机通过使用复制日志保持同步。然而，Raft协议的细节超出了本教程的范围，关于Raft的更多细节，参见<a class="ae kv" href="https://raft.github.io/raft.pdf" rel="noopener ugc nofollow" target="_blank">寻找可理解的共识算法</a></p><h2 id="3dee" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><strong class="ak">戈朗木筏的实施</strong></h2><p id="eeb5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Raft算法是在寻找一种可以理解的共识算法。不幸的是，大多数go库都需要对它们的实现和API有深入的了解。</p><p id="70c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在本教程中使用的raft库是为了与可理解性raft原则保持一致而诞生的，它的唯一目的是为极简、简单、干净和惯用的API提供共识。</p><p id="b371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">Etcd Raft</code>是生产中使用最广泛的Raft库。但是，它遵循极简主义的设计哲学，只实现核心raft算法，留下了缺口和歧义。</p><p id="49a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<code class="fe ni nj nk nl b"><a class="ae kv" href="https://github.com/shaj13/raft" rel="noopener ugc nofollow" target="_blank">shaj13/raft</a></code>库使用<code class="fe ni nj nk nl b">etcd raft</code>作为其核心，而不是重新发明轮子。</p><p id="2690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是你如何受益于<code class="fe ni nj nk nl b">etcd raft</code>的强大和稳定性，以及一个可理解的API。事实上，它让你专注于构建优秀的软件。</p><h1 id="8fb7" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">创建我们的项目</h1><p id="15d4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将从创建我们的项目开始。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="d9ee" class="mw ma iq nl b gy nv nw l nx ny">mkdir raft &amp;&amp; cd raft &amp;&amp; go mod init raft &amp;&amp; touch raft.go</span></pre><p id="ec7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建一个名为<code class="fe ni nj nk nl b">raft</code>的新目录，并用<code class="fe ni nj nk nl b">go.mod</code>初始化项目。</p><h1 id="e151" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">我们的第一行代码</h1><p id="1826" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们写任何代码之前，我们需要写一些强制性的代码来使程序运行。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="e0b2" class="mw ma iq nl b gy nv nw l nx ny">package main<br/>import (<br/>  "log"<br/>)<br/>func main() {<br/>  log.Println("Raft !!")<br/>}</span></pre><h1 id="50b1" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">创建我们的流程命令行</h1><p id="a3db" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将删除打印出<code class="fe ni nj nk nl b">Raft!!</code>的行，添加标志包并初始化它。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="243b" class="mw ma iq nl b gy nv nw l nx ny">package main <br/>import "flag"<br/>func main() {<br/>   addr := flag.String("raft", "", "raft server address")<br/>   join := flag.String("join", "", "join cluster address")<br/>   api := flag.String("api", "", "api server address")<br/>   state := flag.String("state_dir", "", "raft state directory (WAL, Snapshots)")<br/>   flag.Parse() <br/>}</span></pre><h1 id="fe9a" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">创建我们的kv数据库</h1><p id="e085" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将实现一个名为<code class="fe ni nj nk nl b">stateMachine</code>的结构来定义<code class="fe ni nj nk nl b">kv</code>数据库，该数据库读取并应用一个键值，同时获取<code class="fe ni nj nk nl b">database</code>快照并恢复它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="0768" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">创建我们的端点</h1><p id="c62a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将添加gorilla mux包，并在主函数中初始化路由器。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="7218" class="mw ma iq nl b gy nv nw l nx ny">router := mux.NewRouter()</span></pre><p id="3d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将建立API的端点，我们将在main函数中创建所有端点，每个端点都需要一个函数来处理请求，我们将在main函数下定义这些端点。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="3891" class="mw ma iq nl b gy nv nw l nx ny">router.HandleFunc("/", http.HandlerFunc(save)).Methods("PUT", "POST")<br/>router.HandleFunc("/{key}", http.HandlerFunc(get)).Methods("GET")<br/>router.HandleFunc("/mgmt/nodes", http.HandlerFunc(nodes)).Methods("GET")<br/>router.HandleFunc("/mgmt/nodes/{id}", http.HandlerFunc(removeNode)).Methods("DELETE")</span></pre><h1 id="7d80" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">路线处理程序</h1><p id="83df" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们只需要定义处理请求的函数。<br/>在开始之前，我们需要声明两个变量来允许routes访问数据。</p><ul class=""><li id="4df3" class="ob oc iq ky b kz la lc ld lf od lj oe ln of lr og oh oi oj bi translated">节点表示raft过程</li><li id="49db" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">FSM代表raft进程状态机</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="2704" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">创建我们的raft节点和服务器</h1><p id="5e6f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在主函数中和路由器下面，我们需要声明我们的raft节点和<code class="fe ni nj nk nl b">gRPC</code>服务器，以允许当前raft节点与其他raft节点通信。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的文件现在应该看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="a576" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">测试我们的代码</h1><h2 id="814c" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">建筑筏形集群</h2><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="4029" class="mw ma iq nl b gy nv nw l nx ny">go mod tidy &amp;&amp; go build raft.go </span></pre><h2 id="b9a6" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">运行单节点筏</h2><p id="e85a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，启动raft的单成员集群:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="ba84" class="mw ma iq nl b gy nv nw l nx ny">./raft -state_dir=$TMPDIR/1 -raft :8080 -api :9090</span></pre><p id="13ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个raft进程维护一个raft实例和一个键值服务器。</p><p id="8fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">raft服务器地址(<code class="fe ni nj nk nl b">-raft</code>)、状态目录(<code class="fe ni nj nk nl b">-state_dir</code>)和http键值服务器地址(<code class="fe ni nj nk nl b">-api</code>)通过命令行传递。</p><p id="04d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，将一个值(“<code class="fe ni nj nk nl b">medium</code>”)存储到一个键(“<code class="fe ni nj nk nl b">hello</code>”):</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="fc80" class="mw ma iq nl b gy nv nw l nx ny">curl -L http://127.0.0.1:9090/ -X PUT -d '{"Key":"hello", "Value":"<!-- -->medium<!-- -->"}'</span></pre><p id="fd42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，检索存储的密钥:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="8a89" class="mw ma iq nl b gy nv nw l nx ny">curl -L <a class="ae kv" href="http://127.0.0.1:9090/hello" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9090/hello</a></span></pre><h2 id="10a0" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">运行本地集群</h2><p id="1c75" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们带来两个额外的raft实例。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="dfc9" class="mw ma iq nl b gy nv nw l nx ny">./raft -state_dir $TMPDIR/2 -raft :8081 -api :9091 -join :8080<br/>./raft -state_dir $TMPDIR/3 -raft :8082 -api :9092 -join :8080</span></pre><p id="efaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在可以向集群的任何成员写入一个键-值对，同样也可以从任何成员检索它。</p><h2 id="8be6" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">容错</h2><p id="c06b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要测试集群恢复，请将值“<code class="fe ni nj nk nl b">foo</code>”写入关键字“T10”:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="6fbb" class="mw ma iq nl b gy nv nw l nx ny">curl -L <a class="ae kv" href="http://127.0.0.1:9090/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9090/</a> -X PUT -d '{"Key":"foo", "Value":"foo"}'</span></pre><p id="6946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，停止一个节点(9092)并将值替换为“bar ”,以检查集群可用性:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="944f" class="mw ma iq nl b gy nv nw l nx ny">curl -L <a class="ae kv" href="http://127.0.0.1:9090/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9090/</a> -X PUT -d '{"Key":"foo", "Value":"bar"}'<br/>curl -L <a class="ae kv" href="http://127.0.0.1:9090/foo" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9090/foo</a></span></pre><p id="6de2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，重新启动该节点，并验证它是否使用更新后的值“<code class="fe ni nj nk nl b">bar</code>”进行了恢复:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="1327" class="mw ma iq nl b gy nv nw l nx ny">curl -L <a class="ae kv" href="http://127.0.0.1:9092/foo" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9092/foo</a></span></pre><h2 id="2c9f" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">集群重构</h2><p id="3771" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可以从正在运行的群集中添加、删除或更新节点。让我们使用对REST API的请求来删除节点。</p><p id="fcdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，列出所有raft集群节点，并获取节点id。</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="c43f" class="mw ma iq nl b gy nv nw l nx ny">curl -L <a class="ae kv" href="http://127.0.0.1:9090/mgmt/nodes" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9090/mgmt/nodes</a></span></pre><p id="bda2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用删除请求删除节点:</p><pre class="kg kh ki kj gt nr nl ns nt aw nu bi"><span id="ccc3" class="mw ma iq nl b gy nv nw l nx ny">curl -L http://127.0.0.1:9090/&lt;ID&gt; -X DELETE</span></pre><p id="c175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦群集处理了此请求，节点将自行关闭。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe ni nj nk nl b">raft</code>库的更多信息可以在<a class="ae kv" href="https://github.com/shaj13/raft" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae kv" href="https://pkg.go.dev/github.com/shaj13/raft" rel="noopener ugc nofollow" target="_blank"> GoDoc </a>上找到。非常感谢您的阅读。我希望这篇文章对你有所帮助。</p></div></div>    
</body>
</html>