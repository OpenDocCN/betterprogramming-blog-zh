<html>
<head>
<title>The Complete Guide to Concurrency and Multithreading in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中并发和多线程的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-concurrency-and-multithreading-in-ios-59c5606795ca?source=collection_archive---------0-----------------------#2022-02-15">https://betterprogramming.pub/the-complete-guide-to-concurrency-and-multithreading-in-ios-59c5606795ca?source=collection_archive---------0-----------------------#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b07f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">主线程与后台线程。异步/等待和执行元。GCD与OperationQueue。组调度、如何支持后台线程等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eecd9f2a0ae6b74a57d4ac05dbf71b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OUahLXqbffAW6U5y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·安维克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="4d83" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="bdee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们将了解以下内容:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b6d4" class="ms la it mo b gy mt mu l mv mw">TABLE OF CONTENTS</span><span id="4cf4" class="ms la it mo b gy mx mu l mv mw"><a class="ae ky" href="#9cb6" rel="noopener ugc nofollow">What Is Multithreading</a><br/>  Serial Queue vs. Concurrent Queue<br/>  Parallelism<br/>  Concurrency<br/><a class="ae ky" href="#b3d8" rel="noopener ugc nofollow">Basics of Multithreading</a><br/>  Main Thread (UI Thread) vs. Background Thread (Global Thread)<br/><a class="ae ky" href="#6b25" rel="noopener ugc nofollow">GCD (Grand Central Dispatch)</a><br/><a class="ae ky" href="#0830" rel="noopener ugc nofollow">DispatchGroup</a><br/><a class="ae ky" href="#b38c" rel="noopener ugc nofollow">DispatchSemaphore</a><br/><a class="ae ky" href="#fe80" rel="noopener ugc nofollow">DispatchWorkItem</a><br/><a class="ae ky" href="#c340" rel="noopener ugc nofollow">Dispatch Barrier</a><br/><a class="ae ky" href="#0a2a" rel="noopener ugc nofollow">AsyncAfter</a><br/><a class="ae ky" href="#9b83" rel="noopener ugc nofollow">(NS)Operation and (NS)OperationQueue</a><br/><a class="ae ky" href="#b6c0" rel="noopener ugc nofollow">DispatchSource (How To Handle Files and Folders)</a><br/><a class="ae ky" href="#eef2" rel="noopener ugc nofollow">Deadlock (Issue What To Avoid)</a><br/><a class="ae ky" href="#0a2b" rel="noopener ugc nofollow">Main Thread Checker (How To Detect Thread Issues)</a><br/><a class="ae ky" href="#f309" rel="noopener ugc nofollow">Threads in Xcode (How To Debug Threads)</a><br/><a class="ae ky" href="#bffe" rel="noopener ugc nofollow">Async / Await / Actor Is iOS13+</a></span></pre><p id="9599" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我知道有很多话题。如果有些东西你已经很熟悉了，跳过它，读未知的部分。有窍门和小技巧。</p><h1 id="9cb6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">现实世界中的多线程示例</h1><p id="8b64" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">想象你有一家餐馆。服务员正在收集订单。厨房在准备食物，酒保在煮咖啡和鸡尾酒。</p><p id="2a72" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">在某些时候，很多人会点咖啡和食物。那需要更多的时间来准备。突然铃响了，5份食物和4份咖啡准备好了。即使所有的产品都准备好了，服务员也需要一个接一个地为桌子上菜。这是<strong class="lt iu">序列队列</strong>。对于串行队列，您只能有一个服务员。</p><p id="38ba" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">现在想象有两三个服务员。同时，他们上菜的速度也会更快。这就是<strong class="lt iu">平行度</strong>。使用多个CPU运行多个进程。</p><p id="32ca" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">现在想象一下，一个服务员不会立刻为一张桌子服务，而是首先为所有的桌子服务所有的咖啡。然后，他们会询问一些新桌子的订单，然后提供所有的食物。这个概念叫做<strong class="lt iu">并发。它是上下文切换，管理，同时运行许多计算。这并不一定意味着它们会同时运行。比如单核机器上的多任务处理。</strong></p><p id="f6b0" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">现在的设备都有多个CPU(<a class="ae ky" href="https://en.wikipedia.org/wiki/Central_processing_unit" rel="noopener ugc nofollow" target="_blank">中央处理器</a>)。为了能够创建无缝流程的应用，我们需要理解<strong class="lt iu">多线程</strong>的概念。这是我们在应用程序中处理一些任务的一种方式。重要的是要明白，如果某样东西“有效”，也许它不是最好的、想要的方式。很多时候，我看到一个长时间运行的任务发生在UI线程上，并在几秒钟内阻止了应用程序的执行。如今，这可能是不去的时刻。用户可以删除你的应用程序，因为他们觉得其他应用程序启动更快，更快地获取书籍和音乐。竞争是巨大的，高标准是意料之中的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/dfff4388631eb69ade143f9e3b9298e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*VAGYSwgHGTHvAPhP1m204Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线程执行类型</p></figure><p id="acea" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果在当前时间安排了“序列6”任务，则可以看到该任务。它将以<strong class="lt iu"> FIFO </strong>的方式添加到列表中，等待将来执行。</p><h1 id="b3d8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">多线程基础</h1><p id="ccb3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我一直纠结的一件事是没有标准术语。为了帮助这些科目，我将首先写下同义词，例子。如果你来自iOS之外的其他技术，你仍然可以理解这个概念，并把它移植过来，因为基本原理是一样的。我很幸运，在我职业生涯的早期，我与C、C++、C#、node.js、Java(Android)等一起工作。所以我习惯了这种上下文切换。</p><ul class=""><li id="a8ba" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">主线程/ UI线程:</strong>这是应用程序启动的线程，预定义的串行线程。它监听用户交互和UI变化。所有的变化都需要立即得到回应。需要注意不要给这个线程增加大量的工作，因为应用程序可能会冻结。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/08e8ed063651a0c10195799189de5046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*xz9E1Nuw29R-rcINHsnUlA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UI线程上长时间运行的任务(错误，不应该这样做)</p></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8093" class="ms la it mo b gy mt mu l mv mw">DispatchQueue.main.async {<br/>    // Run async code on the Main/UI Thread. E.g.: Refresh TableView<br/>}</span></pre><ul class=""><li id="fc55" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">后台线程(全局):</strong>预定义。大多数情况下，我们根据需要在新线程上创建任务。例如，如果我们需要下载一些大的图像。这是在后台线程上完成的。或者任何API调用。我们不想阻止用户等待这个任务完成。我们将调用一个API调用来获取后台线程上的电影数据列表。当它到达并且解析完成后，我们切换并更新主线程上的UI。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/352ea8eebc17dba6a16f04ef7eca9241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*WqeTWiks2f1AXxy2uAdWUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">长时间运行的任务(在后台线程上以正确的方式完成)</p></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="dacd" class="ms la it mo b gy mt mu l mv mw">DispatchQueue.global(qos: .background).async {<br/>     // Run async on the Background Thread. E.g.: Some API calls.<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/c41a3c9320a4d73fa91c4389dfb8a99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnKZUZS-ZeYlZ9CHgsxCgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">串行队列示例</p></figure><p id="cb3f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">在上图中，我们在第56行添加了一个断点。当点击它时，应用程序停止，我们可以在线程左侧的面板上看到这一点。</p><ol class=""><li id="c954" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nq nk nl nm bi translated">你可以看到<code class="fe nr ns nt mo b">DispatchQueue(label: “com.kraken.serial”)</code>的名字。标签是标识符。</li><li id="bb9a" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nq nk nl nm bi translated">这些按钮有助于关闭/过滤系统方法调用，只查看用户发起的调用。</li><li id="72c5" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nq nk nl nm bi translated">你可以看到我们增加了<code class="fe nr ns nt mo b">sleep(1)</code>。这将停止代码执行1秒钟。</li><li id="a092" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nq nk nl nm bi translated">如果你观察顺序，它仍然以连续的方式被触发。</li></ol><p id="4706" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">根据之前的iOS，最常用的两个术语之一是串行队列和并发队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/be26e112eeffb5065b6a325c2bfdc318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnTmlYColH5efxcnLtJBzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">并发队列示例</p></figure><ol class=""><li id="3931" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nq nk nl nm bi translated">这是并发队列的结果之一。上面还可以看到串口/主线程(<em class="oa"> com.apple.main-thread </em>)。</li><li id="04ac" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nq nk nl nm bi translated"><code class="fe nr ns nt mo b">sleep(2)</code>就是加到这一点上的。</li><li id="7aa2" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nq nk nl nm bi translated">你看没有秩序。它在后台线程上异步完成。</li></ol><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8e55" class="ms la it mo b gy mt mu l mv mw">let mainQueue = DispatchQueue.main<br/>let globalQueue = DispatchQueue.global()<br/>let serialQueue = DispatchQueue(label: “com.kraken.serial”)<br/>let concurQueue = DispatchQueue(label: “com.kraken.concurrent”, attributes: .concurrent)</span></pre><p id="df41" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我们还可以创建一个私有队列，它可以是串行的，也可以是并发的。</p><h1 id="6b25" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">大中央调度</h1><p id="453e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">GCD是Apple的低级线程接口，用于支持多核硬件上的并发代码执行。简单地说，GCD使您的手机能够在后台下载视频，同时保持用户界面的响应性。</p><blockquote class="ob oc od"><p id="c568" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">“DispatchQueue是一个对象，它管理应用程序主线程或后台线程上任务的串行或并发执行。”—苹果开发者</p></blockquote><p id="3201" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果您注意到上面的代码示例，您可以看到“qos”这意味着服务质量。使用该参数，我们可以如下定义优先级:</p><ul class=""><li id="1370" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">背景</strong> —当一个任务对时间不敏感，或者当用户可以在这个过程中进行其他交互时，我们可以使用这个。比如预取一些图像，加载，或者在这个后台处理一些数据。这项工作需要大量的时间、秒、分和小时。</li><li id="d345" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu">实用程序</strong> —长时间运行的任务。一些用户可以看到的过程。比如下载一些带指标的地图。当一项任务需要几秒钟，最终需要几分钟。</li><li id="7f77" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu">用户启动</strong> —用户从UI启动某个任务，等待结果继续与应用交互。这项任务需要几秒钟或一瞬间。</li><li id="6359" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu"> userInteractive </strong> —当用户需要立即完成一些任务，以便能够继续与应用程序进行下一次交互时。即时任务。</li></ul><p id="425f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">给<code class="fe nr ns nt mo b">DispatchQueue</code>贴标签也很有用。这可以帮助我们在需要时识别线程。</p><h1 id="0830" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">调度组</h1><p id="8351" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通常我们需要启动多个异步进程，但是当所有进程都完成时，我们只需要一个事件。这可以通过DispatchGroup实现。</p><blockquote class="ob oc od"><p id="1485" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">"作为一个单元监控的一组任务."—苹果文档</p></blockquote><p id="cd90" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">例如，有时您需要在后台线程上进行多个API调用。在应用程序准备好进行用户交互或更新主线程上的UI之前。下面是一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用<code class="fe nr ns nt mo b">DispatchGroup</code>多线程</p></figure><ul class=""><li id="c327" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nj nk nl nm bi translated"><strong class="lt iu">步骤1。</strong>创建<code class="fe nr ns nt mo b">DispatchGroup</code></li><li id="3462" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu">步骤二。</strong>然后为该组需要调用<code class="fe nr ns nt mo b">group.enter()</code>事件的每个任务启动</li><li id="528f" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu">第三步。</strong>因为每完成一个任务<code class="fe nr ns nt mo b">group.enter()</code>还需要叫<code class="fe nr ns nt mo b">group.leave()</code>。</li><li id="43c6" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><strong class="lt iu">第四步。</strong>当所有回车-回车对完成后，调用<code class="fe nr ns nt mo b">group.notify</code>。如果你注意到它是在后台线程上完成的。您可以根据需要进行配置。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/630d99355ff374ad82627593ab2e2d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5abBihhgOraZToTOi4lwVA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调度组。任务一个接一个，全靠通知。</p></figure><p id="9036" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">值得一提的是<code class="fe nr ns nt mo b">wait(timeout:)</code>选项。它将等待任务完成一段时间，但超时后，它将继续。</p><h1 id="b38c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">调度信号量</h1><blockquote class="ob oc od"><p id="ccf6" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">"通过使用传统的计数信号量来控制跨多个执行上下文对资源的访问的对象."—苹果文档</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用DispatchSemaphore的多线程</p></figure><p id="a636" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">每次访问共享资源时调用<code class="fe nr ns nt mo b">wait()</code>。</p><p id="76f7" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">当我们准备好释放共享资源时，调用<code class="fe nr ns nt mo b">signal()</code>。</p><p id="a4d9" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nr ns nt mo b">DispatchSemaphore</code>中的<code class="fe nr ns nt mo b">value</code>表示并发任务的数量。</p><h1 id="fe80" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">分派工作项</h1><p id="8526" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个普遍的看法是，当一个GCD任务被安排好了，它就不能被取消。但这不是真的。iOS8之前确实如此。</p><blockquote class="ob oc od"><p id="2ccd" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">您要执行的工作，以允许您附加完成句柄或执行依赖项的方式封装—苹果文档</p></blockquote><p id="ec5b" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">例如，如果您正在使用搜索栏。每输入一个字母都会调用一个API调用，从服务器端请求一个电影列表。想象一下，如果你正在输入“蝙蝠侠”“B”、“Ba”、“Bat”……每一个字母都会引发一个网络呼叫。我们不想这样。例如，如果在一秒钟的范围内输入了另一个字母，我们可以简单地取消之前的呼叫。如果时间过去了一秒钟，而用户没有键入新的字母，那么我们认为需要执行API调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/27fc2f9744abf59756f7068450c40224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kurFvLtoj7jovJcKT1P4tg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索栏。使用DispatchWorkItem模拟“去抖”</p></figure><p id="5d2f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">当然，使用像RxSwift / Combine这样的函数式编程，我们有更好的选择，比如<code class="fe nr ns nt mo b">debounce(for:scheduler:options:)</code>。</p><h1 id="c340" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">调度障碍</h1><p id="6ab0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">分派障碍正在解决读/写锁问题。这确保只执行这个DispatchWorkItem。</p><blockquote class="ob oc od"><p id="e0e4" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">"这使得线程不安全的对象成为线程安全的."—苹果文档</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/152fa95af1422cd7fde60a66eb4ef534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlHRf0N33mKFj_GHm91Wyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调度障碍</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/d0b8d39fbf477a17115e67191c24fba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GiFY0BTDW2guffVbajIPJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">障碍时间线</p></figure><p id="96e3" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">例如，如果我们想保存游戏，我们想写一些打开的共享文件，资源。</p><h1 id="0a2a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">AsyncAfter</h1><p id="91c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以使用这段代码来延迟一些任务的执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">邪恶的阿斯卡特。多线程不好的一面</p></figure><p id="aa7b" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">在我看来，这是万恶之源，尊重例外。对于每一个需要延迟的异步任务，我建议仔细考虑一下，如果可能的话，使用一些状态管理系统。不要把这个选项作为首选。通常，还有另一种方法。</p><h1 id="9b83" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">(NS)操作和(NS)操作队列</h1><p id="7f60" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你正在使用n operation，这意味着你正在使用GCD，因为n operation是建立在GCD之上的。NSOperation的一些好处是，它有一个更加用户友好的依赖关系界面(以特定的顺序执行任务)，它是可观察的(KVO观察属性)，有暂停、取消、恢复和控制(您可以指定队列中的任务数量)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OperationQueue示例。iOS多线程的选项2</p></figure><p id="0941" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">您可以将并发操作计数设置为1，这样它将作为一个串行队列工作。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fe96" class="ms la it mo b gy mt mu l mv mw">queue.maxConcurrentOperationCount = 1</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">串行操作队列</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">并发操作队列</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组并发操作队列</p></figure><p id="530b" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这最后一个是调度组。唯一的区别是编写复杂的任务要容易得多。</p><h1 id="b6c0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">调度资源</h1><p id="ed36" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">DispatchSource用于检测文件和文件夹中的更改。根据我们的需要，它有许多变化。下面我只举一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例如何监控一些“物理”文件</p></figure><h1 id="eef2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">僵局</h1><p id="675c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有一种情况，两个任务可以互相等待对方完成。这叫做死锁。该任务将永远不会执行，并将阻止应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iOS多线程中的死锁</p></figure><p id="3b24" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">从不在主队列上调用同步任务；会造成死锁。</p><h1 id="0a2b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">主线程检查器</h1><p id="748a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有一种方法可以得到我们做错了事的警告。这是一个非常有用的选项，我推荐使用它。它可以很容易地捕捉一些不必要的问题。</p><p id="e115" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果你在目标上打开并编辑下一个图像上的方案，打开主线程检查器，那么当我们在后台进行一些UI更新时，这个运行时选项会通知我们。请参见下图中的紫色通知:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/bbfb4e963b2b55b285f68785aecbc439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIBFEKYQx3iX0eaOWuVwPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主线程检查器</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1dada492cccc09179754b5ce1c18702f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_UquEAZtmgM7bMSYb2vWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主线程检查器结果</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/af197808881426de64eb2f1f1a306ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQORZnI8tlPbxYRmkuwN6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法名问题在哪里可以看出来</p></figure><p id="3d5a" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">您还可以在Xcode终端中看到有什么问题。对于新来的人来说，这可能有点奇怪，但是你会很快习惯的。但是你可以在这一行中，找到问题所在的方法的名字。</p><h1 id="f309" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Xcode中的线程</h1><p id="d434" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在调试时，有几个技巧可以帮助我们。</p><p id="520d" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果你添加了一个断点并停在某一行。在Xcode终端你可以输入命令<code class="fe nr ns nt mo b">thread info.</code>，它会打印出当前线程的一些细节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0e9b9bd9fcdf73a4b9754951be3819fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17YeQlxRG8Dtt4cD9zpzOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调试代码终端中的线程</p></figure><p id="26b8" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">以下是一些对终端更有用的命令:</p><p id="cfad" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nr ns nt mo b">po Thread.isMainThread</code></p><p id="bbc3" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nr ns nt mo b">po Thread.isMultiThreaded()</code></p><p id="4cee" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nr ns nt mo b">po Thread.current</code></p><p id="fa7b" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><code class="fe nr ns nt mo b">po Thread.main</code></p><p id="f31f" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">也许你也有类似的情况——当应用程序崩溃时，在错误日志中你可以看到类似<code class="fe nr ns nt mo b">com.alamofire.error.serialization.response</code>的内容。这意味着框架创建了一些自定义线程，这是标识符。</p><h1 id="bffe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">异步/等待</h1><p id="182d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">随着iOS13和Swift 5.5的推出，期待已久的Async / Await应运而生。苹果很好，他们认识到了这样一个问题，当一个新的东西推出时，会有很长一段时间的延迟，直到它可以用于生产，因为我们通常需要支持更多的iOS版本。</p><p id="3ce2" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">Async / Await是一种在没有完成处理程序的情况下运行异步代码的方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最简单的异步/等待</p></figure><p id="2f58" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">下面是一些值得一提的代码:</p><ul class=""><li id="889a" class="ne nf it lt b lu my lx mz ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe nr ns nt mo b">Task.isCancelled</code></li><li id="1616" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><code class="fe nr ns nt mo b">Task.init(priority: .background) {}</code></li><li id="724c" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><code class="fe nr ns nt mo b">Task.detached(priority: .userInitiated) {}</code></li><li id="7d32" class="ne nf it lt b lu nu lx nv ma nw me nx mi ny mm nj nk nl nm bi translated"><code class="fe nr ns nt mo b">Task.cancel()</code></li></ul><p id="7b7a" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我想强调任务组。这是Await / Async世界中的“DispatchGroup”。我发现Paul Hudson在这个<a class="ae ky" href="https://www.hackingwithswift.com/quick-start/concurrency/how-to-create-a-task-group-and-add-tasks-to-it" rel="noopener ugc nofollow" target="_blank">链接</a>上有一个很好的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Paul Hudson的TaskGroup的好例子</p></figure><h1 id="d359" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">行动者</h1><p id="4065" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">参与者是类，是线程安全的引用类型。它们处理数据竞争和并发问题。正如您在下面看到的，访问actor的属性是用<code class="fe nr ns nt mo b">await</code>关键字完成的。</p><blockquote class="ob oc od"><p id="a69e" class="lr ls oa lt b lu my ju lw lx mz jx lz oe na mc md of nb mg mh og nc mk ml mm im bi translated">"参与者一次只允许一个任务访问他们的可变状态."—苹果文档</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://docs.swift.org/" rel="noopener ugc nofollow" target="_blank">https://docs.swift.org/</a>的例子</p></figure><h1 id="caef" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="656b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经讨论了许多多线程主题——从UI和后台线程到死锁和DispatchGroup。但是我相信你现在正在成为专家的路上，或者至少已经准备好了关于多线程主题的iOS面试问题。</p><p id="f9fb" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">完整的代码样本可以在下一个链接找到:<a class="ae ky" href="https://github.com/skyspirit86/Multithreading" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。希望自己玩的有价值。</p><p id="0d60" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果你到了这一步，感谢你的阅读。你应该得到一杯咖啡☕️.🙂如果你喜欢的内容，请👏，分享，还有<a class="ae ky" href="https://varga-zolt.medium.com/" rel="noopener">跟着</a>，对我来说就意味着一个。如果您有一些建议或问题，请随时发表评论。</p><p id="0643" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><strong class="lt iu">想要连接？</strong> <br/>你可以在<a class="ae ky" href="https://www.linkedin.com/in/varga-zolt/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ky" href="https://twitter.com/skyspirit86" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ky" href="https://skyspiritlabs.com/" rel="noopener ugc nofollow" target="_blank">https://skyspiritlabs.com/</a>与我联系。还有更多文章和教程。</p></div></div>    
</body>
</html>