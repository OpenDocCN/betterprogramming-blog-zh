<html>
<head>
<title>Database Connection Pooling With PgBouncer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PgBouncer的数据库连接池</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/database-connection-pooling-with-pgbouncer-d8766a8a2c85?source=collection_archive---------3-----------------------#2020-05-29">https://betterprogramming.pub/database-connection-pooling-with-pgbouncer-d8766a8a2c85?source=collection_archive---------3-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8204" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Postgres连接池问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c34aff09002e9cc36ee19c3dff997bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHEUbv4IjMUVjL_h43uXeQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·德马利诺在<a class="ae ky" href="https://unsplash.com/s/photos/neon-green?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="1025" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介:Postgres连接池问题</h1><p id="8216" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当<a class="ae ky" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>在近25年前被创建时，开发者决定不为新请求使用线程。相反，他们决定为每个请求创建一个新的进程<em class="mn"> </em>。他们的理由是，进程不太可能导致内存损坏，而且最终在目标平台(Unix)上创建进程的成本也不是很高。从那以后，这个决定引发了很多讨论。但是开发者坚持他们的决定，并抵制重新架构。</p><p id="0845" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当时，使用流程的决定是正确的。但是现代应用程序(例如微服务)往往需要大量的连接，并且它们使用和释放这些连接的速度非常快。因此，虽然“无线程”的决定在十年前是站得住脚的，但今天Postgres无法伸缩是一个严重的问题。幸运的是，这是一个众所周知的问题，开发人员多年来一直在面对和解决这个问题。</p><p id="3f42" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">那么答案是什么呢？连接池。</p><p id="0561" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这篇文章中，我们将看看Postgres上的连接池和连接池选项。然后，在后续文章中，我们将使用<a class="ae ky" href="https://www.heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>、<a class="ae ky" href="https://devcenter.heroku.com/articles/best-practices-pgbouncer-configuration" rel="noopener ugc nofollow" target="_blank">PgBouncer指南、</a>和<a class="ae ky" href="https://devcenter.heroku.com/articles/postgres-connection-pooling" rel="noopener ugc nofollow" target="_blank">Postgres连接池指南</a>在应用程序上实现PgBouncer连接池</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8788" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">什么是连接池？</h1><p id="3dbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">连接池是开放数据库连接的缓存，可供客户端重用。使用池通过减少对新连接的请求来减轻数据库的压力。池还提高了单个数据库调用的性能，因为不需要花费时间来请求和打开连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/859a2d03357d49246e4ab97ce34d0ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BtfG-uEDI-K_K3u6.png"/></div></div></figure><p id="5b77" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从高层次来看，连接池是这样工作的:</p><ol class=""><li id="d934" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm nl nm nn no bi translated">用户请求数据库连接。</li><li id="e871" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">该池检查现有的和可用的缓存连接。</li><li id="7fa1" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">如果找到缓存的连接，它将返回给用户。</li><li id="4f16" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">如果找不到缓存的连接，则会创建一个新连接，只要该池符合连接池的设置，如最大池大小、数据库允许的最大连接数、每个用户允许的最大连接数等。</li><li id="880b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">如果创建新连接违反了这些设置中的任何一项，请求将被排队，直到连接可用或可以创建新连接。</li></ol></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="21bd" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">在哪里创建连接池</h1><p id="d872" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了什么是连接池，让我们来看看当您实现连接池时将面临的第一个决定——将它放在堆栈的什么位置。你有几个选择。您可以在语言级别、在您的客户机上、作为中间件或者作为这些选择的某种混合来创建您的池。与许多技术决策一样，正确的选择通常取决于您的情况。</p><p id="ef10" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里有一些利弊来帮助你决定。</p><h2 id="63e1" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">语言级</h2><p id="8cdd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您的库使用专门为您的语言创建的库，在您的代码需要的任何地方本地运行。大多数语言都包含本地或附加的连接池库(例如，Java的<a class="ae ky" href="https://jdbc.postgresql.org/documentation/81/datasource.html" rel="noopener ugc nofollow" target="_blank"> JDBC </a>或Python的<a class="ae ky" href="https://www.psycopg.org/" rel="noopener ugc nofollow" target="_blank"> Psycopg </a>)。</p><p id="aadb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">优点:</p><ul class=""><li id="4797" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">低延迟，因为池与请求者在同一机器上。</li><li id="ec41" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">更好的安全性，因为连接仅限于一个客户端。</li><li id="0903" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">不需要学习新工具。</li></ul><p id="62d8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">缺点:</p><ul class=""><li id="f4a1" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">很难监视和控制到数据库的连接，因为您最终可能会有来自多个客户端的多个池。</li><li id="beba" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">针对您的语言优化，不一定针对Postgres。</li></ul><h2 id="3f7f" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">客户端级别</h2><p id="321e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您的池与您的代码是分开的，但是与您的客户端应用程序运行在同一台机器上。</p><p id="ba59" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">优点:</p><ul class=""><li id="3c74" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">低延迟和更好的安全性，类似于语言级别。</li><li id="129b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">针对Postgres优化，不针对您的语言。</li></ul><p id="5777" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">缺点:</p><ul class=""><li id="7ff7" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">同样，与语言级别类似，很难监控和控制连接。</li></ul><h2 id="dbea" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">中间件</h2><p id="2fbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您的池在客户机和数据库之间运行，可以在独立的服务器上运行，也可以在与数据库相同的机器上运行。</p><p id="771c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">优点:</p><ul class=""><li id="87cf" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">灵活—数据库可以换出。</li><li id="7ede" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">针对Postgres优化，不针对您的语言。</li><li id="38d7" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">连接的集中控制，这使得监视和控制连接更加容易。</li></ul><p id="4f56" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">缺点:</p><ul class=""><li id="7576" class="ng nh it lt b lu mo lx mp ma ni me nj mi nk mm og nm nn no bi translated">您引入了新的层，因此也带来了新的延迟。</li><li id="1040" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">跨所有客户端的数据库调用的单点故障。</li><li id="b85f" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">潜在的安全问题，因为您在层之间共享连接。</li><li id="4184" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">还有一层需要维护。</li></ul><p id="c77e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">人才库的理想位置将取决于您的独特情况、技术需求和个人优势。然而，在大多数情况下，中间件可能是您的最佳选择。对于一个拥有许多服务的现代应用程序来说，中间件可以让您更好地控制和了解您的连接。</p><p id="4c70" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">接下来，让我们深入最常见的用例:Postgres上的中间件连接池。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="aa50" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">Postgres中间件连接池选项</h1><p id="0425" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Postgres中间件连接池有两个领先的库:<a class="ae ky" href="https://www.pgpool.net" rel="noopener ugc nofollow" target="_blank"> Pgpool-II </a>和<a class="ae ky" href="https://www.pgbouncer.org/" rel="noopener ugc nofollow" target="_blank"> PgBouncer </a>。详细对比，我推荐<a class="ae ky" href="https://www.cybertec-postgresql.com/en/connection-pooling-intro-pgbouncer-and-pgpool-ii/" rel="noopener ugc nofollow" target="_blank">阅读这篇文章</a>。让我们快速看一下每种方法的优缺点，因为决定可能很简单。</p><h2 id="585b" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">Pgpool-II</h2><ul class=""><li id="5073" class="ng nh it lt b lu lv lx ly ma oh me oi mi oj mm og nm nn no bi translated">基本连接池</li><li id="3b5f" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">还提供负载平衡、复制和其他高级功能</li></ul><h2 id="34cb" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">PgBouncer</h2><ul class=""><li id="bdc8" class="ng nh it lt b lu lv lx ly ma oh me oi mi oj mm og nm nn no bi translated">基本连接池。就是这样。</li><li id="f687" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm og nm nn no bi translated">重量轻，性能更好</li></ul><p id="17e1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这通常是一个非常容易的决定。这两个选项都是成熟的解决方案，运行良好，并且拥有坚实的用户基础。决定因素是你是否需要连接池或者更多。Pgpool-II稍微慢一点，重一点，但是有一些高级特性，比如负载平衡。</p><p id="1693" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另一方面，如果您只需要一个连接池，不需要其他东西，PgBouncer是您的轻量级快速解决方案。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="40cc" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">结论</h1><p id="6344" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们讨论了<em class="mn">为什么</em>应该在Postgres中创建连接池，以及一些选项。在下一篇文章中，我们将通过一个在Heroku 上的例子来看一下<em class="mn">如何在Postgres中建立PgBouncer连接池。</em></p></div></div>    
</body>
</html>