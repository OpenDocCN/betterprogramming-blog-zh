<html>
<head>
<title>When to Use React.PureComponent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用React。纯组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-react-purecomponent-723f85738be1?source=collection_archive---------3-----------------------#2019-11-04">https://betterprogramming.pub/when-to-use-react-purecomponent-723f85738be1?source=collection_archive---------3-----------------------#2019-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2345" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这个鲜为人知的组件类优化性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f666b6beba45c9f824b2d7afb10ff2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NwT4s2vnA0NrSH9kyci_A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布雷特·乔丹在<a class="ae kv" href="https://unsplash.com/collections/8567307/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="262e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你用过<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>，那么你就熟悉<code class="fe ls lt lu lv b">React.Component</code>。这可能就是你每次创建一个新的有状态组件时所扩展的东西。<code class="fe ls lt lu lv b">App.js</code>就是这样一个类组件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1d1f" class="ma mb iq lv b gy mc md l me mf">import React from 'react';</span><span id="407f" class="ma mb iq lv b gy mg md l me mf">export default class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="43ab" class="ma mb iq lv b gy mg md l me mf">    this.state = {<br/>      message: 'hello',<br/>    };<br/>  }</span><span id="7173" class="ma mb iq lv b gy mg md l me mf">  render() {<br/>    return (<br/>      &lt;main&gt;<br/>        {this.state.message}<br/>      &lt;/main&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="83fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是还有另一个鲜为人知的组件类可以扩展，叫做<code class="fe ls lt lu lv b">React.PureComponent</code>。这两个类有什么区别，为什么要用<code class="fe ls lt lu lv b">PureComponent</code>？</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="8cec" class="mo mb iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">做出反应。PureComponent主要用于性能优化</h1><p id="8840" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如<a class="ae kv" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"> React文档</a>中所述:</p><blockquote class="nk nl nm"><p id="3754" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">如果你的React组件的<code class="fe ls lt lu lv b">render()</code>函数在相同的道具和状态下呈现相同的结果，在某些情况下你可以使用<code class="fe ls lt lu lv b">React.PureComponent</code>来提升性能。</p></blockquote><p id="35cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那到底是什么意思？假设我们有一个子组件，<code class="fe ls lt lu lv b">child.js</code>:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="51b5" class="ma mb iq lv b gy mc md l me mf">import React from 'react';</span><span id="9173" class="ma mb iq lv b gy mg md l me mf">const Child = props =&gt; &lt;div&gt;{ props.message }&lt;/div&gt;;</span><span id="c728" class="ma mb iq lv b gy mg md l me mf">export default Child;</span></pre><p id="051a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件从其父组件接收道具<em class="nn"> </em>。我们希望这个组件在收到新的道具时重新渲染。但是如果它的父节点正在跟踪不同种类的状态呢？即使子组件收到的道具没有改变，父组件会触发子组件的重新渲染吗？</p><p id="510b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设父组件如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="045a" class="ma mb iq lv b gy mc md l me mf">import React from 'react';<br/>import Child from './Child';</span><span id="754b" class="ma mb iq lv b gy mg md l me mf">export default class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="488b" class="ma mb iq lv b gy mg md l me mf">    this.state = {<br/>      counter: 0,<br/>      message: 'hello',<br/>    };<br/>  }</span><span id="a2f1" class="ma mb iq lv b gy mg md l me mf">  render() {<br/>    return (<br/>      &lt;main&gt;<br/>        {this.state.counter}<br/>        &lt;br /&gt;<br/>        &lt;Child message={this.state.message} /&gt;<br/>      &lt;/main&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="256e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Parent.js</code>呈现一个<code class="fe ls lt lu lv b">&lt;main&gt;</code>元素，显示两组状态，<code class="fe ls lt lu lv b">counter</code>和<code class="fe ls lt lu lv b">message</code>。<code class="fe ls lt lu lv b">message</code>状态被传递给<code class="fe ls lt lu lv b">&lt;Child /&gt;</code>组件并在那里呈现。</p><p id="e867" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细看看<code class="fe ls lt lu lv b">constructor</code>方法中的状态，父方法在这里跟踪我们的状态:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="cfe7" class="ma mb iq lv b gy mc md l me mf">this.state = {<br/>  counter: 0,<br/>  message: 'hello'<br/>};</span></pre><p id="7ade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定这些组件，如果我们运行<code class="fe ls lt lu lv b">yarn start</code>，我们会在视口中得到以下结果:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="42fe" class="ma mb iq lv b gy mc md l me mf">0<br/>hello</span></pre><p id="0fb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">0</code>从父组件渲染，<code class="fe ls lt lu lv b">hello</code>从子组件渲染。</p><p id="fa26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有设置在<code class="fe ls lt lu lv b">Parent.js</code>的<code class="fe ls lt lu lv b">counter</code>和<code class="fe ls lt lu lv b">message</code>道具。再看一下<code class="fe ls lt lu lv b">Child.js</code>，你可以看到它只是在接收<code class="fe ls lt lu lv b">message</code>道具。如果<code class="fe ls lt lu lv b">counter</code>道具改变，我们不希望<code class="fe ls lt lu lv b">Child.js</code>重新渲染，因为<code class="fe ls lt lu lv b">counter</code>与<code class="fe ls lt lu lv b">Child.js</code>无关。对于像这样的小项目，担心这种级别的重新渲染可能不会有太大的影响，但是不必要地重新渲染一堆又一堆的子组件可能会妨碍更大项目的性能。</p><p id="6a28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们的子组件重新渲染时，我们可以做一些事情来测试。这个<a class="ae kv" href="https://www.youtube.com/watch?v=PXXjkq4A-OU" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>显示，通过在我们的每个组件中放置<code class="fe ls lt lu lv b">console.log()</code>语句，我们可以检查哪些语句在特定事件后重新呈现。</p><p id="96ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用父组件和子组件对此进行测试。首先，让我们向父组件添加一个<code class="fe ls lt lu lv b">console.log()</code>。让我们也提供一种方法来改变我们的<code class="fe ls lt lu lv b">counter</code>状态:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2752" class="ma mb iq lv b gy mc md l me mf">import React from 'react';<br/>import Child from './Child';</span><span id="ea9d" class="ma mb iq lv b gy mg md l me mf">export default class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="505b" class="ma mb iq lv b gy mg md l me mf">    this.state = {<br/>      counter: 0,<br/>      message: 'hello',<br/>    };<br/>  }</span><span id="402f" class="ma mb iq lv b gy mg md l me mf">  handleClick = () =&gt; {<br/>    this.setState(prevState =&gt; ({ counter: prevState.counter + 1 }));<br/>  };</span><span id="9f62" class="ma mb iq lv b gy mg md l me mf">  render() {<br/>    console.log('parent rendered');<br/>    return (<br/>      &lt;main&gt;<br/>        {this.state.counter}<br/>        &lt;br /&gt;<br/>        &lt;Child message={this.state.message} /&gt;<br/>        &lt;button type='button' onClick={this.handleClick}&gt;Increment&lt;/button&gt;<br/>      &lt;/main&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="4297" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们添加了一个附加到<code class="fe ls lt lu lv b">&lt;button&gt;</code>的<code class="fe ls lt lu lv b">handleClick()</code>方法。这样，我们可以增加<code class="fe ls lt lu lv b">counter</code>状态，这将触发父组件的重新呈现。</p><p id="8f41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们点击几次按钮并检查控制台，我们会看到父组件在每次<code class="fe ls lt lu lv b">counter</code>状态增加时重新呈现:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8229" class="ma mb iq lv b gy mc md l me mf">parent rendered<br/>parent rendered<br/>parent rendered<br/>...</span></pre><p id="912a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利。让我们也给子组件添加一个<code class="fe ls lt lu lv b">console.log()</code>语句，并检查它是否也在每次<code class="fe ls lt lu lv b">counter</code>递增时重新呈现:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3009" class="ma mb iq lv b gy mc md l me mf">import React from 'react';</span><span id="6495" class="ma mb iq lv b gy mg md l me mf">export default class Child extends React.Component {<br/>  render() {<br/>    console.log('child rendered');<br/>    return (<br/>      &lt;div&gt;{ this.props.message }&lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="ac89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将子组件变成了类组件，只是为了在其中添加一个<code class="fe ls lt lu lv b">console.log()</code>语句。在现实世界中，这并不是一个足够好的理由来使这个组件成为一个类。尽管如此，尽管有了<code class="fe ls lt lu lv b">console.log()</code>语句，这个版本的子组件基本上与无状态组件相同。</p><p id="7517" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们在浏览器中增加时，我们会在控制台中看到:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9a8e" class="ma mb iq lv b gy mc md l me mf">Parent rendered<br/>Child rendered<br/>Parent rendered<br/>Child rendered<br/>...</span></pre><p id="7f2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设这些<code class="fe ls lt lu lv b">console.log()</code>语句只在<code class="fe ls lt lu lv b">render()</code>方法被调用时触发，我们可以肯定地说，改变<code class="fe ls lt lu lv b">counter</code>状态是不必要的重新呈现子组件。这就是<code class="fe ls lt lu lv b">React.PureComponent</code>的用武之地。如果我们改为从<code class="fe ls lt lu lv b">React.PureComponent</code>扩展子组件，那么我们将阻止它不必要的重新渲染:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7554" class="ma mb iq lv b gy mc md l me mf">import React from 'react';</span><span id="73ee" class="ma mb iq lv b gy mg md l me mf">export default class Child extends React.PureComponent {<br/>  render() {<br/>    console.log('child rendered');<br/>    return (<br/>      &lt;div&gt;{ this.props.message }&lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="29cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们增加<code class="fe ls lt lu lv b">counter</code>状态时，我们在控制台中得到这个:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="20fa" class="ma mb iq lv b gy mc md l me mf">parent rendered<br/>child rendered<br/>parent rendered<br/>parent rendered<br/>parent rendered<br/>...</span></pre><p id="27f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经成功地防止了子组件中不必要的重新渲染。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f61f" class="mo mb iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">引擎盖下是什么？</h1><p id="17a3" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Component</code>和<code class="fe ls lt lu lv b">PureComponent</code>最大的区别在于<code class="fe ls lt lu lv b">PureComponent</code>自动实现了<code class="fe ls lt lu lv b">shouldComponentUpdate()</code>生命周期方法。</p><p id="3b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">shouldComponentUpdate()</code>的<a class="ae kv" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">文档</a>中写着:</p><blockquote class="nk nl nm"><p id="0079" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">shouldComponentUpdate()</code>让React知道组件的输出是否不受当前状态或道具变化的影响。默认行为是在每次状态改变时重新渲染，在大多数情况下，您应该依赖默认行为。</p></blockquote><p id="41b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，现在你知道了——正如我们的<code class="fe ls lt lu lv b">console.log()</code>实验所示，组件的默认行为是在每次状态改变时重新呈现。<code class="fe ls lt lu lv b">shouldComponentUpdate()</code>是这个自动重新渲染之前的一个检查点，评估状态的变化是否与手头的组件有任何关系。</p><p id="3d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，您可以手动实现<code class="fe ls lt lu lv b">shouldComponentUpdate()</code>，但是<code class="fe ls lt lu lv b">PureComponent</code>是隐式实现的，有时这正是您想要的。您可以看到将几十个有状态子节点切换到扩展<code class="fe ls lt lu lv b">PureComponent</code>可以避免许多不必要的重新渲染。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1e6c" class="mo mb iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">是否应该尽可能使用PureComponent？</h1><p id="570b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">有时候，使用<code class="fe ls lt lu lv b">PureComponent</code>没有多大意义，即使它确实有助于优化性能。给定我们上面的例子，除了使用一个<code class="fe ls lt lu lv b">console.log()</code>之外，没有必要让<code class="fe ls lt lu lv b">Child</code>成为一个有状态的类组件。如果没有理由让它成为一个类，那么它就不会扩展<code class="fe ls lt lu lv b">Component</code>或<code class="fe ls lt lu lv b">PureComponent</code>，把它变成一个类只是为了使用<code class="fe ls lt lu lv b">PureComponent</code>是没有必要的。</p><p id="1a7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果子组件是类，并且只被传递了其父组件的一些道具，那么<code class="fe ls lt lu lv b">PureComponent</code>可能是值得研究的。</p></div></div>    
</body>
</html>