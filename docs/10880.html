<html>
<head>
<title>Supercharging Python Classes with Magic Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用神奇的方法给Python类增压</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/transforming-your-objects-into-real-python-objects-using-magic-methods-c413c9d72927?source=collection_archive---------18-----------------------#2022-02-01">https://betterprogramming.pub/transforming-your-objects-into-real-python-objects-using-magic-methods-c413c9d72927?source=collection_archive---------18-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9559" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解常见Python语法背后的方法，以及如何让您的对象使用这些语法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e1040b8bc3d1f44b6535d7fe45c3bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JtpVKGm7V6kD98u1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">朱利叶斯·德罗斯特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="361d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许，你已经注意到有可能使用某些内置方法(例如<code class="fe ls lt lu lv b">len(my_list_or_my_string)</code>)，以及语法(例如。<code class="fe ls lt lu lv b">my_list_or_my_string[:3]</code>、<code class="fe ls lt lu lv b">my_fancy_dict['some_key']</code>上的一些本土类型如<code class="fe ls lt lu lv b">list</code>、<code class="fe ls lt lu lv b">dict</code>。也许你很好奇为什么不能在你写的一些类中使用相同的语法。</p><p id="01f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本机类型的变量(<code class="fe ls lt lu lv b">list</code>、<code class="fe ls lt lu lv b">dict</code>、<code class="fe ls lt lu lv b">int</code>、<code class="fe ls lt lu lv b">str</code>)具有独特的行为，并对某些语法做出响应，因为它们在各自的类中定义了一些特殊的方法——这些方法被称为魔术方法。</p><blockquote class="lw"><p id="f2d8" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">神奇的方法只是指以双下划线开始和结束的特殊方法。它们也被称为“邓德”方法。</p></blockquote><p id="f6a0" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated">神奇的方法不是设计来直接调用的，它们是在某个动作上或者遇到特殊语法时从类内部调用的。</p><p id="5b9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探索哪些神奇的方法适用于常见的本机类型，以及如何让我们的对象表现出常见本机类型的流行行为。</p><p id="a8a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在深入研究每个原生类型的特殊方法之前，让我们先熟悉一下所有变量共有的基本方法。</p><h1 id="a806" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">理解Python中的魔法方法</h1><h2 id="f697" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated">实例化函数</h2><p id="cc27" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__new__(self, *args, **kwargs)</code>是实例创建的第一步。它首先被调用，负责<strong class="ky ir">返回</strong>你的类的一个新实例。如果希望控制创建新实例的方式，请使用此方法。</p><p id="0723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__init__(self, *args, **kwargs)</code>每当我们想要初始化一个新的实例时，这个类方法就会被调用。这样，<strong class="ky ir"> <em class="nu">就在通过<code class="fe ls lt lu lv b">__new__</code>方法创建了</em> </strong>实例之后被调用。Python中的<code class="fe ls lt lu lv b">__init__</code>方法不返回任何东西。</p><p id="578f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时调用一个对象就像调用函数一样是可能的。这是通过<code class="fe ls lt lu lv b">__call__</code>方法实现的。</p><h2 id="4474" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated">演示功能</h2><p id="9bdb" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">如果没有内置函数的帮助，对象将是非常匿名的，内置函数可以帮助识别它们并以一种不仅有意义而且在开发和测试期间有用的方式格式化它们。</p><p id="b6e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__dir__(self)</code>当用户想知道一个对象的属性时，他们可能会调用该对象的<code class="fe ls lt lu lv b">dir(...)</code>函数。然后解释器调用该对象的<code class="fe ls lt lu lv b">__dir__</code>方法。</p><p id="2ac5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__len__(self)</code>适用于包含多个元素的对象。由此我们可以调用对象上的方法<code class="fe ls lt lu lv b">len(my_object)</code>。</p><p id="1f2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__repr__(self)</code>为了调试和开发，当解释器想要明确地识别一个对象时，这个方法被调用。这个值通常包含在尖括号<code class="fe ls lt lu lv b">&lt; . . . &gt;</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标是让一个对象可读。如果该方法在类中与<code class="fe ls lt lu lv b">__repr__</code>一起使用，则<code class="fe ls lt lu lv b">__str__</code>方法的值优先。</p><p id="3079" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__sizeof__(self)</code>帮助识别对象的字节大小。</p><h2 id="326a" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated">等号</h2><p id="cd66" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">当解释器遇到两个变量之间的等号时，这些函数被调用。其中包括:</p><p id="540d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__eq__(self, x)</code>当我们比较两个变量的值是否相等时，解释器触发这个方法得到一个结果。</p><p id="92c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__gt__(self, x)</code>直观上，这代表“大于”,当大于算术符号<code class="fe ls lt lu lv b">&gt;</code>在两个变量之间时调用。它通常用于两个数值变量之间，但也可用于比较其他类型的变量。</p><p id="db16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__ge__(self, x)</code>这代表“大于或等于”,当大于或等于算术符号<code class="fe ls lt lu lv b">&gt;=</code>在两个变量之间时调用。</p><p id="0e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__lt__(self, x)</code>直观上，这代表“小于”,当大于算术符号<code class="fe ls lt lu lv b">&lt;</code>在两个变量之间时调用。</p><p id="cd78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__le__(self, x)</code>这代表“小于或等于”,当大于或等于算术符号<code class="fe ls lt lu lv b">&lt;=</code>在两个变量之间时调用。</p><h1 id="bd4d" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">本机类型的神奇方法</h1><h2 id="56c9" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated">数字</h2><p id="fda6" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">数字最明显的特征是它们的算术运算。通过简单地实现下面列举的一两个特殊方法，我们可以让我们的对象表现出与数字相同的行为，并像数字一样响应算术符号。</p><p id="e829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当两个变量之间出现“+”号时，Python解释器调用该方法。</p><p id="7de5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__mul__(self, x)</code>对于乘法算术运算，这个特殊函数由解释器隐式调用。</p><p id="def9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__sub__(self, x)</code>为了给我们的对象以从中减去的能力，我们可以加上这个方法。</p><p id="b972" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">真实世界的例子#1:一个更加Pythonic化的温度类<br/> </strong>首先，让我们定义一个简单的类来保存特定房间的温度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/95842bb96c015764917da0e85b3dddc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ra7o-PI0c3DmcW9C"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@matteofusco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马泰奥·富斯科</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a26d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图向我们的温度类的实例添加一个值时，我们得到一个错误。</p><pre class="kg kh ki kj gt ny lv nz oa aw ob bi"><span id="c7ea" class="nd mm iq lv b gy oc od l oe of">&gt;&gt;&gt; Temperature(30, 'C') + 1</span><span id="0646" class="nd mm iq lv b gy og od l oe of">TypeError: unsupported operand type(s) for +: 'Temperature' and 'int'</span></pre><p id="2cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们扩展这个类，通过实现<code class="fe ls lt lu lv b">__add__</code>方法赋予它执行算术运算的能力。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看在我们的温度类中添加一个自定义的<code class="fe ls lt lu lv b">__add__</code>方法后的结果。</p><pre class="kg kh ki kj gt ny lv nz oa aw ob bi"><span id="b5fe" class="nd mm iq lv b gy oc od l oe of">&gt;&gt;&gt; Temperature(30, 'C') + 6<br/>&lt;Temperature: 36°C&gt;</span><span id="7feb" class="nd mm iq lv b gy og od l oe of">&gt;&gt;&gt; Temperature(30, 'C') + Temperature(35.6, 'F')<br/>&lt;Temperature: 38°C&gt;</span><span id="2609" class="nd mm iq lv b gy og od l oe of">&gt;&gt;&gt; Temperature(34, 'C') + Temperature(66, 'C')<br/>&lt;Temperature: 100°C&gt;</span></pre><h2 id="8fec" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated"><strong class="ak"> Iterables:列表、元组、字符串、集合</strong></h2><p id="1d87" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__contains__(self, x)</code>当<code class="fe ls lt lu lv b">in</code>关键字被用来检查一个元素是否存在于一个iterable中时(例如:<code class="fe ls lt lu lv b">x in ["a", "b"]</code>)</p><p id="3931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__delitem__(self, key)</code>当通过<code class="fe ls lt lu lv b">del</code>关键字从iterable中删除一个项目时，该方法被触发(例如<code class="fe ls lt lu lv b">del my_dict[x]</code>)</p><p id="2fc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__getitem__(self, key)</code>当访问器语法用于变量时，该方法由解释器调用(例如:<code class="fe ls lt lu lv b">my_variable[x]</code></p><p id="aaa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__iter__(self)</code>在生成器表达式中使用<code class="fe ls lt lu lv b">iter</code>方法，一次生成数组中的一项。</p><p id="c785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">__next__(self)</code>可以和<code class="fe ls lt lu lv b">__iter__</code>一起使用，使任何对象可迭代。一旦<code class="fe ls lt lu lv b">__iter__</code>和<code class="fe ls lt lu lv b">__next__</code>对出现在任何类中，对象将响应<code class="fe ls lt lu lv b">for i in my_object</code>语法。</p><p id="406b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个方法被解释器用来在任何给定的位置设置元素。你会注意到<code class="fe ls lt lu lv b">str</code>和<code class="fe ls lt lu lv b">tuples</code>不支持项目赋值，因为它们是<strong class="ky ir">不可变的</strong>。</p><h2 id="f2bf" class="nd mm iq bd mn ne nf dn mr ng nh dp mv lf ni nj mx lj nk nl mz ln nm nn nb no bi translated">现实生活中的例子#2:拼字游戏的更Pythonic化的方法</h2><p id="2c24" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">让我们通过对一个简化的拼字游戏的概念化，将我们在这篇文章中学到的东西都变成现实。我们的拼字游戏将利用一些神奇的方法，使其以更友好的方式与解释者互动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/9a1620ef1e5bece8ff61ebb458b9331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Klyi2BIM4NERfj3B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="84e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有字母牌就没有拼字游戏可玩。拼字游戏包含字母表中的一个字母和一个数字，该数字表示玩家通过在一个回合中玩它而得分。在拼字游戏中，玩家通常会在方块之间进行比较，以选出得分最高的方块，所以让我们在设计中支持这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cf4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后可以像这样在游戏中声明和使用瓷砖:</p><pre class="kg kh ki kj gt ny lv nz oa aw ob bi"><span id="1da1" class="nd mm iq lv b gy oc od l oe of">tile_a = Tile('A', 1)<br/>tile_q = Tile('Q', 10)</span><span id="4dfd" class="nd mm iq lv b gy og od l oe of">print(tile_a)<br/># A (1)</span><span id="fea2" class="nd mm iq lv b gy og od l oe of">print(tile_q)<br/># Q (10)</span><span id="4722" class="nd mm iq lv b gy og od l oe of">print(tile_q &gt; tile_a)<br/># True</span></pre><p id="a503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">单元格<br/> </strong>接下来，我们将定义拼字板上的方块。我们知道棋盘上有255个方格。这些单元中的一些已经向玩它们的玩家奖励特殊点数。我们的细胞将保存以下数据:<code class="fe ls lt lu lv b">row</code>、<code class="fe ls lt lu lv b">column</code>、<code class="fe ls lt lu lv b">letter_multiplier</code>、<code class="fe ls lt lu lv b">word_multiplier</code>。因为我们在整个游戏中也有一个单元格实例，所以我们应该使它成为一个单独的，以防止在棋盘上多次创建一个单元格。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f82c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">董事会<br/> </strong>最后，我们将定义我们的董事会。棋盘上有游戏开始以来的所有棋步。我们将需要一个完整的游戏会话板，<strong class="ky ir">我们将使这成为一个</strong> <a class="ae kv" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">单例</strong> </a> <strong class="ky ir">类。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">移动<br/>为了在代码中表示这一点，我们可以保存一个瓷砖数组和播放瓷砖的单元格。玩家还不断权衡潜在的动作，以确定哪一个动作能给他们最高分。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="40da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当一个玩家想要比较两个移动来看哪一个更有利时，我们可以优雅地比较移动，就像我们对自然数字、字符串等所做的那样。</p><pre class="kg kh ki kj gt ny lv nz oa aw ob bi"><span id="58e4" class="nd mm iq lv b gy oc od l oe of">move_one = Move([<br/>    [tile_a, cell_1], [tile_c, cell_2], [tile_e, cell3]<br/>])<br/>print(move_one)<br/># ACE = 5</span><span id="bbdf" class="nd mm iq lv b gy og od l oe of">move_two = Move([<br/>    [tile_z, cell_1], [tile_o, cell_2], [tile_o, cell3]<br/>])<br/>print(move_two)<br/># ZOO = 12</span><span id="bf6f" class="nd mm iq lv b gy og od l oe of">print(move_one &gt; move_two)<br/># False</span><span id="8e4c" class="nd mm iq lv b gy og od l oe of">print(move_one &lt; move_two)<br/># True</span></pre><h1 id="e172" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="ff39" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">如果大型Python项目的大部分组件接受并响应我们对原生类型习以为常的大量语法——我们在Django ORM中看到了这一点，能够迭代一个<code class="fe ls lt lu lv b">QueryDict</code>,那么使用大型Python项目肯定会更加直观。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt ny lv nz oa aw ob bi"><span id="742a" class="nd mm iq lv b gy oc od l oe of"><strong class="lv ir">Want to Connect?</strong></span><span id="0760" class="nd mm iq lv b gy og od l oe of"><a class="ae kv" href="https://tomisin.dev/subscribe" rel="noopener ugc nofollow" target="_blank">Get weekly articles and coding tricks on only the topics you care about by subscribing to my channel.</a></span></pre></div></div>    
</body>
</html>