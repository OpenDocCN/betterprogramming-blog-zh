<html>
<head>
<title>Variable, References, and Lifetimes in Rust — A Practical Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的变量、参考和寿命——实用介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/variable-references-and-lifetimes-in-rust-a-practical-introduction-dd3c89527c22?source=collection_archive---------11-----------------------#2022-06-09">https://betterprogramming.pub/variable-references-and-lifetimes-in-rust-a-practical-introduction-dd3c89527c22?source=collection_archive---------11-----------------------#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6004" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">掌握防锈基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c18190018889eadbf5d244fc027272d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ytx_wdZmjqYR5N0a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将触及Rust中变量、内存和引用的一些基础知识。目标是理解为什么Rust中存在生存期，以及我们如何使用RUST编译器编写安全的代码。我们将看到一些简单的例子，突出了Rust编译器帮助我们解决引用和内存管理错误的能力。</p><h1 id="c5c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">变量</h1><p id="f336" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为开发人员，我们都知道变量。这是所有编程语言中的通用概念。</p><p id="7b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量是一个符号名，它被赋予我们程序中的值。这些在整个计划中可能会改变或保持不变。根据数据类型，赋给变量的值可以存储在堆栈或堆中。Rust提供了使用<code class="fe ms mt mu mv b">let</code>关键字声明变量的方法。参考下面的例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e89c" class="na lw it mv b gy nb nc l nd ne">fn main() { <br/>  let a = 10 ; <br/>  let b : u32 = 20 ; <br/>  let c = 2999.4 ; <br/>  let name = "hello_world" ;<br/>}</span></pre><p id="3315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像整数、浮点数和双精度数这样的简单类型存储在堆栈中。而字符串、结构或对象等复杂类型存储在堆中。</p><blockquote class="nf ng nh"><p id="e9c9" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">无论哪种情况，内存都是在变量初始化期间分配的。每当变量无效时就释放内存。</p></blockquote><p id="3f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量充当它们所指向的数据/对象的所有者。理解这一块很关键。一旦分配了所有者，只要变量有效，与变量关联的值就有效。</p><p id="3eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经熟悉了变量和引用，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-rust-ownership-model-by-example-5d586ec5e8e4">参考这篇文章来理解关于所有权的规则</a></p><p id="6467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到了变量如何拥有它们所指向的数据。我们还知道数据是可能在堆栈/堆上的内存块。(参考下图。)</p><p id="922f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量的另一个方面是变量的所有权也可以转移给其他变量。这是任何其他编程语言都不具备的部分。让我们以下面显示的真实场景为例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/38ac4a0a2401901d6ab86683bd4b729b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EATwB5oxK_MLty6_5-Q5xA.jpeg"/></div></div></figure><p id="53df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设用户A在亚马逊上买了一本书。这个用户现在是这本书的所有者。几天后，这个用户决定将这本书作为旧书出售。用户B现在购买了这本书。用户A不再拥有该书的访问权限。它被运送给用户B，我们知道所有权转移给了B。</p><p id="502c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，书是一个变量可以保存的数据。我们可以用下面的代码来表示上面的场景。我们创造了两个变量。当我们将user_a的值分配给<code class="fe ms mt mu mv b">user_b</code>时，Rust将所有权转移给用户B，就像在现实生活中会发生的一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="de35" class="na lw it mv b gy nb nc l nd ne">Ownership of Book belongs to User A Lord of the Rings<br/>Ownership of Book belongs to User B Lord of the Rings</span></pre><p id="5d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在尝试访问owner_a并再次打印，看看编译器输出是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><blockquote class="nf ng nh"><p id="e72e" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">按照逻辑，当我们试图访问user_a的书名时，如果用户并不拥有它，我们就不应该被允许这样做。而这正是Rust的编译器用下面的错误信息告诉我们的。</p></blockquote><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c240" class="na lw it mv b gy nb nc l nd ne">error<a class="ae ky" href="https://doc.rust-lang.org/stable/error-index.html#E0382" rel="noopener ugc nofollow" target="_blank">[E0382]</a>: borrow of moved value: `user_a`<br/>  <a class="ae ky" href="https://play.rust-lang.org/#" rel="noopener ugc nofollow" target="_blank">--&gt; src/main.rs:11:52<br/></a>   |<br/>7  |   let user_a = Book{name : "Lord of the Rings".to_string()}; <br/>   |       ------ move occurs because `user_a` has type `Book`, which does not implement the `Copy` trait<br/>8  |   println!("Ownership of Book belongs to User A {}" , &amp;user_a.name); <br/>9  |   let user_b = user_a ; <br/>   |                ------ value moved here<br/>10 |   println!("Ownership of Book belongs to User B {}" , user_b.name); <br/>11 |   println!("Can user A :{}: access this book ? " , user_a.name); <br/>   |                                                    ^^^^^^^^^^^ value borrowed here after move</span></pre><p id="f99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，基本类型没有这个错误，因为当我们试图给它们赋值时，值是被复制的。在复杂类型和所有存储在堆中的数据中，这是我们希望在Rust中看到的行为。</p><h1 id="ac2d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="4767" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们看了什么是变量，以及Rust如何管理它们。现在让我们看看什么是参考。</p><p id="9e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用是指向特定数据的指针。顾名思义，引用指向内存位置的地址。这听起来可能类似于C++中的引用。我们可以通过使用关键字<code class="fe ms mt mu mv b">&amp;</code>来定义一个引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d987" class="na lw it mv b gy nb nc l nd ne">A is stored at address 0x7ffeb6aa08e4<br/>New reference variable address 0x7ffeb6aa08e4</span></pre><p id="0c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这两个变量指向同一个内存地址。对内存中数据的只读指针的引用是不可变的。</p><p id="46ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以通过使用可变引用来更新值。参考下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="841e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用引用改变一个值，必须使用<code class="fe ms mt mu mv b">mut</code>关键字将原始值声明为可变的。点击这里了解更多关于不变性的信息。</p><h1 id="6348" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">借用参考文献</h1><p id="4dc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">重要的是要明白，当我们创建一个引用<code class="fe ms mt mu mv b">a_ref</code>时，我们是从所有者那里借用访问一些数据。这里的主人是变量<code class="fe ms mt mu mv b">a</code>。我们可以不变地或可变地使用数据，但所有权仍然属于原始变量。该参考具有一个必须始终有效的<code class="fe ms mt mu mv b">lifetime</code>。</p><p id="7514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个类比来理解这一点。想象一下，如果你决定从图书馆借一本书。你可以去图书馆借一本可以看两个星期的书，然后还回来。这本书仍归图书馆所有，但人们只是被允许阅读它。过了一段时间或者你看完之后需要还回来。这本书一归还，就可以被其他人借去使用。当你拥有这本书时，如果它被偷或丢失，将会有后果，你必须确保这本书永远是安全的。此外，当你拥有这本书时，没有人可以借走。另一个用户可能会借阅同一本书的不同副本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0cd9dc67af052eb20288f11b9fa6cd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJ3F179F79cpMEidmDd-Tg.jpeg"/></div></div></figure><p id="996d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常严格，但是非常像在rust中使用引用。引用从变量拥有的位置借用数据。使用引用时有一些规则。我们不会详细讨论这些规则。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-rust-ownership-model-by-example-5d586ec5e8e4">你可以在另一篇文章</a>中读到它。但是理解这一点是有帮助的，就像变量一样——引用可以被视为一种特殊类型的变量。</p><blockquote class="nf ng nh"><p id="d1a3" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">当开始使用参考资料时，RUST可能感觉我们每次都在碰壁。我们越是围绕一些简单的概念考虑数据和内存，就越容易使用RUST。</p></blockquote><h1 id="dec2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">借款和寿命</h1><p id="164a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经了解了什么是变量，什么是引用，以及引用用法的一些基本概念。我们还讨论了所有权和变量的范围。该是我们审视一生的时候了。</p><p id="494d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下例所示，一旦作用域结束，变量及其内存就会被删除。编译器确保这些检查完美完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="da66" class="na lw it mv b gy nb nc l nd ne">error<a class="ae ky" href="https://doc.rust-lang.org/stable/error-index.html#E0425" rel="noopener ugc nofollow" target="_blank">[E0425]</a>: cannot find value `b` in this scope<br/> <a class="ae ky" href="https://play.rust-lang.org/#" rel="noopener ugc nofollow" target="_blank">--&gt; src/main.rs:6:57<br/></a>  |<br/>6 |     println!("A value is {} . And b value is {} " , a , b); <br/>  |                                                         ^ help: a local variable with a similar name exists: `a`<br/></span></pre><p id="954f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust编译器确保引用和变量总是有效的。范围是一种非常简单的思考方式。</p><p id="ed7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于引用指向内存中的数据，Rust必须确保程序中的任何一点都没有无效引用。当实际数据没有意义或被完全删除时，我们不希望有引用。引用上不应发生无效的访问/操作。Rust编译器确保所有这些检查的方式是通过生存期。生存期是编译器检查这些情况并确保我们拥有的任何引用总是有效的方法。这些比作用域更高级，但是从作用域的角度考虑是很自然的。这正是Rust的优势所在，在使用<code class="fe ms mt mu mv b">safe</code> Rust时，几乎不可能出现无效的内存访问、故障或与内存和数据访问相关的漏洞。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们不会涉及太多的细节。但是当我们谈到寿命和引用时，我们会看到rust是如何帮助我们的。</p><p id="772c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到上面的例子，我们看到变量<code class="fe ms mt mu mv b">a</code>的范围直到最后都是有效的。但是请注意，在内部块中，a被指定为对<code class="fe ms mt mu mv b">y</code>的引用。一旦第6行的内部作用域阻塞，y的值就被删除。通常，我们会说<code class="fe ms mt mu mv b">a</code>现在持有一个垃圾值。因为a指向的变量不存在。但这在rust中是无效操作。Rust认为y的生命周期比a的生命周期短，超过这个时间点访问它是完全错误的。因此，它抛出以下编译时错误。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0cf1" class="na lw it mv b gy nb nc l nd ne">error<a class="ae ky" href="https://doc.rust-lang.org/stable/error-index.html#E0597" rel="noopener ugc nofollow" target="_blank">[E0597]</a>: `y` does not live long enough<br/> <a class="ae ky" href="https://play.rust-lang.org/#" rel="noopener ugc nofollow" target="_blank">--&gt; src/main.rs:5:13<br/></a>  |<br/>5 |         a = &amp;y;<br/>  |             ^^ borrowed value does not live long enough<br/>6 |     }                           // y is dropped<br/>  |     - `y` dropped here while still borrowed<br/>7 | <br/>8 |     println!("The value of 'x' is {}.", a);<br/>  |                                         - borrow later used here</span></pre><p id="c219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它明确说明y活得不够久，有些引用可能无效。</p><p id="0952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始时，我发现这很难理解，但现在对我来说感觉很自然。这些东西的建模方式帮助我们解决了运行时可能出现的许多错误。想象一下当我们处理并行和并发程序时可能出现的竞争情况。生存期使我们避免了很多这些方面，编译器为我们做了大部分繁重的工作。</p><p id="25ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将试着详细描述生命周期，以及一些编码它们的方法。希望这篇文章很好地介绍了所有这些概念。</p></div></div>    
</body>
</html>