<html>
<head>
<title>Improving AWS Lambda Cold Start Times Using Provisioned Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用供应的并发性改进AWS Lambda冷启动时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-aws-lambda-cold-start-times-using-provisioned-concurrency-803b090406c2?source=collection_archive---------3-----------------------#2021-09-09">https://betterprogramming.pub/improving-aws-lambda-cold-start-times-using-provisioned-concurrency-803b090406c2?source=collection_archive---------3-----------------------#2021-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bb4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的web应用程序配置供应的并发性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac3f8366ad12600e37d2070390c740ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0YMB9Ab7GbhPbfSg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚采克·迪拉格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="60ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS Lambda是一款经济高效且高度可扩展的无服务器计算解决方案，无需部署或管理服务器即可轻松运行代码。因此，大量企业选择将他们的生产代码部署到AWS Lambda，以便为他们的客户服务。这段代码的很大一部分是需要快速响应的web服务器应用程序(&lt; 1 s)to user requests. AWS lambda cold starts can make it hard to hit this performance requirement.</p><p id="706c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">This blog looks into solving cold start issues by using provisioned concurrency. The sections covered include:</p><ul class=""><li id="0a07" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">What are cold starts?</li><li id="adb9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">What is provisioned concurrency?</li><li id="7b47" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Configuring Provisioned Concurrency using the Console</li><li id="c438" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Configuring Provisioned Concurrency Programmatically. (useful for a CI/CD pipelined)</li><li id="a644" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Using provisioned instances</li><li id="2182" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Using cloud watch events</li></ul><h1 id="57dd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">What Are Cold Starts?</h1><p id="2b38" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Despite AWS Lambda’s significant benefits, one of its main downsides is the <a class="ae ky" href="https://mikhail.io/serverless/coldstarts/aws/" rel="noopener ugc nofollow" target="_blank">经典的冷启动</a>问题)。</p><p id="31cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个新的Lambda工作进程的第一个请求通常需要相对较长的时间来完成的地方，例如3-20秒。这是AWS Lambda或Google Cloud函数等无服务器功能工作方式的一个缺点，因为它们试图优化价格、可伸缩性和可维护性。通常，创建执行环境时的无服务器功能生命周期如下(根据<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html#runtimes-lifecycle-ib" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>):</p><ol class=""><li id="9e1f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">使用配置的资源创建或解冻执行环境，即分配运行应用程序代码所需的适当CPU和内存(初始化阶段)。</li><li id="4d65" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">下载Lambda函数使用的应用程序、扩展和层所需的任何代码(初始化阶段)。</li><li id="ba06" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">初始化扩展和运行时，以及主处理函数之外的任何应用程序代码(初始化阶段)。</li><li id="44a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">当一个请求被发送时，Lambda调用运行核心业务逻辑的函数处理器(调用阶段)。Lambda函数的第二次调用跳过了步骤1、2和3，因此响应时间更快。</li><li id="1337" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">如果在一段特定的时间后没有调用发生，比如最多15分钟，AWS Lambda将关闭运行时，停止扩展，并删除环境。(关闭阶段)</li></ol><p id="f2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，在一个函数的生命周期中有三个主要阶段:初始化阶段、调用阶段和关闭阶段。init阶段总是发生在新的实例被创建的时候，无论是在新的部署过程中还是在扩展Lambda函数的时候。在冷启动期间，初始化阶段和有时调用阶段是过程的瓶颈。</p><p id="4afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个要点需要注意:</p><ul class=""><li id="0e55" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向上扩展的过程并不一定意味着当平台上有多个用户时，如果您正在使用javascript前端运行一个web应用程序，通常会向后端并发发出多个请求，例如获取用户信息、获取用户配置等。如果在Lambda函数已经在处理前一个请求时收到这些请求中的一个，那么将创建一个新的Lambda实例，从而经历init和invoke阶段。即使平台上只有一个用户，只要该用户同时向后端发送多个请求，这种情况也会发生。</li><li id="ccc7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">初始启动时，调用阶段可能会很慢。这是因为即使Lambda在init阶段在主处理程序方法之外初始化应用程序代码，有时应用程序代码也需要在内部初始化，即连接到适当的数据库、下载配置、执行健全性检查等(尤其是在web服务器上)。</li></ul><h1 id="bfa8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">什么是调配并发？</h1><p id="65c1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">有几种方法可以减轻冷启动问题。<a class="ae ky" href="https://aws.amazon.com/blogs/compute/new-for-aws-lambda-predictable-start-up-times-with-provisioned-concurrency/" rel="noopener ugc nofollow" target="_blank">供应并发</a>就是武器库中的一个这样的工具。</p><p id="9f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，保持活动以处理传入请求的Lambda worker实例的最小数量取决于Lambda实例的最后一次调用。这意味着如果一个实例在一段时间内没有被调用，那么该实例将关闭，最终将没有可用的实例来处理新的请求。</p><p id="d0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">供应并发所做的只是分配特定数量的Lambda实例，使其始终可用于处理请求。这些实例不会在调用完成时关闭，必须手动关闭。</p><p id="9ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建预配实例时，它解决了与函数生命周期的init阶段相关的冷启动问题。但是，如果在调用阶段仍然需要额外的内部初始化，例如连接到数据库等。在新设置的实例上仍会遇到这种情况。</p><p id="628c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已处理请求的预配实例在后续请求中不会遇到此问题，直到实例被终止。要修复冷启动调用，云观察事件是有帮助的，但不是必需的，尤其是在CI/CD设置中部署新实例时。</p><h2 id="a5eb" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">成本考虑</h2><p id="8be2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">需要注意的重要一点是，供应的并发性不是免费的，有相关的成本。成本是从所提供的实例开始到结束计算的，取决于分配给该功能的内存量以及所提供的实例数量。</p><p id="5fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设us-east-1区域中每个实例的内存为512 MB1个实例每月花费5.58美元，5个实例每月花费27.90美元，50个实例每月花费279.02美元，500个实例每月花费2790.22美元，依此类推，下图显示了这一趋势。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/bb8ad893cacbe981a2dc6067a5f6f312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imLaLfx1GEljElUewAbwpw.png"/></div></div></figure><p id="8c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，价格呈线性增长，因此在创建供应实例时要考虑到这一点。</p><h2 id="6f30" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">提供的并发不是保留的并发</h2><p id="f1ab" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">人们可能犯的一个错误是使用保留并发来解决冷启动问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/d220bc1751570497981e29505c2effff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OcVFZQVmyVQMzPGMQve5Q.png"/></div></div></figure><p id="c236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置保留并发设置，设置Lambda函数可以创建的最大实例数。例如，如果设置为5，则意味着最多只允许5个实例，因此只能处理5个并发请求，任何溢出请求都将返回5XX错误。</p><h1 id="6baa" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从AWS控制台配置调配的并发性</h1><h2 id="38e9" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">别名和版本</h2><p id="1d83" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们创建预配实例之前，需要对<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html" rel="noopener ugc nofollow" target="_blank">别名</a>和<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html" rel="noopener ugc nofollow" target="_blank">版本</a>有一个基本的了解，因为它们决定了哪个代码库将被部署到预配实例中。</p><p id="d401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">版本通常是自动递增的整数，其中最新的整数(例如77)表示最后发布的版本。一个版本还有一个<code class="fe nv nw nx ny b">$LATEST</code> <strong class="lb iu"> </strong>标签，它会自动映射到你的代码库的最后一个发布版本。可以通过两种方式访问Lambda函数；</p><ol class=""><li id="a7eb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">使用一个非限定的ARN，例如<code class="fe nv nw nx ny b">arn:aws:lambda:aws-region:acct-id:function:helloworld</code>，这个方法隐式地调用$LATEST标签。</li><li id="06a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">使用一个合格的ARN，例如<code class="fe nv nw nx ny b">arn:aws:lambda:aws-region:acct-id:function:helloworld:&lt;version|alias&gt;</code>，其中<code class="fe nv nw nx ny b">&lt;version|alias&gt;</code>可以是一个数字，例如一个版本的42，或者一个特定的别名，并调用代码库的一个特定版本。</li></ol><p id="9c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别名只是一个指向特定版本的指针，这使得更新应用程序代码变得容易，而不必更新上游服务，例如API Gateway、Dynamodb等。使用lambda函数的ARN。</p><p id="24ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建预配实例时，不能使用<code class="fe nv nw nx ny b">$LATEST</code>版本标签，也不能使用指向<code class="fe nv nw nx ny b">$LATEST</code>版本的别名。你需要陈述一个具体的发布版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/4f65f4918efdab85caa7ead8cd4389e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rL6l19HG8HieCnlEfSy2Sg.png"/></div></div></figure><h2 id="17b3" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">创建别名</h2><p id="cb5b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在决定使用别名还是版本时，最好使用别名而不是版本。这将简化CI/CD管道，尤其是在使用API Gateway和任何需要使用合格ARN的相关服务时。</p><p id="0634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建别名，请选择别名选项卡，然后选择添加别名按钮。应显示以下视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9369ed3be1063a43cfabaf94b69fa31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26Lrqy0PYfim4m6pMJnz1A.png"/></div></div></figure><p id="8f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择您的别名，然后选择该别名应该关联的版本。请注意，更新别名时，请始终检查加权别名，如果设置了加权别名，请将其更改为0。然而，当以编程方式完成时，情况不应该是这样。</p><h2 id="e1a4" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">创建预配的实例</h2><p id="07b0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">创建别名后，现在就可以创建调配的实例了。首先，选择Configuration选项卡，然后选择侧面导航中的provisioned concurrency链接，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0838d35fa12bfea7a6053f956c876e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bM8nqxPj3-JcR_HpY1vvg.png"/></div></div></figure><p id="e6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择“添加配置”按钮将允许您选择预配实例的数量以及部署到预配实例的别名，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/3f30a15eaf163cb3e6b7e698e5004b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8fGy7PhB--nnVojIGWrLg.png"/></div></div></figure><p id="45ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于该特定区域，您还将看到所调配实例的相关成本。最初，状态将是<code class="fe nv nw nx ny b">In progress</code>，几分钟后，当所有实例都已被提供时，状态将变为<code class="fe nv nw nx ny b">Ready</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/b3ad8f6ca990aaf238845e2b677ec6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISPQnjXnEGq5EmbTFLG4lQ.png"/></div></div></figure><h1 id="444e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">以编程方式配置调配的并发</h1><p id="ecc2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">从控制台创建调配的并发配置使我们能够看到创建它所涉及的步骤，但是，这在发布版本不断变化的生产环境中是不实际的。解决这个问题的一个方法是以编程方式创建一个预配的并发配置。</p><p id="167e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分代码是从Django Zappa包中的<a class="ae ky" href="https://github.com/Miserlou/Zappa/issues/2047#issuecomment-599132143" rel="noopener ugc nofollow" target="_blank">问题注释</a>中的<code class="fe nv nw nx ny b"><a class="ae ky" href="https://github.com/alecl" rel="noopener ugc nofollow" target="_blank">alecl</a></code>借用来的。它提供了关于如何更新活动版本和创建新实例的见解。修改后的脚本如下:</p><pre class="kj kk kl km gt oe ny of og aw oh bi"><span id="2ec8" class="nh mk it ny b gy oi oj l ok ol">function_name=&lt;my-function-name&gt;<br/>alias=LIVE<br/>instances=5</span><span id="04df" class="nh mk it ny b gy om oj l ok ol">deployedversion=$(aws lambda list-versions-by-function --function-name $function_name --region $REGION --query "to_number(Versions[-1].[Version][0])" --no-paginate)</span><span id="d853" class="nh mk it ny b gy om oj l ok ol">echo "Resetting provisioned concurrency on alias LIVE"<br/>aws lambda delete-provisioned-concurrency-config --region $REGION \<br/>    --function-name $function_name \<br/>    --qualifier LIVE</span><span id="4fb5" class="nh mk it ny b gy om oj l ok ol">echo "Updating alias LIVE to $deployedversion"<br/>aws lambda update-alias \<br/>    --function-name $function_name \<br/>    --function-version $deployedversion \<br/>    --name $alias</span><span id="299d" class="nh mk it ny b gy om oj l ok ol">echo "Setting provisioned concurrency to $instances"<br/>aws lambda put-provisioned-concurrency-config \<br/>        --function-name $function_name \<br/>        --qualifier $alias \<br/>        --provisioned-concurrent-executions $instances</span></pre><p id="a598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本假设存在别名和已配置的实例，如果不存在，可以很容易地更新以考虑这种情况。上述脚本中指示的步骤如下:</p><ol class=""><li id="0ca1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">为函数名、别名和实例数设置变量。</li><li id="6cf5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">检索代码库的最新部署版本。</li><li id="56a7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">删除使用实时别名的现有预配实例。如果没有提供实例，这将导致错误。</li><li id="1135" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">将别名更新到最新部署的版本，如果没有别名，这应该是一个<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/reference/lambda/create-alias.html" rel="noopener ugc nofollow" target="_blank">创建别名</a>命令，而不是<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/reference/lambda/update-alias.html" rel="noopener ugc nofollow" target="_blank">更新别名</a>。</li><li id="c545" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">最后，使用别名以及要创建的实例数量来创建已调配的并发配置。</li></ol><h1 id="a9bc" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用预配的实例</h1><p id="1066" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一旦使用别名或版本创建了供应的实例。始终记住使用具有正确别名或版本号的合格ARN，例如<code class="fe nv nw nx ny b">arn:aws:lambda:aws-region:acct-id:function:helloworld:&lt;version|alias&gt;</code>。</p><p id="0529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用未限定的ARN，例如<code class="fe nv nw nx ny b">arn:aws:lambda:aws-region:acct-id:function:helloworld</code>而不指定别名或版本号，这意味着将调用未部署到预配实例的<code class="fe nv nw nx ny b">$LATEST</code>版本，因此会遇到冷启动问题。</p><h1 id="3898" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用云观察事件</h1><p id="2d86" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如前所述，预配实例解决了问题的初始化阶段，但是如何解决调用阶段呢？为此，我们需要利用<a class="ae ky" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank">云监控</a>事件来实际调用我们的函数处理程序。</p><p id="6381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，熟悉冷启动问题的人可能会想，为什么需要创建预配实例，为什么不简单地使用云观察事件来预热实例呢？</p><p id="ac8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的主要问题是云观察事件是同步的，计划事件中的最小时间间隔是1分钟。这意味着在不使用预配实例或别名的正常设置中，最多只能保持一个实例运行。</p><p id="5505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，通过提供别名，通过提供实例，这种一分钟一次的单一事件被随机地分布在多个提供的实例上，从而调用Lambda实例。</p><p id="d79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仅在最初为预配实例创建执行环境时有用。一旦被调用，云监视事件就是多余的。这意味着这一步是可选的，但为了完整起见添加它。</p><p id="b700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建<a class="ae ky" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank">云观察</a>事件，选择云观察服务，并在左侧导航中选择规则，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/ca3df9028c46d2818f6075fc5a0407b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcRLkqtcNHsbVkaRFWiw-w.png"/></div></div></figure><p id="6642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择schedule单选按钮，并定义事件的速率和目标。从下拉列表中选择函数、别名以及触发函数处理程序所需的输入转换器。</p><p id="6c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会将事件随机发送到您提供的实例，因此，调用是基于预定的速率。如前所述，这一步不是必需的，但是可以确保您的函数在部署时能够快速响应请求。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="d207" class="mj mk it bd ml mm ov mo mp mq ow ms mt jz ox ka mv kc oy kd mx kf oz kg mz na bi translated">结论</h1><p id="bc50" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">希望这篇博客能让你更容易地创建一个预配置的并发配置，以及如何使用和改进它。</p><p id="c486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或想安排一个简短的电话与我联系以澄清任何困惑，您可以通过<a class="ae ky" href="https://mbele.io/mark" rel="noopener ugc nofollow" target="_blank">https://mbele.io/mark</a>找到我</p><p id="39ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><h1 id="cac2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考资料:</h1><ul class=""><li id="9762" class="lv lw it lb b lc nb lf nc li pa lm pb lq pc lu ma mb mc md bi translated"><a class="ae ky" href="https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/" rel="noopener ugc nofollow" target="_blank"> AWS新闻博客</a></li><li id="2ea7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://lumigo.io/blog/this-is-all-you-need-to-know-about-lambda-cold-starts/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda冷启动:解决问题</a></li><li id="ae01" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikhail.io/serverless/coldstarts/aws/" rel="noopener ugc nofollow" target="_blank">AWS Lambda中的冷启动</a></li><li id="9444" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://builtin.com/software-engineering-perspectives/cold-starts-challenge-serverless-architecture" rel="noopener ugc nofollow" target="_blank">冷启动挑战无服务器架构</a></li></ul></div></div>    
</body>
</html>