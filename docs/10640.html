<html>
<head>
<title>Networking With Combine and SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Combine和SwiftUI联网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/networking-with-combine-and-swiftui-fdf8182f7360?source=collection_archive---------17-----------------------#2022-01-19">https://betterprogramming.pub/networking-with-combine-and-swiftui-fdf8182f7360?source=collection_archive---------17-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4016" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用反应式编程执行网络呼叫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53da9f03a556379e63a83a48511d4365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BwtcquhhSXo07rur.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于SF符号中“网络”图标的标题图像</p></figure><p id="21c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不及时更新应用程序不同部分的用户界面会导致非常糟糕的用户体验，我相信我们都知道至少有一两个应用程序因为这种行为而臭名昭著。</p><p id="e669" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编写在UI和底层数据模型之间保持状态同步的应用程序传统上是一项艰巨的任务，开发社区已经提出了许多方法来以或多或少对开发人员友好的方式解决这一挑战。</p><p id="9711" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反应式编程就是这样一种方法，SwiftUI的反应式状态管理通过引入真理的<em class="lu">来源</em>的概念使这变得容易得多，真理的<em class="lu">来源可以使用SwiftUI的属性包装器如<code class="fe lv lw lx ly b">@EnvironmentObject</code>、<code class="fe lv lw lx ly b">@ObservedObject</code>和<code class="fe lv lw lx ly b">@StateObject</code>在您的应用程序中共享。</em></p><p id="62e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实的来源通常是内存中的数据模型——但是众所周知，没有一个应用程序是孤立存在的。大多数现代应用程序需要在某个时候访问网络(或其他服务)，这意味着向应用程序引入异步行为。在我们的应用程序中，有很多方法可以处理异步行为:委托方法、回调处理程序、合并和异步/等待，等等。</p><p id="9df5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个系列中，我们将看看如何在SwiftUI的上下文中使用<strong class="la iu"> Combine </strong>来</p><ul class=""><li id="4914" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">接入网络，</li><li id="623e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">地图数据，</li><li id="fa1d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">处理错误</li></ul><p id="e4b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…并处理一些高级场景。</p><p id="764f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从了解如何使用Combine从服务器获取数据并将结果映射到Swift <code class="fe lv lw lx ly b">struct</code>开始。</p><h1 id="14b9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">如何使用URLSession获取数据</h1><p id="993b" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">让我们假设我们正在开发一个应用程序的注册屏幕，其中一个需求是检查用户选择的用户名在我们的用户数据库中是否仍然可用。这需要我们与授权服务器进行通信。下面是一个请求，显示了我们如何尝试找出用户名<em class="lu"> sjobs </em>是否仍然可用:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="f9d2" class="no mo it ly b gy np nq l nr ns">GET localhost:8080/isUserNameAvailable?userName=sjobs HTTP/1.1</span></pre><p id="e518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，服务器会回复一个简短的JSON文档，说明用户名是否仍然可用:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="b4d4" class="no mo it ly b gy np nq l nr ns">HTTP/1.1 200 OK <br/>content-type: application/json; charset=utf-8 <br/>content-length: 39 <br/>connection: close <br/>date: Thu, 06 Jan 2022 16:09:08 GMT  <br/>{"isAvailable":false, "userName":"sjobs"}</span></pre><p id="b66d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在Swift中执行这个请求，我们可以使用<code class="fe lv lw lx ly b">URLSession</code>。使用<code class="fe lv lw lx ly b">URLSession</code>从网络获取数据的传统方式如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="746e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这段代码运行良好，本身没有任何问题，但它确实存在一些问题:</p><ol class=""><li id="93bd" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nv mf mg mh bi translated">目前还不清楚快乐路径是什么——返回成功结果的唯一位置是非常隐蔽的(1 ),不熟悉使用完成处理程序的开发人员可能会对快乐路径甚至不使用<code class="fe lv lw lx ly b">return</code>语句将网络调用的结果传递给调用者这一事实感到困惑。</li><li id="72bc" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">错误处理分散在各处(2，3，4，5)。</li><li id="d57e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">有几个退出点，很容易忘记<code class="fe lv lw lx ly b">if let</code>条件中的<code class="fe lv lw lx ly b">return</code>语句之一。</li><li id="915c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">总的来说，它很难阅读和维护，即使你是一个有经验的Swift开发人员。</li><li id="eb4e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">很容易忘记你必须打电话给<code class="fe lv lw lx ly b">resume()</code>来实际执行请求(6)。我很确定我们大多数人都疯狂地寻找bug，结果却发现我们忘记了使用<code class="fe lv lw lx ly b">resume</code>来启动请求。是的，我认为<code class="fe lv lw lx ly b">resume</code>对于一个被集成来<em class="lu">发送</em>请求的API来说不是一个好名字。</li></ol><blockquote class="nw nx ny"><p id="32be" class="ky kz lu la b lb lc ju ld le lf jx lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">运行代码示例</em> </strong></p><p id="0934" class="ky kz lu la b lb lc ju ld le lf jx lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated"><em class="it">你会在附带的</em> <a class="ae oc" href="https://github.com/peterfriese/SwiftUI-Combine-Applied" rel="noopener ugc nofollow" target="_blank"> <em class="it"> GitHub资源库</em> </a> <em class="it">中找到所有的代码样本，在</em> <code class="fe lv lw lx ly b"><em class="it">Networking</em></code> <em class="it">文件夹中。为了最大程度地受益，我还在</em> <code class="fe lv lw lx ly b"><em class="it">server</em></code> <em class="it">子文件夹中提供了一个演示服务器(用Vapor构建)。要在您的机器上运行它，请执行以下操作:</em></p></blockquote><h1 id="6a9c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">如何使用Combine获取数据</h1><p id="9ac9" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">当他们推出Combine时，苹果为他们自己的许多异步API增加了发行商。这很好，因为这使我们更容易在自己的联合收割机管道中使用它们。</p><p id="e830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们来看看代码在利用Combine进行重构后的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="23f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经很容易阅读了，而且(除了确保我们得到有效URL的<code class="fe lv lw lx ly b">guard</code>语句)只有<em class="lu">一个</em>出口点。</p><p id="b611" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一步一步地浏览代码:</p><ol class=""><li id="d195" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nv mf mg mh bi translated">我们使用<code class="fe lv lw lx ly b">dataTaskPublisher</code>来执行请求。此发布者是一次性发布者，一旦请求的数据到达，它将发出一个事件。值得记住的是，如果没有订阅者，联合发布者不执行任何工作。这意味着，除非至少有一个订阅者，否则该发布者不会对给定的URL执行任何调用。稍后我将向您展示如何将这个管道连接到UI，并确保每次用户输入他们的首选用户名时都会调用它。</li><li id="2eb7" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">一旦请求返回，发布者发出一个包含<code class="fe lv lw lx ly b">data</code>和<code class="fe lv lw lx ly b">response</code>的值。在这一行中，我们使用<code class="fe lv lw lx ly b">map</code>操作符来转换这个结果。如您所见，我们可以重用先前版本代码中的大部分数据映射代码，除了一些小的更改:</li><li id="202d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">我们可以返回一个<code class="fe lv lw lx ly b">Boolean</code>值来指示用户名是否仍然可用，而不是调用<code class="fe lv lw lx ly b">completion</code>闭包。该值将通过管道向下传递。</li><li id="badc" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">在数据映射失败的情况下，我们捕捉错误并返回<code class="fe lv lw lx ly b">false</code>，这似乎是一个很好的妥协。</li><li id="f04f" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">对于访问网络时可能出现的任何错误，我们也是这样做的。这是一种简化，我们可能需要在未来重新审视。</li></ol><p id="afb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这看起来比最初的版本更好，更容易阅读，我们可以在这里停下来，将它集成到我们的应用程序中。</p><p id="466c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们可以做得更好。这里有三个变化，将使代码更线性，更容易推理:</p><h1 id="09bc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用关键路径解构元组</h1><p id="c357" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们经常发现自己处于需要从变量中提取特定属性的情况。在我们的例子中，我们接收到一个包含我们发送的URL请求的<code class="fe lv lw lx ly b">data</code>和<code class="fe lv lw lx ly b">response</code>的元组。下面是<code class="fe lv lw lx ly b">URLSession</code>中各自的声明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="465d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Combine提供了一个重载版本的<code class="fe lv lw lx ly b">map</code>操作符，允许我们使用一个键路径来析构元组，并且只访问我们关心的属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="dd50" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">更轻松地映射数据</h1><p id="4364" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">由于映射数据是一项如此常见的任务，Combine提供了专门的操作符来使它变得更容易:<code class="fe lv lw lx ly b">decode(type:decoder:)</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="28b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将从上游发布者返回decode的<code class="fe lv lw lx ly b">data</code>值，并将其解码为一个<code class="fe lv lw lx ly b">UserNameAvailableMessage</code>实例。</p><p id="0bed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以再次使用<code class="fe lv lw lx ly b">map</code>操作符来析构<code class="fe lv lw lx ly b">UserNameAvailableMessage</code>并访问它的<code class="fe lv lw lx ly b">isAvailable</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="fcca" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用合并提取数据，简化</h1><p id="9913" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有了所有这些变化，我们现在有了一个易于阅读的管道版本，并且有一个线性流程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="ebdd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">如何连接SwiftUI</h1><p id="4b57" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">最后，让我们看看如何在我们假设的注册表单中集成这个新的联合管道。</p><p id="ac72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个精简版的注册表单，只包含一个用户名字段、一个显示消息的<code class="fe lv lw lx ly b">Text</code>标签和一个注册按钮。在实际的应用程序中，我们还需要一些UI元素来提供密码和密码确认。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="83d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有UI元素都连接到一个视图模型，以分隔关注点并保持视图整洁易读:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6679" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe lv lw lx ly b">@Published</code>属性是组合发布者，我们可以订阅它们，以便在它们的值改变时接收更新。这允许我们调用上面创建的<code class="fe lv lw lx ly b">checkUserNameAvailable</code>管道。</p><p id="818b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个可重用的publisher，我们可以用它来驱动UI中需要显示依赖于用户名是否可用的信息的部分。一种方法是创建一个惰性计算属性。这确保了只有在需要时才会建立管道，并且只有一个管道实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ff46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要调用另一个管道并使用其结果，我们可以使用<code class="fe lv lw lx ly b">flatMap</code>操作符。这将从上游发布者获取所有输入事件(即由<code class="fe lv lw lx ly b">$username</code> published属性发出的值)，并将它们转换成一个新的发布者(在我们的例子中，是发布者<code class="fe lv lw lx ly b">checkUserNameAvailable</code>)。</p><p id="5c93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一步也是最后一步，我们将把<code class="fe lv lw lx ly b">isUsernameAvailablePublisher</code>的结果连接到UI。如果您看一下视图模型，您会注意到我们在视图模型的输出部分有两个属性:一个用于与用户名相关的任何消息，另一个保存表单的整体验证状态(记住，在实际的注册表单中，我们可能还需要验证密码字段)。</p><p id="af90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">联合收割机发布器可以连接到多个订户，因此我们可以将<code class="fe lv lw lx ly b">isValid</code>和<code class="fe lv lw lx ly b">usernameMessage</code>连接到<code class="fe lv lw lx ly b">isUsernameAvailablePublisher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="54ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这种方法允许我们重用<code class="fe lv lw lx ly b">isUsernameAvailablePublisher</code>并使用它来驱动表单的整体<code class="fe lv lw lx ly b">isValid</code>状态(这将启用/禁用<em class="lu">提交</em>按钮),以及通知用户他们选择的用户名是否仍然可用的错误消息标签。</p><h1 id="26fa" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">如何处理“不允许从后台线程发布更改”</h1><p id="500a" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">运行这段代码时，您会注意到几个问题:</p><ol class=""><li id="861f" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nv mf mg mh bi translated">对于您键入的每个字符，API端点都会被调用几次</li><li id="b990" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nv mf mg mh bi translated">Xcode告诉你不应该从后台线程更新UI</li></ol><p id="e212" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在接下来的几集中，我们将更深入地探究这些问题的原因，但是现在，让我们先来解决这个错误消息:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="f2ee" class="no mo it ly b gy np nq l nr ns">SwiftUI] Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</span></pre><p id="63e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出现此错误消息的原因是，Combine将在后台线程上执行网络请求。当请求被满足时，我们将结果分配给视图模型上的一个已发布的属性。反过来，这将提示SwiftUI更新UI——这将发生在前台线程上。</p><p id="5051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止这种情况发生，我们需要使用<code class="fe lv lw lx ly b">receive(on:)</code>操作符指示Combine在收到网络请求的结果后切换到前台线程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1ae8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一集讨论联合调度器时，我们将深入探讨线程化。</p><h1 id="3739" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">关闭</h1><p id="4479" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在本文中，我向您展示了如何使用Combine访问网络，以及这如何使您能够编写比相应的回调驱动代码更易于阅读和维护的直线代码。</p><p id="ad03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还研究了如何通过使用视图模型将向SwiftUI发出网络请求的联合管道连接起来，并将管道附加到一个<code class="fe lv lw lx ly b">@Published</code>属性。</p><p id="caa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，你可能想知道为什么<code class="fe lv lw lx ly b">isUsernameAvailablePublisher</code>使用<code class="fe lv lw lx ly b">Never</code>作为它的错误类型——毕竟，网络错误是我们需要处理的事情。</p><p id="820d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在下一集研究错误处理(和自定义数据映射)。我们还将研究优化基于Combine的网络层的方法，敬请关注！</p><p id="5b45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读🔥</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="e7d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">原发布于</em><a class="ae oc" href="https://peterfriese.dev/posts/swiftui-combine-networking-gettingstarted/" rel="noopener ugc nofollow" target="_blank"><em class="lu">https://peterfriese . dev</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>