<html>
<head>
<title>All Code Is Legacy Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有代码都是遗留代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/all-code-is-legacy-code-4d3df80d0979?source=collection_archive---------13-----------------------#2019-11-06">https://betterprogramming.pub/all-code-is-legacy-code-4d3df80d0979?source=collection_archive---------13-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f078" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">遗留代码与坏代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e0a0630f4f32c81e48801c6c383c0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ScZSC40m756hGB4z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须承认我对“遗留代码”这个术语有点过敏。当程序员加入一个项目，但他们不喜欢现有的代码库时，经常会用到这个短语。</p><p id="8a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，他们会有一种压倒一切的重写一切的冲动。但是让我们面对现实吧，谁<em class="lv">喜欢现有的代码库呢？我们大多数人都生活在一种持续的状态中，感觉我们的代码可以显著地改进。乔尔·斯波尔斯基给了<a class="ae ky" href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" rel="noopener ugc nofollow" target="_blank">这个非常简单的理由</a>:</em></p><blockquote class="lw"><p id="bff3" class="lx ly it bd lz ma mb mc md me mf lu dk translated">“[程序员]认为旧代码一团糟的原因是因为一个重要的、基本的编程法则:</p><p id="61c9" class="lx ly it bd lz ma mb mc md me mf lu dk translated"><strong class="ak">读代码比写代码难。”</strong></p></blockquote><p id="e87a" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">事实是:所有代码都是遗留代码。</p><p id="dcfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名程序员，你正在编写代码，现在，如果代码进入生产，一旦软件发布，它就立即成为遗留代码。</p><p id="a20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们该如何应对？斯波尔斯基认为，一个公司可能做出的最糟糕的战略决策之一就是从头开始重写大量代码。</p><p id="4771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这样做的时候，开发人员丢弃了嵌入代码中的价值:修复、变通办法、专家知识，同时潜在地制造了更多的问题。</p><p id="b771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该考虑重写的方式是，我们用新的遗留代码替换旧的遗留代码。循环往复！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="fa89" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">遗留代码与坏代码</h1><p id="e0e0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">有大量好的预先存在的代码，并且应该尽可能长时间地维护这些代码。你用来阅读这篇文章的操作系统和网络浏览器有可能运行在数百万行遗留代码上。</p><p id="3781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解释一下<a class="ae ky" href="https://www.goodreads.com/work/quotes/108084-the-c-programming-language" rel="noopener ugc nofollow" target="_blank">比雅尼·斯特劳斯特鲁普</a>:有两种计算机程序:包含遗留代码的和没人用的。如果你加入一个项目，有一个15年的代码库仍然做着它的设计，没有错误，培育它，不要重写它。</p><p id="68af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一段代码在代码库中存在的时间越长，它能提供的价值就越大。客户不关心代码的年龄，他们关心的是工作软件。</p><p id="4fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是否意味着我们应该<em class="lv">永远不要</em>重写代码，或者所有的旧代码都是好的？当然不是！</p><p id="8dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，作为程序员，我们需要对什么是不好的、不正确的或有缺陷的有一种感觉，并且将这种感觉与一段代码存在的时间分离开来。我们还需要考虑的是，处理<em class="lv">坏的</em>遗留代码的绝对最好的方法是首先不要写它…</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9fa8" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">如何编写“好的遗留代码”</h1><p id="4aa1" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这里有一些编写<em class="lv">好的</em>遗留代码的快速起点。代码写起来比读起来容易得多，解决问题的最好方法就是不要制造问题。</p><h2 id="1f4f" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated"><strong class="ak"> 1。少写代码</strong></h2><p id="bd62" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">更少的代码=更少的潜在错误=更少的维护=更少的“坏遗产”。</p><p id="3712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总体而言，编写更少的代码可以被视为改进代码的唯一最重要的方法。<a class="ae ky" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干原则</a>可以被看作是一个自然的推论，也是写得更少、成就更多的主要方法。</p><h2 id="4edf" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated"><strong class="ak"> 2。避免// TODO和// FIXME </strong></h2><p id="7f95" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">写<code class="fe ob oc od oe b">// TODO</code>或<code class="fe ob oc od oe b">// FIXME</code>应该被视为一个红旗和一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">码气味</a>。</p><p id="4acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把这些评论翻译成它们的实际意思，那么“TODO”翻译成“创建技术债务”，而“FIXME”翻译成“我故意写一个bug”。</p><p id="6dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能会有极少数的例外情况，延迟解决方案比现在解决它的好处更大，但是一般来说，TODO和FIXME应该保持在最低限度。</p><h2 id="8627" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated"><strong class="ak"> 3。比起前沿，更喜欢已有的习惯用法</strong></h2><p id="f8b8" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这可能看起来矛盾…使用前沿技术使代码更“新”，对吗？是的，但这也创造了更快过时的可能性。</p><p id="a2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也让新程序员更难搞清楚事情。如果代码是使用已建立的习惯用法和框架编写的，它可能更容易阅读，并且有更好的机会在未来工作更长时间。</p><h2 id="3493" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated"><strong class="ak"> 4。总是让代码处于比发现时更好的状态</strong></h2><p id="7dcb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这似乎与开头提到的“不重写”相矛盾，然而，持续改进和重构不同于进行重大重写。</p><p id="a964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试着养成逐渐地、增量地改进事情的习惯。有时确实需要大规模的重构或重写，但是这种重构或重写的商业价值需要与其他优先级仔细权衡。</p><h2 id="6b9e" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated"><strong class="ak"> 5。作为程序员不断进步</strong></h2><p id="da02" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">阅读书籍，阅读博客文章，阅读他人的代码，仔细思考设计和编程实践。有意识地反思你的代码，想办法改进。</p><p id="7f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要责怪前任程序员留下了不好的遗产，要确保你不会成为创造新遗产的程序员。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b0ae" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">但是…如果您继承了一些真正糟糕的遗留代码呢？</h1><p id="f01f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">希望你现在已经明白了，我并不是说所有的遗留代码都是好的，而是说它们并不都是坏的，避免坏代码的最好方法是一开始就不要写。</p><p id="6089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有些时候，我们继承(或创造！)一堆糟糕透顶的代码。在这些情况下，Jonathan Boccara的<a class="ae ky" href="https://leanpub.com/legacycode" rel="noopener ugc nofollow" target="_blank"> <em class="lv">遗留代码程序员工具箱</em> </a>是学习一些处理代码库的关键技术的一个很好的起点。</p><p id="0704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在我们有大量“糟糕的遗留代码”的情况下，也可能会有一个渐进重构或用包装器抽象出复杂性的论点，而不是深入全面重写。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c4df" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">就这样结束了</h1><p id="fc59" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我希望这篇文章能有所帮助，发人深省。勇往直前，不要成为编写糟糕的遗留代码的“那个人”。</p></div></div>    
</body>
</html>