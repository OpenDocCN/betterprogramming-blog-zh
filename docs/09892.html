<html>
<head>
<title>Embracing Algorithms in Your SwiftUI Painting App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI绘画应用中采用算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/embracing-algorithms-in-your-swiftui-painting-app-652f8b8cd604?source=collection_archive---------7-----------------------#2021-10-26">https://betterprogramming.pub/embracing-algorithms-in-your-swiftui-painting-app-652f8b8cd604?source=collection_archive---------7-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4648" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">完成构建我们的iOS paint应用程序的旅程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b653075f501d180bd1a2e1710026d1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQbqLYlcMzmZ7ORj-MnrBg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae ky" href="https://unsplash.com/s/photos/colours?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="04fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你已经阅读了这个简短系列的第一部分、第二部分和第三部分，在这个系列中，我开发了一个简单的绘画应用程序。</p><ol class=""><li id="3ae0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-a-painting-app-in-ios-15-with-swiftui-bb757a925f6a">用SwiftUI在iOS 15中搭建绘画App</a></li><li id="bf60" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/adding-shapes-and-colors-to-your-swiftui-painting-app-751dbb6fdce3">向您的SwiftUI绘画应用添加形状和颜色</a></li><li id="6679" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/adding-more-controls-to-your-swiftui-painting-app-8edaede63e7e">向SwiftUI绘画应用添加更多控件</a></li></ol><h1 id="33f4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">简短的</h1><p id="e916" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这是构建绘画应用系列的最后一篇，我希望巩固我所做的大部分工作，最终做出一些实质性的改变。最大的变化是我在上一篇文章中添加的控件代码。这一灵感来自于<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2018/223/" rel="noopener ugc nofollow" target="_blank">拥抱算法WWDC2018演示</a>的17分钟外卖——戴夫·亚伯拉罕斯在这个外卖中谈论如何修复他自己的绘画应用。</p><p id="8079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他告诉我们，他需要解决的一个问题是关注代码的可靠性、可维护性和性能。他的任务是删除所有的“原始循环”，尽可能用库代码替换它们。</p><p id="7948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了演讲中启发的变化，我还添加了一些我还没有做的新功能，即一些对齐按钮和一个复制/粘贴按钮。我对<code class="fe ng nh ni nj b">ContentView.swift</code>做了一些其他的改变，试图控制它对CPU的需求。</p><h1 id="709e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码</h1><p id="54bc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">所以对于业务部门来说——首先将所有函数移动到它们自己的文件中，<code class="fe ng nh ni nj b">Shapes.swift</code>——我也移动了它们引用的数据结构。当我重新起草代码时，我是在现在移动的数据结构中这样做的。</p><p id="e2af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe ng nh ni nj b">Shapes.swift</code>文件的前40行开始。在其中你会找到<code class="fe ng nh ni nj b">Shapes</code>结构和十几个新EA例程中的第一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找+数据结构的新方法</p></figure><p id="69b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，这是它之前的样子，带有原始的<code class="fe ng nh ni nj b">for …in</code>循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旧的搜索方法</p></figure><p id="0e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几点。</p><p id="59ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大的变化是我用内置的数组方法<code class="fe ng nh ni nj b">lastIndex</code>替换了原始的循环——这一变化带来了一些显著的好处。</p><p id="128e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，最后一个索引向后计数，因此它修复了我提到的选择错误。</p><p id="1187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，它现在是一个更干净的位代码，其功能更加明显——人们希望它没有WWDC会谈中提到的潜在缺陷。</p><p id="4a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个方法是<code class="fe ng nh ni nj b">deselection</code>，现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">取消选择的新方法</p></figure><p id="085d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这又是一个我设法使之更短、更有效的例行程序。我使用内置的库来搜索和构建需要取消选择的形状的索引，以前我只是(几乎)盲目地遍历每个形状(再次在原始循环中)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">取消选择的旧方法</p></figure><p id="8cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我建立了一个我在应用程序的持续开发中需要的新方法。一种简单确认你是否选择了一个形状的方法。我需要它来确保角度/形状改变例程不会改变最后选择的项目，如果你没有选择一个新的项目(错误)。</p><p id="28a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我使用了一个库例程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果选择了任何形状，将返回一个新例程</p></figure><p id="edf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我继续检查代码，做了一些相当大的改动。新的<code class="fe ng nh ni nj b">deleteObjectEA</code>现在只有一行，一段更有效的代码，因为它现在只需一次点击就可以移除所有选中的对象。</p><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="d9d7" class="nq mk it nj b gy nr ns l nt nu">func deleteObjectEA(selectedIndx:Int) {<br/>  objects.removeAll(where: { $0.selected == true })<br/>}</span></pre><p id="6693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我移动了方法来更新形状上的填充和线条中使用的颜色，这是我以前错过的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的着色方法</p></figure><p id="8373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我对代码最大的改进是使用了在WWDC2018演讲中详细解释的想法。更新方法以改变形状的有效<code class="fe ng nh ni nj b">z</code>指数。新的解决方案比以前的方案少一半的代码，而且效率大大提高。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的铺设方法</p></figure><p id="5504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我承认我在SO <a class="ae ky" href="http://sweeper777.me" rel="noopener ugc nofollow" target="_blank"> Sweeper </a>上从一个同事那里得到了帮助，但是我也添加了一些新方法，使用相同的编码范式来实现一些新功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些新方法，新功能</p></figure><p id="01f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也更新了着色方法<code class="fe ng nh ni nj b">setObject</code>,现在看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的色彩方法</p></figure><p id="7add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我将所有这些整合到将要使用它们的视图中。</p><p id="7419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在做了所有这些改变之后，我也需要对<code class="fe ng nh ni nj b">ContentView.swift</code>做一些改变，尽管在我向你展示现在组成它的400行代码之前，这里有一个新应用的动画GIF。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/57019bf54ffce65d0c28574685ff4b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YgAgm-HHzPNIFAAX7NTdUw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示复制/粘贴+水平+对齐的快速演示</p></figure><p id="efbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如描述所说，这是一个快速演示给我看复制/粘贴形状，添加一个形状，给它更多的边，改变它们的形状相对于彼此的z层，最后垂直对齐正方形，然后水平对齐。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="1258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我对更新后的<code class="fe ng nh ni nj b">ContentView</code>做了一些改动，试图控制CPU:</p><ul class=""><li id="2785" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated">我已经移除了<code class="fe ng nh ni nj b">Shapes</code>结构的预分配，并添加了代码在它们被创建时进行分配，有效地修复了我在上一篇文章中提到的删除错误。</li><li id="1a48" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">我在这个形状上添加了一个灰色矩形，以帮助用户将它放在画布上。</li><li id="e007" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">我在拖动过程中添加了一个信号量，以确保它不会同时进入我隔离的四个部分(是的，我知道你永远不应该在主线程上使用信号量，所以你知道他们在家里不这样做)。</li><li id="43dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated">我添加了一个<code class="fe ng nh ni nj b">TimelineView</code>,试图减少接口被调用来重画自己的次数。每10秒刷新一次的视图，就像这里看到的计时器一样。</li></ul><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="fc77" class="nq mk it nj b gy nr ns l nt nu">let redraw = Timer.publish(every: 0.1, tolerance: .none, on: .main, in: .common).autoconnect()</span></pre><ul class=""><li id="4012" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated">我使用了在SO上找到的扩展来安全地测试数组上的属性，即使它没有成员。</li></ul><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="f74c" class="nq mk it nj b gy nr ns l nt nu">extension Collection where Indices.Iterator.Element == Index {<br/>    subscript (safe index: Index) -&gt; Iterator.Element? {<br/>    return indices.contains(index) ? self[index] : nil<br/>  }<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，所有这些附加控件背后的代码，引用了所有新的<code class="fe ng nh ni nj b">EA</code>方法。其中一个引用了您也需要的这个扩展。一个<code class="fe ng nh ni nj b">EA</code>扩展，返回匹配给定谓词的所有元素。</p><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="5e05" class="nq mk it nj b gy nr ns l nt nu">extension Array where Element: Equatable {<br/>  func all(where predicate: (Element) -&gt; Bool) -&gt; [Element]  {<br/>    return self.compactMap { predicate($0) ? $0 : nil }<br/>  }<br/>}</span></pre><p id="85e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法中用到的一个扩展，恐怕我之前没有提到。</p><pre class="kj kk kl km gt nm nj nn no aw np bi"><span id="e528" class="nq mk it nj b gy nr ns l nt nu">func returnObjectEA() {<br/>  let used = objects.all(where: { !$0.unused })<br/>  report.send(used.count)<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些把我带到旅程的终点；尽管我之前说过，永远不要说永远。</p></div></div>    
</body>
</html>