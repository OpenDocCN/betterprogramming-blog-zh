<html>
<head>
<title>Comparing React Context and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较React上下文和Redux</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/context-limitations-when-emulating-redux-in-a-small-to-medium-size-application-acd05ef882e4?source=collection_archive---------14-----------------------#2020-03-11">https://betterprogramming.pub/context-limitations-when-emulating-redux-in-a-small-to-medium-size-application-acd05ef882e4?source=collection_archive---------14-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在中小型应用程序中模拟Redux时的上下文限制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1715a70a14cc7511d9ebb405ef7a82b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9kfHp73quB1NaeSF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://unsplash.com/photos/1HCb2gPk3ik" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/1HCb2gPk3ik</a></p></figure><p id="3a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着钩子(特别是<code class="fe lv lw lx ly b">useReducer</code>和<code class="fe lv lw lx ly b">useContext</code>)和稳定的Context API的引入，不可避免地要在Context和Redux之间进行比较，也许这是正确的，因为大多数技术前提都变得可能了。</p><p id="acb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文试图深入研究Context的技术方面及其在使用React hooks模拟Redux架构时对应用程序性能、可维护性和可伸缩性的限制。在处理中小型web应用程序时，它会根据开发人员的经验来尝试这样做。</p><p id="a4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文包含以下几个部分:</p><ul class=""><li id="f594" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">上下文API概述。</li><li id="dd9d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">用于演示目的的应用程序摘要。</li><li id="22e0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用带挂钩的上下文创建应用程序存储。</li><li id="60d8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">上下文中的应用程序性能。</li><li id="c90d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">上下文中的应用程序可维护性。</li><li id="302c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">结论。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5164" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.上下文API概述</h1><p id="5eaf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">上下文试图解决将状态传递给需要它的组件的问题，而不是将它作为道具。因此，它使得对状态不感兴趣的中间组件忽略它，同时使得嵌套组件能够访问“全局”上下文状态。</p><p id="2191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个上下文，您可以使用<code class="fe lv lw lx ly b">React.createContext</code>，在这里您将描述您想要保存的状态。然后，在需要访问上下文状态的最顶层组件上使用<code class="fe lv lw lx ly b">MyContext.Provider</code>创建上下文提供者。</p><p id="2eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，作为提供者树的后代的所有组件都可以使用以下方式来使用状态:</p><ul class=""><li id="c65a" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">MyContext.Consumer</code>或<code class="fe lv lw lx ly b">useContext</code>钩在功能部件内。</li><li id="1e3d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">this.context</code>或<code class="fe lv lw lx ly b">static contextType = MyContext</code>内类组件。</li></ul><p id="be7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，我们将使用<code class="fe lv lw lx ly b">useContext</code>钩子。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8286" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.将用于演示目的的应用程序摘要</h1><p id="7399" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">该应用程序名为Prep &amp; Groc(Prepare and杂货的缩写)。这是一个网络应用程序，允许用户通过查找他当前存储在冰箱中的食谱中缺少的食谱配料来准备食谱。用户可以将缺少的配料保存到购物清单项目中，在购物时可以将它们标记为完成。该应用程序还根据用户的操作结果显示通知消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0206146e3399fd9bdd13f8478d48dc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*RrVxXWAZJFE9X7wGX2CBuw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序演示</p></figure><p id="d553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序的客户端是用Context和Redux实现的，这样我们可以更好地理解和比较这两者。以下是每个实现的存储库链接:</p><ul class=""><li id="550e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/LumbardhAgaj/prep-and-groc/tree/master/client" rel="noopener ugc nofollow" target="_blank"> <em class="ns">准备&amp; Groc客户端与上下文</em> </a></li><li id="22fe" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/LumbardhAgaj/prep-and-groc-client-with-redux" rel="noopener ugc nofollow" target="_blank"> <em class="ns"> Prep &amp; Groc客户端带Redux </em> </a></li></ul><p id="b0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以看看<a class="ae ky" href="https://prep-and-groc.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> Prep &amp; Groc </a>的直播版。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e7a1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.使用带挂钩的上下文创建应用程序商店</h1><p id="dc62" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">useReducer</code>是一个React钩子，允许复杂的应用程序状态管理。它接受一个reducer函数和一个初始状态作为参数列表，同时返回当前状态和一个dispatcher函数。调度器用于发出改变reducer状态的动作。</p><p id="8b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照单个应用程序全局存储的redux范例，我们可以用一个上下文和<code class="fe lv lw lx ly b">useReducer</code>钩子类似地创建它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用上下文创建应用程序商店</p></figure><p id="9b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对状态和分派使用不同的上下文，仅仅是因为分派函数从不改变，我们想尝试保存一些应用程序的渲染。然后，<code class="fe lv lw lx ly b">StoreUpdateProvider</code>和<code class="fe lv lw lx ly b">StoreProvider</code>都在<code class="fe lv lw lx ly b">StoreContextProvider</code>中创建，后者现在提供应用程序的全局状态。</p><p id="e403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用的根组件，我们可以导入并使用<code class="fe lv lw lx ly b">StoreContextProvider</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在根组件中使用StoreContextProvider</p></figure><p id="7626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">appReducer</code>通过使用Redux中类似于<code class="fe lv lw lx ly b">combineReducers</code>的reducer函数来封装整个应用程序状态。它只是将应用程序状态分割成多个reducers，使其更易于管理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主要应用减速器</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9faa" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.上下文性能</h1><p id="9686" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">关于上下文，需要理解的最重要的一点是，它将重新呈现作为上下文提供者的后代的所有组件，无论它们在状态发生变化时是否使用上下文。这个规则的唯一例外是上下文提供者的子元素没有改变，只有使用上下文的组件才会重新呈现。这是我们将子道具传递给提供上下文的组件而不是在其中创建组件的主要原因(请阅读詹姆斯·纳尔逊的博文<a class="ae ky" href="https://frontarm.com/james-k-nelson/react-context-performance/" rel="noopener ugc nofollow" target="_blank">关于避免不必要的上下文渲染)。</a></p><p id="1d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是，我们最终得到的是重新呈现的组件，即使它们可能没有发生变化，而我们理想的情况是只重新呈现那些发生了变化的组件。至少在按照图书馆的指导方针和实践使用Redux时是这样。</p><p id="8232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减少不必要的重新渲染的最佳策略是将上下文分割成其他上下文(或者从头开始创建新的上下文)。这样做的一个强有力的例子是:</p><ul class=""><li id="5267" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">状态的一部分经常改变，我们想要隔离它。</li><li id="cf4b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">组件只对使用应用程序状态的一部分感兴趣。</li><li id="12bd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">状态的一部分很少改变，组件可能消耗部分和整个状态。</li></ul><p id="7001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了仔细演示我们可能想要拆分上下文的场景，让我们首先描述我们的应用程序的一个公共页面。我们有一个冰箱页面，在页面标题有一个保存配料的表格和一个作为页面主体的冰箱配料列表。此外，当用户成功删除一个冰箱成分时，它会显示一条通知消息，说“冰箱成分已被成功删除。”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9b045a9cabffb372b51457c0b7b167b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/1*5bCBswquH-g1mxdDX2MbIg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">删除冰箱配料</p></figure><p id="a764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当通知发生时，我们可以通过尝试减少不必要的重新呈现来获得稍好的性能。</p><p id="7c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，当用户完成显示通知的动作时，整个页面被重新呈现两次——一次是在屏幕上添加通知时，另一次是在删除通知时。将通知子状态从存储上下文状态中分离出来属于隔离频繁更改(大量用户操作发出通知)的场景，并且组件只对使用状态的一部分感兴趣。</p><p id="c6ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们对<code class="fe lv lw lx ly b">StoreContextProvider</code>所做的那样，我们将实现<code class="fe lv lw lx ly b">NotificationContextProvider</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NotificationContextProvider组件</p></figure><p id="807f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的根组件将创建所有的上下文提供者。我们已经从<code class="fe lv lw lx ly b">appReducer</code>中移除了通知缩减器，取而代之的是，我们将它作为一个属性值传递给新创建的<code class="fe lv lw lx ly b">NotificationContextProvider</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有存储和通知上下文的根组件</p></figure><p id="5fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">NotificationToast</code>组件(负责管理通知)将单独使用通知上下文状态及其调度程序功能，我们称之为“通知”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建通知状态和更新上下文后的NotificatonToast组件</p></figure><p id="dc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每当组件发送通知时，它将只重新呈现<code class="fe lv lw lx ly b">NotificationToast</code>组件，而不是整个应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/80e7e035aad60fb4020ea7af315f56de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*u1LRoDLuSdPj3m0r3cHsQA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用React dev profiler记录删除冰箱配料操作</p></figure><p id="6cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用React dev profiler记录我们的操作，我们可以看到，当通知发生时，只有<code class="fe lv lw lx ly b">NotificationToast</code>组件受到影响(请查看profiler记录的会话中的第三和第四个渲染)。因此，我们不仅提高了应用程序的性能(这带来了可维护性的代价，我们将在下一节中看到)，更重要的是，我们只重新呈现了发生变化的组件(这仅适用于<code class="fe lv lw lx ly b">NotificationToast</code>组件)。</p><p id="c437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将只讨论子状态变化不频繁且组件可能消耗部分和整个应用程序状态的情况。应用程序拥有一个主题，让用户选择自己的应用程序视图偏好，这种做法越来越普遍。国家的这一部分不应该经常改变。因此，我们可以将主题状态和它的分派功能拆分到单独的上下文中。组件会对使用主题上下文和存储上下文提供者感兴趣，但是因为主题状态很少改变，在这种情况下，我们不会被组件不必要的重新呈现所困扰(另一个类似的场景是用户认证)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="601a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">虚上下文分裂</strong></h1><p id="e4db" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">起初，分割上下文似乎是减少React中不必要的重新渲染的好策略。然而，它更微妙，并带有一个警告或一组限制。</p><p id="ee4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在拆分或创建新的上下文之前，必须考虑如何从组件中使用上下文，这一点很重要。如果您创建的部分状态仍然与整个状态同时被大多数组件使用，并且经常发生更改，那么合并或根本不分割它们可能是一个更好的主意，因为您几乎不会从应用程序性能中获得任何好处。例如，在我们的应用程序中，如果某些页面组件也使用了通知状态上下文，就会出现这种情况。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="71d3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">记忆化的案例</strong></h1><p id="13a4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">React库提供了多种记忆机制，在不同的粒度级别上工作。</p><p id="af1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React.memo可以用来记忆功能组件，因为它执行组件属性的浅层比较。</p><blockquote class="nw nx ny"><p id="af01" class="kz la ns lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">"它类似于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">React.PureComponent</a></code>,但是是针对函数组件而不是类."官方React文档。</p></blockquote><p id="2bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">React.useMemo</code>是一种挂钩，也可用于功能组件记忆目的。</p><blockquote class="nw nx ny"><p id="d484" class="kz la ns lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">"<code class="fe lv lw lx ly b">useMemo</code>只会在其中一个依赖关系改变时重新计算记忆值."官方React文档。</p></blockquote><p id="75ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，人们可能会尝试使用它们来提高应用程序的性能，并保存重新呈现后没有发生变化的组件。除了当与上下文一起使用时，它们仍然会被重新呈现。话虽如此，使用上下文时组件记忆化背后的主要动机应该是由昂贵的计算或昂贵的组件呈现所驱动的。不要使用记忆技术来减少不必要的组件重新呈现。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4c41" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">5.上下文可维护性</h1><p id="980d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">虽然可以成功地拆分或创建一个新的上下文，并成功地提高应用程序的性能，但出现的问题是用户操作通常需要更改多个上下文的状态。这意味着一个特定的用户动作将不得不接受每个上下文的调度函数作为参数列表，它必须传递这个变化。这也意味着包含这些用户动作的组件将不得不使用多个上下文。例如，在我们删除冰箱配料的操作中，在创建了<code class="fe lv lw lx ly b">NotificationContextProvider</code>之后，我们必须传递参数列表:</p><ul class=""><li id="1173" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">存储上下文的分派功能。</li><li id="0fb6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">通知更新的调度函数(名为<code class="fe lv lw lx ly b">notify</code>)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用上下文的deleteFridgeIngredient操作</p></figure><p id="ebf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们可能会提高应用程序的性能，但代码的可读性会受到影响。现在，我们必须考虑所有需要的参数，并将它们传递给动作，动作反过来将对它所依赖的所有动作做同样的事情(删除冰箱配料动作使用<code class="fe lv lw lx ly b">removePageItem</code>、<code class="fe lv lw lx ly b">addSuccessToast</code>和<code class="fe lv lw lx ly b">handleFetchError</code>动作)。</p><p id="f591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，我们的组件将充斥着消耗上下文的代码。尽管如此，人们总是可以通过在组件之间共享公共状态来使用定制钩子来缓解这个问题。例如，我们在<code class="fe lv lw lx ly b">DeleteFridgeIngredientButton</code>中使用<code class="fe lv lw lx ly b">useDispatchActionFromButton</code>定制钩子来收集所有必要的分派函数，这样我们就可以成功地调用<code class="fe lv lw lx ly b">deleteFridgeIngredient</code>动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带上下文的DeleteFridgeIngredientButton</p></figure><p id="3e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然创建更多的上下文可能有利于您的性能，但就应用程序的可维护性而言，这被认为不是一个可持续的解决方案。用户操作必须改变多个上下文的状态。与上下文相反，Redux有一个单一的分派函数，当动作是异步的时候，你就不需要在参数列表中传递分派器，因为它由Redux中间件负责。Redux中间件(如redux-thunk或sagas)通过延迟异步动作直到动作被解析为正确的动作对象来规范化异步动作。Redux的相同<code class="fe lv lw lx ly b">deleteFridgeIngredient</code>动作示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Redux删除fridgement操作</p></figure><p id="368d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用Redux时，您只需要关心动作逻辑本身，同时您仍然可以创建自定义钩子或者使用Redux库中的现成钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带Redux的DeleteFridgeIngredientButton</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6f6e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">廉价再现的情况</h1><p id="7184" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">ReactJS之所以速度很快，主要是因为它依赖于虚拟DOM。随着即将到来的React并发模式，应用程序可能会工作得更快，因为它将能够根据优先级暂停任务，这将改善与用户的交互时间。即使使用React的当前版本，大多数应用程序的重新渲染也被认为是廉价的，因为它们通常达不到用户开始感觉到其动作延迟的时间。基于这种假设，有人可能会说不需要性能优化，因为从用户的角度来看，性能优化已经可以接受了。</p><p id="86be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设性能是可接受的，并且我们使用单一的应用程序商店上下文，问题是用户异步和同步操作缺乏一致性。分派异步动作看起来不同于分派同步动作。在前一种情况下，这个动作看起来更像一个助手函数。</p><p id="2ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看当<code class="fe lv lw lx ly b">FridgeIngredientButton</code>被点击时运行的删除冰箱配料异步动作，以及当通知消息在<code class="fe lv lw lx ly b">NotificationToast</code>组件内关闭时运行的同步动作。当运行<code class="fe lv lw lx ly b">deleteFridgeIngredient</code>异步动作时，我们必须将分派函数作为参数传递，而不是直接从组件中分派。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用上下文时的异步操作调用</p></figure><p id="7d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，Redux用中间件解决了这个问题，它允许您编写异步代码并规范化所有操作。我们使用redux-thunk中间件来处理与商店的异步代码交互。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Redux时的异步操作调用</p></figure><p id="8c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上下文时同步动作的调用仍然与Redux动作调用模式相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用上下文时同步操作调用</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d61b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">6.结论</h1><p id="2ad0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">基于我在用上下文和钩子模仿Redux时的经验，我得出以下结论:</p><ul class=""><li id="637a" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">虽然在技术上可以用Context代替Redux，但是随着应用程序规模的增长，应用程序性能和可维护性的限制仍然使它成为一个昂贵的选择。</li><li id="c1f5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如果您不确定Context是否能够满足您的应用程序需求，请开始使用它并模拟Redux架构。当您到达一个端点时，您可以很容易地切换到Redux(无论如何，大部分基础设施都将就位)。</li><li id="e4ae" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">当使用上下文优化应用程序性能时，让组件先成熟起来。之后，您可以通过仔细观察组件和用户操作消耗了哪些信息来开始调整应用程序的性能。这将让您更好地了解可能的候选上下文。</li></ul><p id="96a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语境和Redux不是相互替代的，也不是相互排斥的。我见过的大多数Redux抱怨都是关于需要构建的样板代码。事实上，这是任何定义良好的架构风格都会发生的事情，因为它有一套原则、约束或数据流，它强制自己成功地工作并满足需求。</p></div></div>    
</body>
</html>