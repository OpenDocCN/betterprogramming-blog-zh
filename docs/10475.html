<html>
<head>
<title>6 Reasons Why I Prefer FxTS Over Lodash or Ramda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">相比Lodash或Ramda，我更喜欢FxTS的6个原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-functional-programming-with-fxts-a0e615f1c276?source=collection_archive---------4-----------------------#2022-01-10">https://betterprogramming.pub/javascript-functional-programming-with-fxts-a0e615f1c276?source=collection_archive---------4-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="59aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用FxTs开始函数式编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f07b2ff77241b81687ff1b5c9230f87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwhThlzcK0J2ZzkiT9haGg.png"/></div></div></figure><h1 id="c518" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="c67c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">今天，作为一个热爱函数式编程的人，我要介绍一个函数库<a class="ae mf" href="https://fxts.dev/docs/index/" rel="noopener ugc nofollow" target="_blank"> FxTs </a>，我相信你永远也不会知道。几年前，我偶然发现了一门在线函数式编程课程，作者是FxJs(FxTs的前一版本)的创始人“<a class="ae mf" href="https://github.com/indongyoo" rel="noopener ugc nofollow" target="_blank"> Indong Yoo </a>”,他在从头创建函数库的同时教授函数式编程。</p><p id="5afa" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">由于这个机会，我开始理解FxTs的目标和原则，并且我被函数式编程的美丽所吸引😍。在那之后，我开始在我的个人vue2/vue3项目中积极地使用这个库，这使得我的代码可读性更好，也更容易维护。</p><p id="f0c3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">出于这个原因，我正在考虑将这个库用于我的一个项目，该项目将很快从nuxt2迁移到nuxt3，因为vue3的组合API与函数式编程模式非常匹配。</p><h1 id="545d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">等等，什么是函数式编程？</h1><p id="c8dd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae mf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>是一种范式，通过组合小函数来创建干净、可读的代码，并且没有副作用。</p><p id="5467" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">使用函数式编程，我们可以用可读性和可维护性更强的代码来代替命令式编程方法。例如，假设您要创建一个函数<code class="fe ml mm mn mo b">getMalesAge</code>,从用户列表中只选择n名男性，并获得他们的年龄总和。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ad6c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这里需要注意的是，循环语句(for，while)、条件语句(if)、控制语句(break)只能由函数编写。我们可以更明确地编写代码，而不是指出sumAge或count变量是如何变化的。</p><p id="bf2a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">上面的函数风格例子是用FxTs编写的。那些功能如<code class="fe ml mm mn mo b">map</code>、<code class="fe ml mm mn mo b">filter</code>、<code class="fe ml mm mn mo b">reduce</code>、<code class="fe ml mm mn mo b">take</code>已经像大多数功能库一样被定制了。函数库的用法一般都是相似的，所以一旦你知道了一个，你就可以很快地使用另一个。</p><p id="b710" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">有著名的函数库如lodashFP和Ramda，但我强烈推荐“FxTs ”,原因如下。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="bb6e" class="kr ks iq bd kt ku my kw kx ky mz la lb jw na jx ld jz nb ka lf kc nc kd lh li bi translated">为什么我推荐你FxTs而不是LodashFP，Ramda？</h1><h2 id="c3e7" class="nd ks iq bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh no bi translated">1.惰性评估支持</h2><blockquote class="np nq nr"><p id="08d3" class="lj lk ns ll b lm mg jr lo lp mh ju lr nt mi lu lv nu mj ly lz nv mk mc md me ij bi translated">试试这个链接:<a class="ae mf" href="https://codesandbox.io/s/performance-fxts-vs-lodashfp-vs-ramda-sb9jh?file=/src/index.ts" rel="noopener ugc nofollow" target="_blank"> FxTs vs LodashFP vs Ramda性能对比</a></p></blockquote><p id="4f79" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">首先，FxTs中的所有函数都完美支持ES6规范<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>。换句话说，它将集合的创建延迟到最后，并在最后对其求值。这带来了其他库不具备的性能优势，比如lodashFP或者Ramda。</p><p id="c785" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果实际测量性能，可以看到FxTs明显快于Ramda，略快于Lodash。随着阵列大小的增加，这种差异变得更大。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e5fecbe0845874d0d1e423e8f2e91716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5Qh4yuU_ugXgEdIfqtlbQ.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">性能测试Ramda vs lodash vs FxTs</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8280" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为什么会有这么大的差别？为了考察它，我们在中间插入<code class="fe ml mm mn mo b">tap</code>函数，了解一下FxTs的工作原理。在Ramda中也实现了<code class="fe ml mm mn mo b">tap</code>函数，当您想要检查函数合成过程中值是如何变化的时，就可以使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fb17" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">正如你看到的，FxTs输出一个迭代器，不像Ramda输出一个数组。也就是说，每当执行<code class="fe ml mm mn mo b">map</code>、<code class="fe ml mm mn mo b">filter</code>时，Ramda都会创建一个数组，这也是Ramda的性能明显低于FxTs的原因。</p><p id="680f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">您可能会注意到，在函数合成的最后一步，FxTs中有<code class="fe ml mm mn mo b">toArray</code>。它有助于将迭代器转换成数组。</p><p id="ebcb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果为了调试的目的想在迭代器中检索实际值，可以在FxTs的管道中间使用<code class="fe ml mm mn mo b">peek</code>函数。</p><p id="275e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然而，需要注意的是:惰性求值并不总是高效的。如果我们去掉上面例子中的<code class="fe ml mm mn mo b">take</code>，结果正好相反。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/3bfc75abc6fe274b9bdd73fc74eb4ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ArQsvS8RkOkdtVo1NRgEg.png"/></div></div></figure><p id="e489" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是因为将迭代器转换成数组的<code class="fe ml mm mn mo b">toArray</code>函数需要花费大量时间。当您需要通过只提取大量数组数据的一部分来执行操作时，惰性求值是很好的。否则，最好使用原生JS数组API。</p><blockquote class="np nq nr"><p id="626b" class="lj lk ns ll b lm mg jr lo lp mh ju lr nt mi lu lv nu mj ly lz nv mk mc md me ij bi translated">试试这个链接:<a class="ae mf" href="https://codesandbox.io/s/performance2-fxts-vs-lodashfp-vs-ramda-cuej5?file=/src/index.ts" rel="noopener ugc nofollow" target="_blank"> FxTs vs LodashFP vs Ramda性能对比</a> 2</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/994a0f93e1a7c0945327f1a048d2ad2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbMfifK2380mocP3Wo20WQ.png"/></div></div></figure><p id="f2ea" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，重要的是要知道在哪个时刻懒惰评估可以实现最大的性能。</p><p id="37a7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你想知道更多关于迭代器协议如何与FP一起工作的信息，我推荐你阅读<a class="ae mf" href="https://medium.com/@woolim/build-our-own-functional-programming-library-from-scratch-with-es6-iterator-protocol-292085f66df2" rel="noopener">这篇文章</a>。</p><h2 id="d343" class="nd ks iq bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh no bi translated">2.简单的异步控制</h2><blockquote class="np nq nr"><p id="fcbb" class="lj lk ns ll b lm mg jr lo lp mh ju lr nt mi lu lv nu mj ly lz nv mk mc md me ij bi translated">试试这个链接:<a class="ae mf" href="https://codesandbox.io/s/async-fxts-vs-lodashfp-vs-ramda-f2v97" rel="noopener ugc nofollow" target="_blank">异步测试Fxts vs LodashFP vs Ramda </a></p></blockquote><p id="37c2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">FxTs有一个超级方便的方法来处理异步/同步功能。你可以很容易地以函数编程的形式实现<code class="fe ml mm mn mo b">Promise.all</code>，而且，使用<code class="fe ml mm mn mo b">Concurrency</code>特性可以控制执行多少函数。</p><p id="5546" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">LodashFP和Ramda不支持库本身的异步函数。这是因为在创建库时，它并没有被设计成接收一个Promise对象。如果用lodashFP或Ramda执行下面的代码，那么<code class="fe ml mm mn mo b">Promise</code>对象会保留在数组中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">带有Ramda的异步示例</p></figure><p id="f7d4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然而，当通过迭代器从数组中检索值时，FxTs通过<code class="fe ml mm mn mo b">instanceof</code>在内部检查它是否是一个<code class="fe ml mm mn mo b">Promise</code>对象。如果值是一个<code class="fe ml mm mn mo b">Promise</code>，FxTs通过<code class="fe ml mm mn mo b">then</code>检索该值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">带有FxTs的异步示例</p></figure><p id="c2f2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为此，在使用FxTs以外的其他库时，函数必须自己实现，检查<code class="fe ml mm mn mo b">Promise</code>如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">与Ramda异步示例2</p></figure><p id="b2b8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">FxTs还有一个很酷的功能<code class="fe ml mm mn mo b">Concurrency</code>。在上面的例子中，像<code class="fe ml mm mn mo b">Promise.all</code>一样同时执行5个异步函数，但是如果你使用<code class="fe ml mm mn mo b">concurrent</code>函数，你可以控制同时执行多少个异步函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e0b0b0913ace33d97815405a3e60f48b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6H2CeRP-PvlBWx_1RIN9LQ.gif"/></div></figure><h2 id="bf6f" class="nd ks iq bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh no bi translated">3.错误处理</h2><blockquote class="np nq nr"><p id="5bc0" class="lj lk ns ll b lm mg jr lo lp mh ju lr nt mi lu lv nu mj ly lz nv mk mc md me ij bi translated">试试这个链接:<a class="ae mf" href="https://codesandbox.io/s/error-handling-fxts-vs-lodashfp-vs-ramda-m810d?file=/src/index.ts:95-423" rel="noopener ugc nofollow" target="_blank">错误处理测试FxTs vs LodashFP vs Ramda </a></p></blockquote><p id="5ee4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">处理好错误直接关系到程序的健壮性。在FxTs中，可以使用<code class="fe ml mm mn mo b">try catch</code>处理所有错误</p><p id="1513" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">例如，假设在对象应该存在的数据数组中间有null。当访问Ramda和lodashFP中的null属性时，相应的错误不会出现在<code class="fe ml mm mn mo b">try catch</code>中，库本身会崩溃。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="6df6" class="nd ks iq bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh no bi translated">4.使用方便</h2><p id="f633" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你有函数式编程的基础知识，了解迭代器协议，就可以用FxTs开始函数式编程了。由于它被设计为只实现JS中的数据类型，而不单独实现Functor或Monad，因此它不需要对相关的库或函数式编程有很深的理解，因此它非常适合FP初学者。</p><p id="e9ec" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">你只需要理解FxTs中的2个基本概念:<code class="fe ml mm mn mo b">Lazy</code>和<code class="fe ml mm mn mo b">Strict</code>。</p><ul class=""><li id="ea03" class="oe of iq ll b lm mg lp mh ls og lw oh ma oi me oj ok ol om bi translated">惰性函数使用惰性求值，返回一个迭代器，用在函数合成的开头或中间。</li><li id="9fcb" class="oe of iq ll b lm on lp oo ls op lw oq ma or me oj ok ol om bi translated">严格函数使用立即求值，返回一个值，用在函数合成的末尾。</li></ul><p id="2b48" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们举个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="801c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">懒惰函数如<code class="fe ml mm mn mo b">map</code>、<code class="fe ml mm mn mo b">filter</code>用在函数合成的开头或中间，严格函数用在最后，以产生有意义的值。你可以在这里看到懒惰函数和严格函数的列表<a class="ae mf" href="https://fxts.dev/docs/index/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="8eea" class="nd ks iq bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh no bi translated">5.轻量级选手</h2><p id="eb64" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">FxTs只包含函数式编程必不可少的函数，因此它适合作为函数式编程的入门。</p><p id="433c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它大胆地排除了普通JavaScript中不存在的单子和函子，并致力于仅使用基本JavaScript类型和<code class="fe ml mm mn mo b">Promise</code>的轻量级函数式编程。它当然支持摇树。</p><h1 id="39ee" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">6.有前途的开源软件</h1><p id="d312" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">FxTs最近在<a class="ae mf" href="https://github.com/sorrycc/awesome-javascript" rel="noopener ugc nofollow" target="_blank"> awesome-javascript </a>中注册，并且越来越受欢迎。当然，它现在还没有LodashFP或者Ramda流行，但是考虑到我到目前为止提到的上述原因，它是值得被广泛使用的。</p><h1 id="ce9c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="6c82" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">FxTs是由<a class="ae mf" href="https://www.marpple.com/en/" rel="noopener ugc nofollow" target="_blank"> marpple </a> dev团队开发的开源库，得益于开发者Indong Yoo的函数式编程讲座，它在韩国的知名度越来越高。</p><p id="d9ca" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于通过本文对FxTs感兴趣的人，我链接了Slack社区作为参考。这仍然是一个新的图书馆，所以如果你想贡献，也许现在是一个机会</p><h1 id="e9c1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">参考</h1><ul class=""><li id="c5cf" class="oe of iq ll b lm ln lp lq ls os lw ot ma ou me oj ok ol om bi translated"><a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank"> MDN迭代器协议</a></li><li id="4c3b" class="oe of iq ll b lm on lp oo ls op lw oq ma or me oj ok ol om bi translated"><a class="ae mf" href="https://fxts.dev/" rel="noopener ugc nofollow" target="_blank"> FxTs官方文档</a></li><li id="8176" class="oe of iq ll b lm on lp oo ls op lw oq ma or me oj ok ol om bi translated"><a class="ae mf" href="https://join.slack.com/t/fx-ts-en/shared_invite/zt-z3heqgyc-al69EU_l95xnjeMRfvdoMA" rel="noopener ugc nofollow" target="_blank"> FxTs英语社区</a></li><li id="59d5" class="oe of iq ll b lm on lp oo ls op lw oq ma or me oj ok ol om bi translated"><a class="ae mf" href="https://join.slack.com/t/fx-ts/shared_invite/zt-yw1x81zq-pNa8nM40X6mQAsu2L4m1Fw" rel="noopener ugc nofollow" target="_blank">韩语FxTs社区</a></li></ul></div></div>    
</body>
</html>