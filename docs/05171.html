<html>
<head>
<title>The Inner Workings of State Properties in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中状态属性的内部工作方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-inner-workings-of-state-properties-in-swiftui-8409ef39a7bd?source=collection_archive---------4-----------------------#2020-06-17">https://betterprogramming.pub/the-inner-workings-of-state-properties-in-swiftui-8409ef39a7bd?source=collection_archive---------4-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c07" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这不是魔法——尽管看起来是</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4deb668b5a68f2e8214c7fc7c6689ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7aNqmh_uqvPBcJhLIJcBw.png"/></div></div></figure><p id="5824" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嘿！澄清一下，这篇文章是关于<code class="fe lq lr ls lt b">@State</code>属性(SwiftUI特有的)而不是状态的<a class="ae lu" href="https://medium.com/macoclock/what-is-state-in-swift-8d6a7c51d95b" rel="noopener">一般概念。它们是相关的，但是状态本身只是一个想法，而<code class="fe lq lr ls lt b">@State</code>属性是一个实际的、可见的、有形的对象。它也非常通用，几乎像魔术一样…</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">背景</h1><p id="9d1f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果您一直在使用SwiftUI，那么很可能您曾经创建了一个属性，并试图更改它的值，却得到了这个奇怪的错误:“不能给属性赋值:‘self’是不可变的。”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/f27061c9988c36d7e040fbc46633341d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKNbzfjH2oJ5-9hfyza8og.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">嗯……‘自我’是不可改变的？</p></figure><p id="e581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面，<code class="fe lq lr ls lt b">pressedButton</code>是一个<code class="fe lq lr ls lt b">var</code>，所以它的值是mutable(可变的)——但是错误消息说“自我”是不可变的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/4e31d9ba27bf0a852f3c74eaa8ce1688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Af_GlxHwuo0AqTndLniMUw.png"/></div></div></figure><p id="462a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe lq lr ls lt b">pressedButton</code>是可变的，而<code class="fe lq lr ls lt b">self</code>不是？让我们查找错误信息。</p><div class="kj kk kl km gt ab cb"><figure class="nf kn ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d89a66ef0537315e42b5028aac0c89b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1406/format:webp/1*fJhsMLszy3E6Ykj3fYmmhg.png"/></div></figure><figure class="nf kn nl nh ni nj nk paragraph-image"><a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-fix-cannot-assign-to-property-self-is-immutable"><img src="../Images/3e1a1506cdabac47d9acf1fa708fa615.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*g8fx4QIcHQnARM_X19Jjsw.png"/></a></figure></div><p id="40cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用Swift进行黑客攻击告诉我们“如果你想在程序运行时改变一个属性的值，你应该用<code class="fe lq lr ls lt b">@State</code>来标记它。”好吧，让我们看看它是否有效…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/c1654a09262a3b2b1ffc99c3031d4335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MDZSzOqZKOHbqttOTcM7A.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">在变量前加上` @ State可以了！</p></figure><p id="a002" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很容易解决！但是它是如何摆脱“<code class="fe lq lr ls lt b">self</code>不可变”的错误的——它使<code class="fe lq lr ls lt b">self</code>可变了吗？</p><p id="d43c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案比我预想的要有趣得多(也复杂得多，唉)。就在上周，我还以为<code class="fe lq lr ls lt b">@State</code>属性是专门用来链接UI元素的——就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2ab2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，圆角矩形访问<code class="fe lq lr ls lt b">@State var rectangleIsGreen</code>并在属性值改变时自动更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/33ca3c7d1819621b2866cdbad161b2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/1*cGNUktpRu-hO3spz0oWVDQ.gif"/></div></figure><p id="ef42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe lq lr ls lt b">@State</code>属性用于与UI同步…但是这与修复“<code class="fe lq lr ls lt b">self</code>不可变”错误有什么关系呢？<code class="fe lq lr ls lt b">@State</code>是某种万能魔粉吗？不完全是…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ae6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">研究</h1><p id="feec" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">看起来<code class="fe lq lr ls lt b">@State</code>属性可以做两件事:</p><ol class=""><li id="1070" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">修复一个错误:“无法分配给属性:<code class="fe lq lr ls lt b">self</code>是不可变的。”</li><li id="9246" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">与UI同步并自动更新。</li></ol><p id="14b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这越来越令人困惑，所以让我们做一些研究！</p><h2 id="0783" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated">能力#1 |修复一个错误:“不能给属性赋值:‘self’是不可变的”</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/4a285228fef949048f099e103bbd6cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZGk1tRKnS0DGl9HlEhoWg.png"/></div></div></figure><p id="c8c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，Hacking With Swift说“如果你想在你的程序运行时改变一个属性的值，你应该用<code class="fe lq lr ls lt b">State</code>来标记它。”好了，让我们<a class="ae lu" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-fix-cannot-assign-to-property-self-is-immutable" rel="noopener ugc nofollow" target="_blank">回到教程</a>读解释:</p><blockquote class="op oq or"><p id="90b7" class="ku kv os kw b kx ky ju kz la lb jx lc ot le lf lg ou li lj lk ov lm ln lo lp im bi translated">“SwiftUI的视图应该是structs，这意味着它们在默认情况下是不可变的。如果这是我们自己的代码，我们可以使用<code class="fe lq lr ls lt b">mutating</code>标记方法，告诉Swift它们将更改值，但我们不能在SwiftUI中这样做，因为它使用计算属性。”</p></blockquote><p id="f89f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，有道理…有点。这里有一个总结:</p><ul class=""><li id="9eeb" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp ow nv nw nx bi translated">SwiftUI视图是结构</li><li id="f9f9" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">默认情况下，结构是不可变的(所以里面的值也是不可变的)</li><li id="3ec0" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">标有<code class="fe lq lr ls lt b">mutating</code>的方法(函数)可以改变属性值</li><li id="2a76" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">但是这在SwiftUI中是不允许的，因为它使用了一个计算属性</li></ul><p id="d6c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这提供了相当多的信息，我们现在知道错误在某种程度上与结构有关——但是我们仍然不知道<em class="os">为什么用<code class="fe lq lr ls lt b">@State</code>标记属性会修复错误。在我们深入研究之前，让我们看看<code class="fe lq lr ls lt b">@State</code>的其他能力。</em></p><h2 id="bb46" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated">能力2 |与用户界面同步并自动更新</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/6d4798489a10d23ce42a70b894146fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATXBQqe_HN9zIHj-Vc8twA.png"/></div></div></figure><p id="e619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何用<code class="fe lq lr ls lt b">@State</code>属性同步UI的部分内容在几乎所有SwiftUI教程中都有涉及，比如这篇。我们去看看。</p><div class="ox oy gp gr oz pa"><a href="https://www.hackingwithswift.com/quick-start/swiftui/working-with-state" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">与国家合作</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">Paul Hudson @twostraws针对Xcode 11.5全面更新，所有应用都会改变状态。例如，用户可能已经点击了…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">www.hackingwithswift.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po ks pa"/></div></div></a></div><p id="1b34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要找的东西在第三段(在上面的教程中)…</p><blockquote class="op oq or"><p id="f391" class="ku kv os kw b kx ky ju kz la lb jx lc ot le lf lg ou li lj lk ov lm ln lo lp im bi translated">“…如果我们在[properties]之前添加了特殊的<code class="fe lq lr ls lt b">@State</code>属性，SwiftUI将自动监视更改并更新使用该状态的视图的任何部分。”</p></blockquote><p id="25d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像在普通的UIKit编程中一样，为了<em class="os">使用那个状态，</em>也就是访问属性的值(在本例中是一个布尔值)，只需引用属性的名称:</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="4d35" class="od md it lt b gy pt pu l pv pw">struct ContentView: View {<br/>@State var <strong class="lt iu">rectangleIsGreen</strong> = false<br/>    var body: some View {<br/>        RoundedRectangle(cornerRadius: 5)<br/>        .fill(<strong class="lt iu">rectangleIsGreen</strong> ? Color.green : Color.blue)<br/>    }<br/>}</span></pre><p id="736d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们使用<a class="ae lu" href="https://www.hackingwithswift.com/sixty/3/7/the-ternary-operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>根据<code class="fe lq lr ls lt b"><strong class="kw iu">rectangleIsGreen</strong></code>属性的值确定矩形的颜色。我们可以这样改变它:</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="7bd4" class="od md it lt b gy pt pu l pv pw"><strong class="lt iu">rectangleIsGreen</strong> = true</span></pre><p id="f010" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等——这听起来很熟悉。难道我们的“<code class="fe lq lr ls lt b">self</code>是不可变的”错误不是在我们试图改变一个属性值时发生，并在我们用<code class="fe lq lr ls lt b">@State</code>标记它时消失吗？有趣的是——在<code class="fe lq lr ls lt b">@State</code>中一定有什么东西允许结构可变或者不可变。事实证明，在<code class="fe lq lr ls lt b">@State</code>中有很多有待发现的东西。让我们潜得更深！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="420a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">深潜水</h1><h2 id="bc0f" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated">实验:保持<a class="ae lu" href="https://dzone.com/articles/is-your-code-dry-or-wet" rel="noopener ugc nofollow" target="_blank">干燥</a></h2><p id="4bbf" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">让我们从这段代码开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b98d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们在一个<code class="fe lq lr ls lt b">HStack</code>中有两个圆角矩形和一个按钮。它们与<code class="fe lq lr ls lt b">@State</code>属性<code class="fe lq lr ls lt b">rectangleIsGreen</code>同步。目前，我们与“不要重复你自己”(干)正好相反:我们不是干，而是把所有事情都写两遍(湿)🤣。不管怎样，结果是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/e3a54575aababe03b4a5ec759dac9014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wfi-mI2PRAfzO_4EKGC1yw.png"/></div></div></figure><p id="7f43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不管我们是干的还是湿的，把你的代码分解成更小的组件总是一个好主意——它变得可重用和更容易阅读。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/5c8e9dda761e73776d4518d4bff4bc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OU4iGmfQnJbsPdzKyqoXHQ.png"/></div></div></figure><p id="cef7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们想要将圆角矩形的代码从我们原来的<code class="fe lq lr ls lt b">ContentView</code>移动到它自己的结构中，我们称之为<code class="fe lq lr ls lt b">ColorView</code>(同样，SwiftUI视图应该总是结构)。</p><p id="19a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">圆角矩形在其自身的结构中仍然需要与来自<code class="fe lq lr ls lt b">ContentView.</code>的<code class="fe lq lr ls lt b"><strong class="kw iu">rectangleIsGreen</strong></code>的值同步，但是如果我们简单地将它的引用从<code class="fe lq lr ls lt b">ContentView</code>向下传递到<code class="fe lq lr ls lt b">ColorView</code>，这将违反苹果的规则—<a class="ae lu" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">官方文档</a>说:</p><blockquote class="op oq or"><p id="fa34" class="ku kv os kw b kx ky ju kz la lb jx lc ot le lf lg ou li lj lk ov lm ln lo lp im bi translated">您应该只从视图主体内部访问状态属性…将您的状态属性声明为私有，以防止视图的客户端访问它</p></blockquote><p id="f847" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，在我们的例子中，<code class="fe lq lr ls lt b"><strong class="kw iu">rectangleIsGreen</strong></code> <strong class="kw iu"> </strong>不应该从<code class="fe lq lr ls lt b">ColorView</code>访问。但是我们<em class="os">需要</em>才能访问！嗯…</p><p id="fe9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从子结构(在本例中是<code class="fe lq lr ls lt b">ColorView</code>)访问父属性的值的正确方法是创建一个双向连接。我们可以用相同的值同步两个独立的属性，每个结构一个——通过在<code class="fe lq lr ls lt b">ColorView</code>中添加一个<code class="fe lq lr ls lt b">@Binding</code>属性。</p><p id="c3d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">ContentView</code> <em class="os">中的<code class="fe lq lr ls lt b">@State</code>属性和</em><code class="fe lq lr ls lt b">@Binding</code>属性会指向同一个值，双方都可以读写。</p><p id="4af1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，什么？<strong class="kw iu"> </strong> <code class="fe lq lr ls lt b">@Binding</code>？我们甚至没有报道完<code class="fe lq lr ls lt b">@State</code>！尽管如此，不要担心— <code class="fe lq lr ls lt b">@Binding</code>非常容易理解！不过，让我们先写下<code class="fe lq lr ls lt b">ColorView</code>的代码。</p><ol class=""><li id="3b0b" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">创建一个名为<code class="fe lq lr ls lt b">ColorView</code>的新结构。</li><li id="e157" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">在<code class="fe lq lr ls lt b">ColorView</code>内部，添加圆角矩形的代码。</li><li id="4f08" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">然后，再次在<code class="fe lq lr ls lt b">ColorView</code>中，创建一个名为<code class="fe lq lr ls lt b"><strong class="kw iu">colorRectangleIsGreen</strong></code>的<code class="fe lq lr ls lt b">@Binding</code>属性(名称并不重要，可以与<code class="fe lq lr ls lt b">ContentView</code>中的<code class="fe lq lr ls lt b"><strong class="kw iu">rectangleIsGreen</strong></code>属性相同，但是我在其中添加了<code class="fe lq lr ls lt b">color</code>，以便于区分)。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9637bf087568f0ea7afc55f90f9aa621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6iekqy2N6catktJ33o0eg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">双向连接！在“ContentView”内部，通过“rectangleIsGreen”访问该值。在“ColorView”内部，通过“colorRectangleIsGreen”访问该值。</p></figure><p id="341b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要我们提供类型(在这种情况下，是一个布尔值)，属性<code class="fe lq lr ls lt b">@Binding</code>就不需要默认值——结构自动拥有<a class="ae lu" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID214" rel="noopener ugc nofollow" target="_blank">隐式初始化器</a>。</p><p id="79a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">ColorView</code>的代码现在应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3daf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完成了圆角矩形的构造，回到<code class="fe lq lr ls lt b">ContentView</code>，我们可以…</p><ol class=""><li id="f566" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">删除两个圆角矩形的代码。</li><li id="d124" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">用两个初始化的<code class="fe lq lr ls lt b">ColorView</code>替换它们。</li></ol><p id="887d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">删除很容易，所以先删除圆角矩形。</p><p id="68a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，我们如何实例化<code class="fe lq lr ls lt b">ColorView</code> s呢？我们需要指定<code class="fe lq lr ls lt b">rectangleIsGreen</code>应该与<code class="fe lq lr ls lt b">colorRectangleIsGreen</code>同步。让我们尝试使用Xcode的自动完成功能，看看我们需要什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/d5ac5439c37baa648fa40e4ea74fd170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*qDDqj39OJBT5kYnDz1xdjA.png"/></div></figure><p id="108f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">啊哈！所以看起来<code class="fe lq lr ls lt b">ColorView</code>期望一个<code class="fe lq lr ls lt b">Binding&lt;Bool&gt;</code>作为它的<code class="fe lq lr ls lt b">colorRectangleIsGreen</code>属性。现在唯一能填空的一定是<code class="fe lq lr ls lt b">@State</code>属性，也就是<code class="fe lq lr ls lt b">rectangleIsGreen</code>。我们试试吧！</p><p id="0e86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等…有一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/82c650bd068e80dfbaba15d214674e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nRibMkaxsn6nwZYVDCxiA.png"/></div></div></figure><p id="1162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">错误显示<code class="fe lq lr ls lt b">rectangleIsGreen</code>是一个<code class="fe lq lr ls lt b">Bool</code>而不是一个<code class="fe lq lr ls lt b">Binding&lt;Bool&gt;</code>。然而，编译器提供了一个修复方法:只需添加<code class="fe lq lr ls lt b">$</code>。好吧…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/48606086dd0e658d82e524605a5d4379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0x7B0Xblpj6exKZklKgLYA.png"/></div></div></figure><p id="6923" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以…成功了！但是什么是<code class="fe lq lr ls lt b">$</code>？</p><p id="600d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之:这是一个自动生成的属性。在SwiftUI中，标有<code class="fe lq lr ls lt b">@State</code>(或<code class="fe lq lr ls lt b">@Binding</code> …我将在本文末尾解释)的属性不仅仅是一个属性。<strong class="kw iu">是三个属性！</strong></p><p id="c971" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么？三处房产？！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/44cce4697b50deea3da8b2c441e0c5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_YevxNtP6XdnEGkieljkg.png"/></div></div></figure><p id="537a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，当我们第一次写下<code class="fe lq lr ls lt b">rectangleIsGreen</code>属性时，Xcode的编译器<a class="ae lu" href="https://nalexn.github.io/stranger-things-swiftui-state/" rel="noopener ugc nofollow" target="_blank">自动将</a> <em class="os">翻译成</em>三个属性。它们是不可见的(包含在@State中，这是一个<a class="ae lu" href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#projections" rel="noopener ugc nofollow" target="_blank">属性包装器</a>)——你看不到它们，但是当你引用它们时它们会工作。然后，Xcode删除了原来的<code class="fe lq lr ls lt b">rectangleIsGreen</code> <code class="fe lq lr ls lt b">@State</code>属性——但是你还是可以看到。</p><p id="fc53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的…这是很多信息。我将单独解释每个属性。先说第一个。</p><h2 id="2205" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated"><code class="fe lq lr ls lt b">1. '_rectangleIsGreen'</code></h2><p id="664f" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">基本上，这就是<code class="fe lq lr ls lt b">@State</code>属性本身。如你所见，它的初始值是我们第一次输入的值— <code class="fe lq lr ls lt b">false</code>。</p><p id="e849" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他自动生成的属性将从该属性中获取它们的值，因为该属性包括:</p><ul class=""><li id="d7ce" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp ow nv nw nx bi translated"><code class="fe lq lr ls lt b">wrappedValue</code>，这是布尔值</li><li id="3a4f" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated"><code class="fe lq lr ls lt b">projectedValue</code>，即<code class="fe lq lr ls lt b">Binding</code>值，用于与其他视图同步……听起来很熟悉。</li></ul><p id="40e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果您需要手动编写初始化块，您可以使用该属性，在Swift Playgrounds中，您有时需要这样做。</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="f677" class="od md it lt b gy pt pu l pv pw">@State <strong class="lt iu">var</strong> rectangleIsGreen: Bool</span><span id="04da" class="od md it lt b gy qc pu l pv pw"><strong class="lt iu">init</strong>(rectangleIsGreen: State&lt;Bool&gt;) {<br/>  <strong class="lt iu">self</strong>.<strong class="lt iu">_</strong>rectangleIsGreen = rectangleIsGreen<br/>}</span></pre><h2 id="baae" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated"><code class="fe lq lr ls lt b">2. '$rectangleIsGreen'</code></h2><p id="6e4d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">看到{}s了吗？这意味着这是一个计算属性，这也意味着它<em class="os">计算</em>它将返回的值。</p><p id="3458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等...计算的属性不需要一个<code class="fe lq lr ls lt b">get</code>(用于返回值)，有时还需要一个<code class="fe lq lr ls lt b">set</code>(用于修改其他属性)吗？</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="d4b1" class="od md it lt b gy pt pu l pv pw">var computedProperty: Bool {<br/>  get { return true } // set is optional<br/>}</span></pre><p id="5fcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，但是<code class="fe lq lr ls lt b">set</code>是可选的——如果你没有它，你可以完全省略<code class="fe lq lr ls lt b">get</code>。</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="6912" class="od md it lt b gy pt pu l pv pw">var computedProperty: Bool { // anything inside here is the get!<br/>  return true<br/>}</span></pre><p id="90d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你甚至可以不写<code class="fe lq lr ls lt b">return</code>而让它变得更快(或者更懒……我想我更喜欢更快)。</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="6873" class="od md it lt b gy pt pu l pv pw">var computedProperty: Bool {<br/>  true<br/>}</span></pre><p id="c2c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，<code class="fe lq lr ls lt b">$rectangleIsGreen</code>得到了<code class="fe lq lr ls lt b">_rectangleIsGreen</code>的<code class="fe lq lr ls lt b">projectedValue</code>并返回它。同样，<code class="fe lq lr ls lt b">projectedValue</code>是用于同步视图的。这就是为什么我们在初始化<code class="fe lq lr ls lt b">ColorView</code>时必须使用<code class="fe lq lr ls lt b">$rectangleIsGreen</code>而不是<code class="fe lq lr ls lt b">rectangleIsGreen</code>。啊哈！</p><h2 id="6425" class="od md it bd me oe of dn mi og oh dp mm ld oi oj mo lh ok ol mq ll om on ms oo bi translated"><code class="fe lq lr ls lt b">3. 'rectangleIsGreen'</code></h2><p id="dec2" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这似乎是最简单的属性，因为它前面没有下划线或美元符号…但实际上在它下面有一些逻辑。看到<code class="fe lq lr ls lt b">get</code>和<code class="fe lq lr ls lt b">set</code>了吗？这意味着它也是一个计算属性！</p><ul class=""><li id="5841" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp ow nv nw nx bi translated">当您<code class="fe lq lr ls lt b">get</code>属性(引用它)时，它返回的值是<code class="fe lq lr ls lt b">_rectangleIsGreen</code>的包装值。记住，<code class="fe lq lr ls lt b">_rectangleIsGreen</code>是<code class="fe lq lr ls lt b">@State</code>属性本身，包含了<code class="fe lq lr ls lt b">wrappedValue</code>和<code class="fe lq lr ls lt b">projectedValue</code>。在这里，我们想要的是<code class="fe lq lr ls lt b">wrappedValue</code>，它是一个简单的布尔值。</li><li id="c907" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">当你<code class="fe lq lr ls lt b">set</code>属性时，它也需要更新<code class="fe lq lr ls lt b">@State</code>属性，也就是<code class="fe lq lr ls lt b">_rectangleIsGreen</code>。<code class="fe lq lr ls lt b">newValue</code>是Swift中的一个专业关键词，简单来说就是新价值。</li></ul><p id="6938" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等……但是什么是<code class="fe lq lr ls lt b">nonmutating</code>？还有为什么只有<code class="fe lq lr ls lt b">set</code>前面有<code class="fe lq lr ls lt b">nonmutating</code>？</p><p id="2334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是<code class="fe lq lr ls lt b">@State</code>修复“<code class="fe lq lr ls lt b">self</code>不可变”错误的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a072" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">移动到身体上</h1><p id="b856" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">记得Hacking With Swift说过:</p><blockquote class="qd"><p id="9228" class="qe qf it bd qg qh qi qj qk ql qm lp dk translated">“如果这是我们自己的代码，我们可以使用<code class="fe lq lr ls lt b"><em class="qn">mutating</em></code>标记方法，告诉Swift它们将改变值，但我们不能在SwiftUI中这样做，因为它使用计算属性。”</p></blockquote><p id="c932" class="pw-post-body-paragraph ku kv it kw b kx qo ju kz la qp jx lc ld qq lf lg lh qr lj lk ll qs ln lo lp im bi translated">好的…另外，记住计算属性是在返回值之前做一些计算的属性？好吧，仔细看看<code class="fe lq lr ls lt b">body</code>——它看起来像一个计算属性吗？</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="9084" class="od md it lt b gy pt pu l pv pw"><strong class="lt iu">var</strong> body: <strong class="lt iu">some</strong> View {<br/>  ...<br/>}</span></pre><p id="70f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答:是的，<code class="fe lq lr ls lt b">body</code>是一个计算属性。它没有一个<code class="fe lq lr ls lt b">return</code>语句，但是花括号{}给出了它。尽管您看不到<code class="fe lq lr ls lt b">get</code>或<code class="fe lq lr ls lt b">set</code>，但您知道花括号中的内容是<code class="fe lq lr ls lt b">get</code>(因为计算属性必须总是有一个<code class="fe lq lr ls lt b">get</code>)。</p><p id="0362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Swift中，在一个结构的计算属性中，你不能改变其他属性。<strong class="kw iu"> </strong>这就是为什么我们得到了“<code class="fe lq lr ls lt b">self</code>是不可变的”错误，因为我们试图在<code class="fe lq lr ls lt b">body</code>内部变异<code class="fe lq lr ls lt b">pressedButton</code>(在第一个例子中)。</p><p id="591b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是为什么呢？在Swift中，结构是值类型。这意味着无论何时你改变一个结构，它实际上并没有改变——它只是用你的改变创建了一个新的结构并替换了旧的结构。</p><p id="5d15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么如果你想改变一个结构或者它的一个属性，你需要用<code class="fe lq lr ls lt b">var</code>来声明它。</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="3445" class="od md it lt b gy pt pu l pv pw">var contentView = ContentView()</span></pre><p id="ff9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当你创建一个结构时，编译器不知道它是用<code class="fe lq lr ls lt b">var</code>还是<code class="fe lq lr ls lt b">let</code>来声明。如果它是用<code class="fe lq lr ls lt b">let</code>声明的，那么该结构中的函数或计算属性将不能改变同一结构中的其他属性。</p><p id="f94c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么你必须用<code class="fe lq lr ls lt b">mutating</code>来标记它们，这样编译器就知道你要从内部进行修改，并防止你在以后将<code class="fe lq lr ls lt b">struct</code>声明为<code class="fe lq lr ls lt b">let</code>。</p><p id="50b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，为了避免错误而不使用<code class="fe lq lr ls lt b">@State</code>，我们可以将<code class="fe lq lr ls lt b">mutating</code>关键字添加到<code class="fe lq lr ls lt b">body</code>的<code class="fe lq lr ls lt b">get</code>中，如下所示:</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="581e" class="od md it lt b gy pt pu l pv pw"><strong class="lt iu">var</strong> body: <strong class="lt iu">some</strong> View {<br/>  mutating get {<br/>    ...<br/>  }<br/>}</span></pre><p id="f0c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是……因为<code class="fe lq lr ls lt b">ContentView</code>需要符合<code class="fe lq lr ls lt b">View</code>，所以不行——swift ui的<code class="fe lq lr ls lt b">View</code>不允许<code class="fe lq lr ls lt b">get</code>变异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qt"><img src="../Images/d9f42aa9e8177105efb2dc326b227994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GoC6nmf3UrhhZAH2nZJHOw.png"/></div></div></figure><p id="e162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使SwiftUI允许，我们也不希望将自己局限于将<code class="fe lq lr ls lt b">ContentView</code>作为一个变量——记住，因为我们添加了<code class="fe lq lr ls lt b">mutating</code>属性，编译器会阻止我们将<code class="fe lq lr ls lt b">ContentView</code>声明为<code class="fe lq lr ls lt b">let</code>。这可能会限制您的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qu"><img src="../Images/739acf1e10b083f4e2c66c57f4c7db9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vcf5fD2eEF-GRaNHyqXyqg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">“按下按钮”示例—用“let”声明</p></figure><p id="26c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是有了<code class="fe lq lr ls lt b">@State</code>，你<em class="os">可以</em>用<code class="fe lq lr ls lt b">let</code>声明一个struct。什么？怎么会？这里再次出现了<code class="fe lq lr ls lt b">nonmutating</code>属性。那是<code class="fe lq lr ls lt b">@State</code>不那么秘密的酱。</p><p id="e3f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再来看看编译器生成的<code class="fe lq lr ls lt b">rectangleIsGreen</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qv"><img src="../Images/16fec6b85fd092a3d08e89d2cbb8803c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ2keV9ENmdyfEfIHGMFwA.png"/></div></div></figure><p id="69e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，在computed properties中，<code class="fe lq lr ls lt b">get</code>是<code class="fe lq lr ls lt b">nonmutating</code>而<code class="fe lq lr ls lt b">set</code>是<code class="fe lq lr ls lt b">mutating</code> …但是如果你让<code class="fe lq lr ls lt b">set</code> <code class="fe lq lr ls lt b">nonmutating</code>，你告诉编译器这个<em class="os">不会让</em>改变它所在的结构。让我们回到<code class="fe lq lr ls lt b">pressedButton</code>的例子，在那里使用<code class="fe lq lr ls lt b">nonmutating</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qw"><img src="../Images/e2f2da80603b784fbb8fcb3786566d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqLEXmaxfDpcw78PWpBRxw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">改编自Rob Mayoff的回答<a class="ae lu" href="https://forums.swift.org/t/why-i-can-mutate-state-var-how-does-state-property-wrapper-work-inside/27209/2" rel="noopener ugc nofollow" target="_blank">此处</a>。这将会泄漏内存，但这只是一个例子。</p></figure><p id="992b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们没有改变<code class="fe lq lr ls lt b">ContentView</code>——我们只是修改了<code class="fe lq lr ls lt b">pressedButtonStorage</code>的一个属性，它是一个<code class="fe lq lr ls lt b">let</code>。</p><p id="8778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们设法从一个存储属性中改变了另一个属性的值，有效地解决了我们最初的问题！</p><p id="c2f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，上面的代码很难管理。顾名思义，<code class="fe lq lr ls lt b">UnsafeMutablePointer</code>是不安全的……我们需要注意手动存储和释放内存。它花了大约10行代码，而<code class="fe lq lr ls lt b">@State</code>只是在属性前添加了六个字符！</p><pre class="kj kk kl km gt pp lt pq pr aw ps bi"><span id="058a" class="od md it lt b gy pt pu l pv pw"><strong class="lt iu">@State</strong> var pressedButton = false<br/>↑↑↑↑↑↑ <em class="os">6 characters!</em></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3660" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">干燥实验</h1><p id="d3a6" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">既然我们已经把一切都整理好了，我们就可以完成我们的干燥实验了。下面是最终代码！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2c1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有最后一件事:<code class="fe lq lr ls lt b">@Binding</code>。还记得我说过标有<code class="fe lq lr ls lt b">@State</code> <em class="os">或</em> <code class="fe lq lr ls lt b">@Binding</code> <em class="os"> </em>的属性会自动生成三个属性吗？</p><p id="f49d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">@State</code>和<code class="fe lq lr ls lt b">@Binding</code>的唯一区别是<code class="fe lq lr ls lt b">@Binding</code>需要有一个父节点。那个家长可以是<code class="fe lq lr ls lt b">@Binding</code>或者<code class="fe lq lr ls lt b">@State</code>——没关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qx"><img src="../Images/b62dfd57572890c794dec5ec0d3ecbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIUQvG9e-bf-ep3gUIYUqg.png"/></div></div></figure><p id="9d35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以拥有尽可能多的子结构，全部同步在一起，但是我们需要从某个地方获得初始的<code class="fe lq lr ls lt b">Binding&lt;Bool&gt;</code></p><ul class=""><li id="cdeb" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp ow nv nw nx bi translated">从<code class="fe lq lr ls lt b">@State var rectangleIsGreen</code>属性内部</li><li id="8055" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">从<code class="fe lq lr ls lt b">@State var rectangleIsGreen</code>属性的自动生成的<code class="fe lq lr ls lt b">_rectangleIsGreen</code>属性内部</li><li id="513d" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp ow nv nw nx bi translated">从<code class="fe lq lr ls lt b">@State var rectangleIsGreen</code>属性自动生成的<code class="fe lq lr ls lt b">_rectangleIsGreen</code>属性的<code class="fe lq lr ls lt b">projectedValue</code>属性中。</li></ul><p id="7dcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bfe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><div class="ox oy gp gr oz pa"><a href="https://forums.swift.org/t/why-i-can-mutate-state-var-how-does-state-property-wrapper-work-inside/27209" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">为什么我可以变异@State var？@State属性包装器内部是如何工作的？</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">变异常规成员变量获取错误:“无法分配给属性:“self”是不可变的”“无法在…上使用变异成员</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">forums.swift.org</p></div></div><div class="pj l"><div class="qy l pl pm pn pj po ks pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://nalexn.github.io/stranger-things-swiftui-state/" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">斯威夫图伊州的怪事</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">像许多其他开发人员一样，我从苹果的精彩教程开始了对SwiftUI的实际了解，该教程…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">nalexn.github.io</p></div></div><div class="pj l"><div class="qz l pl pm pn pj po ks pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-fix-cannot-assign-to-property-self-is-immutable" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">如何修复“无法分配给属性:“self”是不可变的”</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">Paul Hudson @twostraws针对Xcode 11.5全面更新SwiftUI的视图应该是structs，也就是说它们是不可变的…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">www.hackingwithswift.com</p></div></div></div></a></div></div></div>    
</body>
</html>