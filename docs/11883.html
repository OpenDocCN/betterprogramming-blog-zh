<html>
<head>
<title>Sharing Code Using a setup.py File in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的setup.py文件共享代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-code-using-a-setup-py-b6a596646532?source=collection_archive---------0-----------------------#2022-04-25">https://betterprogramming.pub/sharing-code-using-a-setup-py-b6a596646532?source=collection_archive---------0-----------------------#2022-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa08" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一篇关于如何在Python项目中共享代码的文章</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/698e52c802facefa74f7efed603992e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_EVAJyggTXtE_TwS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">absolute vision</a>拍摄的照片</p></figure><h1 id="49ba" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">问题</strong></h1><p id="e357" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您有以下项目结构:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="45c2" class="mp kx iq ml b gy mq mr l ms mt">├── <strong class="ml ir">src</strong></span><span id="394c" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">common<br/></strong>     ├── __init__.py<br/>     └── utils.py</span><span id="96c0" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">config<br/></strong>     └── requirements.txt</span><span id="7e0c" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">project1<br/></strong>     ├── __init__.py<br/>     └── main.py</span><span id="83c2" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">project2<br/></strong>     ├── __init__.py<br/>     └── main.py</span><span id="a214" class="mp kx iq ml b gy mu mr l ms mt">├── README.md</span></pre><p id="914a" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">其中两个子项目<code class="fe na nb nc ml b">&lt;project1&gt;</code>和<code class="fe na nb nc ml b">&lt;project2&gt;</code>都有一个使用相似代码的<code class="fe na nb nc ml b">main.py</code>文件。</p><p id="4583" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">您(希望)将这个<em class="nd">共享的</em>代码存储在第三个目录<code class="fe na nb nc ml b">&lt;common&gt;</code>中的<code class="fe na nb nc ml b">utils.py</code>文件中。</p><p id="6ef3" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">要使用存储在<code class="fe na nb nc ml b">utils.py</code>中的任何函数，您尝试将以下导入语句写入<code class="fe na nb nc ml b">&lt;project1&gt;</code>和<code class="fe na nb nc ml b">&lt;project2&gt;</code>的<code class="fe na nb nc ml b">main.py</code>文件中:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="bb5c" class="mp kx iq ml b gy mq mr l ms mt">from common.utils import &lt;function1&gt;, ...</span></pre><p id="c371" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">并且您得到下面的<em class="nd"> ModuleNotFoundError </em>:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="8fa0" class="mp kx iq ml b gy mq mr l ms mt">ModuleNotFoundError: No module named 'common'</span></pre><p id="2d32" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">然后，您尝试将import语句修改为:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="4919" class="mp kx iq ml b gy mq mr l ms mt">from .utils import &lt;function1&gt;</span></pre><p id="ccd9" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">或者</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="99b3" class="mp kx iq ml b gy mq mr l ms mt">from ..utils import &lt;function1&gt;</span></pre><p id="84b6" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">返回一个<em class="nd">导入错误:</em></p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="3654" class="mp kx iq ml b gy mq mr l ms mt">ImportError: attempted relative import with no known parent package</span></pre><h1 id="6d84" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">这怎么解决？</strong></h1><p id="0063" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我将解释为什么您会收到这些错误，以及如何通过使用一个创建Python包的<code class="fe na nb nc ml b">setup.py</code>文件来避免这个问题。</p><p id="dc56" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">首先…</p><h2 id="e019" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak">有哪些错误？</strong></h2><blockquote class="np nq nr"><p id="5ef5" class="lo lp nd lq b lr mv jr lt lu mw ju lw ns mx lz ma nt my md me nu mz mh mi mj ij bi translated">ModuleNotFoundError:没有名为“common”的模块</p></blockquote><p id="e45d" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">当您尝试导入未安装在您的(虚拟)环境中的Python包/模块时，会出现此错误。如果您运行该命令:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c677" class="mp kx iq ml b gy mq mr l ms mt">pip list</span></pre><p id="2495" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">在您的终端(mac)或命令行提示符(windows)中，您试图安装的模块将不在输出到屏幕的列表中。例如，在收到我得到的<code class="fe na nb nc ml b">ModuleNotFoundError</code>后，在我的虚拟环境(venv)中运行<code class="fe na nb nc ml b">pip list</code>命令:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="4cfe" class="mp kx iq ml b gy mq mr l ms mt">Package        Version<br/>-------------- -------<br/>pip            21.3.1<br/>setuptools     59.0.1</span></pre><p id="f8e7" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">这不包含对<code class="fe na nb nc ml b">&lt;common&gt;</code>包文件夹内<code class="fe na nb nc ml b">utils.py</code>的任何引用。</p><blockquote class="np nq nr"><p id="b1b2" class="lo lp nd lq b lr mv jr lt lu mw ju lw ns mx lz ma nt my md me nu mz mh mi mj ij bi translated">ImportError:试图在没有已知父包的情况下进行相对导入</p></blockquote><p id="79c7" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">当您试图从一个父包中导入一个模块，但是Python在<code class="fe na nb nc ml b">__main__</code>中存储了一个不同的父包时，就会出现相对导入错误。本质上，您是在告诉Python从它不知道的包中导入。</p><p id="648a" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">关于Python如何在它的<code class="fe na nb nc ml b">__main__</code>变量中存储信息的一个很好的解释可以在<a class="ae kv" href="https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time" rel="noopener ugc nofollow" target="_blank">【脚本与模块】StackOverflow回答这里</a>中找到。</p><p id="2e1e" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated"><strong class="lq ir">注意:</strong>相对导入不是pythonic式的，应该尽可能避免，以避免混淆并提高代码的可读性。</p><h1 id="d892" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">非Pythonic解</strong></h1><p id="c283" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可能已经尝试过一些可能的非pythonic解决方案…</p><h2 id="d53e" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 1。sys.path() </strong></h2><p id="d744" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您通常可以通过在错误导入之前将所需的包父路径添加到<code class="fe na nb nc ml b">sys.path</code>变量中来解决这两个错误。例如，将下面几行添加到<code class="fe na nb nc ml b">main.py</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5bf6" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">但是，一般来说，我建议避免这种方法，原因如下:</p><ul class=""><li id="7e23" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated"><strong class="lq ir">凌乱</strong>:是凌乱。</li><li id="a210" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><strong class="lq ir">错误传播</strong>:需要正确编码，避免因文件夹位置不同而被他人重复使用的错误。</li><li id="3d0a" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><strong class="lq ir">代码重复</strong>:需要各加一个。包含导入错误的py文件。</li></ul><h2 id="5392" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 2。重组项目</strong></h2><p id="0ce0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可以重新构建项目，并将每个子项目的<code class="fe na nb nc ml b">main.py</code>文件放在根目录下，使导入遵循向下的分层目录结构。</p><p id="aa03" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">避免采用这种解决方案的两个主要原因是:</p><ul class=""><li id="ad56" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated">随着项目的增长，这种方法会变得杂乱无章、不清晰、杂乱无章。</li><li id="bbe9" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated">定制化:它不允许你以一种可读和独特的方式构建你的项目。</li><li id="85fc" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><strong class="lq ir">命名</strong>:你不能用相同的名字命名文件，因为它们都在同一个目录下，这意味着你必须想出唯一的名字，比如<code class="fe na nb nc ml b">main1.py</code>和<code class="fe na nb nc ml b">main2.py</code>。</li></ul><h1 id="295f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">解决方案</h1><p id="8799" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe na nb nc ml b">setup.py</code>去营救……</p><p id="4a80" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">一个很好的经验法则是，如果一个项目中有许多代码可以被许多模块重用，那么就把它放到一个Python包中。</p><h2 id="1112" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak">什么是Python包？</strong></h2><p id="c65d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">包含<code class="fe na nb nc ml b">__init__.py</code>的文件夹会被Python识别为一个包。一个包文件夹<em class="nd">通常</em>包含多个模块。</p><p id="2b02" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">可以使用<code class="fe na nb nc ml b">pip list</code>命令识别安装在您的(虚拟)环境中的包。</p><h2 id="29b9" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak">设置setup.py </strong></h2><ul class=""><li id="ba53" class="nx ny iq lq b lr ls lu lv lx ol mb om mf on mj oc od oe of bi translated">一个<code class="fe na nb nc ml b">setup.py</code>文件提供了关于如何创建定制Python包的信息。它利用Python的<code class="fe na nb nc ml b">setuptools</code>库，基本文件如下所示:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本setup.py文件</p></figure><p id="39b1" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated"><code class="fe na nb nc ml b">setup()</code>的三大法宝是:</p><ul class=""><li id="6183" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated"><code class="fe na nb nc ml b">name </code> —您的Python包的名称。</li><li id="fe53" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><code class="fe na nb nc ml b">install_requires </code> —将<code class="fe na nb nc ml b">setup.py</code>指向一个<code class="fe na nb nc ml b">requirements.txt</code>文件，该文件包含将成为包一部分的Python模块所需的Python库。第3行和第4行让<code class="fe na nb nc ml b">setup.py</code>从指定的位置读入所需的Python包。</li><li id="50cc" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><code class="fe na nb nc ml b">packages </code> —您希望<code class="fe na nb nc ml b">setup.py</code>包含在自定义Python包中的包。您可以使用<code class="fe na nb nc ml b">setuptools.find_packages()</code>来定位项目中的所有包，或者手动输入它们。<code class="fe na nb nc ml b">find_packages()</code>将识别所有包含<code class="fe na nb nc ml b">__init__.py</code>的文件夹。对于示例项目结构，运行<code class="fe na nb nc ml b">find_packages()</code>以包的形式返回以下内容(因为它们是包含<code class="fe na nb nc ml b">__init__.py</code>的文件夹)</li></ul><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="46c5" class="mp kx iq ml b gy mq mr l ms mt">['common', 'project1', 'project2']</span></pre><ul class=""><li id="456c" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated">我们只想将代码打包在<code class="fe na nb nc ml b">&lt;common&gt;</code>中，因此我们将<code class="fe na nb nc ml b">project1</code>和<code class="fe na nb nc ml b">project2</code>添加到<code class="fe na nb nc ml b">exclude</code> kwarg中:</li></ul><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="0252" class="mp kx iq ml b gy mq mr l ms mt">find_packages(exclude=["project1", "project2"])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/65c2c454b4409891f165ba3fc1b859e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YyukQVCFWDdk5VVaWZnqQ.png"/></div></div></figure><h2 id="8d1c" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak">包装安装</strong></h2><p id="5c26" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑到本文“问题”部分的项目设置，以下是使用<strong class="lq ir">上方的<code class="fe na nb nc ml b">setup.py</code> <strong class="lq ir"> </strong>截图时的更新结构。</strong></p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="4e6a" class="mp kx iq ml b gy mq mr l ms mt">├── <strong class="ml ir">src</strong></span><span id="90e7" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">common<br/></strong>    ├── __init__.py<br/>    └── utils.py</span><span id="18c6" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">config<br/></strong>    └── requirements.txt</span><span id="18d8" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">project1<br/></strong>    ├── __init__.py<br/>    └── main.py</span><span id="dc97" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">project2<br/></strong>    ├── __init__.py<br/>    └── main.py</span><span id="4c82" class="mp kx iq ml b gy mu mr l ms mt">  ├── <strong class="ml ir">setup.py       </strong>&lt;--- Added in setup.py to the /src folder</span><span id="f9fb" class="mp kx iq ml b gy mu mr l ms mt">├── README.md</span></pre><p id="c1e8" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated"><strong class="lq ir">注意:</strong><code class="fe na nb nc ml b">setup.py</code>文件需要位于用来构建定制包的包的位置(在<code class="fe na nb nc ml b">setup()</code>包kwarg中)。</p><p id="bd1f" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">要创建包，您需要转到<code class="fe na nb nc ml b">setup.py</code>文件的父文件夹dir并运行以下命令:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="3551" class="mp kx iq ml b gy mq mr l ms mt">pip install -e ./&lt;root of setup.py dir&gt;</span></pre><p id="4502" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">对于本文中的示例项目，您将运行<code class="fe na nb nc ml b">pip install -e ./src</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/2856fc9054ab60174f123b463f3c9d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDyGhm6xgdafTBHNtyEqEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行pip install -e ./src时的终端标准输出</p></figure><p id="e6dc" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated"><code class="fe na nb nc ml b">-e</code>以可编辑模式(动态)运行软件包安装，它会自动检测开发时您对代码所做的任何更改，从而避免不断地重新安装软件包。</p><p id="0fa1" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">安装后，您可以通过重新运行以下命令来检查安装是否成功:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e9f8" class="mp kx iq ml b gy mq mr l ms mt">pip list</span></pre><p id="28f8" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">您现在应该可以看到您的软件包以及在列出的软件包中的<code class="fe na nb nc ml b">requirements.txt</code>中列出的软件包:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="2090" class="mp kx iq ml b gy mq mr l ms mt">Package        Version Editable project location<br/>-------------- ------- -----------------------------<br/>DateTime       4.4<br/>pip            21.3.1<br/>pytz           2022.1<br/>setuptools     59.0.1<br/>simple-package 1.0.0   /Users/danielseal/git_local/Sharing_Code_Example/src<br/>zope.interface 5.4.0</span></pre><p id="a369" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">注意<code class="fe na nb nc ml b">pip list</code>输出的<code class="fe na nb nc ml b">Editable project location</code>部分。</p><p id="f6f8" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">如果你想<em class="nd">硬</em>安装包(静态的)，也就是说，对于一个稳定的版本，你不需要做任何改变，你可以简单地放弃<code class="fe na nb nc ml b">-e</code>并运行<code class="fe na nb nc ml b">pip install ./src</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/4803000254b7864e33a75cac2631fef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fE4By6OhzPws4ECC-1Nyrw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行pip安装时的终端标准输出。/src</p></figure><p id="ae18" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">这个安装更加明确，在运行<code class="fe na nb nc ml b">pip list</code>后返回如下输出:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="da5b" class="mp kx iq ml b gy mq mr l ms mt">Package        Version<br/>-------------- -------<br/>DateTime       4.4<br/>pip            21.3.1<br/>pytz           2022.1<br/>setuptools     59.0.1<br/>simple-package 1.0.0        &lt;--- this is the custom package<br/>zope.interface 5.4.0<br/>wheel          0.37.1.      &lt;--- see 2nd note below</span></pre><p id="93b4" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">当您不在<code class="fe na nb nc ml b">editable</code>模式下时，放下<code class="fe na nb nc ml b">-e</code>还会在<code class="fe na nb nc ml b">/build</code>文件夹中为您的项目中的包装创建一个轮子。</p><p id="c37c" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">注意:</p><ul class=""><li id="7411" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated">静态和动态安装都会在您的项目中添加一个<code class="fe na nb nc ml b">.egg-info</code>文件。</li><li id="aac2" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated">在运行<code class="fe na nb nc ml b">pip install ./src</code>之前，建议使用<code class="fe na nb nc ml b">pip install wheel</code>安装车轮组件，以避免出现未安装车轮的警告。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/9d0e9670f18595ba82fbd53ace7a8132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*se5eko-D81OfC2O4bQAZMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行pip intall后的项目结构。/src(去掉了-e以显示显式安装)。</p></figure><p id="7120" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">在这一步，您已经成功安装了一个定制的Python包。</p><p id="007c" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在，当您运行之前出错的导入时，您应该不会得到任何错误…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/98e8c5131b0c2646a06e38dea7ab3715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNowBmKks3oGd1lfuNvsig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">包安装后运行project1/main.py和project2/main.py时的stdout。</p></figure><h2 id="f93f" class="mp kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">评论</h2><ul class=""><li id="c22d" class="nx ny iq lq b lr ls lu lv lx ol mb om mf on mj oc od oe of bi translated"><strong class="lq ir">警告:</strong>如果您静态安装了软件包(没有在install命令中添加<code class="fe na nb nc ml b">-e</code>)，您将需要重新运行安装命令，在最后添加<code class="fe na nb nc ml b">--upgrade</code>或<code class="fe na nb nc ml b">-u</code>，如果您对正在安装的软件包文件夹内的代码进行了更改(本例中为<code class="fe na nb nc ml b">&lt;common&gt;</code>):</li></ul><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="ddbf" class="mp kx iq ml b gy mq mr l ms mt">pip install ./src --upgrade</span></pre><ul class=""><li id="3d9d" class="nx ny iq lq b lr mv lu mw lx nz mb oa mf ob mj oc od oe of bi translated"><strong class="lq ir">可编辑:</strong>如前所述，使用<code class="fe na nb nc ml b">pip install -e ./src</code>安装软件包将在可编辑模式下安装软件包。它不会将<code class="fe na nb nc ml b">/build</code>文件夹添加到项目中</li><li id="4c6f" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><strong class="lq ir">版本控制:</strong>如果您已经实现了Python包的新特性或修复，建议在<code class="fe na nb nc ml b">setup()</code> <strong class="lq ir"> </strong>中更新<em class="nd">版本</em> kwarg，以促进良好的版本控制。</li></ul><p id="edb1" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">关于使用pip更新本地Python包的StackOverflow feed 很好地解释了-u(升级)和-e(可编辑)的用法。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="9ac0" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated"><code class="fe na nb nc ml b">Setup.py</code>允许您创建一个定制的Python包，使您能够在一个项目中轻松地共享代码。只需将您的子项目和共享代码组织到包含一个<code class="fe na nb nc ml b">__init__.py</code>的文件夹中，并指示您的<code class="fe na nb nc ml b">setup.py</code>的<code class="fe na nb nc ml b">setup()</code>安装包含在共享代码文件夹中的代码。</p><p id="57b3" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">运行<code class="fe na nb nc ml b">pip install -e ./&lt;root of setup.py dir&gt;</code>(可编辑模式)或<code class="fe na nb nc ml b">pip install ./&lt;root of setup.py dir&gt;</code>，你将安装<strong class="lq ir"> </strong> <code class="fe na nb nc ml b">setup.py</code>定义的包。</p><p id="023b" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">一旦完成，你的项目将有两个额外的隐藏项，一个<code class="fe na nb nc ml b">/build</code>文件夹(没有<code class="fe na nb nc ml b">-e</code>)和一个<code class="fe na nb nc ml b">.egg_info</code>文件。</p><p id="8e0b" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">这些包含关于定制Python包的元数据，允许您共享代码，而没有任何<code class="fe na nb nc ml b">ImportError</code> <em class="nd"> </em>或<code class="fe na nb nc ml b">ModuleNotfoundError</code>错误。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="9128" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">本文中用于生成示例的代码可以在这里找到并复制:</p><div class="pa pb gp gr pc pd"><a href="https://github.com/Dseal95/Sharing_Code_Example.git" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ir gy z fp pi fr fs pj fu fw ip bi translated">GitHub-dseal 95/Sharing _ Code _ Example:使用setup.py创建包并共享的示例…</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">使用setup.py创建包并在整个项目中共享代码的示例。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr kp pd"/></div></div></a></div></div></div>    
</body>
</html>