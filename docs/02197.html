<html>
<head>
<title>Quick ES6 Development Guide — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6快速开发指南—第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quick-es6-development-guide-9b9cd9894a7?source=collection_archive---------21-----------------------#2019-11-12">https://betterprogramming.pub/quick-es6-development-guide-9b9cd9894a7?source=collection_archive---------21-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a41" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作用域、循环、数据结构等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/12c61f27e7d545df3a7d1ecfc2496924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlK4QGY4DWp8nTALfdrfsA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@priscilladupreez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kv" href="https://unsplash.com/s/photos/loops?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e46e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将研究ES6中有哪些新特性，以及如何使用它们，并评估一些快速示例来了解相对于ES5的改进。新功能的列表很大，但这里我们将重点关注一些常用的功能。我们还将探索如何在日常开发任务中使用最佳实践。</p><p id="156a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES9正在讨论中，但是ES6仍然不被所有浏览器完全支持。可以查看GitHub上的<a class="ae kv" href="https://kangax.github.io/compat-table/es6/" rel="noopener ugc nofollow" target="_blank">详细兼容性表</a>进行参考。ECMAScript(ES)是标准，而JavaScript是用来实现这一标准并在此基础上构建的最流行的语言。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="41ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">辖域</h1><p id="b932" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">ES6引入了一些受欢迎的变化来解决JavaScript作用域的常见问题。</p><p id="03bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们举个例子(ES5):</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9995" class="nb ma iq mx b gy nc nd l ne nf">function myFunction() {<br/> var myValue = "I am value";<br/> if (1) {<br/>   let myValue = "I am another value";<br/>   console.log(myValue)<br/> }<br/> console.log(myValue)<br/>}</span></pre><p id="840e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<br/> <em class="ng">我是另一个值</em> <br/> <em class="ng">我是另一个值</em></p><p id="c9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我不希望我的外部<code class="fe nh ni nj mx b">console.log</code>语句(如上例)打印内部变量的值。这通常不是我们想要的行为。</p><p id="30c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES5中有两个作用域:全局和函数。</p><h2 id="3460" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated"><strong class="ak">范围</strong></h2><p id="503e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它只是一个边界，在这个边界内变量是存在的，或者说是可以被使用的。</p><p id="a191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f6b7" class="nb ma iq mx b gy nc nd l ne nf">function myFunction(){<br/>    var myValue = "Don't touch, I'm a value"<br/>}<br/>console.log(myValue)</span></pre><p id="3905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<br/> <em class="ng">引用错误:未定义myValue。</em></p><p id="ab92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们试图在变量<code class="fe nh ni nj mx b">myValue</code>的作用域之外访问它的值。虽然在ES5中，你可以通过使用生命来实现它，但这并不容易。</p><p id="00dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES6中引入了一个关键字<code class="fe nh ni nj mx b">let</code>，这个关键字有局部范围(没错，下一节还有一个)。</p><p id="db7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj mx b">let</code>不是var的替代品，但据说它是ES6和TypeScript中的一个很好的编程标准，因为它使变量范围可预测并且更容易推理。</p><h2 id="d703" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">以打字打的文件</h2><p id="f339" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">ES6标准语言，扩展名. ts</p><p id="7c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它如何解决早期的问题(ES6)。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="80d4" class="nb ma iq mx b gy nc nd l ne nf">function myFunction() {<br/> var myValue = "I am value";<br/> if (1) {<br/>   let myValue = "I am another value";<br/>   console.log(myValue)<br/> }<br/> console.log(myValue)<br/>}</span></pre><p id="514d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<br/> <em class="ng">我是另一个值</em> <br/> <em class="ng">我是值</em></p><p id="29b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该感到有成就感！！现在试着用<code class="fe nh ni nj mx b">let</code>为自己循环一次。</p><h2 id="5929" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">常数</h2><p id="f795" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">另一个令人兴奋的新增功能是<code class="fe nh ni nj mx b">const</code>。<code class="fe nh ni nj mx b">const</code>提供了不变性机制，这意味着变量不会随时间而改变。</p><p id="0dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1466" class="nb ma iq mx b gy nc nd l ne nf">const myConst = "my const value";<br/>myConst = "my another const value";</span><span id="bc6f" class="nb ma iq mx b gy nv nd l ne nf">Output:<br/>VM47:1 Uncaught SyntaxError: Identifier 'myConst' has already been declared<br/>    at &lt;anonymous&gt;:1:1</span></pre><p id="8810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在任何参数之前，我要补充的是，变量是不可变的，但它所赋的值是不可变的。这意味着如果我们声明一个对象为<code class="fe nh ni nj mx b">const</code>，我们可以改变这个对象的属性。</p><p id="7356" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e160" class="nb ma iq mx b gy nc nd l ne nf">const myConstObject = {};<br/>myConstObject.constProp = "Const Value";<br/>console.log(myConstObject)<br/>		<br/>Output:<br/>	{constProp: "Const Value"}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="be69" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">环</h1><p id="5fdf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你经常使用<code class="fe nh ni nj mx b">for…in</code> <code class="fe nh ni nj mx b">foreach</code>循环，你可能会怀疑<code class="fe nh ni nj mx b">for…of</code>的引入，但是相信我，你会喜欢它的！</p><p id="1c99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么<code class="fe nh ni nj mx b">for…of</code>已经到来？肯定<code class="fe nh ni nj mx b">for…of</code>有比<code class="fe nh ni nj mx b">for…in</code>更好的东西。我们去看看。</p><h2 id="3999" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">在(ES5)中为……</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4ac8" class="nb ma iq mx b gy nc nd l ne nf">var myCoins = [1,2,5,10];<br/>for( let coin in myCoins){<br/>	console.log(typeof(coin));<br/>}<br/>			<br/>Output:<br/>	string<br/>	string<br/>	string<br/>	string</span></pre><p id="6b94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，你没看错输出。<code class="fe nh ni nj mx b">for…in</code>循环返回一个数字数组作为字符串值。这显然会混淆并产生难以跟踪的错误。</p><h2 id="e53f" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">For和forEach (ES5)</h2><p id="b732" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们看一个基本的例子来说明<code class="fe nh ni nj mx b">forEach</code>是如何工作的:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6e98" class="nb ma iq mx b gy nc nd l ne nf">var myCoins = [1,2,5,10,20]<br/>myCoins.forEach(function(value){<br/>console.log(value);<br/>});</span><span id="ce52" class="nb ma iq mx b gy nv nd l ne nf">Output:<br/>1,2,5,10,20</span></pre><p id="9ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，没错，没有数字到字符串的转换问题。但是有一个问题。您不能使用break语句跳出循环，并使用continue语句移至下一个迭代。</p><h2 id="ae1f" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">为了…的</h2><p id="4001" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在ES6中引入的<code class="fe nh ni nj mx b">for…of</code>避免了<code class="fe nh ni nj mx b">for…in</code>循环的问题，它与break和continue语句一起工作，甚至允许从封闭块返回。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6d6b" class="nb ma iq mx b gy nc nd l ne nf">var myCoins = [1,2,5,10];<br/>for( let coin of myCoins){<br/>	console.log(typeof(coin));<br/>}<br/>			<br/>Output:<br/>	number<br/>	number<br/>	number<br/>	number</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="48a8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">数据结构</h1><p id="58dc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">先说一些常用的，比如<code class="fe nh ni nj mx b">Set</code>和<code class="fe nh ni nj mx b">Map</code>。</p><h2 id="420f" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">一组</h2><p id="9d9f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们快速介绍一下关于<code class="fe nh ni nj mx b">Set</code>的一些重要要点。</p><ul class=""><li id="5858" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">您不像在<code class="fe nh ni nj mx b">Set</code>中的对象那样存储键值对，只存储键。</li><li id="8dc2" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">没有重复值包含不同的元素/对象。</li></ul><p id="f496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="fc5f" class="nb ma iq mx b gy nc nd l ne nf">let myCoinSet = new Set();<br/>myCoinSet.add('foo');<br/>myCointSet.size<br/>// 1</span><span id="f75f" class="nb ma iq mx b gy nv nd l ne nf">myCoinSet.add('foo');<br/>myCoinSet.size<br/>//1</span></pre><p id="4241" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj mx b">Set</code>接收可迭代参数作为其输入。示例:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="540b" class="nb ma iq mx b gy nc nd l ne nf">let myCoinSet = new Set([1, 2, 3]) - correct<br/>let myCoinSet = new Set(1,2,3) -wrong</span></pre><p id="01d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者你可以这样做:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="91f9" class="nb ma iq mx b gy nc nd l ne nf">Let myCoinSet = new Set();<br/>myCoinset.add(1) -correct<br/>myCoinSet.add(1,2,4) -wrong<br/>myCoinSet.add([1,4,5]) -wrong</span></pre><p id="6cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj mx b">Set</code>不像数组那样支持元素的随机顺序访问。例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5e76" class="nb ma iq mx b gy nc nd l ne nf">console.log(myCoinSet[1]) -wrong</span></pre><p id="a84c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj mx b">Set</code>的一些常见操作:</p><ul class=""><li id="1363" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">移除元素:<code class="fe nh ni nj mx b">myCoinSet.delete(2)</code>。</li><li id="5d5d" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">清空器械包:<code class="fe nh ni nj mx b">myCoinSet.clear();</code></li></ul><p id="cda4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环遍历<code class="fe nh ni nj mx b">Set</code>非常简单。例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e25f" class="nb ma iq mx b gy nc nd l ne nf">let myCoinSet = new Set([1, 2, 5, 10])		<br/>for (let coin in myCoinSet){<br/>console.log(coin)<br/>}</span><span id="5e9c" class="nb ma iq mx b gy nv nd l ne nf">Output:<br/>	1, 2, 5, 10</span></pre><h2 id="22c8" class="nb ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">地图</h2><p id="6f0d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们快速介绍一下地图的一些重要要点。</p><ul class=""><li id="93f5" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">映射是一个键值对。</li><li id="d30a" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">保存时会保持一个顺序，所以当我们放置一个循环时，它会以相同的顺序打印。</li></ul><p id="907c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用<code class="fe nh ni nj mx b">Map</code>做一些基本操作。</p><p id="b319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正在创建<code class="fe nh ni nj mx b">Map</code>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6d3f" class="nb ma iq mx b gy nc nd l ne nf">let myMap = new Map();</span></pre><p id="780b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加对:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8cc5" class="nb ma iq mx b gy nc nd l ne nf">let myMap = new Map();<br/>myMap.set("Name", "Carlos")<br/>myMap.set("Occupation", "Engineer" )</span></pre><p id="dd63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种补充方式是:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4945" class="nb ma iq mx b gy nc nd l ne nf">let myMap = new Map([<br/> [ "Name", "Alex" ],<br/> [ "Occupation", "Test Engineer" ],<br/> [ "Company", "Modus Create" ]<br/>]);</span></pre><p id="9f53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过键获取元素:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1e54" class="nb ma iq mx b gy nc nd l ne nf">map.get("Name")<br/>// Carlos</span></pre><p id="a366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正在检查密钥是否存在:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b4b9" class="nb ma iq mx b gy nc nd l ne nf">map.has(“Name”)<br/>//true</span></pre><p id="719d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按键删除:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="946a" class="nb ma iq mx b gy nc nd l ne nf">map.delete(“Name”)</span></pre><p id="9f73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查大小:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b947" class="nb ma iq mx b gy nc nd l ne nf">map.size()</span></pre><p id="b73e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">清空整个地图:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3b01" class="nb ma iq mx b gy nc nd l ne nf">map.clear()</span></pre><p id="60ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像我们对集合所做的那样在地图上循环是非常容易的，但是这里我们有键值，所以这取决于你想要循环什么。示例:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="465c" class="nb ma iq mx b gy nc nd l ne nf">let m = new Map([<br/> ["Name", "Chris"],<br/> ["Occupation", "Technical Manager"],<br/> ["Company", "Modus Create"],<br/> ["Country", "USA"]<br/>]);</span><span id="6616" class="nb ma iq mx b gy nv nd l ne nf">1-	for(let keys of m.keys()){<br/>	console.log(keys)<br/>	}</span></pre><p id="ff5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><p id="735a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">价值:姓名关键字:克里斯<br/>价值:职业关键字:技术经理<br/>价值:公司关键字:作案手法<br/>价值:国家关键字:美国</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8c1d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">对象与地图有何不同</h1><p id="f2e0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Objects中，您必须使用简单的键作为字符串、数字或符号，但是在<code class="fe nh ni nj mx b">Map</code>中，您可以使用偶数数组和对象。</p><p id="e72a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地图是对象的实例，而不是相反。</p><p id="2b61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数作为值在<code class="fe nh ni nj mx b">Map</code>中是不可能的，但在Object中是可能的。示例:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e457" class="nb ma iq mx b gy nc nd l ne nf">var person = {<br/> name: "Carlos",<br/> workingDays() {<br/>   console.log("25 days average")<br/> }<br/>}</span></pre><p id="a0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的应用程序有大量的JSON操作，使用对象比<code class="fe nh ni nj mx b">Map</code>更好。</p><p id="6a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你使用物件和<code class="fe nh ni nj mx b">Maps</code>是什么体验？请分享你认为其中一种比另一种更有效的情景。什么问题是你不能用一种方法解决而用另一种方法不能解决的？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="8f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES6中有很多更酷更高级的特性，比如胖箭头函数、析构、模块、类、接口、承诺和类型。这不是这个话题的结尾。在下一篇文章中寻找这个主题的第二部分。</p><p id="eeaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请留下您对这件作品的宝贵意见和建议。</p></div></div>    
</body>
</html>