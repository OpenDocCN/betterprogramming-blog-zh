<html>
<head>
<title>Computer Science Fundamentals: Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机科学基础:复杂性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/computer-science-fundamentals-complexity-b75000d09cbe?source=collection_archive---------4-----------------------#2020-02-21">https://betterprogramming.pub/computer-science-fundamentals-complexity-b75000d09cbe?source=collection_archive---------4-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">时间与空间的复杂性等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/183ca1809f6de88c36d5b4c4041e8fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3Fw8gYRGciRL3WOSFHYrQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯蒂安·兰伯特在<a class="ae ky" href="https://unsplash.com/s/photos/fibonacci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎每个写代码的人都必须以这样或那样的方式考虑性能。但是，算法的可执行性意味着什么呢？在这篇文章中，我想向你介绍一些计算机科学家通常学习的关于计算复杂性的基本原理，以便对他们的程序和系统进行推理。从这些方面考虑性能可能有助于您编写更好的代码，更一般地说，有助于您更好地解决问题。</p><p id="895b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">小免责声明:我绝不是这方面的专家。我在这里的目标只是写一个简短的介绍。如果你发现错误或不清楚的地方，我将非常感谢你说出来！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/ab5fb4d91dc5fbedae7b77284b34938c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*u96tPhvycFolEnMKLj0wQg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间与空间。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2f7a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">时间与空间</h1><p id="478d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">计算机科学家通常谈论时间<strong class="lb iu"> </strong>复杂性和空间<strong class="lb iu"> </strong>复杂性。前者指的是算法运行需要多长时间(或者更准确地说，算法需要多少步骤来解决一个问题，因为这些步骤的实时持续时间取决于所使用的计算机硬件)，而后者描述的是在这个过程中占用了多少内存。</p><p id="2008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了谈论这些，计算机科学使用了描述符，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> Big-O符号</a>，通俗地说，指的是最糟糕的情况。例如，要检查一个未排序的<strong class="lb iu"> </strong>数组是否包含一个特定的元素，最坏的情况是该元素位于最后检查的位置，因此这个检查算法的时间复杂度为<em class="na"> O(n) </em>。还有其他符号(Little-O，Big-Omega，Small-Omega)描述稍微不同的情况，例如一般情况，但Big-O(通常缩写为O)是迄今为止最广泛使用的一种。</p><p id="1458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说明这一点的一个很好的问题是<a class="ae ky" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契</a>序列。如果你不熟悉，斐波纳契数列中的一个数字是这样计算的:</p><ul class=""><li id="faf6" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">第一个数字是0。</li><li id="d328" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">第二个数字是1。</li><li id="1ca8" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">后面的每一个数字都是前两个数字的和。例如，第三个数是第一个加第二个(0+1=1)，第四个数是第二个加第三个(1+1=2)，依此类推。按照这种模式，我们得到一个看起来像这样的序列:0，1，1，2，3，5，8，13，21，等等。</li></ul><p id="0774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很容易用一点递归来编写代码，这非常类似于问题的陈述方式或人类对问题的思考方式。对于任何示例，我都将使用类似Java的伪代码，但是您可以随意用您选择的任何语言来尝试。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="0f95" class="nu me it nq b gy nv nw l nx ny">Fib(int i) {<br/>  if (i &lt; 2) return i;<br/>  return Fib(i-1) + Fib(i-2);<br/>}</span></pre><p id="2f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察随着输入数量的增加，需要完成的指令数量会发生什么变化:</p><ul class=""><li id="f435" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">如果<code class="fe nz oa ob nq b">i</code>是0或1，我们只需一步就能返回。这是基本情况(对于递归函数非常重要)。</li><li id="24ba" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果<code class="fe nz oa ob nq b">i</code>为2，第一个条件检查失败，下一行进行两次<code class="fe nz oa ob nq b">Fib</code>调用，每次都要走一步返回。总共有四步。</li><li id="28cd" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">如果<code class="fe nz oa ob nq b">i</code>为3，则进行两次呼叫(<code class="fe nz oa ob nq b">Fib(1)</code>和<code class="fe nz oa ob nq b">Fib(2)</code>)。后者导致了两个调用(<code class="fe nz oa ob nq b">Fib(0)</code>和<code class="fe nz oa ob nq b">Fib(1)</code>)。有了条件检查，就有九个步骤。请注意，对<code class="fe nz oa ob nq b">Fib(1)</code>的调用是重复的。我们稍后将使用它来优化这个算法。</li></ul><p id="8192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种幼稚的<strong class="lb iu"> </strong>斐波那契实现具有<em class="na">【o(2^n】</em>的时间复杂度。也就是说，需要<code class="fe nz oa ob nq b">2</code>的<code class="fe nz oa ob nq b">i</code>次方个指令才能完成，因为对于每个数字≤输入(除了基本情况)，都要进行两次<code class="fe nz oa ob nq b">Fib</code>调用。要计算第十个数，需要100条指令。虽然计算机越来越快，但这并不是一个非常好的运行时。根据您使用的语言，无论计算机的硬件如何，运行时间都会从几秒钟到几分钟到几小时甚至更长。就空间复杂度而言，这也是<em class="na"> O(n ) </em>由于每个对<code class="fe nz oa ob nq b">Fib</code>的递归调用都分配了一个额外的调用栈。总的来说，我敢打赌，随着内存变得越来越便宜，时间复杂度通常比空间复杂度优先。除非您在特定的限制或约束下编码(比如在嵌入式或物联网设备上)，否则速度通常是限制因素。</p><p id="2537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个算法的精确复杂度可能是类似于<em class="na"> O(3n) </em>的东西，但是像这个例子中的3这样的常数通常被排除在外，因为所有这些的重点更多的是对一个算法的复杂度进行分类<strong class="lb iu"> </strong>而不是定义它的精确运行时间。另一件要注意的事情是，恒定的时间或空间复杂度(即复杂度不随输入大小而变化)被表示为<em class="na"> O(1) </em>。这方面的一个例子是数组查找。不管数组有多少个元素，访问它的第一个、第二个或第100个元素只需要一个(高级)步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/57e4776025b08256ab83710aafbaf082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JGXdEj9HTa_KNenPzckFQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你好，我是尼克🍌打开<a class="ae ky" href="https://unsplash.com/s/photos/sonic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">防溅</a>。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d3f9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">得快点</h1><p id="a69c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有多种方法可以解决上述功能的性能问题。一种以额外内存为代价降低时间复杂度的流行方法是一种叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>的技术。这通过存储(即记忆)先前计算的数字来节省时间，就像人类写下他们计算的数字一样。在我们的Fibonacci函数的情况下，我们可以在地图中跟踪<code class="fe nz oa ob nq b">Fib</code>结果，并且只计算一个新的结果，如果它不在地图中的话。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="44ff" class="nu me it nq b gy nv nw l nx ny">Map memory = new HashMap&lt;int, int&gt;();<br/>memory[0] = 0;<br/>memory[1] = 1;</span><span id="97a1" class="nu me it nq b gy od nw l nx ny">FibMem(int i) {<br/>  int result = memory[i];<br/>  if (result == null) {<br/>    result = FibMem(i-1) + FibMem(i-2);<br/>  }<br/>  return result;<br/>}</span></pre><p id="2efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用非常少量的附加代码，我们实现了<em class="na"> O(n) </em>的时间复杂度。计算第N个斐波那契数现在需要<em class="na"> N </em>步，而不是<em class="na"> N </em>步。代价是我们现在使用了更多的内存。</p><p id="f081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个隐含的权衡是，这个函数可能比上一个函数更复杂。过早的优化是万恶之源——俗话说得好。在分析计算复杂性时，我们永远不应该忘记人的因素。性能<strong class="lb iu"> </strong>和可读性<strong class="lb iu"> </strong>之间的权衡并不容易，但这超出了本文的范围。</p><p id="fb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更进一步，将空间复杂度降低到O(n) 。为此，我们不使用递归，而是使用一个简单的for循环和一些局部变量。因为我们只更新局部变量，不进行递归调用，所以内存消耗保持不变。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2bc6" class="nu me it nq b gy nv nw l nx ny">FibOptimized(int i) {<br/>  if (i &lt; 2) return index;</span><span id="3cc4" class="nu me it nq b gy od nw l nx ny">  int a = 0;<br/>  int b = 1;<br/>  for (int j = 0; j &lt; i; j++) {<br/>    int temp = b;<br/>    b = a;<br/>    a = a + temp;<br/>  }<br/>  return a;<br/>}</span></pre><p id="a167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了:一个时间复杂度为O(n) 和空间复杂度为O(1)<em class="na">的Fibonacci实现。我还想再一次指出，在我看来，这比简单的斐波那契实现可读性差得多。有一些实现可以进一步降低时间复杂度，是的，这些实现确实变得更加复杂。</em></p><p id="5831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为练习，我将留给你以下问题:给定一个整数数组<code class="fe nz oa ob nq b">[a, b, c, …]</code>，写一个时间复杂度为<em class="na"> O(n) </em>的函数返回一个数组<code class="fe nz oa ob nq b">[b*c*…, a*c*…, a*b*…]</code>，使得输出数组的每个元素都是输入数组的所有元素的乘积，除了具有当前索引的元素。例如，输入<code class="fe nz oa ob nq b">[1, 2, 3, 4]</code>将产生输出<code class="fe nz oa ob nq b">[24, 12, 8, 6]</code>(即<code class="fe nz oa ob nq b">[2*3*4, 1*3*4, 1*2*4, 1*2*3]</code>)。一个<em class="na"> O(n ) </em>解决方案相当简单，但是一个<em class="na"> O(n) </em>解决方案也可以实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0870c5486b96385dcb37a5cd2d78dec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24PgqXVajYVeEgpiPffnbQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae ky" href="https://unsplash.com/s/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0012" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">超越大O</h1><p id="db26" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">计算复杂性是一个广阔的领域，要学的东西比这里强调的众所周知的冰山一角要多得多。你可能想查的东西有<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态规划</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员</a>问题、<a class="ae ky" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分而治之</a>方法、<a class="ae ky" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪算法</a>设计和其他<a class="ae ky" href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" rel="noopener ugc nofollow" target="_blank">启发式</a>以及<a class="ae ky" href="https://en.wikipedia.org/wiki/P_versus_NP_problem" rel="noopener ugc nofollow" target="_blank"> P对NP </a>问题。其中一些可能在本质上比其他的更学术，你可能永远不会被要求为你工作中的代码写一个正式的证明，但是所有这些对于算法优化和计算机科学整体来说都是非常重要的。</p></div></div>    
</body>
</html>