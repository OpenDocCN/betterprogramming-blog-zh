<html>
<head>
<title>I Forked “Asyncpg” — And It Parses Database Records to Numpy 20x Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我使用了“Asyncpg”——它将数据库记录解析为Numpy的速度提高了20倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-forked-asyncpg-and-it-parses-database-records-to-numpy-20x-faster-e71024a84bff?source=collection_archive---------4-----------------------#2022-06-02">https://betterprogramming.pub/i-forked-asyncpg-and-it-parses-database-records-to-numpy-20x-faster-e71024a84bff?source=collection_archive---------4-----------------------#2022-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于NumPy结构化数组展示asyncpg的分支Python的异步PostgreSQL客户端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b83bfb36a7decf5c0443899151bc97db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nXxO71PQ_ELrQ7tj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1aaa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简单地</h1><p id="943d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我入侵了asyncio PostgreSQL客户端库<code class="fe mn mo mp mq b">asyncpg</code>,将来自底层PostgreSQL协议的<code class="fe mn mo mp mq b">SELECT</code>ed记录直接解析到<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.rec.html" rel="noopener ugc nofollow" target="_blank"> NumPy结构化数组</a>,无需具体化Python对象，避免了大部分开销。</p><p id="d701" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">它的工作速度比墙壁快3倍，CPU快20倍；它不施法加速数据库服务器。star的存储库是<a class="ae ky" href="https://github.com/athenianco/asyncpg-rkt" rel="noopener ugc nofollow" target="_blank">athensco/asyncpg-rkt</a>。</p><h1 id="21e0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么我做了一把叉子</h1><p id="44e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://datastation.multiprocess.io/blog/2022-02-08-the-world-of-postgresql-wire-compatibility.html" rel="noopener ugc nofollow" target="_blank">越来越多的新兴数据库选择使用PostgreSQL wire协议，</a>比如蟑螂或者板条箱。假设这很简单，Python 中的<a class="ae ky" href="https://gist.github.com/eatonphil/079f8654174b9b9c1953b76008d024ae" rel="noopener ugc nofollow" target="_blank"> PoC facade服务器不到200行。如此庞大的兼容数据库家族暗示了一个高效的Python客户端库。分析优先的客户端库。</a></p><p id="0324" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在我之前的一篇博客文章中，我注意到从PostgreSQL响应到pandas DataFrame的转换是多么的低效。让我提醒你代码:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="922e" class="na la it mq b gy nb nc l nd ne">pd.DataFrame.from_records(await connection.fetch("SELECT ..."))</span></pre><p id="f4f8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们在下面做了许多多余的动作:</p><ol class=""><li id="a94c" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nk nl nm nn bi translated">解析PostgreSQL网络协议并创建Python对象。</li><li id="b611" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">将这些Python对象插入到创建的<code class="fe mn mo mp mq b">asyncpg.Record</code>中</li><li id="0b2d" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">迭代行并将Python对象插入到<code class="fe mn mo mp mq b">object</code> dtype的NumPy数组中。</li><li id="113d" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">推断更好的数据类型，如int64、datetime64等。，并转换Python对象。</li><li id="e4b0" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">构建数据框架。</li></ol><p id="dccb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但是，我们事先知道返回列的数据类型，可以做得更好:</p><ol class=""><li id="661e" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nk nl nm nn bi translated">将PostgreSQL网络协议解析为类型化的NumPy数组。</li><li id="adf0" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">构建数据框架。</li></ol><p id="3819" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">分析表明，在具体化数百万个Python对象时存在明显的瓶颈，只是为了将它们转换回与PostgreSQL服务器发送的完全相同的内存中表示形式，而忽略了字节序。在Pandas中，每当我们复制一个对象数组时，我们都会增加和减少每个对象的引用计数器，这就为性能棺材钉上了最后一颗钉子。</p><p id="b58d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">不幸的是，asyncpg中负责构建返回的<code class="fe mn mo mp mq b">asyncpg.Record</code> -s数组的部分是用Cython编写的，不容易定制。我不得不叉。</p><p id="d77d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我考虑了以下要求:</p><ul class=""><li id="ff4b" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nt nl nm nn bi translated">肯定是顺路替换。不要破坏现有的用户代码。</li><li id="3733" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">适度降级:当列类型是对象(例如JSON)时，回退到Python对象。</li><li id="8d2d" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">处理好空值。并非所有内置的NumPy dtypes都支持类似null的值，比如NaN或NaT，所以我们必须返回null的位置。</li><li id="1077" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">除了NumPy没有额外的依赖。</li><li id="5675" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">我能安排的最好的演出。</li></ul><h2 id="ffb3" class="na la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">如何利用新的超级大国</h2><p id="899d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">照常安装asyncpg:<code class="fe mn mo mp mq b">python -m pip install asyncpg-rkt</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bead" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们调用<code class="fe mn mo mp mq b">set_query_dtype()</code>来用结果数据类型描述增加查询字符串。数据类型必须是<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.rec.html" rel="noopener ugc nofollow" target="_blank">结构化的</a>。返回的数组的用法和原来的<code class="fe mn mo mp mq b">asyncpg.Record</code> -s的列表没有太大的区别:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a06c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">nulls</code>是<code class="fe mn mo mp mq b">arr</code>中的平面索引，我们在这里获取空值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4af8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">获取常规查询的工作方式与在原始库中相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f7e5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">此外，asyncpg-提供了一种专为熊猫定制的替代“块”输出模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8489" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">返回的数组是一个类似1D对象数组的数组，其中每个元素是一个包含值的列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8eb3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">项目的预期使用案例和限制:</p><ul class=""><li id="ceb9" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nt nl nm nn bi translated">用户应该关心性能。在大多数情况下，潜在的加速并不是翻天覆地的，所以这可能不值得争论。</li><li id="8813" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">SELECT</code>至少十排。否则，好处微乎其微。</li><li id="88b6" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">用户预先知道返回字段的类型。任何数据建模都会派上用场，例如SQLAlchemy。</li><li id="accc" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">那些类型主要是原语，映射到NumPy:整数，浮点，时间戳，<code class="fe mn mo mp mq b">bytea</code>，<code class="fe mn mo mp mq b">text</code>，<code class="fe mn mo mp mq b">uuid</code>，固定大小的几何。</li><li id="65e4" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">用户知道返回字节和字符串的最大长度，以指定足够的<code class="fe mn mo mp mq b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bytes_" rel="noopener ugc nofollow" target="_blank">S#</a></code> <a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bytes_" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe mn mo mp mq b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bytes_" rel="noopener ugc nofollow" target="_blank">U#</a></code> <a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bytes_" rel="noopener ugc nofollow" target="_blank">类型</a>。否则，有可能回退到对象，但性能会下降。</li><li id="12d1" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">要么直接使用asyncpg，要么通过像<a class="ae ky" href="https://github.com/athenianco/morcilla" rel="noopener ugc nofollow" target="_blank"> morcilla </a>这样的薄包装器。Async SQLAlchemy 1.4和encode/databases将会崩溃，因为我们返回一个带有NumPy数组和空索引的元组，而不是一个单个的<code class="fe mn mo mp mq b">Record</code>列表；即使这些库幸存下来，它们也会将结果重新打包到类似记录的Python对象中，并且会忽略这一点。</li><li id="84a6" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">结果转换为熊猫数据帧应该会飞。</li><li id="da85" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">不要期待魔法！这种分叉不会加速数据库服务器。</li></ul><h1 id="3bd4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基准</h1><p id="2a7a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我比较了四种不同执行模式的性能:</p><ol class=""><li id="b9e5" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nk nl nm nn bi translated"><code class="fe mn mo mp mq b">min</code> —正在执行<code class="fe mn mo mp mq b">SELECT 1</code>。该模式设置绝对最小查询执行时间。</li><li id="79cc" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe mn mo mp mq b">dummy</code> —我们从PostgreSQL中读取数据，然后立即删除它。客户端不做任何实际工作，<code class="fe mn mo mp mq b">fetch()</code>总是返回<code class="fe mn mo mp mq b">None</code>。这种模式近似于服务器处理时间以及客户端-服务器通信时间。它是理想的，不可及的目标。</li><li id="4651" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe mn mo mp mq b">record</code> —遗留查询执行，我们照常返回<code class="fe mn mo mp mq b">asyncpg.Record</code>对象的列表。</li><li id="c4bb" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe mn mo mp mq b">numpy</code> —模式。我们返回结构化的NumPy数组和空索引列表。</li></ol><p id="e927" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我的Postgres服务器在本地运行，我连接到了<code class="fe mn mo mp mq b">localhost:5432</code>。该查询是:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="0940" class="na la it mq b gy nb nc l nd ne">SELECT ... FROM generate_series(1, {length})</span></pre><ul class=""><li id="fb3e" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nt nl nm nn bi translated">其中<code class="fe mn mo mp mq b">length</code>是要返回的相同行数</li><li id="7a82" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">...</code>是硬编码的两个布尔值(五个bigints，一个float4，四个时间戳，两个times，两个长度为16的bytea-s，两个长度为5和10的texts)</li></ul><p id="a8f8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我测了从100到50000的各种<code class="fe mn mo mp mq b">length</code>。基准测试大量使用了优秀的<a class="ae ky" href="https://pytest-benchmark.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">py test-benchmark</a>py test插件。我确保了一些预热迭代来正确引导准备好的语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择基准的Tukey直方图，越小越好。“dummy”是丢弃的服务器响应，“record”是返回原始asyncpg中的记录，“numpy”是在async pg-rkt中动态转换为NumPy结构化数组。底部的数字是提取的行数。图片作者。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择基准的Tukey直方图，越小越好。“dummy”是丢弃的服务器响应，“record”是返回原始asyncpg中的记录，“numpy”是在async pg-rkt中动态转换为NumPy结构化数组。底部的数字是提取的行数。图片作者。</p></figure><p id="2c62" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">“numpy”模式下的端到端查询执行速度比“record”模式快3倍如果我们减去不可变的“虚拟”时间，纯CPU时间加速达到22倍。“numpy”执行时间的标准差与“dummy”相同，而“record”跳得高得多。我们在50k行上赢了大约120ms，波动最剧烈的时候赢了250ms。</p><p id="c523" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当然，实际的加速比不到3倍，因为任何实际的查询都要在PostgreSQL服务器上花费更多的时间。我不卖蛇油。不过，绝对增量应该保持不变。</p><p id="71d2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面是用于比较的<code class="fe mn mo mp mq b"><a class="ae ky" href="https://www.benfrederickson.com/profiling-native-python-extensions-with-py-spy/" rel="noopener ugc nofollow" target="_blank">py-spy --native</a></code>配置文件。第一个是“记录”，第二个是“数字”。概要文件显示，将pgproto解析为Python的<code class="fe mn mo mp mq b">datetime</code>是一个严重的瓶颈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ea5e52f930d3414fe4eef4a986db5d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBNsAWrQz2elRWsuLGiNjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">10k行的“记录”模式配置文件。我们可以看到日期时间操作中的一个主要瓶颈。其他领域也很慢。“相同时间”指向在每种模式下经过恒定时间的网络入口。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/3d1234a3d63b282bfe19a67a0630687b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8lzuXU3NcpmleKxWvJZ3Rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">10k行的“numpy”模式配置文件。轮廓是统一的，就像它应该的那样。“相同时间”现在更广了:CPU时间减少了很多。图片作者。</p></figure><p id="4a7c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">基准测试的源代码在<a class="ae ky" href="https://github.com/athenianco/asyncpg-rkt/blob/master/tests/test_numpy_benchmark.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><h1 id="fd81" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">血淋淋的实现细节</h1><p id="c49f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">“查询增强”的工作方式是在pickled dtype前面加上前缀。原生asyncpg中的后端代码会取消回拨。这不如直接传递引用有效，但我不想改变任何公共接口，即使是向后兼容的。如果asyncpg通过包装器库被调用，没有人会急于转发经过那里的引用。</p><p id="c620" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">代价是一些反序列化开销。给定预期的平均提取行数，它应该可以忽略不计。</p><p id="61bf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">原来的Cython代码已经相当快了。它教会了我一些使用扩展类的聪明技巧，比如预分配— <code class="fe mn mo mp mq b"><a class="ae ky" href="https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation" rel="noopener ugc nofollow" target="_blank">@cython.freelist</a></code>或禁用垃圾收集— <code class="fe mn mo mp mq b"><a class="ae ky" href="https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#disabling-cycle-breaking-tp-clear" rel="noopener ugc nofollow" target="_blank">@cython.no_gc</a></code>。我发现只有一个地方需要改进:应该直接内联<code class="fe mn mo mp mq b">frb_check()</code>缓冲区溢出检查，而不是希望Cython做“正确的事情”</p><p id="2d35" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">速度变慢是Cython的异常转发诡计的结果。纯Python版本在某些地方有些扭曲。每次我不得不在asyncpg中跟踪查询流时，我都会笑。连接并通过:</p><ul class=""><li id="65f5" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">execute()</code></li><li id="1e99" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">_execute()</code></li><li id="4222" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">__execute()</code></li><li id="2a89" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">_do_execute()</code></li><li id="4829" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated"><code class="fe mn mo mp mq b">executor()</code></li></ul><p id="7bde" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">async pg——依赖NumPy的<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.rec.html" rel="noopener ugc nofollow" target="_blank">结构化数组</a>。它们是具有可选排列的固定形状的C结构。NumPy通过索引和名称公开结构字段。在内部，NumPy保存了到嵌套的dtypes和offsets的普通列表和字典映射。</p><p id="75e5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">PostgreSQL将行流式传输到客户端，在获取所有行之前，我们不知道将获取多少行。动态调整NumPy数组的大小是不可能的，类似于将<code class="fe mn mo mp mq b">Record</code> -s追加到一个列表中，因此我们必须分配页面对齐的大小相等的块，并在最后将它们连接起来。</p><p id="3d71" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">不幸的是，这些额外的分配导致了内存消耗的双峰和从块到最终目的地的大量<code class="fe mn mo mp mq b">memcpy()</code>。</p><p id="1d18" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">PostgreSQL以微秒级精度的64位整数形式发送时间戳和时间增量。NumPy允许datetime64和timedelta64中的各种单位，例如，天、秒、纳秒。</p><p id="a2fb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，我们必须通过整数乘法或除法进行单位转换。分析表明整数除法太慢。当然，这不是什么新鲜事。幸运的是，有一个从Doom的快速反平方根系列和C头专用<a class="ae ky" href="https://github.com/ridiculousfish/libdivide" rel="noopener ugc nofollow" target="_blank"> libdivide </a>捆绑在一起的技巧是numpy≥1.21。</p><p id="ee42" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我把<code class="fe mn mo mp mq b">numpy/libdivide/libdivide.h</code>包在Cython里，它就像一个“神奇”的符咒。另一个关键步骤是调整零点，也就是纪元。PostgreSQL的零是2000–01–01，NumPy的零是1970–01–01，所以我们必须给每个值加上30年。</p><p id="e7e4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">PostgreSQL在UTF-8中发送字符串。另一方面，我想NumPy希望UCS-4更容易矢量化。我们必须重新编码。CPython导出相关函数，但它们都需要Python字符串或字节对象，这会降低性能。</p><p id="4b49" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我改编了MIT授权的<a class="ae ky" href="https://github.com/freedesktop/fontconfig/blob/6f27f42e6140030715075aa3bd3e5cc9e2fdc6f1/src/fcstr.c#L626" rel="noopener ugc nofollow" target="_blank"> fontconfig </a>的实现:FcUtf8ToUcs4。它工作得相当快；算法很简单。fork有一个选项可以将字符串直接复制到<code class="fe mn mo mp mq b">S#</code>dtype——非常适合ASCII限制的文本。</p><p id="8fa3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我不得不用nulls来解决这个问题。我们必须在不牺牲性能的情况下支持他们。每次遇到空值时，我们将平面索引追加到一个列表中，并向数组块中写入一个NaN代理。</p><ul class=""><li id="47f5" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nt nl nm nn bi translated">对于float32和float64，这是一个真正的NaN。</li><li id="ad4a" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">对于datetime64和timedelta64，这是一个行为类似的NaT。</li><li id="ef2e" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">对于物体，我们写<code class="fe mn mo mp mq b">None</code>。</li><li id="5724" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">对于整数，我们写出给定位数的最小值。</li><li id="18d2" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">对于<code class="fe mn mo mp mq b">S#</code>，我们用<code class="fe mn mo mp mq b">0xFF</code>来填充。</li><li id="4707" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nt nl nm nn bi translated">对于<code class="fe mn mo mp mq b">U#</code>，我们用<code class="fe mn mo mp mq b">0x00</code>填充。</li></ul><p id="6209" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">显然，提到的任何值都可能是合法的，因此唯一有保证的null检查是扫描返回的null索引。</p><p id="3e06" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果用户设置了错误的数据类型，会发生什么？他们应该捕捉一个有用的异常:</p><blockquote class="oj ok ol"><p id="e9d9" class="lr ls om lt b lu mr ju lw lx ms jx lz on mt mc md oo mu mg mh op mv mk ml mm im bi translated">asyncpg . pg proto . pg proto . dtype error:dtype[10]=<u20 does="" not="" match="" postgresql="" text="" of="" size=""/></p></blockquote><p id="1b3f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">Staying on the type topic, I am using an <a class="ae ky" href="https://numpy.org/doc/stable/reference/arrays.dtypes.html#specifying-and-constructing-data-types" rel="noopener ugc nofollow" target="_blank">未记录的<code class="fe mn mo mp mq b">np.dtype</code>的</a>构造函数参数，用于指定列输出模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ddc8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">每个dtype都带有一个元数据属性，该属性是在构造时设置的<code class="fe mn mo mp mq b">None</code>或只读(<code class="fe mn mo mp mq b">mappingproxy</code>)字典。</p><p id="cfdb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">关于列输出，asyncpg将相同数据类型的列组合在一起，并以块为单位分配内存，这让人想起Pandas的做法(以前是这样做的？)它。面向用户的阵列是数据块<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.copies.html#view" rel="noopener ugc nofollow" target="_blank">视图</a>。块原点被列数组的<code class="fe mn mo mp mq b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.base.html" rel="noopener ugc nofollow" target="_blank">base</a></code> <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.base.html" rel="noopener ugc nofollow" target="_blank">属性</a>引用。</p><h1 id="c990" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">你考虑过合并回asyncpg吗？</h1><p id="4035" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这需要相当多的额外努力。没有NumPy，Cython代码编译当前中断。有可能使NumPy成为一个可选的依赖项。如果社区要求合并，并且asyncpg的维护者是仁慈的，那么好吧，让我们开始吧。</p><h1 id="9ad0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="7b2e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我描述了async pg-——async pg的向后兼容分支，这是PostgreSQL的Python asyncio客户端。</p><p id="2142" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">asyncpg——将从低级PostgreSQL协议中选择的记录直接解析到<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.rec.html" rel="noopener ugc nofollow" target="_blank"> NumPy结构化数组</a>中，无需具体化Python对象，从而避免了大量开销。它比墙壁快3倍，CPU快20倍。存储库是<a class="ae ky" href="https://github.com/athenianco/asyncpg-rkt" rel="noopener ugc nofollow" target="_blank">雅典人/asyncpg-rkt </a>。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="c06b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><em class="om">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>