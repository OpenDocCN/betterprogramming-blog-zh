<html>
<head>
<title>How to Create a Figma-like Infinite Canvas in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中创建类似Figma的无限画布</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-figma-like-infinite-canvas-in-react-a2b0365b2a7?source=collection_archive---------4-----------------------#2022-11-23">https://betterprogramming.pub/how-to-create-a-figma-like-infinite-canvas-in-react-a2b0365b2a7?source=collection_archive---------4-----------------------#2022-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c5b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为用户创造无限的体验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/325b4f49898eb08ab49f816d9b16f403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XqIQld-OZZA-_HpC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">网页是你的画布。你要做什么？</p></figure><p id="ca78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最近写了关于如何在WebGL 中构建无限画布的文章，但是当我开始在无限画布上构建更多想法时，我意识到HTML对于原型制作来说是多么简单。所以我想我应该合并两者，在React中构建一个无限画布。这允许我利用浏览器提供的所有好处，这些好处必须为WebGL重写:拖放、文本、iFrames等。</p><p id="f8cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于那些没有阅读过其他文章的人，我建议你至少阅读一下基础部分，尽管阅读全部内容会帮助你理解我在这里使用的代码。在前一篇文章中，我提到了如何在任何框架中实现这种逻辑，我是认真的。我还将展示在React中实现会是什么样子。</p><p id="36d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我已经做了一个代码沙箱，所以你可以查看整个代码并玩它<a class="ae lr" href="https://codesandbox.io/s/infinite-canvas-react-nhfbb0?file=/src/index.tsx" rel="noopener ugc nofollow" target="_blank">这里</a></p><h2 id="d748" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">即时模式渲染</h2><p id="4ca4" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在我们开始实现之前，让我给你介绍一个计算机图形学中的概念，叫做即时模式渲染。这对于它带来的性能优势是必要的。</p><blockquote class="mq"><p id="8a70" class="mr ms iq bd mt mu mv mw mx my mz lq dk translated">在即时模式下，场景(渲染图元的完整对象模型)保留在客户端的内存空间中，而不是图形库中。这意味着在即时模式应用中，要呈现的图形对象的列表由客户端保存，而不是由图形库API保存。</p></blockquote><p id="ab98" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">在React-land中，这意味着我们不依赖React来呈现整个应用程序。React通常会保留整个树，并在状态改变时重新渲染树的各个部分。但是你能想象这对一个无限的画布会有什么影响吗？React跟踪无限中的每个组件，查看并运行每个组件的钩子，并放置它们？退一步说，这将是非常低效的。</p><p id="ae8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们将控制并告诉React渲染什么。我们将保持一个60fps的循环，并告诉React渲染哪些组件以及在哪里渲染它们。我们将隐藏画布外部的任何组件，因此React必须进行足够的渲染来显示内部的元素。它甚至不知道画布之外的元素。</p><p id="a51a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何在React中做到这一点？我们编写了一个定制的钩子，在每一个<code class="fe nf ng nh ni b">RequestAnimationFrame</code>运行一个循环</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="c139" class="nn lt iq ni b be no np l nq nr">import CanvasStore from "modules/state/CanvasStore";<br/>import { useEffect, useRef, useState } from "react";<br/><br/>class RenderLoop {<br/>  private lastFrameTime: number = 0;<br/>  private lastRequestId: number | null = null;<br/>  constructor(private fps: number = 0, private draw: () =&gt; void) {}<br/><br/>  initialize(fps: number) {<br/>    this.fps = fps;<br/>  }<br/><br/>  start() {<br/>    this.lastFrameTime = performance.now();<br/>    this.loop();<br/>  }<br/><br/>  stop() {<br/>    if (this.lastRequestId) cancelAnimationFrame(this.lastRequestId);<br/>    this.lastRequestId = null;<br/>  }<br/><br/>  private get fpsInterval() {<br/>    return 1000 / this.fps;<br/>  }<br/><br/>  private loop() {<br/>    this.lastRequestId = requestAnimationFrame(() =&gt; this.loop());<br/>    const now = performance.now();<br/>    const elapsed = now - this.lastFrameTime;<br/>    if (elapsed &gt; this.fpsInterval) {<br/>      this.lastFrameTime = now - (elapsed % this.fpsInterval);<br/>      this.draw();<br/>    }<br/>  }<br/>}<br/><br/>let renderLoop: RenderLoop;<br/>export function getRenderLoop(fps = 15, draw: () =&gt; void) {<br/>  if (!renderLoop) return new RenderLoop(fps, draw);<br/>  else return renderLoop;<br/>}<br/><br/>export const useRenderLoop = (fps: number = 15) =&gt; {<br/>  const [frame, setFrame] = useState("0");<br/>  const loop = useRef&lt;RenderLoop&gt;(<br/>    getRenderLoop(fps, () =&gt; {<br/>      if (CanvasStore.shouldRender) {<br/>        setFrame(`${performance.now()}`);<br/>        CanvasStore.shouldRender = false;<br/>      }<br/>    })<br/>  );<br/><br/>  useEffect(() =&gt; {<br/>    CanvasStore.shouldRender = true;<br/>    loop.current.start();<br/><br/>    return () =&gt; loop.current.stop();<br/>  }, []);<br/>  return frame;<br/>};<br/><br/>export default useRenderLoop;</span></pre><p id="b4f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其工作方式是，当应用程序启动时，我们启动一个RenderLoop，它一直调用<code class="fe nf ng nh ni b">requestAnimationFrame</code>，并根据<code class="fe nf ng nh ni b">fps</code>触发draw函数，该函数基于当前时间设置一个帧字符串。每当这个值改变时，状态也会改变，所以我们的根组件会每秒每隔<code class="fe nf ng nh ni b">fps</code>帧重新渲染一次。</p><h2 id="5e32" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">履行</h2><p id="d965" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">既然我们已经在前面的章节中介绍了React的使用方法，并在前面的<a class="ae lr" href="https://medium.com/better-programming/how-to-create-a-figma-like-infinite-canvas-in-webgl-8be94f65674f" rel="noopener">博客文章</a>中介绍了投影的基础，我们就可以开始实施了。我们可以像上次一样保持我们的预期输出，即创建9个大块来测试以下内容</p><ul class=""><li id="3c5b" class="ns nt iq kx b ky kz lb lc le nu li nv lm nw lq nx ny nz oa bi translated">放大和缩小画布并查看更多块</li><li id="f6e2" class="ns nt iq kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated">移动相机，看到不同的街区</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/2f757bf807c469f258d69336cb4ca777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2I8aLs5sR2_BaACI7pTCvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们计划的预期产出。它是一个由许多颜色组成的网格，每个块上都有文字</p></figure><p id="c959" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从如何放置最基本的元素开始。我们需要一个组件，可以在画布上放置任何具有全局坐标的元素。</p><p id="9fce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它获取可见的屏幕(由我们的<code class="fe nf ng nh ni b">CanvasStore</code>维护，稍后介绍)，并根据我们的屏幕对其进行局部定位。因此，给定我们的屏幕+全局坐标，该组件将其转换为局部坐标，并将其放置在屏幕上。</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="e7ab" class="nn lt iq ni b be no np l nq nr">import CanvasStore from "modules/state/CanvasStore";<br/>import { PropsWithChildren } from "react";<br/>import { inBounds } from "./math-utils";<br/><br/>export interface CanvasPosition {<br/>  top: number;<br/>  left: number;<br/>  width: number;<br/>  height: number;<br/>}<br/><br/>export const Position = ({<br/>  left,<br/>  top,<br/>  width,<br/>  height,<br/>  children,<br/>}: PropsWithChildren&lt;CanvasPosition&gt;) =&gt; {<br/>  const screen = CanvasStore.screen;<br/>  if (<br/>    inBounds(<br/>      { left, top, height, width },<br/>      {<br/>        left: screen.x,<br/>        top: screen.y,<br/>        width: screen.width,<br/>        height: screen.height,<br/>      }<br/>    )<br/>  ) {<br/>    return (<br/>      &lt;div<br/>        className="absolute inline-block"<br/>        style={{<br/>          left: `${left - screen.x}px`,<br/>          top: `${top - screen.y}px`,<br/>        }}<br/>      &gt;<br/>        {children}<br/>      &lt;/div&gt;<br/>    );<br/>  } else return null;<br/>};</span></pre><p id="90ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还没有实现<code class="fe nf ng nh ni b">inBounds</code>功能。这将检查带有全局坐标的矩形在画布中是否可见。重叠逻辑在<a class="ae lr" href="https://stackoverflow.com/a/306332" rel="noopener ugc nofollow" target="_blank">该堆栈溢出回答</a>中有详细解释。</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="246e" class="nn lt iq ni b be no np l nq nr">// math-utils.ts<br/>export const radians = (angle: number) =&gt; {<br/>  return angle * (Math.PI / 180);<br/>};<br/><br/>interface Rect {<br/>  left: number;<br/>  top: number;<br/>  width: number;<br/>  height: number;<br/>}<br/><br/>export const inBounds = (rect1: Rect, rect2: Rect) =&gt; {<br/>  if (<br/>    rect1.left &lt; rect2.left + rect2.width &amp;&amp;<br/>    rect1.left + rect1.width &gt; rect2.left &amp;&amp;<br/>    rect1.top &lt; rect2.top + rect2.height &amp;&amp;<br/>    rect1.top + rect1.height &gt; rect2.top<br/>  )<br/>    return true;<br/>  else return false;<br/>};</span></pre><p id="5daf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们知道了如何在画布上放置元素，我们可以构建我们的<code class="fe nf ng nh ni b">InfiniteCanvas</code>组件并放置9个包含文本元素的大块</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="59a2" class="nn lt iq ni b be no np l nq nr">import { RECT_H, RECT_W } from "modules/core/constants";<br/>import { CanvasPosition, Position } from "modules/core/foundation";<br/>import CanvasStore from "modules/state/CanvasStore";<br/>import { memo } from "react";<br/><br/>interface TextBlockProps extends CanvasPosition {<br/>  text: string;<br/>  color: string;<br/>  width: number;<br/>  height: number;<br/>}<br/><br/>const TextBlock = ({<br/>  text,<br/>  color,<br/>  left,<br/>  top,<br/>  width,<br/>  height,<br/>}: TextBlockProps) =&gt; {<br/>  return (<br/>    &lt;Position left={left} top={top} width={width} height={height}&gt;<br/>      &lt;div<br/>        className="flex items-center justify-center"<br/>        style={{<br/>          width: `${width}px`,<br/>          height: `${height}px`,<br/>          background: color,<br/>        }}<br/>      &gt;<br/>        {text}<br/>      &lt;/div&gt;<br/>    &lt;/Position&gt;<br/>  );<br/>};<br/><br/>const InfiniteCanvas = ({ frame }: { frame: string }) =&gt; {<br/>  const texts = [<br/>    "Infinite",<br/>    "Canvases",<br/>    "Are",<br/>    "Easy",<br/>    "When",<br/>    "You",<br/>    "Know",<br/>    "The",<br/>    "Fundamentals",<br/>  ];<br/><br/>  const colors = [<br/>    "#f1f7ed",<br/>    "#61c9a8",<br/>    "#7ca982",<br/>    "#e0eec6",<br/>    "#c2a83e",<br/>    "#ff99c8",<br/>    "#fcf6bd",<br/>    "#9c92a3",<br/>    "#c6b9cd",<br/>  ];<br/>  const rectW = RECT_W;<br/>  const rectH = RECT_H;<br/>  const scale = CanvasStore.scale;<br/><br/>  return (<br/>    &lt;div<br/>      className="w-full h-full"<br/>      style={{<br/>        transform: `scale(${(scale.x, scale.y)})`,<br/>        transformOrigin: "top left",<br/>      }}<br/>    &gt;<br/>      {texts.map((text, index) =&gt; (<br/>        &lt;TextBlock<br/>          key={index}<br/>          text={text}<br/>          color={colors[index]}<br/>          left={(index % 3) * rectW}<br/>          top={Math.floor(index / 3) * rectH}<br/>          width={rectW}<br/>          height={rectH}<br/>        /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default memo(InfiniteCanvas);</span></pre><p id="3c34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们应该通过构建我们的<code class="fe nf ng nh ni b">CanvasRoot</code>并将它添加到我们的<code class="fe nf ng nh ni b">ReactDOM</code>来将它合并到我们的UI中:</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="8aec" class="nn lt iq ni b be no np l nq nr">import CanvasStore from "modules/state/CanvasStore";<br/>import { PointerEvent, useEffect, useRef, WheelEvent } from "react";<br/>import useSize from "@react-hook/size";<br/>import InfiniteCanvas from "./InfiniteCanvas";<br/>import useRenderLoop from "modules/core/RenderLoop";<br/><br/>const wheelListener = (e: WheelEvent) =&gt; {<br/>  const friction = 1;<br/>  const event = e as WheelEvent;<br/>  const deltaX = event.deltaX * friction;<br/>  const deltaY = event.deltaY * friction;<br/>  if (!event.ctrlKey) {<br/>    CanvasStore.moveCamera(deltaX, deltaY);<br/>  } else {<br/>    CanvasStore.zoomCamera(deltaX, deltaY);<br/>  }<br/>};<br/><br/>const pointerListener = (event: PointerEvent) =&gt; {<br/>  CanvasStore.movePointer(event.clientX, event.clientY);<br/>};<br/><br/>const CanvasRoot = () =&gt; {<br/>  const canvas = useRef&lt;HTMLDivElement&gt;(null);<br/>  const [width, height] = useSize(canvas);<br/>  useEffect(() =&gt; {<br/>    if (width === 0 || height === 0) return;<br/>    CanvasStore.initialize(width, height);<br/>  }, [width, height]);<br/>  const frame = useRenderLoop(60);<br/>  return (<br/>    &lt;div className="w-full h-full"&gt;<br/>      &lt;div<br/>        className="w-full h-full relative overflow-hidden overscroll-none"<br/>        ref={canvas}<br/>        onWheel={wheelListener}<br/>        onPointerMove={pointerListener}<br/>      &gt;<br/>        &lt;InfiniteCanvas frame={frame}&gt;&lt;/InfiniteCanvas&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default CanvasRoot;</span></pre><p id="e23e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们初始化<code class="fe nf ng nh ni b">CanvasStore</code>并设置<code class="fe nf ng nh ni b">RenderLoop</code>，在这里简单地调用我们的<code class="fe nf ng nh ni b">InfiniteCanvas</code>。</p><p id="5933" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要将画布容器的宽度和高度传递给<code class="fe nf ng nh ni b">CanvasStore</code>，这是通过一个我们已经导入的钩子来完成的。现在唯一剩下的部分是<code class="fe nf ng nh ni b">CanvasStore</code>，它看起来像这样</p><pre class="kg kh ki kj gt nj ni nk bn nl nm bi"><span id="ab72" class="nn lt iq ni b be no np l nq nr">import {<br/>  cameraToScreenCoordinates,<br/>  scaleWithAnchorPoint,<br/>} from "../core/camera-utils";<br/>import { CAMERA_ANGLE, RECT_H, RECT_W } from "../core/constants";<br/>import { radians } from "../core/math-utils";<br/><br/>export interface CanvasState {<br/>  shouldRender: boolean;<br/>  pixelRatio: number; // our resolution for dip calculations<br/>  container: {<br/>    //holds information related to our screen container<br/>    width: number;<br/>    height: number;<br/>  };<br/>  pointer: {<br/>    x: number;<br/>    y: number;<br/>  };<br/>  camera: {<br/>    //holds camera state<br/>    x: number;<br/>    y: number;<br/>    z: number;<br/>  };<br/>}<br/>const getInitialCanvasState = (): CanvasState =&gt; {<br/>  return {<br/>    shouldRender: true,<br/>    pixelRatio: window.devicePixelRatio || 1,<br/>    container: {<br/>      width: 0,<br/>      height: 0,<br/>    },<br/>    pointer: {<br/>      x: 0,<br/>      y: 0,<br/>    },<br/>    camera: {<br/>      x: 0,<br/>      y: 0,<br/>      z: 0,<br/>    },<br/>  };<br/>};<br/><br/>let canvasData = getInitialCanvasState();<br/><br/>export default class CanvasStore {<br/>  private static get data() {<br/>    if (!canvasData)<br/>      canvasData = {<br/>        shouldRender: true,<br/>        pixelRatio: window.devicePixelRatio || 1,<br/>        container: {<br/>          width: 0,<br/>          height: 0,<br/>        },<br/>        pointer: {<br/>          x: 0,<br/>          y: 0,<br/>        },<br/>        camera: {<br/>          x: 0,<br/>          y: 0,<br/>          z: 0,<br/>        },<br/>      };<br/>    return canvasData;<br/>  }<br/><br/>  static initialize(width: number, height: number) {<br/>    const containerWidth = width;<br/>    const containerHeight = height;<br/>    canvasData = getInitialCanvasState();<br/>    canvasData.pixelRatio = window.devicePixelRatio || 1;<br/>    canvasData.container.width = containerWidth;<br/>    canvasData.container.height = containerHeight;<br/>    canvasData.camera.x = 1.5 * RECT_W;<br/>    canvasData.camera.y = 1.5 * RECT_H;<br/>    canvasData.camera.z = containerWidth / (2 * Math.tan(CAMERA_ANGLE));<br/>  }<br/>  public static get screen() {<br/>    const { x, y, z } = this.camera;<br/>    const aspect = this.aspect;<br/>    const angle = CAMERA_ANGLE;<br/>    return cameraToScreenCoordinates(x, y, z, angle, aspect);<br/>  }<br/>  public static get camera() {<br/>    return this.data.camera;<br/>  }<br/>  public static get scale() {<br/>    const { width: w, height: h } = CanvasStore.screen;<br/>    const { width: cw, height: ch } = CanvasStore.container;<br/>    return { x: cw / w, y: ch / h };<br/>  }<br/>  public static get shouldRender() {<br/>    return canvasData.shouldRender;<br/>  }<br/>  public static set shouldRender(value: boolean) {<br/>    canvasData.shouldRender = value;<br/>  }<br/><br/>  private static get container() {<br/>    return canvasData.container;<br/>  }<br/><br/>  private static get pointer() {<br/>    return canvasData.pointer;<br/>  }<br/><br/>  private static get aspect() {<br/>    return canvasData.container.width / canvasData.container.height;<br/>  }<br/><br/>  private static isCameraInBounds(<br/>    cameraX: number,<br/>    cameraY: number,<br/>    cameraZ: number<br/>  ) {<br/>    return true;<br/>  }<br/><br/>  public static moveCamera(mx: number, my: number) {<br/>    const scrollFactor = 1.5;<br/>    const deltaX = mx * scrollFactor,<br/>      deltaY = my * scrollFactor;<br/>    const { x, y, z } = this.camera;<br/>    if (this.isCameraInBounds(x + deltaX, y + deltaY, z)) {<br/>      this.data.camera.x += deltaX;<br/>      this.data.camera.y += deltaY;<br/>      // move pointer by the same amount<br/>      this.shouldRender = true;<br/>      this.movePointer(deltaY, deltaY);<br/>    }<br/>  }<br/><br/>  public static zoomCamera(deltaX: number, deltaY: number) {<br/>    // Normal zoom is quite slow, we want to scale the amount quite a bit<br/>    const zoomScaleFactor = 10;<br/>    const deltaAmount = zoomScaleFactor * Math.max(deltaY);<br/>    const { x: oldX, y: oldY, z: oldZ } = this.camera;<br/>    const oldScale = { ...this.scale };<br/><br/>    const { width: containerWidth, height: containerHeight } = this.container;<br/>    const { width, height } = cameraToScreenCoordinates(<br/>      oldX,<br/>      oldY,<br/>      oldZ + deltaAmount,<br/>      CAMERA_ANGLE,<br/>      this.aspect<br/>    );<br/>    const newScaleX = containerWidth / width;<br/>    const newScaleY = containerHeight / height;<br/>    const { x: newX, y: newY } = scaleWithAnchorPoint(<br/>      this.pointer.x,<br/>      this.pointer.y,<br/>      oldX,<br/>      oldY,<br/>      oldScale.x,<br/>      oldScale.y,<br/>      newScaleX,<br/>      newScaleY<br/>    );<br/>    const newZ = oldZ + deltaAmount;<br/>    this.shouldRender = true;<br/>    if (this.isCameraInBounds(oldX, oldY, newZ)) {<br/>      this.data.camera = {<br/>        x: newX,<br/>        y: newY,<br/>        z: newZ,<br/>      };<br/>    }<br/>  }<br/><br/>  // pointer position from top left of the screen<br/>  public static movePointer(deltaX: number, deltaY: number) {<br/>    const scale = this.scale;<br/>    const { x: left, y: top } = this.screen;<br/>    this.data.pointer.x = left + deltaX / scale.x;<br/>    this.data.pointer.y = top + deltaY / scale.y;<br/>  }<br/>}</span></pre><p id="21b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在之前的帖子中已经讨论过这个<code class="fe nf ng nh ni b">CanvasStore</code>背后的逻辑，所以如果你仍然困惑，我建议你去看看那篇帖子，以便更加清晰。唯一附加的部分是一个<code class="fe nf ng nh ni b">shouldRender</code>布尔的概念。</p><p id="59a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果什么都没有改变，我们不想在<code class="fe nf ng nh ni b">60fps</code>渲染整棵树。所以我们只在UI中出现新的东西时设置<code class="fe nf ng nh ni b">shouldRender</code>。这是一个优化，应该使我们的代码更具性能</p><p id="916c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们把所有东西放在一起的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8bd90936b95df982aceb976c2c466822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5kHAXOLchokhrbLekvpfFQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有滚动和收缩缩放功能的无限画布</p></figure><p id="6303" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你在许多工具和框架中学习并体验了更多的无限画布。我相信它们是你能给用户的最强有力的体验之一，这个概念给了我很多灵感。祝您旅途顺利，并继续打造美好的事物:)</p></div></div>    
</body>
</html>