<html>
<head>
<title>Architecting SaaS Applications With Auth0, .NET Core, and Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Auth0设计SaaS应用程序。NET Core和Postgres</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/architecting-saas-applications-with-auth0-net-core-and-postgres-562744ca7cbe?source=collection_archive---------2-----------------------#2021-11-30">https://betterprogramming.pub/architecting-saas-applications-with-auth0-net-core-and-postgres-562744ca7cbe?source=collection_archive---------2-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cdc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">考虑多租户的构建指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b14c95a9e1a08be3da1a97c8fb0dead9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cXFZqtHOawJnL8j0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kelvin1987?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelvin Ang </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Salesforce、Slack和Shopify的共同点是什么？</p><p id="0250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们都是建立在多租户SaaS软件基础上的一批非常成功且不断成长的公司的一部分。在我写这篇文章的时候，这三家上市公司的<a class="ae ky" href="https://www.investopedia.com/terms/m/marketcapitalization.asp" rel="noopener ugc nofollow" target="_blank">市值</a>已经超过5000亿美元。</p><p id="2dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是什么是SaaS软件呢？什么是多租户？这些概念是如何驱动如此成功的企业的？</p><p id="37c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这些问题，我们将从分解<em class="lv"> SaaS </em>和<em class="lv">多租户开始。</em></p><blockquote class="lw lx ly"><p id="f251" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“软件即服务(或SaaS)是一种通过互联网交付应用程序的方式——即服务。您只需通过互联网访问软件，而不是安装和维护软件，将自己从复杂的软件和硬件管理中解放出来。”— <a class="ae ky" href="https://www.salesforce.com/in/saas/" rel="noopener ugc nofollow" target="_blank">销售队伍</a></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="ed34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SaaS是通过互联网交付的即用型软件。用户通常需要支付一定的费用才能使用和访问该软件。</p><p id="0118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面:</p><blockquote class="lw lx ly"><p id="a095" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“多租户是一种软件架构，其中单个软件实例可以服务于多个不同的用户组。<a class="ae ky" href="https://www.redhat.com/en/topics/cloud-computing/what-is-saas" rel="noopener ugc nofollow" target="_blank">软件即服务</a> (SaaS)产品是多租户架构的一个例子。”— <a class="ae ky" href="https://www.redhat.com/en/topics/cloud-computing/what-is-multitenancy" rel="noopener ugc nofollow" target="_blank">红帽</a></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="c628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多租户是一种模式，在这种模式下，一个应用程序的实例可以服务于多个用户，通常称为租户。这个概念与SaaS密切相关。</p><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要回答上面提出的最后一个问题，构建SaaS产品的进入门槛很低，并且(通常)在增加额外租户的金钱和时间方面的成本非常低。</p><p id="6413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建SaaS软件，你需要的只是一个想法和开发软件的能力。如果你自己不写代码，你可以出去雇佣开发人员来帮你写。</p><p id="1b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你发现有人愿意为你的想法买单，把他们作为租户加入你的应用程序的成本通常可以用几美元或者更少来衡量。假设您有自助注册流程，这些租户也可以非常快速地添加。</p><p id="c298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都使得SaaS的企业有能力快速发展。</p><p id="28f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这个背景，让我们在构建SaaS应用程序时考虑更多的技术问题。</p><h1 id="5794" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">多租户架构</h1><p id="dc4a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">设计和实现一个能有效处理多个租户及其数据的应用程序绝非易事。</p><p id="abb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多事情需要考虑，包括以下内容:</p><ul class=""><li id="26ef" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">数据安全和隔离</strong> —数据必须安全存储，并与其他租户的数据隔离(逻辑上或物理上)</li><li id="01e1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">认证和授权</strong> —用户需要能够登录并拥有适当级别的访问权限来使用应用程序</li><li id="461a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">优化性能/可扩展性</strong> —因为系统可能会经历快速增长的使用率，所以它必须能够快速高效地扩展以满足需求</li><li id="65a2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">处理升级</strong> —部署新功能应该相对容易</li><li id="c365" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">控制成本</strong> —随着应用程序的增长，基础架构成本应降至最低</li><li id="0dbd" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">自助服务和定制</strong> —不同的租户会有不同的要求，因此从一开始就内置可定制性非常重要</li><li id="8bdd" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">法规遵从性和治理</strong> —如果您处于高度管制的领域(医疗保健、政府等)。)，将有适用于您的应用程序的附加规则</li></ul><p id="b256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将主要关注上述考虑事项中的数据安全性/隔离、身份验证/授权、管理利用率和控制成本。</p><p id="449e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了多租户应用程序应该具备的一些特征，让我们来看看我们将要构建的系统级图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/1b8b8a78bc18d5f2b5bbb0da3e1d637b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO6b21yr8imqxRq4kibrPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">系统图</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="882b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将我们的应用程序建模为一个基本的三层架构。</p><p id="0d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种架构的一般流程如下:</p><ol class=""><li id="a1d4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">前端代码(<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度</a>等。)将根据用户凭证从身份服务器请求并接收一个<a class="ae ky" href="https://jwt.io/introduction" rel="noopener ugc nofollow" target="_blank"> JWT (JSON Web令牌)</a></li><li id="5e54" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">前端代码将提供这个JWT作为<a class="ae ky" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank">承载令牌</a>来认证对应用服务器的任何请求</li><li id="9d0d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">然后，应用服务器将验证/解析JWT，并从数据库返回适用的数据</li></ol><p id="eb27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您可以选择使用(或构建)任何您想要实现该架构的工具集，但我们将使用以下工具:</p><ul class=""><li id="c939" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">Postgres</em></strong>T5】作为我们的数据库</a></li><li id="299a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">auth 0</em></strong></a><strong class="lb iu"><em class="lv"/></strong>作为我们的身份服务器</li><li id="13c1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/dotnet/core" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">。NET Core </em> </strong> </a>作为我们的应用服务器</li></ul><p id="b502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将省略对前端工具的详细讨论，因为这里不会包含太多的多租户逻辑(尽管我们将在Auth0一节中触及)。</p><p id="d7f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果您选择在应用程序中使用React或Angular，那么Auth0有一些用于实现客户端登录的优秀文档，可以在这里找到<a class="ae ky" href="https://auth0.com/docs/quickstart/spa/react/01-login" rel="noopener ugc nofollow" target="_blank">这里找到</a>和<a class="ae ky" href="https://auth0.com/docs/quickstart/spa/angular/01-login" rel="noopener ugc nofollow" target="_blank">这里找到</a>。</p><p id="cbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们从数据库开始，看看如何在架构的每一层实现多租户。</p><h1 id="96ba" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Postgres</h1><p id="1ea3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">数据库是设计多租户应用程序时首先要关注的领域之一。正是在这一层，每个租户的数据在逻辑上或物理上都是分离的。</p><p id="5094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当考虑数据隔离和安全需求时，这是关键。此外，经过深思熟虑的数据设计是任何成功应用程序的关键。</p><p id="0d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到实现，对于关系数据库，我们可以采用三种主要方法:</p><ol class=""><li id="6d54" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">一种<strong class="lb iu">“每租户数据库”</strong>方法</li><li id="d7c6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">一种<strong class="lb iu">“每租户模式”</strong>方法</li><li id="f45a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">一种<strong class="lb iu">“共享模式”</strong>方法</li></ol><p id="33b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择哪种方法适合您的体系结构在很大程度上取决于业务需求。每一种都有适合某些用例的属性，但不适合其他用例。</p><p id="ef55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更深入地看看这些利弊。</p><h2 id="e92a" class="nw mk it bd ml nx ny dn mp nz oa dp mt li ob oc mv lm od oe mx lq of og mz oh bi translated">每个租户的数据库</h2><p id="7624" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这种方法中，每个租户都有自己独立的数据库服务器。这意味着添加的每个租户都需要一个物理数据库来存储他们的数据。</p><p id="0176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞成的意见</p><ul class=""><li id="add9" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">提供最高级别的数据隔离</li><li id="ce4b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它在概念上简单易懂</li><li id="7e42" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">针对特定租户执行数据迁移非常容易</li><li id="bd32" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">可以为每个租户定制数据模型</li></ul><p id="91bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骗局</p><ul class=""><li id="d765" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">就基础设施而言，这是迄今为止最昂贵的方法</li><li id="f2e3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">硬件资源没有得到有效利用</li><li id="c06b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">管理开销随着规模迅速增加</li></ul><p id="303a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你在一个高度监管的领域，如医疗保健或金融。在这种情况下，由于法规要求，您可能别无选择，只能使用这种方法。</p><p id="5f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法开始起来很简单，但是扩展性不好。维护的资金成本和工程时间随着系统中租户数量的增加而线性增长。</p><p id="56b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您只希望有几个租户，这种方法可能行得通。否则，这种设计模式可能难以大规模支持。</p><h2 id="e88c" class="nw mk it bd ml nx ny dn mp nz oa dp mt li ob oc mv lm od oe mx lq of og mz oh bi translated">每租户模式</h2><p id="4c6a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这个场景中，应用程序中的所有租户共享同一个数据库服务器。但是，每一种都有自己逻辑上独立的模式。每当有新的租户加入时，都必须为该租户创建新的模式。</p><p id="cca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞成的意见</p><ul class=""><li id="09bd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">提供相当多的逻辑数据隔离</li><li id="0bfa" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">比每租户数据库更高效地利用资源</li><li id="6680" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">因为硬件是共享的，所以更便宜</li><li id="16bc" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">允许在每个租户级别进行更多定制</li></ul><p id="6a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骗局</p><ul class=""><li id="0bb1" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">仍然需要大规模的工程开销</li><li id="ca5d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">可能无法为某些用例提供足够的数据隔离</li></ul><p id="f6f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据库多租户的中间选择。</p><p id="4f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的主要缺点是管理可能有成百上千个模式的数据库。需要为所有租户进行的任何数据/模式迁移都必须在每个单独的模式上执行。</p><p id="a8cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只打算有几个租户，这不是太大的问题。</p><p id="863b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的租户有安全意识，但没有任何需要单独数据库的法规要求，这也是一个不错的选择。</p><p id="01c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，大规模支持这种数据库架构可能会很困难(尽管没有每个租户支持一个数据库的方法那么困难)。</p><h2 id="3811" class="nw mk it bd ml nx ny dn mp nz oa dp mt li ob oc mv lm od oe mx lq of og mz oh bi translated">共享模式</h2><p id="97d8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这最后一个选择或多或少是一种“共享一切”的方法。</p><p id="94fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个租户的数据都驻留在同一个数据库中，在同一个模式中，甚至在同一个表中。将一个租户的数据与另一个租户的数据区分开来的方面是包含了一个<strong class="lb iu">鉴别器列。</strong></p><p id="9a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这个列称为<code class="fe oi oj ok ol b">TenantId</code>，用于指示表中的哪些行属于哪个租户。</p><p id="dad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞成的意见</p><ul class=""><li id="8d83" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">最有效地利用资源和最低成本的选择</li><li id="b10c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">最简单的工程管理开销</li><li id="8af1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">可以轻松地在租户之间共享桌子</li><li id="214b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">最快的租户入职</li></ul><p id="0e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骗局</p><ul class=""><li id="bd2f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">最低级别的数据隔离</li><li id="fc6e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">为单个租户定制数据模型非常困难/不可能</li><li id="64d1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果表变得太大，所有租户的性能都会受到影响</li></ul><p id="2f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个小型团队构建多租户应用程序的流行方法。</p><p id="7dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为这是最便宜的选择，并且当应用程序增加租户时，需要维护的工程工作量最少。</p><p id="c9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，注重安全性的租户可能对这种方法提供的数据隔离级别有问题。此外，您必须在应用程序/API层投入更多，以确保租户只能访问他们自己的数据。</p><p id="4de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文的目的，我们将采用这种方法，因为对于各种各样的应用程序来说，这是一个极好的选择。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="4b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们在数据库中建立了一个模式。</p><p id="b23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个模式-模式设计的例子，我们可以用它来构建一个简单的多租户电子商务平台:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此模式，我们可以执行以下操作:</p><ul class=""><li id="48bf" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">通过向<code class="fe oi oj ok ol b">tenant</code>表添加记录，向我们的应用程序添加新的租户</li><li id="757a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">允许每个租户使用<code class="fe oi oj ok ol b">product</code>表列出产品(该表包含对<code class="fe oi oj ok ol b">tenant</code>表的外键引用)</li><li id="2a98" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用<code class="fe oi oj ok ol b">product_image</code>表将图像与产品关联起来(该表包含对<code class="fe oi oj ok ol b">product</code>表的外键引用)</li></ul><p id="9208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，<code class="fe oi oj ok ol b">product</code>表中的<code class="fe oi oj ok ol b">tenant_id</code>是我们的鉴别器列。这将在逻辑上隔离每个租户的数据。</p><p id="832a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个示例模式相对简单，但是它的概念应该很简单，可以扩展到更高级的用例。这些可以包括购买/销售产品、“购物车”系统、用户管理、财务报告等。</p><p id="3a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这种方法不能提供与我们其他数据库设计(每租户数据库、每租户模式)相同级别的数据安全性和隔离。但是，它具有成本/资源效率，对于小型团队来说易于管理，并且使添加新租户和扩展变得简单。</p><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，假设我们需要在租户之间共享一个表(例如，共享管理员的列表)。用共享模式设计实现这一点，在数据和API层需要较少的逻辑。</p><p id="4efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，哪种方法适合您的应用的答案是<strong class="lb iu">这取决于具体情况。</strong>务必根据您独特的业务需求评估每种方法的利弊。</p><p id="0a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">讨论完数据库层后，让我们继续处理身份。</p><h1 id="1fff" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Auth0</h1><p id="b3ee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">毫无疑问，<strong class="lb iu">身份</strong>可能是构建SaaS应用程序最具挑战性的部分之一。密码学、<a class="ae ky" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 </a>、<a class="ae ky" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>等概念。，理解和正确实施起来都很复杂。</p><p id="bc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在构建应用程序时，首先要做出的决定之一是构建身份服务还是使用<a class="ae ky" href="https://www.okta.com/identity-101/idaas/" rel="noopener ugc nofollow" target="_blank">身份即服务(IDaaS)平台</a>。</p><p id="f2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建自己的身份服务当然有优势，首先是可定制性。当您开发自己的产品时，您可以根据应用的具体需求进行定制。从短期来看，这也是一个更便宜的选择。</p><p id="237d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这种方法也有明显的缺点，包括以下几点:</p><ul class=""><li id="30c6" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">这里不太安全</li><li id="6596" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">额外的维护开销，尤其是大规模维护</li><li id="b28a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它占用了本可用于构建应用程序核心功能的时间</li></ul><p id="15c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，在某些边缘情况下，构建身份服务可能是有意义的。尽管如此，如果可以的话，尽量避免这种情况，使用像Auth0这样的知名IDaaS提供商。</p><p id="a351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Auth0，有许多不同的方法可以实现多租户。同样，您实现它的方式高度依赖于您特定的业务需求。</p><p id="cea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><ul class=""><li id="623e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">租户需要定制的登录页面吗？</li><li id="d335" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">用户需要登录像脸书或谷歌这样的社交网站吗？</li><li id="27f2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">租户需要访问他们自己的Auth0帐户控制面板吗？</li></ul><p id="7075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将对应用程序的要求做一些假设:</p><ol class=""><li id="df6e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">用户只能使用用户名/密码登录</li><li id="6ebb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">所有用户都存在于同一个Auth0管理的<a class="ae ky" href="https://auth0.com/docs/connections/database" rel="noopener ugc nofollow" target="_blank">数据库</a></li><li id="ad08" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">租户无需访问他们自己的Auth0控制面板</li><li id="4bce" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">用户将只属于一个租户</li><li id="78b5" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">我们将只有一个<a class="ae ky" href="https://auth0.com/docs/configure/applications" rel="noopener ugc nofollow" target="_blank"> Auth0应用程序</a>和一个<a class="ae ky" href="https://auth0.com/docs/configure/apis" rel="noopener ugc nofollow" target="_blank"> Auth0 API </a></li><li id="aeb6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">所有租户都有自定义子域(例如，<code class="fe oi oj ok ol b">https://tenant1.myapplicationdomain.com</code>)</li><li id="5ee8" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">所有租户通过同一个登录域(例如，<code class="fe oi oj ok ol b">https://login.myapplicationdomain.com</code>)登录，没有自定义品牌</li></ol><p id="b982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还假设已经设置了我们的Auth0帐户，包括一个应用程序、一个API和该API的权限/范围。</p><p id="abab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然介绍这些资源的设置超出了本文的范围，但是请务必查看Auth0的文档中提供的各种<a class="ae ky" href="https://auth0.com/docs/quickstarts" rel="noopener ugc nofollow" target="_blank">快速入门指南。入门很容易，文档也很优秀。</a></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="7b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于我们已经了解了背景，让我们进入架构。</p><p id="87f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须解决的最关键的问题是<em class="lv">“当用户注册/登录时，我们如何将用户与特定租户相关联？”。</em></p><p id="3c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管实现如何，在Auth0 <a class="ae ky" href="https://auth0.com/docs/users/user-profiles" rel="noopener ugc nofollow" target="_blank">用户配置文件</a>中有两个地方可以存储对应用程序中租户的引用。</p><p id="d36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是<code class="fe oi oj ok ol b"><a class="ae ky" href="https://auth0.com/docs/users/metadata" rel="noopener ugc nofollow" target="_blank">user_metadata</a></code> <a class="ae ky" href="https://auth0.com/docs/users/metadata" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe oi oj ok ol b"><a class="ae ky" href="https://auth0.com/docs/users/metadata" rel="noopener ugc nofollow" target="_blank">app_metadata</a></code>字段。</p><p id="e1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok ol b">user_metadata</code>字段旨在存储用户可能看到和编辑的特征。另一方面，<code class="fe oi oj ok ol b">app_metadata</code>意在存储仅应用程序的信息，如权限或外部id。</p><p id="e092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在用户档案的<code class="fe oi oj ok ol b">app_metadata</code>部分存储一个<code class="fe oi oj ok ol b">tenant_id</code>更合适。正如您所料，有许多方法可以做到这一点。</p><p id="8bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是创建一个定制的登录页面来捕获用户注册信息，包括租户名称或ID。然后，您可以利用自己的API/auth 0管理API<a class="ae ky" href="https://auth0.com/docs/api/management/v2" rel="noopener ugc nofollow" target="_blank">来创建用户。</a></p><p id="bf24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是使用默认的<a class="ae ky" href="https://auth0.com/docs/login/universal-login" rel="noopener ugc nofollow" target="_blank"> Auth0登录页面/小部件</a>。从那里，您可以使用一个<a class="ae ky" href="https://auth0.com/docs/actions/triggers/post-login/redirect-with-actions" rel="noopener ugc nofollow" target="_blank"> Auth0定制动作在注册/登录过程中将</a>重定向到由您的应用程序管理的页面。该页面将负责收集任何特定于租户的信息，并将其添加到用户配置文件中。</p><p id="e8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是合理的解决方案。但是，对于我们的设计，我们将尝试做到以下几点:</p><ol class=""><li id="d29f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">让用户体验尽可能无缝</li><li id="bac3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">最小化我们负责的代码量</li></ol><p id="e24f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这些设计目标，我们将使用<a class="ae ky" href="https://auth0.com/docs/login/universal-login" rel="noopener ugc nofollow" target="_blank"> Auth0通用登录页面</a>和由<a class="ae ky" href="https://auth0.com/docs/actions/triggers/post-login" rel="noopener ugc nofollow" target="_blank">登录后事件</a>触发的<a class="ae ky" href="https://auth0.com/docs/actions" rel="noopener ugc nofollow" target="_blank">自定义动作</a>。</p><p id="c5af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用登录页面需要最少的自定义代码/不需要自定义代码。此外，使其工作所需的集成工作量很低。它满足上面的#2，并处理各种不同的身份验证场景。</p><p id="9d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果通用登录页面的默认设置不适合您的应用程序，您可以随时定制页面的<a class="ae ky" href="https://auth0.com/docs/brand-and-customize/universal-login-page-templates" rel="noopener ugc nofollow" target="_blank">外观和代码。</a></p><p id="0907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，定制动作满足我们设计的需求#1。Auth0自定义操作是版本化的函数，可以在<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中实现，并且可以在Auth0运行时的特定点执行。</p><p id="6c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过挂钩post-login事件，我们可以在用户成功登录之后(但在他们被重定向到应用程序之前)添加定制逻辑。在我们的例子中，这个定制逻辑将执行以下操作:</p><ol class=""><li id="2c02" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">检查用户的<code class="fe oi oj ok ol b">app_metadata</code>是否包含一个<code class="fe oi oj ok ol b">tenant_id</code>属性</li><li id="bf10" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">如果是，则结束执行。否则，将适当的<code class="fe oi oj ok ol b">tenant_id</code>添加到<code class="fe oi oj ok ol b">app_metadata</code></li><li id="81d7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">将用户的<code class="fe oi oj ok ol b">app_metadata</code>添加到Auth0返回的访问令牌中</li></ol><p id="8842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法应该可行，但我们仍然需要弄清楚如何将上下文传递给登录后的操作，这将允许它确定要添加给用户的正确的<code class="fe oi oj ok ol b">tenant_id</code>。</p><p id="c779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特定于租户的自定义子域的假设是解决方案的一部分。</p><p id="9be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个子域格式<code class="fe oi oj ok ol b">https://{tenant_name}.myapplicationdomain.com</code>。通过强制租户的名称是惟一的(就像在前面介绍的数据库模式中一样)，我们可以对该名称执行数据库查询以确定一个<code class="fe oi oj ok ol b">tenant_id</code>。</p><p id="65c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，我们所需要的是让我们的自定义操作知道用户试图访问什么URL。</p><p id="de7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，作为传递给登录后操作的<a class="ae ky" href="https://auth0.com/docs/actions/triggers/post-login/event-object" rel="noopener ugc nofollow" target="_blank">事件对象</a>的一部分，我们可以访问启动登录流的请求的细节。这包括Auth0在成功登录尝试后应该重定向到的URL(即我们特定于租户的子域)。</p><p id="c111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，Auth0要求你在登录后将特定的URL加入白名单。这是出于安全目的，主要是为了防止重定向URL被操纵将用户发送到恶意站点。</p><p id="52ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着我们可以对我们将用来在自定义操作中驱动多租户逻辑的<code class="fe oi oj ok ol b">event.request.query.redirect_uri</code>属性有相当程度的信心。</p><p id="6dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看自定义操作中的代码可能是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这段代码，我们现在可以说明多租户用户注册和登录过程:</p><ol class=""><li id="8936" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">用户导航到租户的子域(<code class="fe oi oj ok ol b">https://tenant1.myapplicationdomain.com</code>)</li><li id="25f4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">假设用户没有通过身份验证，重定向到Auth0通用登录页面</li><li id="28ce" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">用户通过默认的注册过程，提供一个电子邮件和密码</li><li id="7567" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">然后，用户使用他们的凭据登录</li><li id="7f30" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">登录后自定义操作将执行，并将新创建的用户与正确的租户相关联</li><li id="0f16" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">前端从Auth0接收包含<code class="fe oi oj ok ol b">tenant_id</code>的访问令牌，用户被重定向到租户的站点</li></ol><p id="5b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，前端的职责是将访问令牌作为承载令牌包含在对后端的每个请求中。后端是多租户逻辑的其余部分将被实现的地方。</p><p id="bedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，事不宜迟，让我们开始讨论如何在我们的后端做到这一点。</p><h1 id="9e2f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">。网络核心</h1><p id="d81b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于多租户，后端职责的高级视图包括:</p><ol class=""><li id="ce84" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">验证传入请求的身份验证标头中提供的JWT(身份验证)</li><li id="9657" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">确保用户/租户有权访问适用于请求的端点(授权)</li><li id="f027" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">在响应中访问并返回正确的用户/租户数据</li></ol><p id="911f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保数据隔离和身份验证/授权，后端必须正确执行这些操作。否则，一个租户可能会看到另一个租户的数据(这不太理想)。</p><p id="95c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是。NET Core framework提供了可配置的工具来解决这些确切的情况。</p><p id="21b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">在我们的<code class="fe oi oj ok ol b">Startup.cs</code>文件中注册一个认证服务和中间件</a>，它验证来自Auth0的JWT不记名令牌。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。NET身份验证启动配置</p></figure><p id="5618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码片段最重要的方面是对<code class="fe oi oj ok ol b">services.AddAuthentication()</code>和<code class="fe oi oj ok ol b">app.UseAuthentication()</code>的调用。</p><p id="803b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些告诉了。NET应用程序向<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank"> DI(依赖注入)容器</a>注册我们定制的认证服务，并包含<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">认证中间件</a>。反过来，中间件将使用注册的服务来验证传入的请求。</p><p id="5692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将<code class="fe oi oj ok ol b">DefaultAuthenticateScheme</code>配置为<code class="fe oi oj ok ol b">JwtBearerDefaults.AuthenticationScheme</code>并添加了对扩展方法<code class="fe oi oj ok ol b">.AddJwtBearer()</code>的调用，所以我们的认证中间件将在认证头中期待一个JWT承载令牌。</p><p id="b11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还将验证它是由Auth0为特定的<strong class="lb iu">受众</strong>(即Auth0中的API)发布的<strong class="lb iu">(即发布机构)。</strong></p><p id="e936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，在我们的应用程序中向任何路由添加身份验证就像向端点或控制器添加<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank"> AuthorizeAttribute </a>一样简单。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例产品控制器</p></figure><p id="c43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将确保访问端点的用户通过身份验证，但不确保他们有权访问端点。为了做到这一点，我们必须向我们的<code class="fe oi oj ok ol b">Startup.cs</code>文件添加更多的配置。</p><p id="ef65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示的目的，我们假设用户的权限编码在JWT的<code class="fe oi oj ok ol b">scope</code>字段中。</p><p id="4bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要一些自定义代码来验证这些权限。下面是代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/01-authorization#validate-scopes" rel="noopener ugc nofollow" target="_blank"> Auth0的HasScopeRequirement.cs。网络核心快速入门</a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/01-authorization#validate-scopes" rel="noopener ugc nofollow" target="_blank"> Auth0的HasScopeHandler.cs。网络核心快速入门</a></p></figure><p id="1a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两段代码将允许我们实现<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">基于策略的授权</a>，这将由我们的授权服务和中间件来执行。</p><p id="7df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将这段代码连接到<code class="fe oi oj ok ol b">Startup.cs</code>文件中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。NET授权启动配置</p></figure><p id="833d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码假设应用程序中有一个<code class="fe oi oj ok ol b">admin</code>类别的用户。</p><p id="8e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过再次使用AuthorizeAttribute将对某些端点的访问限制为只有具有该权限的用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管理产品控制器示例</p></figure><p id="6200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了适当的身份验证和授权，我们现在需要一些逻辑来为每个请求返回正确的特定于租户的数据。</p><p id="09be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是从JWT中提取<code class="fe oi oj ok ol b">tenant_id</code>属性。这可以在控制器、<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#action-filters" rel="noopener ugc nofollow" target="_blank">动作过滤器</a>等中完成。重要的是<code class="fe oi oj ok ol b">tenant_id</code>在API的<a class="ae ky" href="https://exceptionnotfound.net/the-repository-service-pattern-with-dependency-injection-and-asp-net-core/" rel="noopener ugc nofollow" target="_blank">服务和存储库层</a>中可用。</p><p id="bb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在存储库层对Postgres进行数据库调用时，将<code class="fe oi oj ok ol b">tenant_id</code>作为请求参数之一。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">租户使用<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/" rel="noopener ugc nofollow" target="_blank"> LINQ </a>过滤产品的示例</p></figure><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方法，我们能够查询与特定租户相关的所有产品。</p><p id="7177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这是一个简单的例子，但它可以扩展到支持更高级的概念，如分页、排序和附加过滤。</p><p id="6797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了在我们的应用程序中实现多租户。用户现在可以注册/登录、查看特定于租户的网站，并安全地访问后端提供的特定于租户的数据。</p><h1 id="926f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结束语</h1><p id="7360" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">虽然这种体系结构提供了一种构建多租户应用程序的建议方法，但是还有大量可能的替代方法。</p><p id="f356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅举几个例子，这些备选方案受所选技术堆栈、开发人员体验和个人偏好的影响。</p><p id="b723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在实践中构建多租户应用程序是很麻烦的。业务需求和潜在的假设很少像这个例子中呈现的那样清晰。根据我的经验，我发现身份层是大多数挑战出现的地方(但并不总是如此)。</p><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在为你的下一个SaaS/多租户应用编写任何代码之前，你应该确保做好研究，至少有一个粗略的架构计划。关于将多租户构建到应用程序中的最佳方式，有大量优秀的资源和大量其他观点。</p><p id="74f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我很乐意听到您构建SaaS系统的经验、最佳实践，或者对本文中使用的任何工具的想法！</p><p id="797f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见，感谢阅读。</p></div></div>    
</body>
</html>