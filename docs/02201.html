<html>
<head>
<title>How To Upload Images to a Rails API — And Get Them Back Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将图像上传到Rails API——并再次取回它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-upload-images-to-a-rails-api-and-get-them-back-again-b7b3e1106a13?source=collection_archive---------1-----------------------#2019-11-13">https://betterprogramming.pub/how-to-upload-images-to-a-rails-api-and-get-them-back-again-b7b3e1106a13?source=collection_archive---------1-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有了Rails API，图片上传并不像看起来那么简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/214dd8c02f352f7bfa1220db64430b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcXfGDQzZlqoEHv3X6HdRg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·安德鲁斯在<a class="ae ky" href="https://unsplash.com/s/photos/image?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给自己一周的时间为Supagram编写Rails API后端，supa gram是一个轻量级的基于浏览器的Instagram克隆，提供帖子、赞和你关注的用户按时间顺序排列的活动提要。</p><p id="091f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我预见到的最大困难是处于不同角色的用户之间的多态数据库关系，如追随者、被追随者、喜欢者等等。我一点也不知道，最不直观的工作实际上是围绕着Instagram的简单概念:图片上传。</p><p id="baab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我带你解决这个问题。该服务器需要:</p><ul class=""><li id="6286" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">接受来自React前端的图像文件</li><li id="15ae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将图像与数据库中新创建的帖子记录相关联</li><li id="8545" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将图像上传到Cloudinary或AWS等内容交付网络进行存储和检索</li><li id="b9c5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">获取图像URL并将其作为帖子创建的确认返回，并在后续的GET请求中返回给活动提要</li></ul><p id="3644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何做到这一点的现有资源极其分散。对于Rails API的具体环境，需要进行大量的推断或临时拼凑。这里有一个明确的、一步一步的指导来帮你减轻痛苦。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="480c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.接受来自JavaScript前端的图像</h1><p id="0aea" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">将图像上传发送到服务器有两种常见方式:作为FormData或base64字符串。base64编码和传输有相当大的性能缺点，所以我选择了FormData。</p><p id="a509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用React组件来演示，但是FormData是一个web API——它不受任何特定框架的约束，甚至不受JavaScript本身的约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="abe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，一个简单的HTML表单接受一个标题和一张图片进行上传。字段的名称应该与您的API端点期望接收的参数相匹配，在本例中是<code class="fe np nq nr ns b">caption</code>和<code class="fe np nq nr ns b">image</code>。</p><p id="4373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在提交时，我们阻止默认的表单行为(刷新页面),并使用JavaScript的FormData构造函数从<code class="fe np nq nr ns b">event.target</code>创建一个FormData对象——整个表单。</p><p id="0ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们第一次调用API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个请求的配置对象，有两件重要的事情需要注意:</p><ul class=""><li id="8593" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">标题中没有<code class="fe np nq nr ns b">"Content-Type"</code>键—内容类型是<code class="fe np nq nr ns b">multipart/form-data</code>，这是由FormData对象本身隐含的。</li><li id="c658" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">尸体没有纤维化。FormData API处理要通过web发送的图像的所有必要处理。</li></ul><p id="1a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授权头是可选的，将取决于您发布到的端点的要求。在这个例子中，我使用的端点由<code class="fe np nq nr ns b">POSTS_URL</code>表示。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="24d6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.将图像与数据库中新创建的帖子记录相关联</h1><p id="22ef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在后端，我使用ActiveStorage在图像和它们所属的对象之间创建关联。从Rails 5.2开始，它就是文件关联的标准瑰宝，并逐渐取代了CarrierWave和Paperclip等旧解决方案。</p><p id="8c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始，只需运行<code class="fe np nq nr ns b">rails active_storage:install</code>。它将为数据库中的两个新表创建迁移，<code class="fe np nq nr ns b">active_storage_blobs</code>和<code class="fe np nq nr ns b">active_storage_attachments</code>。这些是自动管理的；你不需要碰它们。运行<code class="fe np nq nr ns b">rails db:migrate</code>来完成这个过程。</p><p id="07fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，在开发环境中运行时，ActiveStorage将使用本地存储来存储上传的文件。在生产中，这几乎肯定不是您想要的。这也为从服务器返回图像URL带来了一些独特的挑战。在第三部分中，我们将在查看我们的Post模型和附带的端点之后对此进行适当的配置。</p><h2 id="aab5" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">迁移后/模型</h2><p id="1600" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为我的post模型研究这个迁移。这件事有点奇怪。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="416d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到这里没有任何关于图像的东西。图像和对图像的引用都不存在于Posts表中。</p><p id="e5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来看看这个模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的本质线是<code class="fe np nq nr ns b">has_one_attached :image</code>。这告诉ActiveStorage将一个文件与给定的Post实例相关联。</p><p id="4c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附加对象的名称应该与前端发送的参数相匹配。我将它命名为<code class="fe np nq nr ns b">:image</code>，因为我将相应的上传表单字段命名为T6。你爱怎么叫就怎么叫，只要前端和后端一致。</p><p id="1ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为奖励，我添加了验证功能，以确保没有图片的帖子无法创建。改变这一点，以适应您的目的。</p><p id="c9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好奇<code class="fe np nq nr ns b">include</code>语句和我的<code class="fe np nq nr ns b">get_image_url</code>方法？在回到这些之前，让我们检查一下创建后端点。</p><h2 id="35f1" class="nt mr it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated">创建后端点</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d6c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，<code class="fe np nq nr ns b">post_params</code>方法可以说是最重要的。来自我们前端的数据以一个Rails params hash结束，其主体大致类似于:<code class="fe np nq nr ns b">{ "caption" =&gt; "Great caption", "image" =&gt; &lt;FormData&gt; }</code>。</p><p id="db9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个散列的键必须与模型所期望的属性相匹配。</p><p id="9fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的特定post模型需要一个user_id，它不是在请求体中发送的，而是从请求头中的一个<code class="fe np nq nr ns b">Authorization</code>标记中解码出来的。那是发生在<code class="fe np nq nr ns b">get_current_user()</code>的幕后，你不需要担心。</p><p id="c5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将<code class="fe np nq nr ns b">post_params()</code>传递给<code class="fe np nq nr ns b">Post.create()</code>时，ActiveStorage开始工作，根据包含在<code class="fe np nq nr ns b">image</code>参数中的表单数据保存一个文件，并将该文件与新的Post记录相关联。如果您使用本地存储，图像将默认保存在<code class="fe np nq nr ns b">root/storage</code>中。然而，那很可能不是你想要的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0d6f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.将图像上传到CDN进行存储和检索</h1><p id="fd63" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">本地存储占用空间，无法与Cloudinary和AWS等专用内容交付网络的交付速度竞争。无论你的目的是什么，让自己熟悉这些基本服务都是一个好主意。</p><p id="3f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cloudinary非常用户友好，并且易于与ActiveStorage集成，所以这是我在这个项目中采用的方法。从现在开始，我假设你已经有了一个(免费的)Cloudinary帐户。如果你更喜欢使用另一种服务，不要担心——这种方法对所有主要的提供商来说基本上都是一样的。</p><p id="cc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，将<code class="fe np nq nr ns b">cloudinary</code> gem添加到您的gem文件并运行<code class="fe np nq nr ns b">bundle install</code>。</p><p id="e680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe np nq nr ns b">/config</code>中，打开ActiveRecord的<code class="fe np nq nr ns b">storage.yml</code>配置文件并添加以下内容。其他不要修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，导航到<code class="fe np nq nr ns b">config/environments/development.rb</code>和<code class="fe np nq nr ns b">./production.rb</code>，并分别将<code class="fe np nq nr ns b">config.active_storage.service</code>设置为<code class="fe np nq nr ns b">:cloudinary</code>。默认情况下，您的测试环境将继续使用本地存储。</p><p id="c06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，从您的Cloudinary仪表板下载<code class="fe np nq nr ns b">cloudinary.yml</code>配置文件，并将其放在<code class="fe np nq nr ns b">/config</code>文件夹中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5809c44778985721f24216e5c52df59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*1DDIFERpLQGWe2C7DqhCaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在您的仪表板帐户详细信息部分的右上角找到YML下载链接。</p></figure><p id="2e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:此文件包含您的Cloudinary帐户的密钥。不要分享这个文件或把它推给你的git repo，否则你的帐户可能会受到威胁。将<code class="fe np nq nr ns b">/config/cloudinary.yml</code>包含在您的<code class="fe np nq nr ns b">.gitignore</code>文件中。如果您不小心泄露了这些细节(我是凭经验说的)，请立即停用泄露的密钥，并通过您的Cloudinary仪表板生成一个新的密钥。更新<code class="fe np nq nr ns b">cloudinary.yml</code>以反映新的密钥。</p><p id="c493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，ActiveStorage将自动从云中上传和检索图像。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cefd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.获取图像URL并返回它</h1><p id="73e9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是使用ActiveStorage最不直观的部分。获取图像非常容易。在没有指导的情况下让他们再次出来就像喝醉了解12面魔方一样。</p><p id="e619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果像我一样，希望将构建端点响应的逻辑转移到专用的序列化程序类中，这将变得特别复杂。</p><p id="bae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的post控制器<code class="fe np nq nr ns b">respond_to_post()</code>方法中，我首先检查新的post是否有效，如果有效，从新的post和当前用户创建一个实例PostSerializer，并使用序列化器的<code class="fe np nq nr ns b">serialize_new_post() </code>方法呈现JSON。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="16ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在PostSerializer中，我收集了关于帖子的详细信息，包括将最终用户重定向到Cloudinary托管的图像的URL。如果显式地将实例变量<code class="fe np nq nr ns b">@post</code>传递给实例方法<code class="fe np nq nr ns b">serialize_post</code>看起来很奇怪，请忽略它——这是与本文无关的其他PostSerializer函数的要求。如果你好奇的话，完整的源代码在这里。同样，<code class="fe np nq nr ns b">serialize_user_details</code>方法的内容也不重要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="196d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe np nq nr ns b">post.get_image_url()</code>到底是如何工作的，它从何而来？</p><p id="ad4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我在帖子模型本身上定义的方法，图片URL是帖子的伪属性。对我来说，帖子应该知道它的图片URL是有意义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了访问ActiveStorage为每个图像创建的URL，我们使用Rails的<code class="fe np nq nr ns b">url_for()</code>方法。但是有一个障碍:模特通常不能使用Rails的<code class="fe np nq nr ns b">url_helpers</code>。有必要<code class="fe np nq nr ns b">include Rails.application.routes.url_helpers</code>在班里排在前面才能用。</p><p id="e942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图在这个阶段从前端访问您的端点，您可能会在后端看到以下错误:</p><pre class="kj kk kl km gt og ns oh oi aw oj bi"><span id="8688" class="nt mr it ns b gy ok ol l om on">ArgumentError (Missing host to link to! Please provide the :host parameter, set default_url_options[:host], or set :only_path to true)</span></pre><p id="e9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，导航到<code class="fe np nq nr ns b">config/environments/development.rb</code>并添加<code class="fe np nq nr ns b">Rails.application.routes.default_url_options = { host: "http://localhost:3000" }</code>(或者您的首选开发端口，如果不是3000的话)。在<code class="fe np nq nr ns b">./production.rb</code>中，使用您的生产服务器的web根目录作为主机值，执行相同的操作。</p><p id="429b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正常，您的端点现在将返回包含图像链接的格式精美的JSON。当点击或加载时，它会重定向到您的云托管的图像。</p><p id="e65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提交工作，推到Github，松一口气。</p></div></div>    
</body>
</html>