<html>
<head>
<title>Commonly Used Design Patterns in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中常用的设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/commonly-used-design-patterns-in-javascript-bfcd91827002?source=collection_archive---------6-----------------------#2020-02-24">https://betterprogramming.pub/commonly-used-design-patterns-in-javascript-bfcd91827002?source=collection_archive---------6-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e15e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单例模式、迭代器模式和工厂模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d8dc62ca4a1a4c73dc94f8c62728806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xKTwlgXlZPC7Xv3r"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔治·帕甘三世在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="36c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式使我们能够以标准的方式组织程序代码。</p><p id="90d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">《设计模式:可重用面向对象软件的元素》一书于1994年出版，书中提出了23种面向对象程序使用的设计模式。</p><p id="728d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究JavaScript程序中一些更常用的设计模式，包括单例模式、迭代器模式和工厂模式。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d487" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一个</h1><p id="3e35" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Singleton是JavaScript中常见的一种模式。它是一个只创建一个对象实例的类。</p><p id="67c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们用object literal来定义一个不是类的实例的对象。例如，我们有:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="47cf" class="nf me it nb b gy ng nh l ni nj">const obj = {<br/>  foo: 1<br/>}</span></pre><p id="bcd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有类语法，它做的事情和构造函数一样，我们可以定义一个<code class="fe nk nl nm nb b">getInstance</code>方法来获得一个类的实例。</p><p id="f004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个单例类，我们可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们将<code class="fe nk nl nm nb b">this</code>赋给了<code class="fe nk nl nm nb b">this.instance</code>，并在<code class="fe nk nl nm nb b">getInstance</code>中返回，我们应该总是得到相同的引用。</p><p id="8d8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该让<code class="fe nk nl nm nb b">foo1 === foo2</code>成为<code class="fe nk nl nm nb b">true</code>，因为它们引用了<code class="fe nk nl nm nb b">Foo</code>类的同一个实例。</p><p id="43c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单例类对于facade对象隐藏程序的复杂性很有用。由程序的不同部分共享的状态对象也使单例类成为一个好的选择。</p><p id="858f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们还让我们无需创建全局变量就能共享数据。全局范围没有被污染，所以它是共享数据的一个好选择。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cd9e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">迭代器</strong></h1><p id="826b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">迭代器模式是一种我们创建迭代器来顺序访问容器中的数据的模式。</p><p id="6f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要这种模式来遍历集合中的项目，而不暴露底层数据结构。我们还应该能够在不改变接口的情况下遍历聚合对象中的对象。</p><p id="9fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以定义可迭代的对象和生成器来实现这一点。</p><p id="8dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要定义一个可迭代对象，我们可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe nk nl nm nb b">iterableObj</code>从外部隐藏了它内部的数组。此外，我们可以将它更改为我们想要的任何其他内容，而不必担心在外部更改代码。</p><p id="d319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">[Symbol.iterator]</code>自ES6起，发电机功能已可用。从此以后，我们可以很容易地定义迭代器。</p><p id="c138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以定义返回生成器的生成器函数。为此，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="413c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与<code class="fe nk nl nm nb b">iterableObj</code>相似，因为它们都使用发电机。不同之处在于<code class="fe nk nl nm nb b">generatorFn</code>是一个返回生成器的生成器函数。生成器是我们迭代的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/bd8aa651e400ead4374220ef106efd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tOAeV0zASMfvNgBU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nahilnaseer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">纳希尔·纳赛尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f35a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">工厂</strong></h1><p id="da21" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">工厂模式以工厂功能为中心。它是一个不使用<code class="fe nk nl nm nb b">new</code>关键字构造类的实例或构造函数就返回对象的函数。</p><p id="784c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望使用工厂模式使代码更具可读性，因为它允许我们创建从更多代码中返回新对象的函数。</p><p id="4422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还允许我们在不知道创建对象的代码的情况下返回对象。我们不必担心实例化什么类来创建对象，或者它是如何创建的。</p><p id="c6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，当一个函数返回一个不带<code class="fe nk nl nm nb b">new</code>关键字的对象时，它就是一个工厂函数。</p><p id="9e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下创建一个简单的工厂函数:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="55d3" class="nf me it nb b gy ng nh l ni nj">const createFoo = () =&gt; ({<br/>  foo: 1<br/>});</span></pre><p id="cc1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nk nl nm nb b">createFoo</code>函数时，它总是返回<code class="fe nk nl nm nb b">{ foo: 1 }</code>对象。它总是返回一个不带<code class="fe nk nl nm nb b">new</code>关键字的对象，所以它是一个工厂函数，使用工厂模式。</p><p id="b65e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂函数在JavaScript中很常见。例如，浏览器使用<code class="fe nk nl nm nb b">document.querySelector()</code>方法获取一个给定CSS选择器的DOM对象。</p><p id="2690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中到处都有类似的返回对象的方法。</p><p id="9cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单例模式创建一个对象的单个实例。在JavaScript中，我们可以用对象文字或一个类的<code class="fe nk nl nm nb b">getInstance</code>方法来实现这一点，它总是返回一个类的同一个实例。</p><p id="4a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它对于共享数据和隐藏实现的复杂性很有用。</p><p id="a2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器模式让我们在不知道实现的情况下遍历对象集合。此外，它让我们可以在不改变接口的情况下改变底层的数据结构和逻辑。</p><p id="edea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了生成器函数，JavaScript还有迭代器来做这件事。</p><p id="1231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，工厂模式在JavaScript中很常见。任何不使用<code class="fe nk nl nm nb b">new</code>关键字实例化就返回新对象的函数都是工厂函数。</p><p id="bd58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对向其他开发人员隐藏创建对象的复杂性很有用。例如，我们不必担心<code class="fe nk nl nm nb b">document.querySelector()</code>如何从DOM中获取元素。它只返回匹配选择器的第一个DOM元素。</p></div></div>    
</body>
</html>