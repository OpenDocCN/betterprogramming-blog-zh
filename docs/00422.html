<html>
<head>
<title>Context, Scope, Execution Context, and Eight This Values in JavaScript, Explained by PAW Patrol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的上下文、范围、执行上下文和八个This值，由PAW Patrol解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-context-scope-execution-context-and-8-different-this-value-in-javascript-3366f2ecac6f?source=collection_archive---------1-----------------------#2019-05-17">https://betterprogramming.pub/understanding-context-scope-execution-context-and-8-different-this-value-in-javascript-3366f2ecac6f?source=collection_archive---------1-----------------------#2019-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fe7076ad86ff38641f0d9ecc8c1672fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMysft5VZXALruMTEevNRQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">安德鲁·庞斯在<a class="ae kf" href="https://unsplash.com/search/photos/paw-patrol?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4cc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在向职业培训和大学生解释前端六年多之后，我发现很难理解JavaScript中保留字<code class="fe le lf lg lh b">this</code>的用法。</p><p id="e8d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着<a class="ae kf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>和<a class="ae kf" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>等框架的出现，这个保留字的问题被隐藏了起来，尽管在这些层下面仍然有JavaScript，缺乏知识会导致花费数小时来修复错误。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="1bd1" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">背景与范围</h1><p id="d3d0" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们必须澄清的第一个概念是<code class="fe le lf lg lh b">context</code>和<code class="fe le lf lg lh b">scope</code>的区别。</p><p id="2dca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个术语被许多前端开发人员混淆了。我也花了一段时间去理解它们。</p><p id="cb5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的功能都有相关的范围和上下文。</p><ul class=""><li id="74d9" class="ms mt it ki b kj kk kn ko kr mu kv mv kz mw ld mx my mz na bi translated"><code class="fe le lf lg lh b">Scope</code>定义调用函数时对函数变量的访问。</li><li id="2f33" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe le lf lg lh b">Context</code>总是保留字<code class="fe le lf lg lh b">this</code>的值，它是对拥有代码执行权的对象的引用。</li></ul></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="9f70" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">执行上下文</h1><p id="cb05" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">JavaScript是单线程语言，所以同一时间只能执行一个任务。</p><p id="563b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其余的任务在执行上下文中排队。不幸的是，当他们说“执行上下文”时，他们实际上指的是范围。他们为什么这么做？</p><p id="4351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每次调用中，函数都会将其上下文附加到执行上下文中。因此，每个函数都创建了自己的执行上下文(自己的范围)。</p><p id="a33e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦调用结束，上下文被销毁，执行上下文将被转移到父上下文。只有一个全局上下文和有限函数上下文。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8edb" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.“这个”是指全局对象</h1><p id="213e" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">默认情况下，执行的执行上下文是全局的，这意味着如果代码作为简单函数调用的一部分执行，那么<code class="fe le lf lg lh b">this</code>指的是一个全局对象。</p><p id="f11d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在浏览器中运行代码，全局对象就是<code class="fe le lf lg lh b">window</code>对象。在<a class="ae kf" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js中，</a>全局对象可以是特殊的<code class="fe le lf lg lh b">global</code>或<code class="fe le lf lg lh b">module.exports</code>。</p><p id="939c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下代码正在浏览器中运行:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/b78b192a0b6f33e50e7308147eedb194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeZy0jSK9Orzzo3d1sGd1g.png"/></div></div></figure><p id="c886" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下代码在Node.js环境中运行:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/ab7a544b010204f3b0872ead8614e24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6CgHVsAII27zKAL_MlEYw.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="9a2a" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.“这”指的是新的实例</h1><p id="5a30" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当使用<code class="fe le lf lg lh b">new</code>关键字调用一个函数时，该函数被称为构造函数，并返回一个新的实例。</p><p id="8614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，<code class="fe le lf lg lh b">this</code>的值指的是一个新创建的实例。</p><p id="d652" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">new</code>关键字执行以下四项任务:</p><ol class=""><li id="dd94" class="ms mt it ki b kj kk kn ko kr mu kv mv kz mw ld nl my mz na bi translated">它创建新的空对象，例如<code class="fe le lf lg lh b">obj = { }</code>。</li><li id="2bd1" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld nl my mz na bi translated">它将新的空对象的不可见的<code class="fe le lf lg lh b">prototype</code>属性设置为构造函数的可见且可访问的<code class="fe le lf lg lh b">prototype</code>属性。(每个函数都有一个可见的<code class="fe le lf lg lh b">prototype</code>属性，而每个对象都包含不可见的<code class="fe le lf lg lh b">prototype</code>属性)</li><li id="dcb1" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld nl my mz na bi translated">它将使用<code class="fe le lf lg lh b">this</code>关键字声明的属性或函数绑定到新对象。</li><li id="bf21" class="ms mt it ki b kj nb kn nc kr nd kv ne kz nf ld nl my mz na bi translated">它返回一个创建的对象，除非构造函数返回一个非原始值(自定义JavaScript对象)。如果一个构造函数不包含return语句，那么编译器会在函数的末尾隐式插入<code class="fe le lf lg lh b">return this;</code>。如果构造函数返回一个原始值，那么<code class="fe le lf lg lh b">return this;</code>将不会被插入。</li></ol><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/f4bbbb8e6f4ee69838d2da4de0816714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXEtAkeOKBxLZSPicBz9qA.png"/></div></div></figure><p id="1eff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个新的执行上下文，可以为<code class="fe le lf lg lh b">Dog</code>函数定义新的属性。在这种情况下，我们有两个新的爪子巡逻犬:大菱鲆和粗石族。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/24c774c3a488875e266b74c10c95ea3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOB5DaXcA8z4CnfRDfZZ7g.png"/></div></div></figure><p id="4a3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能知道，JavaScript的最大优点是你可以使用每个函数的原型。(我建议您阅读一下prototype pattern，这种模式在其他面向对象语言中使用，因为它们不是本地的)。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/db8d37e28cfdba2d8bc9802546f17261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tzarcueG0omnAoCRyTBcA.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="3062" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">3.“这”是指调用程序对象(父对象)</h1><p id="fed6" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在JavaScript中，对象的属性可以是函数或简单的值。</p><p id="1938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个对象的方法被调用时，那么<code class="fe le lf lg lh b">this</code>指的是包含被调用方法的对象。</p><p id="c1fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，您可以看到关于<code class="fe le lf lg lh b">this</code>值如何不同，这取决于执行上下文:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/28dd7f30ff6b5bb88c04b788181900ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72E35PPIrj4Wy_tFffI6Tg.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="be6f" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">4.“This”带有调用或应用方法</h1><p id="ba13" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">JavaScript中的函数也是一种特殊类型的对象。</p><p id="8369" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个函数都有<code class="fe le lf lg lh b">call</code>、<code class="fe le lf lg lh b">bind</code>和<code class="fe le lf lg lh b">apply</code>方法。这些方法可用于将<code class="fe le lf lg lh b">this</code>的自定义值设置为函数的执行上下文。</p><p id="10e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，您可以看到如何使用<code class="fe le lf lg lh b">call</code>方法来更改执行上下文。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/a5be8fa5851598727792565d5115a912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0B-N2Se5YmJggwRFOD3eA.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="31ec" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">5.“This”与Bind方法</h1><p id="5b21" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe le lf lg lh b">bind</code>方法返回一个新方法，其中<code class="fe le lf lg lh b">this</code>引用传递的第一个参数。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/d7bb1ce9f02fedb3284fc584e6a6e707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIcoelINumD3YPJcf6Fr1g.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="158e" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">6.“这个”有胖箭头功能</h1><p id="12a1" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">作为ES6的一部分，有一种定义函数的新方法:使用<code class="fe le lf lg lh b">fat arrow</code> ( <code class="fe le lf lg lh b">=&gt;</code>)。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/a69fe98c7c0926db90efabe48c416062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCsHabQyBcCt_MjZdzwSrA.png"/></div></div></figure><p id="8aed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用粗箭头时，它不会为<code class="fe le lf lg lh b">this</code>创造新的值。</p><p id="fbec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>在函数外一直引用它所引用的同一个对象。没有新的执行上下文。</p><p id="131c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码显示了这个的值。参见函数<code class="fe le lf lg lh b">growUp</code>，它的执行上下文中没有<code class="fe le lf lg lh b">age</code>属性。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/f4b7f103ec23c13aca3428c6329332d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJ2uB_ZJly0KiGYiRhQNnA.png"/></div></div></figure><p id="d825" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，解决方案是不创建新的执行上下文。因此，我们可以使用粗箭头。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/9a5b32aee265aa734baa9f1430ad311a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gERpCciMe3wZzOFDS1Ijg.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="5446" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">7.“This”具有胖箭头功能和应用-调用</h1><p id="227d" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当您在粗箭头函数上使用<code class="fe le lf lg lh b">apply</code>或<code class="fe le lf lg lh b">call</code>方法时，<code class="fe le lf lg lh b">this</code>不会改变，因为粗箭头不拥有<code class="fe le lf lg lh b">this</code>。</p><p id="2e77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe le lf lg lh b">apply</code>和<code class="fe le lf lg lh b">call</code>方法只调用带参数的原方法，而<code class="fe le lf lg lh b">thisArg</code>被忽略。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/7526b74c3b5cc448fcb86b17f0b651ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tho-lIeFZeoFD5uiZH4XqA.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="eb83" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">8.“This”与类糖语法</h1><p id="7a83" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当我们使用<code class="fe le lf lg lh b">class</code> sugar语法时，通常会像在任何其他面向对象编程语言中一样使用<code class="fe le lf lg lh b">this</code>。</p><p id="f029" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，大多数OOP(面向对象编程)语言不允许在函数中定义函数。</p><p id="1d1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们看一下下面的代码，有一个方法<code class="fe le lf lg lh b">displayName</code>。它包括一个名为<code class="fe le lf lg lh b">innerDisplay</code>的方法，该方法使用关键字<code class="fe le lf lg lh b">this</code>。</p><p id="499a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在这个上下文中执行<code class="fe le lf lg lh b">innerDisplay</code>函数，我们将创建一个新的执行上下文，因此<code class="fe le lf lg lh b">this</code>值将不属于<code class="fe le lf lg lh b">Dog</code>类。</p><p id="061b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，为了解决这个问题，我们可以使用本博客中解释的任何技巧。在这种情况下，我们将使用<code class="fe le lf lg lh b">apply</code>函数将<code class="fe le lf lg lh b">innerDisplay</code>函数的上下文更改为<code class="fe le lf lg lh b">Dog</code>的上下文。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/16d487bd1491cf792358e65fb63c4478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWft80OhVTjMo_JLNbWBUg.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="a6fc" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">资源</h1><p id="e3ca" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><a class="ae kf" href="https://www.tutorialsteacher.com/javascript/new-keyword-in-javascript" rel="noopener ugc nofollow" target="_blank">https://www . tutorialsteacher . com/JavaScript/new-keyword-in-JavaScript</a><br/><a class="ae kf" href="https://medium.com/quick-code/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8" rel="noopener">https://medium . com/quick-code/understanding-the-this-keyword-in-JavaScript-CB 76d 4 c 7 C5 e 8</a><br/><a class="ae kf" href="https://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/" rel="noopener ugc nofollow" target="_blank">https://JavaScript sexy . com/understand-JavaScript-this-with-clarity-and-master-it/</a><br/><a class="ae kf" href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" rel="noopener ugc nofollow" target="_blank">http://www</a></p></div></div>    
</body>
</html>