<html>
<head>
<title>Swift’s Equatable and Comparable Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的等价和可比协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swifts-equatable-and-comparable-protocols-54811114a5cf?source=collection_archive---------13-----------------------#2020-01-06">https://betterprogramming.pub/swifts-equatable-and-comparable-protocols-54811114a5cf?source=collection_archive---------13-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cc1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您的Swift类型何时应该等同或可比？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e18c3ba167930d0ee1a3cacd5fd69f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wiCyo5KqmLvH9ijJaCDVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@unitasphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">查尔斯“鸭子”尤纳斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/equals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f8d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“等值”是指相等，“可比”是指对象之间的比较。这很重要，因为我们如何确定两个复杂的对象是相同的？在许多情况下，这是你应该决定的事情。</p><p id="acab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初级|简单<strong class="lb iu"> </strong> | <strong class="lb iu">普通</strong> |挑战</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件:</h1><ul class=""><li id="cb5f" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">能够产生一句“你好，世界！”iOS应用(指南<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/your-first-swift-application-without-a-mac-79598ad839f8" rel="noopener">此处</a>)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><p id="84aa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">Comparable:一个协议，可以使用关系运算符<code class="fe ni nj nk nl b">&lt;</code>、<code class="fe ni nj nk nl b">&lt;=</code>、<code class="fe ni nj nk nl b">&gt;=</code>和<code class="fe ni nj nk nl b">&gt;</code>应用于一个类型</p><p id="9540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Equatable:可以应用于类型以允许值相等的协议</p><p id="c365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作数:对其执行运算符的值</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2af0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这个例子</h1><p id="db33" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们创造了一个<code class="fe ni nj nk nl b">struct</code>来代表一个人。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="dc57" class="nq md it nl b gy nr ns l nt nu">struct Person {<br/>    let name: String<br/>    let age: Int<br/>    let parent: Bool<br/>}</span></pre><p id="f215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建两个人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7a136bf9600d3603845b09e77040f198.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*OMBSMfD-f8_L0NJPDPz3JQ.png"/></div></figure><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="f73d" class="nq md it nl b gy nr ns l nt nu">let dave = Person(name: "Dave", age: 22, parent: false)<br/>let karen = Person(name: "Karen", age: 32, parent: true)</span></pre><p id="90e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后可以把它放入一个人的数组中，就像大多数物体一样:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="3b3b" class="nq md it nl b gy nr ns l nt nu">let people = [dave, karen]</span></pre><p id="b54e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是我们是否能有效地比较我们的人。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">比较</h1><p id="cb32" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们可以把<code class="fe ni nj nk nl b">dave</code>，和<code class="fe ni nj nk nl b">karen</code>比作两个人。</p><p id="808f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种比较意味着什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7c8e56fd3a7573b959d477bafb895841.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*dCdOkSCtB7sd-ftc4mV-sA.png"/></div></figure><p id="12ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以比较他们的名字:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="fb4f" class="nq md it nl b gy nr ns l nt nu">dave.name == karen.name // is false</span></pre><p id="e87c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解析为false(因为名称不相等，分别是“Dave”和“Karen”的<code class="fe ni nj nk nl b">Strings</code>)。</p><p id="e628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们知道这两个人的年龄是一样的:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="7c39" class="nq md it nl b gy nr ns l nt nu">dave.age == karen.age // is true</span></pre><p id="4f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这些人中只有一个是父母:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="61f2" class="nq md it nl b gy nr ns l nt nu">dave.parent == karen.parent // is true</span></pre><p id="f4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们通过依次调查每个属性来决定类型<code class="fe ni nj nk nl b">Person</code>是否相同。这很棘手，因为如果我们决定一个人是相同的<strong class="lb iu"> <em class="nw">只有</em> </strong>如果所有的属性都是相同的，我们可能会写出如下的<code class="fe ni nj nk nl b">If</code>语句:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="f6a3" class="nq md it nl b gy nr ns l nt nu">if dave.name == karen.name &amp;&amp; dave.age == karen.age &amp;&amp; dave.parent == karen.parent {<br/>    print ("The same")<br/>}</span></pre><p id="a79a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呃。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d19e2f1f8d155a053ec6fba83396a210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RF_BKA8vjlttGex1fpw9lA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事情不应该是这样的！</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2603" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">平等街</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b237598cc98e5e208782f24dfb76fd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*c-CFEywAcnzzLQTSWhRuWQ.png"/></div></figure><p id="eeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ni nj nk nl b">contains</code>协议扩展方法，而不是像上面那样使用笨拙的<code class="fe ni nj nk nl b">if</code>语句:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="22c3" class="nq md it nl b gy nr ns l nt nu">people.contains{ obj -&gt; Bool in <br/>    return obj.name == dave.name<br/>         &amp;&amp; obj.age == dave.age<br/>         &amp;&amp; obj.parent == dave.parent<br/>} </span></pre><p id="9059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面表示的人<code class="fe ni nj nk nl b">array</code>，返回true。</p><p id="6e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以做得更好——这只适用于戴夫这个人。我们需要<em class="nw">提取</em>这个，这样就很容易找到<em class="nw">任何</em>人。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="6b0e" class="nq md it nl b gy nr ns l nt nu">let person = Person(name: "Dave", age: 22, parent: <strong class="nl iu">false</strong>)</span><span id="7c55" class="nq md it nl b gy nz ns l nt nu">people.contains{ obj -&gt; Bool in <br/>    return obj.name == person.name<br/>         &amp;&amp; obj.age == person.age<br/>         &amp;&amp; obj.parent == person.parent<br/>}</span></pre><p id="086b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还是不太好。一定有更简单的方法。更简单的方法是使用<code class="fe ni nj nk nl b">Equatable</code>协议。因此我们必须让我们的<strong class="lb iu">对象</strong>符合这个协议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6dee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">符合等效协议</h1><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们建立一个符合<code class="fe ni nj nk nl b">Equatable</code>协议的新例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fe6ba823d58e074da77a9b2f00e911be.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*peL-GszqFhK6OvYrBUjNgA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">平等很重要！</p></figure><p id="fdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们上面的对象没有太大的不同；特别是，我们将有一只新的狗<code class="fe ni nj nk nl b">Struct</code>。这些狗也将有一个名字，年龄和布尔声明，如果狗是父母。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="92f7" class="nq md it nl b gy nr ns l nt nu">struct Dog {<br/>    let name: String<br/>    let age: Int<br/>    let parent: Bool<br/>}</span></pre><p id="26c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这目前不符合<code class="fe ni nj nk nl b">Equatable</code>协议。为此，我们将协议的名称放在对象名称之后(在本例中为<code class="fe ni nj nk nl b">struct</code>)。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5f90" class="nq md it nl b gy nr ns l nt nu">struct Dog: Equatable {<br/>    let name: String<br/>    let age: Int<br/>    let parent: Bool<br/>}</span></pre><p id="04df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创造一些狗:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="e278" class="nq md it nl b gy nr ns l nt nu">let millie = Dog(name: "Millie", age: 5, parent: false)<br/>let bear = Dog(name: "Bear", age: 5, parent: true)</span></pre><p id="c89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以测试两个狗对象(<code class="fe ni nj nk nl b">operands</code>)之间的相等性，这使得下面的语句有效！</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5a48" class="nq md it nl b gy nr ns l nt nu">millie == bear</span></pre><p id="6f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象相等，操作数的所有属性都相等，这是没有问题的。但是如果我们有一个操作数不完全是这样的呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向类型添加==运算符函数</h1><p id="92f6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们想象一下，我们有一堆t恤，并且只对我们的尺寸，中号感兴趣(如果你拿了一件不同尺寸的t恤，想象你是中号的，特别是因为你正在中号上阅读这篇文章)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f4b56bc1bf433e05d531480824a2077a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*sFjCmObkhyv8tE78-1UDyw.png"/></div></figure><p id="1143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于阅读，我把所有的属性都做成<code class="fe ni nj nk nl b">String</code>:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="4c13" class="nq md it nl b gy nr ns l nt nu">struct TShirt: Equatable {<br/>    let shade: String<br/>    let size: Int<br/>}</span></pre><p id="506b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以声明几件衬衫，并将它们放入衣服数组:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="f262" class="nq md it nl b gy nr ns l nt nu">let redM = TShirt(shadeL "Red", size: "Medium")<br/>let redS = TShirt(shadeL "Red", size: "Small")<br/>let yellowM = TShirt(shadeL "Yellow", size: "Medium")<br/>let yellowS = TShirt(shadeL "Yellow", size: "Small")</span><span id="17d5" class="nq md it nl b gy nz ns l nt nu">let clothes = [redM, redS, yellowM, yellowS]</span></pre><p id="9483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我声明所有中号衬衫都是一样的。看，我不在乎你衬衫的颜色(冲我来)。</p><p id="b953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们添加一个<strong class="lb iu">静态函数</strong>来使</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="d9f7" class="nq md it nl b gy nr ns l nt nu">struct TShirt: Equatable {<br/>    let shade: String<br/>    let size: Int</span><span id="6fe1" class="nq md it nl b gy nz ns l nt nu">    static func == (lhs: T-shirt, rhs: TShirt) -&gt; Bool {<br/>         return lhs.size == rhs.size<br/>    }<br/>}</span></pre><p id="598f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致只有相同尺寸的衬衫是相等的。我们可以使用以下内容对此进行测试:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="dc11" class="nq md it nl b gy nr ns l nt nu">redM == redS //false<br/>redM == yellowM //true<br/>redS == yellowS //true<br/>yellowS == yellowM //false<br/>redM == yellowS //false</span></pre><p id="16f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事值得一提。我们在t恤衫上声明的静态函数:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="af65" class="nq md it nl b gy nr ns l nt nu">static func == (lhs: Tshirt, rhs: TShirt) -&gt; Bool {<br/>     return lhs.size == rhs.size<br/>}</span></pre><p id="8c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几件事值得注意。</p><p id="57a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">lhs</code>代表左手边，<code class="fe ni nj nk nl b">rhs</code>代表右手边。所以当我们比较两个t恤对象时，我们假设第一个是左手对象，第二个是右手对象。</p><p id="cb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了该静态函数的组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a202388941d1cf2b1992d8edb357a35b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDftqSeKiNEY22fuS8PVKQ.png"/></div></div></figure><p id="a789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">contains</code>现在可以像我们预期的那样工作:如果数组中有一件中号t恤，我们询问数组中是否包含另一件中号t恤，这将返回<strong class="lb iu"> true </strong>。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="4b1d" class="nq md it nl b gy nr ns l nt nu">var clothesArray: [TShirt] = []<br/>clothesArray.append(redM)<br/>clothesArray.append(redS) //false<br/>clothesArray.append(yellowM) //true</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fef6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">整理</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/63a6559cd662b8dea9f2f4e0979b28ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*xO8eX-mJP6qbM8Ri72F_Hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分类回收！</p></figure><p id="2dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以按照如下定义对数组进行排序:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="0c7a" class="nq md it nl b gy nr ns l nt nu">var clothes = [redM, redS, yellowM, yellowS]</span></pre><p id="817b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按大小，通过以下方式:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="3593" class="nq md it nl b gy nr ns l nt nu">clothes.sorted(by: {$0.size &lt; $1.size})</span></pre><p id="8b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们希望我们的衣服总是按大小排序，我们可以使用可比协议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2162" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过实现可比较的协议进行排序</h1><p id="7ae4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果我们尝试将可比较的协议实现为:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="8db5" class="nq md it nl b gy nr ns l nt nu">struct TShirt: Equatable, Comparable {<br/>    let shade: String<br/>    let size: Int</span><span id="4748" class="nq md it nl b gy nz ns l nt nu">    static func == (lhs: T-shirt, rhs: TShirt) -&gt; Bool {<br/>         return lhs.size == rhs.size<br/>    }<br/>}</span></pre><p id="cea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将得到一个错误，表明我们当前不符合协议。太好了。这是真的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ea974e1c47a62b8e09573c26a3dec169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eam1Fzv3dlKIDp-nJRe3Yg.png"/></div></div></figure><p id="6ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您实际上可以让编译器为您添加协议存根，但是在任何情况下，我们都可以将我们的对象修改为:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="193c" class="nq md it nl b gy nr ns l nt nu">struct TShirt: Equatable, Comparable {<br/>    let shade: String<br/>    let size: Int</span><span id="83ba" class="nq md it nl b gy nz ns l nt nu">    static func == (lhs: TShirt, rhs: TShirt) -&gt; Bool {<br/>         return lhs.size == rhs.size<br/>    }<br/>  <br/>    static func &lt; (lhs: TShirt, rhs: TShirt) -&gt; Bool {<br/>         return lhs.size &lt; rhs.size<br/>    }<br/>}</span></pre><p id="70cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用以下方法对衣服数组进行排序:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="8141" class="nq md it nl b gy nr ns l nt nu">clothes.sorted()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="12c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">附件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f0f805448185b79acd4bd568ffc7dbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*RHnByC7eOSQvxdGuYVS3Rg.png"/></div></figure><p id="4185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想用Swift <code class="fe ni nj nk nl b">Class</code>做同样的实验，过程是相似的。如果希望声明多个属性相等，可以使用&amp; &amp;操作符，如果希望对多个属性进行排序，可以使用||操作符。</p><p id="12c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好用一个例子来说明这一点:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="9cb2" class="nq md it nl b gy nr ns l nt nu">class Animal: Equatable, Comparable {<br/>    let name: String<br/>    let type: String<br/>    let age: Int</span><span id="ca70" class="nq md it nl b gy nz ns l nt nu">    init(name: String, type: String, age: Int) {<br/>         self.name = name<br/>         self.type = type<br/>         self.age = age<br/>    }</span><span id="6a68" class="nq md it nl b gy nz ns l nt nu">    static func == (lhs: Animal, rhs: Animal) -&gt; Bool {<br/>          return lhs.name == rhs.name <br/>             &amp;&amp; lhs.type == rhs.type <br/>             &amp;&amp; lhs.age == rhs.age<br/>    }</span><span id="a0f6" class="nq md it nl b gy nz ns l nt nu">    static func &lt; (lhs: Animal, rhs: Animal) -&gt; Bool {<br/>          return lhs.name &lt; rhs.name ||<br/>             lhs.type &lt; rhs.type ||<br/>             lhs.age &lt; rhs.age<br/>    }</span></pre><p id="da2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道是动物，但动物很好，对吧？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8bac" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">向类型添加equatable和comparable相当容易。它确实提供了使代码更容易阅读的机会，上面的例子和解释给了你(我希望)这背后的一些概念，让你知道这是如何工作的，以及如何在你自己的代码中实现它。</p><p id="ec36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，快乐编码！</p></div></div>    
</body>
</html>