<html>
<head>
<title>JavaScript 201 — Reference Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 201 —引用类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-201-references-2c2fb4a6f250?source=collection_archive---------17-----------------------#2019-08-29">https://betterprogramming.pub/javascript-201-references-2c2fb4a6f250?source=collection_archive---------17-----------------------#2019-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6a2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">了解属性获取、属性分配、属性删除、</em><code class="fe kp kq kr ks b"><em class="ko">this</em></code><em class="ko">-绑定的关系</em></p><p id="3843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多编程语言中，点运算符(<code class="fe kp kq kr ks b">.</code>)通常被称为<strong class="js iu">属性访问符</strong>运算符。我们在C、Java、Python和JavaScript等语言中看到了这一点。例如，陈述的结果</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/764a969c8af1f242e300cde6cc1db5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*fDWGgO1uUAs4S_Ix8BSd6w.png"/></div></figure><p id="d413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取<code class="fe kp kq kr ks b">x</code>上“foo”属性的当前值，并将其放入变量<code class="fe kp kq kr ks b">y</code>。</p><p id="5e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是在JavaScript中，点运算符比简单的属性获取更微妙，这种微妙之处是<code class="fe kp kq kr ks b">delete</code>运算符和<code class="fe kp kq kr ks b">this</code>绑定等等背后的驱动因素。</p><p id="f8ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，点运算符表达式的结果是<em class="ko">而不是</em>简单地表示指定属性的当前值:如果是这样，下面的例子将是无意义的:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/5089df1fecc2e826946a1e8ca4c7396b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*HagD49nXkucT61qoskTquA.png"/></div></figure><p id="09f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述语句的意思是从<code class="fe kp kq kr ks b">x</code>中删除名为“foo”的属性。<em class="ko">不是</em>的意思是从系统中删除12的值。</p><p id="4b24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ECMAScript标准(JavaScript背后的语言定义)将<a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-property-accessors" rel="noopener ugc nofollow" target="_blank">属性访问器<strong class="js iu"> </strong>表达式</a>的结果定义为<a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-reference-specification-type" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="ko">引用</em> </strong> </a>。它不是保存一个简单的值，而是跟踪被访问的对象，这个对象被称为<strong class="js iu"> <em class="ko">基值</em></strong>(<code class="fe kp kq kr ks b">.</code>左边的值)<em class="ko"/>被访问属性的名称，被称为<strong class="js iu"> <em class="ko">引用名称</em></strong>(<code class="fe kp kq kr ks b">.</code>右边的名称)。</p><p id="9ec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引用是ECMAScript <em class="ko">规范类型</em>，这意味着您不能显式创建此类型的值，也不能在您的代码中直接使用此类型。它是运行时本身固有的，永远不会向您的代码公开——它只是运行时执行其他操作的一种机制。这些操作包括一些基本操作，例如:</p><ul class=""><li id="e5bf" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">属性获取</li><li id="c181" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">财产分配</li><li id="42f3" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">属性删除</li><li id="39a6" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated"><code class="fe kp kq kr ks b">this</code>-装订</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a55a" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">属性获取</h1><p id="f7c7" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这是显而易见的。引用类型用于从引用的<em class="ko">基值</em>中获取由<em class="ko">引用名</em>指示的属性的当前值。当引用出现在应该有值的位置时，运行时将对引用执行此操作，作为计算的一部分。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/3f35b7c06a0ac9ed5a7af965ca51565f.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*2lgV2iD0ME4eoEFp8QXsZg.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">y被赋值为12。</p></figure><h2 id="1813" class="nf lz it bd ma ng nh dn me ni nj dp mi kb nk nl mm kf nm nn mq kj no np mu nq bi translated">财产分配</h2><p id="db0b" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">当引用出现在<a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-assignment-operators-runtime-semantics-evaluation" rel="noopener ugc nofollow" target="_blank">赋值表达式</a>的左侧时，就会发生这种情况:运行时将表达式右侧的值赋给引用的<em class="ko">基值</em>上的<em class="ko">引用名</em>所指示的属性。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/94d5e00fe7077b1655e872ace8bab729.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*ius2F9N-9Y8KvJeEJfI4rg.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">x的“foo”属性被赋值为12。</p></figure><h2 id="80a8" class="nf lz it bd ma ng nh dn me ni nj dp mi kb nk nl mm kf nm nn mq kj no np mu nq bi translated">属性删除</h2><p id="d825" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">当使用<code class="fe kp kq kr ks b"><a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-delete-operator" rel="noopener ugc nofollow" target="_blank">delete</a></code> <a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-delete-operator" rel="noopener ugc nofollow" target="_blank">运算符</a>时，应用该操作:运行时将从引用的<em class="ko">基值</em>中删除被引用的<em class="ko">所指示的属性</em>。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/5089df1fecc2e826946a1e8ca4c7396b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*HagD49nXkucT61qoskTquA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">从x. 12中删除了“foo”属性，但它仍然存在。</p></figure><h2 id="33f0" class="nf lz it bd ma ng nh dn me ni nj dp mi kb nk nl mm kf nm nn mq kj no np mu nq bi translated"><code class="fe kp kq kr ks b">This-</code>装订</h2><p id="4ae7" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这就是事情变得有趣的地方。当一个函数被调用时，<em class="ko">如何为调用访问它是很重要的。考虑下面的片段:</em></p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9b6c58fd156aa5113ad682bbd114da52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*AjfhkxvznuhluESwu7EDAw.png"/></div></figure><p id="d036" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第七行，我们将来自<code class="fe kp kq kr ks b">x.frob</code>的函数存储到<code class="fe kp kq kr ks b">frob</code>变量中。这执行一个普通的<em class="ko">属性获取</em>操作，从<code class="fe kp kq kr ks b">x</code>获取“frob”属性的当前值，这恰好是一个函数。我们现在可以通过从<code class="fe kp kq kr ks b">x</code>的“foo”属性访问这个函数，如第八行所示，或者通过直接访问<code class="fe kp kq kr ks b">frob</code>变量，如第九行所示。</p><p id="fd20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，这两种访问方式<em class="ko">不同</em>，它们给出的<em class="ko">结果也不同</em>。这是因为第八行的<code class="fe kp kq kr ks b">x.frob</code>并不是一个简单的<em class="ko">属性获取</em>操作来产生当前值:相反，它是一个<a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-function-calls" rel="noopener ugc nofollow" target="_blank"> <em class="ko">函数调用表达式</em> </a>，其中被调用的函数由一个引用来指示，这使得函数被调用时<code class="fe kp kq kr ks b">this</code>被设置为引用的<em class="ko">基值</em>。</p><p id="71e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第九行，要调用的函数是引用所指示的<em class="ko">而不是</em>，因此调用<a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinarycallbindthis" rel="noopener ugc nofollow" target="_blank">函数，并将</a> <code class="fe kp kq kr ks b"><a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinarycallbindthis" rel="noopener ugc nofollow" target="_blank">this</a></code> <a class="ae lc" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ordinarycallbindthis" rel="noopener ugc nofollow" target="_blank">设置为<em class="ko">全局环境记录</em> </a>(例如，在浏览器运行时为<code class="fe kp kq kr ks b">window</code>)。</p><p id="793b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两行中被调用的函数是相同的，但是为调用设置<code class="fe kp kq kr ks b">this</code>的方式取决于如何访问该函数。</p><p id="2f27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数调用中<code class="fe kp kq kr ks b">this</code>的绑定变得更加复杂，比如<code class="fe kp kq kr ks b">apply</code>、<code class="fe kp kq kr ks b">bind</code>和<em class="ko">粗箭头函数</em>。这些细节超出了本文的范围，但仍然很重要。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c77a" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">为什么它很重要</h1><p id="3736" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">你也许可以通过执行<em class="ko">属性获取</em>、<em class="ko">属性赋值</em>和<em class="ko">属性删除</em>来实现，而无需考虑引用类型，但是因为JavaScript函数是一级对象(也就是说，它们可以像任何其他值一样被传递)，理解以不同方式使用它们的后果是至关重要的。</p><p id="a4a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您是将一个函数作为一个对象(以及什么对象)的属性来调用，还是作为一个空值来调用，这很重要，并可能导致非常不同的结果。理解引用为理解这些和相关概念如何工作提供了一个简单的模型，以避免混淆和错误。</p></div></div>    
</body>
</html>