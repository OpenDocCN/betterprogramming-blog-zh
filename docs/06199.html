<html>
<head>
<title>5 Alternatives to ‘If’ Statements for Conditional Branching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">条件分支的“If”语句的5种替代方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-alternatives-to-if-statements-for-conditional-branching-6e8e6e97430b?source=collection_archive---------2-----------------------#2020-09-09">https://betterprogramming.pub/5-alternatives-to-if-statements-for-conditional-branching-6e8e6e97430b?source=collection_archive---------2-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用JavaScript示例实现条件分支的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/13472f1fb4683ebd416b4d4b6c24875b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-QCT3HOdiHt1-uMxej3GTg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Booyabazookaoriginal的SVG巴布亚新几内亚由Wapcaplet / CC BY-SA</p></figure><p id="e124" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">条件</em> <em class="lq">分支</em>是基于条件执行或评估一段代码，通常使用<code class="fe lr ls lt lu b">if...else</code>构造来实现。</p><p id="c9d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="3c8f" class="lz ma it lu b gy mb mc l md me">if (customerPaid)<br/>{<br/>    sendThankYou()<br/>}<br/>else<br/>{<br/>    sendReminder();<br/>}</span></pre><p id="787c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，如果<code class="fe lr ls lt lu b">customerPaid</code>是<code class="fe lr ls lt lu b">true</code>，那么<code class="fe lr ls lt lu b">sendThankYou()</code>将被调用；否则<code class="fe lr ls lt lu b">sendReminder()</code>就会被召唤。</p><p id="c6b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在编程社区中有一些想法认为<code class="fe lr ls lt lu b">if</code>应该被认为是有害的或者代码气味。不管这种说法是否正确，可能会有这样的情况，即<code class="fe lr ls lt lu b">if</code>不是分支的最佳方法，或者应该完全避免分支。</p><p id="121e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在本教程中，我将展示六种<code class="fe lr ls lt lu b">if...else</code>的替代方案，并讨论何时可以选择使用它们。</p><p id="7089" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例是用JavaScript编写的，但是概念也适用于许多其他语言。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="948b" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">1.三元运算符</h1><p id="4dd8" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我最喜欢的<code class="fe lr ls lt lu b">if...else</code>的替代品之一是<em class="lq">三元运算符。</em></p><p id="622c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其形式如下:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="a95b" class="lz ma it lu b gy mb mc l md me">condition ? expressionIfTrue : expressionIfFalse</span></pre><p id="b73e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe lr ls lt lu b">condition</code>评估为<code class="fe lr ls lt lu b">true</code>，则<code class="fe lr ls lt lu b">expressionIfTrue</code>将被评估；否则将评估<code class="fe lr ls lt lu b">expressionIfFalse</code>。</p><p id="4a9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">三元运算符的美妙之处在于它们可以用在赋值的右边。</p><p id="ca38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7829" class="lz ma it lu b gy mb mc l md me">const labelText = customerPaid ? "Thank You!" : "Payment Overdue";</span></pre><p id="7eba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果客户已经付款，这将把<code class="fe lr ls lt lu b">labelText</code>设置为<code class="fe lr ls lt lu b">“Thank You!”</code>；否则你会得到<code class="fe lr ls lt lu b">“Payment Overdue”</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0ce7" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">2.<code class="fe lr ls lt lu b">Switch</code>声明</h1><p id="4ae3" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated"><code class="fe lr ls lt lu b">switch</code>语句的结构如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fce0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">break</code>语句是可选的，将导致<code class="fe lr ls lt lu b">switch</code>程序块退出。如果省略了<code class="fe lr ls lt lu b">break</code>，那么执行将进行到下一个<code class="fe lr ls lt lu b">case</code>语句。</p><p id="d9e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">switch</code>适用于基于一组同质值的分支。</p><p id="a9fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4c55" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">3.跳台</h1><p id="e311" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated"><em class="lq">跳转表</em>是一种使用查找表分支到新函数或块的条件分支方法。</p><p id="be62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从技术上讲，在C语言中，这将被实现为函数指针的<a class="ae mf" href="https://en.wikipedia.org/wiki/Branch_table#Jump_table_example_in_C" rel="noopener ugc nofollow" target="_blank">数组。然而，除非我们非常需要数组查找的效率，否则我们可以将其推广到任何类型的键控函数查找。</a></p><p id="026e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，上面的<code class="fe lr ls lt lu b">switch</code>语句可以重构为JavaScript中的跳转表，如下所示:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7175" class="lz ma it lu b gy mb mc l md me">const handleColour = <br/>{<br/>    'red'               : stop,<br/>    'amber'             : stop,<br/>    'green'             : go,<br/>    'flashing amber'    : go<br/>}</span></pre><p id="d9bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的<code class="fe lr ls lt lu b">stop</code>和<code class="fe lr ls lt lu b">go</code>是函数对象。让我们把它充实一下，以便弄清楚这种方法在上下文中是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们的代码基于<code class="fe lr ls lt lu b">colour</code>变量的值有条件地分支。语义与我们的<code class="fe lr ls lt lu b">switch</code>示例相同，但是我们的代码更少。而且(可以说)读起来更清晰。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="69e4" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">4.动态调度</h1><p id="0a33" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">使用<code class="fe lr ls lt lu b">if</code>语句的另一种选择是<em class="lq">动态分派。这包括根据对象的类型选择调用哪个<a class="ae mf" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态</a>方法。</em></p><p id="ed70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它可以用于有条件的分支，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a2c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，根据传递给<code class="fe lr ls lt lu b">handleShape</code>函数的对象类型，采用不同的代码路径。在我们的例子中，<code class="fe lr ls lt lu b">Shape</code>是一个<code class="fe lr ls lt lu b">Square</code>，因此该区域被记录为<code class="fe lr ls lt lu b">4</code>。</p><p id="e4b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法会产生更多的代码，但是对于它的用法有一些争论。当代码已经使用了<code class="fe lr ls lt lu b">OOP</code>时，这种模式通常是合适的；然而，试图总是使用多态性来设计分支似乎有些矫枉过正。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f3d9" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">5.<code class="fe lr ls lt lu b">try' and 'catch' statements</code></h1><p id="1d58" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我把这个包括进来是为了完整性，因为<code class="fe lr ls lt lu b">try</code> / <code class="fe lr ls lt lu b">catch</code>应该很少用于控制流。</p><p id="8577" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于为什么这是一个坏主意，已经有很多文章写了，但是我个人认为<code class="fe lr ls lt lu b">try</code> / <code class="fe lr ls lt lu b">catch</code>是为处理异常而设计的，所以通过将它们用于控制流，我们的意图就变得不清楚了。</p><p id="3f4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，这里有一个使用异常的条件分支的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3ff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，<code class="fe lr ls lt lu b">item</code>将被赋值给<code class="fe lr ls lt lu b">previousItem</code>，如果它存在的话；否则，将抛出一个<code class="fe lr ls lt lu b">ReferenceError</code>异常，并分配一个新的<code class="fe lr ls lt lu b">Item</code>对象。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9faf" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">6.模式匹配</h1><p id="cd3b" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">当谈到分支时，模式匹配是一个新的领域。它通常受到那些喜欢更函数式编程风格的人的欢迎。</p><p id="081e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模式匹配可以被认为是基于值而不是类型的动态分派(见上文)。</p><p id="d744" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个经典的例子是使用两个函数实现一个<a class="ae mf" href="https://en.wikipedia.org/wiki/Factorial" rel="noopener ugc nofollow" target="_blank">阶乘</a>函数:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8469" class="lz ma it lu b gy mb mc l md me">factorial(0) ::= 1<br/>factorial(n) ::= n * factorial(n-1)</span></pre><p id="6598" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果传入的值为零，则调用第一个函数，在这种情况下，返回<code class="fe lr ls lt lu b">1</code>。如果传入的值是非零的，则调用第二个函数——在这种情况下，返回表达式<code class="fe lr ls lt lu b">n * factorial(n-1)</code>的结果。</p><p id="5ff1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些语言内置了模式匹配。在JavaScript中，需要使用外部库—例如，<a class="ae mf" href="https://z-pattern-matching.github.io" rel="noopener ugc nofollow" target="_blank">Z(JavaScript的模式匹配</a>)。</p><p id="a638" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阶乘函数可以用Z写成如下:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="e1e5" class="lz ma it lu b gy mb mc l md me">var factorial = number =&gt; {<br/>  return number.matches (<br/>    (x = 0) =&gt; 1,<br/>    (x)     =&gt; x * factorial (x - 1)<br/>  )<br/>}<br/> <br/>factorial(6) // returns 720</span></pre><p id="7966" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以说，在JavaScript中计算阶乘有更具可读性和表达性的方法，但是模式匹配作为一种条件执行方式的潜力远远超出了这个简单的例子。</p><p id="eb1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一个<a class="ae mf" href="https://ponyfoo.com/articles/pattern-matching-in-ecmascript" rel="noopener ugc nofollow" target="_blank">提议</a>在JavaScript语言中构建一个模式，值得一读。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="009b" class="mn ma it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="55c3" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">条件分支会给程序带来复杂性。</p><p id="b924" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嵌套的<code class="fe lr ls lt lu b">if</code>和<code class="fe lr ls lt lu b">switch</code>语句会降低代码的可读性，并可能导致错误。其他形式的分支会导致过度工程化的代码库。如果有可能完全避免分支，这通常是一个好的起点。</p><p id="955f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果我们确实需要有条件的分支，最好选择最合适的工作机制。希望在这篇文章中，我提供了一些有用的选项供参考。</p></div></div>    
</body>
</html>