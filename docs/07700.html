<html>
<head>
<title>3 Simple Ways To Get an English Weekday Name in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python获得英文工作日名称的3种简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-simple-ways-to-get-an-english-weekday-name-in-python-3ce2c7da8f55?source=collection_archive---------9-----------------------#2021-02-10">https://betterprogramming.pub/3-simple-ways-to-get-an-english-weekday-name-in-python-3ce2c7da8f55?source=collection_archive---------9-----------------------#2021-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python获取日期是一项简单的任务。然而，获取工作日名称(用简单的英语)并不简单。幸运的是，有一些简单的方法可以返回用户友好的日期名称。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c484f14441bddc0d819eb3b15c682ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPzb_WeEbiPrep8RzhyG4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片来自</em> <a class="ae kz" href="https://www.overcoded.net/python-datetime-weekday-name-482616/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">过度编码</em> </a> <em class="ky">。</em></p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="ee08" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">获取日期和工作日</h1><p id="7ab9" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在我们了解如何获取工作日名称之前，让我们考虑一下Python的<code class="fe mv mw mx my b">datetime</code>类是如何获取日期并随后确定该日期是星期几的。这没什么特别的，但是知道你从哪里开始是值得的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="766b" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">这段代码说明了在你必须开始变得有创造性之前，<code class="fe mv mw mx my b">datetime</code>类将带你走多远。在我们继续之前，有两件事值得注意:</p><ul class=""><li id="5c99" class="ng nh it mb b mc nb mf nc mi ni mm nj mq nk mu nl nm nn no bi translated"><code class="fe mv mw mx my b">weekday</code>方法将值<code class="fe mv mw mx my b">0</code>赋给星期一。</li><li id="38ea" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">另一种方法是<code class="fe mv mw mx my b">isoweekday</code>，将值<code class="fe mv mw mx my b">1</code>赋给周日。</li></ul><p id="e82b" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">查看官方<code class="fe mv mw mx my b"><a class="ae kz" href="https://docs.python.org/3/library/datetime.html#datetime.datetime.weekday" rel="noopener ugc nofollow" target="_blank">datetime.weekday</a></code>文档了解更多信息。既然我们知道了如何获取给定的<code class="fe mv mw mx my b">datetime</code>对象的星期几的整数表示，我们可以开始计划如何生成一个简单的英文版本。下面是三种方法<a class="ae kz" href="https://www.overcoded.net/most-popular-programming-languages-184015/" rel="noopener ugc nofollow" target="_blank">，按照依赖关系的顺序</a>排列。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="15e9" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">1.手动操作</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9ea2" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">这种方法提供了动态调整工作日命名和排序的灵活性。需要截断日期名称吗？只需编辑列表。需要从周日开始？只是重新安排一下。因为某种奇怪的原因需要倒榜？就<code class="fe mv mw mx my b">reverse</code>吧！</p><h2 id="f530" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated">赞成的意见</h2><ul class=""><li id="2512" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">没有添加依赖项</li><li id="0aaa" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">没有需要记住的附加方法</li><li id="ca1d" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">变化的灵活性</li><li id="fb40" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">代码中的显式表示</li></ul><h2 id="0d11" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated">骗局</h2><ul class=""><li id="d924" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">更多打字</li><li id="0662" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">不能立即抵制复制问题(即在整个项目中使用它)</li><li id="546a" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">对错别字的恐惧</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="ca60" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">2.使用Strftime</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ea06" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">这种方法可以说是最简洁的。这是一个<em class="oj">合理的</em>一行程序，不会偏离<code class="fe mv mw mx my b">datetime</code>类，并且一旦您熟悉了<code class="fe mv mw mx my b"><a class="ae kz" href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" rel="noopener ugc nofollow" target="_blank">strftime</a></code> <a class="ae kz" href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" rel="noopener ugc nofollow" target="_blank">文档</a>，它会提供一些灵活性。</p><h2 id="b6a8" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="cb2d" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">没有额外的依赖</li><li id="b041" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">可能是一行程序</li><li id="ad91" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">半柔性的</li><li id="f8d7" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">不怕错别字</li><li id="2e6a" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">易于在项目范围内集成</li></ul><h2 id="1191" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated"><strong class="ak"> Con </strong></h2><ul class=""><li id="b201" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">需要熟悉<code class="fe mv mw mx my b">strftime</code>才能改变格式</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="8051" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">3.日历模块</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9172" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">这实际上只是一种迂回的方式，以达到与第一种方法相同的结果。这里的额外好处是其他人管理工作日列表(在这种情况下，这并不是真正的负担。)这个<code class="fe mv mw mx my b">calender.day_name</code>对象只是一个所有工作日名称的奇特列表。索引到该对象与索引到手动列表是一样的。</p><h2 id="4213" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated">赞成的意见</h2><ul class=""><li id="83d8" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">内置模块</li><li id="1598" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">轻量级依赖</li><li id="c6f4" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">使用本机Python语法进行索引</li></ul><h2 id="9d7d" class="nu li it bd lj nv nw dn ln nx ny dp lr mi nz oa lt mm ob oc lv mq od oe lx of bi translated">骗局</h2><ul class=""><li id="fdd1" class="ng nh it mb b mc md mf mg mi og mm oh mq oi mu nl nm nn no bi translated">额外依赖性</li><li id="13d7" class="ng nh it mb b mc np mf nq mi nr mm ns mq nt mu nl nm nn no bi translated">语法可以更简单</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="634b" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">最后的想法</h1><p id="8bd1" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">当我第一次学习编码时，最让我吃惊的是管理时间和日期是多么复杂。月份、闰年的细微长度差异，将<code class="fe mv mw mx my b">strings</code>转换为<code class="fe mv mw mx my b">datetimes</code>——这看起来像是为了这样一个外围任务而涉入深水区。</p><p id="06fd" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">将计算机友好的日期表示(如纪元时间戳)转换为用户友好的表示是另一项令人烦恼的艰巨任务。在这种情况下，Python的<code class="fe mv mw mx my b">datetime</code>类使得以整数值形式获取工作日变得很简单。之后就全是句法糖了！就我个人而言，我更喜欢第二种方法，因为它让一切都与<code class="fe mv mw mx my b">DateTime</code>模块紧密耦合。</p><p id="4e70" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated"><em class="oj">本文原载于</em><a class="ae kz" href="https://www.overcoded.net/python-datetime-weekday-name-482616/" rel="noopener ugc nofollow" target="_blank"><em class="oj"/></a><em class="oj">，经许可在此转载。</em></p></div></div>    
</body>
</html>