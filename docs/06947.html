<html>
<head>
<title>How to Build Desktop Applications the Right Way Using Electron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用电子构建桌面应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-desktop-applications-the-right-way-using-electron-aee5deedeb8c?source=collection_archive---------4-----------------------#2020-11-19">https://betterprogramming.pub/how-to-build-desktop-applications-the-right-way-using-electron-aee5deedeb8c?source=collection_archive---------4-----------------------#2020-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6aea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用电子启动你的下一个项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02e7b8f1b5779ad202e2798952971425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi8PtUBSlhshsPU6ZHJj5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>。</p></figure><p id="5a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你像我一样，喜欢JavaScript及其生态系统，并且一直在使用React或<a class="ae ky" href="https://bajcmartinez.medium.com/when-you-should-and-shouldnt-use-node-js-for-your-project-2e141dc118b6" rel="noopener">performant web server with node . js</a>之类的框架构建令人惊叹的web应用程序。现在你想开发一个桌面应用程序，又不想学习新的编程语言。或者您可能希望尽可能多地重用现有的web项目。</p><p id="68e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是当<a class="ae ky" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>进入画面，以拯救世界。</p><p id="5006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Electron允许您使用HTML、CSS和JavaScript构建桌面应用程序。互联网上有许多反对Electron的论点，其中一些是它的性能和经常是低质量的应用程序，但不要责怪框架。电子是强大的，可以表演。如今，许多流行的应用程序都运行在Electron之上，如VS Code、Slack、Skype、Discord等等。</p><p id="919a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么那么多人反对呢？问题始于应用程序和人们使用电子产品的方式。对许多人来说，将web应用程序移植到Electron意味着将您现有的代码原封不动地嵌入到Electron容器中。这是一件可怕的事情吗？也许不是，但是你没有充分利用电子的力量。您只是在为一个独立的应用程序更改浏览器选项卡。</p><p id="9cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能改进什么？在本文中，我们将探索电子的基础知识，并构建一个示例应用程序来展示一些电子方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a0d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">电子是如何工作的？</h1><p id="796c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">电子建立在三个主要组件之上:</p><ul class=""><li id="09bc" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Chromium:负责网页内容。</li><li id="8dae" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">节点:用于与操作系统交互。</li><li id="675a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">自定义API:解决处理操作系统时的常见问题。</li></ul><p id="58eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些组件中的每一个都在电子体系结构层的不同级别上相互作用，如体系结构图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/22a852f6cdc023d883276634db09f71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5G9BFD2ItXo6lv2pinEJrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">电子建筑</p></figure><p id="b7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电子与两种类型的过程一起工作:</p><ul class=""><li id="6655" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">主进程:负责窗口管理和所有与操作系统的交互。这是一切开始的地方，它可以创建和管理多个渲染器进程。</li><li id="2a07" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">渲染器进程:可能有一个或多个。每个都将托管一个Chromium实例，并负责web内容。</li></ul><p id="0eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，渲染器进程不能直接访问操作系统功能。相反，它们通过IPC与主进程通信来完成这些任务。</p><p id="16ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多典型的电子应用程序会使用main进程来创建一个renderer进程并加载它们的web应用程序。今天，我们将更进一步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="86b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">必备部分:Hello World！</h1><p id="9451" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们要建立一个“hello world！”申请。我们将不会使用任何框架或库，这对于专注于电子代码是不必要的。</p><p id="ed86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><h2 id="c520" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">设置电子</h2><p id="ecca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">构建应用程序的第一步是创建一个项目并安装电子库，所以从使用NPM创建项目开始:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="c8f1" class="no md it ob b gy of og l oh oi">npm init</span></pre><p id="df2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并设置您的应用程序详细信息。作为应用程序的起点，我喜欢使用<code class="fe oj ok ol ob b">main.js</code>，但是您可以使用任何您想要的文件名。</p><p id="8e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，安装电子设备:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="384e" class="no md it ob b gy of og l oh oi">npm install -D electron@latest</span></pre><h2 id="6a75" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">构建屏幕</h2><p id="88ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于我们的微型hello world示例，我们需要两个文件:<code class="fe oj ok ol ob b">main.js</code>和<code class="fe oj ok ol ob b">hello-world.html</code>。<code class="fe oj ok ol ob b">main.js</code>是我们的主要流程。我们将创建第一个渲染器进程来加载我们的<code class="fe oj ok ol ob b">hello-world.html</code>。</p><p id="fff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe oj ok ol ob b">main.js</code>的启动代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初学者工具包将处理运行应用程序的最少操作，用<code class="fe oj ok ol ob b">new BrowserWindow</code>创建第一个渲染器，并在其上加载<code class="fe oj ok ol ob b">main.html</code>。它还将解决一些退出应用程序并在需要时重新启动主窗口的情况。</p><p id="04af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于我们的<code class="fe oj ok ol ob b">main.html</code>，我们将使用如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="77dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的HTML，展示了我们的应用程序使用的Node、Chrome和Electron的当前版本。</p><p id="975c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要运行我们的应用程序。首先，您需要更改<code class="fe oj ok ol ob b">package.json</code>并添加启动脚本:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="bf8f" class="no md it ob b gy of og l oh oi">"scripts": {<br/>    "start": "electron .",<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },</span></pre><p id="098d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的“脚本”部分现在应该是这样的。</p><p id="9029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候测试一下了！在终端上，运行:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="987f" class="no md it ob b gy of og l oh oi">npm start</span></pre><p id="8959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，您应该会看到这样一个窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/f0b238feb17d0f42ba13ad9a99db62f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avUieDUlSxXUr18xE3lmrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用电子制作的Hello World app</p></figure><h2 id="c4b8" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">没有更简单的方法吗？</h2><p id="c58a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简短的回答是肯定的，尽管这是有代价的。许多样板文件为构建电子应用程序提供了一个起点——其中一些使用vanilla JS，另一些则直接集成了一些最流行的框架，如React和Vue。</p><p id="59f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不太喜欢这些样板文件，因为它们通常附带了许多我不需要的库和附件。但是它们是让你开始的好地方。</p><p id="4fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些受欢迎的:</p><ul class=""><li id="258f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://www.electronforge.io/" rel="noopener ugc nofollow" target="_blank">电子锻造</a></li><li id="0c9a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/electron-userland/electron-builder" rel="noopener ugc nofollow" target="_blank">电子生成器</a></li><li id="dadc" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/electron-react-boilerplate/electron-react-boilerplate" rel="noopener ugc nofollow" target="_blank">电子反应样板</a></li><li id="b8b3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/SimulatedGREG/electron-vue" rel="noopener ugc nofollow" target="_blank">电子眼</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c2e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建流畅的应用程序</h1><p id="8b50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经看到了电子结构的工作原理。如果你像我一样，你可能会担心Chromium和Node运行的所有实例——你应该担心。我们都知道铬(或Chrome)如何吞噬我们的内存并影响我们的性能，那么我们如何才能避免基于铬的应用程序这样做呢？我们如何保持它的性能？</p><p id="8638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些建议。</p><h2 id="9292" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">永远不要阻塞主进程</h2><p id="c1e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">主要流程是一切开始的地方。它是应用程序所有进程的父进程。它与操作系统通信，处理所有窗口和它们之间的通信，并运行UI线程。</p><p id="81cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阻止此进程意味着应用程序将停止响应，直到操作完成。在任何情况下，您都不应该运行占用大量CPU资源并且需要很长时间才能完成的代码。</p><p id="a380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些建议:</p><ul class=""><li id="9801" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">对于CPU密集型操作，将这些功能委托给一个工作线程、一个渲染器进程，或者甚至衍生一个专用进程来执行该任务(不过要确保您知道自己在为最后一个任务做什么)。</li><li id="f897" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">尽可能避免使用<code class="fe oj ok ol ob b">remote</code>模块。使用<code class="fe oj ok ol ob b">remote</code>模块很容易在不知不觉中阻塞UI线程。</li><li id="b568" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">避免在主线程上使用阻塞I/O操作。如果需要，使用Node提供的异步对等项。</li></ul><h2 id="8fc0" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">阻止渲染器进程可以吗？</h2><p id="4464" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不完全是。也许后果不会像阻塞主进程那样有害，但是阻塞渲染器是有代价的。您的windows可能会变得缓慢或无响应，整体用户体验将非常糟糕。</p><p id="833b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用网络时，我们习惯了一些网络应用程序突然变慢，不流畅，我们对此没有意见。然而，当涉及到桌面应用程序时，我们的标准更高。请注意这一点，因为用户的期望很重要。</p><p id="84bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能做些什么来提高我的应用程序的响应速度？就像我们可以在网络应用上做的一样。毕竟，在渲染器过程中，我们只是在谈论铬。</p><ul class=""><li id="0469" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe oj ok ol ob b">requestIdleCallback</code>:这是一个API，允许JavaScript的执行在空闲浏览器时间排队运行，要么在一帧结束，要么在用户不活动的时候。</li><li id="bb0d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Web workers:通过将计算分配给一个新线程，在Web浏览器上运行昂贵计算的最佳工具。</li></ul><h2 id="03f7" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">你不需要跨浏览器兼容性</h2><p id="16bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在web开发过程中，使用polyfills来支持不同的浏览器是非常典型的。当构建电子应用时，你不需要这些。如果它运行在Chromium上，它就运行在Electron上，不需要支持任何其他浏览器。通过不加载这些额外的模块，减少您的包并使一切更快。</p><h2 id="7f86" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">捆绑你所有的代码</h2><p id="b908" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在web开发中，我们有时会从cdn等服务器上加载脚本或页面，这些服务器与我们的应用程序是分开提供的——这很好。毕竟，对于web，我们总是需要下载这些资产来运行应用程序。</p><p id="23c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于桌面应用程序，这是不同的。通过在应用程序中捆绑所有静态资产、脚本和内容，避免任何不必要的网络请求。这将使你的应用程序做两件事:离线工作和加快加载过程，因为读取磁盘比上网便宜。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dbdd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下次您需要构建跨平台的桌面应用程序时，我建议您尝试使用electronic——尤其是如果您是JavaScript出身，并且已经有了一些可以重用的代码。</p><p id="2663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用得当，电子可以发挥巨大作用。请记住，虽然它看起来像web，但它并不完全是web，因此您需要做一些特殊的考虑才能使它工作。</p><p id="1140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>