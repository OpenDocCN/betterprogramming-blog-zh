<html>
<head>
<title>Modeling Relationships in MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在MongoDB中建模关系</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modeling-relationships-in-mongodb-b69b93181c48?source=collection_archive---------3-----------------------#2020-09-07">https://betterprogramming.pub/modeling-relationships-in-mongodb-b69b93181c48?source=collection_archive---------3-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一致性和性能之间的权衡</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83fa180874d790fa5170d5f0a412a8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*83KXkuFFJ6QEjwpM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jakob Owens 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB 是一个无模式的NoSQL数据库，处理文档和集合。与SQL数据库不同，MongoDB可以以JSON格式存储文档，并且其结构可以变化，从而强调系统的高可扩展性和降低部署的复杂性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a962" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关对象</h1><p id="9a5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在关系数据库中，关系加强了数据的完整性。但是在MongoDB和其他NoSQL数据库中，文档之间没有关系。因此，文档是独立的。但是，有一些方法可以对文档之间的这些关系进行建模。</p><p id="685b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">场景:</em> <strong class="lb iu"> <em class="mz"> </em> </strong> <em class="mz">最近在做一个电子钱包的app，这里有一个简单的功能可以更好的理解。这款应用允许用户在电子钱包中存储一张或多张银行卡。</em></p><p id="1363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于这个场景中提到的一对多关系，让我们探索在MongoDB中建模关系的可能方法。</p><h2 id="90ca" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">使用引用</h2><p id="4af3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种方法叫做<em class="mz">归一化</em>。为了实现这一点，我们将为用户和银行卡建立两个独立的集合，如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="27d8" class="na md it nn b gy nr ns l nt nu">let bankCard = {<br/>    id:'',<br/>    number:''<br/>}</span><span id="1c38" class="na md it nn b gy nv ns l nt nu">let user: {<br/>    id:'', <br/>    name:'', <br/>    bankCard:'id'<br/>}</span></pre><p id="ecc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，除了<code class="fe nw nx ny nn b">user</code>对象的属性之外，<code class="fe nw nx ny nn b">bankCard</code>对象的ID作为对<code class="fe nw nx ny nn b">user</code>对象中的<code class="fe nw nx ny nn b">bankCard</code>对象的引用被传递。</p><p id="d9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这些文档是独立的，即使我们通过<code class="fe nw nx ny nn b">id</code>属性引用银行卡文档。他们之间没有关系。</p><p id="e6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照这个场景，一个用户可能有不止一张银行卡。因此，我们用id数组替换用户文档中的<code class="fe nw nx ny nn b">bankCard</code>属性，如下所示:<code class="fe nw nx ny nn b">bankCards:[‘id1’, ‘id2’, ‘id3']</code>。</p><p id="403a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种方法类似于关系数据库，数据操作集中在一个点上，因此提高了数据的一致性。</p><h2 id="4297" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">使用嵌入文档</h2><p id="c250" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种方法叫做<em class="mz">反规格化</em>。为了实现这一点，我们必须将银行卡对象嵌入到<code class="fe nw nx ny nn b">user</code>对象中。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="320d" class="na md it nn b gy nr ns l nt nu">let user = {<br/>    id:'', <br/>    name:'',</span><span id="afcd" class="na md it nn b gy nv ns l nt nu">bankCard: {<br/>        id: '',<br/>        number:'',<br/>    }<br/>}</span></pre><p id="d92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe nw nx ny nn b">user</code>对象有自己的属性。除此之外，它将包含<code class="fe nw nx ny nn b">bankCard</code>对象及其各自的属性。</p><p id="567b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于用户有多张银行卡的情况，可以用银行卡对象的数组:<code class="fe nw nx ny nn b">bankCards:[{id:’id1’, number:’’}, {id:’id2’, number:’’}]</code>替换<code class="fe nw nx ny nn b">bankCard</code>对象。</p><p id="1265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将一个文档嵌入到另一个文档中，我们可以提高系统的查询性能，从而节省时间并提高速度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1dcc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">权衡取舍</h1><p id="6a62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您有SQL背景，您很可能偏向于使用引用，而有些人可能更喜欢嵌入文档的方法。但是你不能同时拥有两种方法。</p><p id="e302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法各有利弊。因此，您需要在一致性和查询性能之间进行权衡。</p><h2 id="7cad" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">一致性</h2><p id="a540" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用引用时，与嵌入的文档相比，文档更整洁，不那么拥挤。因此，我们有两份干净和独立的文件。</p><p id="280c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法类似于关系数据库的方法。因此，假设我们想要更新一个特定的文档。我们只有一个地方需要修改。因此，这种做法是一致的。</p><p id="86f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，为了加载数据，我们可能必须运行额外的查询，从而降低查询性能。有时，在某些情况下，您必须快速运行查询，在这种情况下，不建议继续使用引用。</p><h2 id="87ea" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">查询性能</h2><p id="df77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当嵌入文档时，我们有一个包含两个文档所有细节的单一文档。嵌入文档的最大优势之一是，您可以在一次查询中加载用户详细信息和银行卡详细信息，从而提高速度和查询性能。</p><p id="195b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，文档可能看起来很拥挤——特别是当文档本身有很多属性时。</p><p id="81cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设对子文档进行了更新或更改。风险很大，因为有时会有更多的文档需要更新。如果在任何时候更新失败，一些部分将不会被更新。所以数据不一致。这是应用这种技术时最大的缺点之一。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="806b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">混合方法</h1><p id="d73e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">考虑到上面提到的问题，在开发复杂的应用程序时，文档可能会有许多属性(每个属性超过50个)。在这种情况下，引用或嵌入是不够的，会直接影响系统的性能。</p><h2 id="08fc" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">概念</h2><p id="06b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在混合方法中，创建两个文档(用户和银行卡),每个文档都有自己的属性列表。然后，提取子文档(银行卡)的<em class="mz">必要的</em>属性，并嵌入到用户文档中:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a326" class="na md it nn b gy nr ns l nt nu">let bankCard = {<br/>    id:'',<br/>    name:'',<br/>    number:'', <br/>    expiry:''<br/>}</span><span id="b23c" class="na md it nn b gy nv ns l nt nu">let user = {<br/>    id:'', <br/>    name:'',<br/>    dob:'',<br/>    <br/>    bankCard: {<br/>        id: 'ref',<br/>        number:'',<br/>    }<br/>}</span></pre><p id="ecc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，银行卡有一个单独的文档，只有银行卡文档的必要属性被提取出来，并作为其他<code class="fe nw nx ny nn b">user</code>属性中的一个对象放在用户文档中。因此，这避免了将银行卡的所有属性存储在子文档中的需要。</p><p id="d7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于子文档只具有必要的属性，这种方法会影响整个系统的优化查询性能和一致性。</p><h2 id="7801" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">应用</h2><p id="fcfe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发电子商务应用程序时，数据库中会有以下文档:产品、订单、购物车等。下订单时，您将需要产品的快照和某些细节，例如给定时间点的产品名称和价格。</p><p id="cef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种需要数据快照的情况下，建议使用混合方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a6e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">讨论了利弊之后，考虑到应用程序和查询需求，最佳方法完全由您决定。因此，您必须预先决定查询，并基于查询设计关系，以进行权衡。关于建模关系的更多信息可以在<a class="ae ky" href="https://docs.mongodb.com/manual/core/data-modeling-introduction/" rel="noopener ugc nofollow" target="_blank"> MongoDB的文档</a>中找到。</p><p id="401e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章已经教会了你如何在MongoDB中建模关系。享受学习和编码的乐趣！</p></div></div>    
</body>
</html>