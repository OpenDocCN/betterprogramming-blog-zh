<html>
<head>
<title>How to Write a Bash Script to Create and Update a Changelog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写Bash脚本来创建和更新Changelog</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-bash-script-to-create-and-update-a-changelog-de4df98985ab?source=collection_archive---------5-----------------------#2022-04-20">https://betterprogramming.pub/how-to-write-a-bash-script-to-create-and-update-a-changelog-de4df98985ab?source=collection_archive---------5-----------------------#2022-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再有生成器、日志或依赖项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f62f31e03f1632eb4c1d1340546702cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TF41GE3B9jE_O9qKeqzdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·高尔在<a class="ae ky" href="https://unsplash.com/s/photos/notebook-ledger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<a class="ae ky" href="https://keepachangelog.com/en/1.0.0/#:~:text=Why%20keep%20a%20changelog%3F,or%20version)%20of%20the%20project." rel="noopener ugc nofollow" target="_blank">变更日志</a>是一个有用的工具，向其他贡献者和用户展示你的项目做了什么更新，什么时候，以及那些更新需要什么。虽然你可能认为保持一个变更日志是乏味的或费时的，但从长远来看，它可以提供更多的信息并提高责任感。</p><p id="fdfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果可以的话，减少一些花在你的变更日志上的时间是很好的。这就是我创建自己的bash脚本来创建和更新自己的changelog时想要做的事情。</p><p id="2509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些预先存在的生成变更日志的方法，但是它们要么在清晰度方面不太符合我的要求(例如包括git标签提供的版本号)，要么包含了太多的信息。我所说的太多信息是指这些其他生成方法从您的git日志中获取您的所有提交，并以一种更有组织的方式列出它们。</p><p id="3f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的技巧，但我想创建一个更谨慎的变更日志，而不是简单地重新组织我的各种提交。</p><blockquote class="lw"><p id="3f0a" class="lx ly it bd lz ma mb mc md me mf lu dk translated">更改日志条目的目的是记录值得注意的差异，通常是在多次提交之间，以便向终端用户清楚地传达这些差异</p><p id="eb28" class="lx ly it bd lz ma mb mc md me mf lu dk translated">—保留变更日志</p></blockquote><h2 id="14ba" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">我们的变更日志</h2><p id="9377" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用我们自己的脚本来生成changelog允许灵活地决定包含什么信息以及它应该是什么样子。在本帖中，我们将生成一个基本结构如下的changelog。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/f10e07ff901a5227e4f74edf8611ad6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcQEvWhMlp_Lok_H-B1zmg.png"/></div></div></figure><p id="8cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的项目的变更日志不需要看起来像这样，但是我喜欢它，因为它遵循了<a class="ae ky" href="https://keepachangelog.com/en/1.0.0/#:~:text=Why%20keep%20a%20changelog%3F,or%20version)%20of%20the%20project." rel="noopener ugc nofollow" target="_blank">保持变更日志</a>的惯例，并且提供了大量的信息而不会让人不知所措。变更日志的每个点都包含版本号，后跟ISO格式的日期。在每一个下面都有一个与所做的更改相关的部分，比如添加、修复和删除(这些是我个人最常用的更改类型)。有关这些约定的更多信息，请参见“保持常日志”倡议。</p><p id="2227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们开始用bash生成我们的第一个Changelog。</p><p id="3231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目目录的根目录下，为changelog逻辑创建一个bash shell脚本文件。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7604" class="mg mh it ng b gy nk nl l nm nn">root:~ &gt; touch changelog.sh</span></pre><p id="0973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了您的shell脚本文件，我们只需在我们的终端中运行这个命令就可以使它可执行。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0d66" class="mg mh it ng b gy nk nl l nm nn">root:changelog-script &gt; chmod u+x changelog.sh</span></pre><p id="5fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行的作用是让我们只需在命令行中键入文件名，按enter键，然后执行它包含的脚本。现在我们可以开始研究我们的逻辑了。我们将编写三个函数:<code class="fe no np nq ng b">new_changelog</code>、<code class="fe no np nq ng b">new_changelog_item</code>和<code class="fe no np nq ng b">init</code>。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="75f2" class="mg mh it ng b gy nk nl l nm nn">new_changelog()<br/>{<br/>  echo 'new changelog'<br/>}</span><span id="b016" class="mg mh it ng b gy nr nl l nm nn">new_changelog_item()<br/>{<br/>  echo 'adding changelog item'<br/>}</span><span id="bb83" class="mg mh it ng b gy nr nl l nm nn">init()<br/>{<br/>  echo 'initiate script'<br/>}</span></pre><p id="14bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们脚本的目标是，当我们执行shell脚本(用户键入<code class="fe no np nq ng b">./changelog.sh</code>并点击enter)时，脚本将确定我们是否需要在添加项目之前创建一个changelog。如果changelog不存在，创建它，然后添加第一项。如果确实存在，只需添加一个新的changelog项目—仅当当前版本不存在changelog项目时。</p><p id="c422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后会详细介绍。</p><p id="740b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们初始化一个重要的变量:<code class="fe no np nq ng b">changelog</code>。这个变量将位于我们脚本的顶部，顾名思义，它将引用我们的changelog文件。将<code class="fe no np nq ng b">changelog=CHANGELOG.md</code>添加到文件的顶部。一旦在脚本文件中，我们可以更新我们的<code class="fe no np nq ng b">init</code>函数来检查文件是否存在。如果是，那么简单地添加一个新项目。如果没有，我们需要先创建它，然后添加一个新项目。如果一个文件存在于我们的项目中，我们如何告诉<em class="lv">？</em></p><p id="3f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">我们可以在我们的</a> <code class="fe no np nq ng b"><a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">init</a></code> <a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">函数中实现一个</a> <code class="fe no np nq ng b"><a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">if</a></code> <a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">语句。</a></p><p id="2bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要检查的条件是<code class="fe no np nq ng b">if test -f "$changelog"</code>。这一行使用内置的<code class="fe no np nq ng b">test</code>命令，该命令用于测试文件的属性并执行其他操作。<code class="fe no np nq ng b">-f</code>操作符只是告诉条件寻找一个文件，并检查它是否是一个正常的文件(不是一个目录或外部设备)。现在让我们看看更新后的<code class="fe no np nq ng b">init</code>函数，我们已经知道如何检查文件是否存在。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="94c6" class="mg mh it ng b gy nk nl l nm nn">init()<br/>{<br/>  if test -f "$changelog" ; then<br/>    echo "$changelog exists."<br/>  else<br/>    echo "$changelog does not exist."<br/>  fi<br/>}</span></pre><p id="6b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，第一部分完成了。现在，我们需要工作在我们的其他功能，将取代这些<code class="fe no np nq ng b">echo</code>行。第一个是<code class="fe no np nq ng b">new_changelog</code>。这一个将需要最少的努力，因为所有我们需要做的是使文件。如何在bash中制作一个文件？我们所要做的就是使用<code class="fe no np nq ng b">echo</code>，然后指示这个回显输出应该被定向到一个新文件中。我们通过使用<code class="fe no np nq ng b">&gt;</code>来做到这一点，它是一个<a class="ae ky" href="https://unix.stackexchange.com/questions/122977/what-is-the-correct-name-for-the-command" rel="noopener ugc nofollow" target="_blank">文件描述符重定向</a>。让我们来看看实际情况。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d070" class="mg mh it ng b gy nk nl l nm nn">new_changelog()<br/>{<br/>  echo "here is my changelog" &gt; CHANGELOG.md<br/>}</span></pre><p id="d969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在您的项目目录中创建一个changelog文件。我个人喜欢在我的Changelog文件中包含Keep A Changelog标题。所以我们可以用下面的代码替换<code class="fe no np nq ng b">'here is my changelog'</code>。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2b32" class="mg mh it ng b gy nk nl l nm nn">"# Changelog<strong class="ng iu"><br/></strong>All notable changes to this project will be documented in this file.</span><span id="1d12" class="mg mh it ng b gy nr nl l nm nn">The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),<br/>and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).</span><span id="da50" class="mg mh it ng b gy nr nl l nm nn">## [Unreleased]"</span></pre><p id="900c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美。如果我们的<code class="fe no np nq ng b">init</code>条件发现一个changelog不存在，我们的<code class="fe no np nq ng b">new_changelog</code>函数将创建一个。我们差不多完成了，但是我认为我们应该为开发者节省一个额外的步骤。我的意思是，不是在这里结束脚本，让开发者再运行一次<em class="lv"/>来添加新的changelog项，我们只是在<code class="fe no np nq ng b">new_changelog</code>的末尾调用<code class="fe no np nq ng b">new_changelog_item</code>。这意味着我们需要开始<code class="fe no np nq ng b">new_changelog_item</code>的工作。</p><p id="fea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个函数中，我们需要做的第一件事是找到我们项目的当前版本。为此，您可以在您的<code class="fe no np nq ng b">changelog</code>变量下添加以下代码行。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="87b7" class="mg mh it ng b gy nk nl l nm nn">version="$(git describe --long)"</span></pre><p id="b0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打印您的标记版本，如下所示:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="5718" class="mg mh it ng b gy nk nl l nm nn">1.2.1-2-gabc12d34</span></pre><p id="0a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有项目版本(<code class="fe no np nq ng b">1.2.1</code>)，接着是这个版本的提交数量(<code class="fe no np nq ng b">-2</code>)，最后是提交本身的缩写名称(<code class="fe no np nq ng b">-gfa17e39</code>)。有很多方法可以将整个版本压缩成可读性更好的版本(比如将上面的版本表示为1.2.3 ),但我不会在这里深入讨论。</p><p id="6af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于git标签的更多信息，请查看本文。</p><p id="7946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了版本，我们需要得到日期。这是我们可以添加到<code class="fe no np nq ng b">version</code>下的另一个变量。在Bash中，只需使用<code class="fe no np nq ng b">date</code>就可以获得日期。但是这会给我们以下的结果。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3f02" class="mg mh it ng b gy nk nl l nm nn">Tue Mar 29 13:10:19 EDT 2022</span></pre><p id="cf4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个变更日志中，我们将遵循<a class="ae ky" href="https://www.progress.com/blogs/understanding-iso-8601-date-and-time-format" rel="noopener ugc nofollow" target="_blank"> ISO格式</a>，基本上是年，然后是月，然后是日。您可以包含时间，但是在这个脚本中，我们将只使用年-月-日格式。为了使我们的日期符合ISO格式，我们可以使用下面的代码。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3a42" class="mg mh it ng b gy nk nl l nm nn">today="$(date '+%Y-%m-%d')"</span></pre><p id="12d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经正确格式化了日期，我们可以开始脚本中最难的部分了:实际上在changelog文件的特定行添加一行。为了做到这一点，我们需要阅读变更日志。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="5d5a" class="mg mh it ng b gy nk nl l nm nn">while read line; do<br/>  echo $line<br/>done &lt; CHANGELOG.md</span></pre><p id="c7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码遍历changelog的每一行(用<code class="fe no np nq ng b">$line</code>表示),并在命令行中使用<code class="fe no np nq ng b">echo</code>。现在我们可以阅读每一行了，我们只需要找到哪一行是我们想要在后面添加新闻变更日志项目的行。鉴于<code class="fe no np nq ng b">## [Unreleased]</code>是我们的changelog的一个常见附件，在它下面是我们发布的变更，当添加一个新的changelog项目时，这是一个很好的线索。</p><blockquote class="ns nt nu"><p id="13dc" class="kz la lv lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">由于<code class="fe no np nq ng b">## [Unreleased]</code>变更(与当前日期或版本无关)在发布时已经被删除，所以添加对检查未发布变更的支持并不是当前的首要任务。</p></blockquote><p id="f880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个if语句，用于检查行<code class="fe no np nq ng b">## [Unreleased]</code> <em class="lv">。</em></p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="76ba" class="mg mh it ng b gy nk nl l nm nn">if [[ $line == "## [Unreleased]"* ]]; then<br/>  echo "LINE FOUND"<br/>fi</span></pre><p id="0e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美。我们现在可以知道在哪一行插入新的changelog项目。这就引出了下一个问题，我们如何实际插入changelog项？为此，我们将使用<code class="fe no np nq ng b"><a class="ae ky" href="https://www.geeksforgeeks.org/sed-command-in-linux-unix-with-examples/" rel="noopener ugc nofollow" target="_blank">sed</a></code>。</p><p id="42fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq ng b">sed</code>是一个文本流编辑器，有很多很好的用途，但是现在，我们只使用它来查找和改变文件中的文本。我们可以使用带有<code class="fe no np nq ng b">-i</code>标志的<code class="fe no np nq ng b">sed</code>命令来编辑文件。这很好，因为我们想要实际编辑现有文件，而不是简单地打印到标准输出。</p><p id="a014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe no np nq ng b">sed</code>来插入文本，我们需要遵循下面的格式。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3a14" class="mg mh it ng b gy nk nl l nm nn">sed -i "" "s/old_line/new_line" FILE.ext</span></pre><p id="baec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了分解它，首先你需要在<code class="fe no np nq ng b">-i</code>后面加上<code class="fe no np nq ng b">""</code>，因为这一行是如何被解析的(<em class="lv">至少在Mac OS X上是需要的。其他操作系统可能不需要它</em>。然后，您可以提供旧行，接着是它的替换行，接着是文件本身。该字符串开头的<code class="fe no np nq ng b">s</code>代表“替换”，因此该命令知道用<code class="fe no np nq ng b">new_line</code>替换<code class="fe no np nq ng b">old_line</code>。</p><p id="06d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，上面的内容可以改写成这样:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="036b" class="mg mh it ng b gy nk nl l nm nn">sed -i "" "s/$newvar/## [Unreleased]\n\n## [$version] - $date\n### Added\n - ADD CHANGE HERE!/" CHANGELOG.md</span></pre><p id="c67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能已经注意到<code class="fe no np nq ng b">$newvar</code>代替了<code class="fe no np nq ng b">$line</code>。这是因为我们的原始行包含括号(<code class="fe no np nq ng b">[]</code>)。这些是为括号表达式保留的，因此与普通文本的计算方式不同。所以为了<a class="ae ky" href="https://stackoverflow.com/questions/71861374/why-cant-sed-find-line-in-changelog" rel="noopener ugc nofollow" target="_blank">解析这个</a>，我们必须创建一个新的变量，用<em class="lv">转义的</em>括号来替换括号。我们可以找到带有普通括号的行，但是我们需要对这些括号进行转义，以便让<code class="fe no np nq ng b">sed</code>命令正确地替换它。参见下面的<code class="fe no np nq ng b">$newvar</code>。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="4832" class="mg mh it ng b gy nk nl l nm nn">newvar=$(&lt;&lt;&lt;"$line" sed 's/[].*[]/\\&amp;/g')</span></pre><p id="0661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了这篇文章和简洁起见，我不会太深入地讨论这个语法的结构。只需知道这一行用转义括号替换了<code class="fe no np nq ng b">$line</code>中的括号，因此它们被视为文本的一部分，而<em class="lv">不是</em>被视为括号表达式。</p><p id="24a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们更新的<code class="fe no np nq ng b">new_changelog_item</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们快完成了。</p><p id="7a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经准备好了大部分代码。我们现在需要做的就是检查是否已经有一行与我们当前的版本一致。要做到这一点，我们可以简单地看看在changelog中的任何地方是否有这样一行:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="c755" class="mg mh it ng b gy nk nl l nm nn">## [$version] - $date</span></pre><p id="84c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以将下面的条件添加到我们的<code class="fe no np nq ng b">new_changelog_item</code>中。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="24f7" class="mg mh it ng b gy nk nl l nm nn">item="## [$version] - $date"<br/>if grep -Fxq "$item" CHANGELOG.md; then<br/>  echo "Changelog item already exists for $item."<br/>else<br/># rest of function</span></pre><p id="1b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq ng b">-<a class="ae ky" href="https://www.codegrepper.com/code-examples/shell/grep+fxq" rel="noopener ugc nofollow" target="_blank">Fxq</a></code>是一个标志，它允许我们检查所提供的模式(在我们的例子中是changelog项目头)是固定字符串、精确匹配还是安静输出。本质上，它是一个非常全面的标志，可以帮助我们捕捉任何类型的模式。一旦我们有了这个，我们就可以把之前的函数放到<code class="fe no np nq ng b">else</code>语句中。这是因为如果此版本/日期组合的变更日志项目不存在，我们应该添加一个新的项目。</p><p id="3a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了！一个<em class="lv">纯粹的</em> bash脚本整合到您的应用程序中以生成变更日志，添加变更日志项目，<em class="lv">和</em>在格式和变更日志内容方面为您提供灵活性<em class="lv">，而</em>不需要生成器、日志或其他依赖项。完整代码在<a class="ae ky" href="https://github.com/macro6461/changelog-bash" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="1657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://matt-croak.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="lv">升级您的免费Medium会员资格</em> </strong> </a> <em class="lv">并接收各种出版物上数千名作家的无限量、无广告的故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。</em></p><p id="f27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">你也可以通过电子邮件</em> <a class="ae ky" href="https://matt-croak.medium.com/subscribe" rel="noopener"> <strong class="lb iu"> <em class="lv">订阅，当我发布新内容时，你会收到通知！</em></strong></a></p><p id="9952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你！</p><h1 id="b449" class="oh mh it bd mi oi oj ok ml ol om on mo jz oo ka mr kc op kd mu kf oq kg mx or bi translated">参考</h1><div class="os ot gp gr ou ov"><a href="https://github.com/macro6461/changelog-bash" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">GitHub-macro 6461/changelog-bash:生成和添加changelog项目的纯bash脚本</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">这是用于创建和更新changelog的纯bash脚本的代码。不需要发电机。不需要…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://keepachangelog.com/en/1.0.0/#:~:text=Why%20keep%20a%20changelog%3F,or%20version%29%20of%20the%20project" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">保留变更日志</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">changelog是一个文件，它包含一个按时间顺序排列的列表，列出了每个版本的显著变化…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">keepachangelog.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ks ov"/></div></div></a></div><p id="e8bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://linuxize.com/post/bash-check-if-file-exists/" rel="noopener ugc nofollow" target="_blank">https://linuxize.com/post/bash-check-if-file-exists</a></p><div class="os ot gp gr ou ov"><a href="https://unix.stackexchange.com/questions/122977/what-is-the-correct-name-for-the-command" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">“&gt;”命令的正确名称是什么</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">正如其他人回答的那样，&gt;不是一个命令，而是一个重定向操作符。然而，术语“重定向…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">unix.stackexchange.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://git-scm.com/docs/git-describe" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">描述文档</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">使用类似git.git的当前树，我得到:[Torvalds @ G5 git]$ git describe parent v 1 . 0 . 4-14-g 2414721，即…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">git-scm.com</p></div></div><div class="pe l"><div class="pm l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://www.geeksforgeeks.org/sed-command-in-linux-unix-with-examples/" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Linux/Unix中的Sed命令及示例</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">UNIX中的SED命令代表流编辑器，它可以对文件执行许多功能，如搜索、查找和…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="pe l"><div class="pn l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://stackoverflow.com/questions/71861374/why-cant-sed-find-line-in-changelog" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">为什么sed在changelog中找不到行</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">stackoverflow.com</p></div></div><div class="pe l"><div class="po l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://www.codegrepper.com/code-examples/shell/grep+fxq" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">grep fxq代码示例</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">只需使用带有标志‘F’(固定字符串)、‘x’(精确匹配)和‘q’(安静输出)的grep来检查一个单词是否…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">www.codegrepper.com</p></div></div><div class="pe l"><div class="pp l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>