<html>
<head>
<title>VIPER For SwiftUI? Please. No.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蝰蛇换SwiftUI？求你了。号码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/viper-for-swiftui-please-no-ee61ce99694c?source=collection_archive---------2-----------------------#2022-07-16">https://betterprogramming.pub/viper-for-swiftui-please-no-ee61ce99694c?source=collection_archive---------2-----------------------#2022-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者为什么你不应该抚摸那条特别的蛇。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/286adae5b8cb667e384a33b37557bf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3dzDq-lR7MGDPjXmkAM1Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·库里在<a class="ae ky" href="https://unsplash.com/s/photos/viper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个人都喜欢写他们如何通过SwiftUI使用他们最喜欢的UIKit架构。其中一个比较突出的设计模式/架构是VIPER。</p><p id="3eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图-交互者-演示者-实体-路由器。</p><p id="c7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我。VIPER是一个很棒的软件架构，旨在解决在开发和创建基于UIKit和UIViewController的应用程序时遇到的许多经典和常见问题。</p><p id="7fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于SwiftUI来说,<em class="lv">不是</em>最好的架构。也不是第二好的。事实上，这是最糟糕的情况之一，我希望在这篇文章中说明原因。</p><p id="1960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在此之前，我们首先需要知道两件事。</p><ol class=""><li id="7487" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">毒蛇是什么？</li><li id="472e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">它解决什么问题？</li></ol><p id="9273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吃吧。</p><h1 id="128a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">毒蛇是什么？</h1><p id="4a5c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如上所述，VIPER是一个首字母缩写词，代表视图-交互者-呈现者-实体-路由器。</p><p id="8055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在读这篇文章，你可能已经熟悉了VIPER。因此，与其花时间自己解释每一个组成部分，我将走捷径，从Mahdi Chtioui的一篇关于这个主题的写得很好的文章中借用一点。</p><p id="a86d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是VIPER模块中的组件。</p><blockquote class="nh ni nj"><p id="bd1a" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">视图</strong>:视图层，基本上是UIViewController和其他任何视图类型。这一层包含UI逻辑(显示、更新、动画…)，负责截取用户的动作并发送给演示者。最重要的是，它没有商业逻辑。</p><p id="50ec" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu"> Interactor </strong>:我们可以把它想象成“网络管理器”:当提交者请求时，负责从服务(网络、数据库、传感器……)中检索数据。交互器负责管理来自模型层的数据(注意，模型不是VIPER架构的一部分，你可以随意实现它或不实现它，但肯定它会使我们的应用程序更加简洁)。</p><p id="27ec" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">演示者</strong>:我喜欢把它想象成主板，它把所有层连接在一起。演示者是唯一与视图通信的层(其余层与演示者通信)。基本上，它是负责根据视图发送的用户动作做出决策的层。</p><p id="a27d" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">实体:实体只是我们的模型，由交互器使用。至少在我看来，最好将它们放在VIPER模块之外，因为这些实体通常由不同的模块在整个系统中共享。</p><p id="cfa2" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">路由器:</strong>有人称之为“线框”。这一层负责处理导航逻辑:推送、弹出、呈现UIViewControllers。</p></blockquote><p id="2921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VIPER是最常见的所谓干净架构之一。但是为什么要使用它呢？</p><h2 id="c042" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">它解决什么问题？</h2><p id="e83d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">VIPER是传统UIKit MVC(模型-视图-控制器)软件开发中最大问题的众多解决方案之一。</p><p id="5d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个问题如此普遍，以至于MVC这个缩写词很快获得了另一个不同的、同样众所周知的定义。</p><blockquote class="nh ni nj"><p id="0ea2" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">MVC:大规模视图控制器。</p></blockquote><p id="c67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道问题所在。在MVC中，我们经常会把一个给定屏幕的所有代码放到那个屏幕的视图控制器中。标签和文本字段以及视图出口。按钮和动作处理程序。委托和事件处理程序。商业逻辑。验证。网络请求和错误处理。导航路由和控制。</p><p id="4ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真是一团糟。</p><p id="c451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VIPER就是为了解决这个问题而创建的，它专注于一个核心概念，即单一责任原则。</p><p id="8d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前包含在视图控制器中的所有代码都将被分解，并转移到一个特定的、定义良好的结构中。每个组成部分在这一过程中都有特定的职责和角色。</p><p id="4f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看与演示者的对话。演示者与互动者交谈。Interactor将实体返回给Presenter，它将事物分解成视图可以使用的容易理解的部分。完成后，演示者与路由器对话，然后我们转到链中的另一个VIPER模块。</p><p id="4b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">冲洗。根据需要重复。</p><p id="a9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，VIPER创建了许多小的活动部件，不幸的是，为管理VIPER而编写的代码中有很大一部分是为了管理VIPER而编写的。</p><blockquote class="nh ni nj"><p id="16c8" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">事实上，<a class="ae ky" href="https://theswiftdev.com/the-ultimate-viper-architecture-tutorial/" rel="noopener ugc nofollow" target="_blank">我读过的一篇关于这个主题的文章</a>指出，VIPER创建并使用了如此多的样板代码，以至于人们应该依靠代码生成器来创建所有需要的东西。</p></blockquote><p id="245c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是……总之……它起作用了。</p><p id="45c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以工作…但是它不适合SwiftUI。</p><p id="dc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？首先，它是为另一个时代设计的。和另一种语言。和另一个SDK。</p><h2 id="5df4" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">委托</h2><p id="224b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">VIPER起源于传统的Objective-C和基于早期Swift UIKit的开发，它显示了。</p><p id="4c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，VIPER主要是通过委托来工作的。系统中的每个组件都有一个接口，为了让一个组件与另一个组件对话，它需要一个对该组件的引用。</p><p id="1974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建并呈现一个新的UIViewController和Presenter，其他所有东西都必须在一个正式的、严格的结构中创建、连接和绑定在一起。</p><p id="79fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图控制器需要了解演示者，所以它有一个对它的强引用。但是演示者<em class="lv">也</em>需要知道视图控制器，所以它可以驱动UI的变化。因此，演示者需要一个弱委托链接返回到视图控制器(必须观察那些引用周期)。</p><p id="6814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VIPER中的其他组件也是如此。</p><p id="66cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果今天要求创建这样一个系统，人们可能会更关注具有回调闭包的函数，或者甚至使用RxSwift或Combine进行组件通信和消息路由，而不是硬连线委托。</p><p id="0f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这些工具不可用，或者不常用。没有多少人知道或使用Rx，Objective-C中的块语法非常糟糕<a class="ae ky" href="http://fuckingblocksyntax.com" rel="noopener ugc nofollow" target="_blank">许多网站被创建</a>来解释如何定义、创建和使用它们。</p><p id="6ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，委托被选为各层之间的主要通信机制。好吧。有点笨重，不过还好。我们应该可以接受。</p><h2 id="7cf1" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">没有风景</h2><p id="c5ec" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">除了在SwiftUI中，视图不是视图。在UIKit中，UIView或UIViewController是一种引用类型。我可以链接到它和它的delgate。</p><p id="f0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，“视图”是定义我们的应用程序的轻量级结构。它们不是引用类型，而是值类型，因此演示者不能持有对值类型的引用。</p><p id="5610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，视图不是由演示者对视图的命令性调用来驱动的，以更新UI。它们由系统驱动，基于可观察数据的变化。</p><p id="547b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在VIPER中，路由器隐藏了视图之间创建、推送和导航的复杂性。但是在SwiftUI中，导航就像在<code class="fe nz oa ob oc b">NavigationLink</code>中包装一个视图，或者在<code class="fe nz oa ob oc b">NavigationStack</code>中添加一个值一样简单。</p><p id="61d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，随着每一张行为多米诺骨牌的倒下，VIPER赖以生存的整个结构和理性开始崩溃。它名副其实，变成了一个蛇窝，你越深入其中，就越有可能被咬。</p><p id="2013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近从一个代码库中看到了一些例子，在那里开发人员放弃了，并且<em class="lv">还</em>被迫在他的VIPER代码中添加一个视图模型，这样他就有地方放置他的可观察值了。所以，VIPERVM？</p><p id="e483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在让我们忽略所有这些，因为VIPER有一个更大的问题。</p><p id="a0f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，毒蛇很大程度上是一个错误问题的答案。</p><h2 id="4f33" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">我们如何修复大规模视图控制器？</h2><p id="b617" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这样问的话，VIPER似乎是一个合乎逻辑的答案。提取所有我们能提取的代码，并把它转移到其他地方。</p><p id="7afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公平地说，不管我们做什么，有些代码确实想放在别处。例如，网络代码。</p><p id="b1f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个简单的答案回避了真正的问题。</p><p id="1494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问:首先，为什么我们的视图控制器这么大？T13】</p><p id="31f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想要答案？在这里。</p><p id="ba74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">答:因为UIKit让构图很难。</em> </strong></p><p id="4c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是问题的症结所在。</p><p id="65ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将UIViews和UIViewControllers分解成更小的组件是很困难的。太难了，事实上，我们不这样做。所以我们经常以一个单一的UIViewController来驱动我们在单一屏幕上看到的一切。</p><p id="d426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要一些例子吗？</p><h2 id="5290" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">UIKit组件</h2><p id="3e60" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">想在你的屏幕上添加一个单独的<code class="fe nz oa ob oc b">UIViewController</code>？你能不能只添加视图？只是添加视图控制器作为子视图？没有。你必须这样做。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="cb03" class="nn ml it oc b gy oh oi l oj ok">let controller = AccountDetailsViewController()<br/>controller.accounts = accounts<br/>addChild(controller)<br/>controller.view.translatesAutoresizingMaskIntoConstraints = false<br/>container.addSubview(controller.view)<br/>NSLayoutConstraint.activate([<br/>    controller.view.leadingAnchor.constraint(equalTo: container.leadingAnchor, constant: 0),<br/>    controller.view.trailingAnchor.constraint(equalTo: container.trailingAnchor, constant: 0),<br/>    controller.view.topAnchor.constraint(equalTo: container.topAnchor, constant: 0),<br/>    controller.view.bottomAnchor.constraint(equalTo: container.bottomAnchor, constant: 0)<br/>])<br/>controller.didMove(toParent: self)</span></pre><p id="a6ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想要使用在XIB中创建的界面元素吗？哦天啊。首先，我们必须让系统为我们做一个。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="94ec" class="nn ml it oc b gy oh oi l oj ok">let cardView = NSBundle.mainBundle("CardView").loadNibNamed("", owner: nil, options: nil)[0] as! CardView</span></pre><p id="b1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这假设你首先在<code class="fe nz oa ob oc b">CardView</code>类中正确地实现了<code class="fe nz oa ob oc b">required init?(coder aDecoder: NSCoder)</code>方法。</p><p id="dccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit鼓励你写代码来创建视图，写xib来创建视图，写故事板来创建视图。但是想一起用？将一个嵌入另一个？那是痛苦开始的地方。</p><p id="1e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit通过要求特殊情况下的特殊视图使问题变得更加复杂。需要表格视图的标题吗？嗯，那不是<code class="fe nz oa ob oc b">UIView</code>，那是<code class="fe nz oa ob oc b">UITableViewHeaderFooterView</code>。想在列表中显示视图吗？当然是<code class="fe nz oa ob oc b">UITableViewCell</code>。或者可能是<code class="fe nz oa ob oc b">UIContainerViewCell</code>，如果你是那样滚动的话。但是嘿！想在另一个视图中使用刚刚编写的单元格视图吗？没有。</p><p id="2f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit主动使用<em class="lv">来对抗</em>视图合成。</p><p id="69ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当系统积极地与解决方案对抗时……我们最终会做得更少，这有什么奇怪的吗？</p><p id="2880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果不是这么痛苦的话。如果将我们的视图和视图控制器分解成更小的视图和视图控制器更容易些…<em class="lv"/></p><p id="eada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们的大规模视图控制器会如此庞大吗？</p><h2 id="6493" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">作文</h2><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我已经写了这个<a class="ae ky" href="https://medium.com/swlh/structural-decomposition-in-swiftui-8892e512b18e" rel="noopener">再</a>和<a class="ae ky" href="https://medium.com/swlh/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">再</a>。SwiftUI基于的基本原则之一是<em class="lv">组合</em>。</p><p id="d843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想在我们的视图中嵌入在别处创建的CardView吗？</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="bcf9" class="nn ml it oc b gy oh oi l oj ok">VStack {<br/>    ...<br/>    CardView(title: "Account", item: account)<br/>    ...<br/>}</span></pre><p id="4fbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘣。就这么简单。想在列表中使用吗？</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="c442" class="nn ml it oc b gy oh oi l oj ok">List {<br/>    ForEach(accounts) { account in<br/>        CardView(title: "Account", item: account)<br/>    }<br/>}</span></pre><p id="b472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成了。</p><p id="fd44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在<a class="ae ky" href="/better-programming/best-practices-in-swiftui-composition-282b02772a24" rel="noopener ugc nofollow" target="_blank">SwiftUI组合的最佳实践</a>中指出的，如果在WWDC swift ui会议期间有一件事被反复重复，那就是swift ui视图是极其轻量级的，创建它们几乎没有性能损失。</p><p id="5e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想把视图的一部分分割成一个更小的子视图吗？又快又简单。见鬼，在Xcode中，你只需按住command键点击部分代码，然后选择“提取子视图”。</p><p id="1224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可能已经看到了这一趋势…</p><h2 id="e259" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">视图-交互者-演示者-实体-路由器</h2><p id="a242" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果在SwiftUI中创建和使用小的、专用的、特殊用途的视图和组件很容易…那么我为什么要使用一个<em class="lv">不鼓励我这样做的架构呢？</em></p><p id="d411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个架构需要我移动视图代码…和相关的表示器代码…和相关的交互器代码…以及其他所有需要的东西。</p><p id="b2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，前面提到的SwiftUI VIPERVM示例有超过<strong class="lb iu"> 200行</strong>的VIPER样板代码…全部支持<strong class="lb iu">一个</strong>20行的视图。</p><p id="e51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两百行代码。</p><p id="bb58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果每个新视图<em class="lv">也</em>需要创建大量额外的类和组件来配合它…我会在需要时创建许多简单的子视图吗？或者我应该避免麻烦，继续将所有内容整合到更大的SwiftUI视图中？</p><p id="eafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要用大规模视图体来代替大规模视图控制器吗？</p><p id="5f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到VIPER是因为UIKit不鼓励视图合成。</p><p id="62d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果毒蛇也和我们作对…</p><h2 id="c0d7" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">斯威夫特伊</h2><p id="06c5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">正如我在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-choosing-an-application-architecture-6ec9289f8e8f"> SwiftUI:选择应用架构</a>中总结的:</p><blockquote class="nh ni nj"><p id="c936" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">SwiftUI为编写应用程序带来了一种简单的声明式方法。也许更确切地说，是<em class="it">简洁</em>。你可以用很少的代码完成很多工作。</p><p id="c189" class="kz la lv lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">因此，给我们自己和我们的应用程序增加过于正式的架构的负担将是一种耻辱，这又一次显著地增加了我们需要编写的代码量。</p></blockquote><p id="d1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们当然不需要为不同的SDK设计的架构，构建和设计来解决和克服另一种语言和另一种环境的限制。</p><p id="c28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个架构，让SwiftUI…成为SwiftUI。</p><h2 id="017a" class="nn ml it bd mm no np dn mq nq nr dp mu li ns nt mw lm nu nv my lq nw nx na ny bi translated">完成块</h2><p id="c923" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">原来如此。在我看来，VIPER虽然仍然是UIKit开发的好选择，但对于SwiftUI来说却是一个极其糟糕的选择。</p><p id="61dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是用什么代替呢？嗯，你可以在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-choosing-an-application-architecture-6ec9289f8e8f"> SwiftUI中看到我目前的想法:选择应用架构</a>。</p><p id="ecd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这件事我还有一些想法。</p><p id="7d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但那是另一篇文章了。又是一天。</p><p id="bc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之前，让我知道你的想法。我说的对吗？错了？</p></div></div>    
</body>
</html>