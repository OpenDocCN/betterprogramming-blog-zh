# 使用 React With Redux 时，您应该始终进行单元测试的 3 件事

> 原文：<https://betterprogramming.pub/3-things-you-should-always-unit-test-when-using-react-with-redux-ee663c88e82d>

## 直面你对单元测试的负罪感，以及你可以安全跳过的内容

![](img/376ef597a214d8c7f07ae403261d7931.png)

矢量艺术插图作者[作者](https://medium.com/@jasonleehodges)

周五下午晚些时候，你正准备结束一周的工作，然后事情发生了。一位客户报告了前一天推出的产品代码的问题。你肾上腺素激增，所有其他与工作相关的任务和周末计划都从你的脑海中消失了。你靠咖啡因补充能量，然后深入研究 bug 票，找到问题所在。您的手指在键盘上疯狂地移动，以实现修复，确保停机时间最小化。

当您将补丁发布到远程存储库进行持续集成时，您会想一个 bug 最初是如何进入生产环境的。毕竟，有一个测试套件可以保持你的代码稳定，对吗？然后，持续集成构建与实现您的修复*失败*。你疯狂地搜索日志，试图找出原因。突然的领悟像一堵砖墙一样打击着你。*你的修复破坏了一个单元测试*。压力在于尽快修复构建并修复您的 bug。您的经理不断通过即时消息向您发送 ping 命令，询问您的最新情况。其他开发人员开始抱怨构建失败，因为它阻碍了他们的工作。当你努力想弄清楚这个测试是如何工作的时候，你的手指开始颤抖，你的脸开始发红。

最后，您举手表决，注释掉测试，并推动它。持续集成构建通过了，您的 bug 修复进入了生产阶段，每个人都很高兴。也许除了你的良心——它因为删除了一个旨在保持你的代码库稳定的测试而充满了罪恶感。

你遇到过这种情况吗？

作为一名工程经理，我观察到从事大型项目的工程师有一种共同的情绪。他们有时害怕创建*任何*单元测试，万一他们最终破坏了构建，人们会因此对他们感到愤怒。这种恐惧也可以表现为担心编写测试会给他们的同行带来大量的长期维护负担，因为测试本身是脆弱的。这看起来至少是一个文化问题，但甚至可能是一个过程问题。但是怎么修呢？这里存在一个动机的问题——我们为什么要编写单元测试？

# 单元测试的原因

我的团队肯定不会为了确保我们的持续集成管道将一直构建而编写单元测试。如果这是真的，那么上面场景中提供的经验可能会激励我们根本不写单元测试。所以另一方面，我会假设我们编写单元测试只是为了确保我们的代码做我们期望它做的事情。但是除此之外，你可以争辩说它也可以增加我们作为开发人员的生产力，并且鼓励更好的设计模式。

我经常发现开发人员努力识别他们的错误的来源。在他们的追求中，他们用“钉钉子的锤子”来武装自己。他们会向我寻求帮助，以确定为什么他们的单一功能，臃肿的 50-100 行代码，不工作。我会简单地看一下，如果 60 秒后还不清楚这个函数试图完成什么，我会让他们写一个单元测试，然后回来找我。像这样的大型函数通常会有意想不到的副作用，或者它们非常复杂，很难推理。通过要求开发人员编写单元测试，我实际上是要求他们准确地分解他们期望函数接受和返回的内容(也称为参照透明性)。毕竟，最终，单元测试确实是为了帮助我们确保代码做我们期望的事情，但是这也迫使我们定义我们期望的事情。

几乎每次我让某人这样做，他们都会回来说他们的功能没有做他们认为应该做的事情。他们经常将他们的功能分解成几个更模块化、更易维护的功能。此外，仅仅通过重构他们的代码使其更具可测试性，他们就解决了问题，而不需要实际运行单元测试。这是因为可测试的代码更容易预测，也更容易推理。

编写测试实现的另一个主要好处是，他们不必等待代码在浏览器中重新加载，并返回到触发`console.log`语句所需的状态。我将看到开发人员添加日志调用，重新加载浏览器，点击鼠标，并意识到他们实际上需要在其他地方`console.log`。所以他们又一次地重复这些动作……*慢慢地*。通过编写单元测试，他们可以做出快速的改变，点击键盘上的向上箭头调出他们刚刚编写的最后一个`yarn test`命令，然后再次启动单元测试。或者更好的是，他们在 TDD/watch 模式下运行他们的代码，当他们保存他们的更改时，自动运行测试。这导致了一段代码的快速迭代，极大地提高了生产率。

值得一提的是，在我的调试工作流程中，我几乎从不使用`console.log`。相反，我使用 Redux DevTools 和单元测试。

那么，现在我们已经确定有一个好的理由来编写单元测试，这是否意味着我们应该确保我们有 100%的代码覆盖率，并且我们绝对测试我们代码库中的所有东西？我以前试过，结果证明是矫枉过正。让我们来看看什么对单元测试有意义，什么是浪费时间和资源。

# React + Redux 测试什么？

如果您现在没有在 react 应用程序中使用 Redux，我强烈推荐您使用它。Redux Toolkit 改变了游戏，让 Redux 变得更容易使用。Redux 本身提供了一种设计模式，允许开发人员从组件中提取尽可能多的业务逻辑，这是表示层和逻辑层的有效分离。通过从表示层抽象出业务逻辑，您的应用程序本质上变得更具可测试性。如果您正在努力将业务逻辑从应用程序中分离出来，您可能会停下来问自己，“这个逻辑是为了改变还是访问状态？”如果这个问题的答案是肯定的(通常是这样——我发现大多数业务逻辑都涉及到操纵状态)，那么将这个逻辑放在 Redux reducer 或 selector 中可能是一个很好的例子。

因此，如果在应用程序中使用 Redux 使代码更易测试，那么实际上应该测试什么呢？我认为在使用 Redux 进行状态管理的 React 应用程序中，应该始终测试 3 个主要函数。

## 1.还原剂

如果你很了解 Redux flux 设计模式，你会知道要更新应用程序的状态，你必须分派动作，并让一个 reducer 处理这些动作。减速器本身是纯函数。它们将现有状态和一个操作对象作为输入参数，并返回一个新状态。可以理解，当处理这些动作时，减压器不应产生副作用。因此，如果它接受参数，返回一个更新的状态，并且没有副作用，那么它就保持了引用透明性的所有规则，从而使它成为可测试代码的典型例子。

在清单 1 中，您会发现一个稍微修改过的缩减器示例，它是由官方的[create-react-app template for redux with typescript](https://www.npmjs.com/package/cra-template-redux-typescript)提供的样板示例提供的。我在这里修改它只是为了证明当 reducer 处理动作时，实际上没有副作用发生(模板提供的例子使用了`immer`,它允许您提供可变的语法，实际上在幕后为您转换成不可变的操作)。这个 reducer 有一个简单的计数器`value`,可以增加 1，减少 1，或者增加动作有效负载提供的数量。还有一个异步动作，在经过一定时间后递增 1。

清单 1 — Redux 工具包缩减器

记住上面的 reducer，我们现在有几个案例，其中一个动作正在操纵应用程序的现有状态(T2 值)。这被认为是业务逻辑，应该进行测试，以确保它确实在做我们期望它做的事情。清单 2 显示了 create-react-app redux-typescript 模板提供的默认测试。如您所见，这些测试非常容易编写。您只需导入缩减器本身，为该缩减器提供一个初始状态，并为其提供一个动作。调用该 reducer 的结果是更新后的状态，我们可以对照我们期望的状态进行检查。

清单 Redux Toolkit Reducer 的单元测试

## 2.选择器

在通过 reducer 操纵状态之后，大多数开发人员需要做的下一件事就是在他们的组件中访问状态。我经常发现刚接触 Redux 的开发人员不为他们的应用程序编写专用的选择器，这意味着他们在组件中内嵌编写选择器，如清单 3 所示。内联定义这些选择器的问题是它们不能在其他组件中重用，也不能被测试。

清单 3——在组件中内联定义选择器的反模式

我观察到的另一件事是，即使开发人员有一个专用的选择器文件，他们在其中编写了所有要重用的选择器，他们也经常编写尽可能最少的选择器(即`export const selectCount = (state: RootState) => state.counter.value;`)。然后，他们将这些选择器导入到他们的组件中，并对组件中所选的状态执行所有必要的业务逻辑。这使得测试业务逻辑更加困难，因为您必须在单元测试中安装组件本身，并模拟用户交互来查看逻辑是否工作。

作为一个最佳实践，如果执行业务逻辑是为了从 Redux 存储的当前状态中获取一个值，那么应该在选择器中完成。选择器和减速器一样，都是纯函数。它们接受应用程序的当前状态，并返回一个派生值(基于业务逻辑)，没有副作用。这使得它们非常适合测试。

我见过一些开发人员努力通过选择器从状态中获取值，因为他们需要提供额外的值来执行业务逻辑。但是一些简单的奉承，如清单 4 中的`selectCountFormatted`选择器所示，可以帮助完成这个任务。清单 4 中还提供了一个示例，说明如何在同一个选择器中从 state 返回多个值，在本例中为`selectCountAndStatus`。如果需要，这也可以通过减速器来实现，因为提供给选择器的状态是`RootState`。

清单 4 —计数器选择器文件

这些选择器现在可以在您的应用程序中重复使用，并且很容易测试，以确保我们总是得到预期的结果。清单 5 展示了如何在组件内部的`useSelector`钩子中使用 curried 选择器的例子，以及如何测试这些选择器的例子。

清单 5——带有定制选择器和选择器单元测试的 useSelector 示例

## 3.公用事业

通常，如果业务逻辑不能被封装在改变状态或选择状态中，它通常仍然可以被抽象成可以在组件之外存储和测试的纯功能。通过将它们存储在组件之外，它们不需要在每次组件重新渲染时重新定义，而且它们…你猜对了，*更容易测试*。

我称这些函数为实用程序，但其他人可能称它们为助手函数。创建效用函数时要考虑的最重要的事情是它们应该是纯的。如果您的组件中有一部分本地状态是您的业务逻辑所依赖的，并且您觉得不能因此将该逻辑抽象成一个实用函数，那么只需将该本地状态作为参数传递，并保持该函数的纯洁性。一个效用函数不应该依赖于任何存在于它自身范围之外的变量。

![](img/81c566e467b277efc37cb7608c1c0feb.png)

矢量艺术插图作者[作者](https://medium.com/@jasonleehodges)

# 什么不是单元测试

我坚信，当操作的逻辑具有合理的计算性时，应该在 React 应用程序中测试上述 3 个元素。然而，这并不意味着您应该测试代码库中的所有内容。

## 基本冗余元素

对于 Redux，如果您的选择器尽可能小(如清单 4 的第 1 行所示)，您可能不需要为此进行单元测试。这里没有实际的业务逻辑，只是访问一个值。同样，如果一个 reducer 通过简单地将一个状态改变为有效负载提供的确切值来处理一个动作，那么您可能也不需要测试它。但是如果有任何逻辑发生(比如在现有值上增加一个值)，您可能应该测试一下，以确保 reducer 按照预期处理逻辑。

## 类型

如果您没有使用 Typescript，我强烈推荐您使用它。通过将静态类型系统引入我们的代码库，我的团队已经能够将我们编写的单元测试数量减少至少 50%。任何简单检查对象形状或函数返回的对象类型的测试都可以被静态类型化系统删除和替换。

## API 调用

我注意到一些开发人员花费大量时间维护测试，对 API 调用进行大量模拟。最终，应用程序的前端和后端之间应该有一个契约。API 应该被版本化，并且不应该中断。在我的组织中，我们不是关注模拟 API 调用，而是确保在后端执行适当的快照测试。我们还在代码的服务层放置了类型保护和错误处理，以防止意外的结果。但是通常避免为 API 编写带有模拟的单元测试(除非我们正在编写一些跨多个项目共享的外部客户端)。

## 模拟用户交互

很多人真的喜欢确保应用程序中的测试尽可能地模拟用户交互。论点是，通过测试用户交互，您将知道整个应用程序将按照用户期望的方式工作。这被称为端到端测试，有时也称为集成测试，这取决于你如何看待它。[`react-testing-libary`的作者肯特·c·多兹](https://medium.com/u/db72389e89d8?source=post_page-----ee663c88e82d--------------------------------)，已经写了很多关于这个话题的文章，如果你有兴趣了解更多的话。

然而，在 react 应用程序中安装组件，通过`react-testing-library`或`enzyme`来模拟用户交互进行测试，本质上是非常脆弱的。每当您更新组件的任何部分时，这些集成测试往往会失败。它们需要大量的维护，因此非常昂贵。还有，他们*真的*慢(尤其是`react-testing-library`)。这对于持续的集成管道工作来说很好，但是如果我想确保我的代码在推到我的远程分支之前没有破坏任何测试，我不想在它运行所有集成测试时等待 5-10 分钟。单元测试本来就应该很快。

我的组织倾向于依赖手工 QA 测试来完成端到端的测试。我们的逻辑是，如果你必须在这些类型的测试上花费大量的维护时间，你还不如有一个专门的人工 QA 人员。对此持保留态度，里程可能会有所不同，取决于您的项目。

# TL；速度三角形定位法(dead reckoning)

Redux 是一种可预测和可维护的设计模式，使测试变得容易。使用 Redux 时，将尽可能多的业务逻辑转移到 reducers、选择器和实用函数中，并对它们进行测试。

最终，您的组件应该是一个非常薄的表示层。也许一些钩子做一些不同的事情，但是你的大部分逻辑发生在组件之外。

不要担心测试超薄选择器、简单地将状态设置为所提供的任何有效负载、API、类型或模拟用户交互的 reducer 案例。