<html>
<head>
<title>How To Write SwiftUI Using Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用测试驱动开发编写SwiftUI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-swiftui-using-test-driven-development-ace8e2f6132b?source=collection_archive---------4-----------------------#2021-11-08">https://betterprogramming.pub/how-to-write-swiftui-using-test-driven-development-ace8e2f6132b?source=collection_archive---------4-----------------------#2021-11-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9533" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为一个简单的计算器应用程序编写单元和UI测试…然后制作应用程序</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a6db519bb3672d0a7d01046f02e9c6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9rrgo0Z_Off4mb1i"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kz" href="https://unsplash.com/@element5digital?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Element5数码</a>拍摄</p></figure><p id="82d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Jean_Bartik" rel="noopener ugc nofollow" target="_blank">1945年，Jean Jennings Bartik </a>被选为从事电子数字积分器和计算机(也称为ENIAC)工作的首批六名程序员之一。</p><p id="8bb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">机器花了15分钟来计算60秒的炮弹轨迹，而人类要花40小时来完成同样的任务。作为早期的计算机，ENIAC很容易以各种机械方式出现故障，导致它输出不正确的数据。</p><p id="3343" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在纪录片《绝密玫瑰》中，她解释了他们采用的测试过程:</p><blockquote class="lw lx ly"><p id="cd69" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">Ruth【Teitelbaum】和<a class="ae kz" href="https://en.wikipedia.org/wiki/Marlyn_Meltzer" rel="noopener ugc nofollow" target="_blank">Marlyn【Meltzer】</a>被分配了计算轨迹的工作，其方式与ENIAC完全相同。所以我们有测试程序…我们将运行测试程序，如果结果正常，那么我们将运行真实轨迹，然后我们将再次运行测试轨迹…如果两个测试轨迹都正常，我们假设中间的轨迹会。Marlyn和Ruth所做的轨迹在工程师眼中给了我们有用的东西，因为有了这个程序，我们可以将ENIAC调试成真空管！</p></blockquote><p id="28dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">任何曾经编写过单元测试的人都应该熟悉这个过程。</p><p id="9097" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你知道一个函数被设计用来做什么，你应该能够输入带有已知结果的数据，并最终得到你期望的结果。</p><blockquote class="md"><p id="895d" class="me mf iu bd mg mh mi mj mk ml mm lv dk translated">测试驱动开发(TDD)得出了它的逻辑结论:如果你不知道如何测试你的代码，你甚至不应该写它。</p></blockquote><p id="994a" class="pw-post-body-paragraph la lb iu lc b ld mn jv lf lg mo jy li lj mp ll lm ln mq lp lq lr mr lt lu lv in bi translated">TDD要求您在编写允许那些相同的测试通过的代码之前，编写那些没有通过<em class="lz">的测试。不要试图在现有的代码上改造测试，在那里<strong class="lc iv">它所做的</strong>可能与<strong class="lc iv">它打算做的</strong>不同，当你的意图还在你的脑海中时，你就开始。一开始就完美地编写测试可能是不可能的，因为您看不到一路上可能遇到的所有陷阱。</em></p><p id="8ba9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在为这个简单的计算器应用程序编写测试时，我忘记了一个事实，即一个<code class="fe ms mt mu mv b">Double</code>用一个带有6个尾随零的<code class="fe ms mt mu mv b">String</code>来表示。当我的测试失败时，我喜欢这个样子，所以我回去修改了我的测试，期望有6个小数位。尽管在TDD中许多这样的小调整是必要的，但是测试的大部分结构和逻辑是不变的。</p><p id="7c64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">修改现有的测试比从头开始编写测试要容易得多。</p><p id="9a21" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你等到你的应用程序完成后才写测试，可能就没有时间或动力去正确地或广泛地写测试了。</p><h1 id="4656" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">我们开始吧</h1><p id="a242" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">我创建了一个名为<code class="fe ms mt mu mv b">TDDCalculator</code>的新Xcode项目，但是你可以随意命名你的项目。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/a9fe41e0bb52a96db1438efa2d7642bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWW8YV2KqX2qJrUG8Vk4fw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">确保您勾选了“包含测试”,这样Xcode就会为您生成测试目标</p></figure><p id="94b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">组织标识符也无关紧要，因为我们不会尝试将此应用程序提交到应用程序商店。</p><p id="c5b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，确保SwiftUI是选定的接口，并且勾选了Include Tests，这一点很重要。测试可以在以后添加，但是更容易的是勾选这个框，并在项目创建时准备好并等待Apple的示例测试。默认情况下，该项目应该附带一个名为<em class="lz"> ContentView.swift </em>的文件，其中包含一个基本的“Hello world”用户界面。</p><p id="d7a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到所有的(失败的)测试都被写完，我们才会修改用户界面。</p><h1 id="19d9" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">编写UI测试</h1><p id="9baf" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">Apple提供的示例UI测试类中有许多不必要的样板代码。我们真正需要做的是获得一个应用程序的引用，并使用该引用来启动它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">您不需要默认情况下得到的tearDownWithError函数</p></figure><p id="6c86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你不熟悉UI测试，这是一种“黑盒”方法，测试无法访问代码。</p><p id="d1c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在你的模拟器或设备上安装了一个名为test runner的独立应用程序，这个测试运行程序通过像人类用户一样点击或滑动来与你的应用程序进行交互。</p><p id="d326" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们简单的计算器应用程序不会有小数点按钮，但它将能够在答案不是整数的情况下进行计算。</p><p id="ecf2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它将能够执行加、减、乘、除的运算，从下面代码示例开头的<code class="fe ms mt mu mv b">enum</code>可以看出。这个<code class="fe ms mt mu mv b">enum</code>的每一种情况都有一个将操作符表示为<code class="fe ms mt mu mv b">String</code>的原始值，它们用文字描述主要是因为在Swift的标识符中不能使用'+'和'-'操作符。</p><p id="2b01" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里我们还有一个函数，它执行一个相当简单的任务。当我们给它一个数字时，它会把这个数字分解成单个的数字。每个数字都是通过调用<code class="fe ms mt mu mv b">app.buttons[String(digit)].tap()</code>打出来的。由于每个数字只是一个<code class="fe ms mt mu mv b">String</code>的一部分，所以需要显式地转换回来。然后我们依靠<code class="fe ms mt mu mv b">XCUIElementQuery</code>，它将在视图层次结构中搜索一个按钮，这个按钮的可访问性标签是这个数字。默认情况下，任何带有标题的按钮都将该标题作为其辅助功能标签，而不是自定义形状或图像。</p><p id="e272" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们所有的按钮都将以这种方式创建，所以我们将在所有的查询中使用这种格式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">这个函数允许UI测试运行者点击计算器数字按钮</p></figure><p id="3ef0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输入数字只是计算过程的一部分。</p><p id="89ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们想要一个测试函数，它知道当给定两个数字和一个操作符时，点击什么按钮以及我们可以期望什么结果。已经用对应于按钮的原始<code class="fe ms mt mu mv b">String</code>值创建了<code class="fe ms mt mu mv b">Operator enum</code>，所以我们可以将其中一个值传递给函数，并使用该原始值来定位按钮。equals按钮不是操作符之一，因为我们不希望出现像<code class="fe ms mt mu mv b">2 = 2</code>那样请求“计算”结果的情况。</p><p id="6eb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你对操作数这个术语不熟悉，这仅仅意味着我们在运算符两边的计算中使用的数字(加号、减号、乘号或除号)。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">现在，我们可以键入整个计算结果，并自己进行计算，以便比较结果</p></figure><p id="de92" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，使用<code class="fe ms mt mu mv b">switch</code>执行计算并返回结果，该结果将用于与屏幕上显示的内容进行比较。</p><p id="f80d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与我们到目前为止所做的相比，UI测试本身相对简单。我们使用<code class="fe ms mt mu mv b">XCTAssertTrue</code>要求应用程序启动时显示一个零，我们进行计算，并检查结果是否显示。</p><p id="2e71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个测试都有一个一位数和多位数的例子，因为我们可能会在实现更长的数字时出错。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">每个测试中都包含一个多位数计算，以确保这些计算正确</p></figure><p id="90f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想要在此时运行测试以确认它们失败，通过按下<strong class="lc iv"> Cmd + 6 </strong>打开测试导航器。</p><p id="4eaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您还没有在这里看到您的测试，通过按下<strong class="lc iv"> Cmd + Shift + U </strong>来构建用于测试的项目。以测试为目的的构建包括从应用中构建完全独立的目标，因此构建项目通常不会刷新测试列表或消除测试代码中陈旧的错误消息。</p><p id="0f49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在您可以看到所有的测试，您可以将鼠标悬停在左侧面板中的单个测试或类本身上，然后按play按钮来运行它。</p><p id="481a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码带中也有菱形按钮，如第10行的截图所示。</p><p id="a6b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些功能与左侧面板中的Test Navigator功能完全相同，同样，为了使它们保持最新，它们可能需要您为测试而构建。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nw"><img src="../Images/c331380165d72ae7fea4db4fd0f7b1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0ZEsyASup9IhCDn6jzCjg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">右侧面板中的Test Navigator允许您运行测试，并显示测试是通过还是失败</p></figure><h1 id="50a7" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">编写单元测试</h1><p id="be47" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">说到<code class="fe ms mt mu mv b">calculate(_,_,_)</code>功能，没有必要重新发明轮子。有了单元测试，我们可以直接在代码中调用函数，所以没有必要(或者实际上不可能)自己点击屏幕输入操作数和运算符。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="40e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">需要注意的是，我们将<code class="fe ms mt mu mv b">TDDCalculator</code>(或者你的项目名称)作为<code class="fe ms mt mu mv b">@testable</code>导入，因为没有这个，类和函数将无法访问。</p><p id="8410" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果没有它，类将被视为<code class="fe ms mt mu mv b">internal</code>，即使它们被标记为<code class="fe ms mt mu mv b">public</code>。</p><p id="569f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们已经达到了在不产生构建错误的情况下可以编写的测试的极限。这是因为我们想要创建一个名为<code class="fe ms mt mu mv b">CalculatorViewModel</code>的类的实例。</p><p id="6035" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了尽快回到编写测试上来，我尽可能定义了最简单的形式。</p><p id="e57c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在应用程序的主文件夹中创建一个名为<em class="lz">calculatorviewmodel . swift</em>的文件，而不是你的任何测试所在的位置。我们需要再次创建Operator enum，因为主应用程序目标不知道UI测试目标中的那个。</p><p id="dc5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来我添加了<code class="fe ms mt mu mv b">Calculatable</code>协议，它定义了属性是什么以及函数签名是什么样子。</p><p id="d1c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该协议也符合<code class="fe ms mt mu mv b">ObservableObject</code>协议，这意味着当<code class="fe ms mt mu mv b">CalculatorViewModel</code>中的数据改变时，我们的用户界面将自动刷新。我提供的<code class="fe ms mt mu mv b">CalculatorViewModel</code>使用了<code class="fe ms mt mu mv b">@Published</code>装饰来表明我们希望SwiftUI注意这些属性的变化。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">协议是为一个类或结构设置最低要求的好方法</p></figure><p id="1389" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我提供的<code class="fe ms mt mu mv b">calculate(_,_,_)</code>函数将总是返回<code class="fe ms mt mu mv b">-1</code>，原因很简单。</p><p id="ac71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我想在这里做最少的工作，这样我就可以写我的(失败的)测试，这正是我接下来要做的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="c294" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于不需要点击或滑动，我们所要做的就是将<code class="fe ms mt mu mv b">CalculatorViewModel.calculate(_,_,_)</code>的结果与<code class="fe ms mt mu mv b">TDDCalculatorTests.calculate(_,_,_)</code>的结果进行比较。我们可以用<code class="fe ms mt mu mv b">XCTAssertEqual</code>来做到这一点，它接受两个值，如果它们不同，测试就会失败。</p><p id="ec66" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想运行单元测试并看到它们失败，请继续。没有一个答案是<code class="fe ms mt mu mv b">-1</code>，我们写了<code class="fe ms mt mu mv b">CalculatorViewModel</code>来返回这个值。当你准备好制作一个实际运行的calculate函数版本时，请查看下面的内容。该函数与之前的迭代之间的主要区别在于，它将<code class="fe ms mt mu mv b">operatorType</code>设置为零，将<code class="fe ms mt mu mv b">operand1</code>设置为答案(以防您想要进行更多操作),并将<code class="fe ms mt mu mv b">operand2</code>重置为零。</p><p id="ccf1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将返回答案，以便可以更新用户界面。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="6f72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lz">“什么用户界面？”你可能会问。</em></p><p id="bb29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们要创造它了！</p><h1 id="de52" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">创建用户界面</h1><p id="c20a" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">每个计算器都有一个显示屏，显示最近输入的数字。我们不会提供一个<em class="lz"> C </em>或<em class="lz"> AC按钮</em>来清除输入，所以在我们指定一个操作之前，数字将一直保留在屏幕上。这个视图所做的只是用圆角矩形轮廓显示与屏幕右侧对齐的数字。字体是Menlo，这是一种等宽字体，以相同的宽度显示所有数字。</p><p id="b90c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用<code class="fe ms mt mu mv b">Color.primary</code>，我们避免了黑暗模式的问题，因为这将在明亮模式下显示为黑色，在黑暗模式下显示为白色。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="7c24" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后一段代码相当长，但它基本上包含了整个用户界面。</p><p id="b36c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们从<code class="fe ms mt mu mv b">CalculatorButtonStyle</code>开始，它将应用于界面中的每一个按钮。就<code class="fe ms mt mu mv b">Color</code>而言，这基本上与<code class="fe ms mt mu mv b">DisplayView</code>相反，利用<code class="fe ms mt mu mv b">UIColor.systemBackground</code>在亮模式下给我们白色，在暗模式下给我们黑色。按钮的纵横比被设置为1，以便强制它们显示为圆形方形。</p><p id="34dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你不介意每个按钮都是一个宽大于高的矩形，你可以删除那一行。</p><p id="dd06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">定义了一个自适应的<code class="fe ms mt mu mv b">GridItem</code>来指定我们的列应该是什么样子。</p><p id="b5c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为它们是自适应的，所以列的数量可以根据所提供的空间而变化。在横向模式下，计算器将是宽的，而在纵向模式下，计算器将是高的。每次点击一个数字按钮，我们都会使用一个名为<code class="fe ms mt mu mv b">appendDigit(_:)</code>的功能。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div></figure><p id="f6e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当点击一个操作员时，显示被清除，因此可以输入一个新的数字。</p><p id="23de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是当显示一个答案时会发生什么呢？</p><p id="a46d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输入一个新的数字应该可以清除答案，因为我们不想添加新的数字。</p><p id="373c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经用一个名为<code class="fe ms mt mu mv b">answerShown</code>的布尔值粗略地完成了这项工作，只要输入一个新数字，它就会被设置为false。</p><p id="1eae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它应该是这样的:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nx"><img src="../Images/85a2f0f14f3f37a228e3f3fc45093d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRz2dGFWoPkhamQh_vTNww.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">自适应网格根据设备的大小改变计算器的形状</p></figure><p id="c4d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/sturdysturge/TDDCalculator" rel="noopener ugc nofollow" target="_blank">如果你需要看到完整的代码，可以在GitHub </a>上找到。</p><p id="7a0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果代码样本中有错误，或者如果你有问题，请在下面的回复中告诉我。</p><h1 id="704c" class="mw mx iu bd my mz na nb nc nd ne nf ng ka nh kb ni kd nj ke nk kg nl kh nm nn bi translated">后续步骤</h1><p id="35d6" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">你知道一个计算器通常能做什么，TDD不止于此。无论您是想要添加小数点按钮、C/AC按钮，还是M+/M-/MRC按钮，该功能都是从测试开始的。</p><p id="b1b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你按下这些按钮时，你希望用户界面做什么？</p><p id="f28b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的单元测试将如何确保代码以您期望的方式计算或返回值？</p><p id="ee83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">无论您是在ENIAC上计算shell轨迹，还是使用M1 Max MacBook Pro构建跨平台Swift应用程序，在您开始编程之前，测试已经存在，因此测试您的代码要容易得多。</p></div></div>    
</body>
</html>