# Swift 5.7 中如何使用通用协议实现动态调度

> 原文：<https://betterprogramming.pub/how-to-achieve-dynamic-dispatch-using-generic-protocols-in-swift-5-7-cac664d481e0>

## 从来没有这么简单过！

![](img/05a62b96d2c9d50fe0b7ad6d97a070a8.png)

动态调度是面向对象编程中最重要的机制之一。它是使运行时多态性成为可能的核心机制，使开发人员能够编写在运行时而不是编译时决定其执行路径的代码。

在 OOP 中实现动态调度似乎很容易，但在面向协议编程(POP)中却不是这样。由于 Swift 编译器中的各种限制，试图使用协议完成动态调度总是会遇到无法预料的困难。

随着 Swift 5.7 的发布，这一切都成为了历史！在 POP 领域实现动态调度从未如此简单。在本文中，让我们探讨一下 Swift 5.7 带来了哪些改进，以及使用带有关联类型的协议实现动态调度需要做些什么。

所以，事不宜迟，让我们开始吧！

> 注意:
> 
> 如果你对 Swift 中的`some`和`any`关键字不熟悉，我强烈建议你首先阅读我的博客文章《理解 Swift 5.7 中的“一些”和“任何”关键字》。

# 重要的事情先来

在我开始向您展示 Swift 5.7 的改进之前，让我们定义本文中样本代码所需的协议和结构。

我们上面的定义类似于我们在我的[上一篇](https://swiftsenpai.com/swift/understanding-some-and-any/)文章中使用的定义，但是有一点扭曲。在我们的`Vehicle`协议中，我们有两个功能需求，`startEngin()`和`fillGasTank(with:)`。为了便于演示，我们将尝试在`Car`和`Bus`结构中使用这两个函数来实现动态调度。

# Swift 5.6 及以下版本中通用协议的局限性

现在，假设我们想要创建一个接受异构数组的`startAllEngin()`函数，如下所示:

您会注意到，在 Swift 5.6 中，这实际上是不可能的，因为您会得到一个错误提示:“协议‘Vehicle’只能用作通用约束，因为它具有自身或关联的类型要求”。Swift 编译器禁止我们创建以`Vehicle`为元素类型的异构数组，因为`Vehicle`有一个关联的类型(`FuelType`)。

> 专业提示:
> 
> 如果您想了解有关该错误的更多信息，以及如何在 Swift 5.7 之前解决该错误，请查看我在 Medium 上发表的文章:“ [Swift:在 PATs(具有关联类型的协议)上实现动态调度](https://leekahseng.medium.com/accomplishing-dynamic-dispatch-on-pats-protocol-with-associated-types-b29d1242e939)”

由于苹果对 Swift 编译器进行了升级，这一限制在 Swift 5.7 中不再存在。我们终于可以像在 OOP 中使用超类一样使用协议了。让我告诉你怎么做。

# 对简单函数执行动态调度

在 Swift 5.7 中，编译器不再禁止创建异构数组。我们需要做的就是使用`any`关键字。

通过使用`any`关键字，我们告诉编译器数组将包含存在类型，并且它们的底层具体类型将总是符合`Vehicle`协议。

这样，调用`startAllEngin(for:)`就会得到我们想要的动态调度。

# 对带有泛型参数的函数执行动态调度

现在让我们来看看另一个更复杂的例子。假设我们想要创建一个名为`fillAllGasTank(for:)`的函数。该函数将根据给定的`vehicles`数组对车辆的`fillGasTank(with:)`函数进行动态调度。

## 定义泛型参数类型

一开始，我们试图实现的目标似乎很简单，但是当我们开始编码时，我们会遇到第一个问题:

由于不同类型的车辆需要不同种类的燃料，我们必须创建一个通用协议来表示`Gasoline`和`Diesel`。让我们继续做那件事。

`Fuel`协议只是一个简单的协议，由一个名为`FuelType`的关联类型和一个静态`purchase()`函数组成。注意我们如何约束`FuelType`总是等于符合`Fuel`协议的类型。为了让编译器确定静态`purchase()`函数返回的具体类型，这个约束非常重要。

接下来，让我们使`Gasoline`和`Diesel`都符合`Fuel`协议。

除此之外，我们还需要确保`Vehicle`协议的`FuelType`是符合`Fuel`协议的类型。

## “任何”到“一些”的转换

随着`Fuel`协议和所有其他相关变更的就绪，我们现在可以重新访问`fillAllGasTank(for:)`函数并对其进行相应的更新。

在上面的代码中，注意我们如何利用车辆的燃料类型来获取`Fuel`具体类型的实例，这样我们就可以将它传递给`fillGasTank(with:)`函数。

不幸的是，如果我们试图编译我们的代码，我们将遇到我们的第二个问题: **" *成员“fillGasTank”不能用于类型“any Vehicle”的值；考虑使用一个通用约束来代替“*** ”。那是什么意思？

为了理解我们得到的错误，让我们快速回顾一下`some`和`any`关键字之间的区别。

![](img/ab4d10c336259562c6fb897c07d2036e.png)

如上图所示，存在类型的底层具体类型被包装在一个盒子里。因此，编译器禁止我们访问`fillGasTank(with:)`函数。为此，在访问`fillGasTank(with:)`函数之前，我们必须首先将存在类型转换(拆箱)为不透明类型。

幸运的是，苹果在 Swift 5.7 中已经使转换(拆箱)过程变得极其容易。我们所要做的就是将存在类型传递给一个接受不透明类型的函数，转换就会自动发生。

这样，我们现在可以编译和执行我们的代码，没有任何错误。

如果您想亲自尝试，可以在这里随意获取完整的示例代码[。](https://gist.github.com/LeeKahSeng/a347da1778c71f55537eda991bd56c64)

# 包扎

你有它！这就是我们如何在具有关联类型的协议上实现动态调度。综上所述，以下是 Swift 5.7 中使所有这些成为可能的改进:

1.  消除使用具有关联类型的协议创建异构数组的限制。
2.  允许在函数的参数位置使用`any`和`some`关键字。
3.  从存在型到不透明型的自动转换，反之亦然。

如果你喜欢这篇文章，请随时在 Twitter 上关注我，并订阅我的每月简讯，这样你就不会错过我即将发表的任何文章。

感谢阅读。

# 资源

*   [Swift:完成 PATs(关联类型的协议)的动态调度](https://leekahseng.medium.com/accomplishing-dynamic-dispatch-on-pats-protocol-with-associated-types-b29d1242e939)