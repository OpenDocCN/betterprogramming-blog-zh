<html>
<head>
<title>Designing a Supply Chain Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计供应链智能合约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/supply-chain-smart-contract-design-e0ae5071bcbe?source=collection_archive---------9-----------------------#2022-10-04">https://betterprogramming.pub/supply-chain-smart-contract-design-e0ae5071bcbe?source=collection_archive---------9-----------------------#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6dd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简化农业供应链网络的运作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12189ab6578116cf7b54dfc11d77b064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atzFP_axxksTVViKfnDmmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">供应链|作者图片</p></figure><p id="1104" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">农业在为全球70亿公民提供衣食方面发挥着至关重要的作用。超过25%的世界人口受雇于农业部门。为了满足全球化世界的需求，农业供应链已经形成了漫长而复杂的生产、加工、分销和营销渠道网络。他们由农民、加工商、贸易商、物流供应商、金融公司、消费者和许多其他人组成，每一个人的利益经常是多种多样和相互冲突的。</p><p id="98c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">农业是全球经济的主要贡献者，每年的收入超过6万亿美元。这个行业为世界提供了基本商品，如大米、玉米、小麦和牲畜。然而，尽管农业供应链在为全球提供基本产品方面发挥着至关重要的作用，但它面临着许多跨地域和跨商品的共同挑战。</p><p id="362a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">区块链技术创造了单一的真理来源。这对于供应链来说很重要，因为供应链中的多个参与者并不一定相互信任。</p><p id="50f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们采用了一种实用的方法来研究代码。本文中的例子旨在简化农业供应链的运作。它提高了农民、经销商、零售商和消费者之间的透明度和效率。</p><h1 id="ef57" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">流程图</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/60fb1913d0cc2bff64c6c7feeb5b03b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MC-4EjYtl0jrpHuwwHh0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流程图</p></figure><h2 id="41cf" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated">功能</h2><ol class=""><li id="5888" class="mz na it la b lb nb le nc lh nd ll ne lp nf lt ng nh ni nj bi translated">Farmer创建了一个产品，并列出要由经销商购买的产品</li><li id="d528" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">农民运送产品</li><li id="cdff" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">经销商接收产品，加工产品，包装产品，并将其投放市场</li><li id="b4fd" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">零售商从分销商处购买产品</li><li id="c044" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">分销商将产品运送给零售商</li><li id="41a9" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">零售商收到产品并将其出售</li><li id="7a8f" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">消费者购买产品</li></ol><h2 id="db2f" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated">环境设置</h2><p id="672e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">让我们克隆存储库并安装依赖项:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="391d" class="mn lv it nt b gy nx ny l nz oa">git clone <a class="ae ob" href="https://github.com/ac12644/Supply-Chain.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ac12644/Supply-Chain.git</a><br/>cd Supply-Chain<br/>yarn or npm install</span></pre><p id="7632" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在导航到<code class="fe oc od oe nt b">/contracts</code>文件夹，并按给定方式创建文件夹:</p><p id="0a55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将看到四个文件夹:</p><ul class=""><li id="1ed3" class="mz na it la b lb lc le lf lh of ll og lp oh lt oi nh ni nj bi translated"><code class="fe oc od oe nt b">/access</code>文件夹包含农民、经销商、零售商&amp;消费者的角色</li><li id="021d" class="mz na it la b lb nk le nl lh nm ll nn lp no lt oi nh ni nj bi translated"><code class="fe oc od oe nt b">/ownership</code>文件夹包含一个solidity文件<code class="fe oc od oe nt b">Ownable.sol</code>，将功能限制在选定的地址，类似于你在<a class="ae ob" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> openzeppelin </a>上看到的</li><li id="f324" class="mz na it la b lb nk le nl lh nm ll nn lp no lt oi nh ni nj bi translated"><code class="fe oc od oe nt b">/supplyChain</code>文件夹包含了链的结构</li><li id="f2c3" class="mz na it la b lb nk le nl lh nm ll nn lp no lt oi nh ni nj bi translated"><code class="fe oc od oe nt b">/utils</code>文件夹包含一个<code class="fe oc od oe nt b">Context.sol</code>，它提供关于当前执行上下文的信息，包括事务的发送者及其数据，取自<a class="ae ob" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol" rel="noopener ugc nofollow" target="_blank"> openzeppelin </a>。</li></ul><p id="89c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先为角色设计一个智能契约，为此我们使用<code class="fe oc od oe nt b">/access</code>文件夹。</p><h2 id="4a63" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/Roles.sol" rel="noopener ugc nofollow" target="_blank">角色. sol </a></h2><p id="c574" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">该合同将用于管理平台上的角色。它提供了添加、删除和查询角色信息的功能。这将被导入到我们的其他角色智能合同中。</p><ol class=""><li id="5a25" class="mz na it la b lb lc le lf lh of ll og lp oh lt ng nh ni nj bi translated">让我们从创建<code class="fe oc od oe nt b">library Roles</code>开始:</li></ol><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="672c" class="mn lv it nt b gy nx ny l nz oa">library Roles {<br/>  ...<br/>}</span></pre><p id="33ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.现在，我们创建<code class="fe oc od oe nt b">struct Role</code>来设置地址。为此，您必须创建一个映射，将布尔值中的地址映射到载体。</p><p id="9a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须创建一个映射，将地址映射到载体的布尔值。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b09b" class="mn lv it nt b gy nx ny l nz oa">library Roles {<br/>  struct Role {<br/>    mapping(address =&gt; bool) bearer;<br/>  }<br/>  ...<br/>}</span></pre><p id="7040" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.创建具有存储角色的内部函数<code class="fe oc od oe nt b">add</code>和账户地址，以检查该地址正在传递未连接的账户且之前未添加:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5622" class="mn lv it nt b gy nx ny l nz oa">function add( Role storage role, address account) internal {<br/>  require(account != address(0));  <br/>  require(!has(role, account));<br/>}</span></pre><p id="3358" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.类似地，我们创建<code class="fe oc od oe nt b">remove</code>函数，在这里我们检查传递的地址不是关联的帐户，并且该地址确实存在于给定的角色中，最后将存储中的角色值设置为false。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="2cc3" class="mn lv it nt b gy nx ny l nz oa">function remove( Role storage role, address account) internal {<br/>  require(account != address(0));  <br/>  require(has(role, account));</span><span id="f400" class="mn lv it nt b gy oj ny l nz oa">role.bearer[account] = false;<br/>}</span></pre><p id="9acc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.在最后一步，创建一个函数<code class="fe oc od oe nt b">has</code>来检查帐户是否有角色，它返回一个布尔值:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1a0f" class="mn lv it nt b gy nx ny l nz oa">function remove( Role storage role, address account) <br/>  internal <br/>  view <br/>  returns (bool)</span><span id="0eba" class="mn lv it nt b gy oj ny l nz oa">{<br/>  require(account != address(0));  <br/>  return role.bearer[account];<br/>}</span></pre><p id="7713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.完成后，您的智能合约看起来如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">角色. sol</p></figure><h2 id="4798" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/FarmerRole.sol" rel="noopener ugc nofollow" target="_blank">农民角色</a></h2><p id="e152" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">现在，我们使用之前的<code class="fe oc od oe nt b">Roles</code>库合同为农民创建新角色。</p><ol class=""><li id="e7f2" class="mz na it la b lb lc le lf lh of ll og lp oh lt ng nh ni nj bi translated">让我们从创建一个合同<code class="fe oc od oe nt b">FarmerRole</code>文件开始，并使用<code class="fe oc od oe nt b">struct Role</code> <code class="fe oc od oe nt b">Role</code>库。</li></ol><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="e950" class="mn lv it nt b gy nx ny l nz oa">contract FarmerRole is Context {<br/>  using Roles for Roles.Role<br/>  ...<br/>}</span></pre><p id="65a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.如果成功添加或删除农民，创建两个事件来捕获。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c784" class="mn lv it nt b gy nx ny l nz oa">event FarmerAdded(address indexed account); <br/>event FarmerRemoved(address indexed account);</span></pre><p id="a455" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.通过从<code class="fe oc od oe nt b">Roles</code>库<code class="fe oc od oe nt b">struct Role</code>继承来定义一个结构<code class="fe oc od oe nt b">farmers</code>。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a34b" class="mn lv it nt b gy nx ny l nz oa">Roles.Role private farmers;</span></pre><p id="80a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.合同的部署地址将被添加为第一个农民。使用协定的构造函数时，必须执行协定的初始设置。使用构造函数将确保在协定创建期间进行初始化。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1950" class="mn lv it nt b gy nx ny l nz oa">constructor() public { _addFarmer(_msgSender()); }</span></pre><p id="56db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.定义一个修饰符来检查调用函数的地址是否有合适的角色。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="cc0c" class="mn lv it nt b gy nx ny l nz oa">modifier onlyFarmer() { <br/>  require(isFarmer(_msgSender())); <br/>  _; <br/>}</span></pre><p id="16f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.创建一个函数来检查地址是否是farmer，它返回一个布尔值。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c945" class="mn lv it nt b gy nx ny l nz oa">function isFarmer(address account) <br/>  public <br/>  view <br/>  returns (bool) <br/>  { <br/>    return farmers.has(account); <br/>  }</span></pre><p id="cc34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.现在，让我们来看看添加和删除<code class="fe oc od oe nt b">Farmer</code>角色的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d357" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe nt b">Farmer</code>角色智能合约完成，请看下图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">法默罗尔.索尔</p></figure><p id="0e53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们创建其他角色<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/DistributorRole.sol" rel="noopener ugc nofollow" target="_blank">DistributorRole.sol</a></code>、<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/RetailerRole.sol" rel="noopener ugc nofollow" target="_blank">RetailerRole.sol</a></code>和<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/ConsumerRole.sol" rel="noopener ugc nofollow" target="_blank">ConsumerRole.sol</a></code>，我们重复<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/access/FarmerRole.sol" rel="noopener ugc nofollow" target="_blank">FarmerRole.sol</a></code>中给出的相同过程，只是根据角色改变函数和变量的名称。</p><p id="41b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们转到主合同<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/supplyChain/SupplyChain.sol" rel="noopener ugc nofollow" target="_blank">SupplyChain.sol</a></code>。</p><h2 id="82c3" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/supplyChain/SupplyChain.sol" rel="noopener ugc nofollow" target="_blank">供应链</a></h2><p id="59ad" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">这个智能合同包含了供应链背后的所有逻辑。一个农民创造了一种产品并把它放在市场上销售，一个经销商购买它，卖给一个零售商，然后零售商再把它卖给消费者。整个过程是透明的，区块链上的每个人都可以看到，因此没有出错或欺诈的机会。</p><ol class=""><li id="1b61" class="mz na it la b lb lc le lf lh of ll og lp oh lt ng nh ni nj bi translated">让我们首先导入我们之前创建的所有必要的契约，并创建一个契约<code class="fe oc od oe nt b">SupplyChain</code>。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">供应链合同模式</p></figure><p id="93b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.存储当前连接的电子钱包的地址。请在之后保存钱包地址。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6869" class="mn lv it nt b gy nx ny l nz oa">address owner;</span></pre><p id="6b4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.由农民生成的产品代码印在产品上，由经销商验证。<code class="fe oc od oe nt b">productCode</code>存储该值。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1955" class="mn lv it nt b gy nx ny l nz oa">uint256 productCode;</span></pre><p id="d8fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.记录由<code class="fe oc od oe nt b">Farmer</code>创建的库存单位数量。<code class="fe oc od oe nt b">stockUnit</code>存储该值。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="dce9" class="mn lv it nt b gy nx ny l nz oa">uint256 stockUnit;</span></pre><p id="57d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.创建映射<code class="fe oc od oe nt b">items</code>，将产品代码映射到稍后将在<code class="fe oc od oe nt b">struct</code>中创建的项目。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="21be" class="mn lv it nt b gy nx ny l nz oa">mapping(uint256 =&gt; Item) items;</span></pre><p id="e74d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.定义一个公共映射<code class="fe oc od oe nt b">itemsHistory</code>，将产品代码映射到一个数组<code class="fe oc od oe nt b">TxHash</code>，该数组跟踪产品在供应链中的行程——从应用程序发送。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c724" class="mn lv it nt b gy nx ny l nz oa">mapping(uint256 =&gt; Txblocks) itemsHistory;</span></pre><p id="23a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.现在创建一个州，用以下值跟踪产品的生产过程，并将默认州设置为由农民生产。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">供应链流程的状态</p></figure><p id="bb68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.创建一个结构来存储所需的所有产品详细信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目结构</p></figure><p id="3906" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.创建一个结构来存储<code class="fe oc od oe nt b">farmer-distributor</code>、<code class="fe oc od oe nt b">distributor-retailer</code>和<code class="fe oc od oe nt b">retailer-consumer</code>之间事务的块地址。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5ad7" class="mn lv it nt b gy nx ny l nz oa">struct Txblocks { <br/>  uint256 FTD; // block of farmerToDistributor <br/>  uint256 DTR; // block of DistributorToRetailer <br/>  uint256 RTC; // block of RetailerToConsumer <br/>}</span></pre><p id="4b63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">8.现在为所有函数创建事件，这些事件将在作业成功完成时发出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">供应链事件</p></figure><p id="199c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">9.创建一个修饰符，检查地址是否是合同的所有者。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="f71b" class="mn lv it nt b gy nx ny l nz oa">modifier only_Owner() {<br/>  require(_msgSender() == owner);        <br/>  _;    <br/>}</span></pre><p id="f5c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">10.定义一个修改量来验证<code class="fe oc od oe nt b">Caller</code>，然后定义另一个修改量来检查支付的金额是否足以支付价格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7aa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">11.现在，我们定义修改量来检查产品代码是否存在，并更新产品的当前状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="34cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">12.创建一个构造函数来设置所有者、库存单位和产品代码。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9b60" class="mn lv it nt b gy nx ny l nz oa">constructor() public payable {        <br/>  owner = _msgSender();        <br/>  stockUnit = 1;        <br/>  productCode = 1;    <br/>}</span></pre><p id="1f89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">13.现在，创建一个允许您将地址转换为可支付地址的函数。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="4cc0" class="mn lv it nt b gy nx ny l nz oa">function _make_payable(address x) internal pure <br/>returns (address payable) { <br/>  return payable(address(uint160(x))); <br/>}</span></pre><p id="a367" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">14.为所有者创建一个kill函数，将合同中存储的所有剩余乙醚发送到所有者的地址。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="152c" class="mn lv it nt b gy nx ny l nz oa">function kill() public { <br/>  if (_msgSender() == owner) { <br/>    address payable ownerAddressPayable = _make_payable(owner);<br/>    selfdestruct(ownerAddressPayable); <br/>  } <br/>}</span></pre><p id="7252" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">15.现在，让我们创建一个允许<code class="fe oc od oe nt b">Farmer</code>创建产品的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建产品</p></figure><p id="5d44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">16.让我们创建一个函数，允许农民销售您创建的产品，另一个函数允许分销商从农民那里购买产品。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向分销商销售产品的功能</p></figure><p id="e7e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">17.当经销商购买产品时，农民需要发货，经销商需要收货。我们可以通过创建发货和收货功能来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="fbd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">18.<code class="fe oc od oe nt b">Distributor</code>列出的产品现在必须由<code class="fe oc od oe nt b">Retailer</code>购买。在<code class="fe oc od oe nt b">Retailer</code>购买产品后，<code class="fe oc od oe nt b">Distributor</code>将产品发送给<code class="fe oc od oe nt b">Retailer</code>，后者需要接收产品。为此，需要创建三个函数:一个用于<code class="fe oc od oe nt b">Retailer</code>购买产品，一个允许<code class="fe oc od oe nt b">Distributor</code>运送产品，一个用于<code class="fe oc od oe nt b">Retailer</code>接收产品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加工、包装和销售清单的功能</p></figure><p id="2175" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">19.<code class="fe oc od oe nt b">Distributor</code>列出的产品现在由<code class="fe oc od oe nt b">Retailer</code>购买。在<code class="fe oc od oe nt b">Retailer</code>购买后，<code class="fe oc od oe nt b">Distributor</code>会运送产品，<code class="fe oc od oe nt b">Retailer</code>会收到。为此，需要创建三个函数:一个用于<code class="fe oc od oe nt b">Retailer</code>购买产品，一个用于<code class="fe oc od oe nt b">Distributor</code>发货，一个用于<code class="fe oc od oe nt b">Retailer</code>接收产品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="8e09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">20.现在，我们还剩两步。第一步是把产品放在零售商的货架上，让它一直放着，直到消费者出现。第二步是让消费者购买该产品。让我们看看如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b5e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">21.现在是创建获取产品的函数的时候了:我们创建了三个函数<code class="fe oc od oe nt b">fetchItemBufferOne</code>、<code class="fe oc od oe nt b">fetchItemBufferTwo</code>和<code class="fe oc od oe nt b">fetchitemHistory</code>。</p><p id="cb65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe nt b">fetchItemBufferOne</code>:该功能仅获取创建时生成的产品创建信息。</p><p id="fbfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe nt b">fetchItemBufferTwo</code>:获取产品信息，包括所有参与者的地址</p><p id="2c33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe nt b">fetchitemHistory</code>:获取农民到分销商、分销商到零售商、零售商到消费者的流程的块数据</p><p id="1372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这些函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取数据的函数</p></figure><p id="a6ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们的供应链智能合同完成了，你可以在这里看一下最终合同<a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/contracts/supplyChain/SupplyChain.sol" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c036" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">测试和部署</h1><p id="1192" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">现在，我们在多边形网络上测试、编译和部署契约。我已经包含了一个<a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/test/SupplyChain.js" rel="noopener ugc nofollow" target="_blank">测试文件</a>，您可以使用它进行测试。您还必须检查<code class="fe oc od oe nt b"><a class="ae ob" href="https://github.com/ac12644/Supply-Chain-Smart-Contract/blob/main/truffle-config.js" rel="noopener ugc nofollow" target="_blank">truffle-config.js</a></code>中的配置。</p><p id="2dae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要部署合同，请运行以下命令:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="793b" class="mn lv it nt b gy nx ny l nz oa">truffle develop</span><span id="3cdc" class="mn lv it nt b gy oj ny l nz oa">$truffle(develop)&gt; test<br/>$truffle(develop)&gt; deploy</span></pre><p id="5bbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜🤩！您的合同已成功部署。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="e857" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><h2 id="ca95" class="mn lv it bd lw mo mp dn ma mq mr dp me lh ms mt mg ll mu mv mi lp mw mx mk my bi translated">想要更多吗？</h2><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/create-your-initial-coin-offering-ico-contract-in-ethereum-5a94ec3e2337"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">如何在以太坊创建您的初始硬币发售(ICO)合同</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">让你的众筹更进一步</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">better编程. pub</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>