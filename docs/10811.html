<html>
<head>
<title>From JQuery to React, Vue, Angular — The Evolution of Frontend Frameworks and There Difference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从JQuery到React、Vue、Angular——前端框架的演变及其差异</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-jquery-to-react-vue-angular-the-evolution-of-frontend-frameworks-and-there-difference-3e6b6fcc6200?source=collection_archive---------5-----------------------#2022-01-28">https://betterprogramming.pub/from-jquery-to-react-vue-angular-the-evolution-of-frontend-frameworks-and-there-difference-3e6b6fcc6200?source=collection_archive---------5-----------------------#2022-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="930c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是前端面试中必然要问的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7078aa54d817e0dcfe0eb4d4d6c1a804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MgdFO0IcpzqnLkOn5GAfA.png"/></div></div></figure><p id="f896" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些年来，前端开发一直在不断改进。从简单的静态页面到现在复杂的单页应用，我们的工具变得越来越强大。现在，三种前端框架统治着前端开发，那么你知道这三种框架的区别吗？为什么一直保持着三足鼎立的局面，而没有一个确定的框架来统一其他的呢？让我们在本文中讨论这些问题。</p><h1 id="d0a9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">前端开发的演变</h1><h2 id="10d2" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">PHP &amp;&amp; JSP</h2><p id="0a66" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">早些年，网页的动态内容是在服务器端渲染的，主要使用PHP、JSP等技术。</p><p id="6a9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，服务器通过模板引擎填充数据，然后生成HTML，并将HTML返回给浏览器进行渲染。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0553" class="mi lr it na b gy ne nf l ng nh">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="9e20" class="mi lr it na b gy ni nf l ng nh">&lt;h1&gt;My first PHP page&lt;/h1&gt;</span><span id="74e3" class="mi lr it na b gy ni nf l ng nh">&lt;?php<br/>echo "Hello World!";<br/>?&gt;</span><span id="4c44" class="mi lr it na b gy ni nf l ng nh">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="2d35" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">创建交互式、快速动态网页应用的网页开发技术</h2><p id="6625" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">后来有了AJAX技术，JavaScript可以直接在浏览器中发送异步HTTP请求，从服务器动态获取数据，而不是把所有数据都放在HTML中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b8f4" class="mi lr it na b gy ne nf l ng nh">&lt;body&gt;<br/>  &lt;h2&gt;Hello world&lt;/h2&gt;<br/>  &lt;div id="demo"&gt;&lt;/div&gt;<br/>  &lt;script&gt;<br/>    var xhttp = new XMLHttpRequest();<br/>    xhttp.onreadystatechange = function () {<br/>      if (this.readyState == 4 &amp;&amp; this.status == 200) {<br/>        // Typical action to be performed when the document is ready:<br/>        document.getElementById("demo").innerHTML = xhttp.responseText;<br/>      }<br/>    };<br/>    xhttp.open("GET", "/api/data", true);<br/>    xhttp.send();<br/>  &lt;/script&gt;<br/>&lt;/body&gt;</span></pre><p id="af31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最早的AJAX是基于XML的，所以我们现在用JavaScript发送HTTP请求的时候，用到的函数叫做<code class="fe nj nk nl na b"><strong class="kw iu">XML</strong>HttpRequest</code>。但是XML中有很多不必要的标签，浪费了服务器带宽，所以JSON格式的数据占据了主流地位。</p><h2 id="dea0" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">DOM API和jQuery</h2><p id="22a7" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">以前开发网页的时候，主要是通过浏览器提供的DOM API来操作DOM。</p><p id="4e8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是DOM API比较繁琐，在不同浏览器中存在兼容性问题。为了简化dom操作，兼容不同的浏览器，jQuery开始流行。在当时，jQuery可以说是前端开发人员必须学习的技术。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bf05" class="mi lr it na b gy ne nf l ng nh">$( "button.continue" ).html( "Next Step..." )</span></pre><h2 id="bc1b" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">前端框架</h2><p id="057e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">然后在开发网页的时候，我们发现一个网页需要做的就是先从服务器获取数据，然后根据数据更新DOM。</p><p id="69a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且这个过程是固定的。为了简化DOM操作，人们发明了MVVM框架来自动将数据更改映射到DOM更新，而不需要手动操作DOM。前端框架Angular，React，Vue就是这么做的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fde4" class="mi lr it na b gy ne nf l ng nh">import { useState } from 'react'</span><span id="cc33" class="mi lr it na b gy ni nf l ng nh">function Counter() {<br/>  <br/>  const [count, setCount] = useState(0)</span><span id="ba93" class="mi lr it na b gy ni nf l ng nh">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;you clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increase&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;decrease&lt;/button&gt;<br/>  &lt;/div&gt;)<br/>}</span><span id="4f45" class="mi lr it na b gy ni nf l ng nh">export default Counter</span></pre><p id="4fde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，前端框架也支持DOM的逻辑划分。我们可以将DOM的一部分封装成组件，将组件相互组合起来形成整个应用。</p><p id="65ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种思路可以让我们把一个复杂的页面拆分成不同的组件，方便我们开发项目。</p><h1 id="caaf" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">反应、Vue、角度之间的差异</h1><p id="321c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这些前端框架主要使用以下思想:</p><blockquote class="nm"><p id="2af3" class="nn no it bd np nq nr ns nt nu nv lp dk translated">UI = f(状态)</p></blockquote><p id="4a4a" class="pw-post-body-paragraph ku kv it kw b kx nw ju kz la nx jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">我们只需要声明组件的状态、视图以及组件之间的依赖关系，然后组件的UI就会自动生成。</p><p id="8a5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然它们的核心思想是相同的，但是这些框架的实现细节是不同的。下面我们来分析一下。</p><h2 id="2157" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">反应JSX与Vue模板</h2><p id="3b03" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在描述视图层时，React和Vue给出了不同的解决方案。React选择扩展JavaScript并引入JSX。而Vue创建了独立的模板语法。</p><p id="6dbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSX反应过来:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="90fc" class="mi lr it na b gy ne nf l ng nh">export default function TodoList() {<br/>  let list = ['JavaScript', 'React', 'Vue']<br/>  return &lt;div&gt;<br/>    {<br/>      list.map(item =&gt; &lt;li&gt;{ item }&lt;/li&gt;)<br/>    }<br/>  &lt;/div&gt;<br/>}</span></pre><p id="c30d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vue模板:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f4ba" class="mi lr it na b gy ne nf l ng nh">&lt;ul id="array-rendering"&gt;<br/>  &lt;li v-for="item in items"&gt;<br/>    {{ item.message }}<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="ef55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSX的优势:</p><ul class=""><li id="c085" class="ob oc it kw b kx ky la lb ld od lh oe ll of lp og oh oi oj bi translated">在编写JSX时，开发人员可以使用他们现有的JavaScript知识，而不需要太多额外的学习成本。</li><li id="ba60" class="ob oc it kw b kx ok la ol ld om lh on ll oo lp og oh oi oj bi translated">JSX可以利用JavaScript本身的特性，所以更强大。</li><li id="233b" class="ob oc it kw b kx ok la ol ld om lh on ll oo lp og oh oi oj bi translated">JSX代码和普通的JavaScript代码将在相同的执行上下文中执行，因此JSX可以很容易地与TypeScript结合。Vue模板和JavaScript执行上下文是分离的，所以在Vuejs中引入TypeScript比较困难。你需要分别为<code class="fe nj nk nl na b">prop</code>、<code class="fe nj nk nl na b">method</code>和<code class="fe nj nk nl na b">data</code>声明类型。</li></ul><p id="ba2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，Vue模板也有自己的优势。由于Vue模板只能使用有限的语法，Vue可以更容易地对其进行静态分析和性能优化，这在JSX是很难做到的。</p><h2 id="4a6a" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">检查数据更新的不同方法</h2><p id="65d7" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这三个前端框架都需要观察数据变化来决定UI是否需要更新，但是它们选择了完全不同的方式来做这件事。</p><p id="2864" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular采取的方式是脏检查。在每个可能修改数据的语句执行后，Angular会比较前后的数据，以确定是否有数据更改。</p><p id="785a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vue直接使用JavaScript的原生特性来监控数据变化。Vue2使用了<code class="fe nj nk nl na b">Object.defineProperty</code>，Vue3使用了<code class="fe nj nk nl na b">Proxy</code>。</p><p id="3e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，React采取了不同的策略。React不直接监视数据变化，而是在数据和UI之间添加一个虚拟DOM。每次组件更新后都会重新生成一个虚拟DOM，并获取新的虚拟DOM和旧的虚拟DOM之间的差异。然后React决定是否以及如何更新真正的DOM。</p><h2 id="6d61" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">Vue和React的优化</h2><p id="b6c5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">Vue的数据观察是组件级的。当组件内部有很多地方需要观察数据变化时，一次更新可能需要大量的计算，可能会导致丢帧，也就是渲染卡顿。所以<strong class="kw iu">Vue的优化方法是把大组件拆分成小组件</strong>，这样每个数据不会有太多的watchers。</p><p id="f276" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React不观察数据变化，而是渲染整个虚拟dom，然后进行diffs。所以React的优化方法是，对于不需要重新渲染的组件，通过<code class="fe nj nk nl na b">shouldComponentUpdate</code>跳过渲染。</p><p id="1f88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当应用程序的组件树非常大时，仅仅使用<code class="fe nj nk nl na b">shouldComponentUpdate</code>来跳过一些组件的渲染可能仍然是非常计算密集型的。大量的计算也可能导致渲染冻结。那么我们该怎么办呢？</p><p id="27d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">树的遍历有两种方法:深度优先和广度优先。组件树的呈现是深度优先的，这通常通过递归来实现。递归调用无法挂起，这可能会导致页面冻结。</p><p id="8e9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果用链表来记录访问路径，就可以把树的递归遍历转化为数组的循环遍历。在循环遍历数组时，可以按照时间片进行分段，这样虚拟dom的生成就不会再阻塞页面渲染。这非常类似于操作系统对多个进程的分时调度。</p><p id="5e21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将组件树改为链表，将虚拟dom的生成由递归改为循环的机制有一个著名的名字:<strong class="kw iu"> React Fiber </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/a8259a297fba842ebe2880b6fffc58f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wr7YsYh-ZQ6bqJ_VSPKdA.png"/></div></div></figure><p id="827f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与之前的组件节点相比，光纤节点没有<code class="fe nj nk nl na b">parent</code>和<code class="fe nj nk nl na b">children</code>属性，而是有<code class="fe nj nk nl na b">child</code>、<code class="fe nj nk nl na b">sibling</code>和<code class="fe nj nk nl na b">return</code>属性。React通过纤程链表树优化渲染性能。</p><p id="d7ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们可以发现Vue的性能优化与React有很大不同:</p><ul class=""><li id="661a" class="ob oc it kw b kx ky la lb ld od lh oe ll of lp og oh oi oj bi translated">Vue使用组件级数据观察解决方案。当一个属性有太多的观察者时，可能会出现性能瓶颈，所以优化的思路是把大组件拆分成小组件，保证每个属性不会有太多的观察者。</li><li id="1d4a" class="ob oc it kw b kx ok la ol ld om lh on ll oo lp og oh oi oj bi translated">但是，React不会观察或检查数据更改。它每次渲染生成虚拟dom，然后对比新旧虚拟dom。优化的思路是用<code class="fe nj nk nl na b">shouldComponentUpdate</code>跳过一些组件的渲染。</li></ul><h2 id="8a49" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">重用代码的不同方式</h2><p id="c966" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">需要重用的组件之间会有一些共同的逻辑。React和Vue有不同的解决方案。</p><p id="cb8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vue的组件是以option对象的形式出现的，所以很自然地会想到通过对象属性来实现逻辑重用的mixins。Vue2组件的内部逻辑复用方案确实是mixin，但是mixin很难区分自身属性和混合属性，无法判断方法的来源。所以mixin的代码很乱，维护很差。但是没有更好的解决办法。</p><p id="aad5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React在开始时也支持mixins，但后来被弃用了。</p><p id="9e99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React组件有两种形式:类组件和功能组件。对于类组件，像高阶函数这样的高阶组件(HOC)是重用代码的一种自然方式。具体来说，我们可以用父组件包装子组件，在父组件中执行一些逻辑，然后渲染子组件。</p><p id="458f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了使用HOC，我们还可以直接将一些JSX作为道具传递给另一个组件重用，也就是渲染道具。</p><p id="f27e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HOC和render props是React的类组件支持的两种逻辑重用方案。</p><p id="b01c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原始的功能组件是无状态的，只是作为类组件呈现的辅助而存在。</p><p id="5f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，HOC的逻辑复用方式最终导致了组件的深度嵌套。而且类的内部生命周期很多，把不同的逻辑放在一起会让组件更复杂。</p><p id="f1a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何解决类组件的深度嵌套？而且解决方案不能进入突破性更新。</p><p id="a604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，React团队研究了功能组件。他们想在功能组件中扩展一些API来支持状态。</p><p id="69a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个功能组件要支持状态，那么状态应该存储在哪里？</p><p id="dc04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类组件本身有状态，变成纤程节点后仍然有状态。功能组件最初没有状态，在它变成纤程节点之后也没有状态。</p><p id="ce25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这么想，给功能组件的纤程节点添加状态还不够吗？</p><p id="e28c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">于是React在功能组件的一个纤程节点上添加了<code class="fe nj nk nl na b">memorizedState</code>属性来存储数据，然后开发者就可以通过API使用功能组件中的数据了。这些API被称为React钩子。因为数据是在纤程节点上使用的，所以这些API被命名为<code class="fe nj nk nl na b">useXxx</code>。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="449e" class="lq lr it bd ls lt ox lv lw lx oy lz ma jz oz ka mc kc pa kd me kf pb kg mg mh bi translated">结论</h1><p id="1458" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">三种前端框架各有优缺点。单纯比较谁更优秀是没有意义的。我们需要做的是为一个应用场景选择一个合适的解决方案。</p><p id="b7cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">技术是不断变化的，但最终目的是提高工作效率，降低开发成本，保证质量。</p><p id="c464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>