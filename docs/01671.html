<html>
<head>
<title>Easy Guide to Unit Testing in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang单元测试简易指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/easy-guide-to-unit-testing-in-golang-4fc1e9d96679?source=collection_archive---------5-----------------------#2019-10-03">https://betterprogramming.pub/easy-guide-to-unit-testing-in-golang-4fc1e9d96679?source=collection_archive---------5-----------------------#2019-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/11ee1bfcded60f97e740adbe73b6dd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZI0LIunbOr-_8sfsJiPq_Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">布莱克·康纳利在<a class="ae kf" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bde6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单元测试是编写好代码的必要组成部分。每个开发人员都应该知道如何编写好的单元测试。随着越来越多的组织使用Golang，作为开发人员，我们必须了解如何为Golang函数编写漂亮的单元测试。</p><p id="5907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本指南是对Golang单元测试最基本的介绍。它没有涵盖高级主题，如模拟、基准测试和幂等性。我将在以后尝试涵盖这些主题。</p><p id="846e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们开始吧。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3f39" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">代码</h1><p id="ebda" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们今天测试的功能非常简单。我们有一个接口<code class="fe mo mp mq mr b">Operator</code>，它有两个方法。</p><p id="9716" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">Generate</code>获取两个整数并基于某个模板创建一个密钥，<code class="fe mo mp mq mr b">Degenerate</code>获取一个密钥并解码出创建密钥的整数。</p><p id="e820" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果密钥无效，<code class="fe mo mp mq mr b">Degenerate</code>提供一个错误。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a42c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建这个接口的一个实现，叫做<code class="fe mo mp mq mr b">keyOp</code>。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="473b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里面的逻辑非常简单。</p><p id="35af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们提供了一个函数<code class="fe mo mp mq mr b">GetKeyOperator</code>，它用模板<code class="fe mo mp mq mr b">%v_%v</code>创建了一个新的<code class="fe mo mp mq mr b">keyOp</code>实例。</p><p id="c491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">Generate()</code>将两个整数合并到模板中。</p><p id="a182" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">Degenerate()</code>将键解组成相应的两个整数。如果键与模板结构不匹配，这由<code class="fe mo mp mq mr b">_</code>字符的位置决定，我们返回一个错误。</p><p id="a9a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主函数现在可以使用这些方法来查看功能。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="56b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如所料，输出是这样的:</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="6fdc" class="nc lm it mr b gy nd ne l nf ng">key=2_3, a=2, b=3</span></pre><p id="8189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经建立了功能。让我们开始测试它。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5003" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试</h1><p id="c854" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们将首先在与<code class="fe mo mp mq mr b">operators.go</code>相同的目录中创建一个名为<code class="fe mo mp mq mr b">operators_test.go</code>的文件。运行<code class="fe mo mp mq mr b">go test</code>命令时，Go自动在带有<code class="fe mo mp mq mr b">_test</code>后缀的目录中查找文件。</p><p id="bb64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们为我们的<code class="fe mo mp mq mr b">Generate()</code>和<code class="fe mo mp mq mr b">Degenerate()</code>函数编写测试用例。</p><p id="ba9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于测试函数，以<code class="fe mo mp mq mr b">Test_</code>开始函数名，然后为这个测试提供结构。然后你会想要写方法的名字。例如，我们的测试方法将被分别命名为<code class="fe mo mp mq mr b">Test_keyOp_Generate</code>和<code class="fe mo mp mq mr b">Test_keyOp_Degenerate</code>。</p><p id="d26f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的测试方法都需要一个<code class="fe mo mp mq mr b">testing.T</code>参数。<code class="fe mo mp mq mr b">T</code>是传递给测试函数的类型，用于管理测试状态和支持格式化的测试日志。</p><p id="9043" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们的方法签名是这样的:</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="8123" class="nc lm it mr b gy nd ne l nf ng">func Test_keyOp_Generate(t *testing.T)</span></pre><p id="8a0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">Generate</code>的参数是两个整数。所以让我们定义<code class="fe mo mp mq mr b">args</code>来存储这两个整数。</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="d254" class="nc lm it mr b gy nd ne l nf ng">type args struct {<br/>   x int<br/>   y int<br/>}</span></pre><p id="258e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们定义测试的需求。</p><p id="42c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将把测试组织成它们的名字——以及测试的参数和想要的结果。我们还将添加一些这样的测试:</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="e03f" class="nc lm it mr b gy nd ne l nf ng">tests := []struct {<br/>   name string<br/>   args args<br/>   want string<br/>}{<br/>   {<br/>      name: "success",<br/>      args: args{<br/>         x: 5,<br/>         y: 50,<br/>      },<br/>      want: "5_50",<br/>   },<br/>   {<br/>      name: "success large integers",<br/>      args: args{<br/>         x: 50000,<br/>         y: 999999,<br/>      },<br/>      want: "50000_999999",<br/>   },<br/>}</span></pre><p id="a639" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，我们已经添加了两个测试用例。一个用于一般成功，另一个用于测试大输入大小。我们还为这些测试用例定义了正确的结果。</p><p id="65a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以简单地遍历<code class="fe mo mp mq mr b">test</code>切片并运行测试。</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="c4ca" class="nc lm it mr b gy nd ne l nf ng">for _, tt := range tests {<br/>   t.Run(tt.name, func(t *testing.T) {<br/>      kp := GetKeyOperator()<br/>      if got := kp.Generate(tt.args.x, tt.args.y); got != tt.want {<br/>         t.Errorf("keyOp.Generate() = %v, want %v", got, tt.want)<br/>      }<br/>   })<br/>}</span></pre><p id="5c70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用在<code class="fe mo mp mq mr b">testing.T</code>结构上提供的<code class="fe mo mp mq mr b">Run</code>方法。<code class="fe mo mp mq mr b">Run</code>将测试名称和函数(<code class="fe mo mp mq mr b">func (t *testing.T)</code>)作为输入参数，并返回一个<code class="fe mo mp mq mr b">bool</code>。它在单独的goroutine中运行第二个参数中提供的函数，并阻塞，直到它返回。</p><p id="9229" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mo mp mq mr b">if</code>条件下，我们创建并实例化<code class="fe mo mp mq mr b">keyOp</code>的<code class="fe mo mp mq mr b">kp</code>，通过检查<code class="fe mo mp mq mr b">got!=want</code>来检查我们是否得到了预期的结果。如果测试用例失败，我们使用<code class="fe mo mp mq mr b">t.Errorf()</code>将错误消息写入<code class="fe mo mp mq mr b">testing.T</code>对象，并适当地构造我们的错误消息。</p><p id="c415" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完整的<code class="fe mo mp mq mr b">Generate</code>测试函数在这里。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bb4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们试着对<code class="fe mo mp mq mr b">Degenerate()</code>方法做同样的事情。这里的变化是<code class="fe mo mp mq mr b">args</code>将只接受一个<code class="fe mo mp mq mr b">string</code>作为参数。</p><p id="7f64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，由于我们从<code class="fe mo mp mq mr b">Degenerate()</code>返回三个结果，我们将用<code class="fe mo mp mq mr b">wantX</code>、<code class="fe mo mp mq mr b">wantY</code>和<code class="fe mo mp mq mr b">wantErr</code>变量来检查它们。<code class="fe mo mp mq mr b">wantErr</code>是一个<code class="fe mo mp mq mr b">bool</code>，它将检测我们是否从被测试的方法收到了一个非nil错误。</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="19d2" class="nc lm it mr b gy nd ne l nf ng">type args struct {<br/>   s string<br/>}<br/>tests := []struct {<br/>   name    string<br/>   args    args<br/>   wantX   int<br/>   wantY   int<br/>   wantErr bool<br/>}{<br/>   {<br/>      name: "success",<br/>      args: args{<br/>         s: "40_99",<br/>      },<br/>      wantX: 40,<br/>      wantY: 99,<br/>   },<br/>   {<br/>      name: "failure",<br/>      args: args{<br/>         s: "4099",<br/>      },<br/>      wantErr:<em class="nh">true</em>,<br/>   },<br/>}</span></pre><p id="3d76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，我们添加了两个简单的测试用例:一个测试成功，另一个测试失败，它有一个无效的输入。在<code class="fe mo mp mq mr b">success</code>测试中，我们使用<code class="fe mo mp mq mr b">wantX</code>和<code class="fe mo mp mq mr b">wantY</code>检查<code class="fe mo mp mq mr b">x</code>和<code class="fe mo mp mq mr b">y</code>的正确值，而在<code class="fe mo mp mq mr b">failure</code>测试中，我们使用<code class="fe mo mp mq mr b">wantErr</code>检查非nil错误。</p><p id="1cca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次编写一个for循环，遍历测试切片，并检查预期结果的匹配情况。这一次，我们检查所有三个参数。<code class="fe mo mp mq mr b">Degenerate</code>的完整测试功能如下:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d49a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">运行测试用例</h1><p id="f266" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们可以使用<code class="fe mo mp mq mr b">test</code>命令运行我们的测试用例。<code class="fe mo mp mq mr b">go test</code>具有多种功能，可在其详细文档<a class="ae kf" href="https://golang.org/cmd/go/#hdr-Test_packages" rel="noopener ugc nofollow" target="_blank">中找到，此处为</a>。</p><p id="37e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">go test</code>最简单的用法是运行当前目录和所有子目录中的所有测试。这可以通过运行以下命令来完成:</p><pre class="ms mt mu mv gt my mr mz na aw nb bi"><span id="be17" class="nc lm it mr b gy nd ne l nf ng">go test ./...</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="fce1" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="d3c8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我希望这个指南可以作为单元测试Golang方法的简单介绍。</p></div></div>    
</body>
</html>