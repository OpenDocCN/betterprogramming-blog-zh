<html>
<head>
<title>Lazy Loading Images With Intersection Observer in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用交叉点观察器延迟加载图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-images-with-intersection-observer-in-react-ad6135f1ca59?source=collection_archive---------2-----------------------#2021-05-19">https://betterprogramming.pub/lazy-loading-images-with-intersection-observer-in-react-ad6135f1ca59?source=collection_archive---------2-----------------------#2021-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc63" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建Gatsby图像样式自定义React组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/341be00cd91e4ffbe8d53f13c04ccd43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x3n0TsFh5r8iHgIT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kalljet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Katarzyna Grabowska </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="3832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">惰性加载是一种常见的性能优化技术，几乎所有重资产网站都采用这种技术。我们经常会遇到这样的网页，加载一个模糊版本的图像，然后接着是一个高分辨率的图像。尽管加载内容的总时间很长，但这对用户体验有明显的影响。</p><p id="9470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个互动过程分为三步:</p><ul class=""><li id="6812" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在开始加载图像之前，等待内容进入视图。</li><li id="b7bc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一旦图像出现在视图中，就会加载一个带有模糊效果的轻量级缩略图，并发出对原始图像的资源获取请求。</li><li id="f273" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一旦原始图像被完全加载，缩略图被隐藏，原始图像被显示。</li></ul><p id="0b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经使用过Gatsby，那么您会遇到一个<strong class="lb iu"> Gatsby Image </strong>组件，它为您做同样的事情。在本文中，我们将实现一个类似的组件，可以用作通用组件。尽管Gatsby Image不仅仅是模糊和加载图像，我们还是将重点放在简单的事情上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/74873f4e5a7b0fb3030678c5eec030d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5BdbU0xaup3vrVNyCPHJvA.gif"/></div></div></figure><h1 id="7143" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">让我们建造它。</h1><p id="a737" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">构建整个系统的第一步是创建图像组件的布局。</p><p id="c678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分很简单。出于本文的目的，我们将动态迭代一组图像并呈现一个<code class="fe nh ni nj nk b">ImageRenderer</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是在<code class="fe nh ni nj nk b">ImageRenderer</code>组件中为我们的图像呈现占位符。</p><p id="d552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用指定的宽度渲染图像时，它们会根据长宽比(即原始图像的宽高比)调整图像的高度。</p><p id="47a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们已经将原始图像的宽度和高度作为道具传递给了<code class="fe nh ni nj nk b">ImageRenderer</code>组件，所以我们可以很容易地计算长宽比，并使用它来计算图像占位符的高度。这样做是为了当我们的图像最终加载时，我们的占位符不会再次更新它们的高度。</p><p id="2fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">占位符的高度通过使用<code class="fe nh ni nj nk b">padding-bottom</code> CSS属性以百分比来设置。</p><p id="f3d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当以百分比指定时，填充的大小按元素宽度的百分比计算。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="258c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们的应用程序如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/46bff4a7e02d4af5c03a7d2661dbaf51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*O5gUBX4lfwAWMRRpJov8oA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像占位符布局</p></figure><h1 id="db18" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">利用路口观测器检测能见度</h1><p id="7523" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们现在需要知道的是我们的图像容器何时进入视图。交叉点观察器是完成这项任务的完美工具。</p><blockquote class="no np nq"><p id="d74f" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">交集观察器API提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>的交集变化的方法。</p><p id="84ac" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">交叉点观察器API允许您配置在发生以下任一情况时调用的回调:</p><p id="2981" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated"><strong class="lb iu">目标</strong>元素与设备的视窗或指定元素相交。出于交叉点观察器API的目的，该指定元素被称为<strong class="lb iu">根元素</strong>或<strong class="lb iu">根元素</strong>。</p><p id="b3bd" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">观察者第一次被要求观察一个目标元素。"</p></blockquote><p id="e59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的是使用一个全局<code class="fe nh ni nj nk b">IntersectionObserver</code>实例来观察我们所有的图像。我们还将保留一个侦听器回调映射，它将由单个图像组件添加，并将在图像进入视口时执行。</p><p id="436c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了维护目标到监听器回调的映射，我们将使用Javascript中的<code class="fe nh ni nj nk b">WeakMap</code> API。</p><blockquote class="no np nq"><p id="cc03" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">“<code class="fe nh ni nj nk b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">WeakMap</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> </a>对象是键/值对的集合，其中键被弱引用。键必须是对象，值可以是任意值。</p></blockquote><p id="4934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了一个定制的钩子来获取<code class="fe nh ni nj nk b">IntersectionObserver</code>实例，将目标元素作为观察者添加到其中，并且还将一个监听器回调添加到映射中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="38b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有为IntersectionObserver指定任何根元素，则默认目标被认为是文档视口。</p><p id="3083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nh ni nj nk b">IntersectionObserver</code>回调从地图获取监听器回调，如果目标元素与视口相交，就执行它。然后它会移除观察点，因为我们只需要加载图像一次。</p><h1 id="d38f" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用intersect observer for image renderer组件</h1><p id="cf28" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在我们的<code class="fe nh ni nj nk b">ImageRenderer</code>组件中，我们使用自定义钩子<code class="fe nh ni nj nk b">useIntersection</code>并传递图像容器的ref和一个回调函数，该函数将为我们的图像设置可见性状态。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fa46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们这样做了，我们的应用程序看起来像下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/241dabcfe03014e3fe8e8f0892cea924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-GR1PZmpHSTz0XHv0toMEA.gif"/></div></div></figure><p id="35ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们滚动图像时，网络请求看起来像下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/2bd87e3a105dba4aa97a0832808fa753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uiGzwa7-HxRdHJK77DYQwA.gif"/></div></div></figure><p id="1795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们的IntersectionObserver工作正常，我们的图像只有在进入视野时才被加载。此外，我们看到的是，当整个图像被加载时，会有一点延迟。</p><p id="9a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了惰性加载特性，我们将进入最后一部分。</p><h1 id="d43d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">添加模糊效果</h1><p id="59e9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">添加模糊效果是通过尝试加载除实际图像之外的低质量缩略图并向其添加<code class="fe nh ni nj nk b">filter: blur(10px)</code>属性来实现的。当高质量图像完全加载后，我们隐藏缩略图并显示实际图像。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cf03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML中的<code class="fe nh ni nj nk b">img</code>元素有一个<code class="fe nh ni nj nk b">onLoad</code>属性，它接受一个在图像加载时触发的回调。我们利用这个属性为组件设置<code class="fe nh ni nj nk b">isLoaded</code>状态，并隐藏缩略图，同时使用<code class="fe nh ni nj nk b">opacity</code> CSS属性显示实际图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/7a3b3b636cd91af6328f59bdc643bdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2XGxU3dAqtFD0-w8Gjfh1g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有模糊效果的最终惰性加载图像</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">懒人加载图片的游乐场</p></figure><h1 id="4842" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="5401" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">所以我们有了它:我们的定制<code class="fe nh ni nj nk b">ImageRenderer</code>组件，当图像进入视图时加载图像，并显示模糊效果以提供更好的用户体验。</p><p id="585a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。你可以在我的<a class="ae ky" href="https://github.com/mayankshubham/react-lazy-loading-image" rel="noopener ugc nofollow" target="_blank"> GitHub仓库找到完整的代码。</a></p><p id="30da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请关注我的更多与web开发相关的小技巧和窍门。</p><h2 id="a588" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">感谢您的阅读！</h2></div></div>    
</body>
</html>