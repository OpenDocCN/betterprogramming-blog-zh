<html>
<head>
<title>How to Calculate MongoDB Document Size in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中如何计算MongoDB文档大小</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-calculate-mongodb-document-size-in-node-js-f463b8457f27?source=collection_archive---------4-----------------------#2020-05-27">https://betterprogramming.pub/how-to-calculate-mongodb-document-size-in-node-js-f463b8457f27?source=collection_archive---------4-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c5f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有bson模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/096d7335159e01b408c91f4510acb3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JoNmvYzhiZvzof0rZBgtA.png"/></div></div></figure><p id="3ade" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的上一篇文章<a class="ae lq" href="https://medium.com/better-programming/how-to-store-documents-larger-than-16-mb-in-mongodb-aecc957bbe6c" rel="noopener">如何在MongoDB中存储大于16Mb的文档</a>中，我提出了一种在链接文档中存储大文档的方法。要做到这一点，我们需要在运行时计算文档的大小，以知道何时拆分它并保存到MongoDB。我用了一个非常简单的方法来计算尺寸。</p><p id="af26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将创建一个函数来计算一个文档的确切字节数。有一点需要注意——我将对上一篇文章中的列类型这样做。为了简单起见，我稍微更改了下面的列类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4ab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文档以BSON格式存储在MongoDB中。你可以猜到，BSON是一个二进制JavaScript对象符号或简称为二进制JSON。它起源于MongoDB——这是它的<a class="ae lq" href="http://bsonspec.org/spec.html" rel="noopener ugc nofollow" target="_blank">规范</a>。</p><p id="0a8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个<code class="fe lt lu lv lw b">bson</code>模块来探索BSON格式。先用<code class="fe lt lu lv lw b">npm install bson</code>装一下吧。然后我们要求用<code class="fe lt lu lv lw b">const BSON = require('bson');</code>来表示。我们准备好了。</p><p id="3062" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始探索文档是如何用BSON编码的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3cbe" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">空对象编码</strong></h1><p id="740d" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">让我们从最简单的文档开始——一个空对象。将其序列化并记录到控制台:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="44ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到有一个5字节的缓冲区。这是最小的有效BSON文件。</p><p id="d421" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看空对象是如何编码的:<code class="fe lt lu lv lw b">05 00 00 00 00</code></p><ol class=""><li id="d7f4" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">05 00 00 00</code>:前四个字节实际上是一个<code class="fe lt lu lv lw b">int32</code>数字。这是BSON文档的大小(5字节)，包括文档本身和文档结束符。</li><li id="7ab3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>:最后一个字节代表文件结束符。</li></ol><p id="d079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="np">实现细节:</em> </strong> <em class="np">字节以小端记数法书写，最低有效字节优先。</em></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7e69" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">数字编码</h1><p id="3e05" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">接下来，让我们看一个有效的MongoDB文档，它可以保存到数据库中。它只有一个键值对。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="6132" class="nq mf it bd mg nr ns dn mk nt nu dp mo ld nv nw mq lh nx ny ms ll nz oa mu ob bi translated"><strong class="ak">数字键值对如何编码</strong></h2><p id="4a24" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe lt lu lv lw b">0e 00 00 00 10 5f 69 64 00 01 00 00 00 00</code></p><ol class=""><li id="b5ed" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">0e 00 00 00</code>文件大小为14字节。</li><li id="6af3" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">10 5f 69 64 00 01 00 00 00</code>键值对。</li><li id="9ff5" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>最后一个字节代表文件结束符。</li></ol><p id="5df2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有BSON文档都以二进制格式存储，其中前四个字节是文档大小，最后一个字节是文档终止符。介于两者之间的是键值对。</p><h2 id="eb32" class="nq mf it bd mg nr ns dn mk nt nu dp mo ld nv nw mq lh nx ny ms ll nz oa mu ob bi translated"><strong class="ak">让我们分析上面的键值对</strong></h2><p id="f1fe" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe lt lu lv lw b">10 5f 69 64 00 01 00 00 00</code></p><ol class=""><li id="e08a" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">10</code>第一个字节是值类型——在本例中是<code class="fe lt lu lv lw b">int32</code>(可以看看上面的规范链接)。</li><li id="974e" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">5f 69 64</code>以下任意数量的字节都是一个密钥。</li><li id="eceb" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>关键的终结者。</li><li id="fe5d" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">01 00 00 00</code>最后四个字节是一个值——我们知道它需要四个字节，因为它是<code class="fe lt lu lv lw b">int32</code>。</li></ol><p id="c375" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有值类型，但是键类型在哪里？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/66a2162784daa6f47e1f3b125c04697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xpbg9kPSIOv-flCUChv5xw.jpeg"/></div></div></figure><p id="7038" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="np">实现细节:</em> </strong> <em class="np">关键始终是一个字符串。因此，我们不需要给BSON添加一个键的类型——我们知道它是一个字符串。</em></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="eb0d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">字符串类型</strong></h1><p id="d51e" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">让我们看看以字符串为值的键值对是如何编码的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="350c" class="nq mf it bd mg nr ns dn mk nt nu dp mo ld nv nw mq lh nx ny ms ll nz oa mu ob bi translated"><strong class="ak">字符串键值部分如何编码</strong></h2><p id="72f6" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe lt lu lv lw b">02 74 79 70 65 00 07 00 00 00 73 74 72 69 6e 67 00</code></p><ol class=""><li id="e3f4" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">02</code>第一个字节是值类型，本例中为字符串。</li><li id="7f89" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">74 79 70 65</code>键<code class="fe lt lu lv lw b">type.</code></li><li id="396d" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>关键终结者。</li><li id="2343" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">07 00 00 00</code>对于字符串类型，字符串的长度值被写入<code class="fe lt lu lv lw b">int32</code>。长度包括字符串值终止符的一个字节。</li><li id="c087" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">73 74 72 69 6e 67</code>我们的编码字符串。</li><li id="1b50" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>一个字符串值终止符。</li></ol><p id="5b93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">实现细节:</strong>字符串采用UTF-8编码，这意味着每个字符需要一到四个字节来编码。拉丁字母、数字和其他一些东西需要一个字节来编码。一些非英语语言字符需要两个字节来编码。中国象形文字需要三个字节。表情符号需要四个字节。为了计算编码字符串的大小，我们可以使用nodejs缓冲方法:<code class="fe lt lu lv lw b">Buffer.from(str).size</code>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2fc5" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">阵列类型</strong></h1><p id="c1c8" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">让我们进一步研究数组是如何编码的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="54b1" class="nq mf it bd mg nr ns dn mk nt nu dp mo ld nv nw mq lh nx ny ms ll nz oa mu ob bi translated"><strong class="ak">数组键值部分如何编码</strong></h2><p id="3c73" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe lt lu lv lw b">04 76 61 6c 75 65 73 00 12 00 00 00 02 30 00 06 00 00 00 66 69 72 73 74 00 00</code></p><ol class=""><li id="1760" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">04</code>:数组文档类型。</li><li id="50a2" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">76 61 6c 75 65 73 00</code>:带终止符<code class="fe lt lu lv lw b">00</code>的钥匙<code class="fe lt lu lv lw b">values</code>。</li><li id="e60f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">12 00 00 00 02 30 00 06 00 00 00 66 69 72 73 74 00 00</code>:编码后的数组。这是一份完整的BSON文件。</li></ol><h2 id="4f53" class="nq mf it bd mg nr ns dn mk nt nu dp mo ld nv nw mq lh nx ny ms ll nz oa mu ob bi translated"><strong class="ak">让我们看看数组</strong> <code class="fe lt lu lv lw b"><strong class="ak">['first']</strong></code> <strong class="ak">是如何编码的</strong></h2><p id="18f6" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe lt lu lv lw b">12 00 00 00 02 30 00 06 00 00 00 66 69 72 73 74 00 00</code></p><ol class=""><li id="5369" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">12 00 00 00</code>:文件长度为12字节。</li><li id="cdf9" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">02 30 00 06 00 00 00 66 69 72 73 74 00</code>:编码键值`。</li><li id="f0d0" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>一个文档终结者。</li></ol><p id="23ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等，如果我们在<code class="fe lt lu lv lw b">['first’]</code>数组中只有一个元素，为什么是键值对呢？</p><p id="cd2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="np">实现细节:</em> </strong> <em class="np">数组作为对象保存在BSON，所以</em> <code class="fe lt lu lv lw b"><em class="np">['first']</em></code> <em class="np">实际上保存为</em> <code class="fe lt lu lv lw b"><em class="np">{ '0': 'first' }</em></code> <em class="np">。</em></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="62bf" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">空类型</strong></h1><p id="983a" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在一个<code class="fe lt lu lv lw b">Column.values</code>数组中，我可以有字符串和空值，所以我也需要知道空值是如何存储的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="293c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">空键值部分如何编码:<br/> </strong> <code class="fe lt lu lv lw b">0a 30 00</code></p><ol class=""><li id="e66d" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">0a</code>空类型代码。</li><li id="cff9" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">30</code>字符串键<code class="fe lt lu lv lw b">0</code>后跟</li><li id="9db1" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe lt lu lv lw b">00</code>一键终止符。</li></ol><p id="2970" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，以BSON格式存储<code class="fe lt lu lv lw b">null</code>非常有效。我们不需要提供一个值，从它的类型可以明显看出。</p><p id="dc47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有足够的信息来为<code class="fe lt lu lv lw b">Column</code>接口创建一个计算BSON大小的函数。MongoDB将文档的大小限制为<code class="fe lt lu lv lw b">16Mb</code>，也就是<code class="fe lt lu lv lw b">16777216</code>字节。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="88d3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">计算BSON尺寸函数</strong></h1><p id="63b0" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在下面的代码片段中，我编写了一个函数来计算列的确切大小。这是为了演示的目的，只是向您展示当您知道规范时，如何可能编写一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6bb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在生产中使用的函数实际上是用空数组使用<code class="fe lt lu lv lw b">bson</code>模块计算对象大小。然后，在添加新元素时，我们跟踪文档的大小。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="cb19" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="8945" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">通过在运行时计算<code class="fe lt lu lv lw b">BSON</code>的大小，我们可以有效地将一列分割成块。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="f767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在以后的文章中讨论减少MongoDB文档大小的其他选择，敬请关注。</p></div></div>    
</body>
</html>