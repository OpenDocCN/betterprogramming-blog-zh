<html>
<head>
<title>OOP Principles for Writing Better Code in Laravel Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了用Laravel编写更好代码的OOP原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/laravel-oop-principles-for-writing-better-code-explained-part-1-531276365cba?source=collection_archive---------0-----------------------#2019-02-23">https://betterprogramming.pub/laravel-oop-principles-for-writing-better-code-explained-part-1-531276365cba?source=collection_archive---------0-----------------------#2019-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第一部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65112cf3c9f626910b5b7822818fca5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6Up_hNzios3ijP0-8yUFg.jpeg"/></div></div></figure><h1 id="590d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">一个小故事:我如何开始与拉勒维尔</strong></h1><p id="db23" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我曾经花了很多年使用WordPress，因为我的客户想要一个能够自己更新网站的低成本解决方案。对于小公司来说，这是一个典型的要求。</p><p id="238f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，随着Wordpress变得越来越大，越来越受欢迎，越来越多的人开始构建自己的插件。事态的发展开始让人无法忍受。这些网站变得不稳定、不安全、庞大、缓慢。</p><p id="92a7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有一天，在花了几个小时试图找出我的一个网站的错误后，我对自己说:<strong class="lo iu">够了</strong>！我对其他选项做了一些研究，发现了几个流行的框架。我几乎立刻就喜欢上了Laravel，并开始学习一种全新的web开发方法。</p><h2 id="ad47" class="mn kv it bd kw mo mp dn la mq mr dp le lv ms mt lg lz mu mv li md mw mx lk my bi translated"><strong class="ak">压死骆驼的最后一根稻草</strong></h2><p id="5195" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">OOP的主要原则之一是<strong class="lo iu"> SRP </strong> — <em class="mz">单一责任原则</em>。WordPress在“专家级”使用SoC。明显是讽刺！</p><p id="214c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我管理的一个网站，但不是我创建的，使用了一个推荐插件。插件的作者认为将一组推荐与文章类别联系起来是个好主意。删除类别后发生了什么？整个主页以一种非常奇怪的方式崩溃了。所有的积木都一个接一个地放在右边。一个简单的分类变化就毁掉了整个网站。WordPress惊人的代码架构！</p><h2 id="589f" class="mn kv it bd kw mo mp dn la mq mr dp le lv ms mt lg lz mu mv li md mw mx lk my bi translated"><strong class="ak">设计良好的代码vs糟糕的代码。金钱—时间—客户</strong></h2><p id="2927" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">许多程序员感到来自客户的压力很大。显然，客户希望这项工作又快又便宜。价格越低越好，但只是刚开始。写得不好的代码的代价是什么？它实际上是巨大的！作为一名专业人士，你必须能够更好地向你的客户或雇主解释。</p><p id="2211" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这幅图展示了糟糕的代码和设计良好的代码之间的典型对比。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/6c281a4c506c9684a52918bb901b6ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-rMqOZJk8raPuYeYieNzA.png"/></div></div></figure><p id="a85f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好吧，深思熟虑的代码在开始时需要更多的工作和思考。初期效果没那么快，价格也比较高。然而，适当的代码将易于扩展或更新。从长远来看，这对程序员和客户来说都是值得的。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="34ae" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">对设计糟糕的代码的体验</h1><p id="8da2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我已经经历过几次“红色情况”了。一个客户让我更新一些别人乱七八糟的代码。我很清楚这是不可能的。程序员自己告诉客户，他不能再更新它了，他已经放弃了。</p><p id="ec7b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">没有适当命名约定的超长函数。<em class="mz">if</em>inside<em class="mz">for</em>inside other<em class="mz">while</em>inside more<em class="mz">if</em>。一个新的程序员需要多少时间来理解这样一个函数？这不值得。我们不得不在绿线上重新开始。</p><p id="18b7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最近，我开始着手一个新项目，也有类似的糟糕概念。PHP、SQL调用、HTML——都在一个文件中。关注点分离在这个项目中夭折了。创建代码的人甚至懒得分离HTML头。每一页都有自己的页眉。现在，如果一个客户要求改变图标，他们最终会更新30多个文件。难道他们没听说过<strong class="lo iu">干</strong>原理吗？</p><p id="72fe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我和客户谈了一下，他说他了解程序员，他们入行很久了，不会差。好吧，如果一个程序员一遍又一遍地犯同样的错误，他的经验算不算几年或几十年都没关系。代码是坏的，句号。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="341c" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">OOP规则将帮助你创建更好的代码</h1><p id="8432" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">OOP规则工作得很好，它们确实能帮助你写出更好的代码。然而，学习如何实际应用它们是非常困难的。这些原则非常清楚，但不幸的是，如何遵循它们往往非常不直观。我的一个朋友是微软的高级程序员，他是我最重要的知识和技巧来源。互联网不再有足够的帮助。一个能直接对你的用例提出建议的人更有价值。</p><p id="a2fe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里我们不会解释主要的原则，而是展示一些如何实际有效地使用OOP的例子。</p><p id="5219" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以下是一些最重要的术语:</p><ul class=""><li id="d423" class="nn no it lo b lp mi ls mj lv np lz nq md nr mh ns nt nu nv bi translated"><a class="ae nw" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">T3】坚实原理</a></li><li id="6f3e" class="nn no it lo b lp nx ls ny lv nz lz oa md ob mh ns nt nu nv bi translated"><a class="ae nw" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SoC —关注点分离</a></li><li id="142e" class="nn no it lo b lp nx ls ny lv nz lz oa md ob mh ns nt nu nv bi translated"><a class="ae nw" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP —单一责任原则</a></li><li id="d181" class="nn no it lo b lp nx ls ny lv nz lz oa md ob mh ns nt nu nv bi translated"><a class="ae nw" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank"> IoC —控制反转，链接</a></li><li id="b05f" class="nn no it lo b lp nx ls ny lv nz lz oa md ob mh ns nt nu nv bi translated"><a class="ae nw" href="#https://sourcemaking.com/design_patterns" rel="noopener ugc nofollow">设计模式</a></li><li id="a6a9" class="nn no it lo b lp nx ls ny lv nz lz oa md ob mh ns nt nu nv bi translated"><a class="ae nw" href="#https://sourcemaking.com/antipatterns" rel="noopener ugc nofollow">反模式</a></li></ul><p id="46f3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其中一些术语显然是重叠的，但是它们将帮助您搜索更深层次的知识，特别是如果设计模式需要一些使用它们的经验。作为一名程序员，你必须在许多标准中做出适当的妥协，比如复杂性、时间、代码可读性、程序速度、开发进度、团队合作等等。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="03d5" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">从图层开始设计；你的生活会变得轻松很多！</h1><p id="fbdc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最重要的编程原则之一是一个<em class="mz">架构模式</em> ( <a class="ae nw" href="https://en.wikipedia.org/wiki/Abstraction_layer" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae nw" href="https://en.wikipedia.org/wiki/Layer_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank">2</a>)——简单来说，就是层。让我们考虑一下我们通常需要的每一层是做什么的。有没有适合典型web应用程序的大多数标准情况的好方法？</p><p id="901d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">典型web应用程序的可能层次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/03bb2e48f7759e770b051d46ecec9ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*A9CYyQhY2mYUkmFtPz1EOA.png"/></div></figure><p id="02d4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">1.路由。用户或API客户端调用某个URL并期望发生一些事情。我们的应用程序必须识别URL。这是由路由类完成的。在Laravel中，有一个很棒的路由系统，它有很多有用的特性。VueJs还包括一个很棒的路由机制，[ <a class="ae nw" href="https://router.vuejs.org/guide/essentials/dynamic-matching.html#reacting-to-params-changes" rel="noopener ugc nofollow" target="_blank"> 1 </a>。</p><p id="fdd3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">2.应用程序检查调用的重要属性。它有合适的标题吗？会话是否处于活动状态？用户登录了吗？电话授权了吗？用户是否有使用此呼叫的适当权限？</p><p id="ca0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所有类型的调用验证都由中间件管理。在Laravel中，您可以根据需要创建任意数量的中间件。很多马上就为你准备好了。</p><p id="e515" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">3.Laravel创建一个封装了所有输入数据的<em class="mz">请求</em>对象。Laravel将请求对象发送到一个<em class="mz">控制器</em>。</p><p id="4048" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们在一个<strong class="lo iu"> <em class="mz">控制器</em> </strong>中，这是我们应用的一种入口点。在控制器的功能结束时，应用程序应该返回一些数据。在入口点和返回语句之间，我们有一个业务逻辑在做一些客户想要的事情。</p><p id="9b3c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注</strong>:控制器是大部分Laravel教程结束的地方。举个琐碎的例子，多建几层没什么意义。然而，正因为如此，新程序员很难学习更高级的东西。我自己也经历过这种挣扎。</p><p id="8acf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">4.一个<em class="mz">控制器</em>应该验证传入的数据，调用一个服务执行一些业务逻辑，然后以期望的格式形成一个响应(例如json或blade视图)。</p><p id="6f17" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">5.数据验证是一项极其重要的任务。许多程序员没有足够重视它，从而创建了不安全的应用程序。SQL注入只是众所周知的安全威胁之一。</p><p id="8ce6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">记住，你永远不要相信客户的数据。始终验证它们，即使它们来自您自己的前端客户端。请记住，API可能会被其他应用程序使用。</p><p id="433b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">6.数据经过验证后，我们就可以调用服务了。业务逻辑应该与控制器分离，如果可能的话，也应该与框架本身分离。如果类不依赖于框架，那么对你的应用进行单元测试会更容易。建议的一个例子是避免使用<code class="fe od oe of og b"><em class="mz">resolve (‘ClassName’)</em></code><em class="mz">；</em>更喜欢控制反转或将依赖关系手动传递给较低层。</p><p id="72d9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">什么是商业逻辑？大多数时候，你的应用需要<a class="ae nw" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>操作。服务类将接收传入的数据，并将其保存到数据库中。或者，它将读取数据，将其转换成所需的格式，然后返回。如果需要更复杂的东西，服务类将调用其他服务。</p><p id="9d95" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> 7。</strong>如果服务需要访问数据库，它调用一个<strong class="lo iu"> <em class="mz">存储库</em> </strong>类。存储库处理对数据库的所有调用。上面的层不知道数据是如何存储的。你只要打电话</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="6666" class="mn kv it og b gy ol om l on oo">$userRepository-&gt;getById(1);</span></pre><p id="ff77" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">仅此而已。对于服务来说，无论你的数据库是MySQL、NoSQL还是数据通过API保存在云中的某个地方，都没有关系。</p><p id="d0d3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">8.Laravel原生模型非常强大，可以为创建简单的应用程序节省一些时间。然而，它们违反了一些OOP规则。为此，我决定创建自己的系统，彻底摆脱主动记录(反)模式。我将在文章的后面解释这个想法。</p><p id="ef88" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">存储库调用知道如何从数据库获取数据的数据映射器。DataMapper类是特定于数据库的。它必须为每种类型的数据库(mySql、noSql、文件)单独创建。但是，它的界面应该是完全一样的。我的数据映射器总是有这些公共函数:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="fb33" class="mn kv it og b gy ol om l on oo">public function getById($id, $attributes = '*');<br/>public function getBySlug($slug, $attributes = '*');<br/>public function patchById (IModel $model, $selectedAttributes);<br/>public function deleteById ($id);<br/>public function search (array $criteria, $attributes = '*');<br/>public function store (IModel &amp;$model);</span></pre><p id="1645" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果数据映射器需要一些特殊的函数，它们在子类中实现。例如<em class="mz"> UserDataMapper </em>需要<em class="mz"> getByUserName() </em>、<em class="mz"> isRoot() </em>等函数。</p><p id="0312" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">9.DataMapper为Laravel查询生成器准备数据。这是应用程序的最低层。如果失败，查询生成器将返回数据或引发异常。</p><p id="4f60" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">重要规则</strong>:任何类或函数都不应该跳层！它产生了紧密耦合，并最终导致测试和在团队成员中分配工作的问题。这条规则真的很重要，然而，即使是Laravel也支持以一种恐怖的方式打破它。</p><p id="edb7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">示例 : Laravel <a class="ae nw" href="https://laravel.com/docs/5.7/validation" rel="noopener ugc nofollow" target="_blank">验证器</a>是一个强大的工具。毫无疑问。但是，它允许您创建这样的验证规则:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="1bd0" class="mn kv it og b gy ol om l on oo">'state' =&gt; 'exists:states'</span></pre><p id="261f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">看起来简单大方。然而，从OOP规则的角度来看，这是一个可怕的概念。它将顶层与底层SQL数据库连接起来。最重要的是，它将您的验证与数据库列的实际名称联系起来。这是一对极其紧密的组合，最终会踢你的后腿。一旦你走上这条路，你几乎肯定会在将来痛苦地重写一大部分代码。</p><p id="a546" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最重要的是，你可以用这个概念做更糟糕的事情。你可以这样验证用户的数据(伪代码):</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="e3d4" class="mn kv it og b gy ol om l on oo">IF Validator( 'email' =&gt; 'exists:emails') == False THEN createNewUser()</span></pre><p id="cfa5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">为什么这段代码很危险？</strong>如果邮件在你的代码到达save()函数之前就出现在DB里了怎么办？99%的情况下都不会发生。然而，当你的应用程序为更多的客户服务变得更忙时，你必须预料到这种情况会发生。你的应用会在没有警告的情况下崩溃。验证通过，电子邮件未被接收，但数据不会被保存，电子邮件已经在那里。一个你从未见过的异常可能会使应用程序崩溃。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="5e8b" class="ku kv it bd kw kx ni kz la lb nj ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated"><strong class="ak">第1部分的结论</strong></h1><p id="2931" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们已经介绍了PHP/Laravel面向对象编程的重要基本概念。然而，这些概念是一般性的，可以应用于任何类型的代码。</p><p id="7333" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">遵循一些基本的OOP规则将帮助你写出更好的代码，在可读性、安全性和可扩展性方面更好。</p><p id="2e43" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下次在第2部分再见！</p></div></div>    
</body>
</html>