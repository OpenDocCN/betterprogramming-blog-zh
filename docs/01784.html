<html>
<head>
<title>Is This the Last Element of My Python for Loop?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是我的Python for循环的最后一个元素吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-this-the-last-element-of-my-python-for-loop-784f5ff90bb5?source=collection_archive---------2-----------------------#2019-10-14">https://betterprogramming.pub/is-this-the-last-element-of-my-python-for-loop-784f5ff90bb5?source=collection_archive---------2-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们如何容易地找到我们是否在循环中的最后一个元素</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e3faedbcf4eb6ac3a18b80bd1b8393d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z0mdy4p5XrUy9eKB.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">摘自<a class="ae ky" href="https://www.liberiangeek.net/2019/04/check-python-version/" rel="noopener ugc nofollow" target="_blank">https://www.liberiangeek.net/2019/04/check-python-version/</a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="80f7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">问题</strong></h1><p id="f55b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有时，我想对Python <code class="fe mv mw mx my b">for</code>循环中的<em class="mu"> last </em>元素做一些特殊的处理，这与我对其他元素所做的不同。在伪代码中，这个问题看起来像这样:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="f946" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">for</strong> var <strong class="my iu">in</strong> my_iterable:<br/>    <strong class="my iu">if</strong> is_last_element:<br/>        special_function(var)<br/>    <strong class="my iu">else</strong>:<br/>        not_so_special_function(var)</span></pre><p id="1984" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">但是我怎么知道我是否在循环的最后一个元素呢？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="08df" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">不太好的解决方案</h1><p id="1547" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有人可能会想，当然不是你:“啊，只要枚举你的iterable，检查枚举加1是否等于你的iterable的长度！”</p><p id="f2f7" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">由于描述代码可能不是我的强项，我宁愿向您展示我在代码中的意思:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="454d" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">for</strong> i, var <strong class="my iu">in</strong> enumerate(my_iterable):<br/>    <strong class="my iu">if</strong> i + 1 == len(my_iterable):<br/>        special_function(var)<br/>    <strong class="my iu">else</strong>:<br/>        not_so_special_function(var)</span></pre><p id="69de" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这当然有时有效，但首先，对我来说，它读起来并不像它应该的那样好，其次，它并不总是有效！</p><p id="5939" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">为什么？我说的是迭代<em class="mu"> iterables </em>，并不是每一个iterable都提供了一种廉价获取元素数量的方法。举个小例子，看看这个斐波那契数生成器:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="ddbb" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">from</strong> typing <strong class="my iu">import</strong> Iterable<br/><br/><strong class="my iu">def</strong> fib(n_fibs: int = 10) -&gt; Iterable[int]:<br/>    f1, f2 = 0, 1<br/>    yield 1<br/>    <strong class="my iu">for</strong> _ <strong class="my iu">in</strong> range(n_fibs - 1):<br/>        crnt = f1 + f2<br/>        <strong class="my iu">yield</strong> crnt<br/>        f1, f2 = f2, crnt</span></pre><p id="707e" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">试着调用<code class="fe mv mw mx my b">len(fib(10))</code> <em class="mu">，</em>哪个会失败<em class="mu">。</em>虽然这个例子有一半是愚蠢的，但是由于我们知道我们将产生的元素的数量(应该是10)，所以它说明了问题。</p><p id="7b37" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在，我们可以调用<code class="fe mv mw mx my b">len(<strong class="ma iu">list</strong>(fib(10))</code>，这将返回一个清晰的10，但是如果我们的生成器生成了无法存储在内存中的非常大的东西，或者如果每次迭代在计算时间方面代价很高，这就变得不切实际了。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7709" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">真正的解决方案</h1><p id="7e5a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我在这里向您展示的解决方案，也可以在<a class="ae ky" href="https://stackoverflow.com/questions/1630320/what-is-the-pythonic-way-to-detect-the-last-element-in-a-for-loop" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中找到，利用了Python的迭代器协议和函数<code class="fe mv mw mx my b">iter</code> <em class="mu"> </em>和<em class="mu"> </em> <code class="fe mv mw mx my b">next</code> <em class="mu">。</em></p><p id="d2b5" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">你可以像<em class="mu"> enumerate，</em>一样使用我的函数，但是它不是告诉你当前的索引，而是告诉你是否在最后一个元素。所以，这就是:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="c412" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">from</strong> typing <strong class="my iu">import</strong> Iterable, Any, Tuple</span><span id="6e15" class="nd lh it my b gy nn nf l ng nh"><strong class="my iu">def</strong> signal_last(it:Iterable[Any]) -&gt; Iterable[Tuple[bool, Any]]:<br/>    iterable = iter(it)<br/>    ret_var = next(iterable)<br/>    <strong class="my iu">for</strong> val <strong class="my iu">in</strong> iterable:<br/>        <strong class="my iu">yield</strong> False, ret_var<br/>        ret_var = val<br/>    <strong class="my iu">yield</strong> True, ret_var</span></pre><p id="4308" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">作为一个例子，将所有这些放在一起，代码看起来几乎像上面发布的伪代码:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="bbf4" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">for</strong> is_last_element, var <strong class="my iu">in</strong> signal_last(fib(10)):<br/>    <strong class="my iu">if</strong> is_last_element:<br/>        special_function(var)<br/>    <strong class="my iu">else</strong>:<br/>        not_so_special_function(var)</span></pre><p id="0e02" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">读起来不错，不是吗？请注意，您可以很容易地使用几乎相同的函数来确定您是否正在查看iterable的第一个元素。因为我不喜欢有人告诉我一些事情却不给我看，所以代码如下:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="429b" class="nd lh it my b gy ne nf l ng nh"><strong class="my iu">from</strong> typing <strong class="my iu">import</strong> Iterable, Any, Tuple<br/><strong class="my iu">def</strong> signal_first(it:Iterable[Any]) -&gt; Iterable[Tuple[bool, Any]]:<br/>    iterable = iter(it)<br/>    <strong class="my iu">yield</strong> True, next(iterable)<br/>    <strong class="my iu">for</strong> val <strong class="my iu">in</strong> iterable:<br/>        <strong class="my iu">yield</strong> False, val</span></pre><p id="bd3d" class="pw-post-body-paragraph ly lz it ma b mb ni ju md me nj jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在，只要拿起这些函数，把它们放入你的小助手功能工具箱中，就可以享受了。我祝你愉快地找到你的可重复元素中的最后一个(或第一个)元素。</p></div></div>    
</body>
</html>