<html>
<head>
<title>Compose and SwiftUI: ViewModel Event and State Handling Using KMM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Compose和SwiftUI:使用KMM处理视图模型事件和状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compose-and-swiftui-viewmodel-event-and-state-handling-using-kmm-3f39f8dce4fe?source=collection_archive---------2-----------------------#2022-08-28">https://betterprogramming.pub/compose-and-swiftui-viewmodel-event-and-state-handling-using-kmm-3f39f8dce4fe?source=collection_archive---------2-----------------------#2022-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用在Jetpack Compose和SwiftUI之间共享的视图模型的KMM实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/41fb1f38b1a91680bc23df5008ceecc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnGZdEWDMsW4wOQCKnSfpg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@filipthedesigner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲利普·米舍夫斯基</a> @ <a class="ae kv" href="https://unsplash.com/es/s/fotos/boring?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="c9d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道，我知道。有很多文章在讨论<a class="ae kv" href="https://kotlinlang.org/lp/mobile/" rel="noopener ugc nofollow" target="_blank"> Kotlin多平台移动</a>和SwiftUi与Compose之间的视图模型共享。我读过一些。作者带来了很好的解决方案，但在我看来，其中许多非常复杂(或者可能不是最新的)。经过几天的研究，我找到了我个人的解决方案，我想分享一下。</p><p id="4f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就跨平台解决方案而言，我们可能希望在代码可重用性和本机抽象之间找到一个好的位置。在我看来，<a class="ae kv" href="https://multi-os-engine.org" rel="noopener ugc nofollow" target="_blank">多操作系统引擎</a> * (MOE)和<a class="ae kv" href="https://kotlinlang.org/lp/mobile/" rel="noopener ugc nofollow" target="_blank"> Kotlin多平台【移动】</a>完成了这项工作。不像<a class="ae kv" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> Flutter </a>或<a class="ae kv" href="https://dotnet.microsoft.com/en-us/apps/xamarin" rel="noopener ugc nofollow" target="_blank"> Xamarin </a> *，你得到的是用本地语言编写的真正的本地代码。</p><blockquote class="ls lt lu"><p id="9141" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">*在这里查看我关于MOE <a class="ae kv" href="https://martppa.com/2018/10/10/java-clean-way" rel="noopener ugc nofollow" target="_blank">的帖子，或者在这里</a>直接进入应用的代码<a class="ae kv" href="https://github.com/martppa/java-clean-architecture" rel="noopener ugc nofollow" target="_blank">。Xamarin多平台文章也</a><a class="ae kv" href="https://martppa.com/2018/10/23/net-clean-architecture/" rel="noopener ugc nofollow" target="_blank">这里</a>或者直接访问代码<a class="ae kv" href="https://github.com/martppa/dotnet-clean-architecture" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h2 id="7b5b" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">内存管理</h2><p id="6424" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这种集成最重要的部分是JetBrains开发的新内存管理。这将允许您的Swift代码收集<code class="fe ne nf ng nh b">viewmodel</code>的状态流。要启用内存管理，请在您的<code class="fe ne nf ng nh b">gradle.properties</code>中添加以下代码行:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="2507" class="mg mh iq nh b gy nm nn l no np">kotlin.native.binary.memoryModel=experimental</span></pre></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="381b" class="nq mh iq bd mi nr ns nt ml nu nv nw mo jw nx jx mr jz ny ka mu kc nz kd mx oa bi translated">代码可重用性</h1><p id="c298" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果你正在阅读这篇文章，那么你可能知道ViewModel共享的真正目的。在所有平台之间保持一个共同的代码将减少开发时间和精力，也可能共享错误。</p><p id="e4de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的目标是在所有平台之间开发共享代码，并保留特定于平台的用户界面代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/b25f7e9a6430c3fbccffe77ebfb1ab32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykA62y0JB8FOmE9unOKb2A.png"/></div></div></figure><h2 id="dc50" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">视图模型</h2><p id="c66b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">假设您正在为全新的IO设备编写一个应用程序。客户将使用此应用程序来选择Wifi网络并设置他们的设备。将<code class="fe ne nf ng nh b">HomeViewModel</code>视为主屏幕的<code class="fe ne nf ng nh b">viewModel</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6f44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">HomeViewModel</code>只要屏幕打开，就会跟踪所有发现的网络(假计数器)。一旦用户点击“下一步”按钮，<code class="fe ne nf ng nh b">WifiScreen</code>就会出现。<code class="fe ne nf ng nh b">ViewModel</code>公开了一个简单的接口:一个通知“下一步”按钮被点击的方法和一个UI状态对象。</p><h2 id="1dc3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">用户界面状态</h2><p id="e3f3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">状态对象指的是声明性UI的状态。在您的应用程序中，<code class="fe ne nf ng nh b">HomeState</code>保持着<code class="fe ne nf ng nh b">HomeScreen</code>的状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="47cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">counter</code>保存UI中呈现的计数器值。<code class="fe ne nf ng nh b">navigateToNext</code>举办导航的活动。</p><h2 id="5fef" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">事件</h2><p id="4378" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">事件是只能使用一次的对象。事件被放在UI状态中等待使用。</p><blockquote class="ls lt lu"><p id="e561" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">提示:为了简单起见，HomeState包含一个专用的类成员navigateToNext，其唯一目的就是导航。如果您考虑在屏幕上有多个事件，一个好的解决方案可能是使用一个通用的事件对象，并在UI端使用多态性，而不是成员的复制。这有什么坏处吗？嗯……它会给用户界面增加一些逻辑。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f271" class="nq mh iq bd mi nr ns nt ml nu nv nw mo jw nx jx mr jz ny ka mu kc nz kd mx oa bi translated">平台特定代码</h1><p id="337b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">既然已经编写了通用代码，就可以开始在各种平台上使用它了(这里是iOS和Android)</p><h2 id="41aa" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">机器人</h2><p id="42bf" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在Android中，您的<code class="fe ne nf ng nh b">HomeScreen</code>看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">HomeScreen</code>收集其状态，显示计数器并使用导航事件。</p><h2 id="ac3e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">ios</h2><p id="a1cd" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">iOS实现也很类似。SwiftUI本身无法区分Kotlin中状态流的一般类型。要解决这个问题，您必须创建自己的收集器来强制进行这种转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="bd72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面看到的，您的收集器将其功能扩展并委托给Kotlin的流收集器。它将强制转换和发射非空值。</p><p id="1c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦定义了您的自定义收集器，iOS中的<code class="fe ne nf ng nh b">HomeScreen</code>遵循与Android中完全相同的原则:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦视图出现，它将开始通过自定义收集器收集<code class="fe ne nf ng nh b">viewModel</code>的状态。注意<code class="fe ne nf ng nh b">navigateToNext</code>事件就像在Android中一样被使用。</p><h1 id="bd4f" class="nq mh iq bd mi nr oe nt ml nu of nw mo jw og jx mr jz oh ka mu kc oi kd mx oa bi translated">就这样</h1><p id="e46e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这是我对这个话题的一点简单的意见。希望它能对这种情况下的任何人有所帮助。<a class="ae kv" href="https://github.com/martppa/kmmex" rel="noopener ugc nofollow" target="_blank">这里是完整的代码</a>。</p></div></div>    
</body>
</html>