<html>
<head>
<title>A Memory-Friendly Way of Reading Files in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种读取Node.js中文件的内存友好方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-memory-friendly-way-of-reading-files-in-node-js-a45ad0cc7bb6?source=collection_archive---------0-----------------------#2021-01-04">https://betterprogramming.pub/a-memory-friendly-way-of-reading-files-in-node-js-a45ad0cc7bb6?source=collection_archive---------0-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ad9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用有限的内存读取千兆字节的数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9b7004afdc5d8bbffe5c1ed5aa667ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Y8z9n07OCfkF8Oe2v_1gQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@zackeithharris?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">扎克·哈里斯</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="646a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在各种情况下都可能需要读取文件。它可以是解析错误日志的一次性工作、应用程序的功能、预定的数据迁移任务、部署管道的一部分等。不管什么原因，读取Node.js中的文件是一项非常简单明了的任务。但是，当文件大小超过计算机的RAM容量时，就会出现问题。除了硬件限制，内存还会受到VPS提供商、Kubernetes pod设置等的限制。</p><p id="ca3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的<code class="fe ls lt lu lv b">fs.readFile</code>做不了这个工作。闭上眼睛希望这次会过去是没有用的。</p><p id="9bfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候进行一些内存感知编程了。</p><p id="752d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将研究Node.js中读取文件的三种方法。我的目标是找到在内存使用方面最有效的<em class="lw">方法。我将介绍:</em></p><ol class=""><li id="c4af" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">内置<code class="fe ls lt lu lv b">fs.readFileSync</code></li><li id="adb7" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">迭代<code class="fe ls lt lu lv b">fs.createReadStream</code></li><li id="0ee5" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated"><code class="fe ls lt lu lv b">fs.read</code>带共享缓冲区</li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="6e04" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">实验</h1><p id="b7e6" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我将每种方法都实现为一个小型Node.js应用程序，并在Docker容器中运行。每个应用程序的任务是以10MB的块来处理1GB的文件。</p><p id="1034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在程序执行期间，我多次测量Docker容器的内存使用情况。注意，在本文显示的图表中，测量的内存是Node.js程序本身和Docker容器中所有进程(包括OS)使用的内存的总和。</p><p id="3ae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是否注意到单个块的大小相当大？10MB的文本数据包含10，000，000个字符(在UTF-8中，一个字符占用一个字节)。它远远超过了普通日志文件或CSV的单行字符数。在实际应用中，单线的大小是合理的。我使用与空闲Docker容器相当大小的块。这样，对块大小敏感的实现之间的任何差异将在图表中更加明显。</p><p id="efae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速看看我们在处理什么。在下面的图表中，我们可以看到每个程序的内存使用量的移动最大值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/ebe4cc63545d331837fdffc7ea7ace6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqIGUXUo7A6fZVhi69w4Rg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移动createReadStream、read和readFileSync的最大内存使用量。</p></figure><p id="d437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们清楚的看到最差的是<code class="fe ls lt lu lv b">readFileSync</code>，占用了1GB以上的内存。下一个，足迹更小的是<code class="fe ls lt lu lv b">createReadStream</code>。最好的是<code class="fe ls lt lu lv b">read</code>，它使用不到20MB(块大小的两倍)。</p><p id="8961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一张图显示了相同的数据，但仅针对最后两个函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/e53e092ddeda58f30e5d3c722096c7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7S88LMCZoq3KfaQXHqiT3Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移动createReadStream和read的最大内存使用量。</p></figure><p id="2af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个很好的概述，让我们进入每种方法的实现。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="6f19" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">最简单也是最致命的方法是<code class="fe ls lt lu lv b">readFileSync</code>一个文件</h1><p id="623a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe ls lt lu lv b">readFileSync</code>，或者它的异步兄弟<code class="fe ls lt lu lv b">readFile</code>，是最容易的选择。读取一个文件只需要一行代码，然后一个<code class="fe ls lt lu lv b">for</code>循环就可以遍历内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ca84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件的全部内容保存在<code class="fe ls lt lu lv b">data</code>变量中。所以这并不奇怪:它至少需要1GB的内存。当我们处理大文件时，这种方法显然不是最好的。然而，它的简单性和我们可以在一行代码中访问所有数据的事实使得它值得考虑使用较小的文件。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="d82d" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">使用<code class="fe ls lt lu lv b">createReadStream</code>释放一些压力</h1><p id="75be" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">从使用的简单性来说，<code class="fe ls lt lu lv b">fs.crateReadStream</code>和<code class="fe ls lt lu lv b">readFile</code>一样简单。读取一个文件仍然需要一行代码。事实上，这两个代码片段甚至看起来很相似。不同之处在于，这个方法返回的是一个流，而不是文件的内容。流需要额外的处理才能访问实际数据。</p><p id="8fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">流可能听起来很可怕，甚至可以被认为是“高级”编程。然而，正如您在代码示例中看到的，我们可以只使用一个<code class="fe ls lt lu lv b">for-await</code>循环来读取它。这就像迭代一个数组一样简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ac14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">highWaterMark</code>选项告诉Node一次只读取提供的字节数。这使得它的内存效率更高，因为在单次迭代中，内存中保存的数据量是有限的。</p><p id="65c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法已经给了我们一个好得多的结果:90MB。该容器的内存使用量比前一个示例低10倍。尽管如此，它还是比块大小大九倍。</p><p id="4407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，测量值之间的偏差相当大。然而，我们指示Node.js在单次迭代中读取10MB，这并不保证在单个时间点运行时内存中会保留一个块。旧的块最终会被垃圾收集器移除，但我们无法控制何时会发生这种情况。</p><p id="692f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种方法可以在内存使用的水平和稳定性方面取得更好的结果。让我们看看如何使用带有共享缓冲区的<code class="fe ls lt lu lv b">fs.read</code>来实现它。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="a077" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">通过R <code class="fe ls lt lu lv b">ead</code>和共享缓冲器实现更多控制</h1><p id="b317" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这种方法比前两种稍微复杂一点。然而，我能够通过这种方式实现最低的内存使用和变化。</p><p id="342c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序由三个简单的部分组成，我将逐步介绍这三个部分:</p><ol class=""><li id="dfde" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">许诺过的<code class="fe ls lt lu lv b">fs.read</code></li><li id="fd4b" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">异步发电机</li><li id="763b" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">处理数据的主应用程序循环</li></ol><h2 id="23a6" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated">但是首先，什么是“共享”缓冲区？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bde70f7cb43192e5789c1b19d12eb571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIMY5crOiywYdVHgzgrTPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">独立缓冲区与共享缓冲区</p></figure><p id="cc13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">共享缓冲区是通过引用传递给所有函数的变量。我没有在每个函数中创建一个新的缓冲区，而是在程序开始时创建一个单独的缓冲区，并传递下去。在代码示例中，我通过一个名为<code class="fe ls lt lu lv b">sharedBuffer</code>的变量来引用它，所以它应该是清晰可见的。</p><p id="57c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是允许我降低内存使用和变化的实际技术。在下面的图表中，有两个程序之间的比较。如果没有共享缓冲区，程序将会对相同的数据进行多次复制，从而使数据变得多余。从图表中我们可以看出，这是非常昂贵的。此外，内存使用量在20MB到80MB之间变化，这是由于垃圾收集造成的。</p><p id="249f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">共享缓冲区允许我们降低内存使用，使它更一致。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/3838f588277acb1c4247537a613fdc2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mNZ5s9UjId-Z8SNBPokTw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有和没有共享缓冲区的内存使用情况</p></figure><h2 id="410a" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated"><code class="fe ls lt lu lv b">readBytes — </code>被许诺的<code class="fe ls lt lu lv b">fs.read</code></h2><p id="840d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">首先，我们为<code class="fe ls lt lu lv b">fs.read</code>创建一个包装器。将内置的<code class="fe ls lt lu lv b">fs.read</code>转换成承诺会简化它的用法。根据文档中的<a class="ae kv" href="https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback" rel="noopener ugc nofollow" target="_blank">，我们使用以下参数调用<code class="fe ls lt lu lv b">fs.read</code>:</a></p><ul class=""><li id="eaa0" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr oh md me mf bi translated"><code class="fe ls lt lu lv b">fd</code> —表示文件描述符的整数。它将在程序的后面创建。</li><li id="2109" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated"><code class="fe ls lt lu lv b">sharedBuffer</code> —我们要写入数据的缓冲区。</li><li id="6b41" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated"><code class="fe ls lt lu lv b">0</code> —缓冲区中开始写入的偏移量。我们总是在<code class="fe ls lt lu lv b">sharedBuffer</code>的开头写数据。</li><li id="d0d4" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated"><code class="fe ls lt lu lv b">sharedBuffer.length</code>—要读取的字节数。在我们的例子中，它总是我们缓冲区的长度。</li><li id="7398" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated"><code class="fe ls lt lu lv b">null</code> —文件中开始读取的位置。当位置设置为<code class="fe ls lt lu lv b">null</code>时，文件将从第一个字节开始读取，然后位置将自动更新。</li><li id="59a1" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated">最后一个参数是回调函数。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="eb35" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated"><code class="fe ls lt lu lv b">generateChunks</code> —异步发电机</h2><p id="f2e7" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">JavaScript中的生成器返回<em class="lw">迭代器</em>——我们可以在<code class="fe ls lt lu lv b">for</code>循环中使用的特殊对象。我们可以把它们想象成动态更新的数组。在迭代的每一步中，生成器可能会追加下一个元素。这就是我们实际正在做的事情。在每一步中，我们读取下一部分字节，<em class="lw">产生</em>作为这个“虚拟数组”的下一项</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用由<code class="fe ls lt lu lv b">generateChunks</code>生成器返回的迭代器，我们可以在一个<code class="fe ls lt lu lv b">for</code>循环中迭代文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在迭代的最后一步，我们必须格外小心。数据的最后部分可能比我们的缓冲区大小短。但是，缓冲区本身的大小是恒定的。这意味着缓冲区可能在开头由新块组成，在结尾由以前的块组成。</p><p id="358f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过用<code class="fe ls lt lu lv b">buffer.slice(0, end)</code>访问数据来处理这种情况。它从开始到<code class="fe ls lt lu lv b">end</code>返回部分缓冲区，等于当前步骤读取的字节数。</p><h2 id="e707" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated">强大又冒险…</h2><p id="ceb6" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">虽然使用共享缓冲区的<code class="fe ls lt lu lv b">fs.read</code>是对内存最友好的方法，但是<em class="lw">共享缓冲区</em>部分有点棘手。如果使用不当，这种技术可能会导致:</p><ul class=""><li id="00cd" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr oh md me mf bi translated">数据泄漏—当缓冲区中填充了来自以前或将来迭代的字节，并且被错误地处理为当前字节时。尤其是在读取文件结尾时，可能会发生这种情况。</li><li id="7fa3" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated">数据畸形——共享缓冲区在程序的不同部分被无意修改。</li></ul><p id="2dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法时要格外小心！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="4f01" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">摘要</h1><p id="d966" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在读取Node.js中的文件时,<code class="fe ls lt lu lv b">fs.createReadStream</code>和<code class="fe ls lt lu lv b">fs.read</code>都可以降低内存使用量。如果数据结构允许它被流式传输，那么这两种方法中的任何一种都是合适的。我们的应用程序直接使用的内存量取决于块的大小，应该根据数据结构或可用内存等特性进行设置。</p><p id="8772" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当块大小增加时，<code class="fe ls lt lu lv b">fs.createReadStream</code>和<code class="fe ls lt lu lv b">fs.read</code>之间的差异会更加明显。<code class="fe ls lt lu lv b">fs.read</code>的内存使用量大约低10倍。在这个基准测试中，我使用了10MB的内存块，所以内存使用量相差10倍就是100MB。在实际应用程序中，块可能会小得多，因此所用内存量的差异可以忽略不计。在这种情况下，方法的简单性和安全性可能是决定性因素。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="7451" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">资源</h1><ul class=""><li id="f162" class="lx ly iq ky b kz nk lc nl lf oi lj oj ln ok lr oh md me mf bi translated"><a class="ae kv" href="https://github.com/kmoskwiak/articles/tree/master/202012-Memory-friendly-way-of-reading-files-in-Nodejs" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li><li id="ea95" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oh md me mf bi translated"><a class="ae kv" href="https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback" rel="noopener ugc nofollow" target="_blank">节点单据</a></li></ul></div></div>    
</body>
</html>