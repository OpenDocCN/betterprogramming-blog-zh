<html>
<head>
<title>What Are CJS, AMD, UMD, ESM, System, and IIFE?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是CJS，AMD，UMD，ESM，System，IIFE？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62?source=collection_archive---------1-----------------------#2021-02-22">https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62?source=collection_archive---------1-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4646" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用汇总示例说明模块格式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/885b8bf4b2276fc77b570caa73e908a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H9FTM_m_9kn1MzWN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@euwars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法尔扎德·纳兹菲</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代JavaScript项目需要一个捆绑器来将小段代码编译成更大更复杂的东西，比如一个库或应用程序。常见的捆扎机有<a class="ae ky" href="https://medium.com/better-programming/micro-frontends-using-webpack-5-module-federation-3b97ffb22a0d" rel="noopener"> webpack </a>、<a class="ae ky" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>、<a class="ae ky" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>、<a class="ae ky" href="https://requirejs.org/" rel="noopener ugc nofollow" target="_blank">requires</a>和<a class="ae ky" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>。它们将JavaScript代码转换成可以作为一个包加载的模块。</p><p id="0378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">束可以以不同的格式排列。在本文中，我们将展示CJS、AMD、UMD、ESM、System和IIFE格式的真实示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">捆扎机和格式</h1><p id="3483" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个标准的HTML文件，第5行包含一个样式表，第6行包含一个JavaScript文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dc5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有JavaScript代码放在一个文件中对于一个简单的例子来说是可行的。随着项目规模的扩大，我们需要将代码模块化为具有独立名称空间的独立模块。除了更好的组织，模块化还带来了封装、依赖性管理和可重用性的能力。</p><p id="394d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是捆绑者进入画面的方式。需要将小块JavaScript代码连同样式表和图像一起编译成更大更复杂的东西，比如库或应用程序。</p><p id="147d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">捆绑器应该如何将捆绑的代码格式化为输出？有许多选择，<a class="ae ky" href="https://rollupjs.org/guide/en/#outputformat" rel="noopener ugc nofollow" target="_blank">roll up</a>定义了以下格式:</p><ul class=""><li id="ce49" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">cjs</code> (CommonJS) —适用于Node和其他bundlers(别名:<code class="fe nk nl nm nn b">commonjs</code>)。</li><li id="60e9" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">amd</code>(异步模块定义)—用于像RequireJS这样的模块加载器。</li><li id="1bbe" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">umd</code>(通用模块定义)—集<code class="fe nk nl nm nn b">amd</code>、<code class="fe nk nl nm nn b">cjs</code>和<code class="fe nk nl nm nn b">iife</code>于一身。</li><li id="bf50" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">es</code>–将包保存为ES模块文件。适用于其他捆绑器，并作为<code class="fe nk nl nm nn b">&lt;script type=module&gt;</code>标签包含在现代浏览器中(别名:<code class="fe nk nl nm nn b">esm</code>、<code class="fe nk nl nm nn b">module</code>)。</li><li id="801e" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">system</code>–system js加载程序的原生格式(别名:<code class="fe nk nl nm nn b">systemjs</code>)。</li><li id="a9c4" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">iife</code>–适合作为<code class="fe nk nl nm nn b">&lt;script&gt;</code>标签包含的自执行功能。如果您想为您的应用程序创建一个包，您可能想使用这个。</li></ul><p id="0687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过例子来解释这些格式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8386" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这个例子</h1><p id="752c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是一个要捆绑四个文件的示例:</p><ul class=""><li id="7283" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">index.js</code></li><li id="305f" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">increase.js</code></li><li id="80e4" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">decrease.js</code></li><li id="92cd" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">others.js</code></li></ul><p id="64f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主入口文件是<code class="fe nk nl nm nn b">index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4-6行，<code class="fe nk nl nm nn b">index.js</code>明确列出了从<code class="fe nk nl nm nn b">increase.js</code>、<code class="fe nk nl nm nn b">decrease.js</code>和<code class="fe nk nl nm nn b">others.js</code>导入的内容。</p><p id="9ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是进口的<code class="fe nk nl nm nn b">increase.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="96f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是进口的<code class="fe nk nl nm nn b">decrease.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是进口的<code class="fe nk nl nm nn b">others.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本例中没有使用<code class="fe nk nl nm nn b">others.js</code>中的<code class="fe nk nl nm nn b">const d</code>和<code class="fe nk nl nm nn b">index.js</code>中的<code class="fe nk nl nm nn b">function divide()</code>。<code class="fe nk nl nm nn b">index.js</code>中的<code class="fe nk nl nm nn b">function power()</code>也不用，但是导出。</p><p id="b4ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2015/ES6引入了静态<code class="fe nk nl nm nn b"><a class="ae ky" href="https://medium.com/better-programming/a-handy-guide-to-export-and-import-modules-for-javascript-and-typescript-6cff8e47d554" rel="noopener">import</a></code> <a class="ae ky" href="https://medium.com/better-programming/a-handy-guide-to-export-and-import-modules-for-javascript-and-typescript-6cff8e47d554" rel="noopener">和</a> <code class="fe nk nl nm nn b"><a class="ae ky" href="https://medium.com/better-programming/a-handy-guide-to-export-and-import-modules-for-javascript-and-typescript-6cff8e47d554" rel="noopener">export</a></code>，允许静态分析器在不运行代码的情况下构建完整的依赖关系树。此外，这为树抖动优化奠定了基础。根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Tree_shaking" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="nt"><p id="c134" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">“树摇动通过从入口点开始并且仅包括可能被执行的函数，从束中消除了未使用的函数。”</p></blockquote><p id="8092" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">由于这个例子是用ES2015风格写的，带有特定的导入(不是<code class="fe nk nl nm nn b">import *</code>)，所以rollup树抖动过程会移除<strong class="lb iu"> <em class="oi">中的<code class="fe nk nl nm nn b">const d</code>和<code class="fe nk nl nm nn b">function divide()</code>所有</em> </strong>生成的格式。<code class="fe nk nl nm nn b">function power()</code>被保留，因为导出的功能可能会被使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8848" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">CommonJS (CJS)</h1><p id="9e29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank"> CJS </a>适用于<a class="ae ky" href="https://medium.com/better-programming/whats-new-in-node-js-15-fc24e87e2590" rel="noopener">节点</a>以及网页浏览器之外的其他生态系统。在<a class="ae ky" href="https://medium.com/javascript-in-plain-english/a-hands-on-guide-for-a-server-side-rendering-react-app-dd1efa3ec0d8" rel="noopener">服务器端</a>广泛使用。使用<code class="fe nk nl nm nn b">require()</code>功能和<code class="fe nk nl nm nn b">module.exports</code>可以识别CJS。<code class="fe nk nl nm nn b">require()</code>是一个函数，可用于将符号从另一个模块导入到当前范围。<code class="fe nk nl nm nn b">module.exports</code>是当前模块在另一个模块需要时返回的对象。</p><p id="e539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CJS模块的设计考虑到了服务器开发。自然，API是同步的。换句话说，模块是在源文件中按照需要的顺序加载的。</p><p id="6da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于CJS是同步的，并且不能被浏览器本地识别，所以CJS模块不能在浏览器端使用，除非它与transpiler打包在一起。transpiler，如<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>或<a class="ae ky" href="https://github.com/google/traceur-compiler" rel="noopener ugc nofollow" target="_blank"> Traceur </a>，是一种帮助在较新版本的JavaScript中编写代码的工具。如果环境本身不支持较新的版本，transpiler会将它们编译成支持的版本。</p><p id="73d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是CJS格式的汇总生成文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在浏览器端执行这个文件，它出错并显示消息<code class="fe nk nl nm nn b">exports is not defined</code>(第3行)。</p><p id="7aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过在<code class="fe nk nl nm nn b">index.html</code>中包含以下代码来修复错误:</p><pre class="kj kk kl km gt oj nn ok ol aw om bi"><span id="2ffe" class="on md it nn b gy oo op l oq or">&lt;script&gt;<br/>  const exports = {};<br/>&lt;/script&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="71a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步模块定义(AMD)</h1><p id="579b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" rel="noopener ugc nofollow" target="_blank"> AMD </a>诞生于CJS，支持异步模块加载。AMD和CJS的主要区别在于对异步模块加载的支持。AMD是RequireJS用的，在浏览器端工作。</p><p id="7fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="nt"><p id="cf6c" class="nu nv it bd nw nx ny nz oa ob oc lu dk translated">“AMD提供了一些CJS互操作性。它允许在代码中使用类似的<code class="fe nk nl nm nn b">exports</code>和<code class="fe nk nl nm nn b">require()</code>接口，尽管它自己的<code class="fe nk nl nm nn b">define()</code>接口更加基础和首选。”</p></blockquote><p id="60f0" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">以下是AMD格式的汇总生成文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在浏览器端执行这个文件，它出错并显示消息<code class="fe nk nl nm nn b">define is not a function</code>(第1行)。</p><p id="8f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过在<code class="fe nk nl nm nn b">index.html</code>中包含<code class="fe nk nl nm nn b">require.js</code>来修复错误:</p><pre class="kj kk kl km gt oj nn ok ol aw om bi"><span id="d9bb" class="on md it nn b gy oo op l oq or">&lt;script src=”https://requirejs.org/docs/release/2.3.6/minified/require.js"&gt;&lt;/script&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6beb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通用模块定义(UMD)</h1><p id="eeda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">UMD被设计成可以在任何地方工作——在服务器端和浏览器端。它试图提供与当今最流行的脚本加载器的兼容性，比如RequireJS。在许多情况下，它使用AMD作为基础，并添加了特殊的外壳来处理CJS兼容性。然而，兼容性增加了一些复杂性，使得读写变得复杂。</p><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是UMD格式的汇总生成文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码可以在浏览器中运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0505" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">ES2015模块(ESM)</h1><p id="9f50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ESM自2015年起成为JavaScript使用的官方标准。它在JavaScript客户端开发中被广泛使用，并且也被TypeScript所采用，TypeScript是具有附加类型的超集。</p><p id="b5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe nk nl nm nn b">^12.20.0 || ^14.13.1 || &gt;=16.0.0</code>版本开始，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/what-might-be-coming-in-npm-9-6985cf2678a6">节点开始支持ESM </a>。ESM越来越受欢迎，可用于客户端和服务器。</p><p id="ab25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态的<code class="fe nk nl nm nn b">import</code>指令可以用来将模块引入当前范围。<a class="ae ky" href="https://medium.com/better-programming/dynamic-import-code-splitting-lazy-loading-and-error-boundaries-fff57e63f6c4" rel="noopener">动态</a> <code class="fe nk nl nm nn b"><a class="ae ky" href="https://medium.com/better-programming/dynamic-import-code-splitting-lazy-loading-and-error-boundaries-fff57e63f6c4" rel="noopener">import()</a></code>从ES2020开始提供。</p><p id="bc6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面,<code class="fe nk nl nm nn b">export</code>指令可以用来显式地公开项目。</p><p id="aacd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是ESM格式的汇总生成文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="aeec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在浏览器端执行这个文件，它出错并显示消息<code class="fe nk nl nm nn b">Uncaught SyntaxError: Unexpected token 'export'</code>(第45行)。</p><p id="9a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过将<code class="fe nk nl nm nn b">script</code>标签的<code class="fe nk nl nm nn b">type</code>设置为<code class="fe nk nl nm nn b">index.html</code>中的<code class="fe nk nl nm nn b">module</code>来修复该错误:</p><pre class="kj kk kl km gt oj nn ok ol aw om bi"><span id="b3ac" class="on md it nn b gy oo op l oq or">&lt;script type=”module” src=”dist/bundle.js”&gt;&lt;/script&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a1d4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">系统模件</h1><p id="a519" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank"> SystemJS </a>是一款通用模块加载器，支持CJS、AMD和ESM模块。Rollup可以将代码捆绑成SystemJS的原生格式。</p><p id="9044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是以系统格式汇总生成的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在浏览器端执行这个文件，它出错并显示消息<code class="fe nk nl nm nn b">System is not defined</code>(第1行)。</p><p id="ae6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装<code class="fe nk nl nm nn b">system.js</code>:</p><pre class="kj kk kl km gt oj nn ok ol aw om bi"><span id="42d4" class="on md it nn b gy oo op l oq or">npm install --save-dev systemjs</span></pre><p id="aa3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过将<code class="fe nk nl nm nn b">system.js</code>包含在<code class="fe nk nl nm nn b">index.html</code>中来修复该错误:</p><pre class="kj kk kl km gt oj nn ok ol aw om bi"><span id="aa8b" class="on md it nn b gy oo op l oq or">&lt;script src="node_modules/systemjs/dist/s.min.js"&gt;&lt;/script&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1099" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">立即调用函数表达式(IIFE)模块</h1><p id="3139" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如模块名所示，IIFE是一个自执行函数，适合作为<code class="fe nk nl nm nn b">&lt;script&gt;</code>标签包含。我们可以使用这种格式为应用程序创建一个包。它帮助我们将东西放入名称空间，以避免变量冲突并保持代码私有。</p><p id="198f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是以IIFE格式汇总生成的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码可以在浏览器中运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7816" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成多种格式</h1><p id="e5ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nk nl nm nn b">rollup.config.js</code>是一个汇总配置文件。它是可选的，但是功能强大、方便，因此值得推荐。</p><p id="a783" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们用来一次生成多种输出格式的输出配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1171" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7b29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们探讨了JavaScript模块格式——CJS、AMD、UMD、ESM、System和IIFE。在这些格式中，ESM很受欢迎，可用于客户端和服务器。</p><p id="6745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p><p id="dfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">注:感谢Daria Mehra审阅本文。</em></p></div></div>    
</body>
</html>