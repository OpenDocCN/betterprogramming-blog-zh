<html>
<head>
<title>Garbage Collection in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的垃圾收集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/garbage-collection-in-python-6dca154ae1dd?source=collection_archive---------14-----------------------#2020-05-11">https://betterprogramming.pub/garbage-collection-in-python-6dca154ae1dd?source=collection_archive---------14-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d1b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回收内存的过程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84b214ab87cbe328e5a57a2c4862271f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPhtmRdktXK9Aldvyl02yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://twitter.com/ninalimpi" rel="noopener ugc nofollow" target="_blank">卡特琳娜·林皮索妮</a>创作的艺术品</p></figure><p id="c43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经编程一段时间了，你可能听说过<em class="lv">垃圾收集。让我们更深入地了解它是什么以及它是如何工作的。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f761" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">什么和为什么</strong></h1><p id="c7a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在现实世界中，我们会清理掉一些东西，例如旧纸币、不再需要的盒子，然后扔进垃圾箱/回收桶。空间有限，我们想腾出空间来存放其他我们想存放的必需品。</p><p id="365a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，在计算机中，空间——又名<em class="lv">内存— </em>是一种重要而有限的资源。因此，垃圾收集器收集不再需要的数据对象并丢弃它们。</p><p id="21a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据语言的不同，垃圾收集可以是自动的，也可以是手动的。在大多数高级语言中，比如Python和Java，它是自动化的。因此，这些语言被称为<em class="lv">垃圾收集语言。</em>其他语言如C不支持自动垃圾回收，由程序员负责内存管理。</p><p id="8ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看垃圾收集是如何工作的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8d3d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">如何</strong></h1><p id="0f45" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有一些技术，但是大多数垃圾收集语言，包括Python，都使用<em class="lv">引用计数。</em>在引用计数中，我们跟踪对一个对象的引用次数，当计数为<code class="fe na nb nc nd b">0</code>时丢弃一个对象。</p><p id="d60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象的引用计数随着指向它的别名数量的变化而变化。当它被赋予一个新名称或被放入一个容器(如列表或字典)中时，计数会增加。当使用<code class="fe na nb nc nd b">del</code>命令删除它、它的引用超出范围或者它被重新分配时，计数会减少。例如:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="3e76" class="ni me it nd b gy nj nk l nl nm">sample = 100 # Creates object &lt;100&gt;. Ref count = 1 </span><span id="2631" class="ni me it nd b gy nn nk l nl nm">sample_copy = sample # Ref count = 2. </span><span id="ec2a" class="ni me it nd b gy nn nk l nl nm">sample_list = [sample] # Ref count = 3.</span><span id="0c90" class="ni me it nd b gy nn nk l nl nm">del sample # Ref count = 2. Note that this doesn't affect sample_copy and sample_list as they directly point to &lt;100&gt;. </span><span id="ae7a" class="ni me it nd b gy nn nk l nl nm">sample_copy = 10 # Ref count = 1 as alias was reassigned.</span><span id="d5b4" class="ni me it nd b gy nn nk l nl nm">sample_list.clear() # Ref count = 0 as list is cleared and doesn't store the alias pointing to &lt;100&gt;. </span></pre><p id="51f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当引用计数下降到<code class="fe na nb nc nd b">0</code>时，引用计数可以立即回收对象。然而，这是有代价的:我们需要为每个对象存储一个额外的整数值来指示它的引用计数(空间和时间的权衡)。</p><p id="33ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，引用计数的一个问题是<em class="lv">引用周期的概念。</em>如果两个对象A和B相互引用，它们实际上是在一个气泡中，引用计数总是大于或等于<code class="fe na nb nc nd b">1</code>。这在列表、类和函数中很常见。例如，当对象引用自身时:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2a02" class="ni me it nd b gy nj nk l nl nm">x = []<br/>x.append(x)</span></pre><p id="3186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者当对象循环引用彼此时:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a1de" class="ni me it nd b gy nj nk l nl nm">a.attribute_1 = b<br/>b.attribute_2 = a</span></pre><p id="fa49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垃圾收集器定期寻找引用循环并删除它们。由于就资源而言这是一个昂贵的过程，所以这是定期进行的并且是预定的。Python垃圾收集器接口提供了探索垃圾收集执行时间表和阈值的方法。</p><div class="no np gp gr nq nr"><a href="https://docs.python.org/3.7/library/gc.html" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">垃圾收集器接口- Python 3.8.3rc1文档</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这个模块为可选的垃圾收集器提供了一个接口。它提供了禁用收集器的能力…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">docs.python.org</p></div></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="faaa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="e05f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">希望这篇文章对你有帮助。</p><p id="c339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考资料和进一步阅读:</p><div class="no np gp gr nq nr"><a href="https://www.tutorialspoint.com/How-does-garbage-collection-work-in-Python" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python中的垃圾收集是如何工作的？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Python会自动删除不需要的对象(内置类型或类实例)来释放内存空间。流程…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://stackoverflow.com/questions/9910774/what-is-a-reference-cycle-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">python中的引用循环是什么？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">stackoverflow.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>