<html>
<head>
<title>Writing Recursive Queries in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SQL Server中编写递归查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-recursive-queries-in-sql-server-a8f4237bea4f?source=collection_archive---------1-----------------------#2022-11-11">https://betterprogramming.pub/writing-recursive-queries-in-sql-server-a8f4237bea4f?source=collection_archive---------1-----------------------#2022-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f909" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何有效地获取层次结构中的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb3e655f7b0e8f0156fc8a6598285f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jOuHO4UgEpETfUtFc9pYg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/ja/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pyramid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="eaa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据中存在某种层次关系并不罕见。</p><p id="267d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储这些数据可能相对容易，但有时要再次取出就有点棘手了，尤其是当数据包含不同层次的时候。</p><p id="b16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，您可能会遇到这样的数据—它可能是一个嵌套组列表，或者是一个家族树，或者是一个企业中员工和经理的结构。在本文中，我们将以员工/经理为例，但希望您能看到这如何应用于不同的情况。</p><p id="003b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将使用SQL Server 2019，但这将适用于从SQL Server2008开始的所有版本的SQL Server。</p><h1 id="d7b7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">建模分层数据</h1><p id="e6f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从数据如何建模开始。</p><p id="5f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有几个用户，每个用户可以管理其他用户。我们可以这样想象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/552bf1f1b291d1a4666567f3e6b9dc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJCzwOEK36Lk3puwHZN1JQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户管理其他用户的分层结构</p></figure><p id="b493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最上面，我们有约翰，他管理着伊恩和艾莉。埃莉不管理任何人，但伊恩管理艾伦和蒂姆。艾伦管理罗伯特。</p><p id="ce03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储这些数据实际上只需要两个表。</p><h2 id="f505" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">存储分层数据</h2><p id="2942" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将从一个<code class="fe nf ng nh ni b">Users</code>表开始，其中存储了每个用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将存储每个关系，指明谁是经理，谁是员工:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fb39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将输入一些数据。使用上面的示例，我们将为用户提供以下数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c08d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管理人员的数据如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="13e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要获得所有用户及其直属经理的列表，我们可以使用以下代码相当容易地做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fd75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利。但是，如果我们想让任何给定用户的所有管理人员都在这个层次结构中呢？所以，如果我们看艾伦，我们会得到伊恩和约翰的列表。如果我们看艾莉，我们只会看到约翰。</p><p id="33ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们进入递归查询的地方。</p><h2 id="353d" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">编写查询以获取单个用户的所有经理</h2><p id="f13f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从一个非常简单的查询开始，以获得任何给定用户的直接经理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回一个值“Ian”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/341728cc7afacb7a84b5d7950e53410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*VSfUkRKRufvAiCKfPNlyOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="5d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，目前为止。</p><p id="2713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在希望这个结果集包含“John”我们可以选择在查询中添加额外的连接，但是我们会受到我们添加的数量的限制。我们可以让它为两个层次的经理工作，但是如果我们突然有了三个层次呢？还是30？这就是我们需要递归查询来找到所有可能的经理的地方，而不管级别的数量。</p><p id="b4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL Server中递归查询的主要元素是公用表表达式(CTE)。CTEs有一个很好的特性，可以让你轻松地处理递归，所以这就是我们在这里要用的。</p><p id="4225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新现有的查询以使用CTE，这样我们就可以逐步完成所需的更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们是如何将查询的一部分移到<code class="fe nf ng nh ni b">WITH</code>块中的——这就是CTE。这基本上是和以前一样的查询(它仍然只返回‘Ian’)，但是现在我们有了一个CTE，更容易添加递归。</p><p id="6ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归CTE的关键部分是一个T1。我们编写CTE首先选择基本数据(在我们的例子中，查找用户的直接经理)，然后将结果数据返回到CTE本身，查找新结果集的经理。</p><p id="fb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fda4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们如何在那里得到一个新的<code class="fe nf ng nh ni b">UNION</code>，它将CTE(称为<code class="fe nf ng nh ni b">AllManagers</code>)加入到<code class="fe nf ng nh ni b">dbo.Managers</code>表中，使用<code class="fe nf ng nh ni b">StaffUserId</code>列来匹配先前选择的经理。</p><p id="511e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，我们现在得到了一个“Ian”和“John”的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/632bd89ad538c4fc0a19eb1bbe263638.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*nq5ZXWywCBJX2AlxHGKydQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="0e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将参数<code class="fe nf ng nh ni b">UserId</code>更改为Id 6并再次执行，我们现在将获得Robert的所有经理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c2a52dd50828c009eaa2721fa3d06919.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*1ja3ELgvu2OAUF-ABACM0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="7898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们有一个递归查询，它返回任何给定用户的所有经理。</p><h2 id="cadb" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">添加层次级别编号</h2><p id="e6b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可能还想为每个返回的经理返回一个索引，以指示谁是直接经理，谁是下一个经理，等等。这很容易做到，并且是对递归cte的有益补充。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们是如何在CTE中添加“位置”栏的。在基本查询中，我们将其设置为1，这将用于直接经理，然后<code class="fe nf ng nh ni b">UNION</code>部分每次都加1来计算级别。为“罗伯特”运行这个，我们得到这些结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6be7cc07865b1c833bab2c35b52aef42.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*-b5b8sn42hatR5EFxzdYdg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="9d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以看到，直接经理(“Alan”)的职位为1，而每个后续经理的职位都在增加。</p><p id="66da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只对特定数量的经理感兴趣(例如，查找用户的前两个经理)，这很有用。</p><h2 id="8bb8" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">避免无限循环</h2><p id="a8da" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">任何递归的一个风险是无限循环，在我们的例子中，编写一个CTE，一遍又一遍地循环，直到SQL最终有足够的循环并终止查询。</p><p id="1524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe nf ng nh ni b">dbo.Managers</code>表中增加一行，使“Robert”成为“John”的经理从视觉上看，层次结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/30f9405736edc9a4fae296a52c3f794a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wF3NI67L_0yztSHBSjCCIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的经理层次结构</p></figure><p id="11c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后的数据应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行最新版本的查询，我们会得到一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f5437c461da81bf8a3fcb0d497ed303e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PZ_88VK3SQi4EethmRVEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无限循环的误差</p></figure><p id="8493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们查看返回的内容，我们可以看到前100行仍然被返回:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0e4150087194d2c52c65475277ef1cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*oo2_QGOLfY8QdybFmZyNfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="6f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是不对的，解决方案是不增加最大递归限制，除非你需要！</p><p id="0d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以解决这个问题，但最简单的(虽然不一定是最快的)方法之一是建立一个经理“路径”,并检查您要添加到CTE的下一个经理是否已经存在。实际上，您可以为已经处理过的经理id构建一个CSV值，并对照它进行检查。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="71a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们如何将<code class="fe nf ng nh ni b">ManagerPath</code>的初始值设置为经理的id，在它的前后加一个逗号，在<code class="fe nf ng nh ni b">UNION</code>中，我们将这个值添加到下一个经理的id中。我们检查我们还没有在<code class="fe nf ng nh ni b">WHERE</code>子句中看到这个经理，检查id(用逗号包围)在那里不存在。</p><p id="d908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生正确的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f803b1f777d269032ad57dda154adca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*pLHekWUOcwC1SYKI2LQAig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><p id="0506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，让“Robert”的经理列表也包含“Robert”对您来说可能没有意义。如果您想从结果中排除原始用户，您也可以将其添加到<code class="fe nf ng nh ni b">WHERE</code>子句中。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生相同的结果集，只是其中没有原始用户:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a15ec7745bce923e3044058bdcb9f55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*6P7VCuyKE81hS-xR9paHlA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询结果</p></figure><h1 id="656a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="5ea2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经看到，我们可以通过使用递归公用表表达式(CTE)在SQL Server中查询分层数据，以返回任何给定行的所有父/祖先。我们还看到了如何为每个结果包含一个位置值并避免无限循环。</p></div></div>    
</body>
</html>