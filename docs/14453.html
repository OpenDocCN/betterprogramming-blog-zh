<html>
<head>
<title>React, Remix, Remix Validated Form, and Zod: The Ultimate Stack for Type-Safe Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React、Remix、Remix验证表单和Zod:类型安全表单的终极堆栈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fullstack-type-safe-forms-with-react-remix-remix-validated-form-and-zod-6a0e30d2dd2f?source=collection_archive---------1-----------------------#2022-12-18">https://betterprogramming.pub/fullstack-type-safe-forms-with-react-remix-remix-validated-form-and-zod-6a0e30d2dd2f?source=collection_archive---------1-----------------------#2022-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7676" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Remix、Remix Validated Form、Zod和Zod表单数据，开发人员可以验证表单，轻松处理和显示错误状态，防止错误提交，改善开发人员体验，并提高开发速度。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a0022547db98f201f457aa0697252ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcP9uWgruCcy4VG5AzxFtA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">顶部带有react徽标的整叠表单</p></figure><p id="952c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Remix利用了web平台API，这使得创建向动作提交数据的表单变得容易，动作将表单数据传递给服务器。</p><p id="7cd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Zod提供了一种在客户端和服务器端验证数据的方法，确保了处理用户数据时的准确性和安全性。Zod表单数据通过提供一种方便的方法将数据从表单映射到Zod类型，进一步简化了这个过程。</p><p id="d18f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在文章的底部找到源代码和所有包的链接。这种组合的另一个令人惊叹的地方是，即使禁用JavaScript，许多功能仍然可以工作，因为验证是在客户端和服务器端处理的。</p><p id="4487" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Zod是一个JavaScript库，它提供了一种强大的、类型安全的方法来定义、验证和操作数据。它使用类似于TypeScript的声明性语法，使得用React创建类型安全的表单变得容易。</p><p id="4548" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该库提供了一种在客户端和服务器端验证数据的方法，确保了处理用户数据时的准确性和安全性。Zod表单数据通过提供一种方便的方法将数据从表单映射到Zod类型，进一步简化了这个过程。</p><p id="2d84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建类型安全窗体的第一步是创建一个提交按钮组件。该提交按钮可以使用<code class="fe lr ls lt lu b">remix-validated-form</code>中的<code class="fe lr ls lt lu b">useIsSubmittingHook</code>自动处理。这个钩子将允许表单自动处理表单提交的状态，以防止重复提交。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="5cc1" class="lz ma iq lu b be mb mc l md me">import { useIsSubmitting } from "remix-validated-form";<br/><br/>export const SubmitButton = ({<br/>    submitText = "Submit",<br/>  }: {<br/>    submitText?: string;<br/>  }) =&gt; {<br/>    const isSubmitting = useIsSubmitting();<br/>  <br/>    return (<br/>      &lt;button<br/>        type="submit"<br/>        disabled={isSubmitting}<br/>        className="bg-black text-white p-3 rounded-md"<br/>      &gt;<br/>        {isSubmitting ? "Submitting..." : submitText}<br/>      &lt;/button&gt;<br/>    );<br/>  };</span></pre><p id="0c9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要创建一个输入字段，它使用来自<code class="fe lr ls lt lu b">remix-validated-form</code>的<code class="fe lr ls lt lu b">useField</code>钩子。这个钩子有一些有用的特性，比如错误反馈。我们可以使用它来显示哪些字段给我们带来了错误的视觉反馈，并向用户显示该错误。此外，当输入被点击时，我们使用<code class="fe lr ls lt lu b">clearError</code>函数来清除错误。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="ba8e" class="lz ma iq lu b be mb mc l md me">import classNames from "classnames";<br/>import { useField } from "remix-validated-form";<br/><br/>export const Input = ({<br/>  name,<br/>  title,<br/>  id,<br/>}: {<br/>  name: string;<br/>  title?: string;<br/>  id?: string;<br/>}) =&gt; {<br/>  const field = useField(name);<br/>  return (<br/>    &lt;div className={"flex flex-col w-full"}&gt;<br/>      &lt;label htmlFor={name}&gt;{title}&lt;/label&gt;<br/>      &lt;input<br/>        {...field.getInputProps()}<br/>        className={classNames("border-2 rounded-md", {<br/>          "border-2 !border-red-500": field.error,<br/>        })}<br/>        name={name}<br/>        id={id ? id : name}<br/>        onClick={() =&gt; {<br/>          field.clearError();<br/>        }}<br/>        onChange={() =&gt; {<br/>          if (field.error) field.clearError();<br/>        }}<br/>      /&gt;<br/>      &lt;div className="text-red-500"&gt;{field.error}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="8d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的代码中，我们创建了一个模式，我们基于该模式创建了一个验证器，然后我们创建了一个客户端表单，我们在其中传递该模式，然后表单将根据该验证器在客户端和服务器上验证表单。</p><p id="7963" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，一旦我们将表单数据提交给服务器，它将根据验证器验证该数据，然后我们可以提取经过验证的数据。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="413b" class="lz ma iq lu b be mb mc l md me">import { ActionArgs } from "@remix-run/node";<br/>import { withZod } from "@remix-validated-form/with-zod";<br/>import { ValidatedForm, validationError } from "remix-validated-form";<br/>import { z } from "zod";<br/>import { zfd } from "zod-form-data";<br/>import { Input } from "~/components/input";<br/>import { SubmitButton } from "~/components/submit-button";<br/><br/>const createPostSchema = zfd.formData({<br/>  //  zfd(zod form data) is a helper that helps to parse the form data to an object<br/>  // using the zod schema, if there are multiple values with the same name an array will be returned.<br/>  // it can handle URLSearchParams, FormData, and plain objects<br/>  title: zfd.text(z.string().min(1).max(100)),<br/>  author: zfd.text(z.string().min(1).max(50)),<br/>  content: zfd.text(z.string().min(1).max(1000)),<br/>  published: zfd.checkbox(),<br/>});<br/>export type CreatePostType = z.infer&lt;typeof createPostSchema&gt;;<br/>// remix-validated-form with-zod is a helper that helps to validate form data<br/>// remix-validated-form supported custom validation and other libraries like yup<br/>const createPostValidator = withZod(createPostSchema);<br/>export async function action({ request }: ActionArgs) {<br/>  const formData = await request.formData();<br/>  const validation = await createPostValidator.validate(formData);<br/>  // if there are any errors, return validationError, this is also handled<br/>  // by remix-validated-form<br/>  if (validation.error) {<br/>    return validationError(validation.error);<br/>  }<br/>  // if we make it here, we know that there are no errors so we can<br/>  // get the data from the validation object<br/>  const { title, content, author, published } = validation.data;<br/>  console.log("Creating Post...", { title, content, author, published });<br/>}<br/>export default function () {<br/>  return (<br/>    &lt;div className="flex items-center justify-center"&gt;<br/>      {/* Validated form will validate form on both the server side and client side <br/>      form will not submit to server if there are any errors.*/}<br/>      &lt;ValidatedForm<br/>        validator={createPostValidator}<br/>        className="flex flex-col space-y-4 w-10/12 lg:w-1/2"<br/>        method="post"<br/>      &gt;<br/>        &lt;Input name="title" title="Post Title" /&gt;<br/>        &lt;Input name="author" title="Author" /&gt;<br/>        &lt;Input name="content" title="Post Content" /&gt;<br/>        &lt;div className="flex flex-row items-center"&gt;<br/>          &lt;label htmlFor="publish"&gt;Publish&lt;/label&gt;<br/>          &lt;input<br/>            type="checkbox"<br/>            id="publish"<br/>            name="publish"<br/>            className="ml-2 h-5 w-5"<br/>          /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="w-full flex justify-center items-center"&gt;<br/>          &lt;SubmitButton submitText="Create Post" /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/ValidatedForm&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f1be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是我们的表单的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/1468435bff61485cf52ceee8b7bb8931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_77b2JMvDKejCWeMb5dtgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提交前的表格</p></figure><p id="adf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的截图中，我已经提交了没有填写一些字段的表格。你会注意到author字段有焦点样式，关于<code class="fe lr ls lt lu b">remix-validated-form</code>的好处是它会自动聚焦在第一个出错的字段上。当你点击一个字段或开始输入时，你会发现错误被清除了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/6fea1deb2f630438b4b8712489fd76f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmrtVn1_eZRhAJ-7WHFUFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">表单提交后</p></figure><h1 id="8e8f" class="mh ma iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">分解它</h1><p id="74e7" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们从上面的文件中分解每一部分，我们可以按照事情发生的顺序把它分解成3部分:</p><ul class=""><li id="9226" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">表单/zod验证程序</li><li id="e335" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">将提交给服务器的表单</li><li id="515a" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">然后是处理表单数据的服务器端操作</li></ul><p id="b8ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">zod-form-data</code>库为Zod提供了专门解析<code class="fe lr ls lt lu b">FormData</code>或<code class="fe lr ls lt lu b">URLSearchParams</code>的验证助手，这在使用<code class="fe lr ls lt lu b">remix</code>和<code class="fe lr ls lt lu b">remix-validated-form</code>时特别有用。它允许用户按照自己的意愿编写类型，从而简化了验证表单数据的过程。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="7d8a" class="lz ma iq lu b be mb mc l md me">const createPostSchema = zfd.formData({<br/>  title: zfd.text(z.string().min(1).max(100)),<br/>  author: zfd.text(z.string().min(1).max(50)),<br/>  content: zfd.text(z.string().min(1).max(1000)),<br/>  published: zfd.checkbox(),<br/>});<br/><br/>const createPostValidator = withZod(createPostSchema);</span></pre><p id="5003" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要做的就是使用<code class="fe lr ls lt lu b">remix-validated-form</code>库中的<code class="fe lr ls lt lu b">ValidatedForm</code>。从功能上来说，它非常类似于Remix <code class="fe lr ls lt lu b">Form</code>组件，只是增加了验证器，当然，在引擎盖下有神奇的事情发生，我鼓励你阅读他们的文档。</p><p id="6dac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还使用了几个包含错误处理的<code class="fe lr ls lt lu b">Input</code>组件，以及一个复选框和一个<code class="fe lr ls lt lu b">SubmitButton</code>组件。当用户填写表单时，首先在提交时，表单将在客户端进行验证，如果失败，我们将在输入中看到错误状态，但是，如果成功，表单数据将被传递到服务器，服务器将使用相同的验证模式验证表单数据。</p><p id="cdd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，在客户端和服务器上进行验证是有用的，因为有人试图恶意地向服务器提交虚假的表单数据，而您没有在服务器上进行适当的验证，那么您可能会遇到一些问题，您会在数据库中获得您不想要的数据。</p><p id="fb6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Remix最好的一点是，它使用服务器端和Remix Validated表单进行客户端和服务器端验证，即使您禁用了JavaScript，我们仍然会在提交时看到字段错误，因为操作会返回错误并使用操作数据重新混合页面！当然，当启用JavaScript时，Remix不需要重新加载整个页面来获得相同的结果。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="eed9" class="lz ma iq lu b be mb mc l md me">export default function () {<br/>  return (<br/>    &lt;div className="flex items-center justify-center<br/>      &lt;ValidatedForm<br/>        validator={createPostValidator}<br/>        className="flex flex-col space-y-4 w-10/12 lg:w-1/2"<br/>        method="post"<br/>      &gt;<br/>        &lt;Input name="title" title="Post Title" /&gt;<br/><br/>        &lt;Input name="author" title="Author" /&gt;<br/><br/>        &lt;Input name="content" title="Post Content" /&gt;<br/><br/>        &lt;div className="flex flex-row items-center"&gt;<br/>          &lt;label htmlFor="publish"&gt;Publish&lt;/label&gt;<br/>          &lt;input<br/>            type="checkbox"<br/>            id="publish"<br/>            name="publish"<br/>            className="ml-2 h-5 w-5"<br/>          /&gt;<br/>        &lt;/div&gt;<br/><br/>        &lt;div className="w-full flex justify-center items-center"&gt;<br/>          &lt;SubmitButton submitText="Create Post" /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/ValidatedForm&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b13f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当提交表单时，动作在服务器端运行，这里我们从请求中获取表单数据。我们将表单数据传递给验证器，验证器将根据我们定义的每个字段的验证来检查每个字段。如果有一个错误，那么我们用validationError来响应，这将在客户端处理。如果我们通过了错误步骤，我们可以确定我们有有效的数据。在这里，我只是析构数据，以证明我们确实拥有没有类型错误的有效数据，并在控制台记录这些数据。一般来说，从这里开始，您会想要将该数据插入到您的数据库或您可能有的任何用例中。</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="2d4e" class="lz ma iq lu b be mb mc l md me">export async function action({ request }: ActionArgs) {<br/>  const formData = await request.formData();<br/><br/>  const validation = await createPostValidator.validate(formData);<br/><br/>  if (validation.error) {<br/>    return validationError(validation.error);<br/>  }<br/><br/>  const { title, content, author, published } = validation.data;<br/><br/>  console.log("Creating Post...", { title, content, author, published });<br/>}</span></pre><p id="108a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面我们使用Zod的<code class="fe lr ls lt lu b">infer</code>函数，这是一个非常有用的工具，例如，如果你想创建一个函数，将数据插入到数据库中，你可以从表单模式中推断出函数的输入类型。下面是一个<code class="fe lr ls lt lu b">CreatePostType</code>的例子</p><pre class="kg kh ki kj gt lv lu lw bn lx ly bi"><span id="31a6" class="lz ma iq lu b be mb mc l md me">const createPostSchema = zfd.formData({<br/>  title: zfd.text(z.string().min(1).max(100)),<br/>  author: zfd.text(z.string().min(1).max(50)),<br/>  content: zfd.text(z.string().min(1).max(1000)),<br/>  published: zfd.checkbox(),<br/>});</span></pre><p id="69c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b93b09fd3654d1c91cc8bc544866f6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdepgtHKz3xMH8M9k8aQ8w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">z .推断魔法！</p></figure><p id="a880" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">获得正确的表单并提供积极的用户体验总是一个挑战，我已经使用Zod和这些库几个月了，我还没有找到比这些库更简单的类型、验证和健壮的解决方案。我也确信我只是刚刚接触到你可以用这些库做什么的皮毛。</p><p id="264e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我使用的软件包大喊大叫，请检查它们并阅读它们的文档:</p><ul class=""><li id="ce74" class="nd ne iq kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated"><a class="ae ns" href="https://www.npmjs.com/package/zod https://zod.dev/" rel="noopener ugc nofollow" target="_blank">佐德</a></li><li id="f2dd" class="nd ne iq kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated"><a class="ae ns" href="https://www.remix-validated-form.io/" rel="noopener ugc nofollow" target="_blank">混音验证表</a></li></ul><h2 id="689b" class="nt ma iq bd mi nu nv dn mm nw nx dp mq le ny nz ms li oa ob mu lm oc od mw oe bi translated"><strong class="ak">源代码</strong></h2><div class="of og gp gr oh oi"><a href="https://github.com/brandon-schabel/remix-typesafe-forms" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">GitHub-Brandon-schabel/remix-typesafe-forms</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">这是一个演示项目，演示了完整的端到端类型安全与混合形式。混合验证表单，zod…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div></div></div>    
</body>
</html>