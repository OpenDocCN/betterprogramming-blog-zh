<html>
<head>
<title>Spring Boot Caching From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot缓存从零开始</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spring-boot-caching-from-scratch-aaaf9717f407?source=collection_archive---------1-----------------------#2021-12-21">https://betterprogramming.pub/spring-boot-caching-from-scratch-aaaf9717f407?source=collection_archive---------1-----------------------#2021-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用EhCache进行缓存的亲身体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bdd420cf6c039d81ca33acd0f407ef9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNf2eVn0-h21WIikQul8Lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者设计</p></figure><p id="c523" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我将向大家介绍一种提高应用程序性能的最佳方法。我见过这么多的应用程序，但大多数时候，他们没有优化。</p><p id="9202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为开发人员，我们希望我们的应用程序提供出色的用户体验，因此我们需要采用各种技术来优化它们的速度和性能。</p><p id="17e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以今天的文章是关于将你的应用程序提升到一个新的水平。让我们从基础开始。</p><h1 id="92b9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.什么是缓存？</h1><p id="aaf9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">缓存基本上就是临时存储数据以备将来参考。</p><p id="935b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以便将来对该数据的请求能够比通过访问数据的主存储位置更快地得到满足。这就尽可能地减少了数据库命中的次数。</p><p id="cc07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缓存允许您有效地重用以前检索或计算的数据。</p><h1 id="1458" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.缓存的优势</h1><p id="61df" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们已经讨论了缓存的主要好处。这可以总结如下。</p><ul class=""><li id="7845" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu">提高应用性能</strong> —从内存缓存中读取数据速度极快。</li><li id="2245" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">改善体验质量</strong> —缓存可以显著改善内容提供商向消费者提供的体验质量(QoE)。</li><li id="bbc8" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">降低数据库命中率和成本</strong> —单个缓存实例可以提供数十万次IOPS(每秒输入/输出操作)，有可能取代大量数据库实例。</li><li id="10d4" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">降低网络成本</strong> —内容可以缓存在客户端和源之间网络路径的不同点上。当内容缓存在离客户端更近的地方时，请求将需要较低的网络活动。</li><li id="efdf" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">云托管中的成本效益</strong> —如果您在基于云的平台(如AWS)中部署应用程序，如果主数据库按吞吐量收费，您可以大幅降低成本。</li></ul><h1 id="5b83" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.缓存中的一般用例</h1><p id="f579" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">缓存系统的主要实际用途是将其应用到企业应用程序中。除此之外，缓存还有很多流行的用例。这里有一些例子。</p><ul class=""><li id="2682" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu">内容交付网络</strong>(CDN)——希望大家熟悉bootstrap CDN的。它通过在一组全球分布的缓存服务器上复制经常请求的文件，实际上改进了内容的交付。这就是CDN越来越受欢迎的原因。</li><li id="0f8f" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">游戏</strong> —我们都喜欢玩在线多人游戏。我们经常查看排行榜和玩家档案。<strong class="la iu"> </strong>所以有了数百万的游戏玩家，快速更新&amp;获取这样的数据变得极其重要。缓存也用于这个用例。</li><li id="b43d" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu"> RDBMS加速:</strong>当处理数百万行时，关系数据库变得非常慢。大量数据会降低数据库索引的速度。在这种情况下，可能许多“选择”查询或读取查询可以在外部缓存，至少在某个小时间窗口内。</li></ul><p id="33de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缓存可以实现到任何后端解决方案，如node.js、.net、Django等。我会选择Spring Boot，因为这是我个人的最爱。</p><h1 id="3cbf" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.Spring Boot缓存机制是如何工作的？</h1><p id="185c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在Spring中，<strong class="la iu">缓存抽象</strong>是一种机制，允许在对代码影响最小的情况下一致地使用各种缓存方法。我们可以将业务代码和缓存实现分开。</p><p id="1369" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种机制适用于Java方法。实际上，它用于昂贵的方法，如CPU或IO绑定。但是它可以通过缓存提供者进行高度定制。</p><p id="2452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次当一个方法调用时，抽象都会对该方法应用一个缓存行为。它检查该方法是否已经为给定的参数执行过。</p><ul class=""><li id="f8aa" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">如果是，则返回缓存的结果，而不执行实际的方法。</li><li id="e3ef" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">如果没有，首先执行方法，然后缓存结果并返回给用户。</li></ul><p id="11bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里你看到了一个词，“缓存提供者”。我知道你对此很好奇。</p><p id="cddd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Springs缓存服务是一个抽象，而不是一个实现。因此，有必要使用缓存提供者或缓存实现来进行缓存。</p><p id="6cf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在官方的spring boot文档中，它明确指定了spring支持的缓存提供者列表。</p><ol class=""><li id="e0b3" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt nf mx my mz bi translated">一般的</li><li id="4a74" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">JCache (JSR-107) (EhCache 3、Hazelcast、Infinispan等)</li><li id="13e2" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">EhCache 2.x</li><li id="0f85" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">黑泽尔卡斯特</li><li id="fd24" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">无限跨度</li><li id="5c2d" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">沙发底座</li><li id="66d2" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">雷迪斯</li><li id="7896" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt nf mx my mz bi translated">咖啡因</li></ol><p id="3147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这些选项都不可行，那么就配置一个使用<code class="fe ng nh ni nj b">ConcurrentHashMap</code>作为缓存存储的简单实现。如果spring boot应用程序中没有缓存库，这是默认设置。你可以从这里找到更多关于这些缓存的信息。</p><div class="nk nl gp gr nm nn"><a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-simple" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">33.贮藏</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Spring框架支持透明地向应用程序添加缓存。在其核心，抽象…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">docs.spring.io</p></div></div></div></a></div><p id="8223" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中，<strong class="la iu"> JCache </strong>是一个事实上的标准Java缓存API，用于缓存数据。它是一个规范，但不是一个实现。它的目的是为不同的技术创造一种方法来提供一个公共的缓存接口。这个通用接口使得软件开发人员能够更容易地利用各种技术，因为它不需要被重写来与另一种技术一起工作。他们所要做的就是将缓存库从一个供应商换到另一个供应商。任何实现JSR 107的技术都应该遵守规范中的要求。</p><p id="5751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么缓存提供者之间有什么不同呢？这是因为JSR规范中没有描述细节。如果没有特别提到需求，供应商可以自由地以自己的方式实现它。</p><p id="5cf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，该JSR规范没有描述数据应该如何存储在高速缓存中，也没有描述高速缓存中的数据应该如何被保护。所以像Ehcache、Hazelcast等缓存可以用自己的方式实现它。在本文中，我主要向您展示Ehcache，因为它是使用最广泛的基于Java的开源缓存。</p><h1 id="4f38" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.EhCache简介</h1><p id="8857" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Ehcache是Java缓存领域的先驱之一。Ehcache 3.9现已推出，它需要Java 8+。</p><p id="885c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Ehcache的主要特性:</p><ul class=""><li id="0334" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">快速且重量轻</li><li id="996c" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">可攀登的</li><li id="c806" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">灵活的</li><li id="4c9d" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">基于标准(JSR-107)</li><li id="bd4c" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">可扩张的</li><li id="2fe1" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">分布式缓存</li><li id="68c8" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">开源许可</li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="c5a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧！我相信您对缓存已经有了清晰的了解。让我们进入实现阶段。</p><p id="91fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以创建一个虚拟项目来测试这一点。在这里，我开发了一个用户管理系统来演示这些东西。</p><blockquote class="od oe of"><p id="f576" class="ky kz og la b lb lc ju ld le lf jx lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la iu">重要的</strong>:我将从头开始实现这一点。如果您只想将Eh-cache添加到您当前的系统中，请跳到第6节</p></blockquote><p id="affd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你熟悉创建一个新的spring boot项目。你可以使用<a class="ae ok" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> spring initializr </a>或者直接从IntelliJ Idea中创建。我会用我最喜欢的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/0f884827afbf965b80ccf4fc7b27e32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0uLnfXI2PZxHRCLQcbF_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用spring initializr创建一个新项目(图片由作者提供)</p></figure><p id="4acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保添加这些依赖项，因为它们是我们的应用程序的核心依赖项。</p><ul class=""><li id="ffdb" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu"> Spring Web </strong> —构建REST API</li><li id="07de" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu"> MySQL驱动</strong> —连接MySQL数据库</li><li id="31e8" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">Spring Data JPA</strong>——更容易实现持久层</li></ul><p id="c429" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个用户模型、用户存储库、用户服务和用户控制器类来使我们的系统工作。因此，我们的项目将如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d433f318b59dd2b0332e9552228b5a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*LFZN8cTtoXiyKaOG_To24g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目结构(图片由作者提供)</p></figure><p id="be38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ng nh ni nj b">application.properties</code>文件中，我们需要定义我们的应用配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6724" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在MySQL配置中，我将数据库命名为ums，并在MySQL数据库中预先创建了该数据库。</p><p id="a55d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在用户模型中，我创建了4个变量。您可以根据自己的意愿定义任意数量的变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6516" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们必须实现serializable类，因为EhCache是一个Java缓存，它不能总是将其映射存储为Java对象。</p><p id="7a51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要添加getters和setters来访问这些值。然后我们需要创建一个用户存储库来获取我们的数据。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="05bc" class="ot lv it nj b gy ou ov l ow ox">@Repository<br/>public interface UserRepository extends JpaRepository&lt;User, Integer&gt;{<br/>}</span></pre><p id="f875" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需用一个CURD或JPA库进行扩展，这就足够我们测试了。然后是服务层。我上了两节课。一个用于初始数据加载过程，另一个用于获取数据。</p><p id="b4db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是数据加载器类，当应用程序启动时，它会将一些数据预加载到我们的数据库中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4111" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务类中，我添加了一个名为<code class="fe ng nh ni nj b">getAllUsers</code>的方法来获取所有用户。</p><blockquote class="od oe of"><p id="66ac" class="ky kz og la b lb lc ju ld le lf jx lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">注意:</em> </strong>出于安全原因以及抽象原则，最好使用服务类的接口及其实现。但是在这里，我不会这样做，因为为了保持演示的简单性。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a330" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在用户控制器类中，我们定义REST API来获取用户列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a4c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧。我们的简单应用程序现在已经准备好了。让我们运行一下，检查一下是否一切正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/9c4d64afd99fcb65217bbffd895b3d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKAqjupRoei3UG0te1HDhA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试应用程序(图片由作者提供)</p></figure><p id="6ad0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，我们的服务器运行正常。现在是最好的部分。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="0dc8" class="lu lv it bd lw lx oz lz ma mb pa md me jz pb ka mg kc pc kd mi kf pd kg mk ml bi translated">6.缓存实现</h1><h2 id="b03f" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">添加Spring Boot缓存依赖项</h2><p id="3cc6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了给spring boot添加缓存机制，我们需要添加spring boot默认缓存。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="928c" class="ot lv it nj b gy ou ov l ow ox">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><h2 id="c821" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">添加EhCache依赖项</h2><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="ac7d" class="ot lv it nj b gy ou ov l ow ox">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;<br/>    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;<br/>    &lt;version&gt;3.9.6&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;javax.cache&lt;/groupId&gt;<br/>    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;<br/>    &lt;version&gt;1.1.0&lt;/version&gt;<br/>    &lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="57d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还必须添加<code class="fe ng nh ni nj b">cache-api</code>库，这允许我们使用实现<a class="ae ok" href="https://www.jcp.org/en/jsr/detail?id=107" rel="noopener ugc nofollow" target="_blank"> JSR-107 </a>的缓存库。</p><h2 id="b3d5" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">添加EhCache配置</h2><p id="4e13" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果使用EhCache v3，则需要JCache和EhCache。在以前的版本2中，不需要JCache，因为它不是基于JSR标准构建的。</p><p id="afc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧。现在我们需要在resources文件夹中创建EhCache XML配置文件。(类路径)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/fb1e331875581527ac9bc0bccec2ac4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*U5EWmsG9j4X1qcC2pFUOVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">EhCache XML文件位置(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="fe9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们必须定义缓存。<code class="fe ng nh ni nj b">alies</code>代表我们缓存的名称。</p><blockquote class="pq"><p id="6505" class="pr ps it bd pt pu pv pw px py pz lt dk translated">基本上，缓存是键值存储。</p></blockquote><p id="1c11" class="pw-post-body-paragraph ky kz it la b lb qa ju ld le qb jx lg lh qc lj lk ll qd ln lo lp qe lr ls lt im bi translated">因为缓存是键值存储，所以每次调用缓存的方法都需要转换成适合缓存访问的键。所以我们需要提供键类型和值类型。如果我们没有定义一个键，Spring Boot默认键将被分配。</p><p id="9249" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为Spring boot使用参数来定义缓存值的键，所以我们必须从<code class="fe ng nh ni nj b">org.springframework.cache.interceptor.SimpleKey</code>中改变<code class="fe ng nh ni nj b">ehcache.xml</code>中的键类型</p><p id="2b23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个配置文件中，我们正在创建一个名为<code class="fe ng nh ni nj b">tasks</code>的缓存，它将能够存储任何类型的<code class="fe ng nh ni nj b">List</code>，并将它缓存30秒。我们可以使用生存时间(ttl)属性来更改这个时间。</p><p id="6d81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在resources标签中，我们配置缓存的层和容量。我在这里使用两层缓存。</p><ul class=""><li id="dcdb" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu">堆存储</strong>:使用Java堆内存来存储缓存条目，并与应用程序共享内存。垃圾收集也会扫描缓存。这种记忆很快，但也很有限。这里我只允许堆上有10个条目。当空间已满时，将会发生驱逐。</li><li id="c80a" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">堆外存储</strong>:使用RAM存储缓存条目。该内存不受垃圾收集的影响。仍然是相当快的内存，但是比堆上内存慢，因为缓存条目在使用之前必须移动到堆上内存。这里我只允许10 MB的堆外空间。</li></ul><p id="1432" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们应该在<code class="fe ng nh ni nj b">application.properties</code>文件中给出这个文件的路径。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="39cb" class="ot lv it nj b gy ou ov l ow ox">spring.cache.jcache.config=classpath:ehcache.xml</span></pre><p id="2ef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还需要通过使用<code class="fe ng nh ni nj b">@EnableCaching</code>注释在spring boot应用程序类中显式启用cashing。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/e603a1e13eba9831c1d6ed18b019a090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_FAqrI1rFObRxJbiNrvYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用缓存(按作者分类的图像)</p></figure><h2 id="3fc9" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">缓存实现</h2><p id="72a4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们看看如何在服务层实现cash to one方法。</p><p id="4f63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有4种主要的注释可以用来实现缓存系统。让我们逐一探索。</p><p id="1b29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ng nh ni nj b">@Cacheable</code> —这是非常基本的注释，它表明调用方法的结果可以被缓存。</p><p id="07f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将首先查询是否有缓存的数据。如果找到，直接返回原来的缓存数据。如果没有，请再次执行该方法，并将该方法的返回结果放入缓存中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/18137e7c628d95e56ba844592b4260ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqZNB6EqHjip3PchXBDG4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可缓存的注释(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="bcbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们使用一个静态键作为“allUser ”,每次我们调用这个方法，我们都会得到相同的键。</p><p id="c53b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">密切关注<code class="fe ng nh ni nj b">"'customerList'"</code>。我用单引号将它转义，否则你会得到一个<code class="fe ng nh ni nj b">org.springframework.expression.spel.SpelEvaluationException</code></p><p id="10bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个特殊的表达方式，单引号使它再次成为一个<code class="fe ng nh ni nj b">String</code>。</p><p id="0e2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用这个依赖注入来检查当前运行的缓存提供者。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="bdf0" class="ot lv it nj b gy ou ov l ow ox">@Autowired<br/>private CacheManager cacheManager;</span></pre><p id="7d36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打印它的值会给当前的缓存提供者。如果EhCache设置不正确，您可能会将并发缓存视为默认cash。所以检查一下，确保你运行的是EhCache。</p><h1 id="5030" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">7.在活动</h1><p id="ba65" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在是时候测试我们的应用程序了。</p><p id="dc20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行应用程序，然后打开浏览器或postman应用程序，并在端口7000上访问REST服务。</p><p id="9929" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们转到<a class="ae ok" href="http://localhost:7000/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:7000/API/users</a><em class="og">，</em>，那么我们将返回<em class="og"> </em>用户列表。一次又一次地检查，看看我们的缓存是否正常工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/cd3198bb770a21343c4a6f93d6735030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAtEIdKIWcOezJf8U5TMtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">邮递员结果(图片由作者提供)</p></figure><p id="04af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以检查打印语句，以了解缓存是否在工作。当您执行一个请求时，控制器将处理该请求。因此，首先它将收到的请求打印到控制器语句中。然后它将调用服务类来获取结果。</p><p id="30e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果结果在缓存中，它将不会执行该方法，而是返回缓存中的结果。如果数据不在缓存中，它将打印<code class="fe ng nh ni nj b">Getting All the users from DB! | Not Cached</code>语句。因此，您将看到，只有在第一次请求时，它才会执行服务方法，其他时候，它会从缓存中返回数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/d08db064703c2acedc56077169f6a777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpPxlrsMY85gsRsO_fVMsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿色勾号代表缓存的，红色叉号代表未缓存的响应(图片由作者提供)</p></figure><blockquote class="od oe of"><p id="7020" class="ky kz og la b lb lc ju ld le lf jx lg oh li lj lk oi lm ln lo oj lq lr ls lt im bi translated">注意:这样做只是为了演示，除非我们需要为我们的应用程序添加一个合适的日志系统。(希望您也意识到log4j漏洞:)</p></blockquote><p id="2279" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我为ttl和max堆类型定义了一些规则。如果这些一旦超过，它将再次从数据库中获得结果。</p><p id="0f87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以测量每个请求所用的时间，并分析我们的缓存如何优化应用。</p><p id="269f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">邮递员缓存DNS。所以我们的测试可能会有偏差。这次可以用简单的旋度代替那个来过牌。此外，您可以从任何浏览器查看它。(使用匿名/私人模式)</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="d0dd" class="ot lv it nj b gy ou ov l ow ox">curl -o /dev/null -s -w 'Total: %{time_total}s\n\n'  <a class="ae ok" href="http://localhost:7000/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:7000/api/users</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/ca2272a6da183018a1128fcbd7d4ab71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nDEWz4rhPTHsURVWYfTug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">响应时间(图片由作者提供)</p></figure><p id="a254" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平均响应时间，</p><ul class=""><li id="24dc" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">无缓存— 15毫秒</li><li id="0ade" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">带缓存— 5毫秒</li></ul><p id="f179" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">x3中的时间减少了。看，多神奇啊！</p><p id="4f53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在讨论其他注释之前，我将展示一个带有<code class="fe ng nh ni nj b">cacheable</code>注释的例子。假设我们需要找到一个特定的用户。如何缓存它？</p><p id="8341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务类中，让我们定义方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4ae3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里你可以看到两个新的字段被注入到<code class="fe ng nh ni nj b">cacheable</code>注释中。Key表示唯一的键，值将是我们缓存的名称。</p><p id="b530" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在控制器中，我们需要定义新的API端点。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="d0a4" class="ot lv it nj b gy ou ov l ow ox">@GetMapping(path = "/users/{id}")<br/>public User getUser(@PathVariable int id) {<br/>    System.<em class="og">out</em>.println("Request received to the controller");<br/>    return userService.searchUser(id);<br/>}</span></pre><p id="be72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们必须定义缓存。在<code class="fe ng nh ni nj b">ehcache.xml</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5a27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以给值类型作为用户对象。让我们看看它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/b7ae03de450ee66eaacf58b07939a69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nS5mPJGudPM40ome4P-fqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从缓存中查找特定用户(图片由作者提供)</p></figure><h1 id="7078" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8.其他注释</h1><h2 id="29e4" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">8.1缓存</h2><p id="6a58" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">用于更新缓存的值。让我们看看下面的场景来理解缓存器。</p><p id="57b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们向系统添加一个新用户后，由于缓存机制的原因，它可能仍然会获得旧的用户列表。为了解决这个问题，我们需要在更新记录后通知缓存记录发生了变化。因此，我们需要在创建或更新记录时添加缓存put。</p><p id="539f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们实际地看待问题和解决方案。</p><p id="f13f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在控制器类中:</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="445e" class="ot lv it nj b gy ou ov l ow ox">@PostMapping("/register")<br/>public User createUser(@RequestBody User user) {<br/>    System.<em class="og">out</em>.println("Request received to the controller");<br/>    return userService.addNewUser(user);<br/>}</span></pre><p id="6476" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务类别中:</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="6392" class="ot lv it nj b gy ou ov l ow ox">public User addNewUser(@RequestBody User user) {<br/>    System.<em class="og">out</em>.println("Registering the new user");<br/>    return userRepository.save(user);<br/>}</span></pre><p id="c10a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们像这样为用户注册添加一个新的端点，那么在检索用户时就会遇到问题。之前我们创建了启用缓存的<code class="fe ng nh ni nj b">getUserList</code>方法。因此它将从缓存中获取用户。当我们在数据库中添加一条新记录时，缓存不会注意到它并返回先前缓存的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/1a348686d4ec5e05c9ae65706b583e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZQB7AarjKbvVwKU4uDRIdg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户注册后，新用户列表不会更新(GIF by Author)</p></figure><p id="93f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们需要通知缓存。这就是为什么我们需要<code class="fe ng nh ni nj b">CachePut</code>让我们看看解决方案。</p><p id="b45f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要向方法添加注释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ebe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你要记住的一点是，键值应该和前面的<code class="fe ng nh ni nj b">getAllUser</code>方法一样。<code class="fe ng nh ni nj b">getAllUser</code>方法返回一个用户列表，所以我们需要使这个方法返回相同的返回类型。</p><p id="61d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于演示的目的，我使用了这种实现。但是在实践中，我们不会为了得到这么长的列表而增加缓存。(<code class="fe ng nh ni nj b">getAllUser</code>方法)您不应该返回整个值集合，因为这会降低性能。您必须考虑分页概念。</p><p id="df5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们将数据放入现有的缓存中时，<code class="fe ng nh ni nj b">ehcache.xml</code>文件没有任何变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qm"><img src="../Images/eff1ae18e91b0e30873a2380237352a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nVtPv7uC2j8bQAF-DEbgXQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现缓存后(作者提供的GIF)</p></figure><h2 id="908d" class="ot lv it bd lw pe pf dn ma pg ph dp me lh pi pj mg ll pk pl mi lp pm pn mk po bi translated">8.2缓存收回</h2><p id="0402" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">删除记录时，缓存中仍可能有缓存的值。所以我们需要在删除一条记录后从缓存中删除相关的值。缓存收回用于此目的。它可以从缓存中移除一条或多条数据。</p><p id="67dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是服务类中的缓存收回实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="aa52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该值指定了我们引用的缓存，使用<code class="fe ng nh ni nj b">allEntries=true</code>，我们可以清除整个缓存。</p><p id="1211" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，还可以基于特定的键来驱逐值。你可以试试</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="7f17" class="ot lv it nj b gy ou ov l ow ox">@CacheEvict(value = "first", key = "#cacheKey")</span></pre><p id="eafc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将根据键删除值。</p><p id="ee4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">控制器类如下所示。</p><pre class="kj kk kl km gt op nj oq or aw os bi"><span id="5904" class="ot lv it nj b gy ou ov l ow ox">@DeleteMapping(path = "/users/{id}")<br/>public boolean removeUser(@PathVariable int id) {<br/>    System.<em class="og">out</em>.println("Request received to the controller");<br/>    return userService.removeUser(id);<br/>}</span></pre><p id="b77b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您现在可以看到它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qm"><img src="../Images/464972cf1bdcedab980025f07cf9666f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BOZ3GLjWu16KQ3H5Kq59jg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CacheEvict演示(GIF由作者提供)</p></figure><p id="5479" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想我给你带来了缓存中最重要的部分。然而，这个旅程不会随着这篇文章而结束。我们需要深入挖掘，以获得更多关于缓存的知识。我计划为您带来下一篇基于缓存侦听器和条件缓存的文章。在此之前，请仔细阅读这段代码，并尝试进行各种更改。然后你会感受到缓存的力量。</p><h1 id="e7f1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">资源</h1><p id="c24f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我的GitHub存储库中有完整的代码实现:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/Yasas4D/UserManagementSystem" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">GitHub-yasas 4d/用户管理系统:Spring Boot缓存</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">一个演示缓存实现的基本用户管理系统。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="qn l"><div class="qo l qp qq qr qn qs ks nn"/></div></div></a></div><h1 id="f8fc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="b6ab" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在本文中，您了解了缓存的核心概念，并从头开始为spring boot应用程序实现了一种缓存机制。</p><p id="8989" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！我希望这篇文章对你有所帮助。如果有任何问题、意见或建议，请随时联系我。<br/>快乐编码！</p></div></div>    
</body>
</html>