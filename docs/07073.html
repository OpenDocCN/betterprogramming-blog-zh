<html>
<head>
<title>How to Build a Concurrent Chat App With Golang and WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang和WebSockets构建并发聊天App</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-concurrent-chat-app-with-golang-and-websockets-fb48562a1329?source=collection_archive---------0-----------------------#2020-12-04">https://betterprogramming.pub/how-to-build-a-concurrent-chat-app-with-golang-and-websockets-fb48562a1329?source=collection_archive---------0-----------------------#2020-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Go构建实时聊天应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01b6316fb321ba61ee10ecde40814eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wpOOTASrxvDF41sA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mr_fresh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yura Fresh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="35e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>出现于谷歌，出于使用易于理解的语法构建高性能应用程序的需要。它是一种静态类型的编译语言，由C的一些创新者开发，没有手动内存管理的编程负担。首先，它被设计成利用现代多核CPU和网络机器。</p><p id="222c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将展示Go的能力。我们将利用Go轻松创建并发应用的能力来构建一个聊天应用。在后端，我们将使用<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>作为中介接受来自浏览器的消息，并将它们发送给订阅的客户端。在前端，我们将通过<a class="ae ky" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>使用WebSockets来促进客户端通信。我们将把它全部部署在Heroku上，这是一个PaaS提供商，可以轻松部署和托管您的应用。就像Go使编程这样的应用程序变得简单一样，Heroku使用额外的基础设施来补充它变得容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Go中的频道</h1><p id="f35c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员发现Go的吸引力在于它的并发通信能力，这是通过一个叫做<em class="mz">通道</em>的系统实现的。利用经常被引用的<a class="ae ky" href="https://blog.golang.org/waza-talk" rel="noopener ugc nofollow" target="_blank">并发性和</a>并行性之间的区别很重要。<em class="mz">并行性</em>是CPU同时执行多个任务的过程，而<em class="mz">并发性</em>是CPU在相互重叠的同时开始、运行和完成的多个任务之间切换的能力。换句话说，并行程序一次处理许多操作，而并发程序可以在同一时间内在许多操作之间切换。</p><p id="feea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go中的一个<em class="mz">通道</em>是并发性流动的管道。通道可以是单向的(数据由通道发送或接收),也可以是双向的(两者兼有)。下面的示例演示了并发性和通道的基本原则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="546f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在<a class="ae ky" href="https://play.golang.org/p/_FKRgsC7ptB" rel="noopener ugc nofollow" target="_blank"> Go游乐场</a>在线运行此示例，查看结果。通道是通过首先指定它们将与之通信的数据类型来创建的——在本例中是<code class="fe nc nd ne nf b">string</code>。两个<a class="ae ky" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank">go routine</a>、<code class="fe nc nd ne nf b">one</code>和<code class="fe nc nd ne nf b">two</code>接受这些通道中的每一个作为参数。然后两者循环五次，将消息传递给通道，这由<code class="fe nc nd ne nf b">&lt;-</code>符号表示。同时，在主函数中，一个无限的<code class="fe nc nd ne nf b">for</code>循环等待来自通道的消息。<code class="fe nc nd ne nf b">select</code>语句选择有未决消息的通道，打印它，然后继续前进。如果通道被关闭(这不仅对内存管理很重要，而且表明不再发送数据)，通道被设置为<code class="fe nc nd ne nf b">nil</code>。当两个通道都是<code class="fe nc nd ne nf b">nil</code>时，环路中断。</p><p id="6b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上说，接收者无休止地等待接收数据包。当它收到数据时，它对数据进行操作，然后继续等待更多的消息。这些接收器同时运行，不会中断程序流的其余部分。对于这个聊天应用程序，我们将等待用户通过通道向接收者发送消息。当收到消息时，应用程序会将它广播到前端，以便每个坐在聊天中的人都可以阅读文本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="9896" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您应该安装了Golang的一个相对较新的版本；1.12以上的都可以。在您的<a class="ae ky" href="https://golang.org/doc/gopath_code.html" rel="noopener ugc nofollow" target="_blank"> GOPATH </a>中创建一个名为<code class="fe nc nd ne nf b">heroku_chat_sample</code>的目录。如果您想在本地运行代码，您也可以安装并运行一个Redis服务器——但这肯定不是必需的，因为Heroku插件将在生产中为我们提供这一功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f708" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建一个简单的服务器</h1><p id="7ff8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从一个快速简单的“Hello World”服务器开始，来验证我们可以运行Go程序。我们将从获取<a class="ae ky" href="https://www.gorillatoolkit.org/" rel="noopener ugc nofollow" target="_blank"> Gorilla </a>开始，这是一个web工具包，它简化了编写HTTP服务器的过程:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4259" class="nk md it nf b gy nl nm l nn no">go get -u github.com/gorilla/mux</span></pre><p id="9b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个名为<code class="fe nc nd ne nf b">main.go</code>的文件，并将这些行粘贴到其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="32ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在你的终端中输入<code class="fe nc nd ne nf b">go run main.go</code>。您应该能够在浏览器中访问localhost:4444并看到问候语。通过这几行代码，我们可以更好地理解如何使用Gorilla创建路线。</p><p id="4c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是静态文本很无聊吧？让这个服务器显示一个HTML文件。创建一个名为<code class="fe nc nd ne nf b">public</code>的目录，并在其中创建一个名为<code class="fe nc nd ne nf b">index.html</code>的文件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个页面需要一些JavaScript来与服务器通信；现在让我们创建一个占位符<code class="fe nc nd ne nf b">app.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="10fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们将服务器代码更改为如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您重启服务器并返回到localhost:4444，您应该会看到一个邀请您聊天的页面。它还不会做太多，但它是一个开始！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/6f61cd79e355152d9c89517af6172394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IcbhsirX2X3is1Yh.png"/></div></div></figure><p id="2b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再做一个小小的改变，看看这个应用程序如何成为<a class="ae ky" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">一个十二因素应用程序</a>:将我们的端口号存储在一个环境变量中。这在目前的开发中不会非常重要，但当我们将应用程序部署到生产中时，它会有所不同。</p><p id="f13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe nc nd ne nf b">.env</code>的文件，并将这一行粘贴到其中:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="bdb3" class="nk md it nf b gy nl nm l nn no">PORT=4444</span></pre><p id="bd8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，获取<a class="ae ky" href="https://github.com/joho/godotenv" rel="noopener ugc nofollow" target="_blank"> godotenv </a>模块:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="b81d" class="nk md it nf b gy nl nm l nn no">go get github.com/joho/godotenv</span></pre><p id="4fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们再次更改服务器代码，以接受这个环境变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，只要<code class="fe nc nd ne nf b">GO_ENV</code>是空的，我们将从<code class="fe nc nd ne nf b">.env</code>中本地定义的任何地方加载我们的环境变量。否则，应用程序希望环境变量由系统设置，我们将在时机成熟时进行设置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="969e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用WebSockets和Redis建立通信</h1><p id="ad90" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>是一种从客户端/浏览器向服务器传递消息的有用技术。它将成为我们聊天室中所有用户发送和接收聊天信息的基本技术。在后端，我们将使用Redis来存储聊天历史，这样任何新用户都可以立即获得房间中所有以前的消息。Redis是一个内存数据库，通常用于缓存。对于这个项目，我们不需要关系数据库的重量，但是我们需要某种存储系统来跟踪用户和他们的消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="61b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">建立Redis</h1><p id="5de0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们准备引入Redis作为依赖项。如果您在本地运行Redis，您需要添加一个新行来指定您的Redis实例在您的<code class="fe nc nd ne nf b">.env</code>文件中的主机和端口:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="2e5f" class="nk md it nf b gy nl nm l nn no">REDIS_URL=127.0.0.1:6379</span></pre><p id="9555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从GitHub获取Redis模块作为依赖项:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="5586" class="nk md it nf b gy nl nm l nn no">go get -u github.com/gomodule/redigo/redis</span></pre><p id="dba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把我们的Redis客户机设置为一个全局变量，以使工作更容易:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="a89c" class="nk md it nf b gy nl nm l nn no">var (<br/> rdb *redis.Client<br/>)</span></pre><p id="9016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在我们的<code class="fe nc nd ne nf b">main()</code>函数中，我们将通过环境变量创建这个客户机的一个实例:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="f6fc" class="nk md it nf b gy nl nm l nn no">redisURL := os.Getenv(“REDIS_URL”)<br/>opt, err := redis.ParseURL(redisURL)<br/>if err != nil {<br/> panic(err)<br/>}<br/>rdb = redis.NewClient(opt)</span></pre><p id="be67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用环境变量，因为服务器地址可能与我们在开发中使用的不同，但是我们不想硬编码这些值。如果你没有在本地运行的Redis服务器，不要担心——在我们将应用程序发布到Heroku后，你仍然可以跟随教程并在浏览器中实时查看结果。</p><p id="d329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当服务器启动时，它会先连接到Redis，然后再监听任何传入的连接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1dfc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置WebSockets</h1><p id="d240" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">配置我们的WebSockets有点棘手，特别是因为我们需要跳转到一些JavaScript代码来完成连接。然而，在我们到达那里之前，让我们后退一步，记住我们正在努力做什么。用户将访问网页，给自己分配一个用户名，并在聊天室发送消息。公平地说，最小的数据块是用户的名字和他们的信息。让我们在Go中建立一个数据结构来捕捉这一点:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="2523" class="nk md it nf b gy nl nm l nn no">type ChatMessage struct {<br/> Username string`json:”username”`<br/> Text string`json:”text”`<br/>}</span></pre><p id="74e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将与前端进行通信，所以准备考虑这个结构在JSON中的表示方式是很有用的。</p><p id="9195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们在<code class="fe nc nd ne nf b">main()</code>中为我们的web服务器添加两行功能。第一行将指出每当一个新的WebSocket连接打开时，我们希望运行哪个函数——换句话说，每当一个新用户加入时。第二行将设置一个长期运行的goroutine，它决定每当用户发送消息时做什么:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="45d4" class="nk md it nf b gy nl nm l nn no">http.HandleFunc(“/websocket”, handleConnections)<br/>go handleMessages()</span></pre><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们跳回到文件的顶部，添加一些全局变量。我们将在代码后解释它们的用途:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="e277" class="nk md it nf b gy nl nm l nn no">var clients = make(map[*websocket.Conn]bool)<br/>var broadcaster = make(chan ChatMessage)<br/>var upgrader = websocket.Upgrader{<br/>CheckOrigin: func(r *http.Request) bool {<br/> returntrue<br/>},<br/>}</span></pre><p id="7cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些行中:</p><ul class=""><li id="759d" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">clients</code>是所有当前活动客户端(或打开的WebSockets)的列表。</li><li id="6f02" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">broadcaster</code>是一个单通道，负责发送和接收我们的ChatMessage数据结构。</li><li id="f9e1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe nc nd ne nf b">upgrader </code>有点老爷车；有必要将Gorilla的传入请求“升级”为WebSocket连接。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">表达重要意思</h1><p id="7034" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们先开始建造<code class="fe nc nd ne nf b">handleConnections</code>。当一个新用户加入聊天时，会发生三件事:</p><ol class=""><li id="3510" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated">它们应该被设置为接收来自其他客户端的消息。</li><li id="b5a7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">他们应该能够发送自己的信息。</li><li id="1bc0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">他们应该收到以前聊天的完整历史记录(由Redis支持)。</li></ol><p id="5695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Gorilla解决第一个问题很简单。我们将创建一个新的客户端，并将其添加到我们的全球<code class="fe nc nd ne nf b">clients</code>列表中，只需几行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们看看如何发送消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="85a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在客户端WebSocket被打开并添加到<code class="fe nc nd ne nf b">clients</code>池之后，无限的<code class="fe nc nd ne nf b">for</code>循环将无休止地运行。与其他语言不同，Go实际上鼓励无限循环。诀窍是记得摆脱它们，并在你摆脱它们的时候清理干净。这里，WebSocket只是不停地寻找客户端发送的消息:<code class="fe nc nd ne nf b"> ws.ReadJSON(&amp;msg)</code>正在检查<code class="fe nc nd ne nf b">msg</code>是否被填充。如果<code class="fe nc nd ne nf b">msg</code>不是<code class="fe nc nd ne nf b">nil</code>，它会将消息发送到广播频道。就发送信息而言，差不多就是这样了。如果这个WebSocket后来出现了问题，它会将自己从客户端池中删除——删除<code class="fe nc nd ne nf b">(clients, ws)</code>,然后退出这个循环，切断它的连接。</p><p id="4f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe nc nd ne nf b">msg</code>被发送到广播频道时会发生什么？这就是<code class="fe nc nd ne nf b">handleMessages</code>的用武之地。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">接收消息</h1><p id="e336" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">向每个连接的客户端发送新消息是<code class="fe nc nd ne nf b">handleMessages</code>的职责。就像发送消息一样，这一切都始于一个无限的<code class="fe nc nd ne nf b">for</code>循环:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="5d91" class="nk md it nf b gy nl nm l nn no">func handleMessages() {<br/> for {<br/>   // grab any next message from channel<br/>   msg := &lt;-broadcaster<br/> }<br/>}</span></pre><p id="aefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行什么也不做，直到有东西被发送到通道。这是goroutines、并发性和通道的核心。并发性依赖于通道之间的相互通信。如果没有数据被发送，就没有理由或工作。当收到一个<code class="fe nc nd ne nf b">msg</code>时，我们可以将它发送给所有打开的<code class="fe nc nd ne nf b">clients</code>:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="c9c8" class="nk md it nf b gy nl nm l nn no">for client := range clients {<br/> err := client.WriteJSON(msg)<br/> if err != nil &amp;&amp; unsafeError(err) {<br/>   log.Printf(“error: %v”, err)<br/>   client.Close()<br/>   delete(clients, client)<br/> }<br/>}</span></pre><p id="66ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用范围操作符迭代每个<code class="fe nc nd ne nf b">client</code>;对于每个<code class="fe nc nd ne nf b">client</code>，我们不是读取JSON，而是将它写出来。同样，接下来的事情是在JavaScript方面处理的。如果这个写操作有问题，我们将打印一条消息，关闭<code class="fe nc nd ne nf b">client</code>，并将其从全局列表中删除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f84" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保存和恢复历史</h1><p id="09e0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但是我们的最后一个功能是什么呢？它要求每个新的<code class="fe nc nd ne nf b">client</code>都可以访问完整的聊天记录。为此，我们需要使用Redis，特别是在两个操作中:</p><ol class=""><li id="200b" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated">任何新消息都应该被添加到正在运行的消息列表中。</li><li id="e80b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">任何新用户都应该收到完整的列表。</li></ol><p id="2033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发送新消息时，我们可以使用<code class="fe nc nd ne nf b"><a class="ae ky" href="https://redis.io/commands/rpush" rel="noopener ugc nofollow" target="_blank">RPUSH</a></code>将它们作为列表存储在Redis中:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="cfd4" class="nk md it nf b gy nl nm l nn no">rdb.RPush(“chat_messages”, json)</span></pre><p id="1438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当新用户加入时，我们可以使用<code class="fe nc nd ne nf b"><a class="ae ky" href="https://redis.io/commands/lrange" rel="noopener ugc nofollow" target="_blank">LRANGE</a></code>一次发送整个列表:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="32a6" class="nk md it nf b gy nl nm l nn no">chatMessages, err := rdb.LRange(“chat_messages”, 0, -1).Result()<br/>if err != nil {<br/> panic(err)<br/>}</span></pre><p id="0478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个应用程序有点棘手，因为我们需要将所有消息发送给一个客户端。然而，我们可以假设只有新的连接调用<code class="fe nc nd ne nf b">handleConnections</code>，在无限for循环之前的任何时候，我们都可以与这个<code class="fe nc nd ne nf b">client</code>通信，并向他们发送我们的消息。我们的代码应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3837" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整的后端代码</h1><p id="c76f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">他就是我们完整的围棋代码的样子:<a class="ae ky" href="https://gist.github.com/gjtorikian/8894dec140a6e57934572f5b447f6d51" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/gjtorikian/8894 dec 140 a6e 57934572 F5 b 447 F6 d 51</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f86a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前端</h1><p id="3fd0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于本文主要关注Go和Heroku，所以我们不会详细讨论JavaScript代码。不过也就25行左右，就不多赘述了！</p><p id="f18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前的<code class="fe nc nd ne nf b">index.html</code>可以保持原样。让我们把<code class="fe nc nd ne nf b">app.js</code>的内容替换成以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="be20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它分成几块。第一行(<code class="fe nc nd ne nf b">let websocket</code>和<code class="fe nc nd ne nf b">let room</code>)只是设置了一些我们稍后可以使用的全局变量。</p><p id="2350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">websocket.addEventListener</code>负责处理<code class="fe nc nd ne nf b">client</code>收到的任何新消息。换句话说就是<code class="fe nc nd ne nf b">handleMessages</code>对应的前端代码。当<code class="fe nc nd ne nf b">handleMessages</code>写JSON时，它将它作为一个名为<code class="fe nc nd ne nf b">message</code>的事件发送。从那里，JavaScript可以解析出数据，对其进行一些样式化，并将文本添加到聊天室中。</p><p id="cd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，表单逻辑使用WebSockets发送数据到我们前面的<code class="fe nc nd ne nf b">ws.ReadJSON line</code>。任何时候提交表单，JavaScript都会记录下谁说了什么以及他们说了什么。然后，它将消息发送到WebSocket，以便Go代码可以将它存储在Redis中，并通知所有客户端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="95a7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署到Heroku</h1><p id="eac9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您现在可以将此应用程序部署到Heroku了！如果你还没有，一定要在Heroku 上创建一个<a class="ae ky" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank">免费账户，然后安装</a><a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku CLI </a>，这使得创建应用程序和附加组件变得更加容易。</p><p id="8ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，登录您的帐户:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="f65f" class="nk md it nf b gy nl nm l nn no">heroku login</span></pre><p id="078c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用create创建一个新的应用程序:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="52d5" class="nk md it nf b gy nl nm l nn no">heroku create</span></pre><p id="dd76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会被分配一个随机的名字；我有evening-wave-98825，所以我将在这里引用它。</p><p id="6c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个<a class="ae ky" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank"> Procfile </a>。Procfile指定应用程序启动时要运行的命令，以及设置任何工作线程。</p><p id="0905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的将是一条线:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="23e8" class="nk md it nf b gy nl nm l nn no">web: bin/heroku_chat_sample</span></pre><p id="2f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们需要Redis，我们可以为我们的演示应用程序附加免费实例:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="22ff" class="nk md it nf b gy nl nm l nn no">heroku addons:create heroku-redis:hobby-dev -a evening-wave-98825</span></pre><p id="8601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建应用程序，并提交我们所拥有的一切:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="1072" class="nk md it nf b gy nl nm l nn no">go mod init<br/>go mod vendor<br/>go build -o bin/heroku_chat_sample -v .<br/>git init<br/>git add .<br/>git commit -m “First commit of chat app”</span></pre><p id="3aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这些都送给Heroku:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="184f" class="nk md it nf b gy nl nm l nn no">heroku git:remote -a evening-wave-98825<br/>git push heroku main</span></pre><p id="70b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程是您将所有东西部署到生产环境中所需要的。如果您访问Heroku为您生成的URL，您应该会看到您的聊天应用程序。它可能看起来很简单，但在幕后有很多事情要做！</p><p id="d192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从<a class="ae ky" href="https://github.com/gjtorikian/heroku_chat_sample" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载本文使用的所有代码。</p></div></div>    
</body>
</html>