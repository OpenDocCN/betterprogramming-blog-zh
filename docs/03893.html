<html>
<head>
<title>Playing With Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩弄管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/playing-with-pipelines-b5cf357ddd06?source=collection_archive---------28-----------------------#2020-03-10">https://betterprogramming.pub/playing-with-pipelines-b5cf357ddd06?source=collection_archive---------28-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="21ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在新的Jenkins实例上构建现有项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/41dcae8fe83fc95ea06da6df81dc966e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kC1atfHenjZnkXv7SQlSTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@qa9de?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克·阿斯特霍夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/themepark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="e0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上一个帖子，我拿了一个旧的机架式服务器，安装了<a class="ae ky" href="https://www.linux-kvm.org/page/Main_Page" rel="noopener ugc nofollow" target="_blank"> KVM </a>、<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>、<a class="ae ky" href="http://www.postfix.org/" rel="noopener ugc nofollow" target="_blank"> Postfix </a>和Kubernetes，然后把<a class="ae ky" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>安装进Kubernetes。今天，我将把我在GitHub上的一个项目放在新的Jenkins实例上。</p><p id="327c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要阅读本文，您应该具备Linux、网络、Docker之类的容器以及一般编程概念的基础知识。</p><p id="e97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还应该有一个GitHub帐户或其他代码库，因为这是构建管道的起点。它还假设您已经安装了我上一篇文章中设置的所有软件，<a class="ae ky" href="https://medium.com/better-programming/playing-with-vms-and-kubernetes-26ef93019c22" rel="noopener"> <em class="lv">使用虚拟机和Kubernetes </em> </a> <em class="lv">。</em></p><p id="ec7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望我的管道从代码中构建容器映像，将映像安装到运行在Kubernetes上的本地存储库中，将映像部署到Kubernetes中，最后测试部署的代码。</p><p id="82e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在之前的一篇文章<a class="ae ky" href="https://medium.com/@rlkamradt/kubernetes-ci-cd-on-a-budget-6e4ea91117a" rel="noopener"><em class="lv">CI/CD on a budget</em></a>中做了所有这些事情，但是没有Jenkins的帮助，所以我将修改代码以在Jenkins管道中运行。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9f70" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">入门指南</h1><p id="a5a6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我配置Jenkins之前，我必须在后缀配置中添加一行，这样它将从VM子网中继，在我的例子中是192.168.122.0/24。更改<code class="fe na nb nc nd b">mynetworks</code>设置以添加您的虚拟机子网，然后重启Postfix。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="67fa" class="ni me it nd b gy nj nk l nl nm">sudo vi /etc/postfix/main.cf #set mynetworks=127.0.0.0/8 &lt;VM subnet&gt;<br/>sudo systemctl restart postfix</span></pre><p id="aef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我可以对詹金斯做一点配置了。登录到我们在上一篇文章中创建的Jenkins实例。点击<em class="lv">管理Jenkins </em>链接，然后点击<em class="lv">配置系统</em>链接。</p><p id="ab18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将Jenkins URL设置为您用来在浏览器中查看Jenkins的URL，在我的例子中是<a class="ae ky" href="http://jenkins" rel="noopener ugc nofollow" target="_blank"> http://jenkins </a>(我在NGINX设置中使用了一个虚拟主机来将对名为<em class="lv"> jenkins </em>的服务器的请求指向Kubernetes中的Jenkins服务外部IP，并将其添加到我的/etc/hosts文件中)。</p><p id="505d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将<em class="lv">系统管理员</em>电子邮件地址设置为您的电子邮件，以及全局配置用户名值和全局配置用户名值，这样Jenkins就可以将版本更改等内容推送到您的repo中。</p><p id="825b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将SMTP服务器设置为您的主主机(Postfix正在运行的主机)的IP地址，并测试配置。</p><p id="11d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果邮件不行，可以查看<code class="fe na nb nc nd b">/var/log/mail.log</code>看看发生了什么。还是那句话，如果你不能发邮件，那真的不是问题，有就好了。</p><p id="7c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们安装的Jenkins假定它运行在Kubernetes中，并预先配置它使用Kubernetes。如果您想进行测试，请点击<em class="lv"> Kubernetes Cloud Details </em>按钮，然后点击<em class="lv">测试连接</em>按钮。它应该回应说它是成功的。主要配置就这些了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="072f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">添加凭据</h1><p id="9748" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接下来，我们将添加凭证，以便访问GitHub。我们将使用SSH，有两种选择。首先，创建一个新的公钥/私钥，并将公钥添加到GitHub，将私钥添加到Jenkins。</p><p id="5f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种选择，对于不太多疑的人来说，是使用您已经用来访问GitHub的公钥/私钥对，并将私钥复制给Jenkins，这样Jenkins在GitHub看来就是您。我选择第二种选择，因为我更懒惰而不是偏执。</p><p id="6cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<em class="lv">凭证</em>链接、<em class="lv">系统</em>链接和<em class="lv">全局凭证(无限制)</em>链接。然后，点击<em class="lv">添加凭证</em>链接，选择<em class="lv"> SSH用户名</em>种类，将ID和用户名设置为您要从中复制私钥的计算机上的用户名。</p><p id="fcb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<em class="lv">私钥</em>按钮，然后<em class="lv">添加</em>按钮出现一个您的私钥文本框。将文件显示在您本地计算机的<code class="fe na nb nc nd b">~/.ssh/id_rsa</code>中，或者您保存私人密钥的任何地方，然后将其剪切并粘贴到Jenkins中。</p><p id="1ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果您在创建公钥/私钥时使用了密码，请填写密码。请注意，您的私钥是敏感的，因此请确保您不会不小心将其粘贴到您公司的Slack通道中。</p><p id="123b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，我想测试一下与GitHub的连接。我将在回购中创建一个<code class="fe na nb nc nd b">Jenkinsfile</code>，我想在本文的其余部分使用它。回购可以在这里找到。</p><p id="2815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是构建文件，这是我正在构建的<a class="ae ky" href="https://github.com/rkamradt/hellok8s" rel="noopener ugc nofollow" target="_blank">实际项目</a>。我喜欢将管道代码从项目代码中分离出来，这样项目就不会变得混乱。</p><p id="2e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将添加一个非常基本的管道，它什么也不做，但它将证明我们到目前为止所做的事情。下面是最基本的管道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把这个提交给GitHub。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ab0b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建第一个作业</h1><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，在Jenkins服务器上创建我们的第一个作业。如果您尚未创建作业，主屏幕将提示您创建作业，并显示“请创建新作业以开始”</p><p id="beb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<em class="lv">新任务</em>创建一个新任务。给它起个好记的名字，我在叫我的<em class="lv"> HelloK8sBuild </em>，然后选择<em class="lv">管道</em>。点击<em class="lv">确定</em>按钮将进入配置屏幕。</p><p id="a9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的唯一配置是在<em class="lv">管道</em>部分，从SCM中选择<em class="lv">管道脚本</em>。选择<em class="lv"> Git </em>作为SCM类型，从项目中添加克隆URL，在我的例子中是<code class="fe na nb nc nd b">git@github.com:rkamradt/HelloK8sBuild.git</code>，并选择您之前创建的凭证。</p><p id="554c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有问题，它会以红色文本发出嘟嘟声，说明它认为有问题，你必须找出为什么你的詹金斯不能与GitHub通信。</p><p id="9743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<em class="lv">保存</em>按钮，然后点击<em class="lv">立即构建</em>链接启动管道。应该会很快结束。在Stage视图中应该有一个Checkout SCM和Stage 1阶段。您可以单击构建历史中的构建号，并单击控制台输出来查看发生了什么。</p><p id="db62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，默认情况下，它创建一个Kubernetes Pod作为从属代理，并在其中运行。我的运行时间大约是30秒，因为管道本身非常简单，所以大部分时间都是启动一个从站的开销。</p><p id="c4fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这对于像这样的简单管道来说并不是一个好的选择，但是对于像我们将要创建的有许多阶段的更长的管道来说更适合。</p><p id="a124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在容器中运行的一个问题是很难从容器中运行Docker命令。有很多方法可以解决这个问题，但是在我看来，最好的解决方案是不要运行Docker命令。</p><p id="3384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何在Kubernetes Pod中创建一个图像呢？一个名为<a class="ae ky" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>的程序创建了一个图像，并将其存储在一个容器库中，而不使用Docker。下面是新的詹金斯文件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d3e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件引用了一个<code class="fe na nb nc nd b">build-pod.yaml</code>，它是用于运行程序的Kaniko映像的容器定义。这里是<code class="fe na nb nc nd b">build-pod.yaml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们使用的是<code class="fe na nb nc nd b">debug</code>标签，因为普通标签没有<code class="fe na nb nc nd b">tail</code>命令，我们使用该命令使Pod在运行Kaniko时保持忙碌。这是一个小问题，如果我找不到解决的方法，我可能会向Kaniko团队提交一个特性请求来允许这个用例。</p><p id="6e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看是否可以从一个Pod中运行kubectl。我们将从一些简单的东西开始，只是一个用<code class="fe na nb nc nd b">kubectl get all --all-namespaces</code>命令列出Kubernetes中运行的所有项目的stage。</p><p id="bb6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先加一个<code class="fe na nb nc nd b">kubectl-pod.yaml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ec23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用的是<code class="fe na nb nc nd b">linkyard</code>图片，因为它是我在Docker Hub上搜索kubectl时列出的第一张图片。稍后我可能会查看另一张图片，但现在，这张图片完成了任务。然后，我向Jenkinsfile添加了一个新的stage。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="be1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行此操作将重建映像，然后列出pod，其中实际包含运行此阶段的pod。</p><p id="eb56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这种方法奏效时，我们应该尝试部署我们在第一阶段构建的映像。</p><p id="5c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将创建一个新文件<code class="fe na nb nc nd b">helloworld.yaml</code>，并将stage中的<code class="fe na nb nc nd b">kubectl</code>命令改为<code class="fe na nb nc nd b">/usr/local/bin/kubectl apply -f helloworld.yaml</code>，看看会发生什么。</p><p id="1bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是将部署我们新构建的应用程序的<code class="fe na nb nc nd b">helloworld.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行我们的管道，一切似乎正常！然而，我在程序实际运行时遇到了一些麻烦，测试舱卡在了<code class="fe na nb nc nd b">CreatingContainer</code>状态。</p><p id="275f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一番搜索，我发现如果我在<code class="fe na nb nc nd b">helloworld.yaml</code>中将localhost改为127.0.0.1，然后在列出它所知道的端点的部分将<code class="fe na nb nc nd b">/var/snap/microk8s/current/args/containerd-template.toml</code>文件改为使用127.0.0.1而不是localhost，它就工作了(在重启<a class="ae ky" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> MicroK8s </a>之后)。</p><p id="1339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道以前使用本地主机是可行的，但是事情在变，我们必须跟着变。</p><p id="7b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在主主机(运行所有虚拟机的计算机)上手动测试，您可以运行<code class="fe na nb nc nd b">kubectl get services</code>并找到测试服务的IP地址。然后，卷曲结果，它应该打印出“Hello World”。</p><p id="943b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们更进一步，让我们增加一个测试阶段。这实际上是两个阶段，一个是构建测试映像，另一个是运行测试。</p><p id="75c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是要复制<code class="fe na nb nc nd b">Jenkinsfile</code>中的两个阶段，做一点重命名。我还必须创建一个<code class="fe na nb nc nd b">helloworldtest.yaml</code>来定义运行测试的作业。以下是我所知道的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行作业和检查输出的步骤略有不同，以下是阶段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将启动作业，等待它完成，转储日志，最后删除测试。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e216" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">名称空间</h1><p id="b21b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我想做的最后一件事是开始在不同的阶段使用名称空间。到目前为止，我们已经使用了默认的名称空间，如果您计划拥有一个复杂的系统，使用默认不是一个好主意。</p><p id="6e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们为开发、测试和生产创建名称空间，然后为每个名称空间添加阶段。事实上，我们将使用<code class="fe na nb nc nd b">projectname-stage</code>创建二维名称空间。</p><p id="bd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，<code class="fe na nb nc nd b">helloworld-dev</code>、<code class="fe na nb nc nd b">helloworld-test</code>和<code class="fe na nb nc nd b">helloworld-prod</code>。这将为集群中的每个项目提供单独的名称空间。以下是创建它们的方法:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="182d" class="ni me it nd b gy nj nk l nl nm">kubectl create namespace helloworld-dev<br/>kubectl create namespace helloworld-test<br/>kubectl create namespace helloworld-prod</span></pre><p id="7e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以使用<code class="fe na nb nc nd b">kubectl get namespace</code>命令将它们全部列出。您应该会看到新的名称空间以及MicroK8s为您创建的名称空间。</p><p id="a1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们必须更新Jenkinsfile以使用名称空间。我们将首先将它们添加到我们现在拥有的内容中，并对其进行测试，这符合我的理念，即在继续之前进行原子性的更改和测试。</p><p id="dc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在Jenkinsfile中每个有<code class="fe na nb nc nd b">kubectl</code>命令的地方，都应该在子命令后添加<code class="fe na nb nc nd b">-n helloworld-dev</code>。例如:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f7a9" class="ni me it nd b gy nj nk l nl nm">steps {<br/>            sh "/usr/local/bin/kubectl apply -n helloworld-dev -f desc/helloworld.yaml"<br/>          }</span></pre><p id="e479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，运行你的构建，交叉你的手指。构建完成后，获取<code class="fe na nb nc nd b">helloworld-dev</code>名称空间的所有对象:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7a64" class="ni me it nd b gy nj nk l nl nm">rkamradt@beast:~$ kubectl get all -n helloworld-dev<br/>NAME                              READY   STATUS    RESTARTS   AGE<br/>pod/helloworld-7d7547c4cd-gcw6q   1/1     Running   0          12m</span><span id="f139" class="ni me it nd b gy np nk l nl nm">NAME                 TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)        AGE<br/>service/helloworld   LoadBalancer   10.152.183.169   192.168.122.242   80:31567/TCP   12m</span><span id="73f9" class="ni me it nd b gy np nk l nl nm">NAME                         READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/helloworld   1/1     1            1           12m</span><span id="f105" class="ni me it nd b gy np nk l nl nm">NAME                                    DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/helloworld-7d7547c4cd   1         1         1       12m</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="517a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">更多阶段</h1><p id="0235" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">看起来不错！现在让我们增加一些阶段。除非通过测试，否则不会进入下一阶段。我将作弊并使用相同的测试来提升到prod，但显然您会希望在测试阶段有一组更广泛的测试。</p><p id="f9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑您的Jenkinsfile，首先将您的两个构建(应用程序和测试代码)移到前两个阶段。然后，复制部署和测试阶段两次，每次都更改名称空间。别担心，所有的代码都会在我的GitHub项目里。运行新管道，瞧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d51752383b299be1c9a4e11c17d1b58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrGlfmey-N8JfXHnv7M4dg.png"/></div></div></figure><p id="80ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是一条管道！</p><p id="d5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下<code class="fe na nb nc nd b">kubectl get all --all-namespaces</code>的结果，您会看到您所有的<code class="fe na nb nc nd b">helloworld</code>服务，每个服务都有自己的外部地址。</p><p id="0509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中使用的所有脚本都可以在GitHub 上找到。我希望这篇文章能给你一些好主意，记住，永远不要停止游戏！</p></div></div>    
</body>
</html>