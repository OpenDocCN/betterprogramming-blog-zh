<html>
<head>
<title>Understanding All the Details of C++ Const</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解C++ Const的所有细节</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-all-the-details-of-c-const-4d2a4b714b63?source=collection_archive---------6-----------------------#2022-02-22">https://betterprogramming.pub/understanding-all-the-details-of-c-const-4d2a4b714b63?source=collection_archive---------6-----------------------#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="12e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解const限定符的细节非常重要，有助于提高代码质量和编码效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44588ed54fc3fee62dea023bf293aa6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FIq6rtNvMV5YGGj_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jenrielzany?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zany Jadraque </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="f971" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++常量</h1><p id="b2cd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">C++ <code class="fe mn mo mp mq b">const</code>限定词是你学习C++的第一件事。你通常从理解我们应该使用<code class="fe mn mo mp mq b">const</code>作为常量开始。这可能是真的，但实际上我们应该把它看作是告诉编译器和其他程序员我们对代码的意图的一种方式。</p><p id="a2ac" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们将<code class="fe mn mo mp mq b">const</code>添加到一个变量时(后面还有其他用例讨论)，我们实际上是在说我们希望这个变量是<strong class="lt iu"> <em class="mw">只读</em> </strong>或者不可变的。任何修改它的尝试都应该被编译错误所阻止。</p><p id="dfce" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在接下来的章节中，我将介绍我们可以在C++代码中使用<code class="fe mn mo mp mq b">const</code>限定符的不同场景，以及实际发生的情况。</p><h2 id="fb1f" class="mx la it bd lb my mz dn lf na nb dp lj ma nc nd ll me ne nf ln mi ng nh lp ni bi translated">常量变量</h2><p id="df54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先想到的，最简单的例子就是<code class="fe mn mo mp mq b">const</code>变量。这可能是函数中的局部变量、类中的成员变量或全局变量。</p><p id="f8d2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">添加一个<code class="fe mn mo mp mq b">const</code>限定词的目的是明确表示我们的意图是让变量是只读的。例如，看看下面的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5bb2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这个函数表明作者希望参数<code class="fe mn mo mp mq b">val</code>和局部变量<code class="fe mn mo mp mq b">two</code>是只读的。这里没有什么特别的事情发生。这两个变量都像非常数变量一样存储在堆栈内存中。唯一的区别是，当我们试图改变这个值时，我们会得到一个编译错误。以下代码显示了修改<code class="fe mn mo mp mq b">val</code>的尝试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="4dd5" class="mx la it mq b gy np nq l nr ns">error: assignment of read-only parameter ‘val’</span></pre><p id="8721" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">对于类中的<code class="fe mn mo mp mq b">const</code>成员变量也是如此，非常数成员变量的唯一区别是，当我们试图修改它们时，我们会得到与上面相同的编译错误。</p><p id="e1c2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">对于全局变量，还有一个区别，当我们给变量添加一个<code class="fe mn mo mp mq b">const</code>限定符时，变量将被存储在内存的只读段而不是数据段。其余都一样。</p><p id="49ce" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">所以很明显，<code class="fe mn mo mp mq b">const</code>关键字是我们向编译器和其他程序员传达我们的意图的一种方式，告诉他们我们不希望变量在运行时改变。</p><h2 id="5b6f" class="mx la it bd lb my mz dn lf na nb dp lj ma nc nd ll me ne nf ln mi ng nh lp ni bi translated">函数返回常量</h2><p id="4d57" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我发现这种情况很少见，但也是可能的。我们可以给函数的返回类型添加一个<code class="fe mn mo mp mq b">const</code>限定符。只有当我们返回用户定义的类型，而不是像<code class="fe mn mo mp mq b">int</code>这样的原始类型时，这才有意义。看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="80eb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">注意，<code class="fe mn mo mp mq b">CreateT()</code>返回一个临时变量，可以用来调用<code class="fe mn mo mp mq b">SetVal()</code>。将返回值改为<code class="fe mn mo mp mq b">const</code>可以防止这种情况发生。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="132e" class="mx la it mq b gy np nq l nr ns">error: passing ‘const T’ as ‘this’ argument discards qualifiers [-fpermissive]</span></pre><p id="c1e5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">编译器抛出这个错误是因为我们试图将一个指向<code class="fe mn mo mp mq b">const</code>对象的指针传递给只接受非常数的<code class="fe mn mo mp mq b">SetVal()</code>。以防你不知道或者忘记，调用成员函数意味着隐式地传递一个指针(<strong class="lt iu">这个</strong>指针)给函数。在这种情况下，</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="d24c" class="mx la it mq b gy np nq l nr ns">int SetVal(T* this, const int val);</span></pre><p id="843c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">将<code class="fe mn mo mp mq b">const T*</code>传递给这个函数会导致编译错误，因为我们试图隐式删除<code class="fe mn mo mp mq b">const</code>限定符。</p><p id="de8b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">然而，返回一个<code class="fe mn mo mp mq b">const</code>对象有一个缺点，它阻止了从C++11引入的移动语义。现在，让我们假设我们的类<code class="fe mn mo mp mq b">T</code>动态分配内存来管理它的一些成员变量。当然，我们希望使用移动语义来避免昂贵的复制过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e483" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果<code class="fe mn mo mp mq b">CreateT()</code>返回一个<code class="fe mn mo mp mq b">const</code>对象，上面代码中的行<code class="fe mn mo mp mq b">3</code>将调用复制赋值操作符，而如果它返回一个非常数对象，它将调用移动赋值操作符。这是因为编译器会选择接受<code class="fe mn mo mp mq b">const</code>对象引用的复制赋值操作符重载。</p><p id="59a1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">所以除非你用的是旧版本的C++，否则没有理由返回一个<code class="fe mn mo mp mq b">const</code>对象。调用方最好不要调用试图修改临时对象的函数。</p><h2 id="3f2f" class="mx la it bd lb my mz dn lf na nb dp lj ma nc nd ll me ne nf ln mi ng nh lp ni bi translated">常量(成员)函数</h2><p id="be3f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">限定符的另一个用途是用于类的成员函数。这种语法是独特的或者说是笨拙的，因为它被放在函数声明的末尾。</p><p id="8aaa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">应该这样写，因为它限定的变量是隐藏的。回想一下，所有非静态成员函数都有一个指向自己的隐藏指针叫做<strong class="lt iu"> <em class="mw"> this </em> </strong>。我们在这里讨论的<code class="fe mn mo mp mq b">const</code>限定符是用来限定指针的。</p><p id="caea" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">回到我们上面的例子，<code class="fe mn mo mp mq b">T</code>类有一个名为<code class="fe mn mo mp mq b">SetVal()</code>的成员函数。</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="511b" class="mx la it mq b gy np nq l nr ns">int SetVal(const int val);</span></pre><p id="ca9a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">编译代码时，编译器会将其修改为:</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="8a7d" class="mx la it mq b gy np nq l nr ns">int SetVal(T* this, const int val);</span></pre><p id="1e84" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">为了生成第一个变量<code class="fe mn mo mp mq b">const</code>，我们需要将代码写成:</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="96ba" class="mx la it mq b gy np nq l nr ns">int SetVal(const int val) const;</span></pre><p id="0455" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，编译器将其修改为:</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="5ae7" class="mx la it mq b gy np nq l nr ns">int SetVal(const T* this, const int val);</span></pre><p id="51d1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，忽略<code class="fe mn mo mp mq b">SetVal()</code>成为<code class="fe mn mo mp mq b">const</code>没有意义的事实，因为我们想要修改对象。我在这里要说明的是<code class="fe mn mo mp mq b">const</code>限定符的存在使得<strong class="lt iu"> <em class="mw">这个</em> </strong>指针指向一个<code class="fe mn mo mp mq b">const</code>对象。</p><p id="fd5b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">任何改变该函数中任何成员变量的尝试都将导致编译错误。另一个要点是我们上面讨论过的，当你声明一个类型为<code class="fe mn mo mp mq b">T</code>的<code class="fe mn mo mp mq b">const</code>对象时，你只能调用<code class="fe mn mo mp mq b">const</code>函数。那是因为你不能将一个指向<code class="fe mn mo mp mq b">const</code>对象的指针转换成一个指向非常数对象的指针，因为这会违反常量。</p><h2 id="c694" class="mx la it bd lb my mz dn lf na nb dp lj ma nc nd ll me ne nf ln mi ng nh lp ni bi translated">将常数转换为非常数，反之亦然</h2><p id="c80c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有些事情我觉得很困惑，尤其是对初学者来说。即通过引用或指针传递参数，从函数返回引用或指针。</p><p id="3961" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">令人困惑的部分是<code class="fe mn mo mp mq b">const</code>限定词的不同。让我们看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1378" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们在第<code class="fe mn mo mp mq b">10</code>行调用<code class="fe mn mo mp mq b">Process(input);</code>时，我们复制了<code class="fe mn mo mp mq b">input</code>对象，从非常数版本转换到<code class="fe mn mo mp mq b">const</code> <code class="fe mn mo mp mq b">Input</code>版本没有问题，因为有两个副本。另一种方式也是正确的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b6c5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">返回值也是一样，无论我们在哪里添加<code class="fe mn mo mp mq b">const</code>限定符，它都会起作用，因为我们做了一个拷贝。</p><p id="89c9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们处理推荐人时，就不一样了。当我们改变函数来接受<code class="fe mn mo mp mq b">const</code>引用时，行为保持不变，我们可以传递<code class="fe mn mo mp mq b">const</code>和非常数对象给它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d4c2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面两个版本都可以。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="857d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但是当我们改变函数来接受下面显示的非常数引用时，我们只能传递非常数对象给它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3d43" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这是因为与按值传递不同，当我们使用引用时，我们不复制，我们使用同一个对象。因此，我们不能将对象的限定符从<code class="fe mn mo mp mq b">const</code>更改为非常数。</p><p id="cf32" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下面的例子很有趣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="49c4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这个例子中，我们将第<code class="fe mn mo mp mq b">9</code>行上的<code class="fe mn mo mp mq b">const</code>引用传递给一个通过值接受对象的函数。在这种情况下，它是有效的，即使我们从<code class="fe mn mo mp mq b">const</code>变成了非常数。</p><p id="eb03" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">由于编译器的魔力，这很令人困惑。参考只是引擎盖下的指针。编译器会为我们完成所有的转换工作。在这种情况下，会发生以下情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e98f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">编译器将我们的代码修改为按值传递，所以在这种情况下，我们制作了它的副本。这就是为什么它有效。为了完成这个例子，在前面的版本中，这是编译器修改我们的代码后发生的情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e0e5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们看到指针版本时，一切都变得更清楚了。</p><h2 id="bff3" class="mx la it bd lb my mz dn lf na nb dp lj ma nc nd ll me ne nf ln mi ng nh lp ni bi translated">使用const_cast添加/删除const限定符</h2><p id="ead8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上一节中我们已经看到，我们可以有一个指向非常数对象的<code class="fe mn mo mp mq b">const</code>指针或<code class="fe mn mo mp mq b">const</code>引用，反之则不可能。</p><p id="c275" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，如果您有需要修改常量的场景，无论哪种方式，您都可以使用<code class="fe mn mo mp mq b">const_cast</code>。以下是一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f16a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这个例子中，库代码允许我们出于某种原因修改<code class="fe mn mo mp mq b">value</code>。但是，我们决定我们不想这样做。在这种情况下，我们可以使用<code class="fe mn mo mp mq b">const_cast</code>给它添加一个<code class="fe mn mo mp mq b">const</code>限定符。</p><p id="401b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">另一种方式也可以，但不推荐。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ace6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这段代码是可行的，因为第<code class="fe mn mo mp mq b">7</code>行的原始变量<code class="fe mn mo mp mq b">value</code>是非常量对象。所以我们可以删除<code class="fe mn mo mp mq b">const</code>限定符并修改值。但是，如果原始变量是下面代码所示的<code class="fe mn mo mp mq b">const</code>，那么结果就是<strong class="lt iu"><em class="mw"/></strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e8a4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这段代码编译无误，但结果是<strong class="lt iu"> <em class="mw">未定义</em> </strong>。该示例将打印以下内容(用GCC和clang测试):</p><pre class="kj kk kl km gt nl mq nm nn aw no bi"><span id="d1ff" class="mx la it mq b gy np nq l nr ns">mutableValue: 100<br/>value after callback: 10</span></pre><p id="6f98" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">请注意，如果我们写对了代码，我们就不应该使用<code class="fe mn mo mp mq b">const_cast</code>。唯一的用例可能是当我们处理给我们一个指向非常数对象的指针的库代码时，我们想通过把它修改成一个指向<code class="fe mn mo mp mq b">const</code>对象的指针来使它更安全。</p><h1 id="90df" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关键要点</h1><ul class=""><li id="ebf8" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated"><code class="fe mn mo mp mq b">const</code>限定符对于向编译器和其他程序员表达我们希望对象是只读的意图非常重要</li><li id="8418" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated">当试图改变我们的只读变量时，编译器通过抛出错误来帮助我们执行检查</li><li id="d610" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated">成员函数上的<code class="fe mn mo mp mq b">const</code>限定符只是给<code class="fe mn mo mp mq b">this</code>指针添加一个<code class="fe mn mo mp mq b">const</code>限定符的语法</li><li id="3dd3" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated">我们可以从函数中返回一个<code class="fe mn mo mp mq b">const</code>值来防止临时的对象修改，但是这样做会产生意想不到的影响，即防止移动语义</li><li id="ff82" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated">我们可以使用<code class="fe mn mo mp mq b">const_cast</code>来修改对象的常量，但是有效的用例非常少，例如在处理第三方遗留库时，您不能修改它</li></ul></div></div>    
</body>
</html>