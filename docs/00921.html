<html>
<head>
<title>Build a Character Select Screen in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建一个角色选择屏幕</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-character-select-screen-in-react-9ed5ad5797f6?source=collection_archive---------6-----------------------#2019-07-28">https://betterprogramming.pub/build-a-character-select-screen-in-react-9ed5ad5797f6?source=collection_archive---------6-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现在是让React做大事的时候了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4b68a8d9035379ad06e8248eab0209a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSRaNlJdw8ZKXluWCRBO5A.jpeg"/></div></div></figure><p id="5f94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React是一个JavaScript库，众所周知，它有助于构建令人惊叹的用户界面，同时保持其简单性。像<a class="ae lq" href="https://facebook.com/" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae lq" href="https://www.netflix.com/" rel="noopener ugc nofollow" target="_blank">网飞</a>和<a class="ae lq" href="https://www.nytimes.com/" rel="noopener ugc nofollow" target="_blank">纽约时报</a>这样的大型老牌网站已经非常成功地用React维护了他们的网络应用。</p><p id="7325" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢<a class="ae lq" href="https://github.com/facebook/react/pulls" rel="noopener ugc nofollow" target="_blank">对开源库的积极参与</a>，它每天都在变得更好。</p><p id="85b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将介绍构建一个基本角色选择屏幕的步骤，利用React的机制使它变得生动。</p><p id="43ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将一边走一边展示思考的过程，并在问题出现之前揭示如何解决问题。希望这种方法可以帮助新的React开发人员！</p><p id="9094" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你跟着做，到最后你应该会得到这样的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5a7c4b9e79bbd3e54d3fcc6f94353759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*xz6MghESqysV5SdT.gif"/></div></figure><p id="f036" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想要包含附加字符的GitHub repo的链接，请单击此处的<a class="ae lq" href="https://github.com/jsmanifest/character-select" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ac08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了安装一个loading spinner之外，我不会在这篇文章中使用UI库来制作任何效果，因为我希望每个人都能够跟随，而不必研究库的API来理解示例。</p><p id="8cf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事不宜迟，我们开始吧！</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="0c9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将使用<code class="fe ma mb mc md b">create-react-app</code>快速生成一个react项目</p><p id="fdc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续使用下面的命令创建一个项目。在本教程中，我称我们的项目为<em class="lr">角色选择</em>。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="95f3" class="mi mj it md b gy mk ml l mm mn">npx create-react-app character-select</span></pre><p id="2ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后进入目录:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="312d" class="mi mj it md b gy mk ml l mm mn">cd character-select</span></pre><p id="3d3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在主条目src/index.js中，我们进行了一些清理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d78f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是开始的风格:</p><p id="911e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/styles.css </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在转到src/App.js，从根元素开始，因为我们已经定义了样式:</p><p id="4988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://gist.github.com/5488a324c2b127ff9bdac740f601a054" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/5488a324c2b127ff9bdac740f601a054</a></p><p id="2bcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始之前，让我们解释一下这个角色选择屏幕的流程，这样我们就知道我们都在同一页上。</p><p id="83bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在玩MMORPG游戏。所有玩家都从创造一个角色开始。每个玩家默认从<code class="fe ma mb mc md b">Novice</code>职业开始。当他们升到10级时，他们可以变成2级职业(在这篇文章中，我们只有一个<em class="lr">女巫</em>和一个<em class="lr">骑士</em>可用，但是MMORPG游戏通常有其他职业，比如弓箭手和死灵法师。</p><p id="722d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当他们到达10级并选择一个职业时，他们点击一个写着“变形”的按钮，他们的角色就会相应地改变它的外观。在这些动作之间，它们会自动向下滚动，以保持玩家的交互性。最后，他们被引导到一个新的屏幕。</p><p id="c6b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们首先展示一个祝贺他们的屏幕，然后给他们展示两个二级职业，他们可以选择变形他们的角色。</p><p id="dbe6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果他们选择<em class="lr">女巫</em>，他们将能够变成一个女巫，继续他们的旅程，成为游戏中最好的玩家。同样的概念也适用于骑士期权。然而，有一个秘密的选择。如果玩家足够聪明和爱管闲事，他们会意识到他们可以选择<em class="lr">和</em>两个人，然后变成一些人类还没见过的不寻常的东西。生活充满了惊喜，我们的游戏应该反映这一点，以保持现实。</p><p id="4cf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了展示屏幕，我们将向他们展示一个标题、一张他们新手班级的照片(因为他们再也不会看到它了)，以及一条温暖人心的消息，提醒他们他们的努力已经有了回报。</p><p id="2e0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(如果您想使用相同的图片，可以在上面的GitHub链接中找到这些图片)</p><p id="eb44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="06fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是CSS的新增内容:</p><p id="8b02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> styles.css </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fa18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看该组件，您可以看到根元素包含一个标题、一个内容容器和一个子标题作为直接子元素。我提到我们将向用户展示一张新手的照片——这就是在类名为<code class="fe ma mb mc md b">styles.content</code>的div元素中发生的事情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/929d0d6c80edd9fcfd11a627d26f44dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*5HwHEv1_rQ9nD0WN.jpg"/></div></figure><p id="6830" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们为header和subheader定义了CSS类名，因为有些东西告诉我这些可以在进一步的界面中重用，比如当播放器被引导到一个新的部分时。当我想到单词“section”时，我认为它包含一些标题和主体，所以这看起来像是一个有效的移动。我们也可能对其他角色使用“角色箱”,比如法师或其他什么，所以我们定义了一个<code class="fe ma mb mc md b">.characterBox</code>类名称来在我们继续的时候保持这个想法。</p><p id="7ecf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经建立了本教程最简单的部分，让我们继续更有趣的部分！</p><p id="7fc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来要做的是制作<em class="lr">选项</em>或<em class="lr">选择</em>屏幕。这个屏幕负责向玩家显示角色类别选择。这些角色被称为<em class="lr">女巫</em>和<em class="lr">骑士</em>。这是玩家一到达10级就会被提示的画面。</p><p id="ad94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以有效地解决这个问题的方法是思考玩家下一步的目的是什么。目的是让他们在女巫或骑士之间做出选择，因此抓取一些角色选择框并呈现给玩家是有意义的。</p><p id="86df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们想尽可能避免创建基本上做同样事情的多个组件。这样做并不是一个好的做法，因为将来你会越来越难以回头修改代码，甚至在调试小错误的时候。</p><p id="a917" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到这一点，带有字符选择选项的下一个<em class="lr">部分</em>可以具有与前一个相同的结构(标题、内容/正文和副标题)，如前几个示例所示。</p><p id="c9b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将通过提取出<em class="lr">标题</em>、<em class="lr">副标题</em>和<em class="lr">容器</em>(或内容)来重用这个概念来创建角色选择屏幕。</p><p id="a823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常我会将这些可重用的组件提取到它们自己的文件中，这样我们就可以直接将它们作为单独的模块<code class="fe ma mb mc md b">import</code>，但是为了节省时间和空间，我们将把它们全部放入<code class="fe ma mb mc md b">src/components.js</code></p><p id="41b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在同一个目录下创建一个<code class="fe ma mb mc md b">components.js</code>文件，并将可重用文件定义为命名导出文件:</p><p id="c249" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/components.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1ce8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们用新的可重用组件替换应用组件:</p><p id="ee24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dce5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码现在开始变得更好看了，不是吗？现在我们将制作显示角色类的屏幕:</p><p id="b8aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是<code class="fe ma mb mc md b">styles.module.css</code>的新增内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="25ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过这一更改，我们的界面现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/a243c67fb36d7dab2050b0de2f2fa713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ezEI8OT3s_8aiMQn.jpg"/></div></div></figure><p id="b705" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在代码中看到，我们能够为下一个<em class="lr">部分</em>重用<code class="fe ma mb mc md b">Header</code>、<code class="fe ma mb mc md b">Subheader</code>和<code class="fe ma mb mc md b">Content</code>。界面看起来<em class="lr">一致</em>并且我们获得了一个非常重要的好处:我们现在只需要在<em class="lr">一个</em>位置改变标题/子标题/内容组件，而不是将来在多个位置！</p><p id="f6e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这种方法中获得的其他一些显著的好处是<em class="lr">隐式文档</em>(我们现在仅仅<em class="lr">知道</em>那些是标题和子标题组件，并且可以很容易地返回并理解代码)。</p><p id="0f30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要做的下一件事是让女巫和骑士盒子在被点击时调用某种类型的动作。</p><p id="34ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将只定义一个无用的<code class="fe ma mb mc md b">onSelect</code>处理程序，就像我们定义一些<em class="lr">“结构”</em>一样，这样我们可以不断地被提醒，有一些点击动作供以后使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="696e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切看起来都很好，但是没有办法在没有任何视觉变化的情况下判断玩家选择了哪个角色(因为我们所做的只是将“我是无用的”记录到控制台):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/a2080d0c5acaad285f5fe7ae7e337140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pnnOIiEqO0mARqBi.gif"/></div></div></figure><p id="4733" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以首先通过提供悬停效果使它更具交互性，这仍然是一个进步，因为它比静态图像更好。</p><p id="56fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，既然我们要开始合并类名，这样我们就可以对单个元素产生并行的影响，我将安装方便的<a class="ae lq" href="https://github.com/JedWatson/classnames" rel="noopener ugc nofollow" target="_blank"> classnames </a>库来为我们进行合并:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="9291" class="mi mj it md b gy mk ml l mm mn">npm install --save classnames</span></pre><p id="3a41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在需要根据具体情况应用类名时，<code class="fe ma mb mc md b">classnames</code>的实力大放异彩。我们将需要它，因为某些元素只需要在特定时间可见或隐藏。</p><p id="db71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们为字符框元素添加一些样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="249c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当玩家悬停在上面时，我们应用了一个无限变化的<code class="fe ma mb mc md b">hue-rotate</code>过滤器来突出这些。玩家应该很兴奋变成第二层职业！:)</p><p id="4ef4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这些悬停效果不会做任何事情，因为我们需要应用CSS中显示的新类名。我们需要做的就是将<code class="fe ma mb mc md b">className</code>属性应用到tier2图像元素:</p><p id="d695" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="557d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。我们现在有一些颜色变化的悬停效果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/ad416e7ed666ea925e1c26d842d37947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LfWRgfPcNZ4o-KPD.gif"/></div></div></figure><p id="f913" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有了悬停效果，现在我们需要一个样式来处理其中一个被<em class="lr">选中</em>的情况。这意味着当玩家选择一个角色时，我们必须让一些风格保持不变。</p><p id="5615" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，我们现在可以引入react钩子了。让我们在App组件的正上方创建一个名为<code class="fe ma mb mc md b">useLevelUpScreen,</code>的定制钩子，并定义<code class="fe ma mb mc md b">select</code>状态以及一个用于更新它的<code class="fe ma mb mc md b">onSelect</code>处理程序:</p><p id="e815" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9b89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ma mb mc md b">useLevelUpScreen</code>中，我们定义了<code class="fe ma mb mc md b">selected</code>状态，这将帮助我们决定玩家选择哪个等级2。<code class="fe ma mb mc md b">onSelect</code>处理程序是更新该状态的API。它使用回调版本的<code class="fe ma mb mc md b">useState</code>，以确保它准确地接收到对<code class="fe ma mb mc md b">selected</code>状态的最新更新。在回调函数中，它检查是否已经选择了<code class="fe ma mb mc md b">type</code>(在我们的例子中是<code class="fe ma mb mc md b">Knight</code>或<code class="fe ma mb mc md b">Sorceress</code>)。如果是，我们假设玩家决定取消选择，所以我们在下一次状态更新时将其过滤掉，反之亦然。</p><p id="a75d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将<code class="fe ma mb mc md b">onSelect</code>处理程序应用于<code class="fe ma mb mc md b">App</code>组件中需要它们的元素:</p><p id="1685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f571" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在应该会收到关于哪个角色被选中，哪个没有被选中的更新。这还不会反映在玩家的用户界面上，因为我们还没有在组件中应用它，所以我们接下来会这样做。对于下一步，我们将使用<code class="fe ma mb mc md b">classnames</code>包有条件地将类名应用于元素，如下所示:</p><p id="81bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="0fcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着这些新样式的加入，我们必须更新样式以适应它:</p><p id="8378" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/styles.css </em></p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="beb3" class="mi mj it md b gy mk ml l mm mn">.selectedBox {<br/>  border: 1px solid rgb(24, 240, 255) !important;<br/>}</span><span id="4c27" class="mi mj it md b gy mt ml l mm mn">.characterBox img.tier2:hover,<br/>.characterBox img.selected {<br/>  animation: hueRotate 2s infinite;<br/>  transform: scale(1.05);<br/>}</span></pre><p id="dbd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(注意偷偷摸摸的“<code class="fe ma mb mc md b">.characterBox img.selected</code>”被作为兄弟追加在<code class="fe ma mb mc md b">hover</code>行之后)</p><p id="0ee0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个改变，我们现在有两个漂亮的反应角色选择框了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/39baefb76e3dc6bcdcb66775a48d34e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TWoxevuW4tDfjM23.gif"/></div></div></figure><p id="68b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在教程的前面我们提到过，如果玩家够聪明够八卦，他们可以通过选择女巫和骑士以及变形来学习，他们会变成意想不到的东西——一个秘密角色。很明显，我们需要给玩家一些UI元素，这样他们就可以代表自己改变新手。为此我们需要一个<code class="fe ma mb mc md b">button</code>。</p><p id="2e4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将编写一个简单的<code class="fe ma mb mc md b">button</code>，并附加一个我们将要创建的<code class="fe ma mb mc md b">onMorph</code>处理程序，同时将<code class="fe ma mb mc md b">styles.morph</code>应用到按钮的<code class="fe ma mb mc md b">className</code>:</p><p id="7f55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="203c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你看看从<code class="fe ma mb mc md b">useLevelUpScreen</code>钩子返回的内容，我们可以看到有两个新的添加:<code class="fe ma mb mc md b">morphed</code>和<code class="fe ma mb mc md b">onMorph</code>。它们将在自定义挂钩中定义:</p><p id="1454" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">src/uselevelupscreen . js</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="39b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe ma mb mc md b">styles.morph</code>类名的样式:</p><p id="1e71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/styles.module.css </em></p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="164f" class="mi mj it md b gy mk ml l mm mn">.morph {<br/>  margin: 50px auto;<br/>  text-align: center;<br/>}</span></pre><p id="e529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们目前掌握的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/9c6ea779851acc11e0271151311080e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Awu5FL-IYaDo-jD5.jpg"/></div></div></figure><p id="93eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就我个人而言，我更喜欢隐藏变形按钮，直到做出选择，让玩家只专注于选择一个角色类别。所以我会应用一些隐藏的可见性效果，直到<code class="fe ma mb mc md b">selected</code>被填充了一些东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1da3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:我们用一个<code class="fe ma mb mc md b">div</code>元素包装了按钮，这样我们可以更好地控制按钮的位置和间距。</p><p id="6d00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，用户清楚地知道他或她需要选择某样东西，因为这将是我们向他们提供的唯一选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/01cb67a78b0d2830f9f156883350ba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*a6c5BtBUqGxp61Rl.gif"/></div></figure><p id="86c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个钮扣似乎有点朴素。我们试图让玩家保持动力，并为他们已经到了10级而感到高兴。所以对于下一步，我在变形按钮的左右两边放置了图标，你也可以通过安装<code class="fe ma mb mc md b">react-icons</code>来跟随它。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="db63" class="mi mj it md b gy mk ml l mm mn">npm install --save react-icons</span></pre><p id="944e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:如果您在使用NPM安装软件包时遇到错误，请尝试安装yarn并通过运行<code class="fe ma mb mc md b">yarn add react-icons</code>再次添加软件包。之后，您可以返回NPM启动服务器。</p><p id="da78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我导入了这个图标组件:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="a818" class="mi mj it md b gy mk ml l mm mn">import { MdKeyboardTab } from 'react-icons/md'</span></pre><p id="eefa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在按钮前插了一个，然后又插了一个。现在箭头图标是静止的，它们都面向同一个方向。除了将右箭头图标的方向固定为指向按钮之外，我们还必须通过设计它们的样式并赋予它们无限循环的颜色变化效果来为它们添加一些活力:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/fd4772f2737378b3cfb12a212738b1a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/1*_9aCsMWCWRnk9PcnfdujhQ.gif"/></div></figure><p id="082b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用的样式:</p><p id="5df2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src.styles.module.css </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ec38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与以前的版本相比，这将使他们更加兴奋地开始他们冒险的下一个篇章！</p><p id="d7c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们当前的<code class="fe ma mb mc md b">onMorph</code>函数在点击时将<code class="fe ma mb mc md b">morphed</code>状态设置为真，所以一旦<code class="fe ma mb mc md b">morphed</code>转换为真，我们就可以显示玩家选择变形的秘密角色类别。我们将把它放在包含变形按钮的div元素下面:</p><p id="9f9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f280" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/styles.module.css </em></p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="c87b" class="mi mj it md b gy mk ml l mm mn">.morphed {<br/>  animation: flashfade 4s forwards;<br/>  opacity: 0;<br/>}</span><span id="2ebb" class="mi mj it md b gy mt ml l mm mn">@keyframes flashfade {<br/>  0% {<br/>    opacity: 0;<br/>  }<br/>  60% {<br/>    opacity: 0.7;<br/>  }<br/>  100% {<br/>    opacity: 1;<br/>  }<br/>}</span></pre><p id="039f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们将要变成的秘密职业是圣人！现在看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/06a6430ec0026d0bdd926f2e1d78f3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/0*PyR6PL4B00cSO-VF.jpg"/></div></figure><p id="0173" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我<em class="lr">能不能接受这样的结局。但在我看来，一切还是有点“僵硬”。换句话说，我认为玩家需要一些滚动动作，这样他们就可以一直忙于我们的界面。我们将安装一个名为<code class="fe ma mb mc md b">react-scroll-to-component</code>的小库，通过传入元素的引用，它将允许我们将玩家的屏幕滚动到任何元素中:</em></p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="209b" class="mi mj it md b gy mk ml l mm mn">npm install --save react-scroll-to-component</span></pre><p id="aa54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ma mb mc md b">src/App.js</code>内导入:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="fcab" class="mi mj it md b gy mk ml l mm mn">import scrollToComponent from 'react-scroll-to-component'</span></pre><p id="3ec1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们创建一个ref并将其附加到元素上:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="904c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们希望这种滚动效果看起来平滑，我们需要增加页面底部的高度，这样我们就有更多的空间。实际上，当<code class="fe ma mb mc md b">morphed</code>切换为true时，我们可以通过添加一个具有高度的空div来轻松做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bdf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在我们有一个问题。在贤者区域变得可见之前，高度将不能按时出现在屏幕上。换句话说，滚动到功能不起作用，因为在调用它的时候还没有看到进一步的空间。我们将通过添加一个名为<code class="fe ma mb mc md b">morphing</code>的额外状态来解决这个问题，这将给我们一些时间来破坏UI，直到<code class="fe ma mb mc md b">morphed</code>变成<code class="fe ma mb mc md b">true</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a291" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，现在我们面临一个新的问题。似乎<code class="fe ma mb mc md b">morphed</code>阻止了内部元素的渲染，从而阻止了我们在1.5秒的时间框架内应用逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="27ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要做的是去掉<code class="fe ma mb mc md b">morphed &amp;&amp;</code>条件，并使用<em class="lr"> classnames </em>包来合并一些额外的样式。这些样式将模仿行为，并且<em class="lr">将元素保留在react树中，</em>因此它们将支持动画等特性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="030d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编辑:我忘了在变形按钮上应用另一个引用，当玩家选择一个角色类别时，页面会滚动到那里。很抱歉。</p><p id="63c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1984" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，一旦变形完成，我们应用了一个<code class="fe ma mb mc md b">style={{ opacity: morphed ? '0.4' : 1 }}</code>来通知玩家这个按钮将不再可用。</p><p id="9c4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应用了一个禁用属性来禁用<code class="fe ma mb mc md b">disabled={morphed}</code>的点击事件。我们还用<code class="fe ma mb mc md b">{morphing ? 'Morphing...' : morphed ? 'Morphed' : 'Morph'}</code>根据形态状态更新改变了文本，让用户不断忙于查看变化的事物。</p><p id="b60d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还移除了包裹变形按钮的<code class="fe ma mb mc md b">{!!selected.length &amp;&amp; (</code>，因为它阻挡了我们的动画，就像我们最近讨论代码的其他部分一样，并如上所示对它应用了<code class="fe ma mb mc md b">morphRef</code> ref。</p><p id="ff09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在自定义钩子中，我们还在<code class="fe ma mb mc md b">onSelect</code>函数的末尾应用了<code class="fe ma mb mc md b">scrollToComponent</code>实现，以动画显示滚动到变形按钮。</p><h1 id="f2c4" class="mx mj it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak">结束编辑</strong></h1><p id="7685" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">变形完成后，我们模拟某种加载动画，让用户知道我们正在处理接下来的步骤:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="326e" class="mi mj it md b gy mk ml l mm mn">&lt;div<br/>  className={cx(styles.next, {<br/>    [styles.hidden]: !ready,<br/>  })}<br/>&gt;<br/>  &lt;div&gt;<br/>    &lt;RingLoader size={60} color="rgb(213, 202, 255)" loading /&gt;<br/>    &lt;p&gt;Loading...&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="1635" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">款式:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="f3c0" class="mi mj it md b gy mk ml l mm mn">.next {<br/>  text-align: center;<br/>  margin: 35px auto;<br/>  display: flex;<br/>  justify-content: center;<br/>}</span><span id="bc22" class="mi mj it md b gy mt ml l mm mn">.next p {<br/>  font-family: Patua One, sans-serif;<br/>  font-weight: 300;<br/>  text-align: center;<br/>  color: #fff;<br/>}</span></pre><p id="cb81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到还有一个名为<code class="fe ma mb mc md b">ready</code>的新状态，因此我们必须在自定义钩子中实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="11ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将淡化整个页面，这样我们就可以在当前页面完成后开始下一页。这意味着向名为的定制钩子添加另一个状态— <code class="fe ma mb mc md b">shutdown </code>,并向根元素<code class="fe ma mb mc md b">div</code>应用一个新的类名。只有当 <code class="fe ma mb mc md b">ready</code>变为真时，<code class="fe ma mb mc md b">shutdown</code>状态才会切换为真<em class="lr">。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ad04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是最终结果！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/2ed10116717e397b07fadec612420c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*0PeT70WNGSBS0pE6.gif"/></div></figure><p id="9352" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是整个代码的样子:</p><p id="2e60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ca00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/components.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="94fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/styles.module.css </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6681" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到，在整个教程中有一些重复的代码。假设您不得不突然调整字符选择框，比如调整大小。如果你改变了一个，你必须扫描整个文件，找到其他的选择框，使界面一致。目前，<code class="fe ma mb mc md b">Sorceress</code>和<code class="fe ma mb mc md b">Knight</code>选择框是相同的，它们需要保持同步。但是如果我们在游戏中加入更多的第二层角色会怎么样呢？你会有一堆重复的代码，所以把它们抽象成自己的组件是个好主意。这带来了一个非常重要的好处:更好的<em class="lr">定制</em>能力。</p><p id="fb04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您抽象出字符选择框，代码看起来可能是这样的:</p><p id="138b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/App.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="894a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> src/components.js </em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="2867" class="mx mj it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="3fe9" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">本文到此结束。我希望你喜欢它，并在未来继续寻找更多！</p></div></div>    
</body>
</html>