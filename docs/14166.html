<html>
<head>
<title>Redis as a Database — Live Data Updates With PubSub and GraphQL Subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis作为数据库—通过PubSub和GraphQL订阅进行实时数据更新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redis-as-a-database-live-data-updates-with-pubsub-and-graphql-subscriptions-efafa665e173?source=collection_archive---------3-----------------------#2022-11-13">https://betterprogramming.pub/redis-as-a-database-live-data-updates-with-pubsub-and-graphql-subscriptions-efafa665e173?source=collection_archive---------3-----------------------#2022-11-13</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="383f" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">构建一个漂亮的小单词云</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/c96e7b00d2290d48d80bc6d94c8f1677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*02RJMWpH7UtlZaJPEtGiiQ.gif"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">美国使用的实时标签—2022年11月中旬</p></figure><p id="f437" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我的宠物项目被我命名为Visualizer，我用它来了解Redis，它可以开始从Twitter的<a class="ae ls" href="https://developer.twitter.com/en/docs/twitter-api/tweets/volume-streams/introduction" rel="noopener ugc nofollow" target="_blank">音量流</a>或从他们的<a class="ae ls" href="https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/introduction" rel="noopener ugc nofollow" target="_blank">过滤流</a>中摄取推文。</p><p id="3ee9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这样做的同时，Visualizer可以生成当前在摄取的推文中遇到的所有标签的实时流，并根据它们的频率对它们进行排名。</p><p id="1ae6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在这篇文章中，我想回顾一下系统中处理新推文的部分，提取并发布排名标签，最后将它们推到前端，以创建漂亮的词云。</p><p id="01e7" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如果你只是想看代码，这里有后端的GitHub <a class="ae ls" href="https://github.com/mariusmuntean/Visualizer" rel="noopener ugc nofollow" target="_blank">链接，这里有前端</a>的<a class="ae ls" href="https://github.com/mariusmuntean/VisualizerFrontend" rel="noopener ugc nofollow" target="_blank">链接。顺便说一句。这是我关于使用Redis的第三篇文章，所以请确保阅读其他文章。</a></p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="d8e6" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">可视化工具部分架构</h1><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ms"><img src="../Images/ce9591dfe9adfaeb1a752301c2cd22d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-r8qcz_rGe9_ZKEQlNckA.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">可视化工具—部分架构</p></figure><p id="3b83" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">可视化工具由三个组件组成:</p><ul class=""><li id="5870" class="mt mu ir ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><strong class="ky is"> Visualizer摄取— </strong>一种ASP.NET Core 6服务，处理推文流并将它们存储在Redis中作为索引文档(JSON格式)。它还发布每个遇到的hashtag及其等级，即Visualizer遇到它的次数。</li><li id="f656" class="mt mu ir ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky is"> Visualizer API </strong> —另一个ASP.NET Core 6服务，提供对存储的tweet数据和排名标签的实时流的访问。<a class="ae ls" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>是我喜欢的另一项技术，它的<a class="ae ls" href="https://graphql.org/blog/subscriptions-in-graphql-and-relay/" rel="noopener ugc nofollow" target="_blank">订阅</a>是向任何消费者推送排名标签流的理想选择。</li><li id="7fc9" class="mt mu ir ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky is"> Visualizer前端</strong> —一个展示Visualizer特性的React type script+<a class="ae ls" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank">ViteJs</a>SPA。</li></ul><p id="3132" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在以后的文章中，我会更多地谈论我使用这种架构的原因。</p><h1 id="2e36" class="ma mb ir bd mc md nh mf mg mh ni mj mk jx nj jy mm ka nk kb mo kd nl ke mq mr bi translated">发布排名标签</h1><p id="ae19" class="pw-post-body-paragraph kw kx ir ky b kz nm js lb lc nn jv le lf no lh li lj np ll lm ln nq lp lq lr ik bi translated">正如我提到的，<strong class="ky is"> Visualizer摄取</strong>从Twitter的API v2获取推文，除了保存它们，它还发布任何遇到的标签及其排名。</p><p id="1ebf" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">tweet数据检索不是很有趣。我只想说我使用了<a class="ae ls" href="https://linvi.github.io/tweetinvi/dist/streams-v1.1/streams-introduction.html" rel="noopener ugc nofollow" target="_blank"> Tweetinvi </a>来做这件事。</p><p id="007f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">对于每个提取的标签，都会发生一些事情:</p><ul class=""><li id="5c60" class="mt mu ir ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><strong class="ky is">存储和排序</strong>:我将每个标签存储在一个<a class="ae ls" href="https://redis.io/docs/data-types/sorted-sets/#:~:text=A%20Redis%20sorted%20set%20is,Leaderboards." rel="noopener ugc nofollow" target="_blank"> Redis排序集合</a>中。这个Redis数据结构具有集合的预期时间和空间特征，另外，多次添加一个元素将每次增加它的等级。这对于我的用例来说非常好，因为除了抽取我的有序集合中的所有标签之外，我不需要做太多事情。</li></ul><p id="5702" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">下面是获取<code class="fe nr ns nt nu b">IDatabase</code> <em class="nv">实例的代码。</em>最好将其添加到您的DI容器中。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="e21a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">之后，我将hashtag添加到一个有序集合中，并告诉Redis将这个hashtag的等级增加1。请注意，我得到了新的排名作为响应。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><ul class=""><li id="38cb" class="mt mu ir ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">发布等级为的标签:当我得到标签的新等级后，我正在发布它。这里我使用了Redis ' Pub/Sub,它允许我向通道发布字符串消息。这有效地将<strong class="ky is">可视化器摄取</strong>与<strong class="ky is">可视化器API </strong>分离。</li></ul><p id="876b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">首先，您需要一个<code class="fe nr ns nt nu b">ISubscriber</code>实例。像大多数可重用对象一样，我将它添加到我的DI容器中。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="16b0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">有了这个订阅者，我就可以将我的排名标签发布到一个频道</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="3be8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">请注意，我使用了一个<code class="fe nr ns nt nu b">RankedHashtag</code> DTO来表示标签及其等级，并且在发布之前将它序列化为一个JSON字符串。还要注意，我使用了一个常量作为通道名。这是因为常量位于同一解决方案的共享项目中，并由Visualizer API重用。</p><h1 id="f4e2" class="ma mb ir bd mc md nh mf mg mh ni mj mk jx nj jy mm ka nk kb mo kd nl ke mq mr bi translated">消费排名标签</h1><p id="75ce" class="pw-post-body-paragraph kw kx ir ky b kz nm js lb lc nn jv le lf no lh li lj np ll lm ln nq lp lq lr ik bi translated">排名标签流由<strong class="ky is">可视化API </strong>使用。它通过订阅<strong class="ky is"> Visualizer摄取</strong>用来发布每个标签及其当前排名的同一个通道来做到这一点。</p><p id="85b8" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在单例服务中，我为流中的新hashtags注册了一个处理程序</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="f2bc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在处理程序中，每个通道消息被反序列化为<code class="fe nr ns nt nu b">RankedHashtag</code> <em class="nv"> </em>的一个实例，并被传递给任何GraphQL订阅者</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="2b6d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">你看到的<code class="fe nr ns nt nu b">_rankedHashtagStream</code>是一个普通的反应式扩展<em class="nv"> ReplaySubject </em>，缓冲区为1</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="f78c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">它立即向其订户广播任何通知。但我听到你问，谁是它的订户？订阅排名标签的是GraphQL API用户；他们是订户。</p><p id="0032" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<strong class="ky is"> Visualizer </strong>中完成的方式对于我的需求和我正在使用的库来说是非常具体的，称为<a class="ae ls" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank"> GraphQl-Dotnet </a>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">RankedHashtag订阅定义</p></figure><p id="c016" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">请注意，GraphQL <code class="fe nr ns nt nu b">rankedHashtag</code>订阅接受一个名为<code class="fe nr ns nt nu b">sampleIntervalSec</code>的参数，默认值为0。该值用于确定订户是否应该在所有已排名的标签到来时立即接收它们(通常称为实时，但不是严格意义上的)，或者订户是否应该接收通过每隔<code class="fe nr ns nt nu b">sampleIntervalSec</code>秒对“实时”流进行采样而获得的另一个已排名的标签流。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ny"><img src="../Images/32b287f3f9c59c0d6a9d45644f63d3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKbAnULKAuNwceLxB42WAg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">GraphQL模式中的<strong class="bd nz"> rankedHashtags </strong>订阅。</p></figure><h1 id="05ee" class="ma mb ir bd mc md nh mf mg mh ni mj mk jx nj jy mm ka nk kb mo kd nl ke mq mr bi translated">可视化工具前端</h1><p id="90bb" class="pw-post-body-paragraph kw kx ir ky b kz nm js lb lc nn jv le lf no lh li lj np ll lm ln nq lp lq lr ik bi translated">这可能是系统中最没意思的部分，因为它只处理数据检索和呈现。它使用<a class="ae ls" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo Client for React </a>连接到<strong class="ky is"> Visualizer API </strong>和<a class="ae ls" href="https://github.com/chrisrzhou/react-wordcloud" rel="noopener ugc nofollow" target="_blank"> react-wordcloud </a>来呈现数据。</p><p id="4b4d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在高层次上，前端检索前50个hashtags，按照它们的等级降序排列(在本文中没有显示，但这是一个简单的排序集合操作)。这是为了在word cloud中有所显示。</p><p id="62f5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后，它订阅已排序的标签流，每当一个已排序的标签到达时，它要么覆盖现有的50个标签中的一个，要么将其添加到同一个标签集中。</p><h2 id="67e1" class="oa mb ir bd mc ob oc dn mg od oe dp mk lf of og mm lj oh oi mo ln oj ok mq ol bi translated"><strong class="ak">订阅排名标签</strong></h2><p id="7a63" class="pw-post-body-paragraph kw kx ir ky b kz nm js lb lc nn jv le lf no lh li lj np ll lm ln nq lp lq lr ik bi translated">我正在使用Apollo客户端的codegen特性来创建一个不错的React挂钩，用于订阅排名标签</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="2b14" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后，每当有新的排名标签可用时，我的组件被重新呈现。我正在合并新排名的标签和最初的50个</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure><h2 id="38ec" class="oa mb ir bd mc ob oc dn mg od oe dp mk lf of og mm lj oh oi mo ln oj ok mq ol bi translated"><strong class="ak">排名标签Wordcloud </strong></h2><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nw nx l"/></div></figure></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="d25b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">显示一个漂亮的单词云涉及一些系统组件和多个概念，但是每个都很容易理解。</p><p id="9984" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">感谢阅读。如果你喜欢这个锅，给它一个👏请跟随我了解Redis的最新消息。</p></div></div>    
</body>
</html>