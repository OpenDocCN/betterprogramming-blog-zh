<html>
<head>
<title>Stop Using === Everywhere</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止到处使用===</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-everywhere-fd025342132d?source=collection_archive---------0-----------------------#2020-01-30">https://betterprogramming.pub/stop-using-everywhere-fd025342132d?source=collection_archive---------0-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b714" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个冷门的观点，我们来看看</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9be4eff13a3324704117f7db5d1bd2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofXvrzbMMofNyhgXuY7dYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jcgellidon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JC Gellidon </a>在<a class="ae ky" href="https://unsplash.com/s/photos/stop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dbc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多开发者总是用<code class="fe lv lw lx ly b">===</code>而不是<code class="fe lv lw lx ly b">==</code>但是为什么呢？</p><p id="b43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在网上看到的大多数教程都认为预测JavaScript强制是如何工作的太复杂了，因此建议总是使用<code class="fe lv lw lx ly b">===</code>。</p><p id="3db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互联网上有几个教程支持不正确的信息和神话。除此之外，许多林挺规则和受欢迎的网站都固执地认为总是优先选择<code class="fe lv lw lx ly b">===</code>。</p><p id="337c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都导致许多程序员排除了语言的一部分，并将其视为一种缺陷，而不是扩展他们的理解。</p><p id="dd20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个最好使用<code class="fe lv lw lx ly b">==</code>来说明这一点的用例。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8452" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.测试空值</h1><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="b2fc" class="nc mh it ly b gy nd ne l nf ng">if (x == null)</span><span id="04de" class="nc mh it ly b gy nh ne l nf ng"><strong class="ly iu">vs</strong></span><span id="47b3" class="nc mh it ly b gy nh ne l nf ng">if (x === undefined || x === null)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a1f9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.读取来自用户的输入</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将通过发现差异、理解强制、查看一些流行的用例，以及最后有一个指导方针来帮助我们做出决定，来深入理解这个主题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cfcc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><p id="2abd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在Javascript中，相等是由两个运算符完成的。</p><ol class=""><li id="bbd6" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">=== </code> —严格的相等比较，又称三重相等。</li><li id="aa88" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">==</code> —抽象的相等比较，又称双等。</li></ol><p id="a7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在使用<code class="fe lv lw lx ly b">===</code>，因为我被告知它比<code class="fe lv lw lx ly b">==</code>更好，更高级，而且我根本不用考虑它，作为一个懒人，我发现这非常方便。</p><p id="eb9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到我在<a class="od oe ep" href="https://medium.com/u/1b199ed2dfd?source=post_page-----fd025342132d--------------------------------" rel="noopener" target="_blank">前端大师</a>上看了<a class="od oe ep" href="https://medium.com/u/5dccb9bb4625?source=post_page-----fd025342132d--------------------------------" rel="noopener" target="_blank">凯尔</a>或<a class="ae ky" href="https://twitter.com/getify" rel="noopener ugc nofollow" target="_blank"> @getfiy </a>作者<a class="ae ky" href="https://github.com/getify/You-Dont-Know-JS" rel="noopener ugc nofollow" target="_blank"> <em class="of">你不知道JS </em> </a>的《深度JavaScript基础》。</p><p id="8d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名职业程序员，我没有深入思考我每天在工作中使用的操作符之一，这一事实激励我传播意识，并鼓励人们更多地理解并留意我们编写的代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="724a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">真理的源泉在哪里</h1><p id="9a2a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">知道真相在哪里很重要。不在Mozilla的，W3schools上，不在声称<code class="fe lv lw lx ly b">===</code>优于<code class="fe lv lw lx ly b">==</code>的百篇文章里，也绝对不在这一篇里。</p><p id="b214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu"> </strong> JavaScript规范中，你可以找到JavaScript如何工作的文档。</p><div class="og oh gp gr oi oj"><a href="https://tc39.es/ecma262/#sec-abstract-equality-comparison" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">ECMAScript 2020语言规范</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">编辑描述</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">tc39.es</p></div></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6408" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">打破神话</h1><h2 id="8f78" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">1.==仅检查值(宽松)</h2><p id="f163" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果我们看一下规范，从定义中可以很清楚地看出，算法做的第一件事实际上是检查类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/6a828d61e7e505afbe4098968bc30c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtLIMvTkIe-4RlSEmzoiSA.png"/></div></div></figure><h2 id="32b6" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">2.===检查值和类型(严格)</h2><p id="7c17" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在这里，我们同样可以从规范中看到，它检查类型，如果它们不同，它根本不检查值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/994fa9f5d3786e9e983341dda10076ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3tOiO0nvNEtbfGVck1B8A.png"/></div></div></figure><p id="44c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双重平等和三重平等的真正区别在于我们是否允许强迫。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f9c9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JavaScript中的强制</h1><p id="e0e3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">强制或类型转换是任何编程语言的基础之一。这对于动态类型化的语言(如JavaScript)更为重要，因为如果类型改变，编译器不会对你大喊大叫。</p><p id="c336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解强制意味着我们能够像JavaScript那样解释我们的代码，因此，给我们更多的可扩展性和最小化错误。</p><h2 id="61cf" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">显性胁迫</h2><p id="dbea" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">当程序员调用这些方法中的一个，从而强制改变变量的类型时，强制可以显式地发生。</p><p id="3b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Boolean(), Number(), BigInt(), String(), Object()</code></p><p id="b656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="5960" class="nc mh it ly b gy nd ne l nf ng">let x = 'foo';</span><span id="353b" class="nc mh it ly b gy nh ne l nf ng">typeof x // string</span><span id="f5bc" class="nc mh it ly b gy nh ne l nf ng">x = Boolean('foo')</span><span id="3e15" class="nc mh it ly b gy nh ne l nf ng">typeof x // boolean</span></pre><h2 id="30f3" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">隐性强制</h2><p id="8a96" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在JavaScript中，变量是弱类型的，所以这意味着它们可以自动转换(隐式强制)。当我们使用算术运算<code class="fe lv lw lx ly b">+ / — *</code>、上下文或者使用<code class="fe lv lw lx ly b">==</code>时，通常就是这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="322b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隐式强制是一把双刃剑，明智地使用它可以增加可读性，减少冗长。误用或误解，你有一个失望的公式，人们咆哮和指责JavaScript。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be72" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简单地说，等式算法</h1><h2 id="9207" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">抽象相等比较==</h2><ol class=""><li id="fdae" class="np nq it lb b lc nk lf nl li pf lm pg lq ph lu nu nv nw nx bi translated">如果X和Y的类型相同，执行<code class="fe lv lw lx ly b">===</code>。</li><li id="8042" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果X是<code class="fe lv lw lx ly b">null</code>，Y是<code class="fe lv lw lx ly b">undefined</code>或者反过来——<code class="fe lv lw lx ly b">true</code>。</li><li id="b127" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果一个是数字，强制另一个是数字。</li><li id="2c7c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果一个是对象，则强制为基元。</li><li id="5452" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">返回<code class="fe lv lw lx ly b">false</code>。</li></ol><h2 id="3315" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">严格相等比较===</h2><ol class=""><li id="39a5" class="np nq it lb b lc nk lf nl li pf lm pg lq ph lu nu nv nw nx bi translated">如果类型不匹配— <code class="fe lv lw lx ly b">false</code>。</li><li id="a21f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果类型匹配-比较值，则为NaN返回false。</li><li id="98ec" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">-0 —正确。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b6b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">流行的使用案例</h1><h2 id="53b5" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">1.相同类型(大多数情况下)</h2><p id="b40e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果类型相同，那么<code class="fe lv lw lx ly b">===</code>就是<em class="of">与</em>和<code class="fe lv lw lx ly b">==</code>完全相同。所以，你应该用更有语义的那个。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="1cca" class="nc mh it ly b gy nd ne l nf ng">1 == 1 // true                ......        1 === 1 // true</span><span id="092b" class="nc mh it ly b gy nh ne l nf ng">'foo' == 'foo' // true        ......       'foo' === 'foo' //true</span></pre><p id="2c10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"我更喜欢用<code class="fe lv lw lx ly b">===</code>，以防类型不同."</p><p id="d34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是逻辑论证，就像按了两次保存，刷新了五次。为了以防万一，我们不会在代码中两次调用一个方法，不是吗？</p><h2 id="53d5" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">2.不同类型(基本类型)</h2><p id="a935" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，我想提醒大家的是，<strong class="lb iu">不同的</strong>类型并不意味着<em class="of">未知的</em> <strong class="lb iu"> </strong>类型。</p><p id="a824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不知道类型表明你的代码中存在比仅仅使用<code class="fe lv lw lx ly b">===</code> vs. <code class="fe lv lw lx ly b">==</code>更大的问题。</p><p id="72bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解类型表明对代码有更深的理解，这将导致更少的错误和更可靠的软件。</p><p id="f6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们有几种可能类型的情况下，通过理解强制，我们现在可以选择强制或不强制，因此使用<code class="fe lv lw lx ly b">===</code>或<code class="fe lv lw lx ly b">==</code>。</p><p id="6599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个数字或者一个字符串的可能性。</p><p id="cfd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，算法更喜欢数字，所以它会尝试使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://tc39.es/ecma262/#sec-tonumber" rel="noopener ugc nofollow" target="_blank">toNumber()</a></code>。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="558b" class="nc mh it ly b gy nd ne l nf ng">let foo = 2;<br/>let bar = 32; // number or string</span><span id="f397" class="nc mh it ly b gy nh ne l nf ng">foo == bar // if bar is string it will be coreced to number</span><span id="7dd9" class="nc mh it ly b gy nh ne l nf ng">foo === Number(bar) // doing basically the same</span><span id="cd99" class="nc mh it ly b gy nh ne l nf ng">foo === bar // would always fail if bar comes as string</span></pre><h2 id="d227" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">3.空且未定义</h2><p id="5644" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">==</code>时<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>都相等。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="93cc" class="nc mh it ly b gy nd ne l nf ng">let foo = null<br/>let bar = undefined; </span><span id="8335" class="nc mh it ly b gy nh ne l nf ng">foo == bar // true</span><span id="cb42" class="nc mh it ly b gy nh ne l nf ng">foo === bar // false</span></pre><h2 id="4c6e" class="nc mh it bd mi os ot dn mm ou ov dp mq li ow ox ms lm oy oz mu lq pa pb mw pc bi translated">4.非本原[对象，数组]</h2><p id="3ebd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">不应该使用<code class="fe lv lw lx ly b">==</code>或<code class="fe lv lw lx ly b">===</code>来比较对象和数组等非基本元素。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b556" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">决策指南</h1><ol class=""><li id="8143" class="np nq it lb b lc nk lf nl li pf lm pg lq ph lu nu nv nw nx bi translated">在所有可以使用的情况下优先选择<code class="fe lv lw lx ly b">==</code>。</li><li id="d492" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">==</code>用已知的类型，当你想强制转换类型时可选。</li><li id="4e25" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">知道类型总比不知道好。</li><li id="0ad9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">不知道类型就不要用<code class="fe lv lw lx ly b">==</code>。</li><li id="611b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果知道类型，<code class="fe lv lw lx ly b">==</code>就是<code class="fe lv lw lx ly b">===</code>。</li><li id="d1ac" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当类型不匹配时<code class="fe lv lw lx ly b">===</code>是没有意义的。</li><li id="786b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">类型匹配时不需要<code class="fe lv lw lx ly b">===</code>。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2c4b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">避免的理由== </strong></h1><p id="8c87" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">有些情况下，如果没有真正理解JavaScript中的falsy值，就不应该使用<code class="fe lv lw lx ly b">==</code>。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="3c3b" class="nc mh it ly b gy nd ne l nf ng">== with 0 <!-- -->or "" or "   "</span><span id="5cdf" class="nc mh it ly b gy nh ne l nf ng">== with non primtives</span><span id="910b" class="nc mh it ly b gy nh ne l nf ng">== true  or  == false</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b36e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="a49e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">根据我的经验，到目前为止，我总是知道我正在处理的变量的类型，如果我不知道，我使用<code class="fe lv lw lx ly b">typeof</code>只允许我期望的类型。</p><p id="193e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于滚动到帖子末尾的人，这里有四点建议。</p><ol class=""><li id="1f15" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">如果你不能或者不愿意知道类型，使用<code class="fe lv lw lx ly b">===</code>是唯一合理的选择。</li><li id="a781" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">不知道类型可能意味着你不理解代码，尝试重构你的代码。</li><li id="1c6a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">了解类型可以产生更好的代码。</li><li id="a09e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果类型已知，最好使用<code class="fe lv lw lx ly b">==</code>，否则返回<code class="fe lv lw lx ly b">===</code>。</li></ol><p id="836e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，希望这篇文章对你加深对JavaScript的理解有所帮助。我建议你去看看<em class="of">你不知道的JS </em>系列，因为这是一个充满深度知识的矿井。</p><div class="og oh gp gr oi oj"><a href="https://github.com/getify/You-Dont-Know-JS" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">getify/你不知道</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">JavaScript系列丛书。推特上的@YDKJS。为getify/You-don-Know-JS开发做出贡献，创建一个…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oj"/></div></div></a></div></div></div>    
</body>
</html>