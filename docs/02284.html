<html>
<head>
<title>Working Around the Shortfalls of SwiftUI’s TabView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决SwiftUI的TabView的不足</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-around-the-shortfalls-of-swiftuis-tabview-ac9aa2a9d894?source=collection_archive---------2-----------------------#2019-11-19">https://betterprogramming.pub/working-around-the-shortfalls-of-swiftuis-tabview-ac9aa2a9d894?source=collection_archive---------2-----------------------#2019-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">6-tab问题，以及如何使用UITabBarController来解决它</h2></div><p id="33c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更新(2019–12–19):</em><a class="ae lc" href="https://medium.com/@thomasjsvos/hey-this-is-a-very-nice-workaround-but-i-still-have-some-issues-with-the-navigation-bar-6f900d90ef88" rel="noopener"><em class="lb">有读者提到，对于“更多”页签</em> </a> <em class="lb">，他们不能使用</em>  <code class="fe ld le lf lg b"><a class="ae lc" href="https://medium.com/@thomasjsvos/hey-this-is-a-very-nice-workaround-but-i-still-have-some-issues-with-the-navigation-bar-6f900d90ef88" rel="noopener"><em class="lb">NavigationView</em></a></code> <a class="ae lc" href="https://medium.com/@thomasjsvos/hey-this-is-a-very-nice-workaround-but-i-still-have-some-issues-with-the-navigation-bar-6f900d90ef88" rel="noopener"> <em class="lb">。写完这篇文章不久，我就遇到了这个问题。可惜的是，没有办法使用</em> <code class="fe ld le lf lg b"><em class="lb">NavigationView</em></code> <em class="lb">和你</em> <strong class="kh ir"> <em class="lb">拥有</em> </strong> <em class="lb">才能使用</em> <code class="fe ld le lf lg b"><em class="lb">UITabBarController</em></code> <em class="lb">的导航控制器配合这个方案。实际上，我已经受够了这一点，并决定在SwiftUI中实现一个完全模仿苹果标签栏功能的自定义标签栏。你可以在这里查看解释我如何做的文章</em> </a><a class="ae lc" href="https://medium.com/@ardactugay/diving-deep-into-swiftui-a-simple-custom-tab-bar-part-1-of-5-680d05d7f99b" rel="noopener"> <em class="lb">，</em> </a> <em class="lb">，但是这个解决方案要复杂得多。你仍然应该阅读这篇文章，因为我做了一些调试，得到了一些关于SwiftUI如何工作的有用信息！</em></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/119f4373f15c2ead5c278fb2611c08f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXB3nRNc37uuA2y97GiWEQ.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">寻找解决方案！(图片由阿尔达·c·图盖提供)</p></figure><p id="c54d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的五年里，我主要专注于后端开发，最近我决定尝试一下iOS应用程序开发。我以前在工作中尝试过它，以在移动开发者人手不足时为他们提供支持，但我从未花时间认真学习如何开发iOS应用程序。我认为这是最好的时机，SwiftUI将于今年秋天发布。它吸引了我，特别是随着<code class="fe ld le lf lg b">Combine</code>框架的引入，因为我以前使用过反应式编程。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="80d3" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">包含6个或更多选项卡的选项卡视图</h1><p id="5f0b" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">我从<a class="ae lc" href="https://developer.apple.com/videos/play/wwdc2019/237/" rel="noopener ugc nofollow" target="_blank"> WWDC第237期</a>开始了解<code class="fe ld le lf lg b">Views</code>是如何运作的，然后就一头扎进了一个项目。然而，我很快就被一堵墙的bug击中了，其中很多都在<code class="fe ld le lf lg b">TabView</code>。我开发的应用程序将有七个选项卡项目，我做了以下工作来实现这一点:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="dbe8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单吧？我使用了<a class="ae lc" href="https://developer.apple.com/documentation/swiftui/tabview" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中的简单概述。它看起来很棒，直到我试用它并注意到两个问题。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="4297" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">首要问题</h1><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d4b343c64b0db71d62bfe73898f08443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/1*J_Ia9oRSrmC-oUe4HrN1HA.gif"/></div></figure><p id="62ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">轻按“更多”,然后轻按行，应该会用文本视图显示它们各自的视图，但不会。</p><p id="b618" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您有六个或更多的标签栏项目时，<code class="fe ld le lf lg b">TabView</code>会自动用更多的标签替换第五个标签，并在表格视图中将其余的标签栏项目显示为行。你会注意到，在点击更多之前，点击任何标签栏项目都会显示其相关视图。但是，点击任何一行都会导航到一个空视图。我认为这需要更多的调查，所以我决定在Xcode中使用调试器来调查视图层次结构。</p><h2 id="4be5" class="ne mf iq bd mg nf ng dn mk nh ni dp mo ko nj nk mq ks nl nm ms kw nn no mu np bi translated">当第一个标签激活时</h2><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nq"><img src="../Images/ae60b97eb1b39b9291c0e54080b1a28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ize1xmeCtIwfXr8-w66Mjw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">SwiftUI文本位于UIHostingController内部。SwiftUI的TabView内部使用<code class="fe ld le lf lg b">UITabBarController</code>。</p></figure><p id="d178" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在上面看到苹果使用了引擎盖下的<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbarcontroller" rel="noopener ugc nofollow" target="_blank">UITabBarController</a></code>！<strong class="kh ir"> </strong>它们通过将SwiftUI视图封装在<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/swiftui/uihostingcontroller" rel="noopener ugc nofollow" target="_blank">UIHostingController</a></code>中来显示它。这感觉很熟悉；苹果在他们的<a class="ae lc" href="https://developer.apple.com/tutorials/swiftui/interfacing-with-uikit" rel="noopener ugc nofollow" target="_blank"> SwiftUI教程中就是这么做的，用于与UIKit </a>接口。至少他们在身体力行！</p><p id="1efa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这实际上是一个好消息，因为根据<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbarcontroller" rel="noopener ugc nofollow" target="_blank">UITabBarController</a></code>文档，它应该处理标签栏项目选择，并自动生成我们在上面的视频中看到的更多视图。太好了，但是为什么不管用？</p><h2 id="0b25" class="ne mf iq bd mg nf ng dn mk nh ni dp mo ko nj nk mq ks nl nm ms kw nn no mu np bi translated">当第六个标签激活时</h2><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nq"><img src="../Images/99255542c037edfd5db39db39fc10660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP5XjS5AY-_5JKgPC9c_Ug.png"/></div></div></figure><p id="e0b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的SwiftUI视图不再显示。它甚至没有被包在一个<code class="fe ld le lf lg b">UIHostingControlle</code> r里面。</p><p id="9cd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与上面的选项卡栏项目视图相比，您会注意到有所不同。有个<code class="fe ld le lf lg b">UIMoreNavigationController</code>，意料之中；在<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbarcontroller#1653016" rel="noopener ugc nofollow" target="_blank">UITabBarController</a></code>文档中,“更多导航控制器”部分解释了为什么会在这里。</p><p id="001e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但令人惊讶的是，我们的SwiftUI视图不再显示。事实上，一个<code class="fe ld le lf lg b">UIHostingController</code>甚至不存在。这感觉像是个bug。似乎苹果忘记了处理使用<code class="fe ld le lf lg b">TabView</code>时可能出现六个或更多标签的情况。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e4dc" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第二个问题</h1><p id="82bf" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">还有另一个问题，在重新排列标签栏项目时出现，这是<code class="fe ld le lf lg b">TabView</code>的另一个内置功能(通过<code class="fe ld le lf lg b">UITabBarController</code>):</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7d52299679cccf92d53adcb9ac4c538b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/1*0xAU-F2QXVHG_s9TiHAMnQ.gif"/></div></figure><p id="8bc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新排列选项卡栏项目后，TabView不考虑这些更改并自行重置。</p><p id="8673" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，重新排列的标签栏项目甚至不被尊重。<code class="fe ld le lf lg b">TabView</code>只是重置回原来的状态！我认为这可能是因为我没有明确地给每个标签栏项目分配<code class="fe ld le lf lg b">tag</code>值(我在使用<code class="fe ld le lf lg b">UITabBarController</code>和初始化单个<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbaritem/1617056-init" rel="noopener ugc nofollow" target="_blank">UITabBarItems</a></code>时已经这样做了)，但是在每个<code class="fe ld le lf lg b">tabItem</code>上使用<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/swiftui/tabview/3367703-tag" rel="noopener ugc nofollow" target="_blank">tag(_:)</a></code>也没有帮助。</p><p id="32c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，考虑到缺少<code class="fe ld le lf lg b">TabView</code>的文档，我放弃了尝试让<code class="fe ld le lf lg b">TabView</code>按照我想要的方式运行，决定直接使用<code class="fe ld le lf lg b">UITabBarController</code>并将其嵌入SwiftUI。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9c93" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">将UITabBarController与SwiftUI一起使用</h1><p id="7949" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">…以及在选项卡栏项目内容中嵌入SwiftUI视图。</p><p id="ef04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先创建一个新的SwiftUI视图文件，将其命名为<code class="fe ld le lf lg b">UITabBarWrapper</code>。第一次创建时，它看起来像这样:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f65c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们在这里为UIKit <code class="fe ld le lf lg b">UITabBarController</code>添加一个包装器。它必须符合<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewControllerRepresentable</a></code>协议:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ul class=""><li id="b39c" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated">我们在这里使用<code class="fe ld le lf lg b">fileprivate</code>来保持<code class="fe ld le lf lg b">UITabBarControllerWrapper</code>专用于这个文件，因为它不会在其他地方使用。我们需要符合<code class="fe ld le lf lg b">UIViewControllerRepresentable</code>，因为我们想在SwiftUI中表示一个UIKit视图控制器。</li><li id="6e2f" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">来自<code class="fe ld le lf lg b">UIViewControllerRepresentable</code>的第一个必需的实例方法。这是我们创建<code class="fe ld le lf lg b">UITabBarController</code>并在返回之前对其进行配置的地方。</li><li id="7eaf" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">第二个必需的实例方法来自<code class="fe ld le lf lg b">UIViewControllerRepresentable</code>。SwiftUI调用这个函数来通知UIKit，SwiftUI端有一个更新，UIKit视图控制器需要更新。我们只需在这里为每个选项卡的内容设置视图控制器。需要时，您可以做任何需要做的额外工作来更新<code class="fe ld le lf lg b">UITabBarController</code>。</li><li id="371b" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">协调器与更新方法相反；当UIKit端发生变化时，它会向SwiftUI发送更新。在这种情况下，我只是包含了一个模板，但我们不会使用它。</li></ul><p id="5602" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们使用<code class="fe ld le lf lg b">UITabBarControllerWrapper</code>之前，我们需要定义一个新的SwiftUI视图，它将封装我们想要在每个选项卡中显示的内容。让我们从创建另一个名为<code class="fe ld le lf lg b">TabBarElement</code>的SwiftUI视图文件开始。它看起来会和我们创建<code class="fe ld le lf lg b">UITabBarWrapper</code>时一样。</p><p id="31d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们给这个文件添加一个新的结构和协议:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ul class=""><li id="a9b6" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated">这个结构将包含标签栏项目的标题和我们将为它使用的系统图像名称。我稍后会解释为什么我们要创建这个结构。</li><li id="a732" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">这个协议定义了一个标签栏项目应该包含什么，这样我们的<code class="fe ld le lf lg b">UITabBarWrapper</code>就知道在这个项目的标签栏上显示什么，以及它的内容将会是什么。</li></ul><p id="63e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了我们需要的一切，让我们在<code class="fe ld le lf lg b">TabBarElement</code>中使用它们:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ul class=""><li id="f4e0" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated">我们有<code class="fe ld le lf lg b">TabBarElement</code>符合<code class="fe ld le lf lg b">TabBarElementView</code>，因为<code class="fe ld le lf lg b">TabBarElementView</code>符合<code class="fe ld le lf lg b">View</code>，并且它有我们将需要的附加属性。</li><li id="4334" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">我们用类型<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/swiftui/anyview" rel="noopener ugc nofollow" target="_blank">AnyView</a></code>定义了<code class="fe ld le lf lg b">TabBarElementView</code>协议所需的实例变量，这是一个类型擦除的<code class="fe ld le lf lg b">View</code>。我们需要使用<code class="fe ld le lf lg b">AnyView</code>来允许<code class="fe ld le lf lg b">TabBarElement</code>接受任何类型的视图，而不必担心指定泛型类型。当我们在<code class="fe ld le lf lg b">UITabBarWrapper</code>中使用<code class="fe ld le lf lg b">TabBarElement</code>时，您将会看到这是如何应用的。</li><li id="790e" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/swiftui/viewbuilder" rel="noopener ugc nofollow" target="_blank">@ViewBuilder</a></code>是一个参数属性，允许从闭包构建视图。这是Apple为其所有SwiftUI视图所使用的，以便您可以使用类似DSL的语法来创建视图(如果您想了解更多关于该参数属性如何工作的信息，请查看<a class="ae lc" href="https://blog.vihan.org/swift-function-builders/" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章，</a>因为关于该功能的官方文档仍然缺乏。还有一个很棒的<a class="ae lc" href="https://github.com/carson-katri/awesome-function-builders" rel="noopener ugc nofollow" target="_blank"> GitHub资源</a>供所有类型的使用这个特性的库使用。</li><li id="f2e3" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">由于<code class="fe ld le lf lg b">content</code>的类型是<code class="fe ld le lf lg b">AnyView</code>，我们必须删除作为初始化器参数提供的<code class="fe ld le lf lg b">content</code>。</li><li id="62b3" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">我们的<code class="fe ld le lf lg b">TabBarElement</code>视图的主体使用用户传递给它的<code class="fe ld le lf lg b">content</code>。您可以在预览结构中看到这样的示例。</li></ul><p id="f5c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们准备完成<code class="fe ld le lf lg b">UITabBarWrapper</code>！</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ul class=""><li id="f856" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated">我们创建了一个变量来保存<code class="fe ld le lf lg b">UITabBarController</code>需要的所有控制器。注意，我们将类型定义为一个数组<code class="fe ld le lf lg b">UIHostingController&lt;TabBarElement&gt;</code>，但是我们的初始化器想要一个数组<code class="fe ld le lf lg b">TabBarElements</code>。这是有意的，允许我们的<code class="fe ld le lf lg b">UITabBarWrapper</code>用户完全在SwiftUI中工作，而不必担心UIKit(即关注点分离)！</li><li id="2077" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">我们枚举元素，然后映射它们，本质上模拟了一个具有索引功能的<em class="lb">映射。<code class="fe ld le lf lg b">$0</code>成为索引，而<code class="fe ld le lf lg b">$1</code>是闭包中的<code class="fe ld le lf lg b">TabBarElement</code>元素。</em></li><li id="eb22" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">如果你查看<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbarcontroller" rel="noopener ugc nofollow" target="_blank">UITabBarController</a></code>文档，你必须定义<code class="fe ld le lf lg b">tabBarItem</code>。</li></ul><p id="6127" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选项卡栏项目通过其对应的视图控制器进行配置。要将一个选项卡栏项目与一个视图控制器相关联，创建一个新的<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uitabbaritem" rel="noopener ugc nofollow" target="_blank">UITabBarItem</a></code>类实例，为视图控制器适当地配置它，并将其分配给视图控制器的<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621175-tabbaritem" rel="noopener ugc nofollow" target="_blank">tabBarItem</a></code>属性。如果你没有为你的视图控制器提供一个定制的标签栏项目，视图控制器会创建一个默认项目，不包含图像和来自视图控制器的<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621364-title" rel="noopener ugc nofollow" target="_blank">title</a></code>属性的文本。</p><p id="5872" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ld le lf lg b">tabBarItem</code>实例方法实际上是在<code class="fe ld le lf lg b"><a class="ae lc" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621175-tabbaritem" rel="noopener ugc nofollow" target="_blank">UIViewController</a></code>上定义的，所以<code class="fe ld le lf lg b">UITabBarController</code>只是继承了它。</p><ul class=""><li id="9be2" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated">我们将元素的索引指定为标签栏项目的标签。如果你愿意，你可以自定义它！</li><li id="6374" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">最后，我们将所有控制器传递给符合<code class="fe ld le lf lg b">UIViewControllerRepresentable</code>的结构，它按照我们的要求初始化并更新我们的<code class="fe ld le lf lg b">UITabBarController</code>。</li></ul><p id="c013" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们终于准备好使用我们的新<code class="fe ld le lf lg b"><strong class="kh ir">UITabBarController</strong></code> <strong class="kh ir">！</strong></p><p id="6758" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将把它放在我的<code class="fe ld le lf lg b">ContentView</code>基本视图中:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0a6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我运行它时的样子:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e87fe30ca9e8832e3ecfd85d9ec91a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/1*5CYaU6Ai_Ct7wfHLgnuP1A.gif"/></div></figure><p id="965b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有用！在苹果修复这些错误并更新他们的文档以获得更多细节之前，我将使用原来的<code class="fe ld le lf lg b">UITabBarController</code>。</p><p id="247f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！我希望这能帮助任何有类似问题的人。</p></div></div>    
</body>
</html>