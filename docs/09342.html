<html>
<head>
<title>How to Use Async/Await in JavaScript Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专业人士一样在JavaScript中使用Async/Await</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-how-to-use-async-await-like-a-pro-481a5b829bf0?source=collection_archive---------1-----------------------#2021-08-12">https://betterprogramming.pub/learn-how-to-use-async-await-like-a-pro-481a5b829bf0?source=collection_archive---------1-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3233" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解JavaScript的强大工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17ccedf59e3814891b75ecbdf8fa0d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej8WJLvjwuFntD9Kkc14jg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/person-encoding-in-laptop-574071/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae ky" href="https://www.pexels.com/@goumbik?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">卢卡斯</a>的照片</p></figure><p id="a9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个程序员的一生中，总有一天他们需要知道如何处理异步代码。</p><p id="2377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次理解如何处理异步代码可能有点令人生畏。幸运的是，我在这里解释这一切是如何工作的，这样当这种情况出现时，你可以更好地准备。</p><p id="d176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，我们应该知道同步代码和异步代码的区别。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是异步代码？</h1><p id="e128" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">异步被定义为在不同时间发生的两个或多个事件。通过下面的例子，我们可以更好地理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以清楚地看到我们的代码按照我们期望的顺序执行。我们称之为同步代码。</p><p id="df61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写的很多东西都被认为是同步的，但是当我们试图在执行其他行之前延迟其中一行时会发生什么呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dcaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等…我们的产出怎么了？</p><p id="c80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的输出有点杂乱无章，没有任何意义。实际上，我们的代码应该同时执行，并等待超时结束后再继续，但事实并非如此。</p><p id="da08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生的情况是，超时函数与其余代码同时被调用，但直到500毫秒后才触发我们的内部日志，给我们错误的输出。</p><p id="3d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行代码的执行时间与其他代码不同。我们称之为异步。</p><p id="0541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何解决这个问题呢？</p><p id="ed9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要一种方法来停止其余代码的执行，直到我们的超时函数完成。幸运的是，JavaScript给了我们这样做的工具。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">承诺</h1><p id="258a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道你可能在想什么…不，我不是在说尼禄2011年的歌…我是在说JavaScript的承诺。</p><p id="6533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺可以想象成一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank">回调函数</a> <strong class="lb iu">。像回调函数一样，promise在返回值之前等待我们的内部代码完成。</strong></p><p id="75b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的区别是，一旦我们的异步代码完成，我们的承诺返回一个状态，允许我们使用<code class="fe nb nc nd ne b">then()</code>和<code class="fe nb nc nd ne b">catch()</code>等方法采取进一步的行动。</p><p id="a23c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">旁注:</em>在本文中，我不会深入研究承诺，但我只想让您理解基本概念，因为它们在以后会很重要。</p><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的例子。如您所见，我们的输出再次恢复正常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是怎么发生的呢？</p><p id="42dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我前面提到的，承诺允许我们在执行其余部分之前等待异步代码完成。在这个例子中，您可以看到我们已经将超时函数包装在一个承诺中，以修复这个问题。</p><p id="a3c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们的超时函数完成，我们就解析我们的承诺，并告诉我们的代码可以继续进一步执行。在我们的承诺成功之后，我们使用<code class="fe nb nc nd ne b">then()</code> <strong class="lb iu"> </strong>来执行剩余的同步代码，就像之前一样。</p><p id="73d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的承诺没有实现，反而被拒绝了。我们的产量会有什么变化？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="43d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，如果我们的承诺被拒绝，就会调用<code class="fe nb nc nd ne b">catch()</code>方法，在我们的例子中，它会记录一条错误消息并退出剩余的代码。当这种情况发生时，我们不需要记录错误。</p><p id="e9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有条件地，我们可以说，“如果我们的承诺被拒绝，那么继续我们的代码”，而不是在失败时停止。</p><p id="4048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引入承诺可以使处理异步代码变得容易得多，但是我们开始链接的承诺越多，我们的代码就变得越复杂，可读性就越差。</p><p id="cbf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这不是最好的解决方案，那么什么是呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2954" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">输入异步/等待</h1><p id="023d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过利用JavaScript的async/await关键字，我们可以使我们的代码更加完美，可读性更好。让我们看看在前面的例子中使用async/await时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来好多了！</p><p id="08fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看一下上面的例子，我们可以看到我们的输出仍然和以前一样。以这种方式编写代码可以让我们避免承诺链，同时保持可读性。</p><p id="0499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过从前面获取相同的异步代码来实现的，除了这次我们在函数前面添加了<code class="fe nb nc nd ne b">await</code>关键字，并存储我们得到的承诺的结果。</p><p id="e38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行我们的代码时，我们的主函数将等待我们的<code class="fe nb nc nd ne b">async_func</code> <em class="nf"> </em>解析，然后执行我们代码的剩余部分。</p><p id="414b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将剩余的同步代码包装在一个名为<code class="fe nb nc nd ne b">main()</code>的函数中，并使用了<code class="fe nb nc nd ne b">async</code>关键字。正如承诺有规则一样，我们也必须遵循async/await的规则，这样才能工作。</p><p id="33e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则规定，如果我们想要使用<code class="fe nb nc nd ne b">await</code> <em class="nf"> </em>关键字，那么它必须包含在<code class="fe nb nc nd ne b">async</code>函数中。这就是通知我们的函数的内容，它说:“我应该期待内部的异步代码”。</p><p id="7e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们想在上面的例子中添加另一段异步代码。会发生什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在这个例子中，我们添加了另一个异步代码块，我们的输出仍然是我们期望的顺序。</p><p id="eeba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果仔细观察，您会发现第二个异步函数被设置为在第一个函数之前30毫秒运行。那么为什么没有呢？</p><p id="5043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在同步情况下，第二个函数确实会在第一个函数之前被调用，我们会得到错误的输出。</p><p id="50f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用的是async/await，我们的代码在第一个函数处停止，等待530ms来解析。然后继续执行第二个函数，并在被解析之前等待500毫秒，这就是async/await的强大之处。</p><p id="6acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用async/await的更实际的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ea31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们模拟了一个对后端的调用，并检索了一个字符列表，我们需要用它来检查冒名顶替者。</p><p id="3dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的main函数中，我们等待使用关键字<code class="fe nb nc nd ne b">await</code>解析我们的承诺，这反过来会给出我们所请求的字符列表。</p><p id="ceaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用reduce方法获得每个字符的计数，并存储找到它们的索引以及它们的名称。</p><p id="b624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成之后，我们过滤掉我们的<code class="fe nb nc nd ne b">counts</code>对象中任何计数为1的字符，然后将其映射到我们的<code class="fe nb nc nd ne b">imposters</code>数组。</p><p id="f8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们显示<code class="fe nb nc nd ne b">imposters</code>的列表，并揭示它们在我们的角色数据中的位置。</p><p id="cf29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在这个实际的例子中没有使用<code class="fe nb nc nd ne b">async/await</code>,我们将会面临导致错误代码的错误。</p><p id="f515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并不是所有的异步代码都会提醒我们一个值得注意的问题，所以了解这些情况会在哪里出现并以最好的方式处理它们是一个很好的实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="512c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8cda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好了，你知道了。试图弄清楚如何处理异步代码肯定是一个挑战，尤其是第一次看到它。您接触异步代码越多，就越能更好地处理这种情况。</p><p id="4c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这能让你对async/await的工作原理有所了解，在你知道之前，你很快就会成为一名JavaScript专家。</p><p id="dabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>