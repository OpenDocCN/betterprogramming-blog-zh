# 使用 JavaScript 混合插件——好的部分

> 原文：<https://betterprogramming.pub/using-javascript-mixins-the-good-parts-5be6fdd46ef0>

## 如果你正在使用 JavaScript mixins，你应该做什么

![](img/c512b69e9fc749e380d1abad0245c121.png)

在我们开始使用某样东西之前，我们需要了解它是什么，以及我们可以用它来实现什么。

# 什么是 Mixin？

> “mixin 是一个抽象子类；即可以应用于不同超类以创建相关的修改类族的子类定义—吉拉德·布拉查和威廉·库克，[基于 Mixin 的继承](http://www.bracha.org/oopsla90.pdf)

让我们以伐木为例。假设您有三页:

*   红色
*   格林（姓氏）；绿色的
*   蓝色

```
 +----------+
              |   Page   |
              +----------+
                |  |  |
     +----------+  |  +-----------+
     |             |              |
+---------+ +-----------+ +----------+
| PageRed | | PageGreen | | PageBlue |
+----+----+ +-----------+ +----------+
```

现在，每当有人上`PageRed`时，我们都要记录。为了存档，我们扩展了`PageRed`并创建了一个日志`PageRed`。

```
 +----------+
              |   Page   |
              +-+--+--+--+
                |  |  |
     +----------+  |  +-----------+
     |             |              |
+----+----+  +-----+-----+  +-----+----+
| PageRed |  | PageGreen |  | PageBlue |
+----+----+  +-----------+  +----------+
     |
+----+----+
| Logged  |
| PageRed |
+---------+
```

如果我们想开始为`PageGreen`记录日志，我们会遇到一个问题:

*   我们不能把逻辑放在`Page`中，因为蓝色不应该被记录。
*   我们不能重用`Logged PageGreen`中的逻辑，因为我们不能从两个来源扩展(即使我们可以，也意味着红色和绿色的信息冲突)。

我们能做的就是把它放在一个“外在”的地方，把它写出来，这样它就可以“混进去”了。

```
 +----------+                +----------+
               |   Page   |                | Logging* |
               +-+--+--+--+                +----------+
                 |  |  |
      +----------+  |  +-----------+
      |             |              |
+-----+----+  +-----+-----+  +-----+----+
| PageRed  |  | PageGreen |  | PageBlue |
|  with    |  |   with    |  +----------+
| Logging* |  |  Logging* |
+----------+  +-----------+
```

使用这种方法，我们可以将逻辑提取到单独的代码片段中，以便在需要时使用。

要获得更深入的技术解释，请阅读 [*带有 JavaScript 类的 Real Mixins*](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/)。

# 为什么有必要对 Mixins 进行重复数据删除？

我们现在希望将所有日志记录到红色、绿色和蓝色页面。很简单，因为我们现在可以在页面上应用`LoggingMixin`。

```
 +----------+               +----------+
               |   Page   |               | Logging* |
               |   with   |               +----------+
               | Logging* |
               +-+--+--+--+
                 |  |  |
      +----------+  |  +-----------+
      |             |              |
+-----+----+  +-----+-----+  +-----+----+
| PageRed  |  | PageGreen |  | PageBlue |
+----------+  |   with    |  +----------+
              |  Logging* |
              +-----------+
```

然而，绿色团队急于发布，所以他们已经将`LoggingMixin`应用到他们的`Page`类中。当我们将它应用到基类`Page`时，`Mixin`现在被应用了两次…

突然，绿色页面将每个日志打印两次——这不是我们最初的想法。

我们需要做的是确保每个 mixin 只被附加一次，即使我们试图多次应用它。

一般来说，mixin 越通用，它被多次应用的机会就越大。

作为一个 mixin 作者，你不能控制它如何被使用，也不能总是预测它。因此，作为一项安全措施，始终建议创建重复数据删除混合。

您可以在演示中看到这种情况。

通过将`dedupeMixin`应用于`mixin`函数，在我们导出它之前，我们可以确定我们的`mixin`类只会生效一次，即使它被混合到继承链中的多个基类中。

*   `[no-dedupe](https://open-wc.org/dedupe-mixin/demo/no-dedupe/)`“失败”记录绿色两次。
*   `[with-dedupe](https://open-wc.org/dedupe-mixin/demo/with-dedupe/)`“成功”也记录一次绿色。

你可以在 [GitHub](https://github.com/open-wc/open-wc/tree/master/packages/dedupe-mixin/demo-typed) 上查看两者的源代码。

# 嵌套示例

您可能认为上面的例子太简单了，可以通过调整何时进行更改来解决。

然而，在大多数真实场景中，情况要复杂得多。mixin 是可以扩展的，仅仅因为你导入了一个类，并不意味着这个类已经预先应用了一些 mixin。

考虑这个例子:

```
+----------+
| Logging* |
+----+-----+
     |         +----------+                  +----------+
+----+-----+   |   Page   |                  | Feature  |
| Metrics* |   |   with   |                  |   with   |
+----------+   | Logging* |                  | Metrics* |
               +-+--+--+--+                  +----+--+--+
                 |  |  |                          |  |
      +----------+  |  +-----------+              |  +-----+
      |             |              |              |
+-----+----+  +-----+-----+  +-----+----+  +------+-------+
| PageRed  |  | PageGreen |  | PageBlue |  | WaterFeature |
+----------+  +-----------+  |   with   |  +--------------+
                             | Metrics* |
                             +----------+
```

*   页面一般只需要日志记录。
*   然而，还有一个更高级的度量系统，它扩展了日志记录。
*   特性的度量标准是单独开发的。
*   当我们现在想要在蓝色页面上获得相同的度量时，我们得到了重复的日志记录，甚至没有有意识地应用日志记录一次(我们做了`class PageBlue extends MetricsMixin(Page) {}`)。
*   在这些情况下，只有重复数据删除能有所帮助。

# 何时不使用 Mixin

你现在可能会想:“该死，那是强大的”你是对的。我们现在应该把它用在任何事情上吗？当然不是。

只有在绝对需要访问实例本身时才使用它。这里有一些当*不*使用 mixin 的不好的例子。

## 我想做`if (this.isIE11()) { // ... }`

对于任何“纯”函数，最好将其放在类/原型之外。例句:最好这样写:

## 我想有一个特别的`this.addEventListener()`

首先，重写内置函数可能非常危险。

当在你的类中，当你需要一个非常具体的用例发生时，它可能是好的。然而，如果这在使用 mixin 时神奇地发生了，那就非常令人困惑了。

最好将这些作为一个额外的函数来传递。这样，人们可以选择这些特殊功能，而不会“污染”他们的原型链。

其次，所有的属性/方法对类/原型来说都是全局的。这意味着如果两个 mixins 使用相同的名称，就会发生冲突。

因此，确保明确地为私有/受保护的方法使用特定的名称，并确保如果您使用通用名称，则可以从 mixin name/docs 中清楚地看到。

# 何时使用 Mixin

如果您需要访问类实例本身。也就是说，如果每个实例都有不同的设置。

一个有效的例子可以是，例如，使您能够设置`myEl.locale = 'de-DE';`的`LocalizeMixin`。在这种情况下，mixin 需要提供该属性并对其做出反应。

# 我们学到了什么

使用 mixins，您可以将共享逻辑引入多个类。这是一个非常强大的工具——伴随着这种力量而来的是责任。请务必负责任地使用它，并对您的 mixins 进行重复数据删除。

# 笔记

*   用 [AsciiFlow](http://asciiflow.com/) 制作的 ASCII 图形。
*   由[瓦尼亚拍摄的照片显示](https://unsplash.com/@vaniashows?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/mixer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上。