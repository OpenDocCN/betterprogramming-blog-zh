<html>
<head>
<title>Basic Interview Data Structures in JavaScript: Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的基本访问数据结构:堆栈和队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/basic-interview-data-structures-in-javascript-stacks-and-queues-b68b5a7c82a6?source=collection_archive---------2-----------------------#2019-05-22">https://betterprogramming.pub/basic-interview-data-structures-in-javascript-stacks-and-queues-b68b5a7c82a6?source=collection_archive---------2-----------------------#2019-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="468d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">后进先出与先进先出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/781295b107e80488482d43bb4a7ef3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6NV5SBlPIqW1PxHtXeT8w.jpeg"/></div></div></figure><p id="00b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎阅读我的后续文章“<a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-509003c751fe" rel="noopener">JavaScript</a>中的基本面试数据结构”，在这篇文章中，我描述了数组、数组列表/向量、哈希映射和哈希集的JavaScript实现，供编写面试代码时使用。本文主要关注堆栈和队列。</p><p id="f97a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">堆栈和队列是面试题中常用的，使用它们可以非常高效地解决某些问题。依赖堆栈和队列的两个非常著名的算法是<em class="lr">深度优先搜索</em>和<em class="lr">宽度优先搜索</em>，两者都用于遍历一个图。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="12e2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">大量</h1><p id="7077" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">栈是一种所谓的<em class="lr">后进先出(lifo) </em>数据结构，工作起来就像一堆盘子。你可以很容易地把盘子放在盘子堆的顶部，但是如果你想从底部拿一个盘子，你首先必须把它上面的所有盘子都拿走。</p><p id="8739" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如在我的上一篇文章中一样，我将给出以下操作的运行时复杂度:</p><ul class=""><li id="dea9" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><strong class="kw iu">插入</strong>(推):O(1)</li><li id="9199" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">随机存取</strong>(存取任意元素):O(n)*</li><li id="877c" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">先访问</strong> (peek —访问最近添加的元素):O(1)</li><li id="32b9" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">查找</strong>(查找特定元素):O(n)</li><li id="a391" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">随机删除</strong>(删除任意元素):O(n)</li><li id="1e87" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">删除第一个</strong> (pop —删除最近添加的元素):O(1)</li></ul><p id="0a29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注:</strong>如果使用JavaScript数组作为堆栈，随机访问可以在O(1)中完成。</p><p id="2a1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">栈的重要操作有<code class="fe nk nl nm nn b">insert (push)</code>、<code class="fe nk nl nm nn b">remove first (pop)</code>和<code class="fe nk nl nm nn b">access first (peek)</code>。这些是栈的有效操作。如果你发现自己经常使用不同的操作，那么栈可能不是你想要的数据结构。</p><h2 id="09c4" class="no ma it bd mb np nq dn mf nr ns dp mj ld nt nu ml lh nv nw mn ll nx ny mp nz bi translated">JavaScript中的堆栈</h2><p id="893d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">JavaScript自带动态数组。这些可以非常容易地用作堆栈:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="af10" class="no ma it nn b gy oe of l og oh">const stack = [];</span><span id="05d9" class="no ma it nn b gy oi of l og oh">// insert elements (push)<br/>stack.push('one'); <br/>stack.push('two'); </span><span id="419c" class="no ma it nn b gy oi of l og oh">console.log(<!-- -->stack); <!-- -->// ['one', 'two']</span><span id="0b8a" class="no ma it nn b gy oi of l og oh">// access first (peek)<br/>console.log(<!-- -->stack[stack.length-1]); // "two"</span><span id="5d44" class="no ma it nn b gy oi of l og oh">// remove first (pop)<br/>stack.pop();</span><span id="8aef" class="no ma it nn b gy oi of l og oh">console.log(<!-- -->stack); <!-- -->// ['one']</span></pre><p id="421c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，因为我们使用的是JS数组，所以我们可以访问O(1) <em class="lr"> </em>中的任何元素，而不仅仅是最后一个。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4459" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">行列</h1><p id="f00c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">队列是一种所谓的<em class="lr">先进先出(fifo) </em>数据结构，其工作方式类似于电影院前面的队列。第一个到达电影院的人将是第一个得到票的人。另一方面，最后到达的人也将是最后收到票的人。</p><p id="c505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如在我的上一篇文章中，我将为您提供以下操作的运行时复杂性的<a class="ae lq" href="https://medium.freecodecamp.org/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4" rel="noopener ugc nofollow" target="_blank">:</a></p><ul class=""><li id="c8e6" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><strong class="kw iu">插入</strong>(入队):O(1)</li><li id="ed89" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">随机存取</strong>(存取任意元素):O(n)</li><li id="f991" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">访问最后一个</strong>(访问最近最少添加的元素):O(1)</li><li id="c9ce" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">查找</strong>(查找特定元素):O(n)</li><li id="7fe8" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">随机删除</strong>(删除任意元素):O(n)</li><li id="6728" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><strong class="kw iu">删除最后一个</strong>(出列—删除最近最少添加的元素):O(1)</li></ul><p id="5b3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">队列的基本和有效操作是插入(入队)、最后移除(出队)和最后访问(查看)。类似于栈，如果不需要上面提到的操作，就不应该使用这种数据结构。</p><h2 id="a5ee" class="no ma it bd mb np nq dn mf nr ns dp mj ld nt nu ml lh nv nw mn ll nx ny mp nz bi translated">JavaScript中的队列</h2><p id="db3b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">您可以用JavaScript数组实现一个队列，如下所示:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="e14f" class="no ma it nn b gy oe of l og oh">const queue = [];</span><span id="65a7" class="no ma it nn b gy oi of l og oh">// insert elements (enqueue)<br/>queue.push('one'); <br/>queue.push('two');</span><span id="7b0d" class="no ma it nn b gy oi of l og oh">console.log(<!-- -->queue); <!-- -->// ['one', 'two']</span><span id="1a86" class="no ma it nn b gy oi of l og oh">// access last<br/>console.log(queue<!-- -->[0]); // "one"</span><span id="16b5" class="no ma it nn b gy oi of l og oh">// remove last (dequeue)<br/>queue.shift();</span><span id="61c7" class="no ma it nn b gy oi of l og oh">console.log(queue<!-- -->); <!-- -->// ['two']</span></pre><p id="e259" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这种解决方案有一个缺点:<code class="fe nk nl nm nn b">shift</code> <strong class="kw iu"> </strong>在最坏的情况下需要O(n) <em class="lr"> </em>因为所有的数组元素都必须复制一个位置。</p><p id="9f1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几种第三方解决方案可以有效地实现队列。然而，你不能在面试中使用它们。你应该告诉你的面试官你知道JavaScript中的这个限制，并澄清你是否可以简单地使用数组作为队列，假装<code class="fe nk nl nm nn b">shift</code> <strong class="kw iu"> </strong>只需要O(1) <em class="lr">。如果这不是一个选项，你可以使用链表有效地实现一个队列(以及一个堆栈)。</em></p><p id="5bcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，您也可以从头开始实现队列。为此，您需要以下数据结构:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="874c" class="no ma it nn b gy oe of l og oh">const Node = data =&gt; ({ data, next: null, prev: null });</span></pre><p id="228b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，这看起来类似于一个双向链表(参见<a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-linked-lists-983e169db2e5" rel="noopener">我之前关于链表的文章</a>)。</p><p id="a00f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将其嵌入到队列工厂函数中:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="9594" class="no ma it nn b gy oe of l og oh">const Queue = () =&gt; {<br/>  const Node = data =&gt; ({ data, next: null, prev: null });</span><span id="c6ab" class="no ma it nn b gy oi of l og oh">  let head = null;<br/>  let tail = null;</span><span id="dfb5" class="no ma it nn b gy oi of l og oh">  ...</span><span id="fbe8" class="no ma it nn b gy oi of l og oh">  return {<br/>    enqueue,<br/>    dequeue,<br/>    peek,<br/>  };<br/>};</span></pre><p id="727c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要这个工厂函数，以便有一个包含队列头部和尾部的闭包。</p><h2 id="d3dc" class="no ma it bd mb np nq dn mf nr ns dp mj ld nt nu ml lh nv nw mn ll nx ny mp nz bi translated">插入(排队)</h2><p id="b158" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">要向队列中插入一个新元素，只需将它作为列表式数据结构的新头部:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="9268" class="no ma it nn b gy oe of l og oh">const enqueue = data =&gt; {<br/>  if (head == null) {<br/>    head = Node(data);<br/>    tail = head;<br/>    return head;<br/>  }</span><span id="dd85" class="no ma it nn b gy oi of l og oh">  const newNode = Node(data);<br/>  newNode.next = head;<br/>  head.prev = newNode;<br/>  head = newNode;<br/>  return head;<br/>};</span></pre><h2 id="778c" class="no ma it bd mb np nq dn mf nr ns dp mj ld nt nu ml lh nv nw mn ll nx ny mp nz bi translated"><strong class="ak">移除最后一个</strong>(出列)</h2><p id="f2f6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">从队列中删除最近添加的元素可以通过返回并删除列表的尾部来完成:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="5e50" class="no ma it nn b gy oe of l og oh">const dequeue = () =&gt; {<br/>  if (tail === null) return null;</span><span id="bd05" class="no ma it nn b gy oi of l og oh">  const tailData = tail.data;<br/>  if (tail.prev === null) {<br/>    tail = null;<br/>    head = null;<br/>    return tailData;<br/>  }</span><span id="92be" class="no ma it nn b gy oi of l og oh">  tail.prev.next = null;<br/>  tail = tail.prev;<br/>  return tailData;<br/>};</span></pre><p id="e0a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这相当简单，但是我们必须小心空指针。</p><h2 id="d4c5" class="no ma it bd mb np nq dn mf nr ns dp mj ld nt nu ml lh nv nw mn ll nx ny mp nz bi translated"><strong class="ak">访问最后一个(peek) </strong></h2><p id="d0f6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">要访问队列中最近使用的元素，我们只需返回列表的尾部。我们只需要考虑尾部为空的情况:</p><pre class="kj kk kl km gt oa nn ob oc aw od bi"><span id="252b" class="no ma it nn b gy oe of l og oh">const peek = () =&gt; tail ? tail.data : null;</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5fda" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="9bf2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">堆栈和队列是编码面试中非常常见和有用的数据结构。每当您需要大量访问和丢弃最近添加/最少添加的元素时，您应该考虑使用堆栈/队列。</p><p id="f1a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像Java这样的许多语言在它们的标准库中都包含了链表实现。因此，在Java中可以使用链表作为堆栈和队列。出于这个原因，你应该问你的面试官，为了简单起见，你是否可以只使用JavaScript数组作为队列，而忽略shift操作的运行时间。在大多数情况下，只要面试是语言不可知的，你的面试官会允许的。</p><p id="3ed5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这能帮助你找到下一份工作。祝你面试好运！</p><h1 id="94e2" class="lz ma it bd mb mc oj me mf mg ok mi mj jz ol ka ml kc om kd mn kf on kg mp mq bi translated">参考</h1><ul class=""><li id="c0ca" class="mw mx it kw b kx mr la ms ld oo lh op ll oq lp nb nc nd ne bi translated"><a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-509003c751fe" rel="noopener">JavaScript中的基本面试数据结构</a></li><li id="b603" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://medium.freecodecamp.org/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4" rel="noopener ugc nofollow" target="_blank">你所需要知道的关于“大O符号”的所有知识将帮助你破解下一次编码面试</a></li><li id="706e" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-linked-lists-983e169db2e5" rel="noopener">JavaScript中的基本面试数据结构—链表</a></li></ul></div></div>    
</body>
</html>