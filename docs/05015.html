<html>
<head>
<title>5 Advanced Operations Using Dictionaries in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中使用字典的5种高级操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-advanced-operations-using-dictionaries-in-python-5f8edb4719fa?source=collection_archive---------2-----------------------#2020-06-01">https://betterprogramming.pub/5-advanced-operations-using-dictionaries-in-python-5f8edb4719fa?source=collection_archive---------2-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升在项目中使用词典的技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e52866fc133f297c9158c18db4a7c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T1NF7RxHeJilEFzM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Alberto Restifo 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python灵活性的一个表现是各种数据结构的可用性，包括存储单个值的数据结构(例如整数和字符串)和存储多个值的数据结构(例如列表和元组)。对于后者，我们可以称之为容器数据类型。其中，字典是我的最爱之一。</p><p id="c5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，字典是键值对的集合。对于任何给定的字典，键必须是不同的和可散列的，并且这些键的可散列性允许搜索和更新具有<em class="lv"> O(1) </em>时间复杂度。此外，对于哪些数据类型可以存储为字典值，没有特别的要求。字典的基本用法可以总结如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们大多数人应该非常熟悉字典的这些基本操作。在这些基础上，我想在本文中介绍一些字典的中级或高级操作。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4d7e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.dict()构造函数</h1><p id="1ddb" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">大多数时候，我们习惯于创建一个用花括号括起键值对的<code class="fe nc nd ne nf b">dict</code>对象，就像上一节中显示的例子。使用花括号创建词典被称为文字法。但是，Python提供了一个非常强大的构造器方法，用于在不同场景下创建字典。</p><ul class=""><li id="6f29" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">从元组列表中创建一个<code class="fe nc nd ne nf b">dict</code>对象，每个元组存储一对键和值，如下所示:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="3562" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Create a dict object from tuples</strong><br/>&gt;&gt;&gt; dict_tuples = dict([("a", 0), ("b", 1), ("c", 2)])<br/>&gt;&gt;&gt; dict_tuples<br/>{'a': 0, 'b': 1, 'c': 2}</span></pre><ul class=""><li id="2503" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用<code class="fe nc nd ne nf b">zip()</code>函数压缩两个可重复项，创建一个<code class="fe nc nd ne nf b">dict</code> <em class="lv"> </em>对象。一个iterable用于键，另一个用于值:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="434c" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Create a dict object from two iterables</strong><br/>&gt;&gt;&gt; dict_keys = ["a", "b", "c"]<br/>&gt;&gt;&gt; dict_values = [0, 1, 2]<br/>&gt;&gt;&gt; dict_zipped = dict(zip(dict_keys, dict_values))<br/>&gt;&gt;&gt; dict_zipped<br/>{'a': 0, 'b': 1, 'c': 2}</span></pre><ul class=""><li id="e35f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用赋值操作符(<code class="fe nc nd ne nf b">=</code>)从显式键值对创建一个<code class="fe nc nd ne nf b">dict</code>对象:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="2f08" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Create a dict object from key-value assignments</strong><br/>&gt;&gt;&gt; dict_assigned = dict(a=0, b=1, c=2)<br/>&gt;&gt;&gt; dict_assigned<br/>{'a': 0, 'b': 1, 'c': 2}</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7002" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.词典理解</h1><p id="f11b" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">除了使用<code class="fe nc nd ne nf b">dict()</code>构造函数方法创建字典之外，另一种创建<code class="fe nc nd ne nf b">dict</code>对象的简便方法是使用字典理解技术。</p><p id="b193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你们中的许多人可能听说过列表理解，但是你知道我们也可以使用理解技术来创建字典吗？很直白。让我们看一个例子:</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="9c0f" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Use dictionary comprehension</strong><br/>&gt;&gt;&gt; squares = {x: x*x for x in range(5)}<br/>&gt;&gt;&gt; squares<br/>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></pre><p id="aa4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们使用字典理解创建了一个<code class="fe nc nd ne nf b">dict</code>对象，它具有以下基本语法:<code class="fe nc nd ne nf b">{key_expr: value_expr for item in iterable}</code>。是不是又好看又轻松？</p><p id="c5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要从iterable中过滤一些元素，通过实现一些条件，我们可以有一个稍微复杂一点的用例，如下例所示:</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="6f33" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Create a list of integers used in a dict comprehension</strong><br/>&gt;&gt;&gt; integers = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; odds_squares = {x: x*x for x in integers if x%2 == 1}<br/>&gt;&gt;&gt; odds_squares<br/>{1: 1, 3: 9, 5: 25}</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4678" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.检索值</h1><p id="034d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">看到这一节的标题你可能会笑。“你在跟我开玩笑吗？我知道如何检索值，就像你在开始时展示的那样。”关于使用方括号来检索特定键值，您肯定是对的。但是，您是否经历过可能导致您的程序崩溃的事情？</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="8676" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Create a dictionary for value retrieving</strong><br/>&gt;&gt;&gt; student = {"name": "John", "student_id": 73802}<br/>&gt;&gt;&gt; student["gender"]<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>KeyError: 'gender'</span></pre><p id="1f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道使用方括号来获取字典的值是许多编程语言中最传统的方式，但是在Python中我们也有选择。为了防止可能的<code class="fe nc nd ne nf b">KeyError</code>，一个繁琐的方法是在我们决定是否检索它的值之前，先检查字典对象是否有键。大概是这样的:</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="7ac2" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Use the one-line if-else</strong><br/>&gt;&gt;&gt; name = student["name"] if "name" in student else "Unknown"<br/>&gt;&gt;&gt; name<br/>'John'<br/>&gt;&gt;&gt; gender = student["gender"] if "gender" in student else "Unknown"<br/>&gt;&gt;&gt; gender<br/>'Unknown'</span></pre><p id="9a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用这个三元表达式，我们还有其他选择。我们实际上可以使用<code class="fe nc nd ne nf b">get()</code>方法，如果字典没有指定的键，该方法允许我们设置一个默认值，这样我们可以防止自己陷入<code class="fe nc nd ne nf b">KeyError</code>问题。下面来看看它的用法:</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="0ec0" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Use the get() method</strong><br/>&gt;&gt;&gt; student_id = student.get("student_id", -1)<br/>&gt;&gt;&gt; student_id<br/>73802<br/>&gt;&gt;&gt; grade = student.get("grade", 999)<br/>&gt;&gt;&gt; grade<br/>999</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8fd8" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.迭代次数</h1><p id="6779" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">字典是可迭代的，这意味着我们可以遍历字典中的元素来执行特定的操作。然而，字典存储键值对，因此给了我们更多的迭代方法。让我们看看这些不同的方式。为了简单起见，下面的例子都使用相同的字典:</p><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="1097" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt;<strong class="nf iu"> # Create a dictionary for iterations</strong><br/>&gt;&gt;&gt; currencies = {"America": "USD", "China": "CNY", "Britain": "GBP"}</span></pre><ul class=""><li id="f8e9" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">为了迭代这些键，我们可以使用<code class="fe nc nd ne nf b">keys()</code>函数。需要注意的一点是，如果你直接迭代字典，你基本上是在键上迭代。前者只是调用<code class="fe nc nd ne nf b">keys()</code>函数的语法糖。如下所示，这两种方式生成相同的输出:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="5af2" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Iteration over the keys</strong><br/>&gt;&gt;&gt; for item in currencies:<br/>...     print(item)<br/>... <br/>America<br/>China<br/>Britain<br/>&gt;&gt;&gt; for item in currencies.keys():<br/>...     print(item)<br/>... <br/>America<br/>China<br/>Britain</span></pre><ul class=""><li id="7374" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">为了迭代这些值，我们可以使用<code class="fe nc nd ne nf b">values()</code>函数。用法非常简单，下面是一个简单的例子:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="de86" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Iteration over the values</strong><br/>&gt;&gt;&gt; for item in currencies.values():<br/>...     print(item)<br/>... <br/>USD<br/>CNY<br/>GBP</span></pre><ul class=""><li id="af90" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">为了迭代键值对，我们可以使用<code class="fe nc nd ne nf b">items()</code>函数。这将生成一个元组列表，每个元组存储一个键及其对应的值。见下文:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="cafa" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Iteration over the items</strong><br/>&gt;&gt;&gt; for key, value in currencies.items():<br/>...     print(f"Key: {key}; Value: {value}")<br/>... <br/>Key: America; Value: USD<br/>Key: China; Value: CNY<br/>Key: Britain; Value: GBP</span></pre><p id="8460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的迭代中需要注意的一点是，随着Python的发展，字典已经变得有序了。因此，当元素的顺序很重要时，您仍然可以使用字典。然而，问题是在你删除一个键-值对之后，如果你要把它添加回来，新的插入将会在末尾，并且顺序将会改变。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="b68d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.合并词典</h1><p id="118a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">有时候，我们从多个字典开始，想把它们合并成一个字典。当然，最繁琐但最直接的方法是创建一个新字典，遍历现有字典，并将这些键值对添加到新字典中。</p><p id="9bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在Python中有更好的合并字典的方法。出于演示的目的，我将只使用两个字典，并将它们合并为一个字典。下面给出了例子。</p><ul class=""><li id="de96" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">第一种方法是使用字典的<code class="fe nc nd ne nf b">update()</code>方法。基本上，这个方法将获取另一个字典并更新调用字典(即调用函数的字典)。当存在重叠键时，调用字典的值将被覆盖，如下所示:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="9442" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Merge dictionaries using update()</strong><br/>&gt;&gt;&gt; d0 = {"a": 0, "b": 1}<br/>&gt;&gt;&gt; d1 = {"b": 2, "c": 3}<br/>&gt;&gt;&gt; d0.update(d1)<br/>&gt;&gt;&gt; d0<br/>{'a': 0, 'b': 2, 'c': 3}</span></pre><ul class=""><li id="155b" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">第二种方法是使用双星号(<code class="fe nc nd ne nf b">**</code>)来解包字典。与上面的例子类似，如果有重叠的键，后面解包的键将影响最终值。下面让我们看看在合并字典时解包是如何使用的:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="c41f" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Merge dictionaries using unpacking **</strong><br/>&gt;&gt;&gt; dict0 = {0: "a", 1: "b"}<br/>&gt;&gt;&gt; dict1 = {1: "z", 2: "c"}<br/>&gt;&gt;&gt; dict2 = {**dict0, **dict1}<br/>&gt;&gt;&gt; dict2<br/>{0: 'a', 1: 'z', 2: 'c'}</span></pre><ul class=""><li id="ab81" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">第三种方法是使用<code class="fe nc nd ne nf b">dict()</code>构造函数，它可以接受一个字典和另一个字典的解包的键值对。用法非常简单。下面我们来看看它是如何工作的:</li></ul><pre class="kj kk kl km gt np nf nq nr aw ns bi"><span id="0482" class="nt mg it nf b gy nu nv l nw nx">&gt;&gt;&gt; <strong class="nf iu"># Merge dictionaries using dict()</strong><br/>&gt;&gt;&gt; d0 = {"a": 0, "b": 1}<br/>&gt;&gt;&gt; d1 = {"b": 2, "c": 3}<br/>&gt;&gt;&gt; d2 = dict(d0, **d1)<br/>&gt;&gt;&gt; d2<br/>{'a': 0, 'b': 2, 'c': 3}</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="51d7" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="05ed" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在本文中，我们回顾了五种使用字典的中级或高级操作。在涉及字典的编码中，这些技巧会非常方便。</p><p id="5958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。以下是与当前讨论相关的其他几篇文章，供您参考。</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/swlh/how-to-pack-and-unpack-data-in-python-tuples-and-dictionaries-55d218c65674" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">如何在Python中打包和解包数据—元组和字典</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">了解神奇的星号(*)</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://medium.com/better-programming/dictionary-merging-and-updating-in-python-3-9-4ac67c667ce" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">Python 3.9中的字典合并和更新</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">快速浏览Python 3.9的新merge |和update |=操作符</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>