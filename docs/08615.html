<html>
<head>
<title>5 Lessons I Learned in My First 2 Years of Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在编程的前两年学到的5个教训</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-lessons-i-learned-in-my-first-2-years-of-programming-18e43c652367?source=collection_archive---------6-----------------------#2021-05-20">https://betterprogramming.pub/5-lessons-i-learned-in-my-first-2-years-of-programming-18e43c652367?source=collection_archive---------6-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我在任何教程中都没有找到的东西</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/432fedfc0f2976a3f9ef01c8f5553506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJn9eEX7Lx8UCfRf2tgW0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@element5digital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">元素5数码</a>在<a class="ae ky" href="https://unsplash.com/s/photos/learn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ee6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两年多来，我一直靠写代码赚钱。在那段时间里，我对编程的看法发生了很大的变化。</p><p id="939f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，最重要的课程不是学习一门特定语言或框架的复杂性。相反，我最大的思想转变是更多地了解编程，与其他人一起工作，并做出一些在你停止工作后仍能保持很长时间的东西。</p><p id="cdb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中的例子都是用JavaScript编写的，但我希望它们足够简单，无论您的背景如何，都能容易理解。而且，这些想法都是主观的。如果你不同意，我希望在评论中听到更多。</p><h1 id="5f3f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你是在为人们写代码，而不是计算机</h1><p id="d7d7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我开始的时候，似乎编码就是写指令让计算机去解释。好的代码感觉就像完成工作的代码。但是考虑下面的例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ba52" class="mx lw it mt b gy my mz l na nb">for(let i=0;i&lt;100;)console.log((++i%3?'':'Fizz')+(i%5?'':'Buzz')||i)</span></pre><p id="9782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会意识到这是经典FizzBuzz问题的一个实现。它可以工作，但是代码是如何工作的并不明显。像这样的怎么样？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个例子可能更聪明，但是对我来说，第二个例子更容易阅读、理解和维护。在大多数情况下，我们的目标是后者。当然，这个例子是精心设计的，但是随着我们代码的需求变得越来越复杂，清晰的需求变得越来越重要。</p><p id="de93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，好的代码是为其他人编写的代码。我们与传统作家的共同点比我们想象的要多！</p><h1 id="8d01" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">人们不同意什么使代码可读</h1><p id="c3e7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不幸的是，什么是可读代码可能会引起分歧。</p><p id="6d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我目前的工作中，我们使用类型转换的快捷方式，比如用<code class="fe ne nf ng mt b">+</code>表示数字，用<code class="fe ne nf ng mt b">!!</code>表示布尔值。但是在我以前的工作中，我已经学会了避免这些，而支持<code class="fe ne nf ng mt b">Number</code>和<code class="fe ne nf ng mt b">Boolean</code>构造函数。我也目睹了关于<code class="fe ne nf ng mt b">async</code> / <code class="fe ne nf ng mt b">await</code>和<code class="fe ne nf ng mt b">then</code> / <code class="fe ne nf ng mt b">catch</code>的争论(一个我对有强烈意见的问题)！</p><p id="0ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然许多样式问题可以用您最喜欢的代码格式化程序来解决，但重要的是要知道代码可读性实践会根据上下文而变化。总的来说，我们应该渴望根据他们的经验和偏好，写出其他从事这项工作的人可读的代码。</p><p id="b1c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些关于代码可读性的更具体的想法。</p><h2 id="2fc3" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">1.认知复杂性</h2><p id="0731" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我发现一个有用的可读性概念是<em class="ns">认知复杂性</em>。我在使用代码质量软件<a class="ae ky" href="https://sonarcloud.io/" rel="noopener ugc nofollow" target="_blank"> Sonarcloud </a>时遇到了它，它试图测量一个代码单元的理解难度——包括所有可能的路径。</p><p id="2612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一层新的嵌套和每一条新的可能路径都会增加认知的复杂性。这包括<code class="fe ne nf ng mt b">for</code>和<code class="fe ne nf ng mt b">while</code>循环、<code class="fe ne nf ng mt b">if</code>语句、三元运算符和可选的链接运算符。</p><p id="b4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个简单的例子，这个<code class="fe ne nf ng mt b">isPrime</code>函数的认知复杂度为4:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易遇到在认知复杂性量表上得分极高的文件，它们有许多嵌套和许多可能的路径。减少这一点是提高可读性的一种方法，你的同事可能会同意这一点，但你的格式化程序不会注意到这一点。</p><h2 id="fe61" class="mx lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">2.评论</h2><p id="3a71" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多针对初级程序员的教育内容强调好的注释的重要性。但以我的经验来看，过于依赖注释其实对可维护性不好。</p><p id="c972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这主要有两个原因。首先，注释很容易被它们所解释的代码取代。随着时间的推移，随着项目的变化，代码行将不可避免地四处移动。但是因为注释不是代码运行所必需的，所以很容易把它们放在错误的地方。这可能会导致更多的混乱，因为注释可能会出现在解释错误的代码旁边。</p><p id="f335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个更重要的原因是，注释代码通常可以重写，这样就可以很容易地从代码本身理解代码的作用——主要是通过更好的结构和更好的变量名。</p><p id="3ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在一个生产代码库中遇到过类似上面的东西。尽管我们需要在一个数组中存储所有的产品代码，但我们仍然可以将它们分开存储，这样我们就可以删除注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="293f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的变化意味着代码可以不用注释就能理解，如果结构发生变化，我们忘记哪些id适用于t恤，哪些适用于帽衫的风险就会小得多。</p><h1 id="b0aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编程都是关于数据的</h1><p id="7dcc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于初学编程的人来说，制作软件的想法可能感觉非常神秘。想象最终结果很容易，但要理解如何实现却困难得多。我最早的啊哈之一！moments认为编程都是关于数据的:获取数据、修改数据、显示数据，然后将数据发送到其他地方。</p><p id="be9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，把它归结为这些要点并不意味着它总是简单的。从本质上说，让一架飞机飞起来就是升力、阻力、推力和重量。我知道，但是设计一架飞机对我没多大用处！</p><p id="e6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复杂软件面临的挑战是处理来自许多不同地方的大量数据，这些数据需要高效、大规模地修改，而显示数据也带来了各种挑战。</p><p id="d33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，将编程视为数据经历的旅程帮助我分解了更复杂的问题。一旦您能够确定需要什么数据、如何获取数据、如何将数据转换成所需的形式，以及在哪里显示或发送数据，那么您就离解决方案不远了。</p><h1 id="c62d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">性能并不重要(除非有必要)</h1><p id="f704" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在理想情况下，我们有时间确保所有代码尽可能快地运行。然而，通常花在微调性能上的时间可以更好地用在做其他事情上:在商业中，修复bug或创建新功能通常比从特定函数或代码块中减去几百毫秒更有价值。</p><p id="40b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这条规则也有例外。有些功能需要非常可靠或者非常耗费资源，因此节省下来的每一毫秒都很重要。随着规模的扩大，性能也变得更加重要。如果您可以为一百万用户节省0.1秒的加载时间，那么如果每个人都加载一次，那就相当于总共节省了28小时的时间。可悲的是，我们中很少有人在处理这样的数字。</p><p id="1d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能代码的困境之一是它可能会违背我们更重要的目标:可读性和可维护性。高度优化的代码往往很难看。在我的专业领域——web开发——有时会涉及到对抗库或框架，比如提供从React到使用常规JavaScript的退路。</p><p id="a3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易遇到过早优化导致的问题。以React为例，当使用<code class="fe ne nf ng mt b">useMemo</code>或<code class="fe ne nf ng mt b">useCallback</code>时，事实上<a class="ae ky" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">与常规变量和函数</a>相比会降低性能。</p><p id="60dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也因为过于自由地使用<code class="fe ne nf ng mt b">Promise.all</code>而陷入尴尬的境地。以下面的函数为例(大致基于我写的一些正版代码):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这比逐个执行异步函数要快，但我引入了一些不可靠的结果，而这些结果是较慢的代码可以避免的。我也许能够重新编写这些函数，使它们能够并发运行，但是让这三个函数并行平稳运行所花费的时间不值得节省。所以在这种情况下，最好这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，最高级别的性能需要最高级别的控制。例如，如果我们想从网站中获得最大的理论性能，没有任何库或框架可能会更好。或者也许我们应该使用Web Assembly来用C++编写整个代码？大型、复杂的项目很少选择这种方法有一个很好的原因:实现起来太耗时，维护起来也太耗时。</p><h1 id="1206" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">很多用户界面都是虚幻的</h1><p id="8d77" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，关于编程的可视化方面的一个注意事项。作为一个初学者，我没有完全意识到好的UI往往是一种欺骗——让事情看起来比平常更快或更有趣。</p><p id="30fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以进度条为例。根据任务的不同，很难精确估计需要多长时间。这就是为什么我们如此习惯于不把剩余时间的估计看得太重。但是如果我们没有他们呢？如果没有迹象告诉用户有事情发生，人们会感到无聊，他们可能会关闭窗口或重启电脑。因此，我们给他们最好的猜测，以帮助他们保持参与，并阻止他们做任何事情来中断我们的软件。</p><p id="d801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他例子是当我们获取数据时使用的占位符图形。或者在状态改变被发送到API之前在客户端改变状态。当您在社交媒体网站上关闭通知时，看起来该通知已被标记为立即阅读。但这是客户机在更改实际到达服务器之前向您显示的。一点点的烟火气，让用户的体验感觉又快又滑头。</p></div></div>    
</body>
</html>