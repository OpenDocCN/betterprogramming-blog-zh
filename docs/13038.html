<html>
<head>
<title>Angular 14 Firebase CRUD Tutorial With AngularFire 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AngularFire 7的Angular 14 Firebase CRUD教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-13-firebase-crud-tutorial-with-angularfire-7-2d6980dcc091?source=collection_archive---------0-----------------------#2022-07-21">https://betterprogramming.pub/angular-13-firebase-crud-tutorial-with-angularfire-7-2d6980dcc091?source=collection_archive---------0-----------------------#2022-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="431b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Angular和Firebase实现CRUD Pokedex</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b7b99ba23228a700d281072a9c46bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m_NEHS_t6JUcEjhu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Thimo Pedersen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0c65" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2f1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，您将学习如何使用Angular 14、Firebase的实时NoSQL云数据库(Firestore)和新的可摇树<a class="ae ky" href="https://github.com/angular/angularfire" rel="noopener ugc nofollow" target="_blank"> AngularFire </a> v.7.0模块化SDK创建Pokedex CRUD应用程序，这使我们能够充分利用新的可摇树Firebase JS SDK (v9) 。</p><blockquote class="mn mo mp"><p id="d777" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">请注意，在撰写本教程时，Angular fire v.7.0 API <a class="ae ky" href="https://github.com/angular/angularfire/blob/master/docs/version-7-upgrade.md" rel="noopener ugc nofollow" target="_blank">仍在开发中，功能还不完整</a>；这些文档还没有更新到最新版本。AngularFire提供了一个兼容层，允许您使用最新版本的库，同时完全支持AngularFire v6.0 API。也就是说，如果你和我一样好奇，并且喜欢尝试你所有库的最新版本，那就继续享受这篇教程吧。</p></blockquote><p id="8807" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这是我们今天将构建的应用程序的预览:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/650f2ea9fda9d175732c8ed0f75480eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RiFtaZT3BkXzfIUncVmlDA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用预览</p></figure><p id="0e82" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">你可以在这里找到<a class="ae ky" href="https://github.com/puntotech/ngbytes-pokedex" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p><h2 id="417d" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">索引</h2><ul class=""><li id="ce25" class="nm nn it lt b lu lv lx ly ma no me np mi nq mm nr ns nt nu bi translated">建立一个Firebase项目。</li><li id="e1b6" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">使用AngularFire设置角度投影。</li><li id="f7dc" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">构建应用程序。</li><li id="dd21" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">创建Firestore服务</li><li id="bdb4" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">创建口袋妖怪模块</li></ul></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="5fb9" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">设置Firebase项目</h1><p id="675b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要做的第一件事是创建一个新的Firebase项目，向我们的项目添加一个web应用程序，并设置Firestore。如果您已经完成了，请继续下一部分。</p><p id="0126" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果你不知道如何做到这一点，我建议你遵循我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-and-configure-a-firebase-and-angular-project-9305c40ee308">如何创建和配置一个Firebase和Angular项目教程</a>，一旦你的Firebase项目启动并运行，回来继续阅读。</p><h2 id="d759" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">建立Firestore</h2><p id="7b9e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="mq">注意:如果您尚未将Firestore添加到您的Firebase项目中，我们现在将添加它。如果您已经这样做了，请随意跳过这一部分。</em></p><p id="a38f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">是时候将Firestore添加到我们的项目中了！cloud Firestore是Firebase和Google Cloud开发的一个用于移动、web和服务器开发的数据库。像Firebase实时数据库一样，它通过实时监听器使您的数据在客户端应用程序之间保持同步。</p><p id="2f92" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">前往你的<a class="ae ky" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>上的Firestore数据库页面，点击创建数据库按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/28f15a77c60d1c3d4594990959de75e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2A1d_vpDORuQ-UWhlRjB7Q.png"/></div></div></figure><p id="cc3b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您必须选择是从生产模式还是测试模式开始。对你的选择要非常小心，因为以测试模式开始将允许每个人访问你的数据。仅当您知道自己在做什么时，才选择此选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/c83fdc58ae44cdb98b5a6b3eb5c34695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsY_yUegE1kcl8-00v34ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Firebase —选择安全规则</p></figure><p id="8fc7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您需要选择的最后一件事是Firestore数据的位置。正如警告消息所示，请明智地选择，因为您以后将无法更改此位置。</p><p id="3acf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一旦你选择了地点，点击<em class="mq">启用</em>按钮，你的Firestore就创建好了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/97608f2dc160cb701f8ae3e815c4f11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_fXbUHbJM_mhvVSyCGpxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Firebase —选择Firestore数据位置</p></figure><p id="8670" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您的Firestore数据库页面现在应该包含您新创建的云Firestore数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/fe8d93343837566e6737331900fe2276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96nEcF1RUlsA2O5sxQNVSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Firebase —新创建的云Firestore</p></figure><p id="23ac" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">厉害！我们的Firebase应用程序已经完全设置好了。是时候开始使用我们的Angular应用程序了。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="9bfe" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">设置角度项目</h1><p id="38a5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们要做的第一件事是用Angular CLI创建一个新项目。</p><p id="ce81" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><em class="mq">提示:如果您还没有安装Angular CLI，您可以通过运行以下命令来安装:</em></p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="b2c5" class="na la it or b gy ov ow l ox oy">npm i -g @angular/cli</span></pre><p id="89f7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">要创建新的角度项目，我们可以运行以下命令:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="1f4c" class="na la it or b gy ov ow l ox oy">ng new ngbytes-firepokedex</span></pre><p id="afaf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><em class="mq">注意:当被问及是否要在新应用中添加路线时，不要忘记回答是！</em></p><p id="a7ae" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一旦CLI发挥了它的魔力，我们就可以用我们最喜欢的IDE打开新创建的项目(我建议使用<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>，这是我通常使用的一个)。</p><h2 id="4862" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">添加火基和角火</h2><p id="17cf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们将Firebase和Angularfire添加到我们的项目中。为此，我们将使用AngularFire原理图，它将负责为我们设置一切。让我们运行以下命令:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="bb69" class="na la it or b gy ov ow l ox oy">ng add @angular/fire</span></pre><p id="39c7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们会被问一系列问题，比如我们想要设置哪些Firebase特性。对于本教程，我们只需要使用Firestore，所以让我们选择:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/c96e27a04630141f00076ed4d17afaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3k1uOp_bL3TkDYDwZkevaA.png"/></div></div></figure><p id="034e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">然后我们会被问到我们想要使用的Firebase帐户，以及我们想要设置哪个项目。选择我们之前创建的项目，然后选择我们之前创建的应用程序。</p><p id="2b5f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一旦我们完成了所有这些，您将会看到原理图已经为我们处理了所有的Firebase配置。厉害！</p><h2 id="1146" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">添加角形材料</h2><p id="dc7d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还会添加有棱角的材料。我们将再次使用原理图:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="c8ae" class="na la it or b gy ov ow l ox oy">ng add @angular/material</span></pre><h2 id="16ce" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">禁用strictPropertyInitialization</h2><p id="6bac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要将<code class="fe pa pb pc or b">tsconfig.json</code>文件中的<code class="fe pa pb pc or b">strictPropertyInitialization</code>属性设置为false。</p><p id="c6cb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们这样做是因为从版本12开始，所有新的Angular应用程序都默认启用严格模式，这意味着如果我们声明任何类属性而没有在构造函数中设置它们(Angular中的常见做法)，TypeScript将会抱怨。我们的<code class="fe pa pb pc or b">tsconfig.json</code>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">tsconfig.json文件</p></figure><h2 id="5be1" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">删除角样板</h2><p id="7ff7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，但同样重要的是，我们将删除Angular在<code class="fe pa pb pc or b">app.component.html</code>中自动生成的样板代码。非常小心，确保在删除样板代码时不要删除<code class="fe pa pb pc or b">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>标签，否则路由器将无法工作。</p><p id="e83c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">删除所有内容后，您的<code class="fe pa pb pc or b">app.component.html</code>应该只包含路由器出口标签:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/35762c51e181766132be7cd475c64355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*JA4Fc1QufutXtfAAX5IwdQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app.component.html的路由器出口标签</p></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="a422" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">创建firestore服务</h1><p id="6694" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们要做的第一件事是创建将与Firestore交互的服务，并为我们提供将在Pokedex中显示的数据。我们将使用传统的Angular模块结构，并用Angular CLI创建一个<code class="fe pa pb pc or b">core</code>模块来包含我们的服务。在您的终端中:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="f0da" class="na la it or b gy ov ow l ox oy">cd src/app<br/>ng g m core</span></pre><p id="839b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一旦我们创建了我们的<code class="fe pa pb pc or b">core</code>模块，我们可以用下面的命令在其中创建我们的服务:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="26f1" class="na la it or b gy ov ow l ox oy">cd core<br/>ng g s pokedex-firestore</span></pre><p id="abcb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在我们的服务内部，我们需要做的第一件事是在构造函数中注入AngularFire <code class="fe pa pb pc or b">Firestore</code>实例，正如其名称所示，我们可以用它来与Firestore交互。</p><p id="4141" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们还将创建一个私有的<code class="fe pa pb pc or b">pokemonCollection</code>变量，它将包含对Firestore Pokemon集合实例的引用。我们稍后将在查询中使用这个集合。到目前为止，我们的服务应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">firestore服务<a class="ae ky" href="https://gist.github.com/NyaGarcia/5e7e372aa9ffa8812e3c7471ef4a4375" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/5e7e 372 a9 FFA 8812 E3 c 7471 ef 4a 4375</a></p></figure><p id="c334" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在我们有了基本的Firestore配置，我们可以开始CRUD功能了。我们总共有5种不同的功能:</p><ul class=""><li id="1c8b" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">getAll()</code>:将返回集合中的所有口袋妖怪。</li><li id="8944" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">get(id)</code>:会返回与id匹配的口袋妖怪。</li><li id="12bb" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">create(pokemon)</code>:将增加一个新的口袋妖怪到收藏里。</li><li id="17f4" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">update(pokemon)</code>:将更新集合中的一个口袋妖怪。</li><li id="20bb" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">delete(id)</code>:会删除与id匹配的口袋妖怪。</li></ul><p id="5523" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们继续在我们的服务中实现这些功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现CRUD函数<a class="ae ky" href="https://gist.github.com/NyaGarcia/025c296fde0b93826eff6db6060cfb13" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/025 c 296 fde0b 93826 eff 6b 6060 CFB 13</a></p></figure><p id="0531" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">太棒了，我们已经完成了服务！现在是时候创建<code class="fe pa pb pc or b">pokemon</code>模块了，它将允许我们的用户与服务进行交互。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="94ad" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">口袋妖怪模块</h1><p id="1e69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个功能模块将包含所有的口袋妖怪组件。主要的路由组件将是Pokemon组件，它将包含与Firestore服务交互的所有必要逻辑，并为其他组件提供它们需要的数据。我们总共有三个表示性(纯视觉)组件:</p><ul class=""><li id="a46f" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated">Pokemon表单，我们将重用它来创建和更新Pokemon。我们将在一个<code class="fe pa pb pc or b">MatDialog</code>中打开表单组件。</li><li id="25a0" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">口袋妖怪列表将显示Firestore中存储的口袋妖怪列表。</li><li id="2215" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">口袋妖怪细节将显示选定的口袋妖怪的数据，并将有更新和删除按钮。</li></ul><p id="6d3e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为了创建模块，我们将首先在<code class="fe pa pb pc or b">app</code>中创建一个<code class="fe pa pb pc or b">features</code>目录，然后使用CLI自动生成模块:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="c051" class="na la it or b gy ov ow l ox oy">cd src/app<br/>mkdir features<br/>cd features<br/>ng g m pokemon -m app --route pokemon</span></pre><p id="ccd8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><em class="mq">提示:我们正在使用</em> <code class="fe pa pb pc or b"><em class="mq">--route</em></code> <em class="mq">选项，该选项在新模块中创建一个组件，并将该组件的路由添加到在</em> <code class="fe pa pb pc or b"><em class="mq">-m</em></code> <em class="mq">选项提供的模块中声明的</em> <code class="fe pa pb pc or b"><a class="ae ky" href="https://angular.io/api/router/Routes" rel="noopener ugc nofollow" target="_blank"><em class="mq">Routes</em></a></code> <em class="mq">数组中。</em></p><p id="2551" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您将看到CLI已经在<code class="fe pa pb pc or b">features</code>目录中创建了一个<code class="fe pa pb pc or b">pokemon</code>模块，以及它对应的<code class="fe pa pb pc or b">pokemon-routing.module.ts</code>和组件。它还修改了<code class="fe pa pb pc or b">app-routing.module.ts</code>，增加了一条<code class="fe pa pb pc or b">pokemon</code>路线，懒加载了<code class="fe pa pb pc or b">PokemonModule</code>。</p><p id="c12f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">由于我们希望口袋妖怪模块在我们打开应用程序时立即显示(而不是在我们导航到<code class="fe pa pb pc or b">/pokemon</code>时显示)，我们需要修改<code class="fe pa pb pc or b">app-routing.module.ts</code>文件，并更改路线路径，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">改变口袋妖怪路线<a class="ae ky" href="https://gist.github.com/NyaGarcia/ab68eb742d81b28fd835631622a72147" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/ab 68 EB 742d 81 b 28 FD 835631622 a 72147</a></p></figure><p id="9c47" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">全部完成！</p><h2 id="e18f" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">口袋妖怪界面</h2><p id="151d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们继续创建Pokemon表单之前，我们将花一点时间来重构我们的<code class="fe pa pb pc or b">pokedex-firestore.service</code>。等等，什么？我们刚刚创建了服务，就已经要重构了？</p><p id="0276" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">抱歉，伙计们，这是给你们的计算机科学！还记得我们在服务内部创建的口袋妖怪界面吗？我们应该在<code class="fe pa pb pc or b">pokemon.module</code>中创建一个<code class="fe pa pb pc or b">interfaces</code>目录，并给它一个新家:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="64fc" class="na la it or b gy ov ow l ox oy">cd features/pokemon<br/>mkdir interfaces<br/>cd interfaces<br/>touch pokemon.interface.ts</span></pre><p id="7f2b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们将服务中的接口剪切并粘贴到新文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">口袋妖怪服务<a class="ae ky" href="https://gist.github.com/NyaGarcia/0625bcb5c9bb215aee7dfbc5cb02483e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/0625 BCB 5 c 9 bb 215 aee 7 dfbc 5 CB 02483 e</a></p></figure><p id="ba13" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">厉害！不要忘记在服务中导入接口，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在服务中导入口袋妖怪接口<a class="ae ky" href="https://gist.github.com/NyaGarcia/fa8223633fb69f81de4fda33da24b10a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/fa 8223633 FB 69 f 81 de 4 FDA 33 da 24 b 10 a</a></p></figure><p id="15bb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">恭喜你，你已经成功重构了Firestore服务！我们现在可以继续前进了。</p><h2 id="c67a" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">口袋妖怪的形式</h2><p id="c4dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了能够创建和更新口袋妖怪，我们需要创建一个<code class="fe pa pb pc or b">form</code>组件。首先，我们将在<code class="fe pa pb pc or b">pokemon</code>模块中创建一个<code class="fe pa pb pc or b">components</code>文件夹，然后使用CLI创建我们的表单:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="cce7" class="na la it or b gy ov ow l ox oy">cd features/pokemon <br/>mkdir components<br/>cd components<br/>ng g c form</span></pre><p id="b08b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为了创建我们的表单，我们将使用反应式表单模块。我们还将使用棱角分明的材质模块来设计我们的造型。因为这不是本教程的目标，所以我不会详细讨论如何使用反应式表单。</p><p id="61d5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">首先，我们将把<code class="fe pa pb pc or b">ReactiveFormsModule</code>、<code class="fe pa pb pc or b">MatInputModule</code>、<code class="fe pa pb pc or b">MatFormFieldModule</code>、<code class="fe pa pb pc or b">MatButtonModule</code>和<code class="fe pa pb pc or b">MatDialog</code>模块导入到我们的<code class="fe pa pb pc or b">PokemonModule</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入模块<a class="ae ky" href="https://gist.github.com/NyaGarcia/a8b4769c6fccbc1be1ea2eb743905081" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/a8b 4769 c 6 fc CBC 1 be 1 ea 2 EB 743905081</a></p></figure><p id="779f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">然后，我们将在我们的<code class="fe pa pb pc or b">form.component.ts</code>文件中创建表单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建口袋妖怪表单<a class="ae ky" href="https://gist.github.com/NyaGarcia/da0ed888f32cf2e58b2950247fb51ba4" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/da 0 ed 888 f 32 cf 2e 58 b 2950247 FB 51 ba 4</a></p></figure><p id="e43d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如您所见，我们为表单添加了基本验证，使所有表单字段都成为必填字段。如果您打算在生产中使用这段代码，您可能需要添加进一步的验证，并且，除了其他事情之外，限制所有输入字段的长度。</p><p id="b246" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们还注入了一个<code class="fe pa pb pc or b">MatDialogRef</code>，可以用来关闭包含表单的对话框。关闭时，我们可以提供一个可选的结果值，然后我们可以在最初打开对话框的组件中访问该值。</p><p id="121d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><code class="fe pa pb pc or b">@Inject(MAT_DIALOG_DATA)</code>注入令牌允许我们访问传递给对话框组件的数据。我们为什么需要这个？因为我们将重用我们的表单，既用于创建新的口袋妖怪，也用于更新现有的口袋妖怪。如果我们想创建一个新的口袋妖怪，我们不会向对话框传递任何数据。然而，如果我们想要更新一个现有的口袋妖怪，我们将传递一个口袋妖怪到对话框，并且表单字段将用口袋妖怪的值初始化。</p><p id="b107" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后，让我们仔细看看<code class="fe pa pb pc or b">submit</code>函数，更具体地说，看看<code class="fe pa pb pc or b">dialogRef.close()</code>中的返回值:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="2a47" class="na la it or b gy ov ow l ox oy">{...this.pokemon, ...this.form.value}</span></pre><p id="fa38" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">不知道这行代码是怎么回事？放心吧！我们会一起经历的。我们基本上是将<code class="fe pa pb pc or b">pokemon</code>和<code class="fe pa pb pc or b">form.value</code>对象合并成一个对象，通过使用扩展操作符(不熟悉？阅读本指南，成为专家！)。我们这样做是因为我们想在创建和更新Pokemon时重用这个表单。如果我们使用这个表单来创建一个口袋妖怪，<code class="fe pa pb pc or b">pokemon</code>对象将是未定义的，它不会影响结果。然而，如果我们使用表单来更新一个口袋妖怪，<code class="fe pa pb pc or b">pokemon</code>对象将包含<code class="fe pa pb pc or b">id</code>属性，这在<code class="fe pa pb pc or b">form.value</code>对象中是不存在的，它将被添加到结果中。</p><p id="e384" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们在<code class="fe pa pb pc or b">form.component.html</code>文件中实现模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">口袋妖怪表单模板<a class="ae ky" href="https://gist.github.com/NyaGarcia/cdb5d1c20c320e131ba600d4ccb22856" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/CDB 5 D1 C20 c 320 e 131 ba 600d 4c CB 22856</a></p></figure><p id="d9cc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后但同样重要的是，一点CSS:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表单样式<a class="ae ky" href="https://gist.github.com/NyaGarcia/3d685b7073340f231a57d3039c4271a8" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/3d 685 b 7073340 f 231 a 57d 3039 c 4271 A8</a></p></figure><h2 id="5c82" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">口袋妖怪名单</h2><p id="441b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该组件将显示集合中所有口袋妖怪的列表。让我们用Angular CLI创建我们的<code class="fe pa pb pc or b">list</code>组件(在<code class="fe pa pb pc or b">components</code>目录中，别忘了！):</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="c36e" class="na la it or b gy ov ow l ox oy">ng g c list</span></pre><p id="b3e9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为了设计我们的列表，我们将使用<code class="fe pa pb pc or b">MatCard</code>组件。因此，我们需要将<code class="fe pa pb pc or b">MatCardModule</code>导入到我们的<code class="fe pa pb pc or b">pokemon.module.ts</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入MatCardModule<a class="ae ky" href="https://gist.github.com/NyaGarcia/b0b5b6db81d3fc3e834e10b87c7d69e9" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/B0 b5 b 6 db 81d 3 fc 3 e 834 e 10 b 87 c 7d 69 e 9</a></p></figure><p id="d407" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在我们可以开始列表组件了。</p><h2 id="d9a0" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">列表逻辑</h2><p id="2b71" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">还记得我们firestore服务中的<code class="fe pa pb pc or b">getAll</code>方法吗？它返回一个<code class="fe pa pb pc or b">Observable&lt;Pokemon[]&gt;</code>，一个口袋妖怪数组的可观测值，其中包含了我们Firestore收藏中存储的所有口袋妖怪。我们的列表组件将接收这个可观察对象，并使用它来显示所有的口袋妖怪。在我们的<code class="fe pa pb pc or b">list.component.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在接收口袋妖怪$ Observable<a class="ae ky" href="https://gist.github.com/NyaGarcia/643312e34a9de8cba4b7510b02558a28" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/643312 e 34 a9 de 8 CBA 4 b 7510 b 02558 a 28</a></p></figure><p id="e220" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果你不熟悉<code class="fe pa pb pc or b">Input()</code>和<code class="fe pa pb pc or b">Output()</code>装饰器，我会简单解释一下。如果你已经知道它们是如何工作的，可以跳过下面的解释:</p><ul class=""><li id="beea" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">Input()</code>装饰器意味着<code class="fe pa pb pc or b">pokemon$</code>属性将从父组件接收它的值。在教程的后面，当我们创建Pokemon组件(它是父组件)时，我们将解释如何将值从父组件发送到子组件，所以现在不要担心这一部分。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/f35d90e4b1e20c45c6e0094c5c974b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQLvYdQLFVUgWhFFXUzQbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输入流程图</p></figure><ul class=""><li id="60d1" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">Output()</code>装饰器允许我们向父组件发送数据。它将属性标记为某种入口，通过它我们可以将数据发送给父对象。<code class="fe pa pb pc or b">Ouput()</code>属性<strong class="lt iu">总是</strong>需要类型<code class="fe pa pb pc or b">EventEmitter</code>。在这种情况下，每当我们从列表中选择一个口袋妖怪时，我们就用它来通知父组件。稍后，当我们创建Pokemon组件时，我们将解释如何在父组件中接收数据。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/ff7c0fadf828e47b592b1073f40d2a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHJ8RX-Vjb-qa_XYbaBvuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出流程图</p></figure><p id="be1d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">你可以在<a class="ae ky" href="https://angular.io/guide/inputs-outputs" rel="noopener ugc nofollow" target="_blank">官方角度文档中阅读更多关于输入和输出的信息。</a></p><h2 id="c4fa" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">列表模板</h2><p id="6ca7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然后，在我们的<code class="fe pa pb pc or b">list.component.html</code>组件中，我们将使用<code class="fe pa pb pc or b">ngFor</code>和<code class="fe pa pb pc or b">async</code>管道遍历<code class="fe pa pb pc or b">pokemon$</code>可观察对象。</p><p id="53e0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><em class="mq">注意:</em> <code class="fe pa pb pc or b"><em class="mq">async</em></code> <em class="mq">管道自动订阅和取消订阅可观测量，允许我们使用</em> <code class="fe pa pb pc or b"><em class="mq">ngFor</em></code> <em class="mq">轻松地遍历它们。</em></p><p id="c00b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们将使用<code class="fe pa pb pc or b">mat-card</code>组件来显示我们的口袋妖怪数据，并使它看起来很漂亮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表组件模板<a class="ae ky" href="https://gist.github.com/NyaGarcia/1178db3ff0af5ec507c34d5e515b1a5d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/1178 db 3 ff 0 af 5 EC 507 c 34 D5 e 515 B1 a5d</a></p></figure><p id="4d95" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一些CSS:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表样式<a class="ae ky" href="https://gist.github.com/NyaGarcia/50a344a4eab10450ecb6fdc9bccb7718" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/50a 344 a4 eab 10450 ECB 6 FDC 9 bccb 7718</a></p></figure><p id="2f60" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">厉害！我们的<code class="fe pa pb pc or b">list</code>组件准备好了。</p><h2 id="18ee" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated">口袋妖怪的细节</h2><p id="76bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还需要一个细节组件，它将显示我们选择的口袋妖怪的信息。该组件还将有删除和更新按钮。让我们在我们的<code class="fe pa pb pc or b">components</code>目录中创建它:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="5121" class="na la it or b gy ov ow l ox oy">ng g c detail</span></pre><p id="85fa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">该组件将通过<code class="fe pa pb pc or b">@Input</code>从<code class="fe pa pb pc or b">pokemon</code>组件接收选定的口袋妖怪。然后，在模板中，我们将显示那个口袋妖怪的数据。在我们的<code class="fe pa pb pc or b">detail.component.html</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">详细模板<a class="ae ky" href="https://gist.github.com/NyaGarcia/db904237991ef4348c92d072f41fc47d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/db 904237991 ef 4348 c 92d 072 f 41 fc 47d</a></p></figure><p id="4cc4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如您所见，我们添加了更新和删除按钮。点击更新按钮将调用<code class="fe pa pb pc or b">update</code>函数，点击删除按钮将调用<code class="fe pa pb pc or b">delete</code>函数。这些函数将使<code class="fe pa pb pc or b">updatePokemon</code>和<code class="fe pa pb pc or b">deletePokemon</code>事件发射器发出一个值，让父组件知道我们点击了哪个按钮。然后，家长可以相应地采取行动。下面是我们的组件实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">细节组件逻辑<a class="ae ky" href="https://gist.github.com/NyaGarcia/f7e46f4150f40fc5f1ed3309d020097d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/f 7 e 46 f 4150 f 40 fc 5 f1 ed 3309d 020097d</a></p></figure><p id="6c1e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">注意我们是如何在两个事件发射器中发送<code class="fe pa pb pc or b">void</code>值的？这是因为我们不需要向父组件发送任何实际数据，我们只想知道用户何时单击子组件中的更新或删除按钮，并做出相应的反应。</p><p id="6348" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们添加一些样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">细节造型<a class="ae ky" href="https://gist.github.com/NyaGarcia/a51ee9b2b35bf50aa4f255d24e12d3a2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/a 51ee 9 b 35 BF 50 aa 4 f 255d 24 e 12d 3 a 2</a></p></figure><p id="8e4e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">仅此而已！我们的零件准备好了。这是我们的最后一个表示组件，所以我们现在准备开始我们的智能，充满逻辑的组件:口袋妖怪组件。</p><h2 id="7ede" class="na la it bd lb nb nc dn lf nd ne dp lj ma nf ng ll me nh ni ln mi nj nk lp nl bi translated"><strong class="ak">口袋妖怪组件</strong></h2><p id="eb83" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该组件将包含与Firestore服务通信的所有必要逻辑，并为其他表示组件(表单、列表和细节)提供它们需要显示的数据。它作为一种控制器，指导我们的应用程序的数据流。让我们看一下我们的<code class="fe pa pb pc or b">pokemon.component.ts</code>文件，然后开始吧。</p><p id="71ca" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们需要做的第一件事是在构造函数中注入<code class="fe pa pb pc or b">PokemonFirestoreService</code>，以及表单的<code class="fe pa pb pc or b">MatDialog</code>。我们还将创建两个类变量:</p><ul class=""><li id="4646" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated">一个<code class="fe pa pb pc or b">allPokemon$</code>变量，我们将通过调用<code class="fe pa pb pc or b">pokemonService.getAll()</code>函数在<code class="fe pa pb pc or b">ngOnInit</code>中初始化它。</li><li id="34aa" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">一个<code class="fe pa pb pc or b">selectedPokemon</code>变量，将包含选中的口袋妖怪。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建类变量和添加依赖关系<a class="ae ky" href="https://gist.github.com/NyaGarcia/96dc6554ba14697982d9ecbfcda5a601" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/96dc 6554 ba 14697982d 9 ecbfcda 5 a 601</a></p></figure><p id="f3cf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">厉害！我们继续。我们的口袋妖怪组件将包含以下方法:</p><ul class=""><li id="9eff" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">addPokemon</code>:该方法将打开表单对话框，对话框关闭后，将过滤掉falsy值的流，然后调用<code class="fe pa pb pc or b">pokemonService.create</code>函数，用表单数据创建一个新的Pokemon。</li><li id="6537" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">updatePokemon</code>:该方法与<code class="fe pa pb pc or b">addPokemon</code>类似。它还打开表单对话框，将<code class="fe pa pb pc or b">selectedPokemon</code>作为数据传递，这样我们可以更新它的值。一旦对话框关闭，它也会过滤流，然后调用<code class="fe pa pb pc or b">pokemonService.update</code>函数来更新口袋妖怪。最后，它用新的口袋妖怪数据更新<code class="fe pa pb pc or b">selectedPokemon</code>。</li><li id="5a62" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">selectPokemon</code>:该方法接收一个<code class="fe pa pb pc or b">Pokemon</code>，并相应地更新<code class="fe pa pb pc or b">selectedPokemon</code>类变量。</li><li id="1857" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">deletePokemon:</code>这个方法用<code class="fe pa pb pc or b">selectedPokemon.id</code>调用<code class="fe pa pb pc or b">pokemonService.delete</code>函数。它还将<code class="fe pa pb pc or b">selectedPokemon</code>设置为<code class="fe pa pb pc or b">undefined</code>。</li></ul><p id="e9c6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">下面是这些方法的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现逻辑<a class="ae ky" href="https://gist.github.com/NyaGarcia/b69cd88602f3c348ddc340d8e9060bca" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/b 69 CD 88602 F3 c 348 DDC 340 D8 e 9060 BCA</a></p></figure><p id="4a9f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们需要做的最后一件事是配置模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">口袋妖怪组件模板<a class="ae ky" href="https://gist.github.com/NyaGarcia/30249fdad5bd84e0a4c381e89a727ed0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/30249 fdad 5 BD 84 E0 a4 c 381 e 89 a 727 ed 0</a></p></figure><p id="8ce1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果您不熟悉绑定语法，我将简单解释一下。让我们来看看<code class="fe pa pb pc or b">app-list</code>:</p><ul class=""><li id="1f69" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">[pokemon$]="pokemon$"</code>:这叫做属性绑定。还记得我们在<code class="fe pa pb pc or b">app-list</code>组件中使用<code class="fe pa pb pc or b">Input()</code>装饰器来创建<code class="fe pa pb pc or b">pokemon$</code>变量，该变量将从父组件接收其值吗？通过这个属性绑定，我们将子节点的<code class="fe pa pb pc or b">pokemon$</code>变量绑定到父节点的<code class="fe pa pb pc or b">allPokemon$</code>变量。您可以将此视为将<code class="fe pa pb pc or b">allPokemon$</code>变量“发送”给孩子。</li><li id="5f5e" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><code class="fe pa pb pc or b">(pokemonEmitter)="selectPokemon($event)"</code>:这叫做事件绑定。它将我们使用<code class="fe pa pb pc or b">app-list</code>组件(子组件)中的<code class="fe pa pb pc or b">Output()</code>装饰器创建的<code class="fe pa pb pc or b">pokemonEmitter</code>事件与我们在该组件(父组件)中实现的<code class="fe pa pb pc or b">selectPokemon</code>函数连接起来。当子组件中的<code class="fe pa pb pc or b">PokemonEmitter</code>发出一个值时，父组件在<code class="fe pa pb pc or b">$event</code>中接收它并将其传递给<code class="fe pa pb pc or b">selectPokemon</code>函数。</li></ul><p id="2f25" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">下图解释了<code class="fe pa pb pc or b">input</code>和<code class="fe pa pb pc or b">output</code>语法的工作原理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/b48bd6af810538504ac619e49552905e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXxdK6FfUzkf2vDyBgOBsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">角度文档中的输入/输出示例图</p></figure><p id="c4d9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">你可以在<a class="ae ky" href="https://angular.io/guide/inputs-outputs" rel="noopener ugc nofollow" target="_blank">官方角度文档中了解更多信息。</a></p><p id="c645" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后，让我们添加一点CSS来使它看起来更容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向口袋妖怪组件添加样式<a class="ae ky" href="https://gist.github.com/NyaGarcia/4a190eac2f6dcb6abc45d855070e2938" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/4a 190 ea C2 f 6 dcb 6 ABC 45d 855070 e 2938</a></p></figure><p id="fd16" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我们完了！让我们继续测试，看看一切是否正常。如果您还没有在终端上运行<code class="fe pa pb pc or b">npm start</code>,请在浏览器上运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/650f2ea9fda9d175732c8ed0f75480eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RiFtaZT3BkXzfIUncVmlDA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试应用程序</p></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="6f71" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">重构:处理订阅</h1><p id="749a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用Observables的一个危险是内存泄漏。这是为什么呢？因为，一旦我们订阅了一个可观察对象，它就会无限期地发出值<strong class="lt iu"> </strong>，直到满足以下两个条件之一:</p><ol class=""><li id="d31e" class="nm nn it lt b lu mr lx ms ma pg me ph mi pi mm pm ns nt nu bi translated">我们手动取消订阅可观察的。</li><li id="c4a3" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm pm ns nt nu bi translated">它完成了。</li></ol><p id="33c1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">正如你可能想象的那样，这会给我们带来问题，这就是为什么总是确保订阅得到正确处理是很重要的。</p><p id="5cd5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">当使用Angular时，<code class="fe pa pb pc or b">async</code>管道为我们处理订阅，但是，由于我们只能在组件模板中使用它，每当我们必须订阅组件类中的可观察对象时(就像我们在<code class="fe pa pb pc or b">pokemon.component.ts</code>中所做的那样)，我们将不得不自己处理订阅。怎么会？</p><p id="772d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">嗯，我们可以使用一个Subject和<code class="fe pa pb pc or b">takeUntil()</code>操作符，在组件被销毁时强制我们的可观察对象完成。我们来实施吧。</p><p id="402e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">首先，我们将在<code class="fe pa pb pc or b">pokemon.component.ts</code>文件中创建一个<code class="fe pa pb pc or b">destroyed$</code>主题:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="6d6a" class="na la it or b gy ov ow l ox oy">destroyed$ = new Subject&lt;void&gt;();</span></pre><p id="b9e1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">然后，我们将使用组件被破坏时触发的<code class="fe pa pb pc or b">ngOnDestroy</code>钩子，让我们的主题发出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使销毁的subject发出<a class="ae ky" href="https://gist.github.com/NyaGarcia/77dc5c92858cb830b1d2bc634813bca9" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/77 DC 5c 92858 CB 830 B1 D2 BC 634813 BC a9</a></p></figure><p id="121a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">最后，同样重要的是，当<code class="fe pa pb pc or b">destroyed$</code>主题发出一个值时，我们将使用前面提到的<code class="fe pa pb pc or b">takeUntil</code>操作符来完成我们的Observables:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用take until<a class="ae ky" href="https://gist.github.com/NyaGarcia/1e843737e543cba44d42135f628df493" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/1e 843737 e 543 CBA 44d 42135 f 628 df 493</a></p></figure><p id="89ac" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">经过所有的更改后，我们的<code class="fe pa pb pc or b">pokemon.component.ts</code>文件将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">办理订阅<a class="ae ky" href="https://gist.github.com/NyaGarcia/25aae4e57cb15721de334f2c33822f23" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nya Garcia/25 aae 4 e 57 CB 15721 de 334 F2 c 33822 f 23</a></p></figure><h1 id="81d0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="ec7b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">那都是乡亲们！希望您已经学会了如何使用Angular 14和最新的AngularFire 7模块化SDK创建CRUD应用程序。</p><p id="d284" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">请记住，新的API并不完整，所以如果您决定继续使用它，那么风险自负。此外，请记住，AngularFire 7提供了一个兼容层，以便您可以继续使用以前的AngularFire 6 API。</p><p id="36c6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我希望你喜欢这个教程，并发现它很有用。感谢您的阅读！</p></div></div>    
</body>
</html>