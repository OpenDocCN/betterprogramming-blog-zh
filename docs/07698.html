<html>
<head>
<title>Here’s One NgRx Pattern to Control Your Angular Loading Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这里有一个NgRx模式来控制你的角度加载动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/heres-one-ngrx-pattern-to-control-your-angular-loading-animations-f15bc3c4a1dd?source=collection_archive---------7-----------------------#2021-02-10">https://betterprogramming.pub/heres-one-ngrx-pattern-to-control-your-angular-loading-animations-f15bc3c4a1dd?source=collection_archive---------7-----------------------#2021-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="474b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">控制从NgRx效果加载屏幕</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a709e8e4d3364eb2292916330032d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKuvmDtWsxvG0BEBuPF5LA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5ead" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用NgRx进行状态管理，那么没有比NgRx Effects更好的地方来管理您的加载UI了。</p><p id="ae50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当制作数据库CRUDs或执行用NgRx Effects实现的异步任务时，不要在组件中摆弄加载屏幕，而是尝试在Effects中使用这个简单的模式来控制UI。这种模式干净、简单，并且可以轻松地扩展成你想要的任何数量的UI动画。你可以很容易地修改任何现有的效果，你必须使用这种模式。</p><p id="7a47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文假设您已经熟悉NgRx和效果。它不包括如何设置和使用NgRx的基础知识。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7dbe" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">这种模式是如何工作的</h1><p id="edf8" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这种模式使用NgRx存储中的一个<code class="fe my mz na nb b">ui</code>对象来切换在<code class="fe my mz na nb b">app.component.html</code>或任何其他组件中加载动画。</p><p id="c4f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，在一个动作文件中创建一个动作。您还可以创建一个新的动作文件来专门处理您的UI。创建一个专门处理UI加载的文件可能是明智的，因为你必须将你的动作<em class="nc"> </em>导入到许多不同的效果文件中来处理你所有的UI需求，如果你不需要，你不希望将不必要的数据导入到一个效果中。让我们把这个新文件叫做<code class="fe my mz na nb b">ui.actions.ts</code>。</p><p id="072f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是<code class="fe my mz na nb b">ui.actions.ts</code> <em class="nc">的代码。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ea7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，创建一个名为<code class="fe my mz na nb b">ui.reducer.ts</code>的减速器。对于每个异步检索数据的效果，您需要在<code class="fe my mz na nb b">ui</code>对象(第9行)中有三个属性以及它们的默认值。</p><p id="363b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中是:<code class="fe my mz na nb b">gettingDocError: null, gettingDocSuccess: false, gettingDoc: false</code>。为了从其他效果中控制UI，您为该效果添加了三个不同的属性，比如<code class="fe my mz na nb b">someOtherAsyncError: null, someOtherAsyncSuccess: false, gettingSomeOtherAsync: false</code>。<code class="fe my mz na nb b">ui.reducer.ts</code> <em class="nc"> </em>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="227a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续效果:所有的控制都发生在这里，如下面的代码块所示，它显示了文件<code class="fe my mz na nb b">some.effects.ts</code>。这是打开和关闭加载/成功/错误屏幕的地方。您可以将<code class="fe my mz na nb b">ui.actions</code>导入到任何想要控制加载UI的效果文件中。我在下面的代码中的第8行导入了<code class="fe my mz na nb b">ui.actions</code>。</p><p id="4f44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在效果<code class="fe my mz na nb b">GetDocFromFirebase$</code>(第20行)中，有三个<code class="fe my mz na nb b">ui</code>对象属性被切换——一个表示错误，一个表示成功，还有一个向用户表明正在获取数据。这些是:<code class="fe my mz na nb b">gettingDocError</code>、<code class="fe my mz na nb b">gettingDocSuccess</code>和<code class="fe my mz na nb b">gettingDoc</code>。</p><p id="7eeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦效果被调度，在调用异步数据之前，这些变量应该被设置为新值，如第24行所示。<code class="fe my mz na nb b">gettingDocError</code>和<code class="fe my mz na nb b">gettingDocSuccess</code>应重置为默认值，因为它们在<code class="fe my mz na nb b">ui.reducer.ts</code> <em class="nc">中。</em></p><p id="a26b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要切换这些属性，使用<code class="fe my mz na nb b">tap</code>操作符来分派包含对象<code class="fe my mz na nb b">{ gettingDocError: null, gettingDocSuccess: false, gettingDoc: true }</code>的<code class="fe my mz na nb b">new uiActions.Ui({})</code>。注意，<code class="fe my mz na nb b">gettingDoc</code>属性被打开，从而导致<code class="fe my mz na nb b">app.component.ts</code>中的加载UI屏幕被显示给用户(这将在后面描述)。</p><p id="07aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缩减器<code class="fe my mz na nb b">ui.reducer.ts</code> <em class="nc"> </em>将接收该对象，并将存储对象<code class="fe my mz na nb b">ui</code>设置为这些值。</p><p id="a916" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第30行，在数据从后端返回后，属性<code class="fe my mz na nb b">gettingDoc</code>被设置为<code class="fe my mz na nb b">false</code>，这将取消在获取数据时显示给用户的<code class="fe my mz na nb b">app.component.ts</code>中的加载UI屏幕。同时,<code class="fe my mz na nb b">gettingDocSuccess</code>属性切换到<code class="fe my mz na nb b">true</code>,向用户显示成功屏幕。</p><p id="2eba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第32行，<code class="fe my mz na nb b">gettingDocSuccess</code>属性被切换到<code class="fe my mz na nb b">false</code>，因此成功屏幕被关闭。为此，在<code class="fe my mz na nb b">tap</code>操作器中使用了<code class="fe my mz na nb b">2s</code>中的<code class="fe my mz na nb b">setTimeout</code>。这意味着用户将会看到两秒钟的成功屏幕。</p><p id="a0aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，你需要考虑到错误。如果在检索数据时出现错误，这将被底部的<code class="fe my mz na nb b">catchError</code>操作符捕获(如果在第26行出现错误，第27行和第36行之间的所有其他操作符将被跳过，只有<code class="fe my mz na nb b">catchError</code>将运行)。</p><p id="e62a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用<code class="fe my mz na nb b">return of(new uiActions.Ui({ gettingDocError: err, gettingDoc: false })</code>设置<code class="fe my mz na nb b">gettingDocError</code>属性(第39行)。这将打开错误屏幕，以便用户可以看到有错误并采取行动。</p><p id="ba79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，<code class="fe my mz na nb b">gettingDoc</code>属性同时也被设置为<code class="fe my mz na nb b">false</code>。这是因为当动作开始时，<code class="fe my mz na nb b">gettingDoc</code>属性被设置为<code class="fe my mz na nb b">true</code>，向用户显示加载屏幕，现在加载屏幕必须关闭。</p><p id="903c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第41行，<code class="fe my mz na nb b">gettingDocError</code>属性在四秒钟后使用<code class="fe my mz na nb b">setTimeout</code>被重置回null。这意味着用户将会看到4秒钟的错误屏幕。这就完成了异步获取数据的一个动作的加载屏幕的处理周期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="46b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是简单的部分——向用户显示加载屏幕。在<code class="fe my mz na nb b">app.component.ts</code>中，添加类级变量:<br/> <code class="fe my mz na nb b">ui$ = this.store.pipe(select(fromAuth.ui));</code>(第11行)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="46f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe my mz na nb b">app.component.html</code>中，使用<code class="fe my mz na nb b">| async</code>订阅<code class="fe my mz na nb b">ui$</code>，并使用<code class="fe my mz na nb b">*ngIf="(ui$ | async)?.gettingDocError !== null"</code>打开和关闭错误<code class="fe my mz na nb b">div</code>。请注意，在上述<code class="fe my mz na nb b">some.effects.ts</code>中的效果<code class="fe my mz na nb b">GetDocFromFirebase$</code>中，错误是用错误消息字符串设置的，而不仅仅是<code class="fe my mz na nb b">true</code>或<code class="fe my mz na nb b">false</code>，因此现在可以向用户显示该错误消息。</p><p id="d077" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对<code class="fe my mz na nb b">gettingDocSuccess</code>和<code class="fe my mz na nb b">gettingDoc</code>进行同样的操作。你可以像我一样为每个装载场景创建特殊的组件——例如，<code class="fe my mz na nb b">&lt;app-ui-error&gt;</code>、<code class="fe my mz na nb b">&lt;app-ui-success&gt;</code>和<code class="fe my mz na nb b">&lt;app-ui-gettingDoc&gt;</code>。在这些定制组件中，您可以拥有您想要的任何东西，比如gif、CSS loaders、SVG或图片。</p><p id="5491" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您不必只使用<code class="fe my mz na nb b">app.component.ts</code>中的加载动画。您可以订阅任何组件中的<code class="fe my mz na nb b">ui</code>对象，并使用<code class="fe my mz na nb b">| async</code>控制该组件模板中动画的加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7f0d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="7c8f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在为<code class="fe my mz na nb b">ui</code>对象设置了初始动作和reducer之后，这种模式是高度可伸缩的。现在，所有对数据库的异步调用都可以干净、轻松地触发UI动画。</p><p id="cdf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。如果你喜欢这篇文章，可以考虑<a class="ae nf" href="https://craftedwebpages.medium.com/membership" rel="noopener">在这里</a>订阅中级会员，以获得数以千计的其他文章。</p><p id="e348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以后我会发更多Angular，RxJS，NgRx，通用编程的文章。</p></div></div>    
</body>
</html>