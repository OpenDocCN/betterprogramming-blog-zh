<html>
<head>
<title>4 Clean Code Principles for Functional Programming in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala函数式编程的4条简洁代码原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-clean-code-principles-for-functional-programming-in-scala-6764f8b2a213?source=collection_archive---------14-----------------------#2021-02-12">https://betterprogramming.pub/4-clean-code-principles-for-functional-programming-in-scala-6764f8b2a213?source=collection_archive---------14-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cece" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">隔离您的I/O，避免过度嵌套，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e71d5dc1a5c65fdf754f0788bda9b8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-ZlxCfq9n3jHuD3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sp3v?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯潘塞·埃弗雷特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写命令式代码时，有许多原则和设计模式。例如，有四本书提到了编写维护良好的面向对象代码的23种不同方法。您一定听说过SOLID principles、DRY principles和许多其他关于编写干净代码的原则的缩写。</p><p id="d5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在编写功能性代码时，一些命令性代码原则可能不适用。</p><p id="9db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误会，SOLID和其他设计模式原则对于构造可读代码非常有用。然而，软件工程师可以采用特定于函数式编程的规则来编写可读代码——尤其是在围绕纯函数创建代码时。由于可用编程促进了不变性和纯函数，您考虑构建代码的方式不同于编写命令式代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6b0510f5ca5769e1864c8f5ebac36e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xjMy4aJFI9bfYWHO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="867e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在面向对象编程中有一个策略模式，因为你没有办法创建一个lambda函数。我将提取经典的<code class="fe lw lx ly lz b">shape</code>类，其中每个形状都将打印该形状的名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有更高阶的函数，可以创建一个lambda函数将其传递给<code class="fe lw lx ly lz b">SomeClass</code>。上面的策略模式可以浓缩成几行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ae3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想分享编写可读代码的四个一般原则，您可以在编写函数时应用这些原则。</p><p id="ea71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">免责声明:这些都不是硬性规定，如果你有任何其他模式可以帮助你写出可读性更好的代码，请在下面的评论区分享吧！</em></p><p id="b306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有吻干原则，这是从命令性代码到功能性代码的合理原则。我不会在这里提及它们，因为它们已经被广泛涉及。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="f1cf" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.不要过度筑巢</h1><p id="23b2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我自己也有这个问题。因为函数代码中没有状态，所以大部分代码都是一系列的表达式。拥有多个嵌套表达式似乎是正确的。当你处于心流状态时，写作会更容易。</p><p id="fa6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于过度嵌套的另一件事是，我们倾向于将事情一般化以使它们可重用(DRY原则)，但这样会损害代码的可读性。当你回去读它的时候，你经常会对你的代码中发生的事情感到困惑。</p><p id="f1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c6b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以用名字清晰的更小的函数来重构它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="fa05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然你不知道这个功能是做什么的，但至少它对眼睛来说更容易。</p><p id="7df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，函数式编程将代码分解成一行。其中一个原因是，这是最基本的操作原语，不能用其他操作符来实现。试着将函数分解成多个更小的函数——你会发现你的代码更容易组合。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8472" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2.不要去掉中间变量</h1><p id="3113" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当人们想到函数式编程或Scala时，一个常见的抱怨是人们喜欢一行程序。由于每个表达式返回一个值，我们可以将它们链接在一起来编写函数。尽管我们需要输入更多的击键，但当你的代码没有任何错误时，你可能会感谢我。</p><p id="398d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala中有多种通用操作可以帮助你在<a class="ae ky" href="https://gist.github.com/mkaz/d11f8f08719d6d27bab5" rel="noopener ugc nofollow" target="_blank">一行</a>中编写代码。就拿上面的例子来说吧。在<code class="fe lw lx ly lz b">incrementByOneAndMultipleByTwoWith(x:Int)</code>里面，我不去掉中间值。它看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="304b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，具有中间值可以帮助您理解代码，并使调试代码库更快。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d958" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">3.如果有对应的标准库，就不要使用模式匹配</h1><p id="5968" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">模式匹配很酷的原因之一是你可以用它做任何事情。如果我想得到一个选项的值，我可以通过模式匹配来得到这个选项的值。如果我想反转一个整数数组，我可以做模式匹配来改变一个整数数组。</p><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它的优点也是它的缺点。因为它太普通了，你通过重新发明现有的代码来打破枯燥的原则。您可以使用<code class="fe lw lx ly lz b">getOrElse</code>，而不是使用模式匹配来获取选项monad中的值，这具有相同的目的。不用使用模式匹配来反转整数数组，你可以只使用标准库<code class="fe lw lx ly lz b">reverse</code>。</p><p id="7c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，不是所有的规则都是硬性规则。使用模式匹配时也有例外。如果你想应用的操作不在标准库中，你需要使用它。如果你在你的函数上做些尝试，并且模式匹配更容易理解，你应该选择模式匹配。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="fd80" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">4.隔离您的I/O</h1><p id="73ab" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">编写函数代码并不意味着你所有的函数都必须是纯函数。功能性编写就是知道如何将I/O推到边界的尽头。我们想把不纯的调用隔离在一个地方。</p><p id="47a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些函数式编程语言，如Haskell，是在语言本身中实现的。然而，当它不是强制的时候，试着把所有的I/O调用放在你的程序边界的末端或者一个小盒子里，这样可以帮助你的代码更容易维护。然后，您可以突然快速地对代码进行单元测试，因为这些函数是纯函数。</p><p id="e3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过分离I/O并返回一个<code class="fe lw lx ly lz b">String</code>来进一步将I/O的边界推到边缘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2a1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们可以这样称呼它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="864e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以快速测试<code class="fe lw lx ly lz b">contest</code>函数，因为<code class="fe lw lx ly lz b">contest</code>变成了一个纯函数。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="96af" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="ec62" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">就是这样！我希望您在编写可读的功能性代码方面得到了一些指导。请记住，这些原则更像是指导方针，而不是规则。</p><p id="4b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道任何隐藏的模式或者创建更多模块化代码的方法，请在下面评论让全世界都知道！</p><p id="6480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">最初发表于</em><a class="ae ky" href="https://edward-huang.com/programming/scala/functional-programming/2021/02/10/4-clean-code-principles-for-functional-programming/" rel="noopener ugc nofollow" target="_blank"><em class="mc"/></a><em class="mc">。</em></p></div></div>    
</body>
</html>