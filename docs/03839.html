<html>
<head>
<title>How to Build an Offline-First React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建离线优先的React应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/offline-first-react-app-b79ab1a17649?source=collection_archive---------0-----------------------#2020-03-08">https://betterprogramming.pub/offline-first-react-app-b79ab1a17649?source=collection_archive---------0-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用户不会总是有很好的连接，从一开始就做好准备</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86b3c635d86033108c73a3fba0222758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUGTHMA6lnlK-CxOn7hvUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克尔·泽兹奇在<a class="ae ky" href="https://unsplash.com/s/photos/patterns-tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为一个离线优先的React应用程序做了一个概念验证，并决定与开发者社区分享它。</p><p id="0fd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在开发一个ReactJS应用程序，即使出现网络问题，我们也不能承受CRUD操作的任何暂停。让我们看看如何实现这一点。我将使用Redux进行商店管理。</p><p id="a5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从安装必要的库开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c6ef" class="ma mb it lw b gy mc md l me mf">npm install redux-offline --save</span></pre><p id="10bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<a class="ae ky" href="https://github.com/redux-offline/redux-offline" rel="noopener ugc nofollow" target="_blank">库</a>对于为web和React-native构建离线优先的应用程序来说非常方便。</p><p id="6653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后安装<code class="fe mg mh mi lw b">localforage</code>，因为我们将使用<code class="fe mg mh mi lw b"><a class="ae ky" href="https://javascript.info/indexeddb" rel="noopener ugc nofollow" target="_blank">indexedDB</a></code>而不是<code class="fe mg mh mi lw b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">localStorage</a></code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39b0" class="ma mb it lw b gy mc md l me mf">npm install localforage --save</span></pre><p id="95d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本例中使用的其他库有:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ed38" class="ma mb it lw b gy mc md l me mf">- <a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">redux</a><br/>- <a class="ae ky" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank">redux-thunk</a><br/>- <a class="ae ky" href="https://github.com/LogRocket/redux-logger" rel="noopener ugc nofollow" target="_blank">redux-logger</a><br/>- <a class="ae ky" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank">react-redux</a></span></pre><p id="968a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过单击这些库的名称来了解它们。</p><p id="e8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux store会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e0af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将编写一个React组件来与Redux存储交互:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mg mh mi lw b">redux/actions/app.js</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mg mh mi lw b">redux/reducers/app.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！</p><p id="e3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们在React组件中创建的文本字段中插入一个项目名称后单击“Add”按钮时，它通过使用我们在操作中编写的<code class="fe mg mh mi lw b">useDispatch</code>钩子向我们的本地API ( <code class="fe mg mh mi lw b">/api/sample</code>)发出一个<code class="fe mg mh mi lw b">POST HTTP</code>请求来调度一个操作。Reducer将采用初始状态，并基于该动作返回期望的结果——我们新添加的项目。</p><p id="3f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子<code class="fe mg mh mi lw b">useSelector</code>将在我们组件中获得更新后的值。</p><p id="944b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住:<code class="fe mg mh mi lw b">useSelector</code>是<code class="fe mg mh mi lw b">connect</code>的<code class="fe mg mh mi lw b">mapStateToProps</code>的替代。您传递给它一个函数，该函数接受Redux存储状态并返回您需要的状态，然后<code class="fe mg mh mi lw b">useDispatch</code>替换<code class="fe mg mh mi lw b">connect</code>的<code class="fe mg mh mi lw b">mapDispatchToProps</code>。它所做的只是返回你的商店的<code class="fe mg mh mi lw b">dispatch</code>方法，这样你就可以手动分派动作。</p><p id="dc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果互联网以某种方式断开或有网络问题，那么神奇开始了！</p><p id="db51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将试图攻击我们的API ( <code class="fe mg mh mi lw b">/api/sample</code>)，当然，由于缺乏网络连接，它不能这样做。相反，它将开始与我们已经在商店中配置的<code class="fe mg mh mi lw b">indexedDB</code>交互，并在特定的时间间隔(我们也可以设置时间间隔)后继续尝试访问API。通过<code class="fe mg mh mi lw b">POST HTTP</code>请求发布的所有数据将保存在<code class="fe mg mh mi lw b">indexedDB</code>中。一旦网络恢复，它会将数据从<code class="fe mg mh mi lw b">indexedDB</code>移动到我们的主<code class="fe mg mh mi lw b">DB</code>，并将我们的主<code class="fe mg mh mi lw b">DB</code>与<code class="fe mg mh mi lw b">indexedDB</code>同步。</p><p id="71d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终用户永远不会有互联网断开的印象，可以继续正常的CRUD操作。</p><p id="de45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是不是很酷？</p><p id="663a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个高效的离线优先应用程序应该考虑以下几个方面:</p><ul class=""><li id="824b" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">当从服务器得到不正确的答复(例如，超时)时，尝试重新发送请求。</li><li id="f303" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">仅当我们检测到互联网连接或我们的API启动时发送请求。</li><li id="7638" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">动作排队。</li><li id="3bc0" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">在重新启动应用程序之间保持一个动作队列。</li></ul><p id="cb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux offline是一个完整的解决方案，它实现了上述功能，还允许您配置:</p><ul class=""><li id="1350" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">重新发送请求时服务器请求之间的时间间隔。</li><li id="78ac" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">回滚前失败的请求数。</li><li id="dbf0" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">用于处理这些请求的库(例如，<code class="fe mg mh mi lw b">axios</code>)。</li><li id="cc8a" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">队列实现。</li><li id="8392" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">改变配置。</li></ul><p id="af8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们需要记住，如果用户无法以某种方式打开我们的页面，他将无法下载所有的逻辑，因此应用程序将不会加载。在ReactNative中就不是这样了，在react native中，我们可以在应用程序打开后立即访问应用程序逻辑。</p><p id="8701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信您现在已经完全准备好动手开发一个离线优先的React应用程序了！</p><p id="b5c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回购完全可行的例子:<a class="ae ky" href="https://github.com/mansern/offline-first-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/mansern/offline-first-demo</a></p><p id="5349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你今天学到新东西了吗？评论和反馈总是让作者开心！</p><h2 id="8cde" class="ma mb it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">关于作者</h2><p id="0c93" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated"><em class="nv">我在各种前沿技术领域拥有超过七年的专业软件开发经验，目前在硅谷的一家公司担任首席软件工程师，使用ReactJs和Apollo-GraphQL进行全栈开发。我喜欢写关于技术的文章，并与大家分享我的专业经验。</em></p></div></div>    
</body>
</html>