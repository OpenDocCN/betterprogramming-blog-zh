<html>
<head>
<title>Is Deep Cloning Coming to Our Browsers?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度克隆会出现在我们的浏览器中吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-deep-cloning-coming-to-our-browsers-b703acde29eb?source=collection_archive---------11-----------------------#2020-04-24">https://betterprogramming.pub/is-deep-cloning-coming-to-our-browsers-b703acde29eb?source=collection_archive---------11-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">阅读关于结构化克隆算法在主流浏览器中可能暴露的信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33f5a1b65c7772e907ea3912924795d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*81R7Fo0HlQH7kSGh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲尔·肖在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有很多关于JavaScript深度克隆的讨论。虽然有针对浅层克隆的原生解决方案，如destructuring或<code class="fe lv lw lx ly b">Object.assign()</code> <em class="lz"> </em>，但深层克隆必须使用第三方库(如Lodash)或滥用API(如MessageChannel)来创建，以利用HTML标准提出的结构化克隆的未公开实现。</p><p id="fbb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Lodash等第三方库的使用情况、关于堆栈溢出的JavaScript深度克隆问题的流行程度以及<code class="fe lv lw lx ly b">JSON.parse(JSON.stringify(...)</code>的常见(在许多情况下也是有问题的)用法，开发人员似乎对原生解决方案有很大的需求。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b1a1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结构化克隆</h1><p id="858f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">结构化克隆算法是由HTML标准提出的，已经在普通浏览器中实现，并且在内部使用(例如，用于在web workers之间传输数据或者用IndexedDB存储数据)。</p><p id="e83b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它递归地遍历要克隆的对象，并维护一个已访问引用的映射，以避免无限循环。因此，例如，与<code class="fe lv lw lx ly b">JSON.parse(JSON.stringify(...))</code>方法相比，循环结构对于该算法来说不是问题。</p><p id="4faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript领域中，这意味着支持大多数类型(如Date、RegExp、Array、Object、Map和Set)。但是，原型链没有考虑，还有一些事情要处理。如果您感兴趣，请查看下面参考资料中的MDN Web文档链接。</p><h2 id="589a" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">结构化克隆与深度克隆</h2><p id="4b21" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><em class="lz">深度克隆</em>(也称为<em class="lz">深度复制</em>)是对象的副本，以便为任何引用的对象创建新的副本。这对JavaScript对象意味着什么？这就变得困难了。虽然有些人可能对结构化数据感到满意，但其他人可能希望复制原型链。所以<em class="lz">深度克隆</em>是一个定义相当模糊的术语。</p><p id="c406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，结构化克隆算法是一种定义明确的算法，因此它很好地定义了什么是结构化克隆。可以说这是深度克隆的具体实现。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="05cb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">浏览器中的结构化克隆？</h1><p id="bffd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">虽然Node.js公开了v8 JS引擎的结构化克隆实现作为其序列化API，但许多人仍在等待浏览器的公开实现。如果你是这些人中的一员，有一个好消息:HTML规范中的一个提议已经存在。</p><p id="8e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在我写作的时候，似乎只有Firefox有兴趣实现它。然而，这个话题仍然被讨论，所以如果你渴望那个特性，不要放弃希望。</p><p id="b541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使只是在提议阶段，看起来暴露将以全局函数的形式出现<code class="fe lv lw lx ly b">structuredClone()</code>,这将使结构克隆变得简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要这个特性，我鼓励你公开结构化克隆算法，这样我们可能很快就会在主流浏览器的积压清单上看到它</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d2eb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">参考</h1><ul class=""><li id="9245" class="ns nt it lb b lc mz lf na li nu lm nv lq nw lu nx ny nz oa bi translated">HTML标准:可串行化对象</li><li id="489d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank"> MDN网络文档:结构化克隆算法</a></li><li id="151e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/whatwg/html/issues/793" rel="noopener ugc nofollow" target="_blank">https://github.com/whatwg/html/issues/793</a></li></ul></div></div>    
</body>
</html>