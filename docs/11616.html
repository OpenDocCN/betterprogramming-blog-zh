<html>
<head>
<title>Running Airflow Using Kubernetes Executor and Kubernetes Pod Operator with Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes Executor和带Istio的Kubernetes Pod操作器运行气流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-airflow-using-kubernetes-executor-and-kubernetes-pod-operator-with-istio-d5aa7af16ef5?source=collection_archive---------5-----------------------#2022-04-04">https://betterprogramming.pub/running-airflow-using-kubernetes-executor-and-kubernetes-pod-operator-with-istio-d5aa7af16ef5?source=collection_archive---------5-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e01a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">气流系列</h2><div class=""/><div class=""><h2 id="b468" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">克服障碍</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2a75102370cb0b4f0d7e895c894c43c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yCJ__xmXvWUZXmiM"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">爱德华·拉巴尔在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0567" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是Kubernetes遗嘱执行人</h1><p id="b2bf" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Kubernetes executor在Kubernetes集群上自己的pod中运行每个任务实例。这意味着对于dag中的每个任务，Kubernetes集群中都会生成一个独立的pod。pod的图像是基于气流的图像。pod将运行您的任务、PythonOperator、BashOperator等。它基本上使用pod内的气流基本映像运行气流命令“气流任务运行…”。</p><div class="mw mx gp gr my mz"><a href="https://airflow.apache.org/docs/apache-airflow/stable/executor/kubernetes.html" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">Kubernetes执行器-气流文件</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Kubernetes executor在Kubernetes集群上自己的pod中运行每个任务实例。KubernetesExecutor作为一个…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">airflow.apache.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lb mz"/></div></div></a></div><h1 id="9aa5" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是Kubernetes Pod操作员</h1><p id="9d8b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Kubernetes Pod操作符也在Kubernetes集群上创建一个新的Pod，但是图像是由您使用操作符中的图像参数来定义的。它基本上调用Kubernetes API来启动一个pod并运行您的图像，然后记录您的结果。</p><div class="mw mx gp gr my mz"><a href="https://airflow.apache.org/docs/apache-airflow-providers-cncf-kubernetes/stable/operators.html" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">KubernetesPodOperator-Apache-气流-提供商-cncf-kubernetes文档</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">KubernetesPodOperator使用Kubernetes API在Kubernetes集群中启动一个pod。通过提供图像URL…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">airflow.apache.org</p></div></div></div></a></div><h1 id="3ccf" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是Istio</h1><p id="5946" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">用最简单的语言来说，它是一个服务网络层。它控制流量如何通过每个服务。由于现代微服务架构通常包含数百或数千个服务，因此需要另一层来处理所有网络流量。它被称为服务网格。</p><p id="2d36" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">Istio将在您的pod中注入一个名为istio-proxy的sidecar，并为您处理流量。但是这阻碍了Kubernetes执行者和Kubernetes Pod操作者的正常工作流程。这是因为它们都使用Pod阶段来确定dag任务的状态。当Pod阶段成功和失败时，气流将认为任务完成。由于istio-proxy边车，pod将一直运行。只有任务容器本身完成了。这将导致成功任务中的Pod阶段变为未就绪，以及失败任务中的错误。在Airflow UI中，你会看到任务一直在运行，永无止境。</p><h2 id="1b5e" class="nt lj it bd lk nu nv dn lo nw nx dp ls mj ny nz lu mn oa ob lw mr oc od ly iz bi translated">虚幻的希望</h2><p id="7cf5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当在google中进行初始搜索时，有一个使用Kubernetes生命周期类型的优雅解决方案:Sidecar。就像下面的配置一样，您只需要将容器生命周期类型设置为sidecar，然后Kubernetes会处理所有其他的事情。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="1b9d" class="nt lj it of b gy oj ok l ol om">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: bookings-v1-b54bc7c9c-v42f6<br/>  labels:<br/>    app: demoapp<br/>spec:<br/>  containers:<br/>  - name: bookings<br/>    image: banzaicloud/allspark:0.1.1<br/>    ...<br/>  - name: istio-proxy<br/>    image: docker.io/istio/proxyv2:1.4.3<br/>    lifecycle:<br/>      type: Sidecar<br/>    ...</span></pre><div class="mw mx gp gr my mz"><a href="https://banzaicloud.com/blog/k8s-sidecars/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">Kubernetes 1.18中边车集装箱生命周期的变化</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">更新:看起来下面描述的解决方案终究不会登陆Kubernetes。开发人员回去了…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">banzaicloud.com</p></div></div><div class="ni l"><div class="on l nk nl nm ni nn lb mz"/></div></div></a></div><p id="fe62" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">然而，不知何故，上面描述的解决方案并没有像预期的那样在Kubernetes 1.18中真正实现。</p><p id="5caa" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">另一种方法是在以下情况下包装容器命令:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="ba2f" class="nt lj it of b gy oj ok l ol om">- command:<br/>  - /bin/sh<br/>  - -c<br/>  - |<br/>    until curl -fsI http://localhost:15021/healthz/ready; do echo \"Waiting for Sidecar...\"; sleep 3; done;<br/>    echo \"Sidecar available. Running the command...\";<br/>    &lt;YOUR_COMMAND&gt;;<br/>    x=$(echo $?); curl -fsI -X POST http://localhost:15020/quitquitquit &amp;&amp; exit $x</span></pre><p id="f685" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">开始时，它使用Istio端点检查边车是否已经启动。如果它启动了，那么运行您通常的命令。容器完成后，它使用Istio quitquitquit endpoint关闭istio-proxy。此功能在Istio 1.7之后可用</p><div class="mw mx gp gr my mz"><a href="https://stackoverflow.com/questions/54921054/terminate-istio-sidecar-istio-proxy-for-a-kubernetes-job-cronjob" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">为kubernetes作业/ cronjob终止istio sidecar istio代理</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我们最近开始使用istio Istio在我们的Kubernetes景观内建立服务网络。我们现在有…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">stackoverflow.com</p></div></div><div class="ni l"><div class="oo l nk nl nm ni nn lb mz"/></div></div></a></div><p id="331c" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">乍一看，这可能是我们渴望的解决方案。但是总的来说它失败了，因为我们不能覆盖生成的pod的命令。正如我之前所说的，Kubernetes executor基本上使用pod内部的气流基础映像来运行气流命令“气流任务运行…”。我们需要侵入Kubernetes执行器的源代码来添加包装器。我们绝对不想这样做。</p><p id="0b16" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">该脚本在与气流相关的作业或cronjobs中仍然有用，例如迁移数据库作业。如果您使用舵图来部署气流，以下是您应该在值YAML中输入的内容。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="86b5" class="nt lj it of b gy oj ok l ol om">migrateDatabaseJob:<br/>  args:<br/>    - "bash"<br/>    - "-c"<br/>    - |-<br/>    until curl -fsI http://localhost:15021/healthz/ready; do echo \"Waiting for Sidecar...\"; sleep 3; done;</span><span id="1ac5" class="nt lj it of b gy op ok l ol om">    echo \"Sidecar available. Running the command...\";<br/>    airflow {{ semverCompare "&gt;=2.0.0" .Values.airflowVersion | ternary "db upgrade" "upgradedb" }};</span><span id="d7a4" class="nt lj it of b gy op ok l ol om">    x=$(echo $?); curl -fsI -X POST http://localhost:15020/quitquitquit &amp;&amp; exit $x</span></pre><h1 id="5924" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">更持久的解决方案</h1><h2 id="5f85" class="nt lj it bd lk nu nv dn lo nw nx dp ls mj ny nz lu mn oa ob lw mr oc od ly iz bi translated">天文学家</h2><div class="mw mx gp gr my mz"><a href="https://www.astronomer.io/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">现代数据编排-天文学家</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用Astro构建、运行和观察数据管道，Astro是由Apache提供支持的基本数据编排平台…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www .天文学家. io</p></div></div><div class="ni l"><div class="oq l nk nl nm ni nn lb mz"/></div></div></a></div><p id="a275" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">天文学家image已经处理了这个问题，他们做了一个全新的Istio类来处理这个问题。你可以在这里查看他们的代码:【https://github.com/astronomer/airflow/pull/62/files】T2</p><p id="4ca3" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">他们利用Istio API端点quitquit，在任务完成时关闭istio-proxy。</p><p id="d6f8" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">使用天文学家的解决方案有一个主要缺点。该解决方案只处理Istio代理。还有许多其他的边车可用，例如，保险库代理注射器。Vault是一个机密存储库，vault agent injector使用pod注释来控制使用sidecar将哪个机密注入到Pod中。在这种情况下，使用天文学家的图像仍然面临同样的问题。</p><h2 id="3847" class="nt lj it bd lk nu nv dn lo nw nx dp ls mj ny nz lu mn oa ob lw mr oc od ly iz bi translated">杀死Sidecar的CronJob</h2><p id="7582" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">感谢<a class="ae lh" href="https://yogeshsharma.me/" rel="noopener ugc nofollow" target="_blank">约格什·夏尔马</a>为我们提供了一个关闭所有边车的有用脚本。我们可以部署一个CronJob来使用Kubernetes API检查pod状态，并在任务完成时终止sidecars。我们需要对容器状态进行一些检查。如果容器完成了，container _ statuses返回的字典将有一个名为<code class="fe or os ot of b">terminated</code>的字段。同样默认情况下，Airflow将任务容器命名为<code class="fe or os ot of b">base</code>。</p><p id="870c" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">我们检查容器状态，如果它被终止，那么我们在其他容器上执行exit命令并杀死它。</p><div class="mw mx gp gr my mz"><a href="https://github.com/kubernetes-client/python/issues/1138#issuecomment-717977206" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">从另一个容器中停止Pod中的容器问题#1138 kubernetes-client/python</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在pod中停止/终止另一个集装箱中的一个集装箱我有一个需要停止侧车的用例…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="ou l nk nl nm ni nn lb mz"/></div></div></a></div><p id="fdab" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">这处理了边车问题，并防止修改气流Kubernetes执行代码库。然而，Kubernetes Pod操作员可以在任意名称空间上部署Pod，让cronjob在每个名称空间上终止sidecars并不是一个好的做法。它可能会意外杀死其他有用的豆荚。(也许有些人在他们的吊舱中使用了相同的名字“基地”)</p><h2 id="c72c" class="nt lj it bd lk nu nv dn lo nw nx dp ls mj ny nz lu mn oa ob lw mr oc od ly iz bi translated">定制Kubernetes Pod操作员</h2><p id="ec7e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">最好的方法是实现一个定制的Kubernetes Pod操作符，它在基本容器(运行任务的容器)完成时关闭Pod。它包括创建一个定制的吊舱发射器。</p><p id="9195" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">让我告诉你如何一步一步地构建它。如果您跟踪Kubernetes Pod操作符的源代码，您会发现关键部分在<code class="fe or os ot of b">execute</code>方法中。它首先创建一个pod ( <code class="fe or os ot of b">get_or_create_pod</code>)，然后等待pod启动(<code class="fe or os ot of b">await_pod_start</code>)。然后使用pod管理器的<code class="fe or os ot of b">await_pod_completion</code>等待Pod完成。这是我们希望在自定义pod管理器中覆盖的方法。我们需要的是一个pod管理器，它可以在基本容器完成时考虑Pod已完成。下面是pod管理器的代码片段，您可以在第55到56行看到我们添加了检查来确定Pod是否完成。如果pod状态阶段正在运行(因为istio代理边车仍在运行),但基本容器已完成，则我们认为pod也已完成。</p><p id="5cc3" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated"><code class="fe or os ot of b">container_is_completed</code>方法就像本地的<code class="fe or os ot of b">container_is_running</code>方法一样。如果容器完成了，那么Kubernetes API的响应负载中的<code class="fe or os ot of b">container_status.state.terminated</code>将会有完成信息。要检查是否成功，exit_code字段将为0，否则，它将是另一个退出代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="7b45" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">接下来就简单了，我们只需在Kubernetes pod操作器中使用Pod管理器。正如您在下面看到的，我们的自定义操作符初始化了一个自定义pod管理器。然后我们覆盖原来的清理方法，只修改第8行。这一行检查任务是否失败。如果基础容器不成功，我们只考虑pod失败。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="5d4e" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">这样，我们终于可以在启用Istio的情况下使用Kubernetes executor和Kubernetes Pod Operator运行Airflow了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/8565de56d5a4693ccadad69679a69907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nmqj8OVfonSHQ-dq"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@jasonhogan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·霍根</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="7da1" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">一些预防措施</h1><div class="mw mx gp gr my mz"><a href="https://github.com/istio/istio/issues/25157" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">当名称长度超过63个字符时，Pod创建失败问题#25157 istio/istio</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">由于service.istio.io/canonical-name标签，当名称长度超过63个字符时，错误描述窗格创建失败…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="oy l nk nl nm ni nn lb mz"/></div></div></a></div><p id="2864" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">当您的任务名称足够长时，您可能会遇到Pod创建失败问题。气流会在你的任务名称后随机添加一个后缀，形成吊舱名称。虽然Airflow会自动处理长任务名称并安全地构建pod创建，但Istio会添加一个使用您的pod名称的附加标签<code class="fe or os ot of b">service.istio.io/canonical-name</code>。该标签名称将超过63个字符，因此pod无法创建。</p><p id="6a2b" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">感谢<a class="ae lh" href="https://github.com/kppullin" rel="noopener ugc nofollow" target="_blank">凯文·普林</a>为我们提供了变通办法。我们可以给工人分配一个特定的app.kubernetes.io/name标签或者在pod模板中解决这个问题。如果您使用官方的舵图来部署气流，我们可以在标签字段<code class="fe or os ot of b">app.kubernetes.io/name: some_name</code>中进行设置。这将修复Kubernetes执行器生成工人舱的问题。</p><p id="d9cb" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">对于Kubernetes Pod操作员，我们再次需要修改我们的客户Kubernetes Pod操作员。我们还需要将标签字段添加到pod，因此我们在自定义操作符<code class="fe or os ot of b">__init__</code>方法中将标签添加到kwargs，并传递给原始构造函数。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="bbc0" class="nt lj it of b gy oj ok l ol om">def __init__(self, *args, **kwargs):<br/>  kwargs["labels"] = kwargs.get("labels", {}) | {"app.kubernetes.io/name": "airflow_pod"}<br/>  super().__init__(*args, **kwargs)</span></pre><h1 id="800e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="ac60" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当我们使用Kubernetes executor和Kubernetes Pod Operator将气流部署到支持Istio的Kubernetes集群时，会遇到许多障碍和困难。Istio代理边车妨碍了Kubernetes执行者和Kubernetes Pod操作员的正常工作流程。它使工蜂舱永远挂起并运行。</p><p id="5049" class="pw-post-body-paragraph ma mb it mc b md no kd mf mg np kg mi mj nq ml mm mn nr mp mq mr ns mt mu mv im bi translated">气流永远不知道任务完成了。通过实现一个从Kubernetes Pod Operator继承的自定义操作符，并实现一个cronjob来终止所有这些边车，我们可以成功地将气流部署到一个支持Istio的Kubernetes集群。我希望本文能以我们的经验帮助您更顺利地部署。</p></div></div>    
</body>
</html>