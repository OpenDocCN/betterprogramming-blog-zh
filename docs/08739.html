<html>
<head>
<title>Set Up Thanos With Multi-Tenancy To Power Up Your Prometheus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用多租户设置灭霸来启动你的普罗米修斯</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/set-up-thanos-with-multi-tenancy-to-power-up-your-prometheus-70123e6ea555?source=collection_archive---------7-----------------------#2021-06-07">https://betterprogramming.pub/set-up-thanos-with-multi-tenancy-to-power-up-your-prometheus-70123e6ea555?source=collection_archive---------7-----------------------#2021-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于启用多租户的普罗米修斯和灭霸设计一个高可用性监控解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad413cf1e0de9786f2271d175a520ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oP5AEzgmI5zavA8_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克利姆·穆萨利莫夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="bbcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>是众所周知的开源监控解决方案，也是Kubernetes环境中可观测性的事实标准。</p><p id="7aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于出色的<a class="ae ky" href="https://github.com/prometheus-operator/prometheus-operator" rel="noopener ugc nofollow" target="_blank">操作符</a>使得在Kubernetes集群中部署完整的监控堆栈变得非常容易，所以它特别受欢迎:</p><ul class=""><li id="92d5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Prometheus从动态发现的端点(pod、服务等)收集指标。)然后使用PromQL提供存储指标的查询功能。</li><li id="6502" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过AlertManager，您可以创建自己的规则，在出现问题时得到通知，并与Slack或<a class="ae ky" href="https://www.pagerduty.com/" rel="noopener ugc nofollow" target="_blank"> Pager Duty </a>等流行的解决方案相集成。</li><li id="54e2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>可以添加到mix中(不包括在operator中),以便有一个漂亮的仪表板来显示所有这些指标。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/d6e05054e380f7fb0e8ec1e0f4949638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SYJgDDbJ34XMRy5j.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://prometheus.io/docs/introduction/overview/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a></p></figure><p id="867d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于普罗米修斯的运作方式，有几件事需要理解:</p><ul class=""><li id="b83e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Prometheus定期从已配置的端点收集指标。</li><li id="4727" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">端点(例如，在pod中运行的应用程序)公开端口上的指标。你可以使用<a class="ae ky" href="https://prometheus.io/docs/instrumenting/clientlibs/" rel="noopener ugc nofollow" target="_blank">官方客户端库</a>在每一种流行语言中这样做。</li><li id="919c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Prometheus将指标存储在本地的永久卷中。这里没有对象存储！</li></ul><p id="ad00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在过去的几个月里，Prometheus堆栈已经扩展到:</p><ul class=""><li id="7ca8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://grafana.com/oss/loki/" rel="noopener ugc nofollow" target="_blank"> Loki </a>用于汇总日志。</li><li id="fe9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://grafana.com/oss/tempo/" rel="noopener ugc nofollow" target="_blank">符合OpenTelemetry追踪的速度</a>。</li></ul><p id="dbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将关注核心堆栈以及如何构建一个健壮的、可伸缩的Prometheus设置。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7385" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">挑战</h1><h2 id="9c56" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">高可用性</h2><p id="f65d" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">但是，如果您希望Prometheus系统具有高可用性，该怎么办呢？通常，您会添加第二个实例，然后在您的两个实例前面进行某种负载平衡，这样就完成了。</p><p id="0d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在这种情况下不会，因为在普罗米修斯中没有“集群模式”。Prometheus的每个实例将独立运行，从相同的端点获取相同的指标，并将数据存储在本地文件系统中。两个实例的指标在开始时是相同的，但随着时间的推移会逐渐偏离。</p><p id="d211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，根据处理查询的Prometheus实例，如果进行负载平衡，将不会得到相同的结果。您可以为这种负载平衡增加一些粘性，但这不是一种可伸缩的设计。</p><p id="3e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，您需要一个智能负载平衡系统来聚合两个实例的数据，并呈现统一的指标。</p><h2 id="6a9a" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">长期储存</h2><p id="5676" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">Prometheus实例只能将其数据存储在本地磁盘上。这也带来了自身的挑战:</p><ul class=""><li id="ccc5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您需要监控磁盘，并随着大小的增长移动旧数据或扩展存储。</li><li id="fdc4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为了节省一些钱，您可能会尝试降低指标分辨率(例如，六个月后，只保留每小时而不是每分钟的数据)。</li><li id="88b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为了确保没有数据丢失，您需要创建备份并恢复磁盘策略。</li></ul><p id="a197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尤其是在对象存储(想想S3)已经变得如此流行的世界里，提供长期的、无限制的大小，而不需要花什么力气来设置，这可不是一件容易的事。不幸的是，Prometheus没有内置的方法来写入对象存储桶。</p><p id="f17c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将需要Prometheus和您的对象存储提供者之间的类似代理的服务来存储度量。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="926b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">可用的解决方案</h1><p id="a9d7" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">解决这些问题的两种流行解决方案是:</p><ul class=""><li id="cf0c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">格拉法纳实验室的<a class="ae ky" href="https://grafana.com/oss/cortex/" rel="noopener ugc nofollow" target="_blank">皮质</a>。</li><li id="1f7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://thanos.io/" rel="noopener ugc nofollow" target="_blank">灭霸</a>被爆料。</li></ul><p id="3c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种解决方案有着大致相同的承诺，并且都是<a class="ae ky" href="https://landscape.cncf.io/?project=incubating" rel="noopener ugc nofollow" target="_blank"> CNCF孵化项目</a>的一部分，用于观察和分析。他们提供:</p><ul class=""><li id="0d0d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过多个Prometheus实例和一个统一的查询端点实现高可用性。</li><li id="f743" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用您选择的对象存储(AWS S3、Google云存储、MS Azure Blob等),长期、持久地存储指标。).</li></ul><p id="09af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们很相似，相互合作，相互学习。没有明显的赢家！</p><p id="4809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将把重点放在灭霸。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f74c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">灭霸建筑</h1><h2 id="cbbb" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">使用边车的基本架构</h2><p id="39ea" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">灭霸很受欢迎，因为它可以使用基本部署场景快速轻松地进行设置:</p><ul class=""><li id="ee53" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">你在你的普罗米修斯实例中启用了一个边车。</li><li id="ea8b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以配置一个对象存储桶来存储指标。</li><li id="75a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">sidecar将定期将指标推送到对象存储器。</li><li id="add7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以从一个名为<code class="fe oa ob oc od b">Query</code>的端点使用优秀的PromQL查询所有Prometheus实例。</li><li id="573c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">Query</code>组件可以与Prometheus实例对话以获取新数据，或者与对象存储对话以获取旧数据。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/99e9306910b79e3cab80336a0e4a5be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DyHMDxAOFyL2r5-8DeHpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/thanos-io/thanos" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p></figure><p id="7aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种体系结构运行良好，但是有一个主要缺点:每两个小时(取决于您的Prometheus配置)将通过sidecar将指标推送到对象存储</p><p id="78bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果一个普罗米修斯崩溃并重新启动，您将丢失两个小时的价值指标！</p><p id="db71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实时存储指标并支持多租户，您需要一个更复杂的架构。</p><h2 id="02c0" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">使用接收组件的架构</h2><p id="44a1" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这种架构用<code class="fe oa ob oc od b">Receive</code>组件取代了灭霸边车:</p><ul class=""><li id="60a9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您启用Prometheus的<a class="ae ky" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write" rel="noopener ugc nofollow" target="_blank">远程写入</a>特性，将指标实时推送到<code class="fe oa ob oc od b">Thanos Receive</code>。</li><li id="bbd0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">Receive</code>将数据写入对象存储(并在本地缓存)。</li><li id="6d6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">Query</code>直接从<code class="fe oa ob oc od b">Receive</code>获取指标，或者在桶中获取旧数据。</li><li id="2c0d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">像在以前的架构中一样，作为一个客户端，您只需要与<code class="fe oa ob oc od b">Query</code>对话来查询指标。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/dadc4eb53b3a209357074402476e4b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_j1yPMvHL6gkDSGzq_LPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/thanos-io/thanos" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="460c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">灭霸和多租户</h1><p id="177c" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">灭霸组件支持多租户，这是使用这部分堆栈的另一个原因。</p><h2 id="cc99" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">软多租户</h2><p id="83f4" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在软多租户场景中:</p><ul class=""><li id="bcf8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">度量被推送到一个带有<code class="fe oa ob oc od b">THANOS-TENANT</code> HTTP头集的<code class="fe oa ob oc od b">Receive</code>实例。</li><li id="06cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">Receive</code>将在存储桶上存储指标时使用此标题来填充标签<code class="fe oa ob oc od b">tenant_id</code>。</li><li id="91bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后，在使用此标签进行PromQL查询时，您可以按租户过滤指标。</li></ul><p id="b7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，普罗米修斯不允许你在推进到灭霸时设置任意的头球。您需要使用类似Nginx的反向代理来填充正确的头。</p><p id="d0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果到灭霸的输入度量没有这样的报头，它将与标签<code class="fe oa ob oc od b">tenant_id</code>的默认值一起存储。</p><p id="d7b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里描述的实际上是软租赁，因为<code class="fe oa ob oc od b">Receive</code>实例是在租户之间共享的。但是您也可以通过配置多对<code class="fe oa ob oc od b">Receive</code>和<code class="fe oa ob oc od b">Bucket</code>来选择真正的硬租赁。</p><h2 id="0ea4" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">硬性多租户</h2><p id="3f1b" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在硬多租户场景中:</p><ul class=""><li id="46d7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们从软多租户架构开始。</li><li id="e8f1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">但是这一次，我们添加了其他的<code class="fe oa ob oc od b">Receive</code>实例。</li><li id="5e9d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每个<code class="fe oa ob oc od b">Receive</code>实例可以专用于一个或多个特定的租户。</li><li id="2993" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">任何<code class="fe oa ob oc od b">Receive</code>都可以从Prometheus获得一个传入的推送，并将数据分派给负责这个租户的专用实例。</li></ul><p id="ff25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，多个<code class="fe oa ob oc od b">Receive</code>实例组成一个集群。集群定义是通过一个JSON文件完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中:</p><ul class=""><li id="e8c2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe oa ob oc od b">tenant-a</code>是一组专用于租户a的两个<code class="fe oa ob oc od b">Receive</code>实例</li><li id="e61c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">tenant-b-c</code>是一组专用于租户B和c的两个<code class="fe oa ob oc od b">Receive</code>实例</li><li id="2a49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe oa ob oc od b">soft-tenants</code>是一种“默认”租户，用于既不是A、B也不是c的租户。它也用于没有<code class="fe oa ob oc od b">THANOS-TENANT</code>标题集的租户(例如匿名租户)。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c74c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">履行</h1><p id="a2be" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">看一下<a class="ae ky" href="https://github.com/dsayan154/thanos-receiver-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>，了解启用了软硬租赁的灭霸的完整实施。我不是作者，但这是一部了不起的作品！</p><p id="0e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意一些事情:</p><ul class=""><li id="c901" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果您将自己局限于软租用，那么只有一组<code class="fe oa ob oc od b">Receive</code>实例(在示例中称为“default ”)就足够了。</li><li id="f636" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">要安装灭霸堆栈，不使用原始资源，您可以使用支持<code class="fe oa ob oc od b">Receive</code>组件的Helm chart。比特纳米灭霸掌舵图就是其中之一。Bitnami图表永远不会出错！</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="09fb" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="c7ca" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">分布式监控的最大挑战是建立HA。您当然不希望您的诊断工具在您需要的时候让您失望。</p><p id="0986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">灭霸已成为Prometheus解决高可用性的经典解决方案，但随着最近推出的<code class="fe oa ob oc od b">Receive</code>组件，您现在可以从多租户和实时指标推送中受益。</p></div></div>    
</body>
</html>