<html>
<head>
<title>How I Built My Own TinyURL Like Service Using Serverless Computing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用无服务器计算构建自己的类似TinyURL的服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-built-my-own-tinyurl-like-service-using-serverless-computing-f41899f3fdcb?source=collection_archive---------14-----------------------#2022-01-03">https://betterprogramming.pub/how-i-built-my-own-tinyurl-like-service-using-serverless-computing-f41899f3fdcb?source=collection_archive---------14-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Cloudflare Worker和KV设计和构建低延迟无服务器URL shortener服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d0dce6d1153fea038a062b853ba8cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKL4Yq-67z65qlbg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pawel Czerwinski 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计一个网址缩写器如<a class="ae ky" href="https://tinyurl.com/" rel="noopener ugc nofollow" target="_blank"> TinyURL </a>和<a class="ae ky" href="https://bitly.com/" rel="noopener ugc nofollow" target="_blank"> Bitly </a>是软件工程中最常见的系统设计面试问题之一。</p><p id="22dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用cloud flare Worker<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-i-sync-daily-leetcoding-challenge-to-todoist-e50784bbcc8">将每日LeetCode Challenge同步到我的Todoist </a>时，它给了我一个想法，即构建一个任何人都可以使用的实际URL缩短器。</p><p id="3148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我的思考过程，通过代码示例说明我们如何使用<a class="ae ky" href="https://workers.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Worker </a>创建URL shortener。如果您想跟进，您需要一个<a class="ae ky" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare帐户</a>并使用<a class="ae ky" href="https://developers.cloudflare.com/workers/get-started/guide" rel="noopener ugc nofollow" target="_blank"> Wrangler CLI </a>。</p><h2 id="f6e1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">内容</h2><ul class=""><li id="e6b8" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">使用Cloudflare Worker和KV免费构建URL缩短器</li><li id="68fa" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">项目要求和限制计划</li><li id="eb67" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">短URL UUID生成逻辑</li><li id="4901" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">s.jerrynsh.com<a class="ae ky" href="https://s.jerrynsh.com/" rel="noopener ugc nofollow" target="_blank">的现场演示</a></li><li id="cd85" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://github.com/ngshiheng/atomic-url" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li></ul><p id="d627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，不要抱太大希望。这不是关于以下方面的指南:</p><ul class=""><li id="f89f" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">如何应对实际的系统设计面试</li><li id="5326" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">构建一个商业级的URL缩写器，如TinyURL或Bitly</li></ul><p id="f016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而是如何使用无服务器计算构建实际的URL缩写服务的概念证明(POC)。所以，抛出“可扩展性”、“分区”、“副本”等。从窗户出去，系好安全带。</p><p id="9a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你会发现这篇文章很有见地，读起来很有趣！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="24e4" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">要求</h1><p id="f4e0" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">像任何系统设计面试一样，让我们从定义一些功能性和非功能性需求开始。</p><h2 id="9958" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能的</h2><ul class=""><li id="11ac" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">给定一个URL，我们的服务应该返回一个唯一的短URL。例如<code class="fe oc od oe of b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-clean-code-in-python-5d67746133f2">https://betterprogramming.pub/how-to-write-clean-code-in-python-5d67746133f2</a></code> → <code class="fe oc od oe of b"><a class="ae ky" href="https://s.jerrynsh.com/FpS0a2LU" rel="noopener ugc nofollow" target="_blank">s.jerrynsh.com/FpS0a2LU</a></code></li><li id="53f5" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">每当用户试图访问<code class="fe oc od oe of b"><a class="ae ky" href="https://s.jerrynsh.com/FpS0a2LU" rel="noopener ugc nofollow" target="_blank">s.jerrynsh.com/FpS0a2LU</a></code>时，用户就会被引导回原来的网址。</li><li id="2b15" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">UUID(我有时称它为URL键，因为它是我们存储对象的键)应该遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/Base62" rel="noopener ugc nofollow" target="_blank"> Base62编码方案</a> (26 + 26 + 10):</li></ul><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="888b" class="lv lw it of b gy ok ol l om on">1. A lower case alphabet <strong class="of iu">'a' to 'z'</strong>, a total of 26 characters<br/>2. An upper case alphabet <strong class="of iu">'A' to 'Z'</strong>, a total of 26 characters<br/>3. A digit <strong class="of iu">'0' to '9'</strong>, a total of 10 characters<br/>4. In this POC, we will not be supporting custom short links</span></pre><ul class=""><li id="82a7" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">我们的UUID的长度应该≤ 8个字符，因为62⁸将给我们大约218万亿种可能性。</li><li id="84bc" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">生成的短URL应该永不过期。</li></ul><h2 id="1c65" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">非功能性</h2><ul class=""><li id="3de1" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">低延迟</li><li id="7e29" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">高可用性</li></ul><h2 id="3405" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">预算、容量和限制规划</h2><p id="8f99" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">目标很简单——我希望能够免费提供这项服务。因此，我们的约束很大程度上取决于<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/pricing" rel="noopener ugc nofollow" target="_blank"> Cloudflare Worker的定价</a>和<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/limits" rel="noopener ugc nofollow" target="_blank">平台限制</a>。</p><p id="8258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，每个帐户免费托管我们服务的限制是:</p><ul class=""><li id="ba0a" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">每天10万个请求，每分钟1千个请求</li><li id="631f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">CPU运行时间不超过10ms</li></ul><p id="6a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像大多数URL缩短程序一样，我们的应用程序预计会遇到高读取率，但相对较低的写入率。为了存储我们的数据，我们将使用<a class="ae ky" href="https://developers.cloudflare.com/workers/learning/how-kv-works" rel="noopener ugc nofollow" target="_blank"> Cloudflare KV，这是一个键值数据存储库</a>，支持高读取和低延迟，非常适合我们的用例。</p><p id="9173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们之前的限制继续，KV 和<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/limits#kv-limits" rel="noopener ugc nofollow" target="_blank">限制</a>的<a class="ae ky" href="https://developers.cloudflare.com/workers/platform/pricing#workers-kv" rel="noopener ugc nofollow" target="_blank">自由层允许我们:</a></p><ul class=""><li id="1ef0" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">10万次阅读/天</li><li id="457b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">1k写入/天</li><li id="7832" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">1 GB的存储数据(密钥大小为512字节；25 MiB的值大小)</li></ul><h2 id="5d00" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我们可以存储多少个短网址</h2><p id="88d1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">记住1 GB的免费最大存储数据限制，让我们尝试估计我们可以存储多少URL。在这里，我使用<a class="ae ky" href="https://mothereff.in/byte-counter" rel="noopener ugc nofollow" target="_blank">这个工具</a>来估计URL的字节大小:</p><ul class=""><li id="8345" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">1个字符为1个字节</li><li id="1bc6" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">因为我们的UUID应该最多只有8个字符，所以我们肯定没有密钥大小限制的问题。</li><li id="c13c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">另一方面，值大小限制——我推测最大URL大小应该平均在200个字符左右。因此，我相信可以安全地假设每个存储的对象应该平均不超过400字节，这远远低于25 MiB。</li><li id="01ed" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">最后，使用1 GB，我们的URL shortener最多可以支持总共2，500，000个(1 GB除以400字节)短URL。</li><li id="6aea" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">我知道，我知道。250万个网址并不算多。</li></ul><p id="5b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回头看，我们可以使UUID的长度≥ 4而不是8，因为62⁴的可能性远远超过250万。话虽如此，我们还是坚持使用长度为8的UUID。</p><p id="1efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我认为Cloudflare Worker和KV的免费层非常慷慨，对于我们的概念验证来说绝对足够体面。请注意，限额是基于每个账户的。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="bbe3" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">存储/数据库</h1><p id="65e3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">正如我前面提到的，我们将使用Cloudflare KV作为数据库来存储我们缩短的URL，因为我们预计读取次数将多于写入次数。</p><h2 id="98c1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最终一致</h2><p id="2a03" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">一个重要的注意事项—尽管KV能够支持异常高的全局读取，但它是一个最终一致的存储解决方案。换句话说，任何写入(即创建一个短URL)可能需要长达60秒的时间来进行全局传播，这是我们可以接受的缺点。</p><p id="268b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过我的实验，我还没有遇到过超过几秒钟的情况。</p><h2 id="d9a5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">原子操作</h2><p id="0ce5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">阅读<a class="ae ky" href="https://developers.cloudflare.com/workers/learning/how-kv-works" rel="noopener ugc nofollow" target="_blank">KV如何工作</a>，KV并不适合需要原子操作的情况(例如两个账户余额之间的银行交易)。幸运的是，这与我们无关。</p><p id="bcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的POC，我们的KV的密钥将是跟在我们的域名后面的UUID(例如<code class="fe oc od oe of b">s.jerrynsh.com/<strong class="lb iu">FpS0a2LU</strong></code>),而值将由用户给出的长URL组成。</p><h2 id="d12a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建KV</h2><p id="daff" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">要创建KV，只需使用Wrangler CLI运行以下命令。</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="c37b" class="lv lw it of b gy ok ol l om on"># Production namespace:<br/>wrangler kv:namespace create "URL_DB"</span><span id="b7dc" class="lv lw it of b gy oo ol l om on"># This namespace is used for `wrangler dev` local testing:<br/>wrangler kv:namespace create "URL_DB" --preview</span></pre><p id="3669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建这些KV名称空间，我们还需要更新我们的<code class="fe oc od oe of b">wrangler.toml</code>文件，以包含相应的名称空间绑定。您可以通过访问<code class="fe oc od oe of b">https://dash.cloudflare.com/<em class="op">&lt;your_cloudflare_account_id&gt;</em>/workers/kv/namespaces</code>查看您的KV仪表板。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="3932" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">短URL UUID生成逻辑</h1><p id="a958" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">这可能是我们整个应用程序最重要的方面。</p><p id="35bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的要求，目标是为每个网址生成一个字母数字UUID，其中我们的密钥长度不应超过8个字符。</p><p id="cff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个完美的世界中，生成的短链的UUID应该没有碰撞。另一个需要考虑的重要方面是——如果多个用户缩短同一个URL会怎么样？理想情况下，我们还应该检查重复。</p><p id="7f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑以下解决方案:</p><h2 id="e5cd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.使用UUID发电机</h2><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="a90f" class="lv lw it of b gy ok ol l om on">https://betterprogramming.pub/stop-using-exceptions-like-this-in-python-2bd8ba7d8841 → UUID Generator → <strong class="of iu">Yyf6AJ39</strong><strong class="of iu"> </strong>→ <!-- -->s.jerrynsh.com/<strong class="of iu">Yyf6AJ39</strong></span></pre><p id="8e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案实现起来相对简单。对于我们遇到的每一个新的URL，我们简单地调用我们的UUID生成器来给我们一个新的UUID。然后，我们将使用生成的UUID作为我们的键来分配新的URL。</p><p id="5301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UUID已经在我们的KV中存在(冲突)的情况下，我们可以继续重试。然而，我们确实希望注意重试，因为它可能相对昂贵。</p><p id="a132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当涉及到处理KV中的重复时，使用UUID发生器不会帮助我们。在我们的KV中查找长URL值会相对较慢。</p><h2 id="9e18" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.散列URL</h2><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="6d43" class="lv lw it of b gy ok ol l om on">https://betterprogramming.pub/how-to-write-clean-code-in-python-5d67746133f2 → MD5 Hash → <strong class="of iu">99d641e9</strong>923e135bd5f3a19dca1afbfa → <strong class="of iu">99d641e9 </strong>→ s.jerrynsh.com/<strong class="of iu">99d641e9</strong></span></pre><p id="b8fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，散列URL允许我们检查重复的URL，因为通过散列函数传递字符串(URL)将总是产生相同的结果。然后，我们可以使用结果(键)在KV中查找，以检查重复。</p><p id="29db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们使用<a class="ae ky" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>，我们的密匙将会有≥ 8个字符。那么，如果我们只取生成的MD5散列的前8个字节会怎么样呢？问题解决了对吗？</p><p id="e87c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。散列函数总是会产生冲突。为了降低冲突的<a class="ae ky" href="https://stackoverflow.com/questions/201705/how-many-random-elements-before-md5-produces-collisions" rel="noopener ugc nofollow" target="_blank">概率</a>，我们可以生成一个更长的散列。但是，它对用户不太友好。此外，我们希望保持我们的UUID ≤ 8个字符。</p><h2 id="cf85" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.使用增量计数器</h2><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="9bc1" class="lv lw it of b gy ok ol l om on">https://betterprogramming.pub/3-useful-python-f-string-tricks-you-probably-dont-know-f908f7ed6cf5 → Counter → s.jerrynsh.com/<strong class="of iu">12345678</strong></span></pre><p id="2ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这可能是最简单也是最具扩展性的解决方案。使用这个解决方案，我们将不会遇到冲突问题。每当我们使用整个集合(从00000000到9999999)时，我们可以简单地增加UUID中的字符数。</p><p id="b985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我不希望用户能够通过简单地访问<code class="fe oc od oe of b">s.jerrynsh.com/12345678</code>来随机猜测一个短URL。所以，这个解决方案是不可能的。</p><h2 id="3f8b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最后</h2><p id="b964" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">有许多其他解决方案(例如，预先生成一个键列表，并在新请求到来时分配一个未使用的键)各有利弊。</p><p id="b7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的概念验证，我们将采用<strong class="lb iu">解决方案1 </strong>，因为它易于实施，而且我也不介意重复。为了处理重复，我们可以缓存用户缩短URL的请求。</p><h2 id="8b1e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">纳米ID</h2><p id="3d48" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">为了生成UUID，我们使用了<code class="fe oc od oe of b"><a class="ae ky" href="https://github.com/ai/nanoid" rel="noopener ugc nofollow" target="_blank">nanoid</a></code>包。为了估计我们的碰撞率，我们可以使用<a class="ae ky" href="https://zelark.github.io/nano-id-cc/" rel="noopener ugc nofollow" target="_blank"> Nano ID碰撞计算器</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4130f9471d5c2238439aeece354d9503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x1uQJgSoywzpH7Wi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KV空闲层每天只能处理1k次写入，因此速度大约为42id/小时(1k / 24小时)</p></figure><p id="db7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，说够了，让我们写一些代码吧！</p><p id="fab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理冲突的可能性，我们只需不断重试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b077" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">应用程序接口</h1><p id="1869" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在本节中，我们将定义我们想要支持的API端点。这个项目是使用<code class="fe oc od oe of b"><a class="ae ky" href="https://github.com/kwhitley/itty-router" rel="noopener ugc nofollow" target="_blank">itty-router</a></code> <a class="ae ky" href="https://github.com/cloudflare/worker-template-router" rel="noopener ugc nofollow" target="_blank">工人模板</a>初始化的——它帮助我们处理所有的路由逻辑:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="270b" class="lv lw it of b gy ok ol l om on">wrangler generate &lt;project-name&gt; https://github.com/cloudflare/worker-template-router</span></pre><p id="7bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们项目的切入点在于<code class="fe oc od oe of b">index.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="730a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好的用户体验，我创建了一个简单的HTML登录页面，任何人都可以使用；你可以在这里获得登陆页面的HTML <a class="ae ky" href="https://github.com/ngshiheng/atomic-url/blob/main/src/utils/constants.js#L4" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="f657" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建短URL</h2><p id="902d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">首先，我们需要一个POST端点(<code class="fe oc od oe of b">/api/url</code>)，它调用<code class="fe oc od oe of b">createShortUrl</code>，解析来自主体的<code class="fe oc od oe of b">originalUrl</code>，并从中生成一个短URL。</p><p id="26c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在本地进行尝试(您可以使用<code class="fe oc od oe of b">wrangler dev</code>在本地启动服务器)，使用下面的Curl命令:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="ade1" class="lv lw it of b gy ok ol l om on">curl --request POST \\<br/>  --url http://127.0.0.1:8787/api/url \\<br/>  --header 'Content-Type: application/json' \\<br/>  --data '{<br/>	"originalUrl": "https://www.google.com/"<br/>}'</span></pre><h2 id="3088" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">重定向短URL</h2><p id="b8ac" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">作为一项URL缩短服务，我们希望用户在访问一个短URL时能够重定向到他们的原始URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="3cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删了怎么样？因为用户不需要任何授权来缩短任何URL，所以决定在没有删除API的情况下继续前进，因为任何用户可以简单地删除另一个用户的短URL是没有意义的。</p><p id="3be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在本地试用我们的URL shortener，只需运行<code class="fe oc od oe of b">wrangler dev</code>。</p><h2 id="86e9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">好处:用缓存处理重复</h2><blockquote class="ot ou ov"><p id="9321" class="kz la op lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">注意:目前，这仅适用于自定义域。</p></blockquote><p id="1380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用户决定重复缩短同一个URL会发生什么？我们不希望我们的KV以分配了唯一UUID的重复URL结束，对吗？</p><p id="bcff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减轻这种情况，我们可以使用一个缓存中间件来缓存用户使用<a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/cache" rel="noopener ugc nofollow" target="_blank">缓存API </a>提交的<code class="fe oc od oe of b">originalUrl</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="735a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用这个缓存中间件，只需相应地更新我们的<code class="fe oc od oe of b">index.js</code>:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="ebc6" class="lv lw it of b gy ok ol l om on">// index.js</span><span id="a197" class="lv lw it of b gy oo ol l om on">...</span><span id="9533" class="lv lw it of b gy oo ol l om on">router.post('/api/url', <strong class="of iu">shortUrlCacheMiddleware</strong>, createShortUrl)</span><span id="491a" class="lv lw it of b gy oo ol l om on">...</span></pre><p id="415a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要确保在缩短缓存实例时用原始URL更新它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="dc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我对<code class="fe oc od oe of b">wrangler dev</code>的测试中，<a class="ae ky" href="https://community.cloudflare.com/t/cloudflare-worker-cache-does-not-work/298125" rel="noopener ugc nofollow" target="_blank">工作缓存似乎不能在本地或任何</a> <code class="fe oc od oe of b"><a class="ae ky" href="https://community.cloudflare.com/t/cloudflare-worker-cache-does-not-work/298125" rel="noopener ugc nofollow" target="_blank">worker.dev</a></code>域上工作。</p><p id="cc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试这个问题的解决方法是运行<code class="fe oc od oe of b">wrangler publish</code>在<strong class="lb iu">定制域</strong>上发布应用程序。您可以通过向<code class="fe oc od oe of b">/api/url</code>端点发送请求来验证更改，同时通过<code class="fe oc od oe of b">wrangler tail</code>观察日志。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="a9ab" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">部署</h1><p id="2d59" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">没有一个副业是在没有主持的情况下完成的，对吗？</p><p id="e6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在发布您的代码之前，您需要编辑<code class="fe oc od oe of b">wrangler.toml</code>文件并在其中添加您的Cloudflare <code class="fe oc od oe of b">account_id</code>。你可以在<a class="ae ky" href="https://developers.cloudflare.com/workers/get-started/guide#7-configure-your-project-for-deployment" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到更多关于配置和发布你的代码的信息。</p><p id="6eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向您的Cloudflare Worker部署和发布任何新的更改，只需运行<code class="fe oc od oe of b">wrangler publish</code>。要将您的应用程序部署到自定义域，请查看这个短片。</p><p id="0636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万一你中途迷路了，你可以在这里查看<a class="ae ky" href="https://github.com/ngshiheng/atomic-url" rel="noopener ugc nofollow" target="_blank"> GitHub库。就是这样！</a></p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="7d40" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">最后的想法</h1><p id="2e78" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">老实说，这是我最近最开心的一次——同时研究、编写和构建这个概念验证。在我看来，我们可以为我们的网址缩短器做更多的事情；仅举几个例子:</p><ul class=""><li id="af07" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu mv mw mx my bi translated">存储<a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/kv#metadata" rel="noopener ugc nofollow" target="_blank">元数据</a>，如创建日期、访问次数</li><li id="443c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">添加身份验证</li><li id="6981" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">处理短网址删除和<a class="ae ky" href="https://developers.cloudflare.com/workers/runtime-apis/kv#creating-expiring-keys" rel="noopener ugc nofollow" target="_blank">过期</a></li><li id="afc0" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">用户分析</li><li id="dee3" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">自定义链接</li></ul><p id="c609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数URL缩短服务面临的一个问题是，短URL经常被滥用来将用户引向恶意站点。我认为这是一个值得深入研究的有趣话题。</p><p id="d317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天就到这里吧！干杯！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="5789" class="lv lw it of b gy ok ol l om on"><strong class="of iu">Want to Connect With the Author?</strong></span><span id="6366" class="lv lw it of b gy oo ol l om on">This article was originally published at <a class="ae ky" href="https://jerrynsh.com/i-built-my-own-tiny-url/" rel="noopener ugc nofollow" target="_blank">jerrynsh.com</a></span></pre></div></div>    
</body>
</html>