<html>
<head>
<title>Interactive Recommendation Engine Using Metacritic Review Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用元评论数据集的交互式推荐引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/interactive-recommendation-engine-using-metacritic-review-dataset-6cb8d62c76d4?source=collection_archive---------11-----------------------#2022-01-16">https://betterprogramming.pub/interactive-recommendation-engine-using-metacritic-review-dataset-6cb8d62c76d4?source=collection_archive---------11-----------------------#2022-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3605" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Python创建一个包含视频游戏元数据的推荐引擎，该引擎可以通过Gradio的文本输入进行交互</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a6f5854f93affa4c688c941934b9cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TOkoMhKXcIDC4mmxLvxYQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@everywheresean?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">肖恩·多</a>在<a class="ae ky" href="https://unsplash.com/s/photos/gaming-esports?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="73e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在互联网上通过Python的许多推荐引擎教程中，我有一个使用来自IGN、PC Gamer等出版物的元评论的评论数据生成推荐。</p><p id="2e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在<a class="ae ky" href="https://www.kaggle.com/skateddu/metacritic-critic-games-reviews-20112019" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上访问原始数据集。</p><p id="624c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以在Kaggle上访问我在这个笔记本<a class="ae ky" href="https://www.kaggle.com/seyi92coding/metacritic-review-scores-20112019" rel="noopener ugc nofollow" target="_blank">中使用的版本。</a></p><h1 id="c0ce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">上传您的模块</h1><p id="4611" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">像往常一样，我们将需要上传相关模块。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a525" class="mx lw it mt b gy my mz l na nb">import pandas as pd<br/>import numpy as np<br/>import scipy as sp<br/>from scipy import sparse<br/>from sklearn.metrics.pairwise import cosine_similarity<br/>from fuzzywuzzy import fuzz</span></pre><h1 id="aaf3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">上传和清理数据集</h1><p id="9d67" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您计划使用不同的数据集创建自己的推荐引擎，您需要的3个最重要的列(功能)是:</p><ul class=""><li id="c37b" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">用户标识</li><li id="e3a5" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">项目ID</li><li id="8fe0" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">评级</li></ul><p id="e20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我的数据集包括项目的名称(视频游戏标题)和用户的名称(出版物)，因此输出对于真实世界的场景是用户友好的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="daaa" class="mx lw it mt b gy my mz l na nb">df = pd.read_csv("/content/Ratings_3col_Metacritic.csv",  error_bad_lines=False, encoding='utf-8')</span><span id="9614" class="mx lw it mt b gy nq mz l na nb">df_text = pd.read_csv("/content/Ratings_withText_Metacritic.csv",  error_bad_lines=False, encoding='utf-8')</span><span id="04dd" class="mx lw it mt b gy nq mz l na nb">df.head()<br/>df_text.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c6b7bfc0862758ec51db916af11dbcf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*JfsTqFQOZFWbMjM5BeMNEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Google Colab中的Metacritic数据集的截图</p></figure><p id="b6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须进行常规检查，以确保没有任何无效数据。这些是我最喜欢的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="84b3" class="mx lw it mt b gy my mz l na nb">#Show an overview of the dataset<br/>df.info()<br/>df_text.info()</span><span id="cf16" class="mx lw it mt b gy nq mz l na nb">#Drop unneccessary columns to speed up processing</span><span id="4a80" class="mx lw it mt b gy nq mz l na nb">df = df.drop(['Unnamed: 0'], axis=1)<br/>df_text = df_text.drop(['Unnamed: 0'], axis=1)</span><span id="fe87" class="mx lw it mt b gy nq mz l na nb">#Which columns have null values?</span><span id="3787" class="mx lw it mt b gy nq mz l na nb">print(df.columns[df.isna().any()].tolist())</span><span id="fb5d" class="mx lw it mt b gy nq mz l na nb">#How many null values per column? - Count the missing values in each column</span><span id="0d28" class="mx lw it mt b gy nq mz l na nb">df.isnull().sum()</span></pre><h1 id="5b38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">格式化数据集，以便我们可以转换成数据透视表</h1><p id="a027" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从这一点开始，我将遵循这个Kaggle笔记本中显示的方法。</p><p id="ebd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的步骤中:</p><ul class=""><li id="9fc3" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">我们希望只关注一种类型的控制台，这样可以提高建议的相关性</li><li id="6642" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">将数据集合并到一个数据框架中</li><li id="a876" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">删除重复项</li><li id="b1bb" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">我们只需要主要的3列。</li></ul><p id="d212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将为数据集创建一个数据透视表，其中的每一行都代表每个审阅者的所有分数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0015" class="mx lw it mt b gy my mz l na nb">#step 1 - Filter to one console type</span><span id="cd24" class="mx lw it mt b gy nq mz l na nb">meta_df = df[df['console_ID']== 1]</span><span id="976f" class="mx lw it mt b gy nq mz l na nb">#step 2 - Merge on Game ID across both datasets</span><span id="4952" class="mx lw it mt b gy nq mz l na nb">meta_df = meta_df.merge(df_text, left_on = 'game_ID', right_on = 'game_ID', suffixes= ['_meta', ''])</span><span id="a90b" class="mx lw it mt b gy nq mz l na nb">#step 3 - Remove duplicate reviews</span><span id="d012" class="mx lw it mt b gy nq mz l na nb">def create_uid(row):<br/>#create unique ID based on reviewer and game<br/>    code = str(row['reviewer_ID']) + "_" + str(row['game_ID'])<br/>    return code</span><span id="dc6c" class="mx lw it mt b gy nq mz l na nb">meta_df['uid'] = meta_df.apply(create_uid, axis=1)<br/>#drop duplicates of reviewers who reviewed the same game<br/>meta_df = meta_df.drop_duplicates('uid')</span><span id="3d01" class="mx lw it mt b gy nq mz l na nb">#step 3 - Only return the important columns<br/>meta_df = meta_df[['game', 'reviewer_ID', 'score']]</span></pre><p id="7faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好数据框架后，我们将创建一个以用户为行、以游戏为列的数据透视表。这个数据透视表将帮助我们根据评论者如何评论同一个游戏集合来计算他们之间的相似性。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ad8f" class="mx lw it mt b gy my mz l na nb">pivot = meta_df.pivot_table(index=['reviewer_ID'], columns=['game'], values='score')<br/>pivot.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/6c35dfcea1412d9deb70f4f9c8181e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VQrwU07k8e0CV4zOtfelA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据透视表第一次迭代的屏幕截图</p></figure><p id="189b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，有许多NaN值，我们将在数据透视表的第二次迭代中解决。</p><h1 id="716d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">工程数据透视表还</h1><p id="ecdf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作者:</p><ul class=""><li id="62db" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">价值正常化。</li></ul><p id="fee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当特征在固定范围内或多或少均匀分布时，我们使用称为<a class="ae ky" href="https://developers.google.com/machine-learning/data-prep/transform/normalization" rel="noopener ugc nofollow" target="_blank">线性缩放</a>的标准化技术。评级标准化意味着将不同尺度上测量的值调整到一个名义上的共同尺度，通常是在平均之前。</p><ul class=""><li id="f5a0" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">将NaN值填充为0。</li></ul><p id="4cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数审查数据集将像这样稀疏，所以我们需要以某种方式填充NaN值。根据你的相似性技术，可能会有一个使用不同方法的争论。</p><ul class=""><li id="589d" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">为下一步调换支点。</li></ul><p id="a9c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交换行列可以让我们更容易地删除未评级的评论。</p><ul class=""><li id="d6ff" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">删除值为0的列(未分级)。</li><li id="d110" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">使用scipy包转换为稀疏矩阵格式进行相似度计算。</li></ul><p id="b162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们的数据透视表成形，我们就可以运行余弦相似度函数，该函数将被转换成数据帧供我们进一步分析。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bca1" class="mx lw it mt b gy my mz l na nb">#Applying lambda function to multiple rows using Dataframe.apply()<br/>#(x-np.mean(x))/(np.max(x)-np.min(x)) = Formula</span><span id="88af" class="mx lw it mt b gy nq mz l na nb">pivot_n = pivot.apply(lambda x: (x-np.mean(x))/(np.max(x)-np.min(x)), axis=1)</span><span id="5b13" class="mx lw it mt b gy nq mz l na nb"># step 2 - Fill NaNs with Zeros<br/>pivot_n.fillna(0, inplace=True)</span><span id="13ae" class="mx lw it mt b gy nq mz l na nb"># step 3 - Transpose the pivot table<br/>pivot_n = pivot_n.T</span><span id="6da3" class="mx lw it mt b gy nq mz l na nb"># step 4 - Locate the columns that are not zero (unrated)<br/>pivot_n = pivot_n.loc[:, (pivot_n != 0).any(axis=0)]</span><span id="8748" class="mx lw it mt b gy nq mz l na nb"># step 5 - Create a sparse matrix based on our pivot table<br/>piv_sparse = sp.sparse.csr_matrix(pivot_n.values)</span></pre><h1 id="41c2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">余弦相似模型</h1><p id="bf01" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以根据游戏评论者对游戏的评价来计算余弦相似度。他们越接近，就越有可能被评论者评为相似。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="974d" class="mx lw it mt b gy my mz l na nb">#Compute cosine similarity between samples in X and Y.<br/>game_similarity = cosine_similarity(piv_sparse)</span><span id="4b70" class="mx lw it mt b gy nq mz l na nb">#Turn our similarity kernel matrix into a dataframe<br/>game_sim_df = pd.DataFrame(game_similarity, index = pivot_n.index, columns = pivot_n.index)</span><span id="d9f3" class="mx lw it mt b gy nq mz l na nb">game_sim_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/9ec922faccf3711b2dbe014820c63fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G93Wjztg8BzWzvc8jULONw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标准化并填入NaN值后的数据透视表屏幕截图</p></figure><p id="460e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，NaN值消失了，数据被标准化了，根据所有评论者的评分，给每一个游戏一个相似的分数。越接近1.00000，它们的评级就越接近。</p><h1 id="4546" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">文本匹配</h1><p id="b3c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不太可能有人会输入准确的关键字来进行推荐，因此我们需要将用户输入的语句与数据集中最可能的项目进行匹配。</p><p id="7ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过以下方式做到这一点:</p><ul class=""><li id="f28d" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">创建一个基于“Levenshtein距离”匹配2个输入的函数</li><li id="d393" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">创建新的数据帧，包含:游戏标题，游戏ID</li><li id="f89d" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">创建一个基于提交的ID返回游戏标题的函数</li></ul><p id="e3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过以下方式将所有内容整合在一起的函数:</p><ul class=""><li id="5a49" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">为每个游戏标题和用户输入分配匹配分数</li><li id="5a76" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">按最高匹配分数到最低匹配分数排序</li><li id="3809" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">标识最高分数和游戏标题</li><li id="6085" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">将两者返回给用户</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="87ea" class="mx lw it mt b gy my mz l na nb"># create a function to find the closest title<br/>def matching_score(a,b):<br/>    #fuzz.ratio(a,b) calculates the Levenshtein Distance between a and b, and returns the score for the distance<br/>    return fuzz.ratio(a,b)# if exactly the same, the score becomes 100</span><span id="70ba" class="mx lw it mt b gy nq mz l na nb">df_game_names = df_text[['game','game_ID']].drop_duplicates(subset=['game_ID']).set_index('game_ID')<br/>df_game_names = df_text.set_index('game_ID')</span><span id="f2b8" class="mx lw it mt b gy nq mz l na nb"># a function to convert index to title<br/>def get_title_from_index(index):<br/>    return df_game_names.iloc[index]['game']</span><span id="f17e" class="mx lw it mt b gy nq mz l na nb"># a function to return the most similar title to the words a user type<br/>def find_closest_title(title):<br/>    #matching_score(a,b) &gt; a is the current row, b is the title we're trying to match<br/>    leven_scores = list(enumerate(df_game_names['game'].apply(matching_score, b=title)))<br/>    sorted_leven_scores = sorted(leven_scores, key=lambda x: x[1], reverse=True)<br/>    closest_title = get_title_from_index(sorted_leven_scores[0][0])<br/>    distance_score = sorted_leven_scores[0][1]<br/>    return closest_title, distance_score<br/># Bejeweled Twist, 100</span><span id="9ad8" class="mx lw it mt b gy nq mz l na nb">#Check matching works<br/>get_title_from_index(20)<br/>title, distance_score = find_closest_title('Dragonball Z')<br/>print(title)</span></pre><p id="a653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试输出将返回:DragonBall FighterZ。很接近了。</p><h1 id="0e99" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">推荐功能</h1><p id="e120" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，它根据输入提取最匹配的可用名称，然后根据游戏标题对相似性数据帧进行排序。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4653" class="mx lw it mt b gy my mz l na nb">def game_recommendation(game):<br/>    #Insert closest title here<br/>    game, distance_score = find_closest_title(game)<br/>    #Counter for Ranking<br/>    number = 1<br/>    print('Recommended because you played {}:\n'.format(game))<br/>    for n in game_sim_df.sort_values(by = game, ascending = False).index[1:6]:<br/>    print("#" + str(number) + ": " + n + ", " + str(round(game_sim_df[game][n]*100,2)) + "% " + "match")<br/>    number +=1</span><span id="ab64" class="mx lw it mt b gy nq mz l na nb">game_recommendation('Yakuza 0')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/380979cbcc930998e9990747d1811aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*G9yTW2Tn7eGxhl6CHS_zAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出的屏幕截图</p></figure><p id="d8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘣！</p><p id="41ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并没有结束，我们可以让它与Gradio更加互动</p><h1 id="6f95" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使推荐器与Gradio交互</h1><p id="638d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">没有用户推荐，推荐者会怎样？</p><p id="a338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了Gradio，我们可以让任何人更容易使用输入，甚至超调一些参数。</p><p id="85f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道更多关于你可以用Gradio做的很酷的事情，请访问他们的网站。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9442" class="mx lw it mt b gy my mz l na nb">import gradio as gr</span><span id="22dc" class="mx lw it mt b gy nq mz l na nb">recommender_interface = gr.Interface(game_recommendation, ["text"],</span><span id="f4f5" class="mx lw it mt b gy nq mz l na nb">["text"], title="Top 5 Game Recommendations", description="This is a Recommendation Engine based on how Metacritic professional reviewers have scored games up to 2019 (apologies for the out of date data). Simply input a game you have enjoyed playing and it should return 5 games that have been rated similarily")</span><span id="d1e9" class="mx lw it mt b gy nq mz l na nb">recommender_interface.launch(debug=True)</span></pre><p id="6f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e0bfdf1ee72eb9d72abc3aeec536e664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9I53rLCXgzaD4UZMFHepA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推荐器的Gradio界面截图</p></figure><p id="b0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是开始。我可以通过以下方式让这种方式更具互动性:</p><ul class=""><li id="f3c6" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">允许用户定义建议数量</li><li id="cee3" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">添加参考数据集以包含/排除某些类型</li></ul><p id="b69d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此处可查看<a class="ae ky" href="https://colab.research.google.com/drive/1LYc8gtwW5q9p7jtX7axOMD7MtPN4XROM?usp=sharing" rel="noopener ugc nofollow" target="_blank">完整笔记本。</a></p><p id="ede5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者如果你喜欢Github，<a class="ae ky" href="https://github.com/SeyiAgboola/Recommender-Engines-with-Gradio/blob/main/Recommend_Video_Games_Based_on_Metacritic_Reviews_With_Gradio.ipynb" rel="noopener ugc nofollow" target="_blank">你可以在这里访问代码。</a></p><p id="e4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想用Gradio构建自己的推荐引擎，可以随意借用它作为起点。此外，如果您在构建过程中需要帮助，我可以推荐这些Datacamp课程。</p></div></div>    
</body>
</html>