<html>
<head>
<title>Self-Sizing Hell — UITableView and UICollectionView Cells</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自我调整Hell — UITableView和UICollectionView单元格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/self-sizing-hell-uitableview-and-uicollectionview-cells-509f0fdc7ff1?source=collection_archive---------2-----------------------#2019-10-31">https://betterprogramming.pub/self-sizing-hell-uitableview-and-uicollectionview-cells-509f0fdc7ff1?source=collection_archive---------2-----------------------#2019-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="707e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速了解如何让嵌套的自调整大小单元格工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58def8cddd70073e9c64763c3bdbb759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0kXgQ1A6hOohvwb0x4XPQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@thebstudio?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">艾莉婕·马尚德</a>从<a class="ae kv" href="https://www.pexels.com/photo/white-eggs-in-brown-nest-947457/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="357c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的想法始于我在工作中面临的一个挑战<em class="ls">，</em>我被分配了一个任务，要实现一个<em class="ls">嵌套版本的自调整单元格</em>:在一个自调整单元格<code class="fe lt lu lv lw b">UITableViewCell</code>内实现一个自调整单元格<code class="fe lt lu lv lw b">UICollectionViewCell</code>。</p><p id="ab4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，这似乎是一个相当简单的任务，我天真地认为从一开始一切都会“正常工作”，但伙计，我错了吗？</p><p id="6ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从iPhone开发初期以来，<code class="fe lt lu lv lw b">UITableViews</code>和<code class="fe lt lu lv lw b">UICollectionViews</code>几乎被每个应用程序用来显示内容。</p><p id="0360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，这些内容不是静态的，也不总是具有相同的大小，但是由于引入了动态类型和不同的屏幕大小，因此在每个设备上正确显示内容非常重要。</p><p id="fad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几年前，随着iOS 8的发布，苹果增加了在<code class="fe lt lu lv lw b">UITableViews</code>和<code class="fe lt lu lv lw b">UICollectionViews</code>中轻松实现自我调整单元大小的能力，而无需我们自己进行这些计算。</p><p id="264b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将通过一些例子来看看这是如何工作的，希望这些例子能帮助那些试图让自我调整大小的细胞工作的人。</p><p id="9d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想继续学习，您可以在<a class="ae kv" href="https://github.com/danmunoz/self-sizing-hell" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到示例代码。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="71b4" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">自我评估基础知识</strong></h1><p id="2068" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在iOS 11中，默认情况下会启用自调整单元格，但如果我们仍然需要支持iOS 10，那么让它工作是非常容易的。</p><p id="5308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要将<code class="fe lt lu lv lw b">estimatedRowHeight</code>设置为<em class="ls">估计的</em>高度值，并让<code class="fe lt lu lv lw b">UIKit</code>为我们进行计算。<code class="fe lt lu lv lw b">UICollectionViewFlowLayout</code>iOS 10以后就不需要这个值了。</p><p id="e0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统能够根据其<code class="fe lt lu lv lw b">contentView</code>中定义的约束条件自动计算单元的大小，从而使自调整单元工作。</p><p id="8540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了帮助自动布局计算正确的大小，我们需要确保从顶部锚点到底部锚点的所有UI元素都有完整的约束链。我们必须确保没有不明确的布局，否则尺寸无法计算。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="a1a5" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">超越最简单的情况</strong></h1><p id="5fb3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当我们确保有一个明确的布局时，实现自我调整<code class="fe lt lu lv lw b">UITableView</code>或<code class="fe lt lu lv lw b">UICollectionView</code>是相当容易的。当我们深入到更高级的东西时，事情变得有点棘手，比如将一个嵌套到另一个中。</p><p id="737e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释我对此的发现，我们将看几个不同的情况来理解这是如何工作的。</p><p id="956d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，请注意示例代码。</p><ul class=""><li id="b26e" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">我们以编程方式编写所有UI代码，没有使用<code class="fe lt lu lv lw b">Storyboards</code>或<code class="fe lt lu lv lw b">xib</code>文件。</li><li id="efd6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">我们用<code class="fe lt lu lv lw b">AutoLayout</code>。</li></ul></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="2805" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">方形视图</strong></h1><p id="8df3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了更容易理解，我们将使用一个固定大小(80x80)的正方形视图作为<code class="fe lt lu lv lw b">UICollectionViewCell</code>内部的唯一对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算单元格的正确大小，自动布局需要知道每个单独元素的大小。在这个嵌套的例子中，自动布局需要知道<code class="fe lt lu lv lw b">UICollectionViewCell</code>的大小来计算<code class="fe lt lu lv lw b">UICollectionView</code>(<code class="fe lt lu lv lw b">contentView</code>)的大小。</p><p id="a789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免复杂性，我们将宽度和高度定义为80磅，以帮助自动布局计算。</p><p id="9527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">UICollectionView</code>位于<code class="fe lt lu lv lw b">UITableViewCell</code>内部，因此自动布局需要其尺寸来计算<code class="fe lt lu lv lw b">UITableViewCell</code> ( <code class="fe lt lu lv lw b">contentView</code>)尺寸。</p><p id="c96e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这是作为一个独立的<code class="fe lt lu lv lw b">UICollectionView</code>来实现的，那么定义单元格内元素的大小就足够了，但是在这个嵌套的例子中，我们最终得到了如下所示的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/cf74df033d9bed789421e654a3a3c3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McsP65aOwbf4cCtmO_V6xg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用默认的44磅高度…而不是定义的80磅高度裁剪UICollectionView</p></figure><p id="b794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们还会看到以下警告记录:</p><pre class="kg kh ki kj gt ns lw nt nu aw nv bi"><span id="1d40" class="nw mf iq lw b gy nx ny l nz oa">Warning once only: Detected a case where constraints ambiguously suggest a height of zero for a table view cell’s content view. We’re considering the collapse unintentional and using standard height instead.</span></pre><p id="8854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当定义<code class="fe lt lu lv lw b">UITableView</code>的单元格大小时，它使用的高度为零，因此系统自动分配默认的单元格高度44磅。</p><p id="a551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为<code class="fe lt lu lv lw b">UITableViewCell</code>的大小计算发生在<code class="fe lt lu lv lw b">UICollectionView</code>的<code class="fe lt lu lv lw b">contentSize</code>被定义之前，所以它返回零。</p><p id="b850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算自调整单元格的高度，<code class="fe lt lu lv lw b">UITableView</code>在每个单元格上调用<code class="fe lt lu lv lw b">systemLayoutSizeFitting(targetSize:horizontalFittingPriority:verticalFittingPriority:)</code>。此方法根据单元格内定义的布局计算高度。</p><p id="5731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调试正在发生的事情的一个好方法是覆盖这个方法，并查看对super的调用返回了什么。当我们这样做时，我们可以看到返回的大小是(375 x 44)，由于方形视图的高度是80磅，所以内容被剪裁。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="83e2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">解决方案</strong></h1><p id="ba7b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我在网上寻找解决这个问题的方法，有很多关于从<code class="fe lt lu lv lw b">systemLayoutSizeFitting</code>电话中回复<code class="fe lt lu lv lw b">UICollectionView</code>的<code class="fe lt lu lv lw b">contentView</code>的建议。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/62914b16a7d213bc2b211a0e41e290c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjdsscyPAChxZQwsFkj-0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">UICollectionView有3个正方形，正确高度为80磅</p></figure><p id="7dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种解决方案在大多数情况下都有效，如上所示，但也有一些情况下它不起作用，导致一个奇怪的长<code class="fe lt lu lv lw b">UICollectionView</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/920b415252f88e0ef329ac3ec256cc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgomnlQ24_K-eRrkunukLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">UICollectionView有4个正方形和一个错误的高度，大到足以容纳另一行</p></figure><p id="f59e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现这个计算失败了，因为<code class="fe lt lu lv lw b">UICollectionView</code>的<code class="fe lt lu lv lw b">contentView</code>有时(还)没有调整到它的超级视图(<code class="fe lt lu lv lw b">UITableView</code>)的<em class="ls">正确的</em>宽度，并且使用默认的<code class="fe lt lu lv lw b">UIKit</code>值320磅。</p><p id="b699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们运行示例项目并将方块的数量设置为1到3，则计算将考虑一个320磅宽的框，因为方块的数量仍然适合该框，在布局过程发生后，<code class="fe lt lu lv lw b">UITableView</code>具有适合这些方块的正确高度。</p><p id="7ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，在有四个正方形的例子中，<code class="fe lt lu lv lw b">UICollectionView</code>的<code class="fe lt lu lv lw b">contentSize</code>也是为320磅宽的盒子计算的。</p><p id="5499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着四个方块需要放在第二行，当布局通过时，四个方块将放在一行内(与<code class="fe lt lu lv lw b">UITableView</code>宽度匹配),但是<code class="fe lt lu lv lw b">UITableViewCell</code>已经用不正确的高度计算。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9b21" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">为解决问题而解决</strong></h1><p id="4c0c" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在玩了演示项目后，我发现我们需要强制一个额外的布局通道，以便<code class="fe lt lu lv lw b">UITableView</code>可以计算正确的单元格高度，这也是在<code class="fe lt lu lv lw b">systemLayoutSizeFitting</code>方法中完成的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/57cce4976c2e6d927993f83c0ce3c7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJje1zb9J0VJZOYGs8d-VA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有4个正方形和正确高度的UICollectionView</p></figure><p id="911a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生的事情是，我们将<code class="fe lt lu lv lw b">UITableView</code>的<code class="fe lt lu lv lw b">contentView</code>框架设置为单元格的边界，然后我们触发新的布局传递。当我们这样做的时候，在下一轮，auto layout将能够使用一个具有正确宽度的框来计算它的大小。</p><p id="4327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用不同的布局尝试了这个解决方案，尤其是总是很棘手的多行<code class="fe lt lu lv lw b">UILabel</code>，它似乎一直在解决这个问题。</p><p id="ab21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望有一种更干净的方式来做这件事，所以如果你有任何建议，请发给我。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="74c7" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">总结</strong></h1><p id="d42b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在本文中，我们看到了如何修复实现嵌套的自调整单元格时的一个常见问题。</p><p id="7d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据您的具体情况，尝试调试在<code class="fe lt lu lv lw b">systemLayoutSizeFitting</code>方法中返回的内容，并查看大小调整和布局传递的顺序。</p><p id="5c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网上有关于这个话题的好资料，我推荐<a class="ae kv" href="https://vimeo.com/nsspain/2019-cells" rel="noopener ugc nofollow" target="_blank">雷诺·林哈特的NSSpain talk </a>。</p><p id="4356" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/danmunoz/self-sizing-hell" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的示例代码。</p><p id="31c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在开始时提到的，我希望这个自我调整细胞如何工作的快速解释对面临同样挑战的人有用。</p></div></div>    
</body>
</html>