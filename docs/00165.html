<html>
<head>
<title>JavaScript: Promises and Why Async/Await Wins the Battle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:承诺和为什么Async/Await赢得了这场战斗</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-promises-and-why-async-await-wins-the-battle-4fc9d15d509f?source=collection_archive---------0-----------------------#2018-07-26">https://betterprogramming.pub/javascript-promises-and-why-async-await-wins-the-battle-4fc9d15d509f?source=collection_archive---------0-----------------------#2018-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e71b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Async/Await的易用性和优势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc5bf5f702665146cc814cf334d852c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSIP4S843xY053rCelgVcg.png"/></div></div></figure><p id="077c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">异步函数在JavaScript中有好有坏。好的一面是异步函数是非阻塞的，因此速度很快——尤其是在Node.js上下文中。缺点是处理异步函数可能很麻烦，因为有时您必须等待一个函数完成，以便在继续下一个执行之前得到它的“回调”。</p><p id="e45d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几种方法可以发挥异步函数调用的优势，并正确地处理它们的执行，但是有一种方法比其他方法更好(剧透:它是Async/Await)。在这篇快速阅读中，你将了解到<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>的来龙去脉和<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步/等待</a>的使用，以及我们对两者如何比较的看法。</p><p id="1f5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">享受</strong>！</p><h1 id="256e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">承诺与回访</h1><p id="70bb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">作为一名JavaScript或Node.js开发人员，正确理解承诺和回调<em class="mo">之间的区别以及它们如何协同工作是至关重要的。</em></p><p id="353b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两者之间有微小但重要的差异。在每个承诺的核心，都有一个回调来解决某种数据(或错误),这种数据(或错误)会在被调用的承诺出现。</p><p id="0885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">回调处理程序:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">调用<strong class="kw iu"> </strong> <code class="fe mr ms mt mu b"><strong class="kw iu">validatePassword()</strong></code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="624e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">下面的代码片段显示了验证密码的完整的端到端检查(它是静态的，必须与“bambi”匹配，这是我小时候最喜欢的卡通人物)</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="eb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码被很好地注释了。然而，如果你感到困惑，catch只在从Promise中调用<strong class="kw iu"> </strong> <code class="fe mr ms mt mu b"><strong class="kw iu">reject()</strong></code>的事件中执行。由于密码不匹配，我们调用<code class="fe mr ms mt mu b"><strong class="kw iu">reject()</strong></code>，因此“捕捉”错误并将其发送给<code class="fe mr ms mt mu b"><strong class="kw iu">done()</strong></code>函数。</p><h1 id="b459" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">承诺</h1><p id="9eea" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">与传统的基于回调的方法相比，承诺为执行、组合和管理异步操作提供了一种更简单的替代方法。它们还允许您使用类似于同步try/catch的方法来处理异步错误。</p><p id="f8e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">承诺还提供了三种独特的状态</strong>:</p><ol class=""><li id="2aeb" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><strong class="kw iu">待定</strong> —承诺的结果尚未确定，因为将产生其结果的异步操作尚未完成。</li><li id="e2cb" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">已完成</strong> —异步操作已完成，承诺有值。</li><li id="1ac9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw iu">拒绝</strong> —异步操作失败，承诺永远无法兑现。在拒绝状态下，一个承诺有一个<em class="mo">原因</em>，表明操作失败的原因。</li></ol><p id="ad5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当承诺待定时，它可以转换到“已履行”或“已拒绝”状态。然而，一旦承诺被实现或拒绝，它将永远不会过渡到任何其他状态，其价值或失败原因也不会改变。</p><h1 id="818a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">不利方面</h1><p id="7aaa" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">承诺不做的一件事是解决所谓的“回调地狱”，它实际上只是一系列嵌套的函数调用。当然，打一个电话没问题。对于许多调用，您的代码变得难以阅读和维护。</p><h1 id="1dd9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">重复承诺</h1><p id="3e47" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了避免JavaScript的深度嵌套回调，人们会假设您可以简单地循环遍历承诺，将结果返回给一个对象或数组，当它完成时就会停止。可惜没那么容易；由于JavaScript的异步特性，如果您遍历每个承诺，当您的代码完成时，不会调用“done”事件。</p><p id="96d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理这种情况的正确方法是使用<code class="fe mr ms mt mu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>。该功能在被标记为完成之前等待所有完成(或第一次拒绝)。</p><h1 id="e3eb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">错误处理</h1><p id="88e7" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">用多个嵌套的Promise调用进行错误处理就像蒙着眼睛开车一样。祝你好运，找出是哪个承诺出了错。最好的办法是完全删除<code class="fe mr ms mt mu b"><strong class="kw iu">catch()</strong></code>方法，选择一个全局错误处理程序(交叉手指)，如下所示:</p><p id="820a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">浏览器:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7b4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Node.js: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="nj nk nl"><p id="8e39" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">注意:以上两个选项是确保捕捉错误的仅有的两种方法。如果你错过添加一个<code class="fe mr ms mt mu b"><strong class="kw iu">catch()</strong></code> <strong class="kw iu"> </strong>方法，它就会被代码吞噬。</p></blockquote><h1 id="a02b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">异步/等待？</h1><p id="0f00" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Async/Await允许我们编写看起来同步的异步JavaScript。在这篇文章的前几部分，你已经了解到那些被认为是简化异步流和避免回调地狱的承诺，但是他们没有。</p><h1 id="2ab3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">回调地狱？</h1><p id="1e0b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">回调地狱是一个用来描述以下场景的术语:</p><blockquote class="nj nk nl"><p id="2a02" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">注意:作为一个例子，这里有一个API调用，它将从一个数组中获取四个特定的用户。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d288" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">咻，那太难看了，而且在代码中占据了<strong class="kw iu">吨</strong>的空间。</p><p id="7fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Async/Await是JavaScript最新也是最棒的东西，它不仅让我们避免了回调地狱，还确保了我们的代码是干净的，并且正确地捕获了错误。我发现Async/Await最吸引人的地方是它建立在承诺之上(非阻塞等)。)，但允许代码可读，并且读起来好像是同步的。这就是力量所在。</p><blockquote class="nj nk nl"><p id="6d64" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">注意:这里有一个例子，用一半以上的代码从一个数组中检索四个用户的同一套API调用:</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ca32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很棒，对吧？</p><p id="cf9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Async/Await是建立在承诺之上的，所以您甚至可以将<code class="fe mr ms mt mu b"><strong class="kw iu">Promise.all()</strong></code>与Await关键字一起使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="nj nk nl"><p id="3486" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">注意:Async/Await由于其同步特性而稍慢。在一行中多次使用它时应该小心，因为Await关键字会停止执行它后面的所有代码，就像在同步代码中一样。</p></blockquote><h1 id="dc39" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">如何开始使用Async/Await？</h1><p id="66c4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用Async/Await非常容易理解和使用。事实上，在Node.js的最新版本中,<em class="mo">已经可以直接使用了，并且很快就可以在浏览器中使用了。现在，如果你想在客户端使用它，你需要使用<a class="ae lq" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>，一个易于使用和设置的网络传输器。</em></p><h1 id="40d7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">异步ˌ非同步(asynchronous)</h1><p id="3c98" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们从Async关键字开始。它可以放在函数之前，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="363e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">等待</h1><p id="9683" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">关键字Await让JavaScript一直等到承诺完成并返回结果。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="bdbd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">完整示例:</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="ba95" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为什么异步/等待更好？</h1><p id="5ca6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">既然我们已经讨论了Async/Await必须提供的许多承诺，让我们回顾一下为什么我们(<a class="ae lq" href="https://getstream.io" rel="noopener ugc nofollow" target="_blank"> Stream </a>)认为Async/Await是我们代码库的最佳选择。</p><ol class=""><li id="55ea" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">Async/Await允许使用更少的代码行、更少的输入和更少的错误来创建一个干净简洁的代码库。最终，它使复杂的嵌套代码变得可读。</li><li id="f45e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用try/catch处理错误(在一个地方，而不是在每个调用中)</li><li id="1e32" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">错误堆栈是有意义的，这与您从承诺中收到的不明确的错误堆栈相反，后者很大，很难定位错误的来源。最好的是，错误指向错误来自的函数。</li></ol><h1 id="8f8f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">最后的想法</h1><p id="a3aa" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我可以说Async/Await是过去几年JavaScript中添加的最强大的特性之一。</p><p id="b761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不到一天的时间就理解了语法，并看到了我们的代码库在这方面是多么的混乱。将我们所有的基于Promise的代码转换成Async/Await总共花了大约两天时间，本质上是一次完整的重写——这正好说明了使用Async/Await时需要的代码是多么少。</p><p id="3638" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，感谢你阅读这篇文章。如果你喜欢，请给我一个掌声(或者50下，如果你感觉特别好的话)。谢谢大家！</p><p id="2d67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">快乐编码！</strong></p></div></div>    
</body>
</html>