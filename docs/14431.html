<html>
<head>
<title>Compile Time Feature Flags in Rust: Why, How, and When?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的编译时特征标志:为什么，如何，何时？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compile-time-feature-flags-in-rust-why-how-when-129aada7d1b3?source=collection_archive---------6-----------------------#2022-12-14">https://betterprogramming.pub/compile-time-feature-flags-in-rust-why-how-when-129aada7d1b3?source=collection_archive---------6-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代价是什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2443fa8816965d98ac4c3fb6d0360039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*VX1bKN5JhPca4zrmwYzGhw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="c7cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Rust中挑选编译时特性的能力可以提高代码的性能、大小、可维护性、安全性和可移植性。</p><p id="30b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些论据，说明为什么您应该在使用依赖项时主动使用特性，并将这些特性提供给其他库用户。</p><h1 id="7643" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">表演</h1><p id="840d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在Rust中使用特性标志可以提高结果代码的性能。通过只包含特定应用程序所需的代码，您可以避免未使用或不必要的代码的开销。</p><p id="7384" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管有编译器优化来移除死代码，但这仍然可以产生更快更有效的程序(并使编译器的工作更容易)。</p><h1 id="1849" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">大小</h1><p id="95d5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">生成的二进制文件的总体大小受到您包含的依赖项以及您如何使用它们的影响。</p><p id="a3f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特性选择可以帮助生成的二进制文件更小，有利于需要分布或部署到资源受限环境中的应用程序。</p><h1 id="f613" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">可维护性</h1><p id="ae14" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我最近有一个中断上游依赖，我很幸运地在一个特性标志下有那个上游中断代码——对于一个我没有使用的特性。</p><p id="33a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在等待上游库更新的时候，我为我的本地项目删除了这个特性，它又可以很好地构建了。这意味着您可以通过允许开发人员选择性地包含或排除特定功能来提高Rust代码的可维护性。</p><h1 id="0214" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">安全性</h1><p id="c6bc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">从统计学上来说——您依赖的代码越多，出现安全问题的几率就越高。仅仅依靠你需要的特性来降低安全问题的几率是安全设计思维，而一个“成块”提供自己的板条箱正在帮助实现这一点。</p><p id="060b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一些方法可以根据您对某个实现的安全性的满意程度来选择同一功能的不同实现。例如，与基于C的实现相比，你可能更喜欢Rust-native TLS实现，因为Rust是一种安全的语言，并且像Reqwest 这样的一些<a class="ae mk" href="https://github.com/seanmonstar/reqwest/blob/master/Cargo.toml#L29-L44" rel="noopener ugc nofollow" target="_blank">机箱提供了一系列TLS后端。</a></p><h1 id="cf4e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">轻便</h1><p id="afe5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">作为一种编译语言，特性标志的一个重要方面是提高代码的可移植性。</p><p id="c86b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以有选择地包含或排除特定的功能，以使您的代码在不同的平台和环境之间更具可移植性。</p><h1 id="b362" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">C/C++如何比较？</h1><p id="1746" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">历史上，C和C++一直是部署到许多平台和CPU架构的编译后可移植代码的原型。</p><p id="7d59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">C++没有一个内置的特性直接等同于在Rust中选择编译时特性的能力。然而，<a class="ae mk" href="https://stackoverflow.com/questions/4469645/dos-and-donts-of-conditional-compile" rel="noopener ugc nofollow" target="_blank"> C++确实有许多预处理指令</a>，可以用来在编译时选择性地包含或排除某些代码。</p><p id="69ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以提供一些与Rust中的特性标志相同的好处。尽管如此，无论是作为寻求构建现有代码库的程序员，还是作为寻求启用或禁用功能的消费者，都很难发现这一点。</p><h1 id="531b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">功能标志:构造块</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6f2aca53c852ab6a2f44d83407db6908.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*UaMeKqJ5mFql7bkx1IRKlg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="e469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要启用特定板条箱的特定特征标志，您可以使用板条箱的<code class="fe mm mn mo mp b">Cargo.toml</code>文件中的<code class="fe mm mn mo mp b">default-features = false</code>和<code class="fe mm mn mo mp b">features</code>属性。</p><p id="17b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="0995" class="mu lo iq mp b be mv mw l mx my">[dependencies]<br/>my-crate = { default-features = false, features = ["my-feature"] }</span></pre><p id="2ed2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要为一段特定的代码启用特性标志，可以使用<code class="fe mm mn mo mp b">#[cfg(feature = "my-feature")]</code>属性。例如:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="4a7f" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "my-feature")]<br/>fn my_function() {<br/>    // Code that is only included when the "my-feature" flag is enabled<br/>}</span></pre><p id="6898" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要启用特定模块的特性标志，可以在<code class="fe mm mn mo mp b">mod</code>声明中使用<code class="fe mm mn mo mp b">#[cfg(feature = "my-feature")]</code>属性。例如:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="26df" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "my-feature")]<br/>mod my_module {<br/>    // Code that is only included when the "my-feature" flag is enabled<br/>}</span></pre><p id="bb17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使用<code class="fe mm mn mo mp b">derive</code>为特定的结构或枚举启用特性标志，可以使用<code class="fe mm mn mo mp b">#[cfg_attr(feature = "my-feature", derive(...))]</code>属性。例如:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="0d71" class="mu lo iq mp b be mv mw l mx my">#[cfg_attr(feature = "my-feature", derive(Debug, PartialEq))]<br/>struct MyStruct {<br/>    // Fields and methods that are only included when the "my-feature" flag is enabled<br/>}</span></pre><p id="5b8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是如何启用或禁用对特定平台的支持:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="fab8" class="mu lo iq mp b be mv mw l mx my">#[cfg(target_os = "linux")]<br/>mod linux_specific_code {<br/>    // Linux-specific code goes here...<br/>}</span></pre><p id="eabc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以及如何启用或禁用特征的特定实现:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="7d20" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "special_case")]<br/>impl MyTrait for MyType {<br/>    // Implementation of trait for special case goes here...<br/>}</span></pre><p id="fbf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如何启用或禁用特定的测试用例:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="9df3" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "expensive_tests")]<br/>#[test]<br/>fn test_expensive_computation() {<br/>    // Test that performs expensive computation goes here...<br/>}</span></pre><p id="f32d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是启用或禁用特定基准的代码:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="7583" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "long_benchmarks")]<br/>#[bench]<br/>fn bench_long_running_operation(b: &amp;mut Bencher) {<br/>    // Benchmark for a long-running operation goes here...<br/>}</span></pre><p id="cd24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要仅在设置了多个标志时启用某个功能，您可以使用<code class="fe mm mn mo mp b">#[cfg(all(feature1, feature2, ...))]</code>属性。例如，要仅在<code class="fe mm mn mo mp b">my_feature1</code>和<code class="fe mm mn mo mp b">my_feature2</code>标志都设置时启用<code class="fe mm mn mo mp b">my_function()</code>:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="e9a2" class="mu lo iq mp b be mv mw l mx my">#[cfg(all(feature = "my_feature1", feature = "my_feature2"))]<br/>fn my_function() {<br/>    // code for my_function<br/>}</span></pre><p id="1d95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要仅在设置了多个标志中的一个时启用一个功能，您可以使用<code class="fe mm mn mo mp b">#[cfg(any(feature1, feature2, ...))]</code>属性。例如，当<code class="fe mm mn mo mp b">my_feature1</code>或<code class="fe mm mn mo mp b">my_feature2</code>标志被置位时，启用<code class="fe mm mn mo mp b">my_function()</code>:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="36b8" class="mu lo iq mp b be mv mw l mx my">#[cfg(any(feature = "my_feature1", feature = "my_feature2"))]<br/>fn my_function() {<br/>    // code for my_function<br/>}</span></pre><h1 id="a1b5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">插图特征标志</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5a4ae91423ebe7ff999e9d97362eefd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*ClPJZBSkuwEWmJN1xE-mSQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="fca8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同一个模块，但是指向不同的实现路径，然后用<code class="fe mm mn mo mp b">pub use</code>从那个模块中拉出一个函数来公开。</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="5e32" class="mu lo iq mp b be mv mw l mx my">//! Signal monitor<br/>#[cfg(unix)]<br/>#[path = "unix.rs"]<br/>mod imp;<br/>#[cfg(windows)]<br/>#[path = "windows.rs"]<br/>mod imp;<br/>#[cfg(not(any(windows, unix)))]<br/>#[path = "other.rs"]<br/>mod imp;<br/>pub use self::imp::create_signal_monitor;</span></pre><p id="6c5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参见<code class="fe mm mn mo mp b"> <a class="ae mk" href="https://github.com/shadowsocks/shadowsocks-rust/blob/master/src/monitor/mod.rs" rel="noopener ugc nofollow" target="_blank">https://github.com/shadowsocks/shadowsocks-rust/blob/master/src/monitor/mod.rs</a></code></p><p id="32ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当不同的组件具有相同的实现时:您可以提供世界上所有的东西，而没有任何缺点，因为只有选择的特性会被编译进来。</p><p id="ce4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代价是现在你有了一个更大的测试矩阵，它随着每一个新的选择而增长。</p><p id="9025" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，库允许您选择您能想到的任何分配器，因为分配器有一个定义良好的接口，并且不需要您进行交换:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9843c3db07d79e9e8617c066e6aa30bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ZnnpDa5O7yHgTCsYG_tErw.png"/></div></figure><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="777a" class="mu lo iq mp b be mv mw l mx my">//! Memory allocator<br/>#[cfg(feature = "jemalloc")]<br/>#[global_allocator]<br/>static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;<br/>#[cfg(feature = "tcmalloc")]<br/>#[global_allocator]<br/>static ALLOC: tcmalloc::TCMalloc = tcmalloc::TCMalloc;<br/>#[cfg(feature = "mimalloc")]<br/>#[global_allocator]<br/>static ALLOC: mimalloc::MiMalloc = mimalloc::MiMalloc;<br/>#[cfg(feature = "snmalloc")]<br/>#[global_allocator]<br/>static ALLOC: snmalloc_rs::SnMalloc = snmalloc_rs::SnMalloc;<br/>#[cfg(feature = "rpmalloc")]<br/>#[global_allocator]<br/>static ALLOC: rpmalloc::RpMalloc = rpmalloc::RpMalloc</span></pre><p id="1763" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，您将看到如何让您的用户“嵌入”他们需要的功能，您可以选择想要嵌入的深度:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="2d99" class="mu lo iq mp b be mv mw l mx my">//! Service launchers<br/>pub mod genkey;<br/>#[cfg(feature = "local")]<br/>pub mod local;<br/>#[cfg(feature = "manager")]<br/>pub mod manager;<br/>#[cfg(feature = "server")]<br/>pub mod server;</span></pre><p id="8f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的示例中，您可以使用块来“人为地”在某个特性下的整个代码段中限定范围:</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="02c7" class="mu lo iq mp b be mv mw l mx my">#[cfg(feature = "local-tunnel")]<br/>{<br/>    app = app.arg(<br/>        Arg::new("FORWARD_ADDR")<br/>            .short('f')<br/>            .long("forward-addr")<br/>            .num_args(1)<br/>            .action(ArgAction::Set)<br/>            .requires("LOCAL_ADDR")<br/>            .value_parser(vparser::parse_address)<br/>            .required_if_eq("PROTOCOL", "tunnel")<br/>            .help("Forwarding data directly to this address (for tunnel)"),<br/>    );<br/>}</span></pre><p id="995a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们内联了空的实现，因为如果函数体总是返回一个简单的空值，为什么还要为函数调用付出代价呢？(<code class="fe mm mn mo mp b">Ok(()</code>)。</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="8168" class="mu lo iq mp b be mv mw l mx my">#[cfg(all(not(windows), not(unix)))]<br/>#[inline]<br/>fn set_common_sockopt_after_connect_sys(_: &amp;tokio::net::TcpStream, _: &amp;ConnectOpts) -&gt; io::Result&lt;()&gt; {<br/>    Ok(())<br/>}</span></pre><h1 id="3c97" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">最后但同样重要的是:权衡是什么？</h1><p id="9230" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果特性如此强大，并且抛弃了许多C/C++进行条件代码编译的原始方式，为什么不在任何地方、任何时候都使用它呢？这里有一些你应该考虑的事情。</p><ul class=""><li id="0dba" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated"><strong class="kt ir">使用太多功能是一件真实的事情。</strong>在想象和极端的情况下，想象你在每个模块和功能上都有一个特性。这将要求您的用户解决一个非常困难的难题，即理解如何从其离散的特性中组合您的库。这就是特性的危险。你希望你提供的功能数量适中，以减少认知负荷，并且这些功能是人们关心的删除或添加的东西。</li><li id="c065" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated"><strong class="kt ir">测试是特性的另一个重要方面。您永远不知道您的用户会选择哪种功能组合，而每种组合都会选择不同的代码集，这些代码段必须在编译过程中顺利地互操作(成功编译)。在逻辑上(不是引入bug)，你需要测试所有特性与其他特性的组合，并创建一个强大的特性集！</strong></li><li id="cdcf" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated"><strong class="kt ir">你可以用</strong> <code class="fe mm mn mo mp b"><strong class="kt ir">xtaskops::powerset</strong></code> <strong class="kt ir"> </strong>来实现自动化——点击这里查看更多:<a class="ae mk" href="https://github.com/jondot/xtaskops" rel="noopener ugc nofollow" target="_blank">https://github.com/jondot/xtaskops</a>。</li></ul></div></div>    
</body>
</html>