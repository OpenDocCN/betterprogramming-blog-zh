<html>
<head>
<title>How to Use Rust and MQTT in IoT Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在物联网项目中使用Rust和MQTT</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-rust-and-mqtt-in-your-next-project-e4b80ad1b09e?source=collection_archive---------3-----------------------#2022-11-19">https://betterprogramming.pub/how-to-use-rust-and-mqtt-in-your-next-project-e4b80ad1b09e?source=collection_archive---------3-----------------------#2022-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们看看MQTT，以及在您的下一个物联网项目中，如何使用rumqttc机箱将MQTT与Rust结合使用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6936e71deebe651b5177679608b63b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a4pjzNLjDmviBTno"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@wasdrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安朵斯·瓦斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="bc07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你为什么想买物联网设备？在大多数情况下，你想获得更多的控制你的家。也许你只是想监控东西，甚至远程控制。</p><p id="ed3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，你可以依赖制造商提供的应用程序。但是作为程序员，这不是你唯一的选择。也许，你想在洗衣机完成时收到一条信息，或者你想在设备耗电过多时收到警告。在这些情况下，可以看一看MQTT。</p><p id="e04c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将在Rust中构建一个小型MQTT客户机，它监听MQTT代理并编写消息。所以让我们开始吧。</p><h1 id="7c1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是MQTT</h1><p id="bef1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">那么首先，什么是MQTT？MQTT是一种轻量级、发布-订阅、机器对机器(M2M)的网络协议。它针对低带宽和高延迟进行了优化。</p><p id="b897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是它是如何工作的呢？MQTT按照发布-订阅模式工作。名为<em class="mp">发布者</em>的消息发送者不能直接指定名为<em class="mp">订阅者</em>的接收者，而是将发布的消息分类到名为<em class="mp">主题</em>的类别中。这在不知道有多少订阅者订阅了主题的情况下发生。但是这个系统在现实中是如何运作的呢？</p><p id="237c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使MQTT通信成为可能，我们需要一个代理和许多客户机。经纪人充当中介。客户端可以向代理上的主题发送消息。同时，其他客户端可以收听关于该主题的新消息。在我们阐明了这些基础知识之后，我们可以开始研究代码了。</p><p id="eba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个小项目，我们将使用Rust。Rust是一种性能良好且可靠的语言。性能与C++相当，同时通过其丰富的类型系统和所有权模型保证内存安全和线程安全。这两个特性在轻量级程序在后台长时间运行的特殊情况下都很有用。</p><h1 id="80cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">生锈的MQTT</h1><p id="ee65" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于本文，我们使用Rust crate (=库)<code class="fe mq mr ms mt b"><a class="ae kv" href="https://crates.io/crates/rumqttc" rel="noopener ugc nofollow" target="_blank">rumqttc</a></code>。这是Rust中MQTT客户端的完整实现。</p><p id="794a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要创建一个新的Rust项目。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="1b85" class="my lt iq mt b be mz na l nb nc">cargo new mqtt-rust-demo</span></pre><p id="b89c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">切换到新项目后，我们将<code class="fe mq mr ms mt b">rumqttc</code>添加到我们的<code class="fe mq mr ms mt b">Cargo.toml</code>中。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="4ed9" class="my lt iq mt b be mz na l nb nc">rumqttc = "0.17.0"</span></pre><p id="90b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完库之后，我们可以从代码开始。</p><h1 id="f2cf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">客户</h1><p id="7330" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们做的第一件事是用我们的连接数据创建一个变量。这是通过<code class="fe mq mr ms mt b">MqttOptions</code>完成的。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="d15f" class="my lt iq mt b be mz na l nb nc">let mut mqttoptions = MqttOptions::new("NAME", "YOUR BROKER", 1883);<br/>mqttoptions.set_keep_alive(Duration::from_secs(5));</span></pre><p id="13b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要指定客户端的名称。给客户机一个唯一的名称很重要，因为两个客户机在一个代理上不能有相同的名称。之后，代理的地址和端口将作为下一个参数跟在后面。您可以连接到互联网或本地网络上的代理。此外，您可以设置选项。在我们的例子中，客户端应该每五秒发送一条“仍然活动”的消息。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="c114" class="my lt iq mt b be mz na l nb nc">let (mut client, mut connection) = Client::new(mqttoptions, 10);<br/>client.subscribe("demo/mqtt", QoS::AtMostOnce).unwrap();</span></pre><p id="b14f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们创建同步客户端的方式。我们用我们的选择来填充它。我们得到一个客户端对象和一个事件循环。后者以后会很重要。首先，我们说我们想要订阅主题<code class="fe mq mr ms mt b">demo/mqtt</code>。</p><h1 id="df2a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">服务质量</h1><p id="c852" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">此外，我们还指定了QoS级别。服务质量(QoS)是MQTT协议的一个关键特性。有3种不同级别的QoS:最多一次(0)，至少一次(1)，正好一次(2)。</p><ul class=""><li id="8dcd" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><em class="mp"> QoS 0 —最多一次</em>只是向代理发送消息(就像在<em class="mp"> fire and forget </em>)一样。这个级别应该只用于非常可靠的网络</li><li id="37c5" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><em class="mp"> QoS 1 —至少一次</em>向代理发送消息。同时，发送方在本地存储消息，直到代理发回确认消息(PUBACK消息)为止。当一段时间后没有确认消息返回时，发送方重复该消息。</li><li id="9b3f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><em class="mp">QoS 2——恰好一次</em>向代理发送消息(这并不奇怪)。像QoS 1一样，它一直等到收到确认消息(<code class="fe mq mr ms mt b">PUBREC</code>)才返回。在此之前，发件人会发出带有重复标志的相同的已发布邮件。当发送方收到确认消息时，它用一个<code class="fe mq mr ms mt b">PUBREL</code>消息响应代理。与此同时，发送者存储了<code class="fe mq mr ms mt b">PUBREC</code>消息。当代理接收到<code class="fe mq mr ms mt b">PUBREL</code>消息时，它可以安全地丢弃该消息的所有临时存储的数据。同时，代理向发送者发送一个<code class="fe mq mr ms mt b">PUBCOMP</code>消息。现在，发送者可以删除所有时态数据。</li></ul><h1 id="8fb0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">事件循环</h1><p id="ad2b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个主题中，我们发送一些消息。所以我们产生了一个新的任务。在此任务中，我们发布一条带有主题编号的消息。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="44b6" class="my lt iq mt b be mz na l nb nc">thread::spawn(move || for i in 0..10 {<br/>   client.publish("demo/mqtt", QoS::AtLeastOnce, false, vec![i; i as usize]).unwrap();<br/>   thread::sleep(Duration::from_millis(100));<br/>});</span></pre><p id="8c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们来到我们的事件循环对象。我们将它包裹在一个无限循环中，因为它应该总是监听主题的消息。<br/>这是通过命令<code class="fe mq mr ms mt b">connection.iter().enumerate()</code>完成的。接下来，我们输出消息。</p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="22ee" class="my lt iq mt b be mz na l nb nc">for (_i, message) in connection.iter().enumerate() {<br/>        println!("Message= {:?}", message);<br/>}</span></pre><h1 id="4bb7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="500b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本文只是对MQTT这个庞大而有趣的主题的一个很小的介绍。但是让我们看看你学到了什么——你对MQTT的结构有了基本的了解，并在Rust中创建了一个可以发送和接收消息的小程序。这是一个很好的开始！</p><p id="c4eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这篇文章的<a class="ae kv" href="https://gist.github.com/ngarske/cc5257fff416459f10fd88c422e173cb" rel="noopener ugc nofollow" target="_blank">代码</a></p><pre class="kg kh ki kj gt mu mt mv bn mw mx bi"><span id="bbd3" class="my lt iq mt b be mz na l nr nc">This article can also be found on my blog: <br/><br/><a class="ae kv" href="https://nikolas.blog/how-to-use-rust-and-mqtt-in-your-next-project/" rel="noopener ugc nofollow" target="_blank">https://nikolas.blog/how-to-use-rust-and-mqtt-in-your-next-project/</a></span></pre></div></div>    
</body>
</html>