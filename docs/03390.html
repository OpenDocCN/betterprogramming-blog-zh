<html>
<head>
<title>How to Draw Arcs and Rectangles on HTML Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在HTML画布上绘制圆弧和矩形</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drawing-shapes-on-html-canvas-arcs-and-rectangles-422680b9b05?source=collection_archive---------16-----------------------#2020-02-06">https://betterprogramming.pub/drawing-shapes-on-html-canvas-arcs-and-rectangles-422680b9b05?source=collection_archive---------16-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fcd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用画布元素创造的基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23db370ff604e4cbd2c1cebc42174f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FAMoGwsDln8V9_2H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@delilaziebart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Delila Ziebart </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ca58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML <code class="fe lv lw lx ly b">canvas</code>元素让我们画出形状，并用它们做各种事情。最基本的事情包括添加形状、改变它们的颜色和绘制路径。</p><p id="316e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分，我们将看看如何在画布上绘制形状，包括圆弧和矩形</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0d5d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">网格</h1><p id="ee0a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">画布上的一切都位于一个网格上。这些项目由坐标定位。左上角是原点(0，0)，一切都是相对于那个放置的。通常网格中的一个单位是屏幕上的一个像素。</p><p id="46b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向右移动时，<em class="nd"> x </em>坐标变大，向下移动时，<em class="nd"> y </em>坐标变大。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="75c0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">绘制矩形</h1><p id="7523" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Canvas仅支持两种基本形状——矩形和路径。</p><p id="e7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用渲染上下文的<code class="fe lv lw lx ly b">fillRect</code>方法来绘制矩形。它采用四个参数，分别是左上角的<em class="nd"> x </em>和<em class="nd"> y </em>坐标，以及矩形的宽度和高度。该矩形将用一种颜色填充。</p><p id="c0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">strokeRect</code>方法采用与<code class="fe lv lw lx ly b">fillRect</code>方法相同的参数，让我们画一个矩形轮廓。</p><p id="f42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，还有<code class="fe lv lw lx ly b">clearRect</code>方法，清除指定的矩形区域，使其完全透明。它采用与其他两种方法相同的参数。</p><p id="db3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用这些方法…</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="730c" class="ni mh it ly b gy nj nk l nl nm">const canvas = document.querySelector('canvas');<br/>const ctx = canvas.getContext('2d');<br/>ctx.fillRect(5, 5, 80, 80);<br/>ctx.clearRect(15, 15, 60, 60);<br/>ctx.strokeRect(50, 50, 50, 50);</span></pre><p id="8465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…假设我们有以下HTML …</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="69ee" class="ni mh it ly b gy nj nk l nl nm">&lt;canvas&gt;</span><span id="da31" class="ni mh it ly b gy nn nk l nl nm">&lt;/canvas&gt;</span></pre><p id="df42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…以及CSS:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="07db" class="ni mh it ly b gy nj nk l nl nm">canvas {<br/>  width: 200px;<br/>  height: 200px;<br/>  border: 1px solid black;<br/>}</span></pre><p id="b1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fillRect</code>绘制一个黑色背景的矩形，在左上角有一个用<code class="fe lv lw lx ly b">clearRect</code>方法绘制的清晰矩形。黑色矩形的左上角在(5，5)中，大小为80x80像素。</p><p id="2cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个透明矩形的左上角是(15，15)，它的大小是60x60像素。</p><p id="aa99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用<code class="fe lv lw lx ly b">strokeRect</code>方法在右下角画出矩形。它的左上角在(50，50)处，大小为50x50像素。</p><p id="2eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们得到了以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/44203dc22219e661ffdb000ade3332c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*dFm-XanmLgpAH3G7sKDOGQ.png"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9677" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">绘制路径</h1><p id="0702" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">除了矩形，我们还可以画路径，路径是连接在一起的线段。它们可以是不同的形状或颜色。路径也可以是封闭的。</p><p id="ad2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过以下步骤创建路径:</p><ol class=""><li id="71d4" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">我们创造了道路。</li><li id="8217" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">使用绘图命令绘制路径。</li><li id="ead9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">然后，我们可以描边或填充路径来渲染它。</li></ol><p id="7bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要调用一些方法来绘制路径。我们需要调用<code class="fe lv lw lx ly b">beginPath</code>方法来创建一个新路径。未来的绘图命令将被引导到路径，并建立它。</p><p id="05a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用其他三种方法来绘制路径。我们用<code class="fe lv lw lx ly b">closePath</code>方法给路径添加一条直线，到达当前子路径的起点。</p><p id="106f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">stroke</code>的方法通过描绘轮廓来画出形状。然后，如果我们愿意，我们可以使用<code class="fe lv lw lx ly b">fill</code>方法来填充路径的内容区域。</p><p id="cef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lv lw lx ly b">moveTo</code>方法移动到屏幕的坐标，该方法把要移动到的<em class="nd"> x </em>和<em class="nd"> y </em>坐标作为参数。然后，我们可以用<code class="fe lv lw lx ly b">lineTo</code>方法从那个坐标到另一个坐标画一条线，该方法使用<em class="nd"> x </em>和<em class="nd"> y </em>坐标从当前坐标所在的位置画一条线。</p><p id="ac02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以通过书写来画一个三角形:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="50e2" class="ni mh it ly b gy nj nk l nl nm">const canvas = document.querySelector('canvas');<br/>const ctx = canvas.getContext('2d');<br/>ctx.beginPath();<br/>ctx.moveTo(100, 50);<br/>ctx.lineTo(50, 100);<br/>ctx.lineTo(150, 100);<br/>ctx.fill();</span></pre><p id="eb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先从(100，50)开始尝试。然后，我们用第一个<code class="fe lv lw lx ly b">lineTo</code>调用从(100，50)到(50，100)画一条线。然后，我们用<code class="fe lv lw lx ly b">lineTo</code>方法再次从(50，100)画到(150，100)。最后，我们调用<code class="fe lv lw lx ly b">fill</code>通过填充路径的内容区域来绘制形状。</p><p id="8b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d3758afbee89659aeb5029fb475ff114.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*9x__y08vYP_DMuyG8n66tg.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="943f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">moveTo方法和弧线</h1><p id="f41a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">moveTo</code>方法便于在不绘制任何东西的情况下移动绘图路径的原点。</p><p id="870a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它采用我们想要移动到的<em class="nd"> x </em>和<em class="nd"> y </em>坐标。</p><p id="7083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f6c9" class="ni mh it ly b gy nj nk l nl nm">const canvas = document.querySelector('canvas');<br/>const ctx = canvas.getContext('2d');<br/>ctx.beginPath();<br/>ctx.moveTo(125, 75);<br/>ctx.arc(75, 75, 50, 0, 2 * Math.PI);<br/>ctx.moveTo(135, 75);<br/>ctx.arc(75, 75, 60, 0, 2 * Math.PI);<br/>ctx.stroke();</span></pre><p id="5dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了画一个圆，我们用<code class="fe lv lw lx ly b">moveTo</code>方法移动到圆的最右边的点。然后，我们调用<code class="fe lv lw lx ly b">arc</code>方法来画圆弧。前两个参数是中心的<em class="nd"> x </em>和<em class="nd"> y </em>坐标。第三个参数是半径，第四个参数是起始角度，最后一个参数是结束角度。</p><p id="53d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，起始角度位于3点钟位置。顺时针或逆时针方向是相对于这个点的。</p><p id="bad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以传入一个额外的布尔参数来指定我们是否要逆时针绘制。</p><p id="cc46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有一个<code class="fe lv lw lx ly b">arcTo</code>方法，它分别为前四个参数取起点和终点的<em class="nd"> x </em>和<em class="nd"> y </em>坐标。第五个参数是弧的半径。</p><p id="368b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写完这段代码后，我们得到了下面的圆圈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/971a91a56aa40703f9260e9825203c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*VzgumDiXzdjCkXQ2faZipg.png"/></div></figure><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b4d2" class="ni mh it ly b gy nj nk l nl nm">ctx.moveTo(125, 75);<br/>ctx.arc(75, 75, 50, 0, 2 * Math.PI);</span></pre><p id="d6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将绘制一个半径为50像素的小圆。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="924d" class="ni mh it ly b gy nj nk l nl nm">ctx.moveTo(135, 75);<br/>ctx.arc(75, 75, 60, 0, 2 * Math.PI);</span></pre><p id="ccf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将绘制半径为60像素的较大的圆。</p><p id="bc5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了canvas元素，我们可以轻松地绘制形状。有专门画矩形的方法。对于弯曲的形状和线条，我们可以用<code class="fe lv lw lx ly b">arc</code>和<code class="fe lv lw lx ly b">arcTo</code>的方法画出来。</p><p id="9e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的喜好，形状可以被填充或不被填充。</p><p id="b125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">moveTo</code>方法移动到一个给定的坐标，而不用画任何东西。</p></div></div>    
</body>
</html>