<html>
<head>
<title>How a Go Program Compiles down to Machine Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go程序如何编译成机器代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-a-go-program-compiles-down-to-machine-code-e4532dc8b8ca?source=collection_archive---------0-----------------------#2018-09-25">https://betterprogramming.pub/how-a-go-program-compiles-down-to-machine-code-e4532dc8b8ca?source=collection_archive---------0-----------------------#2018-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/954601f0761768f9a512a72e7bf88ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEhtR8ynzOc1FNOG5vDlig.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">https://getstream.io/blog</p></figure><div class=""/><div class=""><h2 id="abda" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">深入了解编译器的扫描器、解析器和代码生成阶段</h2></div><p id="a7f0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在<a class="ae lt" href="https://getstream.io" rel="noopener ugc nofollow" target="_blank"> Stream </a>这里，我们广泛使用围棋，它极大地提高了我们的生产力。我们还发现，通过使用Go，速度非常快，而且自从我们开始使用它以来，我们已经实现了堆栈中的关键任务部分，例如由gRPC、Raft和RocksDB支持的内部存储引擎。</p><p id="414d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">今天我们将看看Go 1.11编译器，以及它如何将Go源代码编译成可执行文件，以了解我们日常使用的工具是如何工作的。我们还将看到为什么Go代码如此之快，以及编译器如何帮助。我们将看看编译器的三个阶段:</p><ul class=""><li id="38a4" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">扫描器将源代码转换成标记列表，供解析器使用。</li><li id="29d0" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">解析器，它将标记转换成抽象语法树，供代码生成使用。</li><li id="6fce" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">代码生成，将抽象语法树转换成机器代码。</li></ul><p id="1b5e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="mi">注意:我们将要使用的包(</em> <code class="fe mj mk ml mm b"><em class="mi">go/scanner</em></code> <em class="mi">，</em> <code class="fe mj mk ml mm b"><em class="mi">go/parser</em></code> <em class="mi">，</em> <code class="fe mj mk ml mm b"><em class="mi">go/token</em></code> <em class="mi">，</em> <code class="fe mj mk ml mm b"><em class="mi">go/ast</em></code> <em class="mi">等)。)并不由Go编译器使用，而是主要提供给工具使用，以对Go源代码进行操作。然而，实际的Go编译器具有非常相似的语义。它不使用这些包，因为编译器曾经是用C编写的，并被转换成Go代码，所以实际的Go编译器仍然会让人想起那个结构。</em></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c1e3" class="mu mv ji bd mw mx my mz na nb nc nd ne ko nf kp ng kr nh ks ni ku nj kv nk nl bi translated">扫描仪</h1><p id="837d" class="pw-post-body-paragraph kx ky ji kz b la nm kj lc ld nn km lf lg no li lj lk np lm ln lo nq lq lr ls im bi translated">每个编译器的第一步是将原始源代码文本分解成标记，这是由扫描器(也称为lexer)完成的。标记可以是关键字、字符串、变量名、函数名等。每个有效的程序“单词”都由一个令牌表示。用Go的具体术语来说，这可能意味着我们有一个令牌“package”、“main”、“func”等等。</p><p id="ba4b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">每个标记都由它在Go中的位置、类型和原始文本来表示。Go甚至允许我们通过使用<code class="fe mj mk ml mm b">go/scanner</code>和<code class="fe mj mk ml mm b">go/token</code>包在Go程序中自己执行扫描仪。这意味着我们可以检查我们的程序在被扫描后在Go编译器看来是什么样子。为此，我们将创建一个简单的程序来打印“Hello World”程序的所有令牌。</p><p id="ca98" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">该程序将如下所示:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cbe8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将创建我们的源代码字符串并初始化<code class="fe mj mk ml mm b">scanner.Scanner </code>结构，它将扫描我们的源代码。我们尽可能多地调用<code class="fe mj mk ml mm b">Scan()</code>,并打印令牌的位置、类型和文字字符串，直到到达文件结尾(EOF)标记。</p><p id="be2c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当我们运行该程序时，它将打印以下内容:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e339" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里我们可以看到Go解析器在编译程序时使用了什么。我们还可以看到，扫描器在c等其他编程语言中通常放置分号的地方添加了分号。这解释了为什么Go不需要分号:它们是由扫描器智能放置的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="aa7d" class="mu mv ji bd mw mx my mz na nb nc nd ne ko nf kp ng kr nh ks ni ku nj kv nk nl bi translated">句法分析程序</h1><p id="f0ae" class="pw-post-body-paragraph kx ky ji kz b la nm kj lc ld nn km lf lg no li lj lk np lm ln lo nq lq lr ls im bi translated">扫描完源代码后，它将被传递给解析器。解析器是编译器的一个阶段，它将标记转换成抽象语法树(AST)。AST是源代码的结构化表示。在AST中，我们将能够看到程序结构，比如函数和常量声明。</p><p id="721c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Go再次为我们提供了解析程序和查看AST的包:<strong class="kz jj"> go/parser </strong>和<strong class="kz jj"> go/ast </strong>。我们可以像这样使用它们来打印完整的AST:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="611d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">输出</strong>:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="65e7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这个输出中，您可以看到关于这个程序的很多信息。在<strong class="kz jj"> Decls </strong>字段中，有一个文件中所有声明的列表，比如导入、常量、变量和函数。在这种情况下，我们只有两个:我们导入的<strong class="kz jj"> fmt </strong>包和main函数。</p><p id="1580" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了进一步理解它，我们可以看一下这个图表，它是上述数据的一个表示，但只包括类型和对应于节点的红色代码:</p><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/b1ee5e873847e306a9446b466e6593ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*koEbjsR_TeQHjbXG"/></div></div></figure><p id="eb97" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">主函数由三部分组成:名称、声明和主体。该名称用值为main的标识符表示。由Type字段指定的声明将包含一个参数和返回类型的列表，如果我们指定了任何类型的话。主体由一个包含程序所有行的语句列表组成，在本例中只有一行。</p><p id="80e8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的单个<code class="fe mj mk ml mm b">fmt.Println</code>语句由AST中的几个部分组成。该语句是一个<code class="fe mj mk ml mm b">ExprStmt</code>，它表示一个表达式，例如，它可以是一个函数调用，就像这里一样，或者它可以是一个文字、一个二元运算(例如加法和减法)、一个一元运算(例如对一个数字求负)等等。任何可以在函数调用的参数中使用的东西都是表达式。</p><p id="4f10" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的<code class="fe mj mk ml mm b">ExprStmt</code>包含一个<code class="fe mj mk ml mm b">CallExpr</code>，这是我们实际的函数调用。这也包括几个部分，其中最重要的是<code class="fe mj mk ml mm b">Fun</code>和<code class="fe mj mk ml mm b">Args</code>。Fun包含对函数调用的引用，在本例中，它是一个<code class="fe mj mk ml mm b">SelectorExpr</code>，因为我们从<code class="fe mj mk ml mm b">fmt</code>包中选择了<code class="fe mj mk ml mm b">Println</code>标识符。然而，在AST中，编译器还不知道<code class="fe mj mk ml mm b">fmt</code>是一个包，它也可能是AST中的一个变量。</p><p id="6f9f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Args包含作为函数参数的表达式列表。在本例中，我们向函数传递了一个文字字符串，因此它由类型为<code class="fe mj mk ml mm b">STRING</code>的<code class="fe mj mk ml mm b">BasicLit</code>表示。</p><p id="28c1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">很明显，我们能够从AST中推断出很多东西。这意味着我们还可以进一步检查AST，例如找到文件中的所有函数调用。为此，我们将使用ast包中的<code class="fe mj mk ml mm b">Inspect</code>函数。这个函数将递归遍历树，并允许我们检查来自所有节点的信息。</p><p id="9fbc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了提取所有函数调用，我们将使用以下代码:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e50d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们在这里所做的是寻找所有节点，以及它们是否属于类型<code class="fe mj mk ml mm b">*ast.CallExpr</code>，我们刚刚看到它代表了我们的函数调用。如果是，我们将使用打印机包打印该函数的名称，它出现在<code class="fe mj mk ml mm b">Fun</code>成员中。</p><p id="a093" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">此代码的输出将是:</p><p id="bcaf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe mj mk ml mm b">fmt.Println</code></p><p id="d5da" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这确实是我们简单程序中唯一的函数调用，所以我们确实找到了所有的函数调用。</p><p id="edf6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在构建了AST之后，所有的导入都将使用GOPATH进行解析，或者对于Go 1.11和更高版本的<a class="ae lt" href="https://github.com/golang/go/wiki/Modules" rel="noopener ugc nofollow" target="_blank">模块</a>。然后，将检查类型，并应用一些初步优化，使程序的执行更快。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="351f" class="mu mv ji bd mw mx my mz na nb nc nd ne ko nf kp ng kr nh ks ni ku nj kv nk nl bi translated">代码生成</h1><p id="3690" class="pw-post-body-paragraph kx ky ji kz b la nm kj lc ld nn km lf lg no li lj lk np lm ln lo nq lq lr ls im bi translated">在解析了导入并检查了类型之后，我们确定程序是有效的Go代码，我们可以开始将AST转换为(伪)机器码的过程。</p><p id="7ee8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个过程的第一步是将AST转换成程序的低级表示，特别是转换成静态单次分配(SSA)形式。这个中间表示并不是最终的机器码，但它确实更多地表示了最终的机器码。SSA有一组属性，使得应用优化变得更加容易，其中最重要的是，变量总是在使用之前就被定义，并且每个变量只被赋值一次。</p><p id="04ee" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在SSA的初始版本生成之后，将应用大量的优化过程。这些优化应用于某些代码，可以使处理器执行起来更简单或更快。例如，死代码，如<code class="fe mj mk ml mm b">if (false) { fmt.Println(“test”) }</code>可以被消除，因为这将永远不会执行。优化的另一个例子是，某些零校验可以被删除，因为编译器可以证明这些不会为假。</p><p id="061c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们看看SSA和这个简单程序的一些优化过程:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fefa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如您所见，这个程序只有一个函数和一个导入。运行时将打印2。然而，这个示例将足以查看SSA。</p><p id="899c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="mi">注意:只显示主函数的SSA，因为这是有趣的部分。</em></p><p id="4646" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了显示生成的SSA，我们需要将环境变量<code class="fe mj mk ml mm b">GOSSAFUNC</code>设置为我们想要查看SSA的函数，在本例中是main。我们还需要将<code class="fe mj mk ml mm b">-S</code>标志传递给编译器，这样它将打印代码并创建一个HTML文件。我们还将为Linux 64位编译该文件，以确保机器代码与您在这里看到的代码相同。因此，为了编译这个文件，我们将运行:</p><p id="03a0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe mj mk ml mm b">$ GOSSAFUNC=main GOOS=linux GOARCH=amd64 go build -gcflags “-S” simple.go</code></p><p id="c6a3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">它将打印所有的SSA，但也会生成一个交互式的<code class="fe mj mk ml mm b">ssa.html</code>文件，所以我们将使用它。</p><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/2b48f38d63dfd492f0f9b3f0e9949a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BC_0_ob3Rwup8XMn"/></div></div></figure><p id="6c95" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当你打开<code class="fe mj mk ml mm b">ssa.html</code>时，会显示多个通道，其中大部分是折叠的。开始阶段是从AST生成的SSA下一步将非机器专用SSA转换为机器专用SSA，并且<code class="fe mj mk ml mm b">genssa</code>是最终生成的机器代码。</p><p id="c760" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">开始阶段的代码如下所示:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8f30" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个简单的程序已经生成了相当多的SSA(总共35行)。然而，很多都是样板文件，很多都可以删除(最终的SSA版本有28行，最终的机器码版本有18行)。</p><p id="1abf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">每个v都是一个新变量，可以点击查看它的使用位置。<strong class="kz jj"> b的</strong>是块，所以在这种情况下，我们有三个块:<strong class="kz jj"> b1、b2 </strong>和<strong class="kz jj"> b3。b1 </strong>将一直被执行。<strong class="kz jj"> b2 </strong>和<strong class="kz jj"> b3 </strong>是条件块，如果v19 → b2 b3(可能)在<strong class="kz jj"> b1 </strong>结束时，可以通过<strong class="kz jj">看到。我们可以点击那一行的<strong class="kz jj"> v19 </strong>来查看<strong class="kz jj"> v19 </strong>是在哪里定义的。我们看到它被定义为<code class="fe mj mk ml mm b">IsSliceInBounds</code><strong class="kz jj">&lt;bool&gt;v14v 15</strong>，通过<a class="ae lt" href="https://github.com/golang/go/blob/3fd364988ce5dcf3aa1d4eb945d233455db30af6/src/cmd/compile/internal/ssa/gen/genericOps.go#L411" rel="noopener ugc nofollow" target="_blank">查看Go编译器源代码</a>我们可以看到<code class="fe mj mk ml mm b">IsSliceInBounds</code>检查那个<code class="fe mj mk ml mm b">0 &lt;= arg0 &lt;= arg1</code>。我们还可以单击<strong class="kz jj"> v14 </strong>和<strong class="kz jj"> v15 </strong>来查看它们是如何定义的，我们会看到<code class="fe mj mk ml mm b">v14 = Const64 &lt;int&gt; [0]; Const64</code>是一个恒定的64位整数。<strong class="kz jj"> v15 </strong>的定义与<strong class="kz jj"> 1 </strong>相同。所以，我们本质上有0 &lt; = 0 &lt; = 1，这显然是对的。</strong></p><p id="fc5f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">编译器也能够证明这一点，当我们查看<strong class="kz jj"> opt </strong>阶段(“独立于机器的优化”)时，我们可以看到它已经将<strong class="kz jj"> v19 </strong>重写为<code class="fe mj mk ml mm b">ConstBool &lt;bool&gt; [true]</code>。这将用于<code class="fe mj mk ml mm b">opt deadcode</code>阶段，其中<strong class="kz jj"> b3 </strong>被移除，因为来自之前所示条件的<strong class="kz jj"> v19 </strong>始终为真。</p><p id="9585" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们现在来看看另一个更简单的优化，它是由Go编译器在SSA被转换成特定于机器的SSA之后进行的，所以这将是amd64架构的机器代码。为此，我们将比较较低的死码和较低的死码。这是下一阶段的内容:</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="943c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在HTML文件中，一些行是灰色的，这意味着它们将在下一个阶段被删除或更改。例如，<strong class="kz jj"> v15 </strong> ( <code class="fe mj mk ml mm b">MOVQconst &lt;int&gt; [1]</code>)灰显。通过点击进一步检查<strong class="kz jj"> v15 </strong>，我们看到它没有在其他地方使用，并且<code class="fe mj mk ml mm b">MOVQconst</code>本质上与我们之前看到的指令<strong class="kz jj"> Const64 </strong>相同，只是对于<strong class="kz jj"> amd64 </strong>是机器专用的。因此，我们将<strong class="kz jj"> v15 </strong>设置为<strong class="kz jj"> 1 </strong>。而<strong class="kz jj"> v15 </strong>在其他地方都没用，所以是无用(死)代码，可以淘汰。</p><p id="f540" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Go编译器应用了很多这样的优化。因此，虽然来自AST的第一代SSA可能不是最快的实现，但是编译器将SSA优化为一个更快的版本。HTML文件中的每个阶段都有可能加速。</p><p id="7792" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你有兴趣了解更多关于Go编译器中的SSA，请查看<a class="ae lt" href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa" rel="noopener ugc nofollow" target="_blank"> Go编译器的SSA源代码</a>。这里定义了所有的操作和优化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ea87" class="mu mv ji bd mw mx my mz na nb nc nd ne ko nf kp ng kr nh ks ni ku nj kv nk nl bi translated">结论</h1><p id="662c" class="pw-post-body-paragraph kx ky ji kz b la nm kj lc ld nn km lf lg no li lj lk np lm ln lo nq lq lr ls im bi translated">Go是一种非常高效和高性能的语言，受其编译器和优化的支持。了解更多关于Go编译器的知识，<a class="ae lt" href="https://github.com/golang/go/tree/master/src/cmd/compile" rel="noopener ugc nofollow" target="_blank">源代码</a>有一个很棒的<code class="fe mj mk ml mm b">README</code>。</p><p id="a3cf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你想了解更多关于为什么Stream使用Go，特别是为什么我们从Python转向Go，请查看<a class="ae lt" href="https://getstream.io/blog/switched-python-go/" rel="noopener ugc nofollow" target="_blank">我们关于切换到Go的博客文章</a>。</p></div></div>    
</body>
</html>