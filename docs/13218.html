<html>
<head>
<title>4 Ways to Simplify React State (By Not Using React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化React状态的4种方法(不使用React)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-ways-to-simplify-react-state-by-not-using-react-b73070b1ea4f?source=collection_archive---------11-----------------------#2022-08-08">https://betterprogramming.pub/4-ways-to-simplify-react-state-by-not-using-react-b73070b1ea4f?source=collection_archive---------11-----------------------#2022-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用原生浏览器实现简化应用程序状态？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcd0448c2fe5da4e053f9a77ba652554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H7bdKdfVQdC7QmOf.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管理应用程序状态的非反应式生命周期机制。</p></figure><p id="3811" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我告诉您，您不应该在React生命周期中存储所有数据，会怎么样？React中有许多使用内置浏览器API和非生命周期方法的工具，对于正确的用例来说非常强大。</p><p id="3cac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我想向您展示在React中简化状态而不需要“全局状态”工具的方法的系列文章的第二部分。查看<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/stop-using-global-state-6-ways-to-manage-state-in-react-c53ac9503e96">上一部分</a>中关于在React生命周期中存储状态的提示</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">存储类型</h1><p id="2953" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们将重点介绍React应用程序中存储和访问数据的四种机制:</p><ol class=""><li id="cde2" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">网络存储:本地存储、会话存储和Cookies</li><li id="940f" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">URL和路由器状态</li><li id="2fb8" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">React引用:React生命周期之外的状态</li><li id="3c75" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">浏览器存储</li></ol><p id="4b07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后还有奖金！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="66b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.网络存储</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/09e6024e3504fd9692dafb7a70bddb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mFkYhQExfqOIy9hVZSdaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在React应用程序中访问web存储。</p></figure><p id="60f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">利用本地存储、会话存储和cookies等本机浏览器机制是持久化和共享状态的最佳选择，因为它们可以跨所有现代浏览器工作，并且您不需要安装任何新的依赖项来使用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce69" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">局部存储器</h1><p id="11b3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对于给定的来源，本地存储跨浏览器会话持续存在— <em class="no">“来源”是主机名、协议和端口的组合。</em></p><p id="b7a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于其跨浏览器会话的持久性，当数据不需要存储在数据库中时，本地存储是跨页面呈现持久化数据的好方法。它可用于跟踪JWT认证令牌、通知是否已被打开等。</p><p id="e720" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它遵循键值格式，并且只支持字符串值。如果使用<code class="fe np nq nr ns b">JSON.stringify</code>或其他方式将数据字符串化，您仍然可以存储复杂的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7f61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于本地存储的更多信息:<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Window/local storage</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">会话存储</h1><p id="d499" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">会话存储与本地存储非常相似，主要区别在于它只在同一个浏览器会话中存在。它在同一会话的页面刷新中保持不变，但在不同会话(新选项卡、窗口)中保持不变。这种方法对于不太持久的存储很有用，例如跟踪用户会话的指标。</p><p id="86e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会话存储的API几乎与本地存储相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="16a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于会话<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank">存储</a>的更多信息</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">饼干</h1><p id="0b0d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Cookies是存储在客户端计算机上的文本文件中的数据。通常，它们用于维护无状态HTTP调用之间的有状态数据。例如，<a class="ae lu" href="https://owasp.org/www-community/attacks/csrf" rel="noopener ugc nofollow" target="_blank"> CSRF令牌</a>，登录信息，偏好，主题，语言等。服务器可以在HTTP响应中使用<code class="fe np nq nr ns b">Set-Cookie</code>指令来设置cookies。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7ffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浏览器可以使用<code class="fe np nq nr ns b">document.cookie</code>直接读写cookies。它看起来像一个字符串，但行为像一个getter/setter函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="81e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Cookies在现代水疗和Jamstack应用程序时代并不流行，但它们经过了实战检验，在正确的情况下非常有用。</p><p id="e9f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank"> cookies </a>的更多信息。</p><p id="a7d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="no">注意:为了遵守</em><a class="ae lu" href="https://www.privacyaffairs.com/gdpr-cookie-consent-violations/" rel="noopener ugc nofollow" target="_blank"><em class="no">GDPR</em></a><em class="no">的规定，您需要小心地将非必要的数据存储在cookies中，并首先征求您的用户的同意。</em> <a class="ae lu" href="https://www.cookieyes.com/cookie-consent-exemption-for-strictly-necessary-cookies/" rel="noopener ugc nofollow" target="_blank"> <em class="no">严格来说，网站运行所需的必要cookie</em></a><em class="no">都是豁免的——比如会话id、CSRF令牌等。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="227f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.URL和路由器状态</h1><p id="d2c6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">您可以在页面的URL中存储大量信息。当您希望您的用户与其他人共享URL时，这非常有用。URL可以知道每次打开相同链接时呈现应用程序的确切状态。这就是为什么当你试图将它们复制到一些应用程序中时，你会看到很长的URL。</p><ul class=""><li id="d396" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt nv nf ng nh bi translated">您可以通过在URL末尾添加一个<code class="fe np nq nr ns b">?</code>来以键值格式存储<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank"> URLSearchParams </a>。</li><li id="d296" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt nv nf ng nh bi translated">您可以通过使用<code class="fe np nq nr ns b">&amp;</code>分隔多个参数来包含它们。</li><li id="a602" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt nv nf ng nh bi translated">根据您的应用，您可能需要使用<code class="fe np nq nr ns b">encodeURIComponent()</code>和<code class="fe np nq nr ns b">decodeURIComponent()</code>来编码和解码参数，以处理特殊字符。</li><li id="4a8a" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt nv nf ng nh bi translated"><code class="fe np nq nr ns b"><a class="ae lu" href="https://www.npmjs.com/package/query-string" rel="noopener ugc nofollow" target="_blank">query-string</a></code>是一个有用的npm包，可以帮助管理搜索参数的复杂性。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5cf9ffb48bb84657ad634de17ebd626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s35KbKCZiMkFJUpN.png"/></div></div></figure><p id="7457" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe np nq nr ns b">react-router-dom</code>你还可以在应用程序中导航时传递状态。当一个页面需要知道前一个页面的一些信息，或者您想要用获取的数据预先填充它时，这是很有帮助的——比如当从一个列表页面导航到一个细节视图时。</p><p id="0358" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将状态作为常规的JavaScript对象传递给<code class="fe np nq nr ns b">history</code>，或者在使用<code class="fe np nq nr ns b">Link</code>时传递:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3eb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.反应参考</h1><p id="9aa6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Refs更适合访问DOM元素进行直接操作，比如编程聚焦:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="49ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，您也可以将数据存储在ref中，并在组件的渲染生命周期之外使用它。这意味着对它的更新不会触发重新渲染。</p><p id="7c20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="no">注意:在React之前，将一些数据直接存储在DOM元素的自定义属性中是很常见的——这在今天仍然是可能的。</em></p><p id="69aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Refs适用于跨渲染持久化的可变值，如跟踪点击计数、性能指标或间隔/超时id。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="927a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe np nq nr ns b">useRef</code>:<a class="ae lu" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#useref</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="74cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.浏览器存储</h1><p id="571d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这些并不特定于任何框架，对于大多数典型的用例来说可能更高级，但是它们为管理客户端的大型数据问题提供了非常强大的机制。以及对基于原生浏览器API的开发的潜在未来的一瞥。</p><h1 id="3067" class="mc md it bd me mf nw mh mi mj nx ml mm jz ny ka mo kc nz kd mq kf oa kg ms mt bi translated">索引b</h1><p id="7ce4" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Web存储是一种在React之外使用浏览器本机功能持久化状态的极好方式，但是它在可以存储的数据量方面受到限制。主要用例是用于少量的会话相关数据。</p><p id="3f74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IndexedDB也是一种原生浏览器功能，但旨在解决在客户端存储较大数据集的问题。它是一个事务数据库系统，类似于基于SQL的RDBMS——但是具有JavaScript对象的友好性，因为您只需一个<code class="fe np nq nr ns b">key</code>就可以存储和访问数据。它在所有现代浏览器中都可用。</p><p id="f237" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank">索引数据库</a>的更多信息</p><h1 id="185b" class="mc md it bd me mf nw mh mi mj nx ml mm jz ny ka mo kc nz kd mq kf oa kg ms mt bi translated">缓存存储</h1><p id="c2ab" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">CacheStorage是另一个本地浏览器API，用于存储和检索网络请求和响应。顾名思义，CacheStorage是缓存从后端服务获取的数据的绝佳选择。它在引擎盖下使用服务人员，并且可以在所有现代浏览器中使用。</p><p id="33ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" rel="noopener ugc nofollow" target="_blank">缓存存储的更多信息</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca20" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金！不要存储在客户端</h1><p id="0236" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们已经讨论了在浏览器中存储数据的机制，在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/stop-using-global-state-6-ways-to-manage-state-in-react-c53ac9503e96">第一部分</a>中，我们讨论了在React生命周期中存储数据的技巧。</p><p id="bd77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种解决方案都只是大局的一部分。我们的应用程序通常依赖数据库来存储跨浏览器会话的持久状态。数据库是事实的来源——那么为什么不把你所有的状态都存储在那里呢？</p><p id="1b18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在SPAs和现代浏览器出现之前，这是你存储web应用程序状态的方式。浏览器中的任何更改都将被发送回服务器，并保存在内存或数据库中。这极大地简化了客户端代码，使得页面加载速度更快，对用户的响应更快。</p><p id="aa69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，它需要为每一个变化生成HTML，所以当需要大量交互时，应用程序很快就开始感到笨拙。这就是SPAs和现代web技术的力量——在浏览器中高效地创建复杂的交互，而无需重新生成HTML。</p><p id="85bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，结合现代SPA模式，您仍然可以将客户端之外的状态存储在数据库中。事实上，如果您有流畅的API体验，这可能会极大地简化您的一些状态和数据需求。有许多工具和模式可以帮助您将客户端的一些复杂性转移回服务器端。像服务器端渲染或后端对前端(BFF)服务器这样的技术。</p><p id="0fbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GraphQL实现非常适合这种用例，因为它为您的客户端提供了一种使用查询语言查询和修改数据的方法，而无需每次都创建新的REST APIs。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e1a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="5896" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">状态管理是一个困难的问题——但是创建流畅的web应用程序以最好地服务于您的最终用户是至关重要的。始终对存储应用程序状态的方式和位置持批评态度。记住，没有什么是一成不变的。不断地重构和重新架构对软件项目的寿命是有益的。</p><p id="d1d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这有助于您更加批判性地思考如何在web应用程序中最好地存储数据。</p><p id="ba57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我很乐意收到你的来信。请在评论中告诉我你的想法。你在州政府遇到过什么样的挑战？你最喜欢的状态模式是什么？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d4ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="no">原载于</em><a class="ae lu" href="https://oskari.io/blog/stop-react-global-state-part-2" rel="noopener ugc nofollow" target="_blank"><em class="no">https://oskari . io</em></a><em class="no">。</em></p></div></div>    
</body>
</html>