<html>
<head>
<title>Blazor Life Cycle Events: Oversimplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blazor生命周期事件:过于简化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/blazor-life-cycle-events-oversimplified-4b8e1bd5fa4b?source=collection_archive---------1-----------------------#2022-10-12">https://betterprogramming.pub/blazor-life-cycle-events-oversimplified-4b8e1bd5fa4b?source=collection_archive---------1-----------------------#2022-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50ca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您了解不同类型的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90b1985a2dfdc73359e3333125b82bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cBCCtqcLJD7hqIC0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动创建者</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从razor组件激活的那一刻起，就有一系列基于组件不同状态的方法被调用。我们应该清楚地了解控制的流程。</p><p id="2d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将教你剃须刀组件的不同生命周期方法，以及何时调用什么。在这个组件生命周期中有八种方法。</p><p id="02d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从头开始，先了解Blazor页面的架构，然后学习各种同步和异步方法。</p><p id="2e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了razor页面的不同部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/a69299a965e9dc60f8ab9f2db1afe883.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*9xVMD6gIDN4lYiuClxr4iw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图Blazor组件示例</p></figure><p id="5cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些场景中，我们希望先运行C#代码，然后再呈现UI。所以我们在UI中绑定的对象会有数据。例如，<code class="fe lt lu lv lw b">List</code>将首先被四个条目填满，然后UI将知道<code class="fe lt lu lv lw b">DataGrid</code>中有四行。另一方面，有时我们希望先渲染UI，然后运行C#代码。</p><p id="1c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何实现这一切？这就是我们今天要学的内容。让我们从第一个状态开始。</p><h1 id="dc8f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">1.OnInitialized和OnInitializedAsync</h1><p id="8ad8" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这两个方法在组件呈现之前被调用，首先，我们进行服务调用来填充所有的对象，然后这些对象被绑定到屏幕上。</p><p id="8e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看实际情况。</p><p id="5c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe lt lu lv lw b">Parent</code>和一个<code class="fe lt lu lv lw b">Child</code>组件，并在<code class="fe lt lu lv lw b">Parent</code>中添加<code class="fe lt lu lv lw b">Child </code>组件的实例。请参考下图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d52877faa5c44ad0eeac28e60abe2e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*OgWMVdaUqcHhLh9rbfnrJA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:创建父组件和子组件</p></figure><p id="cc3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Parent</code>看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单1: Parent.razor</p></figure><p id="2f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Child</code>组件:我们将使用<code class="fe lt lu lv lw b">List&lt;string&gt;</code>来跟踪添加的事件数量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单2: Child.razor</p></figure><p id="8cf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你运行这个程序，你会注意到这一点。当应用程序启动时，首先调用这两个方法，顺序如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/6e3ec8cd1d56561cec594e245fe32f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SIfw8-TvI0pStDVyXKDCA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:清单1和2的输出</p></figure><h1 id="b06f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">2.OnParametersSet和OnParametersSetAsync</h1><p id="8d79" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这些方法由以下两个触发器调用:</p><ol class=""><li id="d49b" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">每次从父节点收到新参数时，这些方法都会被调用。</li><li id="6f16" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">同样，当组件第一次被加载时，这些方法在<code class="fe lt lu lv lw b">OnInitialized()</code>和<code class="fe lt lu lv lw b">OnInitializedAsync()</code>之后被调用。</li></ol><p id="b684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要看到这一点，我们需要对组件进行一些更改。</p><p id="6eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Parent</code>组件现在将发送一个名为“counter”的参数给<code class="fe lt lu lv lw b">child</code>组件，并负责更新这个计数器的值。我们可以通过点击按钮来实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3: Parent.razor</p></figure><p id="68ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在谈谈<code class="fe lt lu lv lw b">child</code>的成分。它将从<code class="fe lt lu lv lw b">Parent</code>接收参数，并在UI中显示该参数的值。这里我们将展示我们的两个方法，<code class="fe lt lu lv lw b"> OnParametersSet()</code>和<code class="fe lt lu lv lw b">OnParametersSetAsync()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单4: Child.razor</p></figure><p id="56a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，观察下面的一系列图像，注意流动。</p><p id="f82b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景一:应用首次运行，执行顺序如下:<code class="fe lt lu lv lw b">OnInitialized()</code>=&gt;<code class="fe lt lu lv lw b">OnInitializedAsync()</code>=&gt;<code class="fe lt lu lv lw b">OnParametersSet()</code>=&gt;<code class="fe lt lu lv lw b">OnParametersSetAsync()</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ec41102a66b662cb1e6efbc320e6e760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*ljgfILyTmx7JFZ3DCdFm6A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:组件初始化</p></figure><p id="99ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景2:点击一次<code class="fe lt lu lv lw b">Parent</code>组件上的按钮，向<code class="fe lt lu lv lw b">child</code>组件发送一个更新的<code class="fe lt lu lv lw b">counter-parameter</code>，你可以看到<code class="fe lt lu lv lw b">OnParametersSet()</code>和<code class="fe lt lu lv lw b">OnParametersSetAsync()</code>是如何被再次调用的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/66d8661cc683aa07bb37496bca5e85bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*F4CVle2IETXJIaehPpfUTQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:新参数从父组件发送到子组件</p></figure><p id="be33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景3:再次单击按钮，在<code class="fe lt lu lv lw b">child</code>组件中观察到相同的模式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a98f53244915efd2df5bacc7c993038e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*Cw2U2vQTV-sZWJTr6K2yXw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6:新参数从父组件发送到子组件</p></figure><h1 id="d09a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">3.OnAfterRender和OnAfterRenderAsync</h1><p id="6677" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这些方法在组件呈现后调用。稍后将详细介绍这一点！</p><p id="20ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您查看以下代码片段中显示的语法，您会看到这些方法有一个布尔参数<code class="fe lt lu lv lw b">firstRender</code>，如果组件是第一次呈现，则<code class="fe lt lu lv lw b">firstRender</code>的值为真。如果不是，那就是假的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单5: OnAfterRender和OnAfterRenderAsync</p></figure><p id="68d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的两张图片中，让我向您展示这两种方法的执行流程。图7显示了组件第一次呈现时的流程。它调用方法<code class="fe lt lu lv lw b">OnAfterRender()</code>和<code class="fe lt lu lv lw b">OnAfterRenderAsync()</code>两次。</p><p id="f2ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次，<code class="fe lt lu lv lw b">firstRender</code>的布尔值为真，然后这些方法被再次调用。这一次，<code class="fe lt lu lv lw b">firstRender</code>的值是假的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f1d18dbd30cbfee4d9aee742d8984d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*UuAcwIo-Ul-mgkddcTtmpA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图7:首次渲染的组件</p></figure><p id="01ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe lt lu lv lw b">child</code>组件从<code class="fe lt lu lv lw b">parent</code>收到新的更新并再次呈现自己，会发生什么？除了在<code class="fe lt lu lv lw b">OnInitialized()</code>和<code class="fe lt lu lv lw b">OnInitializedAsync()</code>方法上有变化外，遵循图7中的相同模式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ea5e4e7e700225b65334f6c874c2450f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*GvuMEg4EeeeDjr1GhidfZw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8:组件用新值重新呈现</p></figure><p id="927e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们深入了解我们实际上需要这些方法做什么。</p><p id="ed95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了回答这个问题，我必须对我们的代码做一些修改。我将把“<code class="fe lt lu lv lw b">counter-button</code>移动到带有<code class="fe lt lu lv lw b">OnclickHandler()</code>的<code class="fe lt lu lv lw b">child</code>组件中，然后是<code class="fe lt lu lv lw b">override OnAfterRender()</code>。此外，我将“计数器的值”记录到<code class="fe lt lu lv lw b">console-tab</code>中，以交叉验证<code class="fe lt lu lv lw b">counter</code>的当前值。下面是这些变化之后<code class="fe lt lu lv lw b">child</code>组件的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单6: Child.razor</p></figure><p id="abfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看代码清理后的<code class="fe lt lu lv lw b">parent</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单7: Parent.razor</p></figure><p id="5c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行应用程序，你会看到<code class="fe lt lu lv lw b">OnAfterRender</code>实际上是如何工作的。</p><p id="5f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图中，我第一次运行这个应用程序。正如您在Console选项卡中看到的，计数器的值已经通过<code class="fe lt lu lv lw b">OnAfterRender()</code>方法增加了，但是UI没有显示更新后的值。简单地说，<code class="fe lt lu lv lw b">OnAfterRender()</code>在用户界面呈现后执行代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c4232b0d3e8b7c97ab087c5e017ca842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*db6MI1Ai683MAMVeH7Jejw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图9:控制台中的值被更新，而UI上的值没有被更新</p></figure><p id="8481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我点击按钮会发生什么？它将再次呈现组件。</p><p id="9c39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe lt lu lv lw b">IncreaseCounter()</code>会被调用。这将计数器的值增加到<code class="fe lt lu lv lw b">2</code>，然后用值<code class="fe lt lu lv lw b">2</code>呈现UI，然后调用<code class="fe lt lu lv lw b">OnAfterRender</code>，但是UI不会再次呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/353a32dbb4435aa3093c06c3422ce6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*wSv_T3aZdX8cuvj49dIZrA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图10: OnAfterRender()方法增加了值，但是UI忽略了该更新</p></figure><p id="8312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了继续操作，我将再次单击该按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/66061203f4324090dd6000089ed233dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*jXhBJbmeOl63tmX6LXRmTA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图11: OnAfterRender()方法增加了值，但是UI忽略了该更新</p></figure><h1 id="47f5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">4.状态已经改变</h1><p id="53dd" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这个生命周期方法通知UI新值，并触发组件的重新呈现。</p><ul class=""><li id="f678" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nu ne nf ng bi translated">使用:如果您正在调用异步服务，并希望UI基于新值再次呈现，您可以使用此方法。简单地说，它通知组件<code class="fe lt lu lv lw b">State</code>已经改变，所以它将使用新值再次加载组件。</li></ul><p id="4513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们先来了解一下为什么需要<code class="fe lt lu lv lw b">StateHasChanged()</code>。</p><p id="4ed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了证明这一点，我们需要一个可以自我触发的东西。为此，我们可以简单地使用<code class="fe lt lu lv lw b">timer</code>。我们将运行<code class="fe lt lu lv lw b">timer</code>，直到计数器的值达到<code class="fe lt lu lv lw b">5</code>。每过一秒钟，我们就会将计数器的值增加<code class="fe lt lu lv lw b">1</code>。</p><p id="872f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景1:当我们不使用<code class="fe lt lu lv lw b">StateHasChanged()</code>时</p><ul class=""><li id="8e01" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nu ne nf ng bi translated">观察UI线程如何对计时器对计数器变量所做的任何更改保持不响应。</li></ul><p id="184b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:对<code class="fe lt lu lv lw b">child</code>组件进行如下修改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单8: Child.razor</p></figure><p id="207f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们启动应用程序，观察控制台中“计数器”的值与UI上“<code class="fe lt lu lv lw b">counter</code>”的值。UI没有重新呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/ccf9705ec77fd9da6abe242a0597b62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JXs__ltOlld3BnPAcbmpag.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gif 1: UI独立于StateHasChanged</p></figure><p id="42f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景2:当我们使用<code class="fe lt lu lv lw b">StateHasChanged()</code>时</p><p id="b9d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在只需在<code class="fe lt lu lv lw b">TimeCallBack()</code>中调用<code class="fe lt lu lv lw b">StateHasChanged()</code>。参考下面代码片段中的第6行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单8: Child.razor</p></figure><p id="1eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在看到区别了吧！UI正在重新呈现并显示计数器的增量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/dae05682b3c1e09019fb56642f621fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dJVcQVcM-c70EM7ouD9m-g.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gif 2:由于StateHasChanged，UI正在重新呈现</p></figure><h1 id="2b02" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">5.应该呈现</h1><p id="815e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">如果返回true，将强制刷新UI。如果没有，对象的更新状态将留在内存中，但是UI线程不知道新值是什么。</p><p id="96c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景1:当我们从<code class="fe lt lu lv lw b"> ShouldRender()</code>返回false时</p><ul class=""><li id="879a" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nu ne nf ng bi translated">让我们用同样的例子。这一次，覆盖<code class="fe lt lu lv lw b">child</code>组件中的<code class="fe lt lu lv lw b">ShouldRender()</code>，如下所示。您将看到它从该方法返回了<code class="fe lt lu lv lw b">false</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单9: Child.razor</p></figure><p id="5c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我运行这个应用程序，那么<code class="fe lt lu lv lw b">ShouldRender</code>方法将被调用，但是它将阻止UI被呈现，因为我们从该方法返回<code class="fe lt lu lv lw b">false</code>。观察控制台中的值是如何变化的，但是UI不受这些变化的影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/5a2a0ba86e0b463731c317a7fd080d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mvBxt5pXt7S113gc7vhdYw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gif 3: ShouldRender返回false</p></figure><p id="6438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景2:当我们从<code class="fe lt lu lv lw b">ShouldRender()</code>返回true时</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单10: Child.razor</p></figure><p id="0add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的执行流程将会遵循，但是这一次UI将呈现更新的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/49470723a218a32005c4d07bcf833198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2LtpAAqbbGen1t_Vx69r7Q.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gif 4: ShouldRender返回true</p></figure><h1 id="87a9" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="88ac" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">好吧，这是一篇很长的文章，但我相信它是有帮助的。现在我们知道Blazor中有哪些不同的生命周期方法，以及它们如何定义组件的状态。一旦你开始设计组件，你会对使用哪种生命周期方法以及何时使用有一个更清晰的理解。</p><p id="fa60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有几个我讨论过的话题。你可以合并到<a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor" rel="noopener ugc nofollow" target="_blank">炽焰Blazor </a>的仓库，学习以下主题。</p><ol class=""><li id="5422" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/1.%20Event%20Callback" rel="noopener ugc nofollow" target="_blank">事件回调</a></li><li id="945d" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/2.%20RenderFragment" rel="noopener ugc nofollow" target="_blank">渲染片段</a></li><li id="a76d" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/3.%20CSS%20Custom%20Properties" rel="noopener ugc nofollow" target="_blank"> CSS自定义属性</a></li><li id="1839" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/4.%20AttributeSplatting" rel="noopener ugc nofollow" target="_blank">属性设置</a></li><li id="7967" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/5.%20CascadingParameter" rel="noopener ugc nofollow" target="_blank">级联参数</a></li><li id="7c4b" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/RikamPalkar/Blazing-Blazor/tree/main/6.%20CascadingParameter%20with%20Name" rel="noopener ugc nofollow" target="_blank">名为</a>的级联参数</li></ol><p id="7c91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>