<html>
<head>
<title>Why I Quit Using the ObservableObject in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我在SwiftUI中停止使用ObservableObject</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-i-quit-using-the-observableobject-in-swiftui-11bc4b844ca0?source=collection_archive---------9-----------------------#2020-01-03">https://betterprogramming.pub/why-i-quit-using-the-observableobject-in-swiftui-11bc4b844ca0?source=collection_archive---------9-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b6b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它有一个致命的缺陷，对于Redux风格的状态管理尤其明显</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3ee05941966c5f7e3338d38b86bdece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C1gnA8t8vUWjRSn2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@kencheungphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张艺</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="18ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在WWDC 2019 <a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2019/226/" rel="noopener ugc nofollow" target="_blank">数据流直通SwiftUI </a>会议之后，“单一来源的真相”已经成为iOS社区的流行语。</p><p id="8a5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI framework旨在鼓励以单一来源的风格构建应用程序，但这并不意味着整个应用程序必须只有一个中央状态，实际上你可以<a class="ae kv" href="https://medium.com/better-programming/swiftui-microservices-c7002228710" rel="noopener">将其分解</a>。</p><p id="4780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在任何情况下，您都很可能最终使用<code class="fe ls lt lu lv b">@ObservedObject</code>或<code class="fe ls lt lu lv b">@EnvironmentObject</code>来管理视图的状态。</p><p id="3a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是问题所在。</p><p id="92fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我研究SwiftUI在高负载下的表现时，我发现状态更新上订阅的视图越多，SwiftUI刷新的性能就会显著下降:</p><div class="lw lx gp gr ly lz"><a href="https://nalexn.github.io/anyview-vs-group/?utm_source=medium_flawless" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">性能之战:AnyView vs Group</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">我最近收到了一位iOS工程师关于我用SwiftUI编写的开源项目的问题。他分享了…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">nalexn.github.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div><p id="7524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能在屏幕上有几千个视图，但只有一个被订阅——更新会以闪电般的速度呈现，即使是层次结构深处的视图。</p><p id="8caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在同一个更新上只订阅几百个视图就足够了，并且只有一个视图受到实际影响——您会注意到性能显著下降。</p><p id="c855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着如果我们基于一个类似Redux的集中式状态构建一个大型SwiftUI应用程序，我们很可能会遇到大麻烦！</p><h1 id="0fe0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">在EquatableView中包装每个视图</h1><p id="5bc3" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">乍一看，<code class="fe ls lt lu lv b">EquatableView</code>似乎是解决这个问题的最佳人选。</p><p id="1f66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它允许为视图编写定制的区分策略，特别是比较状态而不是比较<code class="fe ls lt lu lv b">body</code>。</p><p id="1f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，即使<code class="fe ls lt lu lv b">EquatableView</code>的<a class="ae kv" href="https://swiftui-lab.com/equatableview/" rel="noopener ugc nofollow" target="_blank">神秘的未记录行为</a>在未来的某一天得到解决，我们仍然无法比较引用变异状态对象的视图，例如<code class="fe ls lt lu lv b">EnvironmentObject</code>或<code class="fe ls lt lu lv b">ObservedObject</code>。</p><p id="022d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我来解释一下原因。考虑这个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ad48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们选择不采用默认的SwiftUI区分策略，而是遵从<code class="fe ls lt lu lv b">Equatable</code>:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="96a0" class="nr mp iq lv b gy ns nt l nu nv">extension CustomView: Equatable {<br/>    static func == (lhs: Self, rhs: Self) -&gt; Bool {<br/>        return lhs.appState.value == rhs.appState.value<br/>    }<br/>}</span></pre><p id="6c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…并在<code class="fe ls lt lu lv b">EquatableView</code>中包装视图:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="9c73" class="nr mp iq lv b gy ns nt l nu nv">CustomView().equatable().environmentObject(AppState())</span></pre><p id="7b22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一切都应该是好的，对不对？</p><p id="4640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行代码，您会发现事情变得更糟:现在视图冻结在初始状态，再也不会重绘。</p><p id="b229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是怎么回事？</p><p id="4efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<code class="fe ls lt lu lv b">lhs</code>和<code class="fe ls lt lu lv b">rhs</code>是<code class="fe ls lt lu lv b">CustomView</code>结构的两个不同实例，但是两个副本都引用同一个共享对象。</p><p id="7d8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe ls lt lu lv b">AppState</code>是一个<a class="ae kv" href="https://developer.apple.com/swift/blog/?id=10" rel="noopener ugc nofollow" target="_blank">引用类型</a>，SwiftUI不会在突变时复制它，所以您基本上是在将对象实例与其自身进行比较。</p><p id="4be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">==</code> func总是返回<code class="fe ls lt lu lv b">true</code>，告诉SwiftUI我们的视图不需要重新计算。从来没有。</p><h1 id="ff6e" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">为视图中的状态拍摄快照</h1><p id="5fde" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">好吧，既然我们不能依赖于比较对<code class="fe ls lt lu lv b">ObservableObjects</code>的引用，那么当它接收到一个更新时，在视图中存储先前状态的快照怎么样？</p><p id="b3ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大概是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d32e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">==</code>函数中，我们将<code class="fe ls lt lu lv b">prevValue</code>与更新后的<code class="fe ls lt lu lv b">appState.value</code>进行比较，因此这应该可以正常工作...</p><p id="c9a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但事实并非如此。原因是——这根本无法编译。<code class="fe ls lt lu lv b">body</code>是不可变的，所以我们不允许在其中设置<code class="fe ls lt lu lv b">prevValue</code>。</p><p id="b7d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题有一个解决方法——我们可以创建一个引用类型包装器来存储<code class="fe ls lt lu lv b">prevValue</code>，但是这一切开始变得非常麻烦和糟糕。除此之外，<code class="fe ls lt lu lv b">==</code> func并不总是被称为<a class="ae kv" href="https://swiftui-lab.com/equatableview/" rel="noopener ugc nofollow" target="_blank">，这使得这种方法毫无价值。</a></p><p id="808d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来点更优雅的怎么样？</p><h1 id="41d0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">过滤状态更新</h1><p id="7a96" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在SwiftUI和Combine框架发布之前，我有机会在一个大规模的UIKit应用程序上尝试Redux状态管理，并且<a class="ae kv" href="https://github.com/ReSwift/ReSwift" rel="noopener ugc nofollow" target="_blank">RES swift</a>和<a class="ae kv" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>的组合工作得非常好。</p><p id="a770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大量状态更新的问题不是很明显，但是我仍然在管道中使用更新过滤来减少负载:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="c038" class="nr mp iq lv b gy ns nt l nu nv">BehaviorRelay(value: AppState()) // produces all state updates<br/>    .map { $0.value1 } // removing all unused state values<br/>    .distinctUntilChanged() // remove duplicated "value1"<br/>    .bind(to: ...)</span></pre><p id="edfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个函数<code class="fe ls lt lu lv b">distinctUntilChanged</code>是RxSwift(在ReactiveSwift中称为<code class="fe ls lt lu lv b">skipRepeats</code>,在Combine中称为<code class="fe ls lt lu lv b">removeDuplicates</code>),当特定视图中使用的值都没有改变时，该函数允许丢弃不必要的更新事件。</p><p id="3ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法也适用于SwiftUI，但是由<code class="fe ls lt lu lv b">@State</code>、<code class="fe ls lt lu lv b">@ObservedObject</code>和<code class="fe ls lt lu lv b">@EnvironmentObject</code>生成的数据绑定没有这种过滤功能。</p><p id="edac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，令人惊讶的是来自Combine的<code class="fe ls lt lu lv b">Publisher</code>与来自SwiftUI的<code class="fe ls lt lu lv b">Binding</code>不兼容，而且有几种奇怪的方式将它们连接起来。</p><h1 id="3a73" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">在ObservableObject中包装ObservableObject</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a097387d34e2aab31bcbd08f2ea92a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yT7oxFVqqLPBxpxYqCU2pQ.png"/></div></figure><p id="33fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想坚持使用<code class="fe ls lt lu lv b">ObservableObject</code>，实际上没有办法跳过来自内部<code class="fe ls lt lu lv b">objectWillChange</code>发布者的事件，因为SwiftUI直接订阅它。</p><p id="0491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以做的是将<code class="fe ls lt lu lv b">ObservableObject</code>包裹在另一个<code class="fe ls lt lu lv b">ObservableObject</code>中，后者在引擎盖下进行过滤。</p><p id="201d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使这个包装器具有通用性和高度可重用性。<code class="fe ls lt lu lv b">@dynamicMemberLookup</code>属性允许客户端代码与包装器交互，就像与真正的对象交互一样。</p><p id="090a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在Github <a class="ae kv" href="https://gist.github.com/nalexn/ace9ddd07db5a6e150163712e20c6235" rel="noopener ugc nofollow" target="_blank"> gist </a>上找到<code class="fe ls lt lu lv b">Deduplicated</code>的实现，不过这里是概念部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="af09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它正在观察原始对象的<code class="fe ls lt lu lv b">objectWillChange</code>,通过仅包含特定视图中使用的值来拍摄<code class="fe ls lt lu lv b">AppState</code>的快照，然后移除重复的值。最后，如果快照与前一个不同，它会触发视图使用的包装器对象上的<code class="fe ls lt lu lv b">objectWillChange</code>。</p><p id="6188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在消费者方面，我们有:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…可以通过以下方式返工:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！现在<code class="fe ls lt lu lv b">AppState</code>可以生成大量的更新，但是只有包含不同<code class="fe ls lt lu lv b">.value</code>的更新才会被转发给视图。</p><p id="afa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我应该指出这种方法的两个缺点:</p><ol class=""><li id="9d7e" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr oc od oe of bi translated">由于<code class="fe ls lt lu lv b">.delay</code>调用，状态更新被异步传递。这可能是众多与比赛条件相关的错误的入口，但我们不在UIKit中。如果另一个更新突然出现，视图将重新计算两次，并最终反映最近的状态值。</li><li id="bf29" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">对于使用<code class="fe ls lt lu lv b">Deduplicated</code>作为<code class="fe ls lt lu lv b">@EnvironmentObject</code>的每个屏幕来说，<code class="fe ls lt lu lv b">Snapshot</code>类型必须是唯一的。这是必需的，因为否则在用<code class="fe ls lt lu lv b">.environmentObject(_:)</code>修改器注入多个对象时可能会有冲突。</li></ol><h1 id="fd01" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">使用Publisher而不是ObservableObject</h1><p id="d184" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">你知道吗，我受够了<code class="fe ls lt lu lv b">ObservableObject</code>！</p><p id="ec76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说真的，当前可用的<code class="fe ls lt lu lv b">Binding</code>API完全不能控制值流。</p><p id="e556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您经常需要在it和来自Combine的发布者之间搭建桥梁，这些发布者通常用于网络和其他异步业务逻辑。</p><p id="1ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我看不到任何用例在处理集中式应用程序状态时，<code class="fe ls lt lu lv b">@ObservedObject</code>或<code class="fe ls lt lu lv b">@EnvironmentObject</code>会超过我将要提出的解决方案。</p><p id="1817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="802d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法有很多好处:</p><ol class=""><li id="85c1" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr oc od oe of bi translated">我们不仅过滤更新，还限制对本地<code class="fe ls lt lu lv b">ViewState</code>结构中定义的值的访问。</li><li id="eeec" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">我们仍然受益于使用原生依赖注入，使用<code class="fe ls lt lu lv b">@Environment</code>而不是<code class="fe ls lt lu lv b">@EnvironmentObject</code>。</li><li id="7b79" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">相同的<code class="fe ls lt lu lv b">injected</code>容器可以扩展用于注入服务。</li><li id="697d" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">更新是同步交付的。</li><li id="d8b9" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">代码比以前更加简洁明了。</li><li id="4bf2" class="nx ny iq ky b kz og lc oh lf oi lj oj ln ok lr oc od oe of bi translated">易于扩展。添加新视图时，不需要更新根依赖注入。</li></ol><p id="d92b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了用完整的代码来完成这个例子，这里是<code class="fe ls lt lu lv b">AppState</code>及其注入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="647e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试了几种方法来实现从标准SwiftUI视图到<code class="fe ls lt lu lv b">AppState</code>的反向数据流。最终运行良好的一个是将提交给SwiftUI视图的<code class="fe ls lt lu lv b">Binding</code>封装到中间件中，该中间件将值转发给<code class="fe ls lt lu lv b">AppState</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bcbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一些方法可以从语法上改进整个解决方案(最明显的是通过使用<code class="fe ls lt lu lv b">keyPaths</code>)，但是从概念上来说，它是<code class="fe ls lt lu lv b">@EnvironmentObject</code>和<code class="fe ls lt lu lv b">@ObservedObject</code>的更好的选择。</p><p id="da45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于后者，你将注入<code class="fe ls lt lu lv b">CurrentValueSubject</code>作为视图的<code class="fe ls lt lu lv b">init</code>参数，代替对象。</p><p id="8d7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经为SwiftUI 示例项目迁移了我的<a class="ae kv" href="https://github.com/nalexn/clean-architecture-swiftui" rel="noopener ugc nofollow" target="_blank"> Clean Architecture以使用这种方法，并更新了我的</a><a class="ae kv" href="https://github.com/nalexn/ViewInspector" rel="noopener ugc nofollow" target="_blank"> SwiftUI单元测试</a>框架以更好地支持它。</p><p id="7e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://twitter.com/nallexn" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，关注即将发布的帖子！</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="c036" class="nr mp iq lv b gy ns nt l nu nv"><strong class="lv ir">Want to Stay Updated With My Latest Articles?</strong></span><span id="3663" class="nr mp iq lv b gy os nt l nu nv">Here’s the <a class="ae kv" href="https://nalexn.github.io/feed.xml" rel="noopener ugc nofollow" target="_blank">RSS</a> of my blog.</span></pre></div></div>    
</body>
</html>