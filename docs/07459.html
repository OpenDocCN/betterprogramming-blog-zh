<html>
<head>
<title>Is Protocol-Oriented Programming in TypeScript Possible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中面向协议的编程可能吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/protocol-oriented-programming-in-typescript-really-e4389cdc7842?source=collection_archive---------1-----------------------#2021-01-16">https://betterprogramming.pub/protocol-oriented-programming-in-typescript-really-e4389cdc7842?source=collection_archive---------1-----------------------#2021-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3aac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的TypeScript代码库中采用这种流行的Swift范例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/132aa6c5b3a6d8fd7add94e7a9190087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Go0OUHfyqy7sPDh-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c690" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">面向协议的编程是Swift中一种常见的抽象方法</h1><p id="8716" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">面向协议的编程是许多Swift程序员用来构建源代码的实践。这是帮助程序员将现实世界的概念建模为软件开发的计算对象的一种常见的抽象方法。既然抽象是面向对象编程中的一个概念，那么其他编程语言是否也有类似的特点呢？</p><p id="3f8b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在直接得出结论之前，让我们先看看是否可以在TypeScript中实现一个通用的<code class="fe mw mx my mz b">print()</code>函数来输出，就像Swift中的<code class="fe mw mx my mz b">CustomStringConvertible</code>协议一样。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c624" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">TypeScript接口定义了对象的形状</h1><p id="f27f" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><code class="fe mw mx my mz b">Interface</code>是一个关键字，可以用TypeScript对计算对象建模。首先，让我们定义两个接口(<code class="fe mw mx my mz b">ICustomStringConvertible</code>和<code class="fe mw mx my mz b">ICustomDebugStringPrintable</code>)，就像Swift中的协议声明一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="528c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">上面的声明是告诉编译器，新增了两种带属性的接口(<code class="fe mw mx my mz b">description</code>和<code class="fe mw mx my mz b">debugDescription</code>)。然后，构造<code class="fe mw mx my mz b">print()</code>和<code class="fe mw mx my mz b">debugPrint()</code>来打印由<code class="fe mw mx my mz b">ICustomStringConvertible</code>和<code class="fe mw mx my mz b">ICustomDebugStringConvertible</code>接口形成的任何类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e57c" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">抽象类定义了对象的类型</h1><p id="c364" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">以上实现之后，下一步就是设计一个符合<code class="fe mw mx my mz b">ICustomStringConvertible</code>和<code class="fe mw mx my mz b">ICustomDebugStringConvertible</code>的抽象类。任何从某个抽象类继承的类都意味着这些类基于共享的特征，并被归类到具有相同方法和属性的同一类型中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="11a6" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">从抽象对象创建一个新类</h1><p id="908f" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">现在，是时候把接口、泛型和抽象类放在一起了。新类别<code class="fe mw mx my mz b">AnObject</code>可创建如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6d2e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在让我们回到最初的目标:在TypeScript中为输出实现一个通用的<code class="fe mw mx my mz b">print()</code>函数，就像Swift中的<code class="fe mw mx my mz b">CustomStringConvertible</code>协议一样。让我们编写一些代码来检查结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7bfe" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">最后的想法</h1><p id="7279" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">面向协议的编程可能不是描述过去TypeScript中接口的最佳短语。然而，TypeScript和Swift在抽象哲学上确实有一些相似之处。作为敏捷的程序员，采用TypeScript的学习曲线可能会更平滑，因为编码风格和经验可以互换。此外，抽象实现也非常有助于形成我们对面向对象编程的理解。</p></div></div>    
</body>
</html>