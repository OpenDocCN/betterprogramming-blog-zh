<html>
<head>
<title>Using Decorators to Instrument Python Code With OpenTelemetry Traces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Decorators通过OpenTelemetry Traces检测Python代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-decorators-to-instrument-python-code-with-opentelemetry-traces-d7f1c7d6f632?source=collection_archive---------7-----------------------#2022-06-07">https://betterprogramming.pub/using-decorators-to-instrument-python-code-with-opentelemetry-traces-d7f1c7d6f632?source=collection_archive---------7-----------------------#2022-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6018" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python decorators可以帮助OpenTelemetry跟踪工具保持干燥</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a636efbd71c5fda7e15a0556db8d054a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9J46JcrAkp3m2OhuuWXWEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ba51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上周，我写了一篇<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/using-the-decorator-pattern-to-auto-instrument-net-classes-with-otel-tracing-781bf2be62ff">帖子</a>，主题是使用装饰设计模式来帮助删除一些设置跟踪所需的样板文件。我的示例代码使用了。NET，这需要一些繁重的工作，使用DispatchProxy类来拦截方法调用并注入跟踪逻辑。然而，Python通过对函数装饰器的内置支持，使我们的生活变得更加轻松。</p><h1 id="ffb1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么要使用跟踪装饰器？</h1><p id="0474" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">OpenTelemetry tracing太棒了！它允许在代码中定义称为“跨度”的特定段，并在运行时跟踪它们的执行和依赖性。然而，为了使信息可用，在检测代码时确实需要大量的训练。基本上，对于每个类/模块/函数，您需要添加如下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4b81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了重复和在任何地方强制添加<code class="fe mr ms mt mu b">tracer.start_as_current_span</code>调用的需要之外，为spans提出正确的命名约定，并确保它们具有惟一的名称和粒度级别，对于大型代码库来说是相当具有挑战性的。</p><p id="2867" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果不用上面的代码，我们能够编写如下代码，那就太好了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7a37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这种方式，整个类可以被自动检测，并且添加的Span属性已经被注入。命名可以通过约定(例如，函数名)来分配，如果需要，可以通过一种简单的方式来改变约定。</p><p id="583f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章的全部源代码可以在<a class="ae lr" href="https://github.com/digma-ai/opentelemetry-instrumentation-digma/blob/main/src/opentelemetry/instrumentation/digma/trace_decorator.py" rel="noopener ugc nofollow" target="_blank">这个库</a>上找到。它也可以作为一个包含装饰器实现的<a class="ae lr" href="https://pypi.org/project/opentelemetry-instrumentation-digma/" rel="noopener ugc nofollow" target="_blank"> pypi包</a>获得，如果你想马上使用它的话。</p><h1 id="051e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用Python装饰器实现基本的跟踪装饰器</h1><p id="b762" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Python decorators真的很整洁。如果你正在寻找关于如何使用它们的更全面的文档，我推荐<a class="ae lr" href="https://realpython.com/primer-on-python-decorators/#author" rel="noopener ugc nofollow" target="_blank"> Geir Arne Hjelle </a>的关于Python Decorators 的帖子<a class="ae lr" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank"> Primer，它很好地涵盖了这个主题。</a></p><p id="7aab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将创建一个简单的装饰器，它可以被添加到一个函数中，以便自动检测它。这将消除添加跟踪样板代码的需要，并照顾到span的默认命名约定(我们将在后面概括)。Python中的实现非常简单，包括返回用于执行修饰函数的包装函数。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bcb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，在这个阶段，我们所做的就是返回包装函数<code class="fe mr ms mt mu b">wrap_with_span</code>,它将被解释器作为函数装饰器使用。我们使用了<code class="fe mr ms mt mu b">functools.wraps()</code>装饰器(第12行),它确保包装器函数与原始函数具有相同的名称和元数据，使得装饰器对函数调用方透明。</p><p id="984b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mr ms mt mu b">wrap_with_span</code>函数将自动创建和命名一个跨度，并设置其属性。默认情况下，我们基于函数名来命名span，但是我们可以围绕它创建可扩展性。例如，这个静态类可以让开发人员用其他实现替换默认命名约定:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="169d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还提供了一个<code class="fe mr ms mt mu b">span_name</code>参数，开发者可以根据需要使用它来设置一个定制的span名称。</p><h1 id="a450" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试代码</h1><p id="6d37" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们添加一个测试来检查我们的新装饰器是否正常工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ada0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们设置了OTEL以便跟踪操作生效，然后验证在应用了新装饰器的测试方法中，我们有一个活动的跟踪跨度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/ef6f0f415ae3c50a7720f34dba34a0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qipc8jrNoUJWd_RQcT3ZXg.png"/></div></div></figure><p id="b224" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">成功！<code class="fe mr ms mt mu b">TracingDecorator</code>的第一次迭代已经完成。</p><h1 id="d30f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">检测整个类</h1><p id="4e70" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在函数到函数的基础上添加装饰器也可能变得有点乏味和重复。为了帮助解决这个问题，我们可以修改decorator来迭代类中的每个函数并修饰它，暂时忽略私有函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fcaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们选择不为类创建一个新的单独的装饰器，而是重载我们用于函数的同一个装饰器。为此，我们添加了一个检查来测试传递的参数是函数还是类(第14，19行)，并相应地应用正确的逻辑。</p><p id="d2f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于类，我们迭代类函数并注入装饰器，返回不变的类对象。</p><p id="2eb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于函数，我们遵循与前面相同的逻辑来应用包装器。</p><p id="a322" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这些代码，我们现在可以重写原始代码来利用新的装饰器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="3a09" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">*几乎*工作</h1><p id="b4e8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">请注意，我们仍然有一个小问题。上例中的<code class="fe mr ms mt mu b">validate</code>函数将应用两个装饰器。结果，将创建两个跨度而不是一个，这不是我们想要的行为。</p><p id="e3db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了处理这种情况，修饰器代码必须对函数是否已经被修饰有一些“记忆”。有几种方法可以做到这一点，在我们的实现中，我们选择将该信息保存在函数元数据中。因此，我们在修饰函数之前检查它是否已经被修饰过:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7700" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果函数已经被修饰过，我们就原样返回它。</p><h1 id="7e9f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">你还有什么要补充的？</h1><p id="54ad" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">您可以在<a class="ae lr" href="https://github.com/digma-ai/opentelemetry-instrumentation-digma" rel="noopener ugc nofollow" target="_blank"> Digma OpenTelemetry资源库</a>中找到完整的源代码。让我看看这是否对你的项目有用！此外，如果有任何你觉得有用的功能，请随时联系或打开GitHub上的问题或PR。</p><p id="4758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你对OTEL和可观察性感兴趣，我已经写了另一篇关于这个主题的文章，特别是关于如何在开发中利用OTEL，你可以在这里找到<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/improving-code-design-with-opentelemetry-a-practical-guide-a08e6440c24d"/>。</p><pre class="kg kh ki kj gt mw mu mx my aw mz bi"><span id="64fe" class="na lt iq mu b gy nb nc l nd ne"><strong class="mu ir">Want to Connect?</strong></span><span id="fcd6" class="na lt iq mu b gy nf nc l nd ne">You can reach me, Roni Dover, on Twitter at @doppleware.</span><span id="c541" class="na lt iq mu b gy nf nc l nd ne">Follow my open source project for continuous feedback at <a class="ae lr" href="https://github.com/digma-ai/digma" rel="noopener ugc nofollow" target="_blank">https://github.com/digma-ai/digma</a>.</span></pre></div></div>    
</body>
</html>