<html>
<head>
<title>Building Better Next.js Static Sites With MDX and Contentlayer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MDX和Contentlayer构建更好的Next.js静态站点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-better-next-js-static-sites-with-mdx-and-contentlayer-9a06ca84e7f7?source=collection_archive---------4-----------------------#2022-02-07">https://betterprogramming.pub/building-better-next-js-static-sites-with-mdx-and-contentlayer-9a06ca84e7f7?source=collection_archive---------4-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afa6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用MDX和Contentlayer发布静态内容变得如此轻松。我会告诉你怎么做</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8a11c385801ab22dafa9c10f9504def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKsmZ5Gm1pVevGuVVyZilw.png"/></div></div></figure><h1 id="cfec" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="e937" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">💨Contentlayer减少了在我的静态网站上发布内容的很多摩擦。</li><li id="be78" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">😍带有remark和rehype插件的MDX非常方便和强大。</li><li id="dc65" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">🍵Next.js与Contentlayer和MDX结合得非常好</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="ff51" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我完全接受了我的网站的静态站点生成(SSG)，以优化网站速度和未来的扩展。</p><p id="adff" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">最近我一直在研究如何减少在我的网站上写一篇新文章的工作量。在我的<a class="ae nf" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>项目设置中有许多接触点，以便:</p><ul class=""><li id="9562" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated">发表一篇新文章</li><li id="bcbd" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">估计阅读时间</li><li id="46cb" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">更新<a class="ae nf" href="https://dawchihliou.github.io/articles" rel="noopener ugc nofollow" target="_blank">文章列表</a></li><li id="b479" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">创建新的RSS源</li><li id="3e2c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">更新网站地图</li></ul><h1 id="233e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">出了什么问题？</h1><p id="f8c9" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">我又分析了一下，发现摩擦出在我的MDX使用上。我的文件结构是这样的:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f7c4" class="nr kv it nn b gy ns nt l nu nv">my-blog<br/>├── public<br/>├── data<br/>│   └── blogs.json<br/>├── components<br/>│   └── Blog.tsx<br/>└── pages<br/>    ├── blogs<br/>    │   ├── blog-one.mdx<br/>    │   ├── blog-two.mdx<br/>    │   └── blog-three.mdx<br/>    └── index.tsx</span></pre><p id="175d" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">是Next.js推荐的<a class="ae nf" href="https://nextjs.org/docs/advanced-features/using-mdx" rel="noopener ugc nofollow" target="_blank">标准设置</a>，我当时是用<a class="ae nf" href="https://github.com/mdx-js/mdx/tree/main/packages/loader" rel="noopener ugc nofollow" target="_blank"> @mdx-js/loader </a>和<a class="ae nf" href="https://www.npmjs.com/package/@next/mdx" rel="noopener ugc nofollow" target="_blank"> @next/mdx </a>把mdx转换成页面。</p><p id="73a0" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">以<code class="fe nw nx ny nn b">pages/blogs/blog-one.mdx</code>为例，内容是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated"><code class="fe nw nx ny nn b">pages/blogs/blog-one.mdx</code></p></figure><p id="00a3" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><code class="fe nw nx ny nn b">blog-one.mdx</code>命名——导出了一个元数据。它被负责布局和呈现元数据的默认组件选中。</p><p id="5309" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><code class="fe nw nx ny nn b">&lt;Blog /&gt;</code>组件看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">components/Blog.tsx</p></figure><p id="d890" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我将MDX文件视为页面。</p><p id="524a" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">因为每个MDX文件中的<code class="fe nw nx ny nn b">meta</code>数据被捕获在页面中，所以我复制了所有的元数据，并在<code class="fe nw nx ny nn b">data/blogs.json</code>中聚合它们。我用它来维护我的网站上的文章列表、RSS提要和用于SEO的站点地图。</p><blockquote class="of og oh"><p id="996d" class="mq mr oi lo b lp ms ju mt lr mu jx mv oj mw mx my ok mz na nb ol nc nd ne lz im bi translated">如果我能将MDX文件视为数据，并根据数据生成页面，那就更好了。</p></blockquote><p id="7407" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">这样，我可以同时将MDX文件用作数据点和页面内容。理想情况下，发表一篇新文章会更加顺畅。</p><p id="1c78" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我偶然看到<a class="ae nf" href="https://leerob.io/" rel="noopener ugc nofollow" target="_blank">李·罗宾逊的网站</a>，发现他正在使用一个名为<a class="ae nf" href="https://github.com/contentlayerdev/contentlayer" rel="noopener ugc nofollow" target="_blank"> Contentlayer </a>的alpha库来解决这个问题。</p><h1 id="e5c4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是内容层</h1><p id="6a38" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated"><a class="ae nf" href="https://github.com/contentlayerdev/contentlayer" rel="noopener ugc nofollow" target="_blank"> Contentlayer </a>是一个处于早期阶段的库，它将内容转化为数据。它大致是这样工作的:</p><ul class=""><li id="dece" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated">它接受YAML、JSON、MDX或Markdown中的headless CMS或本地内容作为源代码。</li><li id="838c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">它将内容转换成JSON中的TypeScript类型和数据文件，包括原始内容、元数据和我们指定的任何派生数据。</li><li id="400b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">它聚合JSON中的所有数据，并将它们导出为<a class="ae nf" href="https://nodejs.org/api/esm.html#modules-ecmascript-modules" rel="noopener ugc nofollow" target="_blank"> ESM </a>。</li></ul><p id="a3c6" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">对于我的用例，我可以使用Contentlayer生成的聚合数据来取代我以前的手动流程:</p><ul class=""><li id="fef7" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated">我使用生成的数据来构建文章的新页面。</li><li id="6281" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">我使用生成的数据来呈现文章列表。</li><li id="ebe0" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">我使用生成的数据创建一个新的RSS提要。</li><li id="4a30" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">我使用新的文件结构来生成新的站点地图。</li><li id="70ed" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">全自动！</li></ul><p id="7ed8" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">Contentlayer提供了与Next.js的简单集成。我将在接下来的部分中向您展示如何集成。</p><h1 id="89a4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用MDX作为数据</h1><p id="d80b" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">我们先来探讨一下如何使用MDX作为数据点。</p><p id="088d" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">MDX为YAML frontmatter提供了自定义解析器的支持。您可以这样表达元数据:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4c40" class="nr kv it nn b gy ns nt l nu nv">---<br/>title: 'Blog One🚀'<br/>publishedAt: 'February 4, 2022'<br/>description: 'Learn how to build a Next.js blog with MDX and Contentlayer!'<br/>cover: '/optimized/articles/blog-one/hero.webp'<br/>---</span><span id="30e8" class="nr kv it nn b gy om nt l nu nv">Hey There👋</span><span id="ab28" class="nr kv it nn b gy om nt l nu nv">Welcome to Blog One✨ Let's learn together!</span></pre><p id="b9a3" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">您可以看到，YAML语法中的元数据在<code class="fe nw nx ny nn b">---</code>块中，内容主体遵循MDX语法。与将MDX文件视为页面的<a class="ae nf" href="https://dawchihliou.github.io/#what-was-the-problem" rel="noopener ugc nofollow" target="_blank">旧设置</a>相比，新的MDX文件仅包含元数据和内容。</p><p id="dc3e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我们需要做的下一件事是生成博客页面，该页面使用来自<code class="fe nw nx ny nn b">&lt;Blog /&gt;</code>组件的布局呈现元数据和内容。</p><h1 id="a725" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">在Next.js中集成Contentlayer</h1><p id="f6e3" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">现在我们已经更新了MDX文件，只包含数据和内容，让我们把它们移到<code class="fe nw nx ny nn b">data</code>目录中。</p><p id="d244" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">新的文件结构如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a62a" class="nr kv it nn b gy ns nt l nu nv">my-blog<br/>├── public<br/>├── components<br/>│   └── Blog.tsx<br/>├── pages<br/>│   ├── blogs<br/>│   │   └── [slug].tsx<br/>│   └── index.tsx<br/>└── data<br/>    └──blogs<br/>       ├── blog-one.mdx<br/>       ├── blog-two.mdx<br/>       └── blog-three.mdx</span></pre><p id="7e8c" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">注意，我们用一个<a class="ae nf" href="https://nextjs.org/docs/routing/dynamic-routes" rel="noopener ugc nofollow" target="_blank">动态路由</a> <code class="fe nw nx ny nn b">[slug].tsx</code>替换了<code class="fe nw nx ny nn b">pages/blogs</code>目录中的MDX文件。稍后我们将使用这个页面静态生成博客页面。</p><h1 id="f50a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">配置内容层</h1><p id="64d3" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">Contentlayer提供了与Next.js的无缝集成。</p><p id="79b7" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">要安装依赖项，请执行以下操作:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="80a1" class="nr kv it nn b gy ns nt l nu nv">yarn add contentlayer next-contentlayer</span></pre><p id="f33d" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">Contentlayer从<code class="fe nw nx ny nn b">contentlayer.config.ts</code>读取配置。让我们创建一个。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="74e4" class="nr kv it nn b gy ns nt l nu nv">touch contentlayer.config.ts</span></pre><p id="0d6d" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在<code class="fe nw nx ny nn b">contentlayer.config.ts</code>中，我们需要添加指令来告诉Contentlayer如何解析:</p><ul class=""><li id="66da" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated"><code class="fe nw nx ny nn b">name</code>:名称空间</li><li id="a0b9" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b">filePathPattern</code>:输入文件</li><li id="fb59" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b">bodyType</code>:解析的内容体类型</li><li id="6535" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b">fields</code>:元数据字段</li><li id="64cd" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b">computedFields</code>:派生元数据字段</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">内容层. config.ts</p></figure><p id="a4f2" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在<code class="fe nw nx ny nn b">computedFields</code>中，我们可以像<code class="fe nw nx ny nn b">readingTime</code>一样从内容体中计算数据🤩。我用<code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/ngryman/reading-time" rel="noopener ugc nofollow" target="_blank">reading-time</a></code>来计算基于字数的阅读时间。<code class="fe nw nx ny nn b">slug</code>字段用于稍后在<code class="fe nw nx ny nn b">[slug].tsx</code>页面中生成动态路线。</p><p id="340c" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在幕后，Contentlayer使用<code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/kentcdodds/mdx-bundler" rel="noopener ugc nofollow" target="_blank">mdx-bundler</a></code>解析MDX和YAML frontmatter，并提取内容和数据。如果你对它背后的魔力感兴趣，你可以阅读更多关于<code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/jonschlinkert/gray-matter" rel="noopener ugc nofollow" target="_blank">gray-matter</a></code>和<code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/remcohaszing/remark-mdx-frontmatter" rel="noopener ugc nofollow" target="_blank">remark-mdx-frontmatter</a></code>的内容。这些是<code class="fe nw nx ny nn b">mdx-bundler</code>内部使用的库。</p><p id="4bc8" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在配置结束时，<code class="fe nw nx ny nn b">makeSource</code>将在<code class="fe nw nx ny nn b">data</code>目录下寻找与<code class="fe nw nx ny nn b">blogs/*.mdx</code>模式匹配的文件，并在项目根目录下的<code class="fe nw nx ny nn b">.contentlayer</code>目录中生成博客数据。</p><p id="2b83" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">最后，用<code class="fe nw nx ny nn b">next-contentlayer</code>包装Next.js配置，以便与Next.js的实时重新加载和构建过程集成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">next.config.js</p></figure><h1 id="3603" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用内容层数据生成静态站点</h1><p id="22a1" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">我们准备使用Contentlayer生成的数据并构建静态页面🤩</p><p id="d21e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我们需要做的就是使用来自<code class="fe nw nx ny nn b">.contentlayer/data</code>的<code class="fe nw nx ny nn b">allBlogs</code>来构建与<code class="fe nw nx ny nn b"><a class="ae nf" href="https://nextjs.org/docs/api-reference/data-fetching/get-static-paths" rel="noopener ugc nofollow" target="_blank">getStaticPaths</a></code>的动态路由，并使用<code class="fe nw nx ny nn b"><a class="ae nf" href="https://nextjs.org/docs/api-reference/data-fetching/get-static-props" rel="noopener ugc nofollow" target="_blank">getStaticProps</a></code>将博客数据传递给<code class="fe nw nx ny nn b">[slug].tsx</code>页面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">页面/博客/[slug]。tsx</p></figure><p id="42aa" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">项目完成后，你会在✨的<code class="fe nw nx ny nn b">/blogs/blog-one</code>、<code class="fe nw nx ny nn b">/blogs/blog-two</code>和<code class="fe nw nx ny nn b">/blogs/blog-three</code>看到博客</p><h1 id="0da4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">额外奖励:备注和重新键入插件</h1><p id="8fcd" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">通过利用<code class="fe nw nx ny nn b">contentlayer.config.ts</code>中的remark和rehype插件，我们可以用MDX做更多的事情。</p><ul class=""><li id="da39" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/remarkjs/remark" rel="noopener ugc nofollow" target="_blank">备注</a>是一个改变markdown的令人敬畏的插件生态系统。</li><li id="0be5" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">re type是另一个改变HTML的强大插件生态系统。</li></ul><p id="b7e6" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">它们是两个独立的生态系统，但是我们可以将remark转换为rehype并生成HTML标记。转换如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="9f48" class="nr kv it nn b gy ns nt l nu nv">MDX ----&gt; remark AST ------&gt; rehype AST --------&gt; HTML<br/>    parse            convert            stringify</span></pre><p id="f9f3" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">Contentlayer负责流程。我们需要做的就是添加插件来为转换提供指导。我正在使用以下插件:</p><ul class=""><li id="3ef2" class="lm ln it lo b lp ms lr mu lt ng lv nh lx ni lz ma mb mc md bi translated"><code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/remarkjs/remark-gfm" rel="noopener ugc nofollow" target="_blank">remark-gfm</a></code>支持<a class="ae nf" href="https://github.github.com/gfm/" rel="noopener ugc nofollow" target="_blank"> GitHub风味降价</a>。</li><li id="0efd" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/rehypejs/rehype-slug" rel="noopener ugc nofollow" target="_blank">rehype-slug</a></code>和<code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/rehypejs/rehype-autolink-headings" rel="noopener ugc nofollow" target="_blank">rehype-autolink-headings</a></code>渲染标题链接。</li><li id="0dbe" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/timlrx/rehype-prism-plus" rel="noopener ugc nofollow" target="_blank">rehype-prism-plus</a></code>在代码块中呈现语法高亮。</li><li id="406c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b"><a class="ae nf" href="https://github.com/rockchalkwushock/rehype-code-titles" rel="noopener ugc nofollow" target="_blank">rehype-code-titles</a></code>渲染代码块标题。</li><li id="0a6e" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><code class="fe nw nx ny nn b"><a class="ae nf" href="https://www.npmjs.com/package/rehype-accessible-emojis" rel="noopener ugc nofollow" target="_blank">rehype-accessible-emojis</a></code>提供表情符号的可访问性。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">内容层. config.ts</p></figure><h1 id="93f6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">内容层应用</h1><p id="43f3" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">我们可以利用这些数据做更多的事情。</p><h1 id="daa8" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">应用#1: RSS提要</h1><p id="81b5" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">我现在可以写一个脚本来生成基于<code class="fe nw nx ny nn b">allBlogs</code>数据的RSS提要了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">脚本/rss.mjs</p></figure><h1 id="20c2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">应用#2: XML站点地图</h1><p id="c3af" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">为站点地图生成编写一个脚本更容易。我们所需要的是<code class="fe nw nx ny nn b">data</code>和<code class="fe nw nx ny nn b">page</code>目录中的文件结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">脚本/sitemap.mjs</p></figure><p id="8552" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在构建项目后运行这两个脚本，并自动生成一个新的RSS提要和站点地图。</p><p id="3489" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在<code class="fe nw nx ny nn b">package.json</code>中，添加:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ff6c" class="nr kv it nn b gy ns nt l nu nv">"scripts": {<br/><em class="oi">+</em>    "sitemap": "node scripts/sitemap.mjs",<br/><em class="oi">+</em>    "rss": "node scripts/rss.mjs",<br/><em class="oi">+</em>    "postbuild": "yarn sitemap &amp;&amp; yarn rss",<br/>  },</span></pre><h1 id="8558" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后的想法</h1><p id="c590" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nj mx my lv nk na nb lx nl nd ne lz im bi translated">使用MDX和Contentlayer，用Next.js构建静态站点变得如此轻松。</p><p id="88fa" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">MDX与remark和rehype生态系统相结合，丰富了使用Markdown构建一致页面的可能性。Contentlayer使MDX文件中的数据和内容可供Next.js项目使用。</p><p id="8e46" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">如果您正在探索构建自己的静态站点的方法，请查看前面提到的库。它不仅缩短了上市时间，而且构建起来非常有趣！🦄</p><h1 id="579f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><ul class=""><li id="e5d9" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/contentlayerdev/contentlayer" rel="noopener ugc nofollow" target="_blank"> GitHub:内容层</a></li><li id="d71e" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/dylang/node-rss" rel="noopener ugc nofollow" target="_blank"> GitHub: rss </a></li><li id="6fa5" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/remarkjs/remark" rel="noopener ugc nofollow" target="_blank"> GitHub:备注</a></li><li id="3b55" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/rehypejs/rehype" rel="noopener ugc nofollow" target="_blank"> GitHub:重新输入</a></li><li id="faa7" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/rehypejs/rehype-slug" rel="noopener ugc nofollow" target="_blank">GitHub:retype-slug</a></li><li id="386c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/rehypejs/rehype-autolink-headings" rel="noopener ugc nofollow" target="_blank"> GitHub:重新键入-自动链接-标题</a></li><li id="e9fd" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/timlrx/rehype-prism-plus" rel="noopener ugc nofollow" target="_blank">GitHub:retype-prism-plus</a></li><li id="e006" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">GitHub:重新类型代码标题</li><li id="7627" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/mdx-js/mdx/tree/main/packages/loader" rel="noopener ugc nofollow" target="_blank"> GitHub: @mdx-js/loader </a></li><li id="52f0" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/ngryman/reading-time" rel="noopener ugc nofollow" target="_blank"> GitHub:阅读时间</a></li><li id="ca4b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/remarkjs/remark-gfm" rel="noopener ugc nofollow" target="_blank"> GitHub: remark-gfm </a></li><li id="6a03" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/kentcdodds/mdx-bundler" rel="noopener ugc nofollow" target="_blank"> GitHub: mdx-bundler </a></li><li id="066c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/jonschlinkert/gray-matter" rel="noopener ugc nofollow" target="_blank"> GitHub:灰质</a></li><li id="1994" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/remcohaszing/remark-mdx-frontmatter" rel="noopener ugc nofollow" target="_blank">GitHub:remark-mdx-front matter</a></li><li id="d587" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/dylang/node-rss" rel="noopener ugc nofollow" target="_blank"> GitHub: rss </a></li><li id="94b1" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.com/sindresorhus/globby" rel="noopener ugc nofollow" target="_blank"> GitHub: globby </a></li><li id="90e6" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://www.npmjs.com/package/@next/mdx" rel="noopener ugc nofollow" target="_blank"> npm: @next/mdx </a></li><li id="1d2b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://www.npmjs.com/package/rehype-accessible-emojis" rel="noopener ugc nofollow" target="_blank"> npm:可访问表情符号</a></li><li id="c046" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://leerob.io/" rel="noopener ugc nofollow" target="_blank">网站:李·罗宾逊作品集</a></li><li id="ba72" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://mdxjs.com/" rel="noopener ugc nofollow" target="_blank">网址:MDX </a></li><li id="c6a2" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nextjs.org/docs/advanced-features/using-mdx" rel="noopener ugc nofollow" target="_blank">网站:使用MDX和Next.js </a></li><li id="b8aa" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">网址:Next.js </a></li><li id="1e7e" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nextjs.org/docs/routing/dynamic-routes" rel="noopener ugc nofollow" target="_blank">网址:Next.js动态路线</a></li><li id="23e0" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nextjs.org/docs/api-reference/data-fetching/get-static-paths" rel="noopener ugc nofollow" target="_blank">网址:Next.js getStaticPaths </a></li><li id="582a" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nextjs.org/docs/api-reference/data-fetching/get-static-props" rel="noopener ugc nofollow" target="_blank">网址:Next.js getStaticProps </a></li><li id="9cae" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://mdxjs.com/guides/frontmatter/" rel="noopener ugc nofollow" target="_blank">网站:Frontmatter </a></li><li id="f2df" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://en.wikipedia.org/wiki/URI_fragment" rel="noopener ugc nofollow" target="_blank">网址:URI片段</a></li><li id="9e48" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://developers.google.com/search/docs/advanced/sitemaps/overview" rel="noopener ugc nofollow" target="_blank">网站:了解网站地图</a></li><li id="6dba" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://nodejs.org/api/esm.html#modules-ecmascript-modules" rel="noopener ugc nofollow" target="_blank">网站:ESMAScript模块</a></li><li id="8030" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://github.github.com/gfm" rel="noopener ugc nofollow" target="_blank">网站:GitHub风味降价规格</a></li><li id="aac1" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">网站:抽象语法树</a></li><li id="5cb4" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://www.netlify.com/blog/2020/04/14/what-is-a-static-site-generator-and-3-ways-to-find-the-best-one" rel="noopener ugc nofollow" target="_blank">网站:什么是静态站点生成器？3种方法找到最好的一个</a></li><li id="4a78" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae nf" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">网站:更漂亮</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e7e5" class="nr kv it nn b gy ns nt l nu nv"><strong class="nn iu">Want to Connect?</strong></span><span id="c86a" class="nr kv it nn b gy om nt l nu nv">This article was originally posted on <a class="ae nf" href="https://dawchihliou.github.io/articles/build-better-nextjs-static-sites-with-mdx-and-contentlayer" rel="noopener ugc nofollow" target="_blank">Daw-Chih’s website</a>.</span></pre></div></div>    
</body>
</html>