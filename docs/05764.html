<html>
<head>
<title>Feature Flags for True Continuous Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于真正连续部署的功能标志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/feature-flags-for-true-continuous-deployment-14175f825ac5?source=collection_archive---------10-----------------------#2020-08-04">https://betterprogramming.pub/feature-flags-for-true-continuous-deployment-14175f825ac5?source=collection_archive---------10-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd5d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在没有特性标志的情况下，有可能实现真正的连续生产部署吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bad4876d278927ba338c9d2ca9a60b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qKpG9OxdffdmwQyQ.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pbs.twimg.com/media/Dwpl5eSWsAEB3rX.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="b7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使是我工作过的最好的软件开发团队也很难解决将<em class="lv">完全自动化部署到他们的生产环境中的问题。这方面的最大障碍往往表现为:</em></p><ul class=""><li id="7a0a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">需要人工批准的生产变更管理</li><li id="92f4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">甚至依赖于捆绑和部署在一起的多种服务的微服务架构</li><li id="8484" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">无法将版本和部署的概念分开</li></ul><p id="31c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以应用几种策略来分别解决这些问题，但是用一种模式解决所有这些问题的一个简单技巧是将<strong class="lb iu">特性标志</strong>应用到您的代码中。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="86b8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">终极左移开发实践</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/ebc88eb2d06f5c33281b1256e59223c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d6Pkf_CZEYvjCUJI.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.techarcis.com/wp-content/uploads/2016/06/shift-left-testing-1.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="4d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是在旧的单片应用程序上开发，还是在新的微服务架构应用程序上开发，都没有关系；您可以在任一模式中引入特征标记。此外，根据敏捷开发的行业标准，在一次sprint中编写一个完整的全新特性几乎是不可能的。使用特性标志，我们可以简单地将新代码默认为“off ”,无论在我们的sprint期间谁要求什么，我们都可以打包并部署我们的应用程序，而不用担心会有什么东西损坏。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="112a" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">生产中测试！</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c27e67ef7befe68e646cfd38127f3bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/0*CHWsSIwQpkxbebPd.jpeg"/></div></figure><p id="ccb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你没看错。我提倡你在产品中使用特性标志来测试！好吧，等一下——在你开始胡思乱想，认为我疯了之前，让我澄清一下。</p><p id="ed2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在几个方面使用功能标志，并在生产中打开这些功能，而不会对我们的最终用户造成重大影响:</p><ul class=""><li id="529e" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">后台负载测试</strong>:假设我们有了一个新特性，我们知道它会非常有趣。也许是向其他用户发送实时消息的能力，或者是在一个文档上的实时协作。在生产和发布我们闪亮的新功能之前，我们可以使用真实的用户来模拟流量负载，而不是试图在QA/performance环境中模拟用户负载和行为。这实际上是脸书在向其用户群推出消息之前使用的一个著名策略。几个月来，一些JavaScript向你的其他朋友发送消息，除非你打开了数据包嗅探器，否则你永远不会知道！</li><li id="c900" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">部分用户部署(Partial user rollout):这更类似于金丝雀部署，但我们为用户子集确定一些标准，并为他们推出新功能，而其他人甚至没有看到它的选项。当你有一个大的用户群时，这是非常好的。这使您能够确保您构建的功能是用户可以利用的，否则就关闭它，专注于不同的东西。非常适合假设驱动的开发。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8e71" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">提供终极商业价值</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d47626f73b91f57aab6a68bd1ad509de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*EW5Pc9Uvp1fYEQsy.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pmi.org/kasimage/bde2aba1-ed4d-40c5-890b-f6a5bf085f9a/p3_01.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="9cf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂时后退一步；让我们回顾一下我们试图解决的问题。很多时候，我们的GIT分支策略很难与可部署的工件保持一致。这在开发和生产之间的环境中变得非常明显。在一些情况下，我们希望QA和完整的端到端测试在生产前进行，但我们的业务合作伙伴需要为关键利益相关方演示功能。那么，我们是否在CI/CD管道中放置手动闸门？嗯，如果我们在特定的环境中没有任何利益冲突，那可能会很痛苦。然而，就像生产一样，如果我们启用了自动部署，可能会有一些外部因素影响我们的部署流程，而这些因素在CI/CD管道的设计中几乎是不可能考虑的。</p><p id="31ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此的唯一解决方案变成了<strong class="lb iu">特征标记</strong>。特性标志将版本代码从版本中具体化。因此，虽然我们可能继续增加我们的工件的版本，但是特性不再直接与工件联系在一起。这给了企业更多的控制权来决定何时开启(或关闭)并简化我们的渠道。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="74f7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">警告:防止意大利面条代码</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a8e5dca4e5a222366062c10a655ca2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/0*ndkwG81os0VaRxUL.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://i.pcmag.com/imagery/encyclopedia-terms/spaghetti-code-spageti.fit_lim.size_955x99999.gif" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="decc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我提出一个警告:特性标志是很好的，但是<strong class="lb iu">不要在没有计划的情况下使用这种模式开始开发</strong>。太多时候，令人讨厌的意大利面条式代码在没有对这种编程范式进行适当审查和标准化的情况下就被实现了。</p><p id="588b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像大多数事情一样，不要多此一举。利用这些标准开源库之一来保持代码整洁:</p><ul class=""><li id="e6f2" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://featureflags.io/" rel="noopener ugc nofollow" target="_blank"> FeatureFlags.io </a></li><li id="714b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/ff4j/ff4j/wiki" rel="noopener ugc nofollow" target="_blank"> FF4J </a></li><li id="0862" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/Unleash/unleash" rel="noopener ugc nofollow" target="_blank">释放</a></li></ul><h2 id="f533" class="nn ms it bd mt no np dn mx nq nr dp nb li ns nt nd lm nu nv nf lq nw nx nh ny bi translated"><strong class="ak">特征标志代码示例:</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a933" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="ca73" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">特性标志解决了当我们试图通过自动化将代码部署到产品中，并且代码一准备好就发布时出现的大量问题。</p><p id="3296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们不再担心“发布”，而是开始简单地发布代码，让业务在他们认为合适的时候打开功能。</p><p id="79d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，我们可以对用户子集测试功能，甚至在真实用户不知情的情况下对他们进行测试，从而让我们最真实地了解我们的应用程序如何扩展。</p><p id="2524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，它需要一个渴望在这个新范例中编码的开发团队，以及希望更快地为他们的用户提供特性的<strong class="lb iu">商业伙伴</strong>！</p></div></div>    
</body>
</html>