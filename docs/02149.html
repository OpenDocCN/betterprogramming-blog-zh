<html>
<head>
<title>Android Internals for Rendering a View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android渲染视图的内部机制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-internals-for-rendering-a-view-430cd394e225?source=collection_archive---------4-----------------------#2019-11-10">https://betterprogramming.pub/android-internals-for-rendering-a-view-430cd394e225?source=collection_archive---------4-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0af9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只有了解了幕后发生的事情，才有可能制作出一个出色的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99c2cd3cef76a0cd0c7052170b4a4e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nq27AY-OlyJJa7Z3v61lXA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马丁·卡特勒在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有读过关于<a class="ae ky" href="https://medium.com/better-programming/understand-how-view-renders-in-android-763f0adfb95c?source=your_stories_page---------------------------" rel="noopener">的书，不知道如何在Android </a>中渲染视图，请<a class="ae ky" href="https://medium.com/better-programming/understand-how-view-renders-in-android-763f0adfb95c" rel="noopener">查看</a>以获得更好的理解。由于我们中的一些人更有兴趣挖掘更多的细节，如渲染时使用的组件，显示管道是什么，以及UI和硬件之间的同步是如何发生的，下面是答案。要知道上述问题的答案，我们需要知道下面列出的基本组件</p><ol class=""><li id="cb61" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">UI线程</li><li id="5e1b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">渲染线程</li><li id="ff57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">编舞者</li><li id="74a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">垂直同步</li><li id="f019" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">缓冲队列</li><li id="d089" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">表面抛油器</li><li id="a4dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">表面视图</li><li id="8116" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">显示管道</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a4ce" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">UI线程</h1><p id="b6ef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">每一个app都有它运行UI对象的特殊线程，比如视图对象；这个线程被称为UI线程。只有在UI线程上运行的对象才能访问该线程上的其他对象。</p><p id="c366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，UI线程准备了要在渲染线程上执行的命令管道。从技术上讲，UI线程负责通过处理视图的生命周期来创建信息。这意味着UI线程运行视图的onMeasure()、onLayout()、onDraw()并收集信息，然后将其传递给渲染线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8023eda8957baa71bab3e54731efe1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DG1w4reiWvdIfhsC7ll5og.jpeg"/></div></div></figure><p id="a59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们考虑在一个视图上有一个点击事件。UI线程处理输入事件；如果视图中有任何属性变化，那么就会发生遍历来测量视图。在定位和放置视图之后，就进入了阶段。最后一个阶段是根据上述信息绘制视图。如果上面的信息准备好了，那么我们就把这些信息从UI线程同步到渲染线程。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e735" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">渲染线程</h1><p id="ae4b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">渲染线程是Android Lollipop中已经引入的组件。它从UI线程获取输入，并将其处理给GPU。我们假设UI线程和渲染线程按顺序工作，因为没有来自UI线程的输入，渲染线程不知道做什么。但是，实际上，它们是异步工作的，例如在一些动画和其他东西的情况下。但一般来说，我们确实准备了UI线程上的所有信息，并将这些信息传递给渲染线程，渲染线程是一个与GPU对话的独立线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c97bc90275ded9f5c3e3ae16225399f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taPswAEgNebPaek9_jXvhg.jpeg"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6e2d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">编舞者</h1><p id="43b4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以说<a class="ae ky" href="https://developer.android.com/reference/android/view/Choreographer" rel="noopener ugc nofollow" target="_blank"> Choreographer </a>是一个类，它充当了底层显示系统和应用级视图系统之间的桥梁。</p><p id="f63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编排器从显示子系统接收定时脉冲，例如垂直同步，然后将工作安排为呈现下一个显示帧的一部分。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="18f7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">垂直同步</h1><p id="abed" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要了解VSYNC，我们需要了解另外两个术语。一个是刷新率，也就是屏幕每秒可以更新显示多少次。第二个术语是帧率，意思是你的GPU每秒可以画多少帧。这两者需要协同工作，才能将图像正确地绘制到屏幕上。不能保证这两者以相同的频率出现。在这种情况下，我们可以在屏幕上看到差异或不完整的绘制帧。</p><p id="0641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GPU使用两个缓冲区:后台缓冲区和帧缓冲区。后台缓冲区用于绘制帧。一旦完成，GPU会将该帧复制到帧缓冲区。简而言之，帧缓冲区保存需要在屏幕上呈现的数据。但是，在将内容从后台缓冲区复制到帧缓冲区时，从帧缓冲区获取数据的屏幕刷新率会出现问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/4e7b4e9f7bd0a09b248466b8d9a1bf30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CFX4nLYWixCF8M4QsLuRg.jpeg"/></div></div></figure><p id="830e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，垂直同步(VSYNC)就派上了用场。VSYNC保存从后台缓冲区到帧缓冲区的复制操作，以防屏幕刷新。因此，帧缓冲区中完整绘制的帧将只在屏幕上呈现。</p><p id="fee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VSYNC通常每秒启动60次(大约16.67毫秒)。在引入VSYNC之前，我们经历过UI渲染的延迟，这是人眼可以察觉的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/db0b84d7c7e4a9cfb54548fe69a78742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqtDsB5bNQWhb4sAfobntw.jpeg"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="0bb6" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">流动</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c1b8aee1b5d1b8211eaf882d19a79295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*yDxkeouE2jeaju1SgCsFVA.png"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="750e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">表面抛油器</h1><p id="f59f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">基本上，SurfaceFlinger获取显示数据的缓冲区，将它们组合成一个缓冲区，然后将其传递给硬件抽象层(HAL)。但是，SurfaceFlinger专门处理包含图形和显示数据的缓冲区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/b0d6134d9a8a8f37bbc990d5a205e3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Elvto6KimjoboMBbV58Pg.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ebae" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">缓冲队列</h1><p id="2339" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">缓冲区是一个简单的内存区域，当某样东西被移动到另一个地方时，用来临时存储它。缓冲队列只是我们的图形缓冲区所在的缓冲区队列。通常，我们会有一到三个缓冲区。缓冲队列主要有两个端点:一个是生产者，另一个是消费者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/57dedb12b4e817533f7eecde96e23864.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*VeyvlKoRcQycijX3Sy-LLA.png"/></div></figure><p id="1213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤1: Producer在队列上调用了一个名为dequeueBuffer的方法，现在Buffer的状态是出列。现在，缓冲区的所有者是生产者，它可以对缓冲区进行任何操作，如渲染、设置数据等。通过使用OpenGL或Canvas。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e9d242891c37ddf1d4249202b527a42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-hp1WbjqvnakYoPjgK-9A.png"/></div></div></figure><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤2:在生产者完成插入数据后，它调用队列缓冲区，以便缓冲区排队返回BufferQueue。此时，缓冲区的状态从出列-&gt;排队变为缓冲区所有者成为BufferQueue。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/1b5a1581d0496934bc761f4f96f13af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxR1mpHgQopcw5fF_iIHDA.png"/></div></div></figure><p id="c424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤3:现在消费者将调用BufferQueue上的acquireBuffer，并获取队列中可用的缓冲区。现在消费者是主人；缓冲区的状态由QUEUED-&gt; ACQUIRED改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/bd3a66da33cd5543eef8522a969fe66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qTDCTjPy-1stGjrFNQrmw.png"/></div></div></figure><p id="87cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤4:在消费者操作之后，它调用release以便缓冲区返回到BufferQueue中。此时，缓冲区的状态从“已获取”-&gt;“自由”变为“缓冲区所有者”，成为BufferQueue。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7d7c916291ddd1fdd74a50fcd111185e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RY53MOnqbMC4h-QSN6xa9g.jpeg"/></div></div></figure><p id="34e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，缓冲队列状态</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c45fbe215f0707182da3f1c970254356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oijwuAwLjgZefaJHco42kw.jpeg"/></div></div></figure><h2 id="d976" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">例子</h2><p id="f68d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们看一个例子，其中WindowManger是我们的生产者，SurfaceFlinger是我们的消费者。当我们创建一个对话框或创建一个活动时，一个窗口被附加到WindowManager。现在这个窗口在SurfaceFlinger端有了一个兄弟，叫做Layer。层是系统中的一个组件，它创建并拥有应用程序的BufferQueue。表面是一个API，它是生产者与BufferQueue交互的端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/b25f3f871c75d3e5a1593b829061d488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f10BexhwCID5P9LqTL9mXA.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d6ae" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">显示管道</h1><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">VSYNC信号同步显示流水线。显示管道由应用渲染、SurfaceFlinger合成和在显示器上呈现图像的硬件合成器(HWC)组成。VYSNC同步应用程序唤醒以开始渲染的时间、SurfaceFlinger唤醒以合成屏幕的时间以及显示刷新周期。这种同步消除了不连贯，提高了图形的视觉性能。</p><p id="67a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HWC生成VSYNC事件，并通过回调将事件发送给SurfaceFlinger。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="36a3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">表面视图</h1><p id="a408" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">SurfaceView提供了嵌入视图层次结构内部的专用绘图表面。您可以控制这个表面的格式，如果您愿意，还可以控制它的大小；表面视图负责将表面放置在屏幕上的正确位置</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/1f6020e6f886b895291da2db0518d4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KD6_LMAjugj_tnif79qwrQ.png"/></div></div></figure><p id="f06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SurfaceView的工作原理是窗口就是它的表面。然后，它精确地在表面上切孔。我们要求WindowManager和SurfaceFlinger创建第二个表面，我们只是把它放在第一个表面的下面。它们是两个不同的表面和不同的缓冲队列；他们可以独立。下面是结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/cbdd32c178aa2b748e3a7cb23047198f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ot-vicN8dvWMX0CUKTugrA.png"/></div></div></figure><p id="997a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>