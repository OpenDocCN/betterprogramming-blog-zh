<html>
<head>
<title>Decoupling Display and Logic in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中分离显示和逻辑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decoupling-display-and-logic-in-ios-4de5a334ffbd?source=collection_archive---------13-----------------------#2019-08-16">https://betterprogramming.pub/decoupling-display-and-logic-in-ios-4de5a334ffbd?source=collection_archive---------13-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1b3340f92cf91a73700ec3ce77e35ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KaXk8HhQje-tGzQQvAMug.jpeg"/></div></div></figure><h2 id="fef0" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="4e62" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">流程的循环:视图→交互者→逻辑→演示者→视图</h2></div><p id="cf3c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的文章《<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS应用架构</a>》中，我提出了一种架构，它将<em class="lz">场景</em>与其他场景划分为<em class="lz">视图</em>、<em class="lz">交互</em>、<em class="lz">逻辑</em>和<em class="lz">呈现者</em>。我想更详细地解释一下为什么我认为这种划分是有意义的。</p><p id="441e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">流程循环将会是:</p><ol class=""><li id="5275" class="ma mb je le b lf lg li lj ll mc lp md lt me lx mf mg mh mi bi translated"><em class="lz">视图</em>提供了视图层次。</li><li id="5f6c" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><em class="lz">交互器</em>将自己挂接到<em class="lz">视图</em>中，以获得关于用户交互的通知。</li><li id="abd9" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated">这些交互然后被映射到<em class="lz">逻辑</em>的方法。</li><li id="d748" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><em class="lz">逻辑</em>计算输入并管理任何状态变化。</li><li id="54c7" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><em class="lz">逻辑</em>告诉<em class="lz">展示者</em>根据新的app状态更新<em class="lz">视图</em>。</li><li id="abd4" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><em class="lz">演示者</em>更新<em class="lz">视图</em>。</li></ol><p id="51be" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一句，这是“可扩展的iOS应用架构系列的<a class="ae ly" href="https://medium.com/@sven.korset/pieces-of-a-scalable-ios-app-architecture-7c182f9dcd2c" rel="noopener">部分”中的一篇文章。</a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="b18b" class="mv mw je bd mx my mz na nb nc nd ne nf kt ng ku nh kw ni kx nj kz nk la nl nm bi translated">视角</h1><p id="a9b8" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">一个<em class="lz">视图</em>的任务是向用户展示一些东西。在iPhone或iPad等基于触摸屏的设备上，<em class="lz">视图</em>也接收所有用户输入。因此，<em class="lz">视图</em>代表用户和应用程序之间的界面。</p><p id="ec4a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一个<em class="lz">视图</em>传统上有两个任务，展示和交互。通常，这由一个<em class="lz"> UIViewController </em>处理，它通过动作监听用户输入，计算一些东西，然后格式化结果并用它填充<em class="lz">视图</em>。</p><p id="df45" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，如果你想从<strong class="le jo">坚实的</strong>原则中尊重<strong class="le jo">单一责任原则</strong>(由<a class="ns nt ep" href="https://medium.com/u/a1ee806e09de?source=post_page-----4de5a334ffbd--------------------------------" rel="noopener" target="_blank"> Chidume Nnamdi解释得很好🔥💻🎵🎮</a>在他的文章“<a class="ae ly" href="https://blog.bitsrc.io/solid-principles-every-developer-should-know-b3bfa96bb688" rel="noopener ugc nofollow" target="_blank">每个开发人员都应该知道的坚实原则</a>”)中，那么这属于他们自己的类别。所以，让我们把这些任务放入自己的类中，称它们为<em class="lz">交互者</em>和<em class="lz">展示者</em>。</p><p id="062d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">那么<em class="lz">视图</em>还剩下什么呢？🤔</p><p id="ead6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">视图</em>提供了静态结构，视图层次结构。它创建并管理子视图，为它们提供一个接口。其他参与者，如<em class="lz">交互者</em>可以将自己钩入子视图来拦截用户输入，或者<em class="lz">演示者</em>可以直接用数据填充子视图。</p><p id="bb4a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果视图层次发生变化，例如，因为要插入一个嵌入式视图，那么这将在<em class="lz">视图</em>的任务区域中。</p><p id="8247" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">子视图的初始值也可以由<em class="lz">视图</em>设置，因为<em class="lz">视图</em>创建这些子视图。例如，当创建<em class="lz">视图</em>时，可以设置视图层次结构中按钮的文本和样式，因为这些是静态默认值。</p><p id="606f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是，如果一个风格或值应该在运行时改变，那么这取决于应用程序的特殊状态，这将不再是<em class="lz">视图</em>的任务，而是<em class="lz">呈现器</em>的任务。</p><p id="edc5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，如果<em class="lz">演示者</em>得到<em class="lz">逻辑</em>的通知，登录按钮现在应该显示红色“取消”，那么<em class="lz">演示者</em>有责任相应地调整按钮，而不是<em class="lz">视图</em>。当然，按钮本身可以提供改变状态和调整外观的相应功能，但这仍然取决于<em class="lz">演示者</em>调用按钮上的功能。</p><p id="0430" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">视图</em>除了提供视图层次之外什么也不做。🙂</p><h2 id="dbff" class="nu mw je bd mx nv nw dn nb nx ny dp nf ll nz oa nh lp ob oc nj lt od oe nl jk bi translated">以编程方式完成的视图</h2><p id="3ecc" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">顺便说一下，在我的<a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)中，<em class="lz">视图</em>是以编程方式创建的，而不是通过xib或storyboard。</p><p id="53a6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为什么？😩</p><p id="6e6f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ns nt ep" href="https://medium.com/u/392098dd9008?source=post_page-----4de5a334ffbd--------------------------------" rel="noopener" target="_blank">张秀坤·维塞尔</a>在他的文章《<a class="ae ly" href="https://medium.com/ackee/user-interface-programming-on-ios-at-ackee-storyboards-vs-xib-vs-code-40f4d3e5ee6b" rel="noopener">iOS上的用户界面编程</a>》中给出了一个很好的对比，我只能同意。用代码编写视图仅仅意味着:</p><ul class=""><li id="a893" class="ma mb je le b lf lg li lj ll mc lp md lt me lx of mg mh mi bi translated">合并冲突变得可以解决</li><li id="ee7d" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx of mg mh mi bi translated">查看-代码可以被审查</li><li id="cec6" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx of mg mh mi bi translated">可以对视图层次结构和约束条件进行注释</li><li id="d1b6" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx of mg mh mi bi translated">相关代码变得不那么支离破碎</li></ul><p id="0418" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">xib和故事板的唯一优点是创建视图更快更直观。然而，如果您不想编写快速原型，而是想在可伸缩的团队中编写专业的、可维护的代码，那么您确实无法避免编程方法。</p><p id="55af" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">试试看。过一段时间你肯定会喜欢它。😘</p><p id="5d63" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我已经能听到你说“但是如果你只有视图的代码，那么在你的头脑中设计一个它的视觉图像是很困难的！”🤯</p><p id="3c47" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这也是我依赖<em class="lz"> IBDesignable </em>并提供xib文件的原因。但是，这些xib不用于创建视图，因此不会在应用程序中提供。它们在开发中只是作为视觉辅助，因为有了InterfaceBuilder和IBDesignable，您可以很容易地用xib可视化代码，这样您就可以相对快速地看到视图是什么样子。</p><p id="223d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">使用<em class="lz"> IBInspectable </em>，您甚至可以提供对不同状态和测试数据的访问，这样您甚至可以在xib中显示视图的不同表示。将多个视图实例添加到xib中，并为可检查的属性提供不同的数据，这样，您就可以一次看到所有的边缘案例。</p><figure class="oh oi oj ok gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/2dbd3e855a06ae3fb3fdd625230d07a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAiv7HXrYS6v_R0CpKvYFQ.png"/></div></div></figure><p id="68d0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你将定制视图外包到你自己的框架中，那么你甚至可以将它们嵌入到<em class="lz">的操场</em>中，并呈现一个实时的交互视图。</p><p id="24d0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我用一个“圆形按钮”做到了这一点，你可以在DAP的“嵌入式框架/自定义视图/按钮”下找到它。</p><figure class="oh oi oj ok gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/a725bd4027bf1d1d2d8cf72acd2b66d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upmEAEcViCLcQdDke0mTLg.png"/></div></div><p class="om on gj gh gi oo op bd b be z dk translated">圆形按钮.游乐场</p></figure><p id="7027" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这样做的好处是可以看到甚至测试用户交互，比如点击按钮，而不必运行整个应用程序。是不是很酷？🤩</p><p id="494d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">苹果似乎正朝着类似的方向前进，推出了新的SwiftUI框架及其声明式方法。这让我非常高兴，我相信我不是唯一一个。</p><p id="670e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz"> SwiftUI </em>甚至用更少的代码和直接的、可操作的、可视化的表示来代替xib方法的<em class="lz">视图</em>部分。一旦iOS 13足够普及，一个项目的最低iOS需求允许，我们就应该切换到<em class="lz"> SwiftUI </em>。😍</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d9e8" class="mv mw je bd mx my mz na nb nc nd ne nf kt ng ku nh kw ni kx nj kz nk la nl nm bi translated">互动者</h1><p id="e277" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">如前所述，<em class="lz">交互器</em>的任务是将所有用户交互映射到业务逻辑，并在<em class="lz">逻辑</em>调用适当的用例方法。</p><p id="e32e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为此，<em class="lz">交互器</em>必须能够直接访问<em class="lz">视图</em>的子视图，以便注册相应的操作。你也可以把<em class="lz">视图</em>放在一个接口的后面，这样<em class="lz">交互器</em>就不会直接依赖于<em class="lz">视图</em>，但这只会不必要地扩大<em class="lz">视图</em>，使其变得比必要的复杂得多，而对可维护性或可测试性没有任何真正的好处。</p><p id="46f9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不确定？🤨</p><p id="3705" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">与直接的<em class="lz">视图</em>类相比，<em class="lz">视图</em>的界面会是什么样子？你必须以某种方式暴露所有的子视图。嗯，这个视图除了提供一个到所有子视图的接口之外，什么也没做。你想测试什么？没有<em class="lz">视图</em>测试<em class="lz">交互器</em>是没有意义的。你只是不能用一个虚拟对象替换视图的类。那么，为什么要抽象出<em class="lz">视图</em>呢？</p><p id="36fe" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">更有趣的是，实际上这种绑定在<em class="lz">视图</em>和<em class="lz">逻辑</em>之间是什么样子的。当你想到<em class="lz">绑定</em>，你肯定会想到Rx。</p><p id="b106" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">事实上，在DAP中，我使用了<em class="lz"> RxSwift </em>和<em class="lz"> RxCocoa </em>将行为耦合到按钮点击、开关变化等。忠实于这样一句格言:如果发生了这种情况，那就应该执行。当然，Rx不是强制性的，但是它使之变得容易得多，例如，如果您想为textfield的更改安装一个节流器，这样就不会在每次击键时都发送新的服务器请求。</p><p id="5f5d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">交互器</em>和<em class="lz">视图</em>一样，最终可能会被<em class="lz"> SwiftUI </em>和<em class="lz">组合</em>所取代。不幸的是，你必须在这里等待一到三年才能获得足够的iOS 13发行版。😴</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="aa97" class="mv mw je bd mx my mz na nb nc nd ne nf kt ng ku nh kw ni kx nj kz nk la nl nm bi translated">逻辑</h1><p id="af83" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">啊，<em class="lz">逻辑</em>。这是一个应用程序的核心。它是用例的集合。它包含了业务逻辑。直到意识到海量视图控制器的问题，这段代码还在<em class="lz"> UIViewController </em>中。现在它让<em class="lz">逻辑</em>变得庞大。耶！🤠</p><p id="1e92" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以这种情况不会发生，代码应该进一步模块化和外包，这最好在框架中完成，由工人封装。因此，不是让<em class="lz">逻辑</em>执行任何服务器请求，而是应该由<em class="lz">服务器工作器</em>来完成，并且<em class="lz">逻辑</em>将只调用工作器上的适当方法。</p><p id="de09" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这将<em class="lz">逻辑</em>的代码或多或少地简化为简单的检查、状态改变和委托。通常常见的用例需求可以直接映射成这样的东西:改变这个，如果这个和那个是真的，那么<em class="lz"> foo </em>应该发生。但是<em class="lz"> foo </em>则取决于<em class="lz">工人</em>、<em class="lz">主持人</em>或<em class="lz">导航员</em>。</p><p id="0b21" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，<em class="lz">逻辑</em>通过DI获得所有的依赖项，这样它们就可以被模拟用于<em class="lz">单元测试</em>。<em class="lz">逻辑</em>是<em class="lz">单元测试</em>的优秀候选。但对每个工人来说也是如此。</p><p id="e2fd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">逻辑</em>的方法主要由<em class="lz">交互器</em>调用，大多数时候是因为用户做了相应的输入，导致状态改变。然而，也可能是<em class="lz"> UIViewController </em>需要向<em class="lz">逻辑</em>传递一些信息，例如设备的旋转。</p><p id="90fd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">反过来，<em class="lz">逻辑</em>并不真正了解关于<em class="lz">视图</em>的任何事情，而只是指示<em class="lz">呈现者</em>执行适当的视图更新。通过使用<em class="lz">接口</em>,<em class="lz">逻辑</em>因此与其他组件强烈解耦。</p><p id="a6c9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">只是尽量保持逻辑尽可能的小。😅</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2e6a" class="mv mw je bd mx my mz na nb nc nd ne nf kt ng ku nh kw ni kx nj kz nk la nl nm bi translated">提出者</h1><p id="90c5" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated"><em class="lz">展示者</em>的职责是更新<em class="lz">视图</em>。因此，如果<em class="lz">逻辑</em>正在传输数据或特殊状态，那么<em class="lz">呈现器</em>必须相应地操纵视图。</p><p id="40aa" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">视图</em>只为视图层次结构提供子视图。<em class="lz">展示者</em>直接访问<em class="lz">视图</em>的子视图，并设置样式和值。</p><p id="23fa" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">相应地，<em class="lz">表示器</em>中的代码也非常简单:获取这个参数并将其分配给那个子视图。有时，格式化程序可能会在赋值前对值进行格式化，但是在<em class="lz">表示器</em>中很少有更多的逻辑。</p><p id="1e47" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是，还是有一些怪癖！🤬</p><h2 id="36e8" class="nu mw je bd mx nv nw dn nb nx ny dp nf ll nz oa nh lp ob oc nj lt od oe nl jk bi translated">警报</h2><p id="0462" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">警告，意思是<em class="lz"> UIAlertController，</em>是<em class="lz"> UIViewController </em>并且呈现它们，人们会期望，将是<em class="lz">导航器</em>的任务，因为它也呈现所有其他<em class="lz">UIViewController</em>，对吗？</p><p id="4458" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不完全是。☹️</p><p id="df80" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">导航器不是用来显示UIViewControllers的，而是导航到其他场景。警报不是一个场景。因此，警报不是<em class="lz">导航员</em>的责任。</p><p id="682a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以，如果<em class="lz">逻辑</em>想要显示类似<em class="lz"> serverError </em>的东西，那不是场景变化，而是场景内信息的简单显示。这不一定要通过警告来实现，但也可以通过现有视图中的简单文本输出来实现。或者它可以是复杂的东西，比如带有模式化呈现的控制器的自定义视图。</p><p id="19a7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">啊哈，一个模态呈现的<em class="lz"> UIViewController </em>几乎就是一个场景转换，不是吗？🤨</p><p id="06e1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你把这个<em class="lz"> UIViewController </em>实现写成<em class="lz">场景</em>，那么是的，因为这样你又传递了依赖关系。你有<em class="lz">核心</em>带着<em class="lz">导航仪</em>回来，也许<em class="lz">导航仪</em>也通向其他场景。</p><p id="c350" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，使用<em class="lz"> UIAlertController </em>永远不会导致其他场景或<em class="lz"> UIViewControllers </em>，而是总是回到当前场景。您不需要移交任何依赖项，也不需要所有的架构开销。原则上，此警报与在当前层次结构中显示简单视图或嵌入式视图没有区别。</p><p id="8abd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">导航到<em class="lz">场景</em>是<em class="lz">导航员</em>的任务，而呈现其他东西如<em class="lz"> UIViewControllers </em>是<em class="lz">呈现员</em>的任务。😜</p><p id="2fee" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">弹出窗口也将通过<em class="lz">展示器</em>显示，而不是通过<em class="lz">导航器</em>显示。</p><h2 id="ec24" class="nu mw je bd mx nv nw dn nb nx ny dp nf ll nz oa nh lp ob oc nj lt od oe nl jk bi translated">嵌入式控制器</h2><p id="5908" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">嵌入式ViewController怎么样？那么，一个拥有自己的<em class="lz"> UIViewController </em>的视图，应该通过<code class="fe oq or os ot b">addChild</code>添加到场景的当前<em class="lz"> UIViewController </em>中？让我们假设为<em class="lz"> serverErrors </em>定制一个错误显示控制器。🤔</p><p id="9444" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这和警报的原理是一样的:它不是一个场景。<em class="lz">展示者</em>通过<code class="fe oq or os ot b">addChild</code>将控制器添加到<em class="lz"> UIViewController </em>中并展示视图。</p><p id="583a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，在这里，控制器的视图应该用<code class="fe oq or os ot b">addSubview</code>插入到视图层次结构中，通常还有新的约束。这将是<em class="lz">视图</em>的任务，例如使用<code class="fe oq or os ot b">addEmbeddedView</code>方法或类似方法，然后由<em class="lz">呈现器</em>调用。</p><p id="8172" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是谁创建了这个<em class="lz"> ViewController </em>类的对象来嵌入，并因此获得了对它的依赖呢？🤨</p><p id="a64f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">同样，与警报一样，具体对象是由<em class="lz">呈现者</em>创建的。因此，<em class="lz">表示器</em>直接依赖于这些要嵌入的控制器，以及<em class="lz"> UIAlertController </em>。</p><p id="ca89" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">您还可以考虑通过<em class="lz">表示器</em>调用<em class="lz">工厂</em>来创建这些依赖关系。然而，这将大大增加复杂性。会有什么好处？</p><p id="b291" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不会有什么好处，因为你不会用单元测试来测试演示者。由于所需的视图生命周期，这是不切实际的。你需要运行完整的<em class="lz"> UIViewController </em>，包括动画、ViewController演示等。如果你想在那里进行测试，那么UITests会更合适。</p><p id="4305" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，您不必用mock替换对这个嵌入式控制器的依赖，因为您不会使用与控制器不同的东西。所以，保持简单，笨蛋！😝</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="da96" class="mv mw je bd mx my mz na nb nc nd ne nf kt ng ku nh kw ni kx nj kz nk la nl nm bi translated">结论</h1><p id="3faf" class="pw-post-body-paragraph lc ld je le b lf nn ko lh li no kr lk ll np ln lo lp nq lr ls lt nr lv lw lx im bi translated">单一责任原则规定一个类应该只做一件事。这个“东西”是什么，有点主观，但是，在我看来，将交互外包给<em class="lz">交互者</em>，将演示外包给<em class="lz">演示者</em>是有意义的。<em class="lz">视图</em>只管理视图层次结构，而<em class="lz">逻辑</em>只包含业务逻辑。</p><p id="27a3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">展示器</em>和<em class="lz">互动器</em>通常不由<em class="lz">单元测试</em>进行测试，而是由<em class="lz">单元测试</em>进行测试。<em class="lz">视图</em>也是如此，尽管您也可以使用快照测试通过单元测试来测试它。但是由于<em class="lz">视图</em>不依赖于任何其他东西，这也不是问题。</p><p id="aeeb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过接口的抽象只对<em class="lz">呈现者</em>是必要的，因为这必须被<em class="lz">逻辑</em>引用。由于<em class="lz">逻辑</em>应该放在<em class="lz"> UnitTest </em>之下，因此能够模仿<em class="lz">演示者</em>非常重要，这要归功于接口。</p><p id="3230" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">剩下的就是<em class="lz">工人</em>。工人是<em class="lz">逻辑</em>的追随者，当然也是通过接口抽象出来的。因此，<em class="lz">逻辑</em>并不直接依赖于<em class="lz">工人</em>。</p><p id="bb48" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">脱钩就是一切！😎</p></div></div>    
</body>
</html>