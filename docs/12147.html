<html>
<head>
<title>Animating Regular Expressions With Python and Graphviz</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和Graphviz制作正则表达式动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/animating-regular-expressions-with-python-and-graphviz-e0df447b827a?source=collection_archive---------0-----------------------#2022-05-16">https://betterprogramming.pub/animating-regular-expressions-with-python-and-graphviz-e0df447b827a?source=collection_archive---------0-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3fe8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">窥视正则表达式引擎的内部</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f0cdfed2e442a08e2b1d65d581e8994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q60ikWIu-CgQS-5u7oygJw.png"/></div></div></figure><p id="44c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正则表达式名声不好。似乎只要一提到它们，就会让人想起可怕的文字墙，这些文字看起来完全是胡说八道。例如，这是一个常用于验证电子邮件地址的正则表达式:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="769b" class="lt lu iq lp b gy lv lw l lx ly">(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</span></pre><p id="0960" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">呀。我不打算假装在本文结束时你会理解这个表达，但我至少想告诉你，它是建立在简单的规则之上的，并不太难理解。</p><p id="a31f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能想知道，为什么您要首先关心这些东西是如何工作的？我认为有几个很好的理由。首先，理解了基本原理，就更容易记住如何编写好的正则表达式。</p><p id="260c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我确实遇到过这样的情况，我写了一个正则表达式，然后几个月都不需要看它。当我最终回来时，我已经忘记了一切，不得不从头开始重新学习。通过理解正则表达式背后的思想而不仅仅是它们的语法，你将能够避免这个问题。</p><p id="2f38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，也许这是我肩上的自学程序员芯片，但我认为窥视一下理论计算机科学的世界是值得的。正则表达式似乎是少数几个已经脱离理论计算机科学并被日常程序员使用的概念之一。理解一个正则表达式引擎提供了一个实践的机会，去接触一些高端的概念，比如有限状态自动机。</p><p id="3cce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现理解一个概念的最好方法是把它形象化。我已经使用Python和Graphviz构建了一个正则表达式引擎，它可以显示正则表达式在搜索文本主体时实际发生的事情。如果你想尝试你自己的例子，这个项目可以在GitHub 上公开获得。作为未来的演示，这里有一个regex <code class="fe lz ma mb lp b">S+NAKE</code>搜索文本SSSSNAKE的动画:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/eb2f185073f24b674bb5fec6432058e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JYdVq5qXkUSSV_Cs4uCeEQ.gif"/></div></div></figure><h1 id="da04" class="md lu iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">背景</strong></h1><p id="dab7" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">正则表达式的概念背后有很多理论，但我将尝试解释实现我们的正则表达式引擎所需的基本要素。</p><p id="5b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要正则表达式的具体定义。<a class="ae ln" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">维基百科</a>将其定义为“在文本中指定搜索模式的字符序列。”正则表达式中的大多数字符都被同等对待，但是有一些特殊的字符，我称之为元字符(*、+、？, |).这些具有独特的功能，将在后面讨论。</p><p id="4a9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该引擎的核心是确定性有限状态自动机(DFA)。这听起来很花哨，但实际上，它只是一个有开始节点和结束(或接受)节点的有向图。DFA通过基于一些输入改变状态来工作。读取所有输入后，我们评估DFA的状态。如果它处于接受状态，它返回<code class="fe lz ma mb lp b">True</code>。否则返回<code class="fe lz ma mb lp b">False</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/ca8c32f6aae3d6affd0c0094e02f38aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*OZucqajTUpwHnhkEuIrkQQ.png"/></div></div></figure><p id="aeb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的DFA中，从起始状态进入接受状态的唯一方法是向它传递序列“BAT”这个例子看起来很简单，但是它可以扩展到任意长的输入和复杂的字母序列。因此，理想情况下，我们希望找到一种方法，将正则表达式转换为DFA。</p><p id="8cdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理论来拯救！<a class="ae ln" href="https://www.cs.cornell.edu/courses/cs2800/2017sp/lectures/lec27-kleene.html" rel="noopener ugc nofollow" target="_blank">克莱尼定理</a>指出对于任何正则表达式，都存在一个能够指定相同字符串集的DFA，反之亦然。这意味着有某种算法能够将我前面提到的疯狂的电子邮件正则表达式验证转换成DFA。一旦它变成那种形式，计算机就能很容易地处理它。</p><p id="b879" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始构建这个算法之前，我还有一个警告要提。将正则表达式转换成DFA在计算上非常昂贵。</p><p id="99f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相反，我们可以把它变成一个不确定的有限状态自动机(NFA)。关键区别在于，NFA可以同时处于多个状态，并且它可以移动到不同的状态，而无需扫描额外的输入字母。这听起来可能有点混乱，但我认为在下面的例子中会变得清晰。</p><h1 id="3748" class="md lu iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">正则表达式</strong> → <strong class="ak"> NFA </strong></h1><p id="e5b2" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">下面是该引擎支持的元字符的简要概述:</p><ul class=""><li id="1146" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">星号(<code class="fe lz ma mb lp b">*</code>):匹配一个字符零次或多次。</li><li id="4a7f" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">加号(<code class="fe lz ma mb lp b">+</code>):匹配一个字符一次或多次。</li><li id="d59d" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">问题(<code class="fe lz ma mb lp b">?</code>):匹配一个字符零次或一次。</li><li id="3688" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">句点(<code class="fe lz ma mb lp b">.</code>):也称为通配符，它匹配任何字符。</li><li id="8f14" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">括号(<code class="fe lz ma mb lp b">()</code>):封装子表达式。</li><li id="229e" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">竖线(<code class="fe lz ma mb lp b">|</code>):也称为<code class="fe lz ma mb lp b">or</code>操作符，匹配子表达式中的多个元素。</li></ul><p id="7b3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您以前使用过正则表达式，您可能会注意到缺少一些元字符，如方括号(<code class="fe lz ma mb lp b">[]</code>)和花括号(<code class="fe lz ma mb lp b">{}</code>)。但是，引擎仍然具有实现这些缺失字符所完成的操作的所有功能。</p><p id="c713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不支持的表达式<code class="fe lz ma mb lp b">[ABC]</code>等同于支持的表达式<code class="fe lz ma mb lp b">(A|B|C)</code>。同样，<code class="fe lz ma mb lp b">A{2, 3}</code>相当于<code class="fe lz ma mb lp b">AAA?</code>。添加这些元字符是完全可能的，但是这会使图形表示变得复杂，所以我选择不添加它们。</p><p id="e243" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将通过使用正则表达式<code class="fe lz ma mb lp b">(A*B|AC)D</code>作为例子来演示转换过程。首先，我们需要对正则表达式进行一点预处理，用括号将它括起来。然后我们为正则表达式中的每个字符创建节点。我们还包括最后一个空白节点来象征接受状态。此时，我们的NFA应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/ebe5b68722a5c7d2a056d33c32f2d5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpreRqwP67TjYfm3xrkdrA.png"/></div></div></figure><p id="fb97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们添加黑色的匹配过渡边缘。我们可以把这些边想象成对应于字母表中字母节点的边。只有当我们从文本中扫描的字母与节点的字母匹配时，这些边才会被跟踪。添加匹配过渡边的逻辑很简单:如果一个节点不包含元字符，则添加从该节点到下一个节点的匹配过渡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/686d7484b0e0a5257e8c16bee090fee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jnda5rqAevbQbtHhF3MQw.png"/></div></div></figure><p id="712d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最难的部分是添加ε过渡边。我们可以把这些边想象成对应于包含元字符的节点的边。这些边缘对于每个元字符来说是不同的，并且还受到括号位置的影响。例如，任何时候一个星形操作符在正则表达式中，它都需要三个独立的ε转换边。一个到它之后的状态，一个到它之前的状态，另一个从它之前的状态回到恒星。</p><p id="9a44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加所有ε转换边后，NFA完成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/a443fada653f7dc999c5a56661b8880d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUW_KqLpuOvcDbEoKEEAHQ.png"/></div></div></figure><h1 id="f1ad" class="md lu iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">NFA模式匹配</h1><p id="74b9" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">既然NFA已经完全构建好了，我们可以在一个文本体上运行它，并观察它如何从一个状态转换到另一个状态。如果NFA达到了最终的接受状态，我们就有了一场比赛。如果我们完成了对文本的扫描，并且从未到达接受状态，则不会找到匹配。</p><p id="4cc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行NFA的基本模式如下:</p><ol class=""><li id="a365" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm np ng nh ni bi translated">在扫描文本的第一个字母之前，创建一个名为<em class="nq">活动状态</em>的列表，并将NFA中的第一个节点添加到其中。</li><li id="4246" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm np ng nh ni bi translated">取从每个处于活动状态的节点到每个可到达状态的ε转换。将所有可到达的状态放入一个候选状态列表中。</li><li id="b596" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm np ng nh ni bi translated">浏览课文中的下一个字母。</li><li id="d2e6" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm np ng nh ni bi translated">清除<em class="nq">活动状态</em>列表。如果<em class="nq">候选状态</em>中的任何状态与文本中的字母匹配，将其匹配转换到下一个状态，并将其添加到新的<em class="nq">活动状态列表</em>。</li><li id="b12f" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm np ng nh ni bi translated">重复步骤2–4，直到到达接受状态或到达文本结尾。</li></ol><p id="e5cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此过程的Python代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1896" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于一个可视化的例子，我们将通过一个文本体运行前面创建的NFA。我们将搜索文本AABD，看看我们是否得到一个匹配。第一步是在AABD的第一个字母被扫描之前，得到所有可能的ε跃迁。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/67d8222b3900b8e75ffc8ae4fd49f558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piZSHe8m0P4105z2f0g7Jg.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">在扫描文本的第一个字母之前，通过ε转换找到可用的状态</p></figure><p id="cacc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NFA在第一步就已经有6个不同的候选州了！接下来，我们浏览课文的第一个字母。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/3070a9710cd08f0d504b41d27112de78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZatx-8C-Pm0MSfdvXIj-Q.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">阅读课文的第一个字母</p></figure><p id="87c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">两个节点具有来自A的匹配转换:节点4和节点8。下一步是从这些节点获取匹配过渡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/a55ed487d990bc58bc38ed6ff05876d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNDdIiqNLlN7j6RWrCX8Wg.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">匹配从A → *和A → C的转换</p></figure><p id="8577" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这里开始，这个过程以完全相同的方式重复。我们从活动状态获取每个可用的ε转换，扫描下一个字母，并获取下一个匹配转换。整个过程如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/63cc09a6a3ef1652963657fd8f2aab88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*948LnmhijMafPl5XwwBNqA.gif"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">整个NFA搜索过程，在接受州结束</p></figure><h1 id="91db" class="md lu iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">最后的想法</strong></h1><p id="2482" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我希望阅读完本文后，您能够更好地理解正则表达式引擎的内部操作。为了进一步澄清，我强烈推荐<a class="ae ln" href="https://www.coursera.org/lecture/algorithms-part2/regular-expressions-go3D7" rel="noopener ugc nofollow" target="_blank">罗伯特·塞奇威克教授的这些视频讲座</a>。</p><p id="2b89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为不与它互动就很难完全理解一些东西，所以我鼓励任何阅读这篇文章的人创建他们自己的<a class="ae ln" href="https://github.com/aydinschwa/Regex-Engine" rel="noopener ugc nofollow" target="_blank">正则表达式动画</a>或者只是摆弄一下<a class="ae ln" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">正则表达式调试器</a>。</p><p id="6657" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你对如何提高可视化有任何问题或建议，我很乐意听听。感谢阅读！</p></div></div>    
</body>
</html>