<html>
<head>
<title>JavaScript: Promises or async-await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:承诺还是异步等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-i-use-promises-or-async-await-126ab5c98789?source=collection_archive---------0-----------------------#2018-08-21">https://betterprogramming.pub/should-i-use-promises-or-async-await-126ab5c98789?source=collection_archive---------0-----------------------#2018-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9be9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一套何时使用的规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb838e78e97911e0cc60b94922f5d45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBiJ82CJVPCyymYYzN1I9Q.png"/></div></div></figure><p id="0eba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近看了一个中型帖子，作者声称使用<code class="fe lq lr ls lt b">async-await</code>比使用<code class="fe lq lr ls lt b">promises</code>更好。</p><p id="5ee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这在一般情况下可能是真的，但我认为这种概括太宽泛了，对<code class="fe lq lr ls lt b">async-await</code>和<code class="fe lq lr ls lt b">promises</code>都不公平。</p><p id="a3d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于JavaScript新手来说，理解这些并决定使用哪一个可能是一个挑战。在这篇文章中，我将列出我学到的关于这些的东西，以及我如何决定何时使用它们。</p><p id="c210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在哪里读到过<code class="fe lq lr ls lt b">async-await</code>是使用<code class="fe lq lr ls lt b">promises</code>的语法糖。因此，在了解<code class="fe lq lr ls lt b">async-await</code>或决定使用哪种方法之前，请确保您对<a class="ae lu" href="https://medium.com/better-programming/understanding-promises-in-javascript-13d99df067c1" rel="noopener">承诺</a>和<a class="ae lu" href="https://medium.com/better-programming/understanding-async-await-in-javascript-1d81bb079b2c" rel="noopener">异步等待</a>有很好的理解。</p><p id="8ac3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我遵循的一些经验法则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用承诺的经验法则</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/de1af4b48302af2983453fcffcadaab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mBlni5vsYZE2wFzfVv8EA.png"/></div></div></figure><ol class=""><li id="7c5d" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">每当使用异步或阻塞代码时，都要使用承诺。</li><li id="b7d1" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">resolve</code>映射到<code class="fe lq lr ls lt b">then</code>并且<code class="fe lq lr ls lt b">reject</code>映射到<code class="fe lq lr ls lt b">catch</code>用于所有实际目的。</li><li id="1e16" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">确保为所有承诺编写<code class="fe lq lr ls lt b">.catch</code>和<code class="fe lq lr ls lt b">.then</code>方法。</li><li id="5498" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果在两种情况下都需要做些什么，使用<code class="fe lq lr ls lt b">.finally</code>。</li><li id="fbf7" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">我们只有一次机会改变每个承诺。</li><li id="2eb6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">我们可以为一个承诺添加多个处理程序。</li><li id="68d8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">Promise</code>对象中所有方法的返回类型，不管它们是静态方法还是原型方法，都是一个<code class="fe lq lr ls lt b">Promise</code>。</li><li id="0e78" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">在<code class="fe lq lr ls lt b">Promise.all</code>中，承诺的顺序保持在values变量中，不管哪个承诺首先被解析。</li></ol><p id="e2bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你对承诺有了概念，看看吧。它有助于您编写可读性更好的代码。如果使用不当，它也有不好的一面。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d6b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步等待的经验法则</h1><p id="7fff" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">以下是我在使用<code class="fe lq lr ls lt b">async</code>和<code class="fe lq lr ls lt b">await</code>时保持理智的经验法则。</p><ol class=""><li id="adca" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">async</code>函数返回承诺。</li><li id="5714" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">async</code>函数使用隐式<code class="fe lq lr ls lt b">Promise</code>返回结果。即使你没有明确地返回一个承诺，T2函数也会确保你的代码通过一个承诺。</li><li id="4153" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">await</code>阻塞<code class="fe lq lr ls lt b">async</code>函数中的代码执行，它(<code class="fe lq lr ls lt b">await statement</code>)是其中的一部分。</li><li id="66fe" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">在一个<code class="fe lq lr ls lt b">async</code>函数中可以有多个<code class="fe lq lr ls lt b">await</code>语句。</li><li id="04dd" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用<code class="fe lq lr ls lt b">async await</code>时，确保使用<code class="fe lq lr ls lt b">try catch</code>进行错误处理。</li><li id="aa52" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">在循环和迭代器中使用<code class="fe lq lr ls lt b">await</code>时要格外小心。您可能会陷入编写顺序执行代码的陷阱，而这本来可以很容易地并行完成。</li><li id="61f6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">await</code>始终为单个<code class="fe lq lr ls lt b">Promise</code>。</li><li id="c3f4" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">Promise</code>创建启动异步功能的执行。</li><li id="4f30" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">await</code>仅阻塞<code class="fe lq lr ls lt b">async</code>函数内的代码执行。它仅确保在<code class="fe lq lr ls lt b">promise</code>解析时执行下一行。所以，如果一个异步活动已经开始，<code class="fe lq lr ls lt b">await</code>不会对它有任何影响。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6880" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我应该使用承诺还是异步等待</h1><p id="619b" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">答案是我们会两者并用。</p><p id="8a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我用来决定何时使用<code class="fe lq lr ls lt b">promises</code>和何时使用<code class="fe lq lr ls lt b">async-await</code>的经验法则。</p><ol class=""><li id="510d" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">async function</code>返回一个<code class="fe lq lr ls lt b">promise</code>。反之亦然。每一个返回一个<code class="fe lq lr ls lt b">promise</code>的函数都可以认为是<code class="fe lq lr ls lt b">async function</code>。</li><li id="37d0" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">await</code>用于调用<code class="fe lq lr ls lt b">async function</code>并等待其到<code class="fe lq lr ls lt b">resolve</code>或<code class="fe lq lr ls lt b">reject</code>。</li><li id="fa6e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe lq lr ls lt b">await</code>阻止代码在其所在的<code class="fe lq lr ls lt b">async</code>函数中执行。</li><li id="0ccc" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果<code class="fe lq lr ls lt b">function2</code>的输出依赖于<code class="fe lq lr ls lt b">function1</code>的输出，我就用<code class="fe lq lr ls lt b">await</code>。</li><li id="d2ae" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果两个功能可以并行运行，创建两个不同的<code class="fe lq lr ls lt b">async functions</code>然后并行运行它们。</li><li id="5299" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">要并行运行承诺，创建一个承诺数组，然后使用<code class="fe lq lr ls lt b">Promise.all(promisesArray)</code>。</li><li id="2ecd" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">每次你使用<code class="fe lq lr ls lt b">await</code>的时候，记住你正在写阻塞代码。随着时间的推移，我们往往会忽略这一点。</li><li id="7be9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">与其创造巨大的<code class="fe lq lr ls lt b">async functions</code>和众多的<code class="fe lq lr ls lt b">await asyncFunction()</code>，不如创造更小的<code class="fe lq lr ls lt b">async functions</code>。这样，我们会意识到不要写太多的阻塞代码。</li><li id="8e08" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用较小的<code class="fe lq lr ls lt b">async functions</code>的另一个好处是，你可以强迫自己考虑哪些异步函数可以并行运行。</li><li id="838b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果你的代码包含阻塞代码，最好让它成为一个<code class="fe lq lr ls lt b">async </code>函数。通过这样做，您可以确保其他人可以异步使用您的函数。</li><li id="6b79" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">通过从阻塞代码中创建异步函数，用户(将调用您的函数)可以决定他们想要的异步级别。</li></ol><p id="fe26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这能帮助你决定什么时候用<code class="fe lq lr ls lt b">promises</code>，什么时候用<code class="fe lq lr ls lt b">async-await</code>。</p><p id="54ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要了解更多这样的经验法则，请加入我们的对话服务器<a class="ae lu" href="https://discord.gg/ENbQbbZy25" rel="noopener ugc nofollow" target="_blank">https://discord.gg/ENbQbbZy25</a>或者在推特上关注我<a class="ae lu" href="https://twitter.com/gokulnk" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gokulnk</a></p><p id="ab20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也可以订阅我的简讯<a class="ae lu" href="https://understandingx.substack.com/" rel="noopener ugc nofollow" target="_blank">https://understandingx.substack.com/</a>我懒得写，所以你可能会有一段时间没有我的消息。</p></div></div>    
</body>
</html>