<html>
<head>
<title>Stop Using Objects as Hash Maps in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在JavaScript中使用对象作为哈希映射</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-objects-as-hash-maps-in-javascript-9a272e85f6a8?source=collection_archive---------0-----------------------#2020-04-14">https://betterprogramming.pub/stop-using-objects-as-hash-maps-in-javascript-9a272e85f6a8?source=collection_archive---------0-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="003c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有一种更好的方法可以做到这一点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/78e540818f2768b30e3c9f6b43063b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PZyaYjBreEds2eeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="54e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">地图是日常编程中最常用的数据结构之一。它保存了键-值对，这些键-值对可以很容易地被它们的键访问。在Java中，使用HashMap来实现这一点是很明显的。然而，在JavaScript中，只使用一个普通对象来实现这个目的是非常方便的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是JavaScript中有一个内置的数据结构就是为了这个目的而设计的:Map。让我给你一些喜欢地图胜过普通物体的理由。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="5fa4" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">1.更多关键类型</h1><p id="6cbc" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">对象只能有符号或字符串。映射可以有任何类型的值作为键:对象、函数或原语。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1fd4" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">2.更好的尺寸测定</h1><p id="22c3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">虽然地图提供了尺寸属性，但是普通对象的尺寸必须通过艰苦的方式来确定。在<em class="nb"> O(1) </em>时间内确定地图的大小是可能的，而对于一个普通的对象则需要<em class="nb"> O(n) </em>步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1dda" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">3.更好的性能</h1><p id="6de8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">映射针对条目的频繁添加和删除进行了优化。</p><p id="d11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且一张地图的条目数可以在常数时间内检索出来，而一个平原物体的条目数必须统计出来，这需要<em class="nb"> O(n) </em>时间。</p><p id="2ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我的Macbook Pro为例，这是一张包含1000万个条目的地图确定大小的平均持续时间:</p><ul class=""><li id="1ad3" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">普通JS对象:~1.6 s</li><li id="65f0" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">地图:&lt; 1毫秒</li></ul><p id="edfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，没有必要将任何键转换为字符串，这可以节省大量时间。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3c7b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">4.直接迭代</h1><p id="3ee3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">必须通过获取键并遍历它们来迭代对象。另一方面，地图是可迭代的，这意味着它可以被直接迭代。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="9eb3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">5.关键订单</h1><p id="dbb2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在ECMAScript 2015之前，不保证对象的键按任何特定顺序排列。对映射进行迭代可以保证键按照插入的顺序出现。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="afc0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">6.没有键覆盖</h1><p id="f360" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">由于原型的原因，一个普通对象已经包含了一些键。您的键和对象已经包含的键之间可能会有冲突。地图在创建时不包含任何键。</p><p id="52c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:从ECMAScript 2015开始，您可以通过使用<code class="fe nq nr ns nt b">Object.create(null)</code>创建您的普通对象映射来避免意外的键覆盖。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="78cb" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="1039" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">使用对象作为哈希映射缺失实现的变通方法的时代已经过去了。对象非常有用，但是当面对典型的哈希映射用例时，它们不再是首选。</p></div></div>    
</body>
</html>