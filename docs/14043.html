<html>
<head>
<title>Thoughts on Software Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于软件体系结构的思考</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/thoughts-on-software-architecture-9c56d18a4e98?source=collection_archive---------0-----------------------#2022-10-30">https://betterprogramming.pub/thoughts-on-software-architecture-9c56d18a4e98?source=collection_archive---------0-----------------------#2022-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么永远不会有一个“纯粹的”架构来统治它们…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd8f7581f5093c411af08576be40af1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lqH-mdhpOsidzOHA7Gaxw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kirkthornton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">柯克·桑顿</a>在<a class="ae ky" href="https://unsplash.com/s/photos/frank-lloyd-wright?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="1a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发人员中有一个学派认为软件架构应该完全独立于它所支持的用户界面。</p><p id="0b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们认为，人们应该能够将任何软件架构放在任何用户界面之上，一切都应该正常工作。</p><p id="ced9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个吸引人的，几乎是诱人的观点…</p><p id="9750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我碰巧认为这是错误的。或者，至少，比这更微妙。</p><p id="492a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读时，请记住，我是从一个iOS应用程序开发人员的角度，特别是从SwiftUI的角度来写这篇文章的，我们讨论的是内部客户端<em class="lv">应用程序</em>架构，而不是后端架构。</p><p id="20df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是故意的，但稍后会详细说明。</p><p id="2fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><h1 id="fd56" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">毒蛇</h1><p id="25e3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/viper-for-swiftui-please-no-ee61ce99694c">写了一篇关于SwiftUI和VIPER的文章</a>,在这篇文章中，我阐述了我认为VIPER不适合作为iOS和Mac上SwiftUI应用程序的架构选择的所有原因。</p><p id="6e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是VIPER背后的核心机制是委托。它被设计成在对象之间传递动作和消息，为了做到这一点，它在每个对象之间维护一组直接的引用。(观点、演示者等。)</p><p id="4d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，VIPER被设计成可以用它的<code class="fe mt mu mv mw b">UIViews</code>和<code class="fe mt mu mv mw b">UIViewControllers</code>整齐地插入UIKit。它是围绕这些对象在内存中的持久化方式和<code class="fe mt mu mv mw b">UIViewController</code>生命周期设计的。</p><p id="9c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是SwiftUI <code class="fe mt mu mv mw b">Views</code>不是<code class="fe mt mu mv mw b">UIViews</code>。它们不是对象，它们没有引用，它们不断被创建和区分，以驱动SwiftUI接口。</p><p id="df14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，虽然你可以用SwiftUI做一些类似于VIPER的工作，但你必须跳过许多关卡，并为此编写大量的代码。</p><p id="effb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如文章中提到的，我看到一个代码库，开发人员被迫向他的VIPER-VM代码添加一个ViewModel，这样他就有地方放置他的可观察值。谈谈胶水代码。</p><p id="e393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多的问题，但不用说，我在那篇文章中提出的所有问题都强调了VIPER架构不适合在SwiftUI中使用。</p><p id="a4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，除非你<em class="lv">喜欢</em>写很多额外的适配器和样板代码。</p><p id="1492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">明白了吗？好吧，我们继续。</p><h1 id="867d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">那不是真正的建筑</h1><p id="7865" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有些人可能会说，像VIPER这样的东西并不是真正的<em class="lv"/>架构，它只是一堆对象，它们的工作是从<em class="lv">真正的</em>架构中获取信息，并将其转化为适合用户界面使用的形式。</p><p id="de76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也不同意这一点。</p><p id="f579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-choosing-an-application-architecture-6ec9289f8e8f">选择应用架构</a>中，我写道，应用架构基本上可以归结为我们用来决定<em class="lv">如何将代码分割成单独组件的规则。为什么那部分在那里<em class="lv">和为什么这部分在这里<em class="lv">和</em>。</em></em></p><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写具有明确定义的角色、行为和责任的类、结构和函数。这是一个观点。那是一个模型。这里的代码是一个提供模型的服务。诸如此类。</p><p id="6596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<em class="lv">这个</em>代码就是从这些服务中获取信息，并将其提供给视图进行显示的代码。而<em class="lv">代码</em>负责执行一组给定的动作，并操纵我们的应用程序的状态。</p><p id="1b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些部分:模型；服务；存储库；视图模型；视图和视图控制器；模块和框架；所有这些组成了我们应用程序的整体架构。</p><p id="5d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会不会指着一栋建筑的地下室说，“那里！那就是<em class="lv">真正的</em>建筑！其余的，地板、房间、出入口和屋顶，这些都不算！”</p><p id="a813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然不是。建筑是一个有凝聚力的整体，建筑是其所有部分的总和。</p><p id="e18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序也是如此。</p><p id="247c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是格式塔。</p><h1 id="d87a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">服务</h1><p id="0218" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当然，你可以走进一个住宅，换掉炉子或热水器。但是这些物品在很大程度上被设计成可互换的。</p><p id="17d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们被设计来为住宅提供特定的服务，并适合其整体建筑中的特定空间。</p><p id="148f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他们需要被替换，我不应该被迫重建整个房子。</p><p id="de18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个精心设计的架构。</p><p id="8fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要记住，这样的服务为应用程序提供服务。他们很少驱动应用程序。</p><h1 id="c763" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">有机建筑</h1><p id="7791" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">弗兰克·劳埃德·赖特可能是美国历史上最著名的建筑师之一，他的指导原则之一是有机建筑。</p><p id="c172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对赖特来说，一座建筑的结构必须与其环境相适应。人们小心翼翼地选择形状、风格和材料。</p><p id="0126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是实际因素也发挥了作用。在北方，房屋通常建有高高的斜屋顶，以更好地遮挡雨雪。它们反映了所处环境的现实。</p><p id="2177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个人可以在西南沙漠建造这样的东西，但目的是什么？它不太适合那种环境，也许更重要的是，这是对稀缺资源的浪费。</p><p id="8274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，在西南地区，我们经常想把水收集起来，而不是简单地把它放掉。</p><p id="6f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这不仅是一个为不同环境设计的解决方案，而且是一个完全<em class="lv">错误</em>的解决方案。</p><h1 id="c93b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">毒蛇，Redux</h1><p id="8817" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">回到VIPER，我们看到它很大程度上不适合在SwiftUI中使用，许多其他常见的架构选择也是如此。</p><p id="1ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在全局应用程序状态中增加一个数字时，使用Redux风格的“整个应用程序的单一数据源”模式可能会导致SwiftUI中的性能和更新问题，现在需要检查整个应用程序视图树以查看需要更新和呈现的内容。</p><p id="19b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他的设计是为了解决Swift以外的语言中固有的问题。</p><p id="7397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，不可变数据和数据流旨在防止基于引用类型的语言发生变化，并且不具备Swift的写时复制语义。参见<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-case-against-immutable-objects-88343bbd7912">Swift中反对不可变对象的案例</a>了解更多</p><p id="d98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以继续说下去，但我想你已经开始明白了。</p><h1 id="dfd4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">UIKit</h1><p id="873d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在许多方面，UIKit强化了我们的“架构”和用户界面代码之间有一个清晰界限的想法。</p><p id="4543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户可以自由选择VIPER、MVP、MVVM、Clean，甚至是完整的RxSwift数据流。</p><p id="9840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，架构和用户界面之间的界限看起来清晰明确。架构是我们在UIKit上添加的所有其他东西。</p><p id="4b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是几乎所有的选择都是为了配合UIKit而设计的。他们需要引用类型、目标和委托。他们期望视图和视图控制器能够持久。</p><p id="a962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人生活在一个命令式的世界里。</p><p id="1ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是世界已经变了。</p><h1 id="3166" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">斯威夫特伊</h1><p id="0fda" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">SwiftUI是声明性的，而不是命令性的，因此它对如何构造和管理“视图”有自己的看法。</p><p id="9d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它固执地认为某个特定元素的状态只有一个真实的来源。</p><p id="8375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它坚持将这种状态绑定在尽可能低的层次结构中，以最小化过多的视图更新周期和渲染。</p><p id="7d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它坚持认为状态应该如何用<code class="fe mt mu mv mw b">@State</code>和<code class="fe mt mu mv mw b">@Binding</code>属性包装器表示，如何定义和使用<code class="fe mt mu mv mw b">ObservableObjects</code>，以及如何通过组合接收事件和更新。</p><p id="ef4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它甚至开始表达对任务的偏好，并使用async/await。</p><p id="d2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">忽略这些意见，你最终会让<em class="lv">与</em>swift ui看待世界的方式背道而驰，最糟糕的是一个完全功能失调的应用程序。</p><p id="3c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">世界，环境，都变了。</p><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我不断回到特定架构与SwiftUI配合得有多好的原因。</p><p id="7d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为如果它<em class="lv">跟swift ui</em>配合不好，真的能通用吗？我真的可以把以前为UIKit设计的任何架构打包到SwiftUI上，并期待一个不错的结果吗？</p><p id="6024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想我已经相当明确地证明了你不能。</p><p id="7c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当世界改变时，架构也需要改变。</p><h1 id="5db1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">平台无关的服务</h1><p id="7c23" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">但是尽管如此，我们也应该尽最大努力防止我们的用户界面选择渗透到我们的业务逻辑和服务层。</p><p id="0998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我可以创建以下服务…</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="bfd5" class="nb lx it mw b gy nc nd l ne nf">class AccountLoadingService: ObservableObject {<br/>    @Published var accounts: [Account] = []<br/>    func load() async throws {<br/>        // logic goes here<br/>    }<br/>}</span></pre><p id="83a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这样做的时候，我已经让SwiftUI惯例和期望融入了我的加载服务。最好是…</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="89ca" class="nb lx it mw b gy nc nd l ne nf">struct BetterAccountLoadingService {<br/>    func load() async throws -&gt; [Account] {<br/>        // logic goes here<br/>    }<br/>}</span></pre><p id="e566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，没有理由让它成为一个类，它提供了一个简单的接口，仍然可以很容易地从SwiftUI <code class="fe mt mu mv mw b">.task</code>处理程序中访问。</p><p id="96bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它使得从另一个服务、从一个视图模型甚至从一个UIKit组件使用服务变得更加容易。并不是我打算这么做。这只是认识到这样一个事实:有一天需求或环境可能会改变，我可能需要这样做。</p><p id="5cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果一开始就没有必要，最好不要把自己逼入困境。</p><p id="e190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，请记住，更好的选择是让我们的服务成为一个协议，以使模拟和测试更加容易。更不用说在我们的数据源发生变化的情况下保护我们的应用程序。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="22f2" class="nb lx it mw b gy nc nd l ne nf">protocol AccountLoader {<br/>    func load() async throws -&gt; [Account]<br/>}</span><span id="2902" class="nb lx it mw b gy ng nd l ne nf">struct EvenBetterAccountLoadingService: AccountLoader {<br/>    func load() async throws -&gt; [Account] {<br/>        // logic goes here<br/>    }<br/>}</span></pre><h1 id="e2f5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">体系结构</h1><p id="e78a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Clean Architecture中，Robert Martin写了许多我们今天使用的设计原则，比如SOLID，他还写了我们的应用程序中对边界和层的需求。</p><p id="024d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里也是如此。</p><p id="948b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，并非SwiftUI应用程序中的所有东西都需要知道SwiftUI是我们正在使用的用户界面。事实上，我们的大多数模型和服务、网络和身份验证层以及数据存储应该都没有意识到这个事实。</p><p id="0a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现实情况是我们已经在编写一个iOS应用程序。我们<em class="lv">已经</em>使用Swift和SwiftUI。</p><p id="3bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经做出了选择。</p><p id="f5ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们的<em class="lv">其他</em>架构选择必须嵌入该平台并与该环境集成。</p><p id="03b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们归结到这样一个问题:这种集成需要做多少工作？我们需要多少“胶水”？这些选择是<em class="lv">与</em>我们的环境合作，还是<em class="lv">与</em>环境对抗？</p><p id="a13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-choosing-an-application-architecture-6ec9289f8e8f"> SwiftUI:选择应用架构</a>中，我在文章结尾列出了我选择SwiftUI架构的标准:</p><ol class=""><li id="128d" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">无论应用程序大小如何，它都必须是高性能的。</li><li id="3ea2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">它必须与SwiftUI行为和状态管理兼容。</li><li id="da6e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">它应该简洁、轻量、适应性强、灵活。</li><li id="87ca" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">它鼓励SwiftUI视图合成。</li><li id="e57a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">它支持测试。</li></ol><p id="11fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，它让SwiftUI成为SwiftUI。</p><p id="aec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">弗兰克·劳埃德·赖特多次说过，建筑永远不应该脱离环境而独立存在。</p><p id="6394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我倾向于同意。人们需要为手头的工作选择合适的架构、合适的工具。</p><h1 id="6ef7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">完成块</h1><p id="b108" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个可能会有点争议，所以继续吧。</p><p id="fdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我知道你的想法。</p></div></div>    
</body>
</html>