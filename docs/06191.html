<html>
<head>
<title>3 Small Solutions to Help With Swift Codable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有助于Swift Codable的3个小解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-solutions-help-you-swift-codable-cfd8de188676?source=collection_archive---------13-----------------------#2020-09-08">https://betterprogramming.pub/3-solutions-help-you-swift-codable-cfd8de188676?source=collection_archive---------13-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定制您的可编码实现以适应不同的高级场景</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4503ecae5ff4b3626f9457e1ac4436c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X53hGALe8__GbMq_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@einfachlaurenz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Laurenz Heymann </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="39e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift 4引入了<code class="fe lv lw lx ly b">Codable</code>协议来解码/编码JSON对象。<code class="fe lv lw lx ly b">Codable</code>紧密集成到Swift工具链中。在客户端和服务器端Swift上广泛使用。</p><p id="791e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们会遇到一些挑战，需要我们定制如何使用<code class="fe lv lw lx ly b">Codable</code>来适应不同的高级场景。这里是我在使用<code class="fe lv lw lx ly b">Codable</code>和我的干净代码解决方案时遇到的三个严峻挑战。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7774" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">同一个键有多个值类型</h1><h2 id="5ca3" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">假设的API</h2><p id="8569" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">考虑一个假设的API，它有时返回一个<code class="fe lv lw lx ly b">String</code>，有时为键<code class="fe lv lw lx ly b">id</code>返回一个<code class="fe lv lw lx ly b">Int</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的多重类型</p></figure><p id="68ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见和最直接的解决方案是使用Enum来映射不同的情况。我们有干净的代码解决方案来避免它引入的样板文件吗？</p><h2 id="e89d" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">干净代码解决方案</h2><p id="248f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了减少样板文件并生成干净的代码，我使用了<code class="fe lv lw lx ly b">PropertyWrapper</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的CodableValue.swift</p></figure><p id="d759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一点一点地分解代码:</p><ul class=""><li id="aa42" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">LosslessStringCodable</code>协议是<code class="fe lv lw lx ly b">LosslessStringConvertible</code>和<code class="fe lv lw lx ly b">Codable</code>协议的组合。对于任何可以字符串转换的类型，它都可以使用泛型类型<code class="fe lv lw lx ly b">T</code>。</li><li id="2a92" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DynamicCoder</code>接受通用类型<code class="fe lv lw lx ly b">LosslessStringCodable</code>。它可以解码不同的类型，包括<code class="fe lv lw lx ly b">String</code>、<code class="fe lv lw lx ly b">Bool</code>、<code class="fe lv lw lx ly b">Int</code>、<code class="fe lv lw lx ly b">Double</code>到<code class="fe lv lw lx ly b">LosslessStringCodable</code>类型。它可以很容易地扩展到其他类型。</li><li id="937e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">CodableValue</code>是一个属性包装器，它将<code class="fe lv lw lx ly b">wrappedValue</code>解码和编码成所需的泛型类型。</li></ul><h2 id="ca8e" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">示例使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的User.swift</p></figure><p id="df59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">struct <code class="fe lv lw lx ly b">User</code>使用ID作为<code class="fe lv lw lx ly b">String</code>值的<code class="fe lv lw lx ly b">CodableValue</code>属性包装器，但是它当然可以用作其他类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8bf6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">动态键</h1><h2 id="9221" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">假设的API</h2><p id="4bf4" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">考虑一个假设的API，它按顺序返回JSON对象作为键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的DynamicKeys.json</p></figure><h2 id="2a1a" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">干净代码解决方案</h2><p id="f1fa" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">使用字典来解码JSON将是一个合适的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的Customer.swift</p></figure><h2 id="9670" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">示例使用</h2><p id="cfa0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">将JSON转换为数据，并使用<code class="fe lv lw lx ly b">JSONDecoder</code>对其进行解码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的《解码.雨燕》</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c678" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">具有协议属性的可编码结构</h1><h2 id="40cb" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">假设的API</h2><p id="a4ee" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">考虑一个假设的API，它返回具有不同类型<code class="fe lv lw lx ly b">Article</code>和<code class="fe lv lw lx ly b">Brief</code>的已发布片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的Publications.json</p></figure><h2 id="6328" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">干净代码解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的PublicationMapper.swift</p></figure><p id="fbd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解代码:</p><ul class=""><li id="d4ff" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">PublicationType</code>包含两种情况:<code class="fe lv lw lx ly b">Article</code>和<code class="fe lv lw lx ly b">Brief</code>。最重要的部分是它根据情况返回不同的结构类型。</li><li id="b764" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">PublicationMapper</code>具有值<code class="fe lv lw lx ly b">publication</code>和映射协议类型的隐藏值<code class="fe lv lw lx ly b">metatype</code>。</li><li id="842c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">PublicationMapper</code>实现编码器功能，将<code class="fe lv lw lx ly b">publication</code>编码为特定的结构类型。</li><li id="62df" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">PublicationMapper</code>还实现了decoder函数，通过检测元类型将JSON解码成特定的struct类型。</li></ul><h2 id="7650" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">示例使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的《共和报》</p></figure><p id="7516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用定制的<code class="fe lv lw lx ly b">CodingKeys</code>和编码器/解码器功能实现<code class="fe lv lw lx ly b">publican</code>结构，以将特定结构映射到<code class="fe lv lw lx ly b">contents</code>数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杨梦的《解码.雨燕》</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8c2d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="0831" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">Codable</code>使得使用JSON序列化更加容易。如果你感兴趣，我发表了另一篇关于Codable和SwiftyJSON比较的文章。</p><p id="0aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文提到的所有代码都可以在GitHub 上找到<a class="ae ky" href="https://gist.github.com/ericleiyang/2bc5a1545ffcab83fe0d9c2a5563f6ae" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>