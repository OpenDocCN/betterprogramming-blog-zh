<html>
<head>
<title>Learn Solidity: Variables (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:变量(第二部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-variables-part-2-f3b842f5bfb8?source=collection_archive---------9-----------------------#2020-11-10">https://betterprogramming.pub/learn-solidity-variables-part-2-f3b842f5bfb8?source=collection_archive---------9-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f353" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据存储如何工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8656985ddaef7730e27833e5e7c19d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zin3TSB_CZ0kyM9GjNh5vA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰西·奥里科在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c1c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎阅读学习可靠性系列的另一篇文章。正如我在<a class="ae kv" href="https://wissal-haji.medium.com/learn-solidity-variables-part-1-657fc27c2cc1" rel="noopener">的上一篇文章</a>中承诺的，我们将看到数据存储如何在Solidity中工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="42ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">以太坊虚拟机(EVM)</h1><p id="859c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在讲<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>中的数据存储之前，我先介绍几个关于以太坊虚拟机的事情，让事情更清晰。</p><p id="23f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">EVM的内部运作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/18e539d983294decc91d0ac87a054be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eu0Qc3cFEplmA8_3dERP9g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">fullstacks.org EVM背景(图片来源:<a class="ae kv" href="https://fullstacks.org/materials/ethereumbook/14_evm.html" rel="noopener ugc nofollow" target="_blank"/>)</p></figure><p id="f39b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们安装以太坊客户端时，它会附带EVM，这是一个轻量级的操作系统，专门用于运行智能合约。EVM的架构基于一个<a class="ae kv" href="https://igor.io/2013/08/28/stack-machines-fundamentals.html" rel="noopener ugc nofollow" target="_blank">堆栈机器</a>的模型，这意味着指令集被设计为使用一个堆栈而不是<a class="ae kv" href="https://en.wikipedia.org/wiki/Processor_register" rel="noopener ugc nofollow" target="_blank">寄存器</a>。黄皮书中描述了EVM <a class="ae kv" href="https://en.wikipedia.org/wiki/Opcode" rel="noopener ugc nofollow" target="_blank">操作码</a>的列表，可以在<a class="ae kv" href="https://github.com/crytic/evm-opcodes" rel="noopener ugc nofollow" target="_blank">以太坊VM (EVM)操作码和指令参考</a>中找到</p><p id="9d5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码执行如下开始:当事务导致智能合约代码执行时，EVM被实例化，并且EVM的ROM加载有被调用的合约的代码。将程序计数器设置为零，从合同帐户的存储中加载存储，将内存全部设置为零，并设置所有块和环境变量。然后代码被执行。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b73c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">数据位置</strong></h1><p id="f857" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在让我们回到记忆关键词，正如<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/types.html#data-location" rel="noopener ugc nofollow" target="_blank"> Solidity文档</a>中提到的。从版本0.5.0开始，所有复杂类型都必须给出一个明确的数据存储位置，有三个数据位置:<code class="fe mx my mz na b">memory</code>、<code class="fe mx my mz na b">storage</code>和<code class="fe mx my mz na b">calldata</code>。</p><p id="00b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>唯一可以省略数据位置的地方是状态变量，因为它们总是存储在帐户的存储器中。</p><p id="3dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.<strong class="ky ir"> </strong> <code class="fe mx my mz na b"><strong class="ky ir">storage</strong></code></p><ul class=""><li id="9bb9" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe mx my mz na b">storage</code>中的数据被永久保存。存储是一个键值存储。</li><li id="1ca6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe mx my mz na b">storage</code>中的数据被写入区块链(因此它们改变了状态)，这就是为什么存储使用起来非常昂贵。</li><li id="ed3f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">占据一个256位的槽要花费2万<a class="ae kv" href="https://ethereum.org/en/developers/docs/gas/" rel="noopener ugc nofollow" target="_blank">气</a>。</li><li id="c198" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">改变一个已经被占用的槽的值花费5000汽油。</li><li id="8f4e" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">当清除存储槽(即，将非零字节设置为零)时，会退还一定量的气体。</li><li id="b9ba" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">存储器将数据保存在256位大小的字段中(32字节=字)。每个使用的插槽都会产生成本，即使它没有被完全占用。</li></ul><p id="a5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir"> </strong> <code class="fe mx my mz na b"><strong class="ky ir">memory</strong></code></p><ul class=""><li id="8f31" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe mx my mz na b">memory</code>是一个字节数组，槽大小为256位(32字节)。这里，数据仅在函数执行期间存储。之后，它们会被删除。他们没有被拯救到区块链。</li><li id="41c1" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">读或写一个字(256位)要花3个气。</li><li id="66e4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">为了避免矿工过多的工作，在22次操作后，每次操作的成本开始上升。</li></ul><p id="5f3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir"> </strong> <code class="fe mx my mz na b"><strong class="ky ir">calldata</strong></code></p><ul class=""><li id="5b32" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe mx my mz na b">calldata</code>是一个不可修改的、非持久的存储函数参数的区域，它的行为很像<code class="fe mx my mz na b">memory</code>。</li><li id="f5b6" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe mx my mz na b">calldata</code>是<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/contracts.html#visibility-and-getters" rel="noopener ugc nofollow" target="_blank">外部函数</a>的参数所必需的，但也可用于其他变量。</li><li id="5ee8" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">它避免了拷贝，也确保了数据不能被修改。</li><li id="5820" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">带有<code class="fe mx my mz na b">calldata</code>数据位置的数组和结构也可以从函数中返回，但是不能分配这样的类型。</li></ul><h2 id="4d26" class="np ma iq bd mb nq nr dn mf ns nt dp mj lf nu nv ml lj nw nx mn ln ny nz mp oa bi translated">数据位置和分配行为</h2><p id="edda" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您不想出现意外行为，那么理解数据位置分配的工作方式非常重要。</p><p id="a2fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分配之间应用以下规则:</p><ul class=""><li id="7322" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">在<code class="fe mx my mz na b">storage</code>和<code class="fe mx my mz na b">memory</code>(或来自<code class="fe mx my mz na b">calldata</code>)之间的分配总是创建一个独立的副本。</li><li id="9412" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">从<code class="fe mx my mz na b">memory</code>到<code class="fe mx my mz na b">memory</code>的分配仅创建参考。这意味着对一个内存变量的更改在引用相同数据的所有其他内存变量中也是可见的。</li><li id="bfc2" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">从<code class="fe mx my mz na b">storage</code>到本地存储变量的赋值也只分配一个引用。</li><li id="f30e" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">所有其他分配给<code class="fe mx my mz na b">storage</code>的任务总是复制。这种情况的例子是对状态变量或<code class="fe mx my mz na b">storage</code>结构类型的局部变量成员的赋值，即使局部变量本身只是一个引用。</li></ul><p id="9eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用<a class="ae kv" href="https://remix-ide.readthedocs.io/en/latest/debugger.html" rel="noopener ugc nofollow" target="_blank"> Remix调试器</a>更详细地检查一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="76d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新文件，复制上面的代码，然后部署契约。<br/>现在尝试调用函数<code class="fe mx my mz na b">foo</code>。您将在控制台中看到事务的详细信息，在它旁边有一个debug按钮。点击它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/72a80e1980f0a65a628e4d8a5ac62d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7whz-mrivPuoWg0CjC1Hg.png"/></div></div></figure><p id="dde0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您应该会看到如下所示的调试器区域:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/36df9cbcc37266316b92d50ae45d9726.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*lzJmPncaxzpBuvfgalWg4w.png"/></div></figure><p id="477d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要跳过代码，请单击我选择的红色箭头。</p><p id="9b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该注意的第一件事是<code class="fe mx my mz na b">storage</code>装载了<code class="fe mx my mz na b">stateVar</code>的内容，正如我们在EVM部分提到的，当然没有局部变量。</p><p id="7447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你单步执行时，你应该看到变量<code class="fe mx my mz na b">y</code>出现在局部变量(实性局部变量)部分。继续往下走，你会注意到，为了分配必要的内存空间和从<code class="fe mx my mz na b">storage</code>加载每个单词，然后在<code class="fe mx my mz na b">memory</code>中复制它，需要很多字节码。这意味着要支付更多的汽油，因此从<code class="fe mx my mz na b"> storage</code>到<code class="fe mx my mz na b">memory</code>的分配是昂贵的。</p><p id="d1e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查第二种情况:从<code class="fe mx my mz na b">memory</code>到<code class="fe mx my mz na b">storage</code>的赋值。<br/>当您完成了对保存在<code class="fe mx my mz na b">memory</code>中的副本的修改，并且您想将修改保存回<code class="fe mx my mz na b"> storage</code>时，可以使用它。也很耗气；17，083气体，如果我们从调试器计算步骤细节部分指示的剩余气体的差异。该操作使用了四个存储操作码:第一个用于存储保持不变的数组大小(消耗800 gas)，另外三个用于更新数组的值(每个消耗5,000 gas)。</p><p id="b1ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来看第三种情况:从仓库到仓库的分配。这一次创建了一个新的局部变量，它包含了与<code class="fe mx my mz na b">stateVar</code>相同的内容。如果我们查看代码执行，我们会注意到Solidity所做的是将包含数组长度的第一个存储槽的地址推入。根据<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.6.8/internals/layout_in_storage.html#mappings-and-dynamic-arrays" rel="noopener ugc nofollow" target="_blank">文档</a>，对于动态数组，包含数组长度的槽的位置用于计算包含数组数据的槽的位置。</p><p id="13fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们现在比较一下将数据复制到<code class="fe mx my mz na b">memory</code>，然后更新数据并将其复制回存储器的成本(21，629 gas)与创建引用并直接更新状态的成本(5，085 gas)，很明显第二种方法要便宜得多。</p><p id="01b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们像这样直接更新状态变量会怎么样呢:</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="60b0" class="np ma iq na b gy oj ok l ol om">stateVar[0] = 12;</span></pre><p id="2d14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也有可能。但是如果您正在处理映射和嵌套数据类型(正如我们将在后面看到的)，使用<code class="fe mx my mz na b">storage</code>指针可以产生更可读的代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="aef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这篇文章简短，并且不会让您被过多的信息淹没，我决定将复杂的变量留到下一篇文章中。我希望这篇文章对你有用，和往常一样，如果你想了解更多，请继续关注即将到来的文章。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="506e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><div class="on oo gp gr op oq"><a href="https://dlt-repo.net/storage-vs-memory-vs-stack-in-solidity-ethereum/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">Solidity和以太坊中的存储与内存和堆栈- DLT-Repo</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">在本文中，我们将重点讨论以太坊中存储、内存和堆栈之间的区别。我们也将给出一个实度…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">dlt-repo.net</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kp oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://fullstacks.org/materials/ethereumbook/14_evm.html" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">以太坊虚拟机</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">编辑描述</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">fullstacks.org</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe kp oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://ethereum.org/en/developers/docs/gas/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">汽油和费用| ethereum.org</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk">░░░░░░░░░▄░░░░░░░░░░░░░░▄░░░░ ░░░░░░░░▌▒█░░░░░░░░░░░▄▀▒▌░░░ ░░░░░░░░▌▒▒█░░░░░░░░▄▀▒▒▒▐░░░ ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐░░░…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">ethereum.org</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe kp oq"/></div></div></a></div></div></div>    
</body>
</html>