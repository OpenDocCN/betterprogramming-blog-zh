<html>
<head>
<title>Why You Should Avoid Testing React Components With Test IDs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该避免用测试id测试React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-avoid-testing-react-components-with-test-ids-ee50d20d37d2?source=collection_archive---------0-----------------------#2021-12-20">https://betterprogramming.pub/why-you-should-avoid-testing-react-components-with-test-ids-ee50d20d37d2?source=collection_archive---------0-----------------------#2021-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何测试它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6992c6721d90373665df19a8fc231d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bd7UX4O4EL3clA4mFxeLEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@laughayette?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Marten Newhall </a>在<a class="ae ky" href="https://unsplash.com/s/photos/magnifying-glass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>是一个流行的库，通过不同的实用程序来方便前端组件测试。如果您熟悉它，那么您也熟悉<code class="fe lv lw lx ly b">getByTestId</code>——这是一种在DOM中定位元素以断言其存在的非常方便的方法。当我第一次学习测试React组件时，<code class="fe lv lw lx ly b">getByTestId</code>是我的首选。只需在元素中添加一个<code class="fe lv lw lx ly b">data-testid</code>属性，并在测试中查询它。它可能看起来像这样:</p><h2 id="5aea" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">成分</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="7234" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">试验</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，对于向用户显示的<code class="fe lv lw lx ly b">title</code>，这到底告诉了我们什么呢？没什么。我们只是断言标题元素存在。这个值可以是任何值，当然不是用户期望的值。</p><p id="693e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Project</code>组件的父组件的上下文中，这个测试可能更有意义，在父组件中，我们可能希望通过查询上面的标题来断言一个项目已经被加载。不管怎样，这个值可以是任何值，我们的测试仍然会通过。</p><p id="66cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们测试我们的React组件时，<a class="ae ky" href="https://twitter.com/kentcdodds/status/977018512689455106" rel="noopener ugc nofollow" target="_blank">我们应该以用户与它们交互的相同方式测试它们，从而检查它们将看到的值或它们将执行的动作。用户对数据属性或<code class="fe lv lw lx ly b">classNames</code>不感兴趣。测试库的创建者自己提倡用除了<code class="fe lv lw lx ly b">data-testid</code>之外的各种方式查询元素，如果可能的话:</a></p><blockquote class="mu mv mw"><p id="b93d" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">根据<a class="ae ky" href="https://testing-library.com/docs/guiding-principles" rel="noopener ugc nofollow" target="_blank">指导原则</a>的精神，建议仅在<strong class="lb iu">其他查询</strong>对您的用例不起作用后使用。使用data-testid属性与软件的使用方式并不相似，如果可能的话应该避免使用。<br/> <a class="ae ky" href="https://testing-library.com/docs/queries/bytestid/" rel="noopener ugc nofollow" target="_blank">测试库</a></p></blockquote><p id="5423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个<code class="fe lv lw lx ly b">Project</code>组件的消费者将项目的描述作为它的<code class="fe lv lw lx ly b">title</code>道具传入。上面的测试仍然会通过，因为有<code class="fe lv lw lx ly b">data-testid</code>存在。</p><p id="a9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个问题与<code class="fe lv lw lx ly b">data-testid</code>并不相似。通过使用<code class="fe lv lw lx ly b">className</code>或自定义属性进行测试，您可能会发现自己处于类似的情况。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="ec5f" class="ni ma it bd mb nj nk nl me nm nn no mh jz np ka mk kc nq kd mn kf nr kg mq ns bi translated">"其他查询"</h1><p id="5545" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">这个测试库文档提到使用<code class="fe lv lw lx ly b">data-testid</code>应该是最后的手段。但是这里需要注意的是，使用它并不总是一件坏事，它只是取决于你使用它的目的。例如，运行基于<code class="fe lv lw lx ly b">data-testid</code>的存在显示标题的断言并不理想，但是假设您只想获取元素，然后对其执行某个操作，可能是一个点击事件。这没有任何风险。与上面的例子不同，您的测试并不是基于此而通过或失败的。您将在下面看到一个例子，说明这个属性特别有用并且没有风险。</p><p id="a885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有其他场景，我的目标是使用文档中提到的那些<a class="ae ky" href="https://testing-library.com/docs/queries/about/#priority" rel="noopener ugc nofollow" target="_blank">其他查询</a>进行测试——从每个人都可以访问的查询开始，其中包括<code class="fe lv lw lx ly b">getByRole</code>、<code class="fe lv lw lx ly b">getByLabelText</code>、<code class="fe lv lw lx ly b">getByText</code>。</p><h1 id="19e1" class="ni ma it bd mb nj ny nl me nm nz no mh jz oa ka mk kc ob kd mn kf oc kg mq ns bi translated">getByRole</h1><p id="c115" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">对<code class="fe lv lw lx ly b">button</code>元素特别有用的是，还有<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles" rel="noopener ugc nofollow" target="_blank">许多其他的元素</a>你可以通过它们的角色来查询，heading就是其中之一。根据测试库，这应该是你的首选，因为你可以用它来查询任何东西。</p><h1 id="024a" class="ni ma it bd mb nj ny nl me nm nz no mh jz oa ka mk kc ob kd mn kf oc kg mq ns bi translated">getByLabelText</h1><p id="c500" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">对表单特别有用，但是它们也拾取<code class="fe lv lw lx ly b">aria-label</code>属性。</p><h1 id="a139" class="ni ma it bd mb nj ny nl me nm nz no mh jz oa ka mk kc ob kd mn kf oc kg mq ns bi translated">getByText</h1><p id="f8f3" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在查找非交互式元素(如div、跨度和段落)时非常有用。</p><p id="db38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">byText</code>在上面的例子中是一个很好的选择。这将表明用户看到的是想要的标题。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="9435" class="ni ma it bd mb nj nk nl me nm nn no mh jz np ka mk kc nq kd mn kf nr kg mq ns bi translated">你能走多低？</h1><p id="da70" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我前面提到过，当实际数据是错误的时候，基于测试通过的<code class="fe lv lw lx ly b">data-testid</code>的不必要行为与这个属性并不相似。您认为这也可能发生在通过<code class="fe lv lw lx ly b">aria-label</code>查询时(如果您为它提供一个固定的硬编码值)。</p><p id="6e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要测试一个颜色选择器(想象一下类似于<code class="fe lv lw lx ly b">Pages</code>或<code class="fe lv lw lx ly b">Microsoft Word</code>中的内容，其中我们有一个不同颜色的列表，但是我们在选择器中的不同位置还有一个“收藏夹”或“最近使用的”颜色部分。我们想测试当从选择器中选择一种颜色时，它会被添加到最近使用的部分。为了实现这一点，我们自动假设在选取器中相同的颜色会出现两次(一次在所有颜色的总列表中，一次在最近使用的部分)。因此，确保我们查询最近使用的部分本身来检查颜色的存在可能是值得的。</p><p id="c5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我最喜欢的问题——<code class="fe lv lw lx ly b">within</code></p><p id="1213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/api-within/" rel="noopener ugc nofollow" target="_blank">within</a></code>允许您检查某些元素<em class="mx">是否存在于</em>其他元素中。这可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe lv lw lx ly b">within</code>,我们提高了精确度，并模拟了用户的行为。这给错误留下了很小的空间。</p><p id="6f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前也提到过，有些情况下<code class="fe lv lw lx ly b">getByTestId</code>并不那么危险。上面的测试就是其中之一。我通过它的<code class="fe lv lw lx ly b">data-testid</code>获取一个元素，然后更深入地搜索它的子元素，但是我的测试并没有根据这个部分本身通过或失败。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="ee38" class="ni ma it bd mb nj nk nl me nm nn no mh jz np ka mk kc nq kd mn kf nr kg mq ns bi translated">摘要</h1><p id="0163" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">以用户与组件交互的方式测试我们的组件是很重要的，这包括检查预期的数据，并避免使用它们的<code class="fe lv lw lx ly b">data-testid</code>属性。虽然在某些情况下这是不可避免的，但是如果我们碰巧传入了不正确的信息，那么使用这些属性测试数据的存在性可能会导致错误的通过。</p><p id="910a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试库的文档建议大多数时候使用<code class="fe lv lw lx ly b">getByRole</code>,因为如果它们是可访问的，这将挑选出大多数元素，其中<code class="fe lv lw lx ly b">getByText</code>和<code class="fe lv lw lx ly b">getByLabelText</code>非常有用。如果我们想非常精确地检查某些项目是否嵌套在某些元素中，我们可以利用<code class="fe lv lw lx ly b">within</code>助手来提高精确度。</p></div></div>    
</body>
</html>