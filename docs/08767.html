<html>
<head>
<title>How To Scale Your Analysis To Handle Very Large Datasets in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中缩放您的分析以处理非常大的数据集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-scale-your-analysis-to-handle-very-large-datasets-in-python-5ab4a84a52dc?source=collection_archive---------6-----------------------#2021-06-09">https://betterprogramming.pub/how-to-scale-your-analysis-to-handle-very-large-datasets-in-python-5ab4a84a52dc?source=collection_archive---------6-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫、NumPy、Xarray和lists的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d14f03889c9ca90700b1f03eb0c4d3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VCoyRprc4zItJuRu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米街</a>拍照。</p></figure><p id="666c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常处理太大而不适合内存的数据，如果您需要所有数据来计算平均值，这可能是一个问题。我在处理大型集合模型时经常遇到这个问题，这些模型可能有几十甚至几百千兆字节的数据。有一个工具极大地提高了我的工作效率，让我能够高效地使用Python处理如此大的数据集，这就是Dask。</p><p id="8bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在展示如何通过在分析数据之前“分块”数据来使用Dask提高可伸缩性。我将提供常用数据类型的例子。</p><h2 id="b835" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">目录</h2><ul class=""><li id="02e0" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="#0a94" rel="noopener ugc nofollow">安装</a></li><li id="a38b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#8852" rel="noopener ugc nofollow">熊猫数据框</a></li><li id="bac6" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#8640" rel="noopener ugc nofollow"> NumPy数组</a></li><li id="7bfa" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#c94e" rel="noopener ugc nofollow"> Xarray数据集</a></li><li id="a3a3" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#9637" rel="noopener ugc nofollow"> Dask包</a></li><li id="9c07" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#49e0" rel="noopener ugc nofollow">最终想法</a></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="0a94" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">装置</h1><p id="294d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Dask可以通过<code class="fe nz oa ob oc b">pip</code>、<code class="fe nz oa ob oc b">conda</code>安装或从源头安装<a class="ae ky" href="https://docs.dask.org/en/latest/install.html" rel="noopener ugc nofollow" target="_blank">。如果你使用<code class="fe nz oa ob oc b">conda</code>，Dask和</a><a class="ae ky" href="https://conda-forge.org/" rel="noopener ugc nofollow" target="_blank"> conda-forge </a>一样保持在默认频道。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="c474" class="lv lw it oc b gy oh oi l oj ok">conda install dask</span></pre><p id="8395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将安装Dask及其任何依赖项。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="8852" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">熊猫数据框</h1><p id="618b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们中的许多人都乐于和熊猫一起工作。然而，当数据变得非常大时，熊猫就崩溃了。Dask提供了一种处理这种情况的方法，只需对现有代码做最小的改动。</p><p id="75fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是Dask如何扩展传统<code class="fe nz oa ob oc b">DataFrames</code>的一个小例子，用一个小<code class="fe nz oa ob oc b">DataFrame</code>来说明这个概念。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="593e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我从用合成数据填充<code class="fe nz oa ob oc b">DataFrame</code>开始。然后我使用<code class="fe nz oa ob oc b">from_pandas()</code>函数将它转换成一个<a class="ae ky" href="https://docs.dask.org/en/latest/dataframe.html" rel="noopener ugc nofollow" target="_blank">Dask</a>T1】。Dask <code class="fe nz oa ob oc b">DataFrame</code>不是一个新的数据类型，只是一群小熊猫<code class="fe nz oa ob oc b">DataFrames</code>。这些较小的帧中的每一个都被称为“组块”，其数量由<code class="fe nz oa ob oc b">npartitions</code>决定。在这里，我选择了块的数量，以便每个较小的帧是一个独特的年份。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/24c030cbcfbfb17cefb90a9bc416f443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJe1LSYN21Mx1WrDrXB9_Q@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dask数据帧示意图(图片由作者提供)</p></figure><p id="c249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我进行分析，就像我在熊猫身上做的那样。然而，Dask懒洋洋地命令<a class="ae ky" href="https://towardsdatascience.com/what-is-lazy-evaluation-in-python-9efb1d3bfed0" rel="noopener" target="_blank"><em class="oo"/></a>，这意味着在调用<code class="fe nz oa ob oc b">compute()</code>函数之前，实际上不进行任何计算。尽管数据被分割成块，Dask会处理与计算相关的所有开销。</p><h2 id="843d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">组块并不总是有用的</h2><p id="ba53" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">上面的例子足够小，可以很容易地加载到内存中，而不需要分块。在这种情况下，Dask可能会对我们造成伤害，并降低我们的计算速度，因为大部分时间可能都花在了阅读每个小的<code class="fe nz oa ob oc b">DataFrame</code>上。真正的增强发生在pandas崩溃的情况下，例如对于无法放入内存的非常大的数据集。在这种情况下，一个大块的Dask <code class="fe nz oa ob oc b">DataFrame</code>可能是个不错的选择。</p><p id="0e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Dask <code class="fe nz oa ob oc b">DataFrames</code>的更多信息可以在<a class="ae ky" href="https://docs.dask.org/en/latest/dataframe.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="8640" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">数字阵列</h1><p id="9096" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">一个<a class="ae ky" href="https://docs.dask.org/en/latest/array.html" rel="noopener ugc nofollow" target="_blank"> Dask阵列</a>由许多小NumPy阵列组成，类似于一个Dask <code class="fe nz oa ob oc b">DataFrame</code>由许多小熊猫<code class="fe nz oa ob oc b">DataFrames</code>组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/87d404a31f6843cc0eb3a4ba75569883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KSOmVmNf8QsdMD0JYuIaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我创建了一个50000 x 50000的大型随机值Dask数组。该数组被分成100个较小的NumPy数组，每个数组的尺寸为5000 x 5000。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a04f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我在第一维上取平均值(即<em class="oo">轴0 </em>)，使用与NumPy相同的语法。记住，在调用<code class="fe nz oa ob oc b">compute()</code>之前，不做任何工作。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="c94e" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">Xarray数据集</h1><p id="df6e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果你使用多维数据集或者分析大量地球系统数据，那么你很可能熟悉<a class="ae ky" href="https://xarray.pydata.org/en/stable/" rel="noopener ugc nofollow" target="_blank">Xarray</a>T0】和<code class="fe nz oa ob oc b">DataSets</code>。Dask被集成到Xarray中，将Xarray数据类型转换成Dask数据类型几乎不需要做任何工作。例如，当调用<code class="fe nz oa ob oc b">open_mfdataset()</code>时，Xarray会将数据集作为Dask数组加载(假设安装了Dask)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1fafa847964b1df06a5edba65cfecb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEWUWl_eEbx8kIZ0dvdLCw@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您检查上面的输出并将块大小与维度形状进行比较，您会注意到变量是随时间分块的，每个块代表不同的年份。您可以使用<code class="fe nz oa ob oc b"><a class="ae ky" href="https://xarray.pydata.org/en/stable/generated/xarray.Dataset.chunk.html" rel="noopener ugc nofollow" target="_blank">chunk()</a></code>随意更改块大小。</p><p id="f9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个根据<a class="ae ky" href="https://psl.noaa.gov/data/gridded/data.ncep.reanalysis2.html" rel="noopener ugc nofollow" target="_blank"> NCEP再分析</a>计算气温长期平均值的例子。我直接从THREDDS服务器上读取数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="30c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我首先用1981年至2009年的四倍每日数据加载气温。每年是包含1460个时间点的单个文件(<em class="oo"> 365*4=1460 </em>)。然后，我将所有数据作为多文件数据集加载。因为Dask被集成到Xarray中，所以它会自动将数据作为Dask数组加载。现在，您只需像使用Xarray一样执行计算，但是当您想要完成实际工作时，不要忘记调用<code class="fe nz oa ob oc b">compute()</code>。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="9637" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">Dask包</h1><p id="a09a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><a class="ae ky" href="https://docs.dask.org/en/latest/bag.html" rel="noopener ugc nofollow" target="_blank"> Dask Bag </a>在通用Python对象集合上实现类似<code class="fe nz oa ob oc b">map()</code>、<code class="fe nz oa ob oc b">filter()</code>和<code class="fe nz oa ob oc b">groupby()</code>的操作，比如lists。下面的代码将一系列数据放入一个包中，然后应用三个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的列表使用<code class="fe nz oa ob oc b">npartitions</code>参数分成三个块。这个列表很小，仅仅是为了说明这个概念。你可以用包做很多事情。参见<a class="ae ky" href="https://docs.dask.org/en/latest/bag.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="49e0" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">最后的想法</h1><p id="f9f7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Dask是提高可伸缩性的好方法。在本文中，我简要地讨论了根据所使用的数据类型来提高可伸缩性的方法。从本地分析转移到使用Dask分析只需要很少的改变。这是因为Dask通过允许您将数据分块来扩展这些数据类型。记住，命令是缓慢运行的，所以您需要调用<code class="fe nz oa ob oc b">compute()</code>来执行实际的计算。</p><p id="1637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文并不全面，只是介绍了Dask提高可伸缩性的几种方法。我希望这能帮助你分析你可能遇到的任何大数据。</p><h2 id="02a5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">如何将数据分块</h2><p id="39c4" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">需要记住的一件事是如何对数据进行分块，这会影响性能。块的大小应该足够大，这样Dask就不必考虑太多的块了——这会影响开销——但也要足够小，这样就可以一次将太多的块放入内存。查看Dask关于分块的文档<a class="ae ky" href="https://docs.dask.org/en/latest/array-chunks.html" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae ky" href="https://docs.dask.org/en/latest/array-best-practices.html" rel="noopener ugc nofollow" target="_blank">一些最佳实践</a>。</p><h2 id="3faa" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">相关文章</h2><div class="or os gp gr ot ou"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-speed-up-your-day-to-day-work-in-python-213762cd56b1"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">如何加快Python中的日常工作</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">使用所有可用的计算能力</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">better编程. pub</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="b966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很乐意帮助解决您可能遇到的任何问题。</p><p id="b25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">感谢阅读和支持媒体作者</em></p><div class="or os gp gr ot ou"><a href="https://lukegloege.medium.com/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">通过我的推荐链接加入Medium—Luke Gloege博士</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">lukegloege.medium.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>