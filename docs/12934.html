<html>
<head>
<title>15 Useful SvelteKit Code Snippets — A Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">15个有用的SvelteKit代码片段——一个备忘单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/15-useful-sveltekit-code-snippets-a-cheat-sheet-ad7e56772ced?source=collection_archive---------6-----------------------#2022-07-12">https://betterprogramming.pub/15-useful-sveltekit-code-snippets-a-cheat-sheet-ad7e56772ced?source=collection_archive---------6-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6db5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Svelte和Svelte-Kit时遇到的有用功能的集合</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5370387577ce22697a8056a4425f2748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p-2q0LoGGGo7UFqe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fedc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.延迟组件直到Dom加载完毕</h1><p id="6b83" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们通常希望在关注视频等资源密集型项目之前加载页面。这里我们使用了一个承诺，在加载那些组件之前，检查页面是否准备好了。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="409e" class="ms la it mo b gy mt mu l mv mw">let domReady = (function () {<br/>   return new Promise( function(resolve) {<br/>      document.addEventListener('readystatechange', function() {    <br/>          if(document.readyState != 'loading' &amp;&amp; document.readyState <br/>              !='interactive') resolve();<br/>   })})})()</span></pre><p id="a5b8" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在，我们可以在添加组件时使用异步await条件:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9eb5" class="ms la it mo b gy mt mu l mv mw">{#await domReady}<br/>   &lt;MyComponent /&gt;<br/>{/await}</span></pre><h1 id="e833" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.包和脚本的外部加载</h1><p id="7722" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通常，我们可能希望从CDN加载一个库来进行测试，或者减少整个包的大小或编译时间。这里我们使用<code class="fe nc nd ne mo b">svelte:head</code>选项来完成。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3d6e" class="ms la it mo b gy mt mu l mv mw">&lt;svelte:head&gt;<br/>   &lt;script defer src='http://...loading1.js'&gt;&lt;/script&gt;<br/>   &lt;script defer src='http://...loading2.js'&gt;&lt;/script&gt;<br/>&lt;/svelte:head&gt;</span></pre><p id="0230" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">当然，如果我们愿意，我们也可以使用动态的<code class="fe nc nd ne mo b">import(...)</code>或者甚至普通的JavaScript方法:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9ffb" class="ms la it mo b gy mt mu l mv mw">function loadScript(src) {</span><span id="2354" class="ms la it mo b gy nf mu l mv mw">   let script = document.createElement('script')<br/>   script.src = src; <br/>   script.async = false;<br/>   document.body.append(script);</span><span id="c2ac" class="ms la it mo b gy nf mu l mv mw">}</span><span id="f506" class="ms la it mo b gy nf mu l mv mw">loadScript("loading1.js");<br/>loadScript("loading2.js");</span></pre><h1 id="182d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.使用窗口函数处理事件</h1><p id="062e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，我们可能希望阅读发生在窗口上的“事件”。一个简单的方法是将它们绑定到<code class="fe nc nd ne mo b">svelte:window</code>:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="48e8" class="ms la it mo b gy mt mu l mv mw">&lt;svelte:window on:keydown={keyed}/&gt;</span></pre><p id="8478" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">并使用回调函数将它们视为正常。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8c87" class="ms la it mo b gy mt mu l mv mw">function keyed(event) {<br/>  key = event.key;<br/>  keyCode = event.keyCode;</span><span id="e7c0" class="ms la it mo b gy nf mu l mv mw">  if (key === ' ' ) alert('you pressed space')<br/> }</span></pre><h1 id="8ec1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.跨多个路线/组件的共享变量</h1><p id="7dff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要跨多个组件更新一个变量，我们可以使用svelte <code class="fe nc nd ne mo b">stores</code>。为此，我们定义了一个共享文件(如<code class="fe nc nd ne mo b">sharedvalues.js</code>)和变量:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e221" class="ms la it mo b gy mt mu l mv mw">import { writable } from 'svelte/store';</span><span id="651c" class="ms la it mo b gy nf mu l mv mw">export const contact = writable({name:'Dan', age:undefined});</span></pre><p id="5a84" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然后在我们的每个简单脚本中，我们可以导入变量并更新它们。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3e1d" class="ms la it mo b gy mt mu l mv mw">import {contact} from './sharedvalues.js';</span><span id="8217" class="ms la it mo b gy nf mu l mv mw">console.log('hello', $contact.name)</span></pre><p id="82c1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们还可以用以下内容更新这些内容:</p><p id="f2e2" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><code class="fe nc nd ne mo b">$contact = {name:’Dan’, 101}</code>或<code class="fe nc nd ne mo b">contact.set({name:’Dan’, age:101})</code></p><h1 id="429d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.在来自另一个组件/页面的变量更新时自动触发回调函数</h1><p id="9398" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们希望每次存储值改变时都运行一次更新，我们只需为它订阅一个回调函数。只要两条路线/组件共享同一个苗条商店，改变的位置就无关紧要。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ce6a" class="ms la it mo b gy mt mu l mv mw">function onChange(){<br/>   console.log('hello', $contact.name)<br/>   }</span><span id="3b1a" class="ms la it mo b gy nf mu l mv mw">contact.subscribe(onChange)</span></pre><h1 id="f96b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.事件调度程序</h1><p id="809a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">svelt组件之间的另一种通信方式是事件调度程序。在这里，我们创建一个自定义事件名称，并发送一个包含我们信息的对象。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d519" class="ms la it mo b gy mt mu l mv mw">import { createEventDispatcher } from 'svelte';  </span><span id="d4f9" class="ms la it mo b gy nf mu l mv mw">const dispatch = createEventDispatcher();</span><span id="e600" class="ms la it mo b gy nf mu l mv mw">dispatch('myEventName', {name:'Dan'});</span></pre><p id="c240" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然后，我们可以将其“绑定”到以下形式的组件:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3de9" class="ms la it mo b gy mt mu l mv mw">&lt;script&gt;</span><span id="ffca" class="ms la it mo b gy nf mu l mv mw">function onChange(event){<br/>   console.log('hello', event.detail.name)<br/>   }</span><span id="0c94" class="ms la it mo b gy nf mu l mv mw">&lt;/script&gt; </span><span id="4f42" class="ms la it mo b gy nf mu l mv mw"><br/>&lt;Component ...  on:myEventName={onChange} /&gt;</span></pre><h1 id="5266" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.从应用程序级别读取“上下文”值</h1><p id="8c03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">还有另一种方式来阅读信息，而不是传递信息，这就是使用苗条的上下文。如果您希望在脚本的应用程序级别定义一组配置参数，然后每个子组件都可以访问这些参数，那么这是非常有用的。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ee5c" class="ms la it mo b gy mt mu l mv mw">//App.svelte</span><span id="2641" class="ms la it mo b gy nf mu l mv mw"> import {setContext} from 'svelte'; </span><span id="4ee4" class="ms la it mo b gy nf mu l mv mw"> setContext('user', {name:Dan} );</span></pre><p id="fab1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们可以从子组件中读取以下内容:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8bb6" class="ms la it mo b gy mt mu l mv mw">import {getContext} from 'svelte';  </span><span id="7232" class="ms la it mo b gy nf mu l mv mw">const user = getContext('user');</span></pre><h1 id="fb20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">8.硬编码响应</h1><p id="a385" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某些情况下，我们希望将事件绑定到对窗口对象的更改。这里我们使用了<code class="fe nc nd ne mo b">svelte:window</code>对象并将一个变量绑定到它的宽度上。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c2fa" class="ms la it mo b gy mt mu l mv mw">&lt;script&gt;<br/> let w<br/>&lt;/script&gt;</span><span id="42de" class="ms la it mo b gy nf mu l mv mw">&lt;svelte:window bind:innerWidth={w}/&gt;</span><span id="294e" class="ms la it mo b gy nf mu l mv mw">&lt;OneThirdComponent style={"width:{w/3}px"} /&gt;</span></pre><h1 id="d1fb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">9.滚动讲故事</h1><p id="e19a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以类似的方式，我们可以将我们的滚动位置绑定到我们的脚本，并触发对我们网站的更新:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2176" class="ms la it mo b gy mt mu l mv mw">&lt;svelte:window bind:scrollY={y}/&gt;</span><span id="a0ee" class="ms la it mo b gy nf mu l mv mw">{#if y &gt; 100}</span><span id="2a87" class="ms la it mo b gy nf mu l mv mw">{#each layers as layer}<br/>  &lt;parallaxComponent<br/>   style="transform: translate(0,{-y * layer / (layers.length -  1)}px)" &gt;<br/> {/each}</span><span id="e95e" class="ms la it mo b gy nf mu l mv mw">{/if}</span></pre><h1 id="cc79" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">10.全局样式</h1><p id="d748" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">svelte的一个很好的特性是样式是有范围的，但是，当你想改变一个外部导入的组件时，这会引起问题。</p><p id="14f8" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">解决方案是定义一个全局样式，它会影响与查询参数匹配的每个组件。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ed2b" class="ms la it mo b gy mt mu l mv mw">&lt;style&gt;<br/>   :global(.myComponentClass){<br/>      display:flex<br/>    }<br/>&lt;/style&gt;</span></pre><h1 id="d328" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">11.呈现HTML</h1><p id="18fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还能够直接呈现HTML字符串，而不需要将它们附加到现有的DOM元素中。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fb34" class="ms la it mo b gy mt mu l mv mw">&lt;script&gt;<br/>   var htmlString = `&lt;img src="${img.src}"/&gt;`<br/>&lt;/script&gt;</span><span id="a814" class="ms la it mo b gy nf mu l mv mw">{@html htmlstring}</span></pre><h1 id="b65e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">12.时间</h1><p id="b60a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当创建一个组件时，我们可以在其中嵌套其他组件/ HTML代码。这是使用插槽完成的。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="bf0e" class="ms la it mo b gy mt mu l mv mw"><em class="ng">//Component.svelte</em></span><span id="30e0" class="ms la it mo b gy nf mu l mv mw">&lt;div&gt;   </span><span id="8f1c" class="ms la it mo b gy nf mu l mv mw">&lt;slot&gt;Default content&lt;/slot&gt; </span><span id="4479" class="ms la it mo b gy nf mu l mv mw">&lt;/div&gt;  </span></pre><p id="e2c5" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然后，放置在组件的开始和结束标记之间的任何内容都会替换“默认内容”位置。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8d89" class="ms la it mo b gy mt mu l mv mw">&lt;Component&gt;   <br/>   &lt;p&gt;My super cool changed content&lt;/p&gt; <br/>&lt;/Component&gt;</span></pre><p id="abb3" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">如果需要多次替换，也可以命名插槽。</p><h1 id="fb66" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">13.绑定组件</h1><p id="8eaa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还可以绑定一个组件，而不需要设置id或可查询的特性。这是通过使用其自身(或此)引用来完成的，如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="bbf4" class="ms la it mo b gy mt mu l mv mw">&lt;script&gt;<br/>   let component;<br/>&lt;/script&gt;</span><span id="3e70" class="ms la it mo b gy nf mu l mv mw">&lt;svelte:component this={component} /&gt;</span></pre><p id="7ecb" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">这种方法的好处是，我们可以通过使用选择工具来动态地改变我们正在查看的组件。</p><h1 id="1da7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">14.简易动画</h1><p id="a120" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我们可以使用svelte中的运动和放松库轻松地对值进行补间并向我们的网站添加动画。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="1a0d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">15.类指令</h1><p id="feed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在UI开发中，基于条件(例如<code class="fe nc nd ne mo b">class="{status === 'loaded' ? 'loadedclass':''}"</code>)添加一个类是如此常见，以至于Svlete已经添加了自己的class指令。为了更清楚地处理条件类，我们现在可以在组件初始化中指定它们:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4246" class="ms la it mo b gy mt mu l mv mw">&lt;Component class:loadedclass={status === loaded} /&gt;</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="2147" class="kz la it bd lb lc nq le lf lg nr li lj jz ns ka ll kc nt kd ln kf nu kg lp lq bi translated">摘要</h1><p id="d20a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我发现的一些有用的苗条技巧的集合。虽然这个列表可能会随着我的继续而更新，但是请随意在评论中添加任何您认为有用的内容。</p></div></div>    
</body>
</html>