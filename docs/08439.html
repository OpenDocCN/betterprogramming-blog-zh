<html>
<head>
<title>How To Debug Using Node.js’s Built-In Debugger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js的内置调试器进行调试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-debug-using-node-js-built-in-debugger-f3ab3ba6e7c8?source=collection_archive---------10-----------------------#2021-04-29">https://betterprogramming.pub/how-to-debug-using-node-js-built-in-debugger-f3ab3ba6e7c8?source=collection_archive---------10-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a86" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用断点有效定位错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2622d75cb178a9133e223c262909702a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V18qwigkQzJjfTDu"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@hirmin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Kleinen </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="48c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有因为自己的代码不工作而沮丧过？你有没有尝试过在整个代码中查找错误，结果却在一天结束时两手空空？嗯，我有！因此，为了节省时间和精力，培养调试技能是非常重要的。</p><p id="6a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，到底什么是调试呢？它是定位和消除计算机程序缺陷、错误或异常的过程。它检查、检测和纠正错误(或“bug”)，以允许根据所需的规范正确执行程序。</p><p id="b554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调试是一个多阶段的过程，通常遵循以下步骤:</p><ol class=""><li id="771b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">找出你程序中的一个错误。</li><li id="2d41" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">找到bug在代码中的位置。</li><li id="1879" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分析错误发生的原因。</li><li id="b9c8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">修复bug。</li><li id="7eb4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">验证您的修复是否有效。</li></ol><p id="4df7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Node.js程序中发现错误后，您将遇到的第一个挑战是找到错误在代码中的确切位置。为了达到这个目的，最有效的方法之一就是一步一步地运行你的代码，这样你就能清楚地知道哪里出错了。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2864" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">断点</h1><p id="6958" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如果你的程序有成千上万行代码，一步一步地运行你的整个代码可能会非常低效。在这种情况下，你可以使用一个<em class="nk">断点</em>。它允许您中断程序的正常执行，并在代码中的给定点暂停。</p><p id="8239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用断点，您可以使程序正常运行，直到到达您怀疑存在错误的关键代码部分。然后，就可以切换到按部就班了。</p><p id="e6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据调试器和代码编辑器，有多种方法可以在代码中定义断点。有一种通用的方法可以强制任何JavaScript调试器在给定的点暂停:使用<code class="fe nl nm nn no b">debugger</code>语句。</p><p id="d60a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在代码中的任何位置添加此语句，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="58b0" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">Node.js检查模式</h1><p id="0969" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">由于调试器拥有对执行环境的完全访问权限，恶意参与者也可以利用它在Node.js程序中注入任意代码。这就是为什么默认情况下Node.js不允许你调试正在运行的程序。您必须启用一种称为<em class="nk">检查器</em>模式的特殊模式，以允许调试。</p><p id="a930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要<code class="fe nl nm nn no b">--inspect</code>选项来允许Node.js进程监听调试器客户端，该客户端将自身附加到进程并控制您的程序执行。</p><p id="7c49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，当inspect模式启用时，它将监听主机<code class="fe nl nm nn no b">127.0.0.1</code>上的端口<code class="fe nl nm nn no b">9229</code>。您也可以通过使用<code class="fe nl nm nn no b">--inspect=&lt;HOST&gt;:&lt;PORT&gt;</code>来指定自定义主机和端口。</p><p id="e5d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nk">注意:避免将Node.js调试器端口绑定到公共IP地址或0.0.0.0。否则，任何可以连接到您的IP地址的客户端都有可能连接并控制您的Node.js进程。这样，攻击者就可以在您的执行环境中远程运行任意代码。此操作可能会导致潜在的严重安全漏洞。</em></p><p id="6d98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为替代，您可以使用<code class="fe nl nm nn no b">--inspect-brk</code>选项。它的工作原理和<code class="fe nl nm nn no b">--inspect</code>一样，但是它在代码开始之前中断代码执行。</p><p id="9a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在启用了检查模式的情况下启动Node.js后，可以使用任何兼容的调试器客户端连接到Node.js进程。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="05b9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">内置调试器</h1><p id="1242" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">例如，您可以使用<a class="ae kv" href="https://github.com/nodejs/node-inspect" rel="noopener ugc nofollow" target="_blank">节点检查</a>。这个命令行调试器与Node.js捆绑在一起。您可以通过如下方式运行您的程序来使用它:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="9d55" class="nv mo iq no b gy nw nx l ny nz">node inspect &lt;YOUR_SCRIPT&gt;.js</span></pre><p id="46ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节点检查调试器将在启用检查模式的情况下运行Node.js，并与集成调试器同时启动。它会在代码开始前暂停执行。您应该会看到调试器提示，指示它已成功启动:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="9fbb" class="nv mo iq no b gy nw nx l ny nz">node inspect myscript.js<br/>&lt; Debugger listening on ws://127.0.0.1:9229/ce3689fa-4433-41ee-9d5d-98b5bc5dfa27<br/>&lt; For help, see: https://nodejs.org/en/docs/inspector<br/>&lt; Debugger attached.<br/>Break on start in myscript.js:1<br/>&gt; 1 const express = require('express');<br/>  2<br/>  3 const app = express();<br/>debug&gt;</span></pre><p id="7748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以使用以下任何一个命令来控制程序的执行:</p><ul class=""><li id="acd2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">cont</code>或<code class="fe nl nm nn no b">c</code>:继续执行，直到下一个断点或程序结束。</li><li id="c19b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">next</code>或<code class="fe nl nm nn no b">n</code>:执行当前上下文中的下一行代码。</li><li id="fd6e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">step</code>或<code class="fe nl nm nn no b">s</code>:踩入。与<code class="fe nl nm nn no b">next</code>相同，除了如果下一行代码是函数调用，则转到该函数代码的第一行。</li><li id="990f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">out</code>或<code class="fe nl nm nn no b">o</code>:步出。如果当前执行上下文在函数的代码中，则执行该函数的剩余代码，并跳回到最初调用该函数的代码行。</li><li id="33f1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">restart</code>或<code class="fe nl nm nn no b">r</code>:重启程序，并在代码开始前暂停执行。</li></ul><p id="05f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要在代码中设置或清除断点，请使用以下命令:</p><ul class=""><li id="a79b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">setBreakpoint()</code>或<code class="fe nl nm nn no b">sb()</code>:在当前行添加断点。</li><li id="c6c3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">setBreakpoint(&lt;N&gt;)</code>或<code class="fe nl nm nn no b">sb(&lt;N&gt;)</code>:在第<em class="nk"> N </em>行增加一个断点。</li><li id="b413" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">clearBreakpoint('myscript.js', &lt;N&gt;)</code>或<code class="fe nl nm nn no b">cb('myscript.js', &lt;N&gt;)</code>:清除文件<code class="fe nl nm nn no b">myscript.js</code>中第<em class="nk"> N </em>行的断点。</li></ul><p id="a13b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获取有关当前执行点的信息，请运行以下命令:</p><ul class=""><li id="5af8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">list(&lt;N&gt;)</code>:在当前执行点前后用<em class="nk"> N </em>行列出你的源代码。</li><li id="e3a4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oa ly lz ma bi translated"><code class="fe nl nm nn no b">exec &lt;EXPR&gt;</code>:在当前执行上下文中对表达式求值。该命令有助于您获取有关当前状态的信息。例如，您可以通过使用<code class="fe nl nm nn no b">exec i</code>获得名为<code class="fe nl nm nn no b">i</code>的变量的值。</li></ul><p id="0df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这需要记住相当多的命令。幸运的是，您还可以使用<code class="fe nl nm nn no b">help</code>命令来显示可用命令的完整列表。要随时退出调试器，请按Ctrl+D或选择命令<code class="fe nl nm nn no b">.exit</code>。</p><h2 id="8094" class="nv mo iq bd mp ob oc dn mt od oe dp mx lf of og mz lj oh oi nb ln oj ok nd ol bi translated">准备环境</h2><p id="0fb9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在，为了将我们刚刚看到的调试概念付诸实践，让我们创建一个简短的Node.js程序来计算斐波那契数列的第n个数字。斐波纳契数列是一组数字，从数字0和1开始，后面的数字是前两个数字的和。顺序如下:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="7058" class="nv mo iq no b gy nw nx l ny nz">0, 1, 1, 2, 3, 5, 8, 13, 21...</span></pre><p id="60a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个名为<code class="fe nl nm nn no b">fibonacci.js</code>的新JavaScript文件，并编写下面给出的基本代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存文件，使用终端运行程序，键入<code class="fe nl nm nn no b">node fibonacci.js</code>。</p><p id="5cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序在控制台显示结果<code class="fe nl nm nn no b">3</code>。哎呀，这里似乎有一个bug，因为我们期望看到的是<code class="fe nl nm nn no b">5</code>。我们通过使用Node.js的内置调试器来了解一下哪里出了问题。</p><h2 id="ee7a" class="nv mo iq bd mp ob oc dn mt od oe dp mx lf of og mz lj oh oi nb ln oj ok nd ol bi translated">启动内置调试器</h2><p id="a327" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">再次启动程序，这次启用内置调试器(即<code class="fe nl nm nn no b">node inspect fibonacci.js</code>)。现在，逐步运行<code class="fe nl nm nn no b">s</code>命令，直到执行点位于<code class="fe nl nm nn no b">fibonacci</code>功能的开始处，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cfc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们可以通过运行命令<code class="fe nl nm nn no b">exec n</code>来检查函数中传递的<code class="fe nl nm nn no b">n</code>参数的值。您应该会看到<code class="fe nl nm nn no b">5</code>显示在控制台上。通过运行<code class="fe nl nm nn no b">s</code>命令再次进入，直到执行点位于循环的开始，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="8dc2" class="nv mo iq bd mp ob oc dn mt od oe dp mx lf of og mz lj oh oi nb ln oj ok nd ol bi translated">用断点定位bug</h2><p id="b6d9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在让我们在这里添加一个断点，这样我们就可以快速地遍历循环迭代(即<code class="fe nl nm nn no b">sb()</code>)。您应该会看到控制台中再次显示相同的行，这表明在该行设置了一个断点。当当前执行点移动时，您会在设置断点的那一行看到一个<code class="fe nl nm nn no b">*</code>。通过运行<code class="fe nl nm nn no b">c</code>命令前进到下一个循环迭代。</p><p id="db93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过运行<code class="fe nl nm nn no b">exec</code>命令(即<code class="fe nl nm nn no b">exec [i, c]</code>)来检查当前的迭代状态。<strong class="ky ir"> <em class="nk"> </em> </strong>你应该在控制台里看到<code class="fe nl nm nn no b">[ 3, 1 ]</code>。因为代码还没有为当前迭代(<code class="fe nl nm nn no b">3</code>)更新<code class="fe nl nm nn no b">c</code>的值，所以它当前表示前一次迭代的斐波纳契数。为了谨慎起见，使用<code class="fe nl nm nn no b">s</code>命令一步一步地推进这个迭代。尝试到达我们之前的断点，但是一步一步来。</p><h2 id="642e" class="nv mo iq bd mp ob oc dn mt od oe dp mx lf of og mz lj oh oi nb ln oj ok nd ol bi translated">修复错误</h2><p id="96f8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">检查完循环条件<code class="fe nl nm nn no b">i &lt; n</code>后，执行突然跳到返回行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，我们找到了我们的bug！代码跳出了循环，而不是更新迭代<code class="fe nl nm nn no b">5</code>的总和。这就是为什么我们在最初的运行中得到前一次迭代(<code class="fe nl nm nn no b">3</code>)的结果。因此，现在通过在代码编辑器中将<code class="fe nl nm nn no b">i &lt; n</code>改为<code class="fe nl nm nn no b">i &lt;= n</code>来修复循环条件。现在，您可以通过选择Ctrl+D退出调试器，然后再次运行您的程序。现在你应该看到控制台中显示的预期结果，即<code class="fe nl nm nn no b">5</code>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="af86" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="9399" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">您可以使用Node.js中的内置调试器来学习基本的调试原则和快速调试会话。我希望这篇文章是有帮助的。感谢阅读。祝你今天开心！玩的开心！</p></div></div>    
</body>
</html>