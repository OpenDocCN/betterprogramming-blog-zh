<html>
<head>
<title>Solving a Deadlock on AWS CloudFormation When Deploying ECS on CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在CI/CD上部署ECS时，解决AWS CloudFormation上的死锁</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-a-deadlock-on-aws-cloudformation-when-deploying-ecs-on-ci-cd-849f1f16e6b7?source=collection_archive---------8-----------------------#2019-08-20">https://betterprogramming.pub/solving-a-deadlock-on-aws-cloudformation-when-deploying-ecs-on-ci-cd-849f1f16e6b7?source=collection_archive---------8-----------------------#2019-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7547" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建一个验证步骤来决定CodeDeploy是否触发任务修订更新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/add94a107781aeab3633acc24c391f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn7Jg-soy7NYjq91Ywbiog.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼古拉斯·斯旺森在<a class="ae kv" href="https://unsplash.com/search/photos/clouds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章假设你对<a class="ae kv" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS服务</a>有很好的了解，比如<a class="ae kv" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>、<a class="ae kv" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> ECS </a>和代码(构建/部署/管道)，所以我不会深究任何资源，因为这不是这篇文章的目的。也就是说，你知道该怎么做。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="01d8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们想象一下</h1><p id="eab7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您已经创建了一个CloudFormation模板，它将启动EC2集群来运行一些微服务和<a class="ae kv" href="https://aws.amazon.com/codepipeline/" rel="noopener ugc nofollow" target="_blank">代码管道</a>来将映像推送到ECR并将更新部署到ECS。</p><p id="ce2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切看起来都很顺利。</p><p id="8e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是您第一次部署模板，一切都开始得很好，创建了EC2实例，创建了ECS集群，创建了ECR repo，创建了ECS服务和任务定义，创建了代码管道的所有阶段…</p><p id="acaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，过了一会儿，您注意到您的CloudFormation模板仍在运行，并且永远不会完成。几个小时后，一切都被回滚，你不知道为什么。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c84b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题是</h1><p id="22f2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">部署ECS微服务时，您需要一个指向ECR报告中Docker映像的任务定义和一个带有任务定义配置的服务。</p><p id="3de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个工作流程看起来不错，但是我们缺少了一个步骤——如果我们有一个完全自动化的模板，我们将如何推送Docker映像？</p><p id="ceb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的线人会处理的。我们的CloudFormation模板已经为我们创建了一切，与git的集成以拉代码，CodeBuild以构建Docker映像并将其推送到ECR，CodeDeploy以触发任务定义修订，这一切都很完美！</p><p id="5ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">没那么快……</em></p><p id="b81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用CloudFormation将你的基础设施写成代码有时会很棘手，你不能在资源创建期间执行验证，这可能会导致竞争条件和死锁。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a3c0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">真正的问题是</h1><p id="dd62" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">云形成提供资源是基于条件和依赖关系的(你已经知道了)<em class="mw">。</em></p><p id="a67b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于您的模板，将并行创建微服务和CI/CD资源，在上述问题之后，我们有两种情况:</p><h2 id="fcfc" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">场景1</h2><p id="64c8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">任务定义将在CI/CD构建阶段完成之前<em class="mw">创建，这将导致任务定义无法稳定，因为ECR中缺少映像。</em></p><p id="c68c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，任务定义将继续尝试，直到它找到一个映像或者云结构请求回滚。CI/CD构建阶段完成，任务定义找到要运行的映像，然后CI/CDs部署阶段触发任务定义修订更新。</p><p id="fa18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你现在看到问题了。还没有？别担心，继续走。</p><h2 id="725f" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">场景2</h2><p id="d073" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">CI/CD构建阶段首先完成，在任务定义创建之前，这真的很好。</p><p id="958f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务定义将有一个Docker映像可用于稳定服务，但我们仍有CI/CD部署阶段要运行，它将触发任务定义修订更新。</p><p id="0099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果部署阶段在任务定义创建之前运行，它将使代码管道执行失败，但不会使CloudFormation堆栈失败。</p><p id="fdc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是竞争条件/死锁所依赖的地方。</p><p id="c30f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当CloudFormation创建一个任务定义时，它将从一个代码修订开始，并等待它的稳定信号来完成堆栈创建。</p><p id="dcd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您并行运行CI/CD，并且您正在触发任务定义修订更新，它会将代码修订提升到两个，<strong class="ky ir"> </strong>导致CloudFormation永远等待代码修订一<strong class="ky ir"> </strong>稳定下来。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="28c4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决办法</h1><p id="9001" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后是解决方案，也是最激动人心的部分。</p><p id="bbaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试了资源顺序的每一种组合来解决这个竞争条件问题，直到我意识到主要问题出在部署阶段，所以只要我修复了部署阶段，这应该就可以正常工作了。</p><p id="66c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您遵循了官方的<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html" rel="noopener ugc nofollow" target="_blank"> ECS持续部署教程</a>，那么在您的<code class="fe nj nk nl nm b">buildspec.yml</code>文件中应该有类似这样的内容</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="20f3" class="mx ma iq nm b gy nr ns l nt nu">version: 0.2</span><span id="1de4" class="mx ma iq nm b gy nv ns l nt nu">phases:   <br/>  pre_build:     <br/>    commands:       <br/>      - echo Logging in to Amazon ECR...        <br/>      - $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)       <br/>      - REPOSITORY_URI=<em class="mw">${ACCOUNT_ID}.dkr.ecr.us-west-2.amazonaws.com/${ECR_REPO_NAME}</em><br/>      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)       <br/>      - IMAGE_TAG=${COMMIT_HASH:=latest}   <br/>  build:     <br/>    commands:       <br/>      - echo Building the Docker image...                 <br/>      - docker build -t $REPOSITORY_URI:latest .       <br/>      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG<br/>  post_build:     <br/>    commands:<br/>      - echo Pushing the Docker images...       <br/>      - docker push $REPOSITORY_URI:latest       <br/>      - docker push $REPOSITORY_URI:$IMAGE_TAG       <br/>      - echo Writing image definitions file...       <br/>      - printf '[{"name":"<em class="mw">${ECR_REPO_NAME}</em>","imageUri":"%s"}]' $REPOSITORY_URI:$IMAGE_TAG &gt; imagedefinitions.json <br/>artifacts:     <br/>  files: imagedefinitions.json</span></pre><p id="7479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的解决方案是创建一个验证步骤来决定CodeDeploy何时触发任务版本更新，何时不触发。</p><p id="af78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是通过在执行结束时不提供<code class="fe nj nk nl nm b">imagedefinitions.json</code>来实现的。</p><p id="6708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，但是……这里决定的标准是什么？</p><p id="67fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想到了在执行期间检查存储库是否已经有了Docker映像的想法。如果存储库至少有一个映像，则这不是第一次运行。AWS CLI将在这里为我们完成这项工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e221" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">仔细讨论</h1><p id="b40f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用以下命令查询ECR存储库映像:</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="043a" class="mx ma iq nm b gy nr ns l nt nu">aws ecr list-images --repository-name ${ECR_REPO_NAME} --max-items 1</span></pre><p id="70f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要一个项目来决定存储库是否有图像，选项<code class="fe nj nk nl nm b">--max-items 1</code>将加快响应速度。</p><p id="27a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令的结果将是一个JSON，带有一个名为<code class="fe nj nk nl nm b">imageIds</code>的顶层对象，它将是一个对象数组或一个空数组。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="01ae" class="mx ma iq nm b gy nr ns l nt nu">{     <br/>  "imageIds": [         <br/>    {             <br/>      "imageDigest": "sha256:236ce1ed44...",             <br/>      "imageTag": "latest"         <br/>    }<br/>  ]<br/>}</span><span id="be90" class="mx ma iq nm b gy nv ns l nt nu">or</span><span id="a823" class="mx ma iq nm b gy nv ns l nt nu">{<br/>  "imageIds": []<br/>}</span></pre><p id="d03b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个结果，我们现在有了验证第一次运行所需的所有数据。</p><p id="cdbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择了值<code class="fe nj nk nl nm b">imageDigest</code>作为决定存储库是否为空的键。如果您对更多的项目运行该命令，您将会看到一些图像没有<code class="fe nj nk nl nm b">imageTag</code> <strong class="ky ir"> </strong>属性，使得<code class="fe nj nk nl nm b">imageDigest</code>值在这里更有保证。</p><p id="d4c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要做的，就是创造一个条件来提供，或者不提供，<code class="fe nj nk nl nm b">imagedefinitions.json</code> <strong class="ky ir"> </strong>文件。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="d7f8" class="mx ma iq nm b gy nr ns l nt nu">version: 0.2</span><span id="2328" class="mx ma iq nm b gy nv ns l nt nu">phases:   <br/>  pre_build:     <br/>    commands:       <br/>      - echo Logging in to Amazon ECR...        <br/>      - $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)       <br/>      - REPOSITORY_URI=<em class="mw">${ACCOUNT_ID}.dkr.ecr.us-west-2.amazonaws.com/${ECR_REPO_NAME}</em><br/>      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)       <br/>      - IMAGE_TAG=${COMMIT_HASH:=latest}   <br/>  build:     <br/>    commands:<br/>      - |<br/>        echo Checking Repository Images<br/>        <strong class="nm ir">REPOSITORY_IMAGES=$(aws ecr list-images --repository-name ${ECR_REPO_NAME} --max-items 1)</strong><br/>        <br/>        echo Building the Docker image...<br/>        docker build -t $REPOSITORY_URI:latest .<br/>        docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG</span><span id="3e2c" class="mx ma iq nm b gy nv ns l nt nu">        echo Pushing the Docker images...<br/>        docker push $REPOSITORY_URI:latest<br/>        docker push $REPOSITORY_URI:$IMAGE_TAG</span><span id="1040" class="mx ma iq nm b gy nv ns l nt nu">        <strong class="nm ir"># Validate if JSON response has imageDigest value<br/>        if echo "$REPOSITORY_IMAGES" | grep -q "imageDigest"; then<br/>          echo Repository contain images and Deploy should run<br/>          </strong>echo Writing image definitions file...<strong class="nm ir"><br/>          </strong>printf '[{"name":"<em class="mw">${ECR_REPO_NAME}</em>","imageUri":"%s"}]' $REPOSITORY_URI:$IMAGE_TAG &gt; imagedefinitions.json<strong class="nm ir"><br/>        else<br/>          echo Repository DOES NOT contain images, DO NOT run deploy<br/>        fi</strong><br/>artifacts:     <br/>  files: imagedefinitions.json</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1f5b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">变更细分</h1><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="0121" class="mx ma iq nm b gy nr ns l nt nu">REPOSITORY_IMAGES=$(aws ecr list-images --repository-name ${ECR_REPO_NAME} --max-items 1)</span></pre><p id="c2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nj nk nl nm b">$(command)</code>语法将结果存储在变量中。即使结果是JSON格式的，它仍然是纯文本，允许我们执行字符串函数。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="e077" class="mx ma iq nm b gy nr ns l nt nu">if echo "$REPOSITORY_IMAGES" | grep -q "imageDigest";</span></pre><p id="dbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nj nk nl nm b"><a class="ae kv" href="https://ss64.com/bash/grep.html" rel="noopener ugc nofollow" target="_blank">grep</a></code> <a class="ae kv" href="https://ss64.com/bash/grep.html" rel="noopener ugc nofollow" target="_blank">命令</a>允许我们在文件中搜索文本，而<code class="fe nj nk nl nm b">echo "$VALUE" |</code> <strong class="ky ir"> <em class="mw"> </em> </strong>将为<code class="fe nj nk nl nm b">grep</code>模拟一个文件，如果找到则返回<code class="fe nj nk nl nm b">0</code>，如果没有找到则返回<code class="fe nj nk nl nm b">1</code>。</p><p id="3d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在条件中使用这种方法，我们可以处理何时创建或不创建一个<code class="fe nj nk nl nm b">imagedefinitions.json</code>文件。该文件的存在将决定CodeDeploy是否运行。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b7c7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="e6f1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">没什么要说的了，我希望这个场景已经解释清楚了，并且这个解决方案对你有帮助。</p><p id="6ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的<a class="ae kv" href="https://github.com/cferrera/medium-stories/tree/master/aws-deadlock-ecs" rel="noopener ugc nofollow" target="_blank"> GitHub账号</a>中找到构建规范文件。</p></div></div>    
</body>
</html>