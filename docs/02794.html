<html>
<head>
<title>What Is Hashable in Swift?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中有什么可散列的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-hashable-in-swift-6a51627f904?source=collection_archive---------1-----------------------#2020-01-02">https://betterprogramming.pub/what-is-hashable-in-swift-6a51627f904?source=collection_archive---------1-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2342" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探讨可散列协议及其更广泛的背景</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8c09b342ffd99b0905d8e8bd1106bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGPBeWophEhteH8_cBcCgQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=704252" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/carlosalbertoteixeira-637237/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=704252" rel="noopener ugc nofollow" target="_blank">卡洛斯·阿尔贝托·特谢拉</a></p></figure><p id="5165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们学习Swift中的基本数据类型时，官方文档多次提到<code class="fe lv lw lx ly b">Hashable</code>协议。</p><p id="ae3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/dictionary" rel="noopener ugc nofollow" target="_blank">Dictionary</a></code>数据类型中的一个键需要是<code class="fe lv lw lx ly b">Hashable</code>。再举一个例子，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/set" rel="noopener ugc nofollow" target="_blank">Set</a></code>数据类型中的元素也需要是<code class="fe lv lw lx ly b">Hashable</code>。如下所示，Dictionary和Set的声明明确指定了这样的要求:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4f64" class="md me it ly b gy mf mg l mh mi">@frozen struct Dictionary&lt;Key, Value&gt; where Key : <a class="ae ky" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank">Hashable</a></span><span id="7da8" class="md me it ly b gy mj mg l mh mi">@frozen struct Set&lt;Element&gt; where Element : <a class="ae ky" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank">Hashable</a></span></pre><p id="dfb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档列出了几种<code class="fe lv lw lx ly b">Hashable</code>数据类型，包括布尔值、整数和字符串，因此它们可以用作字典的键和集合的元素。</p><p id="b604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不清楚是什么造就了这些数据类型<code class="fe lv lw lx ly b">Hashable</code>，以及我们如何才能创造我们自己的数据类型<code class="fe lv lw lx ly b">Hashable</code>。</p><p id="aeb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们退后一步，我们可能还会想，为什么我们一开始就要费心去创建某些数据类型<code class="fe lv lw lx ly b">Hashable</code>。他们有特别的优势吗？关于这个话题，我们可以问更多的问题。</p><p id="73df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我试图深入概述Swift中的<code class="fe lv lw lx ly b">Hashable</code>协议及其常见用例。具体来说，我们将解决以下问题/主题。</p><ol class=""><li id="f741" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">哈希的一般讨论。</li><li id="a960" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">Swift中的<code class="fe lv lw lx ly b">Hashable</code>协议是什么？</li><li id="60f7" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">如何让我们的自定义类型符合<code class="fe lv lw lx ly b">Hashable</code>协议？</li></ol></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="11a9" class="nf me it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">哈希:什么和为什么</h1><p id="e6df" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">当我们谈论哈希时，许多术语在各种设置中频繁使用，包括哈希、哈希、哈希器、哈希代码、哈希值、哈希表和哈希函数。</p><p id="e0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们并不熟悉所有这些术语，但在各种编程语言以及日常生活中，我们确实会大量使用它们(例如，密码加密)，至少是间接使用。</p><h2 id="f1b2" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">基本概念</h2><p id="ab3c" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">一般来说，哈希是应用算法将数据项转换为值的过程。数据项可以简单到整数、字符串，也可以复杂到具有多个属性的对象。</p><p id="3ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法被称为哈希函数或哈希函数。转换后的值称为哈希值、哈希代码或简称为哈希。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/207914493997e3b4fe5e93ac71350451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6uGYaRUpSn2Lb0PWrlj0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希过程图</p></figure><p id="dd37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了散列过程的一个简化示例。本质上，我们从左侧的四种水果(即数据项)开始。</p><p id="c95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法(即hash函数)可以将这四个名字作为输入转换成四个整数(即hash值)作为右侧的输出，看起来像随机数，与它们的原始输入没有明显的联系。</p><p id="4f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个方面需要注意。</p><ol class=""><li id="3a8b" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">散列过程应该是可重复的。如果提供相同的数据，散列函数应该总是产生相同的散列值。每次我们请求苹果的hash值，hash函数都会可靠地返回839021给我们。</li><li id="6a03" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">哈希值需要是唯一的。苹果、橘子、桃子和菠萝都被映射到不同的哈希值。当我们要求哈希函数计算一个新的水果，比如草莓，该函数可能会产生一个类似542381的值，该值预计会与现有的值不同。</li><li id="a03e" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">哈希值看起来应该是随机的。用更专业的术语来说，哈希值不应该很容易被反转以找出原始数据项是什么。因此，哈希值需要看起来是随机的，以最小化反转的可能性。</li><li id="aab9" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">哈希值不必是正整数。出于演示目的，该图使用整数作为哈希值。哈希函数确定输出(即哈希值)，因此，根据哈希函数本身，哈希值可以是负整数，也可以包含数字、字母甚至符号。</li></ol><h2 id="5d82" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">用例</h2><p id="c508" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">哈希已经广泛应用于我们日常生活的各个方面。</p><p id="5361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我将使用下面的例子向您展示数据库操作中的散列、加密和编程中的数据结构的三个常见用例。</p><p id="5ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据库操作:搜索</strong></p><p id="7dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有的网站和手机应用程序都有搜索功能。搜索功能的实现涉及到哈希的使用。</p><p id="8d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子。假设您在数据库表中有一个本地小企业的列表。有一天，你想把你的车送去维修，你记得你的一个朋友推荐了一家叫约翰机械师的商店。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b9dcfd82b9c28218dfad929da7da9598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0wGjJJEj86amIoSgvahPA.png"/></div></div></figure><ul class=""><li id="a9d0" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu oo mq mr ms bi translated">不使用散列法:</li></ul><p id="62a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用商店名称在这个表中搜索时，数据库需要将这个15个字符的字符串与每个记录的企业名称字段进行比较。</p><p id="6047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，记录的数量可能有几十万条，这样这个过程可能会非常冗长并且缺乏效率。用计算行话来说，这个搜索函数的时间复杂度是O( <em class="op"> n </em>)，也就是说需要的时间与数据大小成线性正比。</p><ul class=""><li id="ed19" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu oo mq mr ms bi translated">使用散列法:</li></ul><p id="4b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不知何故，数据库所有者学会了散列的技巧，并使用散列函数为每个企业创建唯一的散列值，并将它们用作所有这些企业的索引。</p><p id="2329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您使用商店名称John's Mechanic发出搜索请求时，数据库将首先使用散列函数来计算这个搜索项的散列值。</p><p id="95f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，散列函数预计会为同一存储产生相同的散列值，因此我们只需查找索引并找出数据记录所在的位置。</p><p id="b651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平均而言，使用哈希的搜索函数的时间复杂度为O(1)，这是一个与数据大小无关的恒定时间量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/7bb85ea44f11c1580f544cff3e623001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLMPlQ8GpBnoxh1YbVC5LA.png"/></div></div></figure><p id="da61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">密码术:密码</strong></p><p id="22c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供个性化的体验，许多网站和应用程序要求用户创建自己的帐户是有道理的。</p><p id="00ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在注册过程中，我们通常会在网站上提供我们的电子邮件地址和新帐户的密码。这两段文本将在到达目的服务器之前通过互联网发送。</p><ul class=""><li id="3f81" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu oo mq mr ms bi translated">不使用散列法:</li></ul><p id="f91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不知何故，网站开发者对哈希一无所知，他们认为网络安全与他们无关。</p><p id="d59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，注册请求被设计为通过纯文本发送。它有很大的数据安全风险。如果请求被拦截，密码很容易被窃取，因为它只是纯文本！</p><ul class=""><li id="7dac" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu oo mq mr ms bi translated">使用散列法:</li></ul><p id="16bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它被使用时，密码将被散列成一个看似随机的文本。如果注册请求被拦截，只有这个散列密码会被暴露。</p><p id="c595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们通常设计哈希函数，使得几乎不可能将哈希值反转为其原始数据项。因此，这是一种更安全的方法。网站的数据库只能存储这个散列密码。</p><p id="3bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们尝试登录时，网站会将提供的密码(再次哈希)与保存的哈希密码进行比较，因为它们应该与输入的密码相同(即，纯文本的正确密码)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/50fa79f8725198b1ddc81d73b1f0dea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9pgaWMS3r-csnvb8n7qpSQ.png"/></div></div></figure><p id="fc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">编程中的数据结构:字典</strong></p><p id="39a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有现代编程语言都有Dictionary数据类型，尽管它们可能使用不同的名称，如关联数组、映射、哈希表、哈希或对象。</p><p id="4aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一个共同点是，它是一个无序的键值对集合。用简单的语言来说，字典成对地存储数据，每一对都有一个键和值。</p><p id="24c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个函数与Dictionary数据类型的使用有关，包括数据检索、插入和删除。看在Swift当前教程的份上，我就用Swift语言给大家演示一下这些功能吧。</p><p id="bc1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他语言涉及到差别语法，但是概念应该是非常相似的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="1106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台，字典是一种哈希表，提供对它包含的条目的快速访问。对于每个键，hash函数都会计算一个hash值作为索引来存储那个数据项，有些人把它称为bucket(即存储数据的地方)。</p><p id="f6ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们检索一个数据项时，程序将为所提供的键计算哈希值，如果存在具有相同哈希值的键，则查找索引。</p><p id="b182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，则返回相应的数据项。如果没有，将返回<code class="fe lv lw lx ly b">nil</code>。这就是为什么从字典返回的数据类型是可选的，因为不保证可用性。</p><p id="0d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们插入一个新的键-值对时，哈希函数将只计算键的哈希值作为数据项的索引，而当我们删除一个键-值对时，我们将只删除根据哈希值计算的索引。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="24f6" class="nf me it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">哈希协议</h1><p id="699a" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在对散列法有了大致的了解之后，我们现在可以通过关注Swift标准库中的<code class="fe lv lw lx ly b">Hashable</code>协议来缩小我们的范围。</p><p id="aae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们查阅<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank">Hashable</a></code>协议文档页面时，我们发现<code class="fe lv lw lx ly b">Hashable</code>的定义是:</p><blockquote class="ou"><p id="c4c5" class="ov ow it bd ox oy oz pa pb pc pd lu dk translated">"一种类型，可以被散列到散列函数中以产生整数散列值."</p></blockquote><p id="2ee2" class="pw-post-body-paragraph kz la it lb b lc pe ju le lf pf jx lh li pg lk ll lm ph lo lp lq pi ls lt lu im bi translated">定义非常清晰，在这个定义中我们可以识别出三个关键词:<em class="op"> type </em>、<em class="op"> Hasher </em>和<em class="op"> integer </em>。我将在下面详细解释它们。</p><h2 id="c28e" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">类型</h2><p id="9ea1" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">以一套为例。如前所述，集合中的所有元素都必须是可哈希的。从表面上看，这仅仅意味着每个单独的元素都是可散列的。</p><p id="d6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它实际上意味着这个通用集合数据类型的<em class="op">具体类型</em>需要符合<code class="fe lv lw lx ly b">Hashable</code>协议。换句话说，就像其他协议一样，<code class="fe lv lw lx ly b">Hashable</code>协议是在类型(例如，类、结构)级别实现的<em class="op">，因此它的所有实例都是可散列的。</em></p><p id="8272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，类型不仅包括标准数据类型，如整数、字符串，还包括自定义类型，我将在本文后面的<code class="fe lv lw lx ly b">Hashable</code>协议实现中展示一个例子。</p><h2 id="0fe4" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">厨师</h2><p id="2e14" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Hasher根据<a class="ae ky" href="https://developer.apple.com/documentation/swift/hasher" rel="noopener ugc nofollow" target="_blank">官方文档</a>定义为集合和字典使用的<em class="op">通用哈希函数</em>。在后台，<code class="fe lv lw lx ly b">Hasher</code>实际上是作为struct实现的，所以我们可以通过调用<code class="fe lv lw lx ly b">var hasher = Hasher()</code>方便地实例化一个空状态的hasher。</p><p id="4d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准的通用散列函数使用每次执行随机的128位种子值，使得散列值不太容易预测。</p><p id="065b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更具体地说，Swift标准库中使用的通用哈希函数是<a class="ae ky" href="https://github.com/attaswift/SipHash" rel="noopener ugc nofollow" target="_blank"> SipHash </a>，最初是由Jean-Philippe Aumasson和Daniel J. Bernstein在2012年设计的。</p><p id="1245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">截至目前，具有320位状态的SipHash-1-3在当前库中实现。需要注意的是，苹果确实警告说，通用哈希函数及其实现可能会在任何新版本中发生变化。</p><p id="877b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个<code class="fe lv lw lx ly b">Hasher</code>实例，我们可以根据需要使用变异的<code class="fe lv lw lx ly b">combine(bytes:)</code>或<code class="fe lv lw lx ly b">combine(_:)</code>方法多次向它提供数据(例如，整数、字符串)。</p><p id="2336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">combine(bytes:)</code>方法，我们向<code class="fe lv lw lx ly b">Hasher</code>提供新字节的数据，因为它们在内存中的单个连续区域中可用，将其位与<code class="fe lv lw lx ly b">Hasher</code>状态混合。</p><p id="aa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">combine(_:)</code>方法只是一个方便的操作，它接受一个<code class="fe lv lw lx ly b">Hashable</code>值，比如一个整数或字符串。在幕后，这个<code class="fe lv lw lx ly b">combine(_:)</code>方法调用<code class="fe lv lw lx ly b">hash(into:)</code>方法将其值混合到<code class="fe lv lw lx ly b">Hasher</code>状态中。</p><p id="cb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您使用这些<code class="fe lv lw lx ly b">combine</code>方法更新<code class="fe lv lw lx ly b">Hasher</code>状态之后，我们将调用<code class="fe lv lw lx ly b">finalize</code>方法，它将完成<code class="fe lv lw lx ly b">Hasher</code>状态并返回哈希值。</p><p id="9647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，调用这个方法将消耗<code class="fe lv lw lx ly b">Hasher</code>，因此建议您不要终结一个您不拥有的<code class="fe lv lw lx ly b">Hasher</code>或者在一个已终结的<code class="fe lv lw lx ly b">Hasher</code>上执行操作。</p><p id="be98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">finalize</code>方法的另一个重要方面是终结过程的计算开销很大。在sipash-1-3中，它的开销是单个64位<code class="fe lv lw lx ly b">combine</code>运算的三倍。</p><p id="0c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要记住，当我们在自定义类型中实现<code class="fe lv lw lx ly b">Hashable</code>协议时，如果可能的话，我们希望减少<code class="fe lv lw lx ly b">finalize</code>的使用，以使我们的代码更有效。</p><h2 id="3493" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">整数</h2><p id="fd1e" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这再简单不过了。上面提到的<code class="fe lv lw lx ly b">Hasher</code>会计算给定实例的哈希值，更具体的说，哈希值是一个整数。</p><p id="b809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，应该注意的是，由于整数溢出，哈希值不一定总是正的，整数溢出有时会产生负的哈希值。</p><p id="9384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于哈希函数的种子值不同，每次执行Swift程序时生成的哈希值也不同，因此您不希望保存哈希值以备将来参考，这将导致您的程序出现不可预测的行为。</p><p id="ad68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外要提到的是，<code class="fe lv lw lx ly b">Hashable</code>协议继承了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/equatable" rel="noopener ugc nofollow" target="_blank">Equatable</a></code> <a class="ae ky" href="https://developer.apple.com/documentation/swift/equatable" rel="noopener ugc nofollow" target="_blank"> </a>协议，所以如果一个数据类型符合<code class="fe lv lw lx ly b">Hashable</code>，那么它也必须符合<code class="fe lv lw lx ly b">Equatable</code>。</p><p id="b45a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个实例有相同的<code class="fe lv lw lx ly b">hashValue</code>会怎么样？这种现象叫做<em class="op">碰撞</em>。有几种方法可以解决冲突。</p><p id="e662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的方法叫做<em class="op">链接</em>。哈希表可以将多个项目链接在一起，而不是在每个桶中存储一个项目，这样每个哈希键都有一个对链表的引用。</p><p id="c6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种常见的方法叫做<em class="op">线性探测</em>或<em class="op">开放寻址</em>，这种方法也是由Swift的<code class="fe lv lw lx ly b">Dictionary</code>类型在内部实现的，用于冲突处理。</p><p id="4fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这种方法通过使用下一个可用的槽(或桶)来解决冲突。如果它到达终点，它将回到起点，直到它找到该项目的桶。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="b8e1" class="nf me it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">符合可散列协议</h1><p id="4b09" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在我们的开发中，我们不可避免地需要不时地创建一些自定义数据类型。有时，我们更进一步，希望将这些类型用作字典键或集合中的元素。</p><p id="e052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如本文开头所提到的，要实现这一点，您的定制数据类型应该符合<code class="fe lv lw lx ly b">Hashable</code>协议。在本节中，我将向您展示如何做到这一点。</p><h2 id="28a4" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">简单数据结构</h2><p id="63ac" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">首先，我们创建一个名为<code class="fe lv lw lx ly b">Student</code>的定制结构，它有两个<code class="fe lv lw lx ly b">String</code>属性，<code class="fe lv lw lx ly b">firstName</code>和<code class="fe lv lw lx ly b">lastName</code>。假设我们想使用字典来跟踪学生的期末考试成绩。</p><p id="e236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们实例化一个字典<code class="fe lv lw lx ly b">var scores = [Student: Int]()</code>。但是Xcode给了我们一个错误:<code class="fe lv lw lx ly b">Type ‘Student’ does not conform to protocol ‘Hashable’</code>。</p><p id="e2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当我写这篇文章时，我使用的是Xcode 11.3和Swift 5.1。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f9c8" class="md me it ly b gy mf mg l mh mi">struct Student {<br/>    var firstName: String<br/>    var lastName: String<br/>}</span></pre><p id="ccb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了消除这个错误，我们需要实现<code class="fe lv lw lx ly b">Hashable</code>协议所需的<code class="fe lv lw lx ly b">hash(into:)</code>方法，如下所示。通用散列函数<code class="fe lv lw lx ly b">hasher</code>使用<code class="fe lv lw lx ly b">combine</code>方法散列学生的名和姓的字符串值。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8633" class="md me it ly b gy mf mg l mh mi">extension Student : Hashable {<br/>    func hash(into hasher: inout Hasher) {<br/>        hasher.combine(firstName)<br/>        hasher.combine(lastName)<br/>    }<br/>}</span></pre><p id="99ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，我们没有在<code class="fe lv lw lx ly b">hash(into:)</code>方法中调用<code class="fe lv lw lx ly b">finalize</code>方法，因为当需要哈希值时，编译器会通过使用下面的代码调用<code class="fe lv lw lx ly b">finalize</code>方法来自动完成计算。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7fd5" class="md me it ly b gy mf mg l mh mi">var hashValue: Int {<br/>    var hasher = Hasher()<br/>    self.hash(into: &amp;hasher)<br/>    return hasher.finalize()<br/>}</span></pre><p id="0e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使我们的自定义类型<code class="fe lv lw lx ly b">Student</code>符合<code class="fe lv lw lx ly b">Hashable</code>协议后，上面提到的错误就没有了，和预期的一样。从现在开始，<code class="fe lv lw lx ly b">Student</code>实例可以是一个<code class="fe lv lw lx ly b">Dictionary</code>键或者一个<code class="fe lv lw lx ly b">Set</code>元素。</p><h2 id="93ae" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">复合数据结构</h2><p id="1340" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在学校，老师决定将学生分成两人一组，这样他们就可以完成他们的小组项目。为了帮助教师管理组分配和跟踪，我们可以创建一个名为<code class="fe lv lw lx ly b">Dyad</code>的新结构，如下所示。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="457e" class="md me it ly b gy mf mg l mh mi">struct Dyad {<br/>    var leader: Student<br/>    var teammate: Student<br/>}</span></pre><p id="ea4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以创建一个字典<code class="fe lv lw lx ly b">var dyadScores = [Dyad: Int]()</code>来帮助老师追踪两人一组的分数。</p><p id="5831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，Xcode会告诉我们<code class="fe lv lw lx ly b">Dyad</code>类型不符合<code class="fe lv lw lx ly b">Hashable</code>协议。一些以前有实施<code class="fe lv lw lx ly b">Hashable</code>协议经验的开发人员可能会这样做:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cb8a" class="md me it ly b gy mf mg l mh mi">extension Dyad: Hashable {<br/>    func hash(into hasher: inout Hasher) {<br/>        hasher.combine(leader.hashValue)<br/>        hasher.combine(teammate.hashValue)<br/>    }<br/>}</span></pre><p id="57e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然没有错，但是如前所述，终结过程的计算量很大。因此，我们可以估计为一个<code class="fe lv lw lx ly b">Dyad</code>实例计算<code class="fe lv lw lx ly b">hashValue</code>需要多少时间。</p><p id="3128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设运行一个<code class="fe lv lw lx ly b">combine</code>方法所需的时间是单位时间<code class="fe lv lw lx ly b">t</code>，那么运行一个<code class="fe lv lw lx ly b">finalize</code>方法所需的时间就是<code class="fe lv lw lx ly b">3t</code>。为了计算一个<code class="fe lv lw lx ly b">Student</code>实例的<code class="fe lv lw lx ly b">hashValue</code>，需要<code class="fe lv lw lx ly b">5t</code>(即两次调用<code class="fe lv lw lx ly b">combine</code>和一次调用<code class="fe lv lw lx ly b">finalize</code>)。</p><p id="4a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，使用上面的代码，计算<code class="fe lv lw lx ly b">Dyad</code>的<code class="fe lv lw lx ly b">hashValue</code>所需的时间总共是<code class="fe lv lw lx ly b">15t</code>(领导者的<code class="fe lv lw lx ly b">5t</code>、队友的<code class="fe lv lw lx ly b">5t</code>和<code class="fe lv lw lx ly b">Dyad</code>本身的<code class="fe lv lw lx ly b">5t</code>)。我们能提高效率吗？</p><p id="d530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是<em class="op">是的</em>。下面的代码最大限度地减少了<code class="fe lv lw lx ly b">finalize</code>方法的使用，这大大减少了计算<code class="fe lv lw lx ly b">Dyad</code>的<code class="fe lv lw lx ly b">hashValue</code>的时间。</p><p id="e4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个改进版本，需要的时间只有<code class="fe lv lw lx ly b">7t</code>，甚至不到使用原版本时所需计算时间的一半。</p><p id="f1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，其中一个要带回家的信息是，当你使你的定制类型符合<code class="fe lv lw lx ly b">Hashable</code>协议时，用调用<code class="fe lv lw lx ly b">finalize</code>方法的最少使用来编写<code class="fe lv lw lx ly b">hash(into:)</code>函数。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="242b" class="md me it ly b gy mf mg l mh mi">extension Dyad: Hashable {<br/>    func hash(into hasher: inout Hasher) {<br/>        hasher.combine(leader.firstName)<br/>        hasher.combine(leader.lastName)<br/>        hasher.combine(teammate.firstName)<br/>        hasher.combine(teammate.lastName)<br/>    }<br/>}</span></pre><h2 id="c024" class="md me it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">自动合成</h2><p id="1921" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">但实际上从Swift 4.1开始，编译器已经支持某些类型的<code class="fe lv lw lx ly b">Hashable</code>一致性自动合成，包括struct。</p><p id="c47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们简单地声明<code class="fe lv lw lx ly b">Student</code>符合<code class="fe lv lw lx ly b">Hashable</code>协议而不使用扩展。因为它的两个存储属性(即<code class="fe lv lw lx ly b">firstName</code>和<code class="fe lv lw lx ly b">lastName</code>)都是可散列的，所以该结构本身自动变成了<code class="fe lv lw lx ly b">Hashable</code>。</p><p id="98d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不需要编写自己的<code class="fe lv lw lx ly b">hash(into:)</code>或<code class="fe lv lw lx ly b">hashValue</code>实现。尤其是对于后者，Swift 5已经弃用了<code class="fe lv lw lx ly b">hashValue</code>而支持<code class="fe lv lw lx ly b">hash(into:)</code>方法，尽管它仍然可以编译您的早期代码，在您的自定义类型中实现<code class="fe lv lw lx ly b">hashValue</code>以符合<code class="fe lv lw lx ly b">Hashable</code>协议。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d84d" class="md me it ly b gy mf mg l mh mi">struct Student : Hashable {<br/>    var firstName: String<br/>    var lastName: String<br/>}</span></pre><p id="a87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，自动合成功能非常强大。按照下面的代码，只要它存储的属性是<code class="fe lv lw lx ly b">Hashable</code>，编译器就可以自动让你自定义类型<code class="fe lv lw lx ly b">Hashable</code>，即使有些属性是自定义类型。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d5ed" class="md me it ly b gy mf mg l mh mi">struct Dyad : Hashable {<br/>    var leader: Student<br/>    var teammate: Student<br/>}</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="da56" class="nf me it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">外卖食品</h1><p id="f817" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">阅读本文后，我希望您对Swift中的<code class="fe lv lw lx ly b">Hashable</code>协议及其更广泛的背景有更好的了解。</p><p id="6314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Swift当前版本中通用哈希函数和自动合成功能的实施，实施<code class="fe lv lw lx ly b">Hashable</code>协议变得非常方便。</p></div></div>    
</body>
</html>