<html>
<head>
<title>A Comprehensive Guide to Profiling Python Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析Python程序的综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-profiling-python-programs-f8b7db772e6?source=collection_archive---------5-----------------------#2020-12-01">https://betterprogramming.pub/a-comprehensive-guide-to-profiling-python-programs-f8b7db772e6?source=collection_archive---------5-----------------------#2020-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="576b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解代码的哪些部分有问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db9669e67b99c8d66ad307f4990e0486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zSaeeD9wZGioTQ8B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@ja5on?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈以桐</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="cdbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，用户对他们使用的程序有很高的期望。用户期望程序具有令人惊奇的特性，运行速度快，并消耗合理的内存量。</p><p id="a7f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发人员，我们应该尽力给用户最好的体验。我们需要在瓶颈影响到我们的用户之前找到并消除它们。不幸的是，随着程序变得越来越复杂，发现这些问题和瓶颈变得越来越困难。</p><p id="b522" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将重点介绍一种找到这些瓶颈的技术，这种技术就是剖析。我今天的目标是向你们展示侧写并不是火箭科学。每个人都能毫不费力地找到自己的瓶颈。</p><p id="3ea1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的代码可以在<a class="ae kv" href="https://github.com/eyaltrabelsi/my-notebooks/blob/master/Lectures/profiling_python_by_example/Profiling%20Python%20by%20Example.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，更详细的录制版本可以在<a class="ae kv" href="https://www.youtube.com/watch?v=9wfFXRCkkLE" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d838" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">特征分析的定义和优点</h1><p id="5a46" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">概要文件是一组描述我们的程序如何执行的统计数据。当我们知道代码的不同部分是如何工作的，我们可以使用这些信息来优化我们的代码。</p><p id="8ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定会问自己，为什么我还要关心优化我的代码，我的功能已经完成了。你应该关心优化，因为它影响我们的用户和我们的公司。这些是主要原因:</p><ul class=""><li id="f3ed" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">快程序比慢程序好</strong>——无论是延迟还是吞吐量。</li><li id="d0bf" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">内存效率很好</strong> —我们大多数人都害怕内存不足的错误。</li><li id="f5b5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">省钱很棒</strong>——如果内存不足的错误没有吓到你，你的AWS账单可能会。</li><li id="67c6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">硬件有局限性</strong> —即使我们愿意花钱来提高性能，硬件也只能帮你到此为止。</li></ul><p id="c50f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望我已经说服了你，剖析是每个程序员工具箱中需要的一个概念。但是在我们跳入水中之前，我要讲一些安全规则。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b37c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安全规则</h1><p id="9c4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面的规则是用血写的。</p><ul class=""><li id="ad94" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">确保它是真正需要的</strong>——优化的代码更难编写和阅读，这使得它更难维护和调试。我们需要收集需求(SLA/SLOS)来理解我们对“完成”的定义</li><li id="9216" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">确保我们的代码经过良好的测试</strong>——我知道每个人都这么说，但这真的很重要。如果我们修复了性能问题，这将是令人难过的，但我们的程序将不会工作。</li><li id="cd59" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">好的工作需要周期</strong> — <strong class="ky ir"> </strong>我们应该关注代码中有问题的部分(瓶颈)。</li></ul><p id="99ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经通过了安全规则，我们终于可以跳入水中，并了解存在哪些类型的分析器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="da48" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">分析器的类型</h1><p id="04c7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们想找到我们的瓶颈时，我们需要使用正确的工具，因为没有免费的午餐。</p><p id="91ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为工作选择合适的工具取决于以下特征:</p><ul class=""><li id="10bf" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">我们想要测量的资源</strong> —无论是CPU、RAM、I/O还是其他外来指标。</li><li id="aad6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">概要分析策略</strong> — <strong class="ky ir"> </strong>概要分析器如何收集数据:使用钩子以确定性的方式，或者通过在每个时间间隔收集信息以统计的方式。</li><li id="85e3" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">剖析粒度</strong> —我们在什么级别获得信息:程序级、函数级或行级。显然，如果我们使用更精细的粒度级别，如线级别，我们可以提取更多的洞察力，但这将增加很多噪声。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d6b8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们的例子</h1><p id="dd92" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我将使用Peter Norvig的简单拼写纠正工具。Norvig的拼写校正器使用Levenshtein距离来查找拼写错误。</p><blockquote class="nk nl nm"><p id="5cbf" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">“Levenshtein距离是一个字符串度量，用于测量两个单词之间的差异。两个单词之间的距离是将一个单词变成另一个单词所需的单字符编辑(即插入、删除或替换)的最少次数—<a class="ae kv" href="https://dzone.com/articles/the-levenshtein-algorithm-1#:~:text=The%20Levenshtein%20distance%20is%20a,one%20word%20into%20the%20other" rel="noopener ugc nofollow" target="_blank">Levenshtein距离算法</a></p></blockquote><p id="4113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Norvig的拼写校正器通过查找Levenshtein距离为2或更小的最可能的单词来纠正拼写错误。这个拼写校正器看起来相当幼稚，但它实际上达到了80%或90%的准确率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="814c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用我们的拼写校正器来理解下面的信息“grofilingg不是rocet Sgience”，我们得到“剖析不是火箭科学。”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/3f8be00e20eab56878bc8ead156c2e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuPWbLtZ03nOi3yjVrdCMA.png"/></div></div></figure><p id="02b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从第一种类型的分析器开始分析我们的例子，临时分析器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c938" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">临时侧写员</h1><p id="48b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">临时分析器让我们了解程序整体上是如何运行的，并让我们了解是否存在问题。</p><p id="73c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要介绍的第一个工具是<code class="fe nu nv nw nx b">time</code>，它帮助我们测量单次运行的用户和系统时间。它是Python内置的，带有IPython magic，不需要额外安装。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/c0d0b4d7b1b08f221fe93be7f600c7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFhn_suf-zegzIg15hv_mw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">墙时间是总的执行时间，CPU时间是程序使用CPU的时间。在我们的示例中，我们可以看到墙时间为220毫秒，其中219毫秒花费在CPU上，这意味着我们受到CPU的限制。</p></figure><p id="52cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要介绍的下一个工具是<code class="fe nu nv nw nx b">timeit</code>模块，它帮助我们测量多次运行的执行时间。它是Python中内置的，并带有IPython，不需要额外安装。它使用一些巧妙的技巧，比如禁用垃圾收集，使结果更加一致。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/d2acc37203cfd3bcde9f31a5804433f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s5Piq3VQ8SrJeb62com4Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们可以看到，我们的程序执行了7次，平均执行时间为22毫秒，两次执行之间的差异为3.6毫秒。</p></figure><p id="fe35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想要相似的能力，为了比较两段(或更多)代码，你<a class="ae kv" href="https://fastero.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> fastero </a>可能值得你花时间。</p><p id="85da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我今天要介绍的最后一个临时剖析工具是<code class="fe nu nv nw nx b">memit</code> magic，它帮助我们测量进程内存。它不是Python内置的，所以需要安装，但是安装之后，我们可以使用IPython magic。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/e2e28b90c3e6854f292a1396c673a6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVCFPL4iIaefINr0RPNbew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">峰值内存是进程使用的最大内存，增量是这个特定调用增加了多少内存消耗。我们可以看到，改正一句话增加了0.69 Mib的内存消耗。</p></figure><p id="ef5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一些比较随意的剖析工具，以及如下的随意剖析景观️️️️looks:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/97b8ff478d348111a6c73f5a06b774fa.png" data-original-src="https://miro.medium.com/v2/format:webp/1*UdIL6X17kkTAUpVpg8msbQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">休闲侧写风景️️️️</p></figure><h2 id="0055" class="oc ma iq bd mb od oe dn mf of og dp mj lf oh oi ml lj oj ok mn ln ol om mp on bi translated">随意侧写有以下优点和缺点</h2><ul class=""><li id="5d5a" class="mw mx iq ky b kz mr lc ms lf oo lj op ln oq lr nb nc nd ne bi translated">它们真的很容易使用。</li><li id="7305" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们让我们了解问题是否存在。</li><li id="fa55" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">但是我们不能用它们来找出瓶颈。</li></ul><p id="37ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我们不能精确定位瓶颈是至关重要的，并引导我们到下一组分析器，离线分析器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7d7b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">离线分析器</h1><p id="f526" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">离线分析器通过跟踪函数调用、异常和行执行等事件，帮助我们理解程序的行为。因为它们在特定事件上执行钩子，所以它们是确定性的，并且增加了大量开销，这使得它们更适合本地调试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/01b41509f2e5ceab1f05b560bbb2b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KypKkMmHwTOsoGWLSnUBrQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Python允许你使用<em class="os"> sys.setprofile </em>或sys.settrace指定对特定解释器事件的回调。</p></figure><p id="a270" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要介绍的第一个工具是<code class="fe nu nv nw nx b">cProfile</code>，它跟踪每个函数调用，并允许我们识别耗时的函数。默认情况下，它测量进程CPU，但允许我们指定自己的测量。它是Python内置的，带有IPython magic，不需要额外安装。<code class="fe nu nv nw nx b">cProfile</code>仅适用于Python级别，不适用于多个进程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/cb0fdd7d38a23dadfdfa94c838f56d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIMKpJ-L4idgodXfX1Ahdw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们可以看到我们的sentence_correction函数用了0.24秒。所有这些都花在了候选函数上，当我们深入研究时，edits1花费了0.1秒(40%)。</p></figure><p id="cd88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要处理的文本很多，而且对初来乍到的人来说有点加密。为此，发明了下一个工具，<code class="fe nu nv nw nx b">SnakeViz</code>。<code class="fe nu nv nw nx b">SnakeViz</code>接受<code class="fe nu nv nw nx b">cProfile</code>的输出并创建直观的可视化效果。它不是Python内置的，所以需要安装，但安装后，我们可以使用IPython magic。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/9e49f236c0f90362336972fbacddfe27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGefOgRxue9B4-fgkipe6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">很容易看到所有的时间都花在了候选函数上，当我们深入研究时，edits1花费了0.1秒(40%)。此外，我们可以过滤并更改显示的层数</p></figure><p id="c1af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我今天要介绍的最后一个临时剖析工具是<code class="fe nu nv nw nx b">memory_profiler</code>。顾名思义，它允许我们测量函数中每一行对内存占用的影响。它不是Python内置的，所以需要安装，但安装后，我们可以使用IPython magic。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/9a1e23a83bcaf6318fdecc1132325fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjwMqX7jVLrTiR6iROzL8g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们可以看到，我们监视了edits1函数的内存占用。我们可以看到，我们以169 MBS开始这个函数，每一行都没有增加很多开销。这让我们相信大部分的内存消耗是由于我们的词汇。</p></figure><p id="8512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下，使用<a class="ae kv" href="https://github.com/pythonspeed/filprofiler" rel="noopener ugc nofollow" target="_blank"> filprofiler </a>或<a class="ae kv" href="https://github.com/bloomberg/memray" rel="noopener ugc nofollow" target="_blank"> memray </a>来分析内存会更容易。但是总的来说，还有很多离线评测器，离线评测的前景️️️️looks如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/26a783a5e27fb44b7b68aa82667544a3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GpDgii5wai-sgFVJ3LjtfA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">离线剖析景观️️️️</p></figure><h2 id="0201" class="oc ma iq bd mb od oe dn mf of og dp mj lf oh oi ml lj oj ok mn ln ol om mp on bi translated">离线分析器有以下优点和缺点</h2><ul class=""><li id="78dd" class="mw mx iq ky b kz mr lc ms lf oo lj op ln oq lr nb nc nd ne bi translated">它们让我们能够找出瓶颈。</li><li id="93f1" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们是决定性的。</li><li id="23e0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">他们开销很大。</li><li id="da5f" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们真的很容易使用。</li><li id="ab5d" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们的输出可能有噪声。</li><li id="f35a" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">他们不能告诉我们哪些输入是慢的。</li><li id="f963" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">他们扭曲了程序的某些部分，因为它只在特定的事件上运行钩子。</li></ul><p id="b627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我们想到了最后一种侧写器，在线侧写器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f843" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在线分析器</h1><p id="96ce" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在线分析器通过定期对程序执行堆栈进行采样，帮助我们理解程序的行为。背后的想法是，如果一个函数累积慢，它会经常出现，如果一个函数快，我们根本不会看到它。因为它们是定期执行的，所以它们是不确定的，并且增加了边际开销，这使它们更适合于生产使用。我们可以通过增加采样间隔和增加更多开销来控制精度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/1c5822c058e19d06540d72da1ec1d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHcxCSiyGiz-nXDYLQV0MA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们使用setitimer系统调用每隔X毫秒向Python程序发送一次信号。Python让我们指定一个信号处理器来记录我们的堆栈。</p></figure><p id="3415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将只介绍<code class="fe nu nv nw nx b">pyinstrument</code>，它通过每一毫秒采样和记录统计数据来测量进程CPU。它不是Python内置的，所以需要安装，而且它没有IPython magic。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/5bed0de28d25cfb3a64d7ceb10eae3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14X-3ivkHu8kbxfdCXRkFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们可以看到我们的sentence_correction函数用了0.28秒。所有这些都花在了候选函数上，当我们向下钻取edits1时，花费了0.1秒(40%)。我们可以看到，由于pyinstrument的统计特性，层次结构中的函数(和噪声)要少得多。</p></figure><p id="2b7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在有更多的在线剖析工具，️️️️looks的在线剖析工具如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/9a2347f6cafe577027d83365bb61b336.png" data-original-src="https://miro.medium.com/v2/format:webp/1*VMSYAuM0q7Am3nl-BDtYqQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在线剖析️️️️风景</p></figure><h2 id="d573" class="oc ma iq bd mb od oe dn mf of og dp mj lf oh oi ml lj oj ok mn ln ol om mp on bi translated">在线分析器有以下优点和缺点</h2><ul class=""><li id="7c45" class="mw mx iq ky b kz mr lc ms lf oo lj op ln oq lr nb nc nd ne bi translated">它们让我们能够找出瓶颈。</li><li id="944c" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们不是决定性的。</li><li id="3733" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">尽管如此，它们引入了开销(边际)。</li><li id="d6ca" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">它们真的很容易使用。</li><li id="20e4" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">他们不能告诉我们哪些输入是慢的。</li></ul><p id="6167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在本文中介绍了许多工具。现在，您有能力在99%的用例中找到瓶颈。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b8c8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的百分比</h1><p id="7853" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">但是我们仍然不能判断哪些输入会降低我们程序的速度，如果我们想要描绘一个奇异的度量，比如上下文切换的数量，我们就有一个问题。</p><p id="c57a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您碰巧没有找到适合您问题的分析器，<br/>您可以创建自己的分析器:</p><ul class=""><li id="ecb2" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">您可以使用<code class="fe nu nv nw nx b"><a class="ae kv" href="https://pythonspeed.com/articles/custom-python-profiler/" rel="noopener ugc nofollow" target="_blank">cProfile</a></code>或<code class="fe nu nv nw nx b"><a class="ae kv" href="https://www.youtube.com/watch?v=e03oTN3e0aM" rel="noopener ugc nofollow" target="_blank">sys.settrace</a></code> <a class="ae kv" href="https://www.youtube.com/watch?v=e03oTN3e0aM" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe nu nv nw nx b"><a class="ae kv" href="https://www.youtube.com/watch?v=e03oTN3e0aM" rel="noopener ugc nofollow" target="_blank">sys.setprofile</a></code>创建一个自定义的离线分析器。</li><li id="4625" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">您可以使用<code class="fe nu nv nw nx b"><a class="ae kv" href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-/" rel="noopener ugc nofollow" target="_blank">setitimer</a></code>或<code class="fe nu nv nw nx b"><a class="ae kv" href="https://eng.uber.com/pyflame-python-profiler/" rel="noopener ugc nofollow" target="_blank">ptrace</a></code>创建一个定制的在线分析器。</li><li id="5a5e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">您可以使用 <code class="fe nu nv nw nx b"><a class="ae kv" href="https://github.com/lmacken/pyrasite" rel="noopener ugc nofollow" target="_blank">pyrasite</a></code>将Python代码附加到正在运行的进程<a class="ae kv" href="https://github.com/lmacken/pyrasite" rel="noopener ugc nofollow" target="_blank">上。</a></li></ul><p id="9508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了减轻分析器不能告诉我们哪些输入很慢的事实，我们可以将日志记录与分析结合使用。日志允许我们记录任何我们想要的东西，没有性能损失。但是您需要提前添加日志记录，否则您就不走运了。</p><p id="8175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">专业提示</strong>:记录热功能输入和持续时间。</p><p id="ce83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们找到了瓶颈，现在怎么办？我们只需要解决问题——说起来容易做起来难。那么我们必须注意性能退化。优化的代码往往是重构的候选对象。我们需要确保我们不会再次提出同样的问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="adb7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">遗言</h1><p id="cfdb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我们首先解释了为什么我们应该关注性能并找到我们的瓶颈。接下来，我们介绍了如何使用profilers来找到这些瓶颈，并让我们的用户满意。</p><p id="22ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我能够分享我对这个迷人的话题的热情，并且你会发现它是有用的。一如既往，我欢迎任何建设性的反馈。</p></div></div>    
</body>
</html>