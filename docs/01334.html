<html>
<head>
<title>Real-Time Search Engine With RxJS (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS的实时搜索引擎(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/real-time-search-engine-with-rxjs-530cbadcde8c?source=collection_archive---------6-----------------------#2019-09-02">https://betterprogramming.pub/real-time-search-engine-with-rxjs-530cbadcde8c?source=collection_archive---------6-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用几个RxJS库演示Angular中的实时搜索引擎</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/606036a4fc7b20ae1b4f33ebc3b7580d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_76P6EKQhVmEvHsI_6Vcw.png"/></div></div></figure><p id="d63d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我将演示如何使用几个可用的RxJS库在Angular中实现实时搜索引擎。我将把教程分成两个部分:第一部分将集中在把我们的搜索框和搜索结果放在一个单独的组件中，然后最后一部分将集中在如何使组件解耦和可重用。</p><p id="b7be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，搜索引擎所做的是根据用户输入的搜索查询，向HTTP资源发出获取数据的请求。我们将使用<a class="ae lq" href="https://cdnjs.com/api" rel="noopener ugc nofollow" target="_blank"> cdnjs </a>库的API。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3124" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">入门指南</h1><p id="4218" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了深入研究，我们将创建一个名为<code class="fe mv mw mx my b">Search</code>的新组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/45508b789792f8f03885b89189bcd9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0CMS9ugV_L9JO7F4B4I1zw.png"/></div></figure><p id="385b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们为搜索框添加标记。</p><p id="b757" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我用的是Bootstrap框架，你可以从<a class="ae lq" href="https://getbootstrap.com/docs/4.3/getting-started/introduction/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>中获取CDN链接，只需复制粘贴到你的<code class="fe mv mw mx my b">index.html</code>文件中即可。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/9c514e87016761b97a65a137a291baab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkXpO94cHTgWOzvmQLLBYA.png"/></div></div></figure><p id="ab7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据上面的标记，我们创建了一个input元素，它附带了一个<code class="fe mv mw mx my b">keyUp</code>事件(我们将在后面详细讨论)。</p><p id="db51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还用引导类<code class="fe mv mw mx my b">list-group</code>创建了一个<code class="fe mv mw mx my b">div</code>，来显示我们的搜索结果。我将在教程的后面对此进行更多的解释。</p><p id="b631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们添加CSS代码，这是尽可能少的代码，只是为了给标记添加一点样式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b130dc944060493db36bd4e5a5d42326.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*plPVufn0Sxz0n7kH4ptuqQ.png"/></div></figure><p id="9792" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，我们试图实现的是获取用户的输入，这将是我们对API的查询词，并用搜索词发出我们的<code class="fe mv mw mx my b">GET</code>请求。</p><p id="2c67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多方法可以实现这一点，我们将走RxJS路线。</p><ol class=""><li id="ef84" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">我们将获得用户的输入，并用它创建一个可观察的流。</li><li id="6e65" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">在每个keyup事件中，我们用windows事件更新可观察的流。</li><li id="1164" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">我们等待几毫秒(以确保用户已经停止输入)，然后用搜索词发出<code class="fe mv mw mx my b">GET</code>请求。</li></ol><p id="ae09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在组件的<code class="fe mv mw mx my b">.ts</code>文件中，只需添加这些:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9876bf4e61694c0dc1b54ba0c5c6e4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ArlOobimhFcUwWfGNQf0eg.png"/></div></figure><ol class=""><li id="6977" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">我创建了一个<code class="fe mv mw mx my b">loading</code> <strong class="kw iu"> </strong>变量来控制标记，向用户表明正在发出请求。我还添加了<code class="fe mv mw mx my b">baseUrl</code> <strong class="kw iu"> </strong>和<code class="fe mv mw mx my b">queryUrl</code>变量，它们将组合成我们的资源URL。我也创建了我们的<code class="fe mv mw mx my b">searchResult</code>变量。</li><li id="9600" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">我把<code class="fe mv mw mx my b">searchTerm</code>变量变成了<code class="fe mv mw mx my b">subject</code>，它允许我们发布和订阅。</li><li id="ed9a" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">在构造函数中，我将来自<code class="fe mv mw mx my b">@angular/common/http</code>的<code class="fe mv mw mx my b">HttpClient</code>服务作为HTTP注入。</li><li id="304f" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">这行代码<code class="fe mv mw mx my b">map( (e: any) =&gt; e.target.value )</code> <strong class="kw iu"> </strong>只是提取用户输入的值。</li><li id="828d" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mv mw mx my b">debounceTime(400)</code> <strong class="kw iu"> </strong>在400毫秒后抑制请求，即我们仅在用户暂停400毫秒后发出请求。可以<a class="ae lq" href="https://www.learnrxjs.io/operators/filtering/debouncetime.html" rel="noopener ugc nofollow" target="_blank">阅读更多关于</a> <code class="fe mv mw mx my b"><a class="ae lq" href="https://www.learnrxjs.io/operators/filtering/debouncetime.html" rel="noopener ugc nofollow" target="_blank">debounceTime</a></code>的内容。</li><li id="2209" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mv mw mx my b">distinctUntilChanged()</code> <strong class="kw iu"> </strong>将确保只有不同的数据通过。如果用户键入一些东西，快速擦除一个字符，然后重新键入相同的字符，<code class="fe mv mw mx my b">distinctUntilChanged</code>将只发送一次数据。</li><li id="75e5" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mv mw mx my b">filter( (term: string) =&gt; term.length &gt; 0)</code> <strong class="kw iu"> </strong>将确保流只发出长度大于0的搜索词。如果您想消除短搜索，实际上可以使用更高的值。</li><li id="ccbc" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">下面几行对可观察对象进行订阅，将<code class="fe mv mw mx my b">true</code>赋给<code class="fe mv mw mx my b">loading</code> <strong class="kw iu"> </strong>并调用<code class="fe mv mw mx my b">_searchEntries</code> <strong class="kw iu"> </strong>方法。我们很快就会谈到这个方法。</li></ol><p id="0506" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们创建<code class="fe mv mw mx my b">searchEntries</code> <strong class="kw iu"> </strong>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8713d450a4fce0f601f2c21e8fddb295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*zWaxlzMGdPVDleowFPsLOA.png"/></div></figure><p id="c48d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个方法(<code class="fe mv mw mx my b">searchEntries</code>)发出HTTP请求来获取我们的资源，并返回可观察到的响应。请注意响应是如何映射的，并且<code class="fe mv mw mx my b">searchResult</code> <strong class="kw iu"> </strong>被设置为响应。</p><p id="90e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个方法用于订阅从第一个方法返回的可观察对象。这里，如果请求成功，<code class="fe mv mw mx my b">loading</code> <strong class="kw iu"> </strong>被设置为<code class="fe mv mw mx my b">false</code>，同样，如果请求中有错误。</p><p id="3ff8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们完整的代码应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c3a6d7ae7e01e0814477c2b322c97a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7mF2WEy5iP4xBN5tEtv-9Q.png"/></div></figure><p id="2ce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本系列的第二部分中，我们将看到如何使组件可重用。文章的第二部分可以在<a class="ae lq" href="https://medium.com/better-programming/real-time-search-engine-with-rxjs-part-2-6585d9394128" rel="noopener">这里</a>找到。</p><p id="1bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过编码来改变现状…</p></div></div>    
</body>
</html>