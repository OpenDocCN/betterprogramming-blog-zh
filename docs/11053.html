<html>
<head>
<title>How To Create an Auto-Updater for Desktop Application (Jetpack Compose)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为桌面应用程序创建自动更新程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-an-auto-updater-for-desktop-application-jetpack-compose-d118db26d65f?source=collection_archive---------11-----------------------#2022-02-14">https://betterprogramming.pub/how-to-create-an-auto-updater-for-desktop-application-jetpack-compose-d118db26d65f?source=collection_archive---------11-----------------------#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="743f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这没有你想象的那么难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20a54bf19e4206902dfa460dd2167489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qn2lN_MRE1PJhGLnLFvYdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为桌面撰写</p></figure><p id="1faa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前，我一直致力于桌面应用程序的自动更新，发现谷歌上的信息并不多。所以我找了拿电子的更新器做参考。我将在教程中使用Jetpack Compose(桌面)和Go(服务器)。该逻辑适用于不同的框架/语言。</p><h1 id="c479" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.Jetpack撰写</h1><h2 id="c83e" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">属国</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="b58e" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">创建存储库</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe na nb nc nd b">VersionRepo</code>将有两个功能</p><p id="0275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个是<code class="fe na nb nc nd b">checkForUpdate</code>，负责检查GitHub版本的更新。</p><p id="ba59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个<code class="fe na nb nc nd b">downloadUpate</code>，负责从GitHub release的资产中下载更新，这个函数会将当前的下载进度发送到UI，这样你可以做任何你想做的事情。</p><h1 id="aa7f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.GitHub发布</h1><p id="5f7b" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">可能有另一种方法来发布你的包，但是对于本教程，我将使用GitHub release作为例子。</p><p id="acdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您需要在项目根文件夹中创建一个名为<code class="fe na nb nc nd b">.github/workflows</code>的文件夹，然后在<code class="fe na nb nc nd b">workflows</code>中创建一个扩展名为<code class="fe na nb nc nd b">yml</code>的文件</p><p id="d60c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目文件夹将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c4e8651d05246af248ef55c2feaba1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/0*OewvMPCZvHnpKf6H.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例项目结构</p></figure><h2 id="aa37" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">YAML档案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="89c6" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><code class="fe na nb nc nd b">name </code> — GitHub将在您的回购操作页面上显示该名称</li><li id="89e0" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">on </code> —触发工作流的GitHub事件的名称。它可以是一个数组、字符串等，但是我们将在推送任何新标签时触发我们的工作流</li><li id="65ee" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">defaults </code>—<code class="fe na nb nc nd b">jobs.run</code>的默认设置。默认情况下，我们使用<code class="fe na nb nc nd b">bash</code>来设置它</li><li id="2b1e" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs </code> —工作流运行由一个或多个作业组成。默认情况下，作业并行运行。</li><li id="887d" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;</code> —每个作业必须有一个<code class="fe na nb nc nd b">id</code>与该作业相关联。关键字<code class="fe na nb nc nd b">job_id</code>是一个字符串，其值是作业配置数据的映射。在这里我们将其命名为<code class="fe na nb nc nd b">release</code></li><li id="2108" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.strategy.matrix</code> —矩阵有键和值。矩阵重用作业的配置，并为您配置的每个矩阵创建一个作业，您将能够从<code class="fe na nb nc nd b">matrix</code>上下文中使用它。在这个例子中，我们想要在macos的最新版本上构建，所以我们使用<code class="fe na nb nc nd b">[macos-latest]</code>。如果你也想在Ubuntu和Windows上构建，你可以这样写:</li></ul><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="dc1f" class="mm lv it nd b gy oc od l oe of">jobs:<br/>  release:<br/>  strategy:<br/>    matrix:<br/>      os: [ macos-latest, windows-latest, ubuntu-latest ]</span></pre><ul class=""><li id="3c4b" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.strategy.fail-fast</code> —设置为<code class="fe na nb nc nd b">true</code>时，如果任何<code class="fe na nb nc nd b">matrix</code>作业失败，GitHub将取消所有正在进行的作业。</li><li id="218e" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.runs-on </code> —运行作业的机器类型。该机器可以是GitHub托管的运行程序，也可以是自托管的运行程序。我们用的是<code class="fe na nb nc nd b">${{ matrix.os }}</code>，就像<code class="fe na nb nc nd b">for loop</code>里的<code class="fe na nb nc nd b">i</code></li><li id="51c5" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.if</code> —您可以使用<code class="fe na nb nc nd b">if</code>条件来阻止某个步骤运行，除非满足某个条件。<a class="ae og" href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">查看更多</a></li><li id="38ca" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.steps.name </code> —当前流量的名称</li><li id="27db" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.steps.uses </code> —来自GitHub的可重用动作代码</li><li id="a8fd" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.steps.run </code> —您可以在这里编写一个或多个命令行操作</li><li id="d4a2" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><code class="fe na nb nc nd b">jobs.&lt;job_id&gt;.steps.with</code> —它是一个键值对，将参数传递给<code class="fe na nb nc nd b">action</code></li></ul><h2 id="95a3" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">步骤说明:</h2><ol class=""><li id="313e" class="nk nl it la b lb ne le nf lh oh ll oi lp oj lt ok nq nr ns bi translated"><strong class="la iu">签出</strong> —该操作在<code class="fe na nb nc nd b">$GITHUB_WORKSPACE</code>下签出您的存储库，因此您的工作流可以访问它。</li><li id="2882" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">设置Java</strong>——我们将使用JDK 15来构建</li><li id="477d" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">验证Gradle wrapper </strong> —此操作验证源代码树中存在的<a class="ae og" href="https://docs.gradle.org/current/userguide/gradle_wrapper.html" rel="noopener ugc nofollow" target="_blank"> Gradle Wrapper </a> JAR文件的校验和，如果发现未知的Gradle Wrapper JAR文件，此操作将失败。</li><li id="587d" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">复制CI gradle.properties </strong> —将预定义的<code class="fe na nb nc nd b">gradle.properties</code>复制到<code class="fe na nb nc nd b">~/.gradle</code>目录</li><li id="1863" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">check out Gradle Build Cache</strong>—此动作允许缓存依赖项和构建输出，以缩短工作流执行时间。</li><li id="ebb9" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">构建发布应用</strong> —构建当前操作系统的发行版</li><li id="65bc" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">归档工件</strong> —我们将构建好的工件存储到GitHub上，以供下一步使用</li><li id="a5e6" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt ok nq nr ns bi translated"><strong class="la iu">释放</strong> —释放工件</li></ol><h1 id="5573" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.更新服务器(Golang)</h1><h2 id="6971" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">开始一个新项目</h2><p id="288d" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">首先，您需要创建一个目录。你想叫它什么都可以。</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="7938" class="mm lv it nd b gy oc od l oe of">mkdir updater-server<br/>cd updater-server</span></pre><p id="de95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在添加任何代码之前，让我们使用下面的命令初始化我们的Go项目。你应该用你的GitHub的用户名替换用户名。对我来说，会是<code class="fe na nb nc nd b">OysterD3</code>。</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="9f70" class="mm lv it nd b gy oc od l oe of">go mod init github.com/USERNAME/updater-server</span></pre><h2 id="6465" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">包封/包围（动词envelop的简写）</h2><p id="6dc1" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">让我们在项目根文件夹中创建一个名为<code class="fe na nb nc nd b">main.go</code>的文件，现在就把它放在那里。之后，创建一个<code class="fe na nb nc nd b">.env</code>文件来存储我们的环境变量，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c11a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，让我们创建<code class="fe na nb nc nd b">env/env.go</code>来读取和解析<code class="fe na nb nc nd b">.env</code>。我们需要两个依赖项；让我们现在安装它们:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="7dec" class="mm lv it nd b gy oc od l oe of">go get github.com/caarlos0/env/v6 &amp;&amp; go get github.com/joho/godotenv</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="77ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe na nb nc nd b">service</code>的用途是存储GitHub的Open API请求的逻辑。</p><p id="9753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要从您在<code class="fe na nb nc nd b">.env</code>中设置的存储库中检索所有的版本。默认的HTTP客户端<code class="fe na nb nc nd b">net/http</code>在我们的例子中已经足够好了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="db08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你的库是公开的，你可以直接从GitHub的API下载文件。如果您的存储库是私有的，那么您需要代理来下载，因为GitHub需要一个用于私有回购的访问令牌，您可以在下面看到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f1ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把响应流式传输到我们的应用程序，这样应用程序就能够处理UI状态。查看<a class="ae og" href="https://oysterd3.medium.com/how-to-create-an-auto-update-for-desktop-application-619b2cea9c9" rel="noopener">第一部分</a>了解更多信息。</p><h1 id="88c2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">路由器</h1><p id="50a5" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，让我们来研究路由器。</p><p id="4a94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用任何支持HTTP/2的HTTP web框架。在这种情况下，我们将使用<code class="fe na nb nc nd b">echo</code>作为我们的HTTP web框架。要安装依赖项，请使用以下命令:</p><pre class="kj kk kl km gt ny nd nz oa aw ob bi"><span id="ab82" class="mm lv it nd b gy oc od l oe of">go get -u github.com/labstack/echo/v4</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="02df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前端不必是Jetpack Compose可以是Electron.js，还有，更新服务器不一定要Go。可以用你喜欢的语言和框架来写。逻辑还是一样的。</p><p id="9f07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能对这个感兴趣:</p><div class="ol om gp gr on oo"><a href="https://blog.oysterlee.dev/how-to-release-built-artifacts-from-one-to-another-repo-on-github-e6006b6764a8" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">如何在GitHub上将构建好的工件从一个repo发布到另一个repo？</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">保持您的源代码私有，并公开发布您的发行版</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">blog.oysterlee.dev</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><h1 id="8d95" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><ul class=""><li id="027d" class="nk nl it la b lb ne le nf lh oh ll oi lp oj lt np nq nr ns bi translated"><a class="ae og" href="https://blog.frankel.ch/state-jvm-desktop-frameworks/6/" rel="noopener ugc nofollow" target="_blank">https://blog.frankel.ch/state-jvm-desktop-frameworks/6/</a></li><li id="7336" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><a class="ae og" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/actions/reference/workflow-syntax-for-github-actions</a></li><li id="b9c8" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated"><a class="ae og" href="https://docs.github.com/en/actions/reference/authentication-in-a-workflow" rel="noopener ugc nofollow" target="_blank">https://docs . github . com/en/actions/reference/authentic ation-in-a-workflow</a></li></ul></div></div>    
</body>
</html>