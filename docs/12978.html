<html>
<head>
<title>Pitfalls of Multithreaded Programs and Achieving Thread-Safety Using Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程程序的陷阱和使用Golang实现线程安全</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pitfalls-of-multithreaded-programs-and-achieving-thread-safety-using-go-1ac80c8d8106?source=collection_archive---------8-----------------------#2022-07-16">https://betterprogramming.pub/pitfalls-of-multithreaded-programs-and-achieving-thread-safety-using-go-1ac80c8d8106?source=collection_archive---------8-----------------------#2022-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有没有想过为什么Node.js单线程？并发与并行、竞争条件、死锁、饥饿、锁定(互斥)、信号量、原子、比较和交换CAS等等。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f06d25272d9e66b8bd2418ae2fe6bd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZI5p0NaxGcgNh8ZK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·安维克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5302" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是多线程？</h1><p id="f621" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="mn">(为了更好地理解，我推荐从本文中快速回顾一下什么是线程和进程:</em> <a class="ae ky" href="https://truongnmt.medium.com/difference-between-process-and-thread-479986d15bb6" rel="noopener"> <em class="mn">进程和线程的区别</em> </a> <em class="mn"> ) </em></p><p id="dbe7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">线程是进程中最小的执行单位。每个进程从一个线程开始，通常称为主线程，但是可以从任何线程创建其他线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/d1b3c1f26d3d29a29875218075308dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A7z_WWkrJtiqyf2o.jpg"/></div></div></figure><p id="c889" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">多线程进程在单个进程中有多个线程，每个线程都有自己的程序计数器、堆栈和一组寄存器，但共享公共代码、数据和打开的文件。</p><h2 id="2257" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">使用多线程进程的动机</h2><p id="520b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在现代编程中，每当一个进程有多个任务要独立执行时，线程就非常有用。当任务之一可能被阻塞，并且希望允许其他任务继续进行而不被阻塞时，尤其如此。</p><p id="4db2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">例如web服务器，多线程允许同时处理多个请求，而不必按顺序处理请求或为每个传入的请求分配单独的进程。(后者是在开发线程概念之前这类事情是如何完成的)。守护进程将在一个端口上监听，为每个要处理的传入请求分出一个子进程，然后返回监听该端口)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/dd401ff34854db044da43e5a42e1e864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/0*Zc5HsW3MmECuYLzd.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多线程服务器架构</p></figure><h2 id="f9fd" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">利益</h2><ul class=""><li id="20d6" class="nh ni it lt b lu lv lx ly ma nj me nk mi nl mm nm nn no np bi translated"><strong class="lt iu">响应能力</strong> <br/>当其他线程被阻塞或忙于处理密集型计算时，一个线程仍然可以继续运行。</li><li id="a855" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">资源共享</strong></li><li id="92b2" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">创建和管理线程(以及它们之间的上下文切换)比为进程执行相同的任务要快得多。</li><li id="6ca5" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><strong class="lt iu">可扩展性，即多处理器架构的利用<br/> </strong>一个单线程进程只能在一个CPU上运行，无论有多少个可用的CPU，而多线程应用的执行可以在可用的处理器之间拆分。</li></ul><h1 id="0c2a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">并发性与并行性</h1><p id="60df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于多线程进程，它是并发运行还是并行运行？<br/>要回答这个问题，首先我们来了解一下这两个术语的区别。</p><p id="3b57" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">例如，我们有一个复杂的问题，并把它分解成更小的部分。同时执行那些较小的问题<em class="mn"/>就是并行。</p><p id="ae0e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另一方面，并发是指同时处理(而不是做)许多事情的能力。这是我们<em class="mn">构建</em>的方式，将问题分解成独立的组件，这使得它能够<em class="mn">潜在地</em>并行运行。一旦我们分解了问题，我们就可以使用或不使用 并行来执行那些问题<strong class="lt iu"> <em class="mn">。并行不是并发的目标，并发的目标是一个好的结构。</em></strong></p><p id="c044" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你运行一个操作系统，它可能有一个鼠标驱动程序或键盘驱动程序，显示驱动程序，网络驱动程序，或其他任何东西。这些都是由操作系统作为内核中独立的东西来管理的。但是这些是同时发生的事情，它们不一定是平行的。如果你的CPU只有一个处理器，那么每次只有一个处理器在运行。</p><p id="a566" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">单个处理器上的多线程给人以并行运行的错觉。事实上，处理器通过使用调度算法在线程之间切换执行，从而导致并发执行。在给定的时间，只有一个线程正在取得进展。线程之间的切换发生得足够快，以至于线程可能<em class="mn">看起来</em>同时运行。</p><blockquote class="nv nw nx"><p id="fbe0" class="lr ls mn lt b lu mo ju lw lx mp jx lz ny mq mc md nz mr mg mh oa ms mk ml mm im bi translated">…这种上下文切换通常发生得足够频繁，以至于用户认为线程或任务是并行运行的(对于流行的服务器/桌面操作系统，当其他线程正在等待时，一个线程的最大时间片通常限制在100-200毫秒)。<br/>(线程(计算)——<a class="ae ky" href="https://en.wikipedia.org/wiki/Thread_(computing)#Single-_vs_multi-processor_systems" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></blockquote><p id="84fc" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在多处理器环境中的同一个多线程进程中，每个线程可以在一个单独的处理器上并发运行，导致并行执行，这是真正的同时执行。当线程数量小于或等于可用处理器数量时，操作系统会确保每个线程运行在不同的处理器上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b2976c40b8519964b026e4f5a3825b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bUkaTsNH3KtO8DJD.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">并发性与并行性—由<a class="ae ky" href="https://www.baeldung.com/cs/concurrency-vs-parallelism" rel="noopener ugc nofollow" target="_blank"> Baeldung </a>制作的图像</p></figure><p id="ac6b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">后续问题:<br/></strong>node . js如何用单线程处理并发请求？</p><p id="75c5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们退后一点，问问我们自己。尽管多线程有这么多好处，为什么Node.js使用单线程，而且一次只处理一个请求呢？</p><p id="67b5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">首先，我们应该了解大多数web应用程序/服务是做什么的。对于带有数据库的典型web应用程序，处理请求的流程如下所示:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="e3e3" class="mu la it od b gy oh oi l oj ok">user do an action<br/>       │<br/>       v<br/> application start processing action<br/>   └──&gt; make database request<br/>          └──&gt; do nothing until request completes<br/> request complete<br/>   └──&gt; send result to user</span></pre><p id="6523" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">需要主动注意的部分称为CPU活动时间，因为它需要CPU主动花时间思考和计算结果。它需要一个线程来处理。</p><p id="f6b9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">不需要主动关注的部分被称为IO(输入输出)，因为它需要等待其他东西提供输入或发送输出。IO的例子包括等待从文件系统中读取文件，等待向另一个服务器发出网络请求，甚至只是等待时间过去。</p><p id="0819" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">想象一下，在一个多线程的web服务器中，我们有100个并发请求，web服务器为每个请求产生100个线程。虽然这些线程可能必须等待来自数据库的100个回复，但是CPU活动时间为零。IO的并行性不受线程的限制，因此100个线程与1个线程一样高效。相反，IO并行性受到IO设备的限制，例如:网卡的数量。因此，如果我们增加线程数量，性能可能不会像我们预期的那样提高。</p><p id="c68e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Node.js所做的是，当请求等待IO时，它通过切换到处理其他请求来节省时间。这就是Node.js所说的非阻塞IO。Node.js在处理所有其他请求之前不会等待一个请求完成。这意味着默认情况下Node.js中的所有请求都是并发的，它们不会等待其他请求完成。</p><p id="a5e1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">IO部分呢？你可能会问。Node.js的内部库<code class="fe ol om on od b">libuv</code>将处理IO。在这个引擎盖下，<code class="fe ol om on od b">libub</code>实际上是一个线程池，每个IO请求都由线程池中的一个线程处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d1096204bfdf3e35d2d612b3d442d8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PUt43SCamARPJxXF.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Node.js app/server单线程事件循环模型—图片由<a class="ae ky" href="https://www.geeksforgeeks.org/why-node-js-is-a-single-threaded-language/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a>提供</p></figure><p id="3c3a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">总之，选择一个web服务器应该取决于我们正在处理什么样的请求。不进行CPU密集型操作的单线程Node.js服务器可以运行数千个并发连接，性能优于基于线程的服务器(每个请求一个线程)。</p><h1 id="3cd8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">多线程程序的问题</h1><p id="5369" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于多线程程序，多个线程可以并发或并行运行同一段代码。它可以以“线程安全”或“非线程安全”的方式运行。接下来，我们将弄清楚这些问题是什么，以及如何避免它们。</p><h2 id="a084" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">线程安全</h2><p id="96a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">线程安全是一个概念，意味着不同的线程可以访问相同的资源，而不会产生不可预知的结果，如竞争条件或死锁。</p><p id="b3a6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们看一个例子，我们希望在初始化数据库连接时实现一个单例模式。简而言之，只需初始化一次数据库连接对象，并在需要与数据库交互时使用该对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有线程安全</p></figure><h2 id="858b" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">竞赛条件</h2><p id="828a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">临界区是指有可能被多个线程同时执行并共享应用程序使用的数据或资源的任何一段代码。上面的代码工作正常，但是在第10行有一个竞争条件。</p><p id="3e89" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">假设多个线程同时在第10行上运行，线程“竞争”读取<code class="fe ol om on od b">instance</code>变量，它在那时做nil，然后多个线程初始化与数据库的连接，这可能会消耗数据库的所有连接池。</p><p id="385e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">竞争条件下的输出难以预测且不一致。</p><h2 id="fc7b" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">锁定(互斥)</h2><p id="e4f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有几种方法可以避免争用情况，从而实现线程安全。第一种方法是锁定或互斥。</p><p id="e89f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">互斥如名<strong class="lt iu"> Mut </strong> ual <strong class="lt iu"> ex </strong> clusion，只有一个线程拥有独占访问权限，并阻止其他线程访问该资源。它允许所有线程都能够使用资源，但一次只允许一个进程使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用互斥的线程安全。</p></figure><p id="34d9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">例如，线程A运行在第12行，它尝试并成功获取了一个锁，然后它运行在第17行并创建了一个单独的数据库连接对象。同时，当线程B运行在第12行时，它必须等待获取锁，因为线程A持有锁。线程A在第20行返回后，在第13行释放获取的锁(<code class="fe ol om on od b">defer</code>关键字将把语句的执行移动到函数的最末尾)。</p><p id="aa36" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在此之前，线程B可以成功获取第12行的锁，并检查<code class="fe ol om on od b">instance</code>变量是否为<code class="fe ol om on od b">nil</code>，由于它已经被线程A赋值，所以它不会再次初始化singleton对象。然后它释放获得的锁。</p><p id="6653" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在Golang有一种更干净的方式，那就是使用<code class="fe ol om on od b">sync.Once</code>库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="7d6d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另见:<a class="ae ky" href="https://go.dev/src/sync/once.go" rel="noopener ugc nofollow" target="_blank">同步。一旦实现</a> <br/>当读到他们为什么不做比较和交换(CAS)来检查动作是否已经完成时，我发现非常有趣。关于CAS我们将在下面讨论。</p><h2 id="3129" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">僵局</h2><p id="72e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当获取锁时，我们必须仔细考虑是否会发生死锁。</p><p id="7b1a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当两个或多个线程无法取得任何进展时，就会发生死锁，因为第一个线程所需的资源被第二个线程占用，而第二个线程所需的资源被第一个线程占用。</p><p id="beae" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">例如，一个多线程程序需要写入两个资源。线程1正在写入资源1，它阻止其他线程写入资源1，然后它想要写入资源2，但它被线程2阻止。同时，线程2正在等待资源1被释放，但是线程1正在等待资源2被释放，死锁正在发生。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c0eaa56be7d67af422c436ad2d484234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*shmdv5nNyy6JvEzS.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">进程1持有资源1并等待由进程2获取的资源2 —图片由<a class="ae ky" href="https://www.geeksforgeeks.org/introduction-of-deadlock-in-operating-system/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a></p></figure><p id="fb44" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为了检测和避免死锁，操作系统必须事先获得关于进程在其生命周期内将请求和使用哪些资源的附加信息。死锁避免算法通过检查如果请求的资源被分配，则在将来没有死锁发生的可能性来分析每个请求。</p><h2 id="af01" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">资源匮乏</h2><p id="d869" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了死锁之外，程序线程还会经历饥饿，在这种情况下，它永远无法访问所需的资源来处理它的工作。饥饿可能是由时间安排上的错误造成的。例如，如果一个(设计糟糕的)多任务系统总是在前两个任务之间切换，而第三个任务从来没有运行过，那么第三个任务就缺乏CPU时间。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="21fb" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">旗语</h2><p id="274f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">避免竞争条件的第二种方法是信号量。</p><p id="44eb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">假设一个图书馆有10间相同的自习室，每次供一名学生使用。如果学生想使用自习室，他们必须向前台申请一个房间。如果没有空房间，学生们就在桌前等候，直到有人让出房间。当学生使用完一个房间后，学生必须回到课桌前，并指出一个房间已经空了。</p><p id="ab2f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在最简单的实现中，前台的职员只知道可用的空闲房间的数量，他/她只有在所有学生都使用房间并在他们用完时归还房间时才正确知道。当一个学生要求一个房间，职员减少这个数字。当一个学生腾出一个房间时，职员会增加这个数字。</p><p id="1121" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这个例子中，前台代表一个计数信号量，房间代表资源，学生代表进程/线程。这个例子中信号量的值最初是10，所有房间都是空的。限于值0和1(或锁定/解锁、不可用/可用)的信号量称为二元信号量。</p><p id="7779" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为了避免饥饿，信号量可以实现一个FIFO队列。当进程/线程具有不同的优先级时，可以按照优先级对队列进行排序，从而首先从队列中取出优先级最高的进程。</p><p id="b20f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">参见:<a class="ae ky" href="https://en.wikipedia.org/wiki/Semaphore_(programming)#Semaphores_vs._mutexes" rel="noopener ugc nofollow" target="_blank">信号量与互斥量</a></p><p id="ac10" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">给你后续问题:<br/> </strong> <em class="mn">互斥vs二元信号量？</em></p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="f86e" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">原子操作</h2><p id="e623" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">“Atom”来源于极客“atomos”=“不可切割”，意思是“不可分割的最小单位”。在操作系统中，原子操作是指有效地同时发生或根本不发生的操作。它不能中途停下来，留下不一致的状态。在操作完成之前，原子操作的副作用是不可见的。</p><p id="a8bb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在并发编程中，原子性等同于线性化，线性化有一个额外的特性，即在它完成之前，它的任何效果都是不可见的。也就是说，其他线程看不到中间状态。(在数据库系统中，该属性被单独归类为“隔离”。)由多个线程运行的原子操作将总是一个接一个地顺序出现。</p><h2 id="e3cf" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">比较和交换</h2><p id="b7a6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">大多数处理器都提供原子比较和交换(CAS)指令，该指令从内存位置读取数据，将该值与用户提供的“预期”值进行比较，如果两者匹配，则写出“新”值，返回更新是否成功。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="510a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里是一个快速游乐场:<a class="ae ky" href="https://go.dev/play/p/RTEv3UtGBYx" rel="noopener ugc nofollow" target="_blank">https://go.dev/play/p/RTEv3UtGBYx</a></p><p id="fb9a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于成功将<code class="fe ol om on od b">atomicinz</code>变量从0交换到1的线程，只有该线程可以创建singleton，其他线程交换变量失败，然后它继续在循环中运行，直到singleton可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/78efe2ac14ecc00bfd728ae88ffcefcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bBTvqtLWCZXCV3-s.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较和交换(CAS)操作—来自<a class="ae ky" href="https://www.baeldung.com/lock-free-programming" rel="noopener ugc nofollow" target="_blank"> baeldung </a>的图像。</p></figure><p id="d002" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">除了CAS，我们还可以使用Load和Store指针值。<br/>参见:<a class="ae ky" href="https://pkg.go.dev/sync/atomic@go1.18.4" rel="noopener ugc nofollow" target="_blank">同步/原子文档</a>。</p><h2 id="d200" class="mu la it bd lb mv mw dn lf mx my dp lj ma mz na ll me nb nc ln mi nd ne lp nf bi translated">阻塞/锁定与非阻塞/无锁定算法</h2><p id="0f6e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据上一篇关于进程/线程的文章，一个线程被允许在CPU中计算一段时间，然后它暂停并从CPU中换出，让另一个线程来完成它的工作。</p><p id="f423" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于操作系统级别的锁定操作，在一个线程获得锁定后，如果该线程的CPU时间已到，并且它被挂起，会发生什么情况？好吧，所有其他线程将只是坐在那里，等待锁被释放，虽然事实上，获得锁的线程没有取得进展，因为它被调度。此外，我们不知道CPU将何时调度线程运行。</p><p id="1d01" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另一个问题是，当线程被换入/换出执行时，存在重新加载/保存线程状态的上下文切换开销。</p><p id="6c2f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">相反，执行原子操作的线程不会等待并不断尝试直到成功，没有上下文切换开销。如果操作系统暂停一个线程，其他线程仍然可以继续运行，当线程恢复时，它只是加载新的值并再次尝试原子操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/63c71f44e1dda7c5ba7c3409d670b83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGV_nBQhCMWoDbIoR4l46w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作系统级阻塞操作与原子操作</p></figure><p id="2289" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一般来说，如果线程之间的争用足够低，原子操作会更快，如果您曾经使用锁定操作，请确保知道您正在使用哪种类型的锁。最好不要使用操作系统级锁定，或者使用CAS锁定(上面的代码示例)，这样线程就不会被挂起。</p><p id="2dd2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">另请参见:<a class="ae ky" href="https://blog.bytebytego.com/i/62209561/blocking-vs-non-blocking-queue" rel="noopener ugc nofollow" target="_blank">来自ByteByteGo </a>的阻塞与非阻塞队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/ffb20a47758e74d4f6153290fb4dcd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jh1BImkS3WsxD8Mdy7wLeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无阻塞队列设计—图片来自ByteByteGo</p></figure><h1 id="2ed6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="59fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们讨论了许多多线程主题:</p><ul class=""><li id="f6a0" class="nh ni it lt b lu mo lx mp ma pb me pc mi pd mm nm nn no np bi translated">多线程程序的利与弊</li><li id="3173" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">并发和并行的区别，<br/>加上Node.js是单线程的原因</li><li id="5955" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">多线程程序的问题:竞争条件、死锁、饥饿</li><li id="18a8" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">如何实现线程安全:锁定(互斥)、信号量、原子操作，例如比较和交换(CAS)</li><li id="be0b" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">阻塞/锁定与非阻塞/无锁定算法</li></ul><p id="e496" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你到了这一步，感谢你的阅读。希望你发现这是有帮助的，你学到了新的东西！</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="ecd4" class="kz la it bd lb lc pe le lf lg pf li lj jz pg ka ll kc ph kd ln kf pi kg lp lq bi translated">参考</h1><ul class=""><li id="8315" class="nh ni it lt b lu lv lx ly ma nj me nk mi nl mm nm nn no np bi translated">罗布·派克【youtube.com T4】【并发不是并行】</li><li id="b664" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://docs.oracle.com/cd/E19253-01/816-5137/mtintro-25092/index.html" rel="noopener ugc nofollow" target="_blank">多线程概念</a>(docs.oracle.com)</li><li id="b70a" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated">Abraham Silberschatz、Greg Gagne和Peter Baer Galvin的“操作系统概念”</li><li id="be46" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://youtu.be/wB9tIg209-8" rel="noopener ugc nofollow" target="_blank">非阻塞I/O以及节点如何使用它:阻塞与异步IO，CPU与IO</a>(youtube.com)</li><li id="3b7c" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Deadlock" rel="noopener ugc nofollow" target="_blank">死锁</a>(en.wikipedia.org)</li><li id="7cbd" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">旗语(编程)</a>(en.wikipedia.org)</li><li id="f487" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://youtu.be/5sZo3SrLrGA?t=3972" rel="noopener ugc nofollow" target="_blank">无锁同步</a>(youtube.com)</li><li id="f4f4" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><a class="ae ky" href="https://medium.com/golang-issue/how-singleton-pattern-works-with-golang-2fdd61cd5a7f" rel="noopener">单例模式如何与Golang一起工作</a>(medium.com)</li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="b8f6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><em class="mn">感谢阅读本文！如果您有任何问题或反馈，请留下您的评论。如果你觉得这篇文章有帮助，请按住鼓掌按钮，让其他人也能发现。请务必在下面注册我的时事通讯，或者在Medium上关注我，以获得更多类似的文章。</em> ☝️👏 🤗</p></div></div>    
</body>
</html>