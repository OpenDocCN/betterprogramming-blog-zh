<html>
<head>
<title>Implementing Cross-Cutting Concerns in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在监督办落实跨部门关注</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-cross-cutting-concerns-in-ios-a312fc72f798?source=collection_archive---------7-----------------------#2021-12-20">https://betterprogramming.pub/implementing-cross-cutting-concerns-in-ios-a312fc72f798?source=collection_archive---------7-----------------------#2021-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在不彻底改变的情况下实现普适特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c92392163e0c2ecfc5df2af5e7e49f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9xhgFk14Ylucpdcz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@robanderson72?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗伯特·安德森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="68e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发一个app的时候，有可能影响整个代码库的非功能性需求。例如，考虑日志记录。为了检查错误，我们可能需要在许多不同的组件中添加日志，以跟踪当前状态和用户正在做的事情。</p><p id="e9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的关注点具有相同的普遍特征:缓存、安全性、度量、验证……所有这些概念都可以跨不同的模块使用，这就是为什么我们称它们为<a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-cutting_concern" rel="noopener ugc nofollow" target="_blank">横切关注点</a>:它们跨越了模块的边界。</p><p id="892e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的实现修改了所有的组件，增加了执行所需任务的依赖性。这种担忧蔓延到整个应用程序的代码中。再次考虑日志记录:如果我们将<code class="fe lv lw lx ly b">log</code>调用分散在整个代码中，并且我们需要更新<code class="fe lv lw lx ly b">log</code>签名，那么我们必须更新所有的调用点，潜在地必须更新整个代码库。</p><p id="541a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将描述一种实现类似特性的更好的方法。首先，我们将使用UIKit创建一个应用程序作为工作示例。然后，我们将以一种天真的方式实现横切关注点。在分析了缺点之后，我们将重构代码以获得更好的方法。最后，我们将讨论实现它们的其他技术。</p><h1 id="1a08" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">该应用程序</h1><p id="4782" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们实现的应用程序(切片)是冥想应用程序的入门。为了简洁起见，我们不会详细讨论所有代码，但我们将只关注重要的部分。我将在整篇文章中分享全部代码，并在<strong class="lb iu">结论</strong>部分分享最终版本。</p><p id="298b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要实现的应用程序由4个屏幕组成:</p><ol class=""><li id="e109" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">欢迎屏幕。</li><li id="06ff" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">询问用户为什么选择安装应用程序的屏幕。</li><li id="443e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">询问用户年龄的屏幕(用于统计目的)。</li><li id="974b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">回顾屏幕。</li></ol><p id="8863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预期行为如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3cce9dedd27f52ba6c0c2ac7449566c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*tOXqH_RrtSgbsW7v4bxRtw.gif"/></div></figure><p id="347d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从与视图最相关的代码开始。</p><h2 id="bcd1" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">欢迎屏幕</h2><p id="4ab5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">欢迎屏幕的完整代码可以在本<a class="ae ky" href="https://gist.github.com/cipolleschi/ac38d0927d42a72e7eb36b6402b0ff85" rel="noopener ugc nofollow" target="_blank">要点</a>中找到。</p><p id="fc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最相关的代码与应用程序的组成方式有关。控制该部分的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="45d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该片段分为两部分:<code class="fe lv lw lx ly b">WelcomeViewController</code>和<code class="fe lv lw lx ly b">WelcomeView</code>。</p><p id="2f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">WelcomeViewController</code>需要初始化一个闭包，并在<code class="fe lv lw lx ly b">loadView()</code>方法中创建<code class="fe lv lw lx ly b">WelcomeView</code>。</p><p id="6570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">WelcomeView</code>需要在<code class="fe lv lw lx ly b">init</code>中进行类似的关闭。当用户点击<code class="fe lv lw lx ly b">Next</code>按钮时，视图调用闭包。</p><p id="48a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<a class="ae ky" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托</a>模式的一个轻量级实现。当<code class="fe lv lw lx ly b">WelcomeView</code>完成其工作时，闭合用于通信。由于这种模式，我们完全分离了入职的各个屏幕:欢迎视图不知道下一个屏幕是什么。</p><p id="b185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建对象图的组件<code class="fe lv lw lx ly b">Composer</code>负责注入导航到正确屏幕的逻辑。</p><h2 id="3ee0" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">理由视图</h2><p id="9bb5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">ReasonView</code>的完整代码可以在本<a class="ae ky" href="https://gist.github.com/cipolleschi/9e4348d735dbdbbf135557827d031ee2" rel="noopener ugc nofollow" target="_blank">要点</a>中找到。</p><p id="e5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把重点放在与应用程序的其余部分最相关的视图组成部分，代码片段如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码片段以一个<code class="fe lv lw lx ly b">Reason</code>枚举开始，描述了用户想要开始冥想的可能原因。</p><p id="5dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个<code class="fe lv lw lx ly b">ReasonsViewController</code>，用一个接受<code class="fe lv lw lx ly b">Reason</code>作为输入的闭包初始化。这样，我们可以将用户的选择传播到<code class="fe lv lw lx ly b">Composer</code>。</p><p id="fcc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击按钮时，<code class="fe lv lw lx ly b">ReasonsView</code>以同样的方式初始化，以使<code class="fe lv lw lx ly b">Reason</code>冒泡。手势在<code class="fe lv lw lx ly b">setup</code>方法中设置，遍历所有按钮并根据点击的按钮传递正确的枚举值。</p><h1 id="8262" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">年龄观</h1><p id="fb9e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">年龄视图的完整代码可以在这个<a class="ae ky" href="https://gist.github.com/cipolleschi/7618e0cb2b136e288dfa9290329567c8" rel="noopener ugc nofollow" target="_blank">要点</a>中找到。</p><p id="5ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再一次关注以下片段中有趣的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段遵循与前面相同的方法。闭包接受一个<code class="fe lv lw lx ly b">Int</code>参数。我们需要将闭包传递给<code class="fe lv lw lx ly b">AgeViewController</code>，它将把闭包传递给<code class="fe lv lw lx ly b">AgeView</code></p><h2 id="c2e4" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">作曲家</h2><p id="c273" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，我们可以把所有的屏幕放在一起。为此，我们创建了一个<code class="fe lv lw lx ly b">Composer</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Composer</code>公开了一个返回onboarding <code class="fe lv lw lx ly b">ViewController</code>的函数。返回类型是一个简单的<code class="fe lv lw lx ly b">UIViewController</code>:通过使用超类，我们可以自由地改变<code class="fe lv lw lx ly b">Composer</code>主体和返回的<code class="fe lv lw lx ly b">ViewController</code>，而不需要将自己限定在一个特定的类型。</p><p id="85c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数使用一个带有一个<code class="fe lv lw lx ly b">Reason</code>和一个<code class="fe lv lw lx ly b">Int</code>参数的闭包来表示用户在入职过程中的选择。<code class="fe lv lw lx ly b">AppDelegate</code>可以决定如何处理这些信息。</p><p id="5e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">onboardingVC</code>方法的主体中，我们用<code class="fe lv lw lx ly b">WelcomeViewController</code>作为<code class="fe lv lw lx ly b">rootViewController</code>来创建一个<code class="fe lv lw lx ly b">NavigationController</code>。在<code class="fe lv lw lx ly b">nextPressed</code>闭包中，我们创建并推送<code class="fe lv lw lx ly b">ReasonsViewController</code>。一旦原因视图控制器终止了它的作业，它就调用一个闭包来创建和推送<code class="fe lv lw lx ly b">AgeViewController</code>。</p><p id="2b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个架构是高度解耦的。我们可以颠倒<code class="fe lv lw lx ly b">Age</code>和<code class="fe lv lw lx ly b">Reasons</code>视图控制器来实现一个完全不同的UX，只需在<code class="fe lv lw lx ly b">onboardingVC</code>方法上工作，不需要改变任何其他代码行。</p><h1 id="46cb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">实施跨领域关注</h1><p id="33e8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在我们可以实现我们的日志功能了。我们希望在用户每次点击next按钮时记录一个条目，看看发生了什么。</p><p id="d5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从定义一个<code class="fe lv lw lx ly b">LogService</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码片段引入了一个具有<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">timestamp</code>属性的<code class="fe lv lw lx ly b">Event</code>结构。它还定义了一个<code class="fe lv lw lx ly b">data</code>属性，为了简单起见，我们将其定义为<code class="fe lv lw lx ly b">[String: String]</code>。对于更完整的解决方案，我们可以使用这个<code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-encode-and-decode-any-json-safely-in-swift-d5b2b8e2e1e3">JSON</a></code>枚举。</p><p id="9e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议定义了一个简单的<code class="fe lv lw lx ly b">log</code>功能。我们可以实现不同种类的日志:写入文件、数据库或发送信息到远程服务器。对于这个例子，我们使用一个简单的<code class="fe lv lw lx ly b">ConsoleLogger</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录器接收该事件，并准备一条操作数据字段的消息。然后，它在控制台中打印消息。</p><h2 id="4fdf" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">天真的实现</h2><p id="b84d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">第一个简单的实现是将记录器传递给所有的<code class="fe lv lw lx ly b">ViewControllers</code>并在每次按钮被按下时调用<code class="fe lv lw lx ly b">log</code>函数。</p><p id="6d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在<code class="fe lv lw lx ly b">WelcomeViewController</code>中应用这个策略，代码看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="70fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们声明一个<code class="fe lv lw lx ly b">logger</code>变量，并把它注入到初始化器中。我们决定设置默认值<code class="fe lv lw lx ly b">ConsoleLogger</code>，不更新所有调用<code class="fe lv lw lx ly b">WelcomeViewControllers</code> <code class="fe lv lw lx ly b">init</code>的地方。</p><p id="d565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还没有使用它:我们需要将它注入到<code class="fe lv lw lx ly b">WelcomeView</code>中，因为它是捕捉用户与按钮交互的视图。<code class="fe lv lw lx ly b">WelcomeView</code>现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">init</code>中注入记录器，并将其存储在一个属性中。然后，我们在<code class="fe lv lw lx ly b">Button</code>的动作中调用记录器。</p><p id="4d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图的<code class="fe lv lw lx ly b">init</code>的变化要求我们更新<code class="fe lv lw lx ly b">WelcomeViewController</code>的<code class="fe lv lw lx ly b">loadView()</code>方法。我们更新它，将ViewController的记录器传递给<code class="fe lv lw lx ly b">WelcomeView</code>。</p><p id="3be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以运行应用程序并点击<code class="fe lv lw lx ly b">WelcomeView</code>的<code class="fe lv lw lx ly b">Next</code>按钮。我们应该会在控制台中看到一个新的记录行。</p><p id="69c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在所有其他ViewControllers中重复这些步骤，以完成日志实现。</p><h2 id="2ed8" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">这种方法的缺点</h2><p id="0473" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">天真的方法很有效，但也有很多缺点:</p><ol class=""><li id="19a1" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">View</code>正在执行一些逻辑，但是视图应该只呈现一些数据并拦截用户输入。</li><li id="059d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">ViewController</code>充当<a class="ae ky" href="https://refactoring.guru/smells/middle-man" rel="noopener ugc nofollow" target="_blank">中间人</a>，只是传递<code class="fe lv lw lx ly b">LogService</code>依赖，而不做任何具体的事情。</li><li id="144d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们引入了一些代码重复。所有的<code class="fe lv lw lx ly b">Views</code>和<code class="fe lv lw lx ly b">ViewController</code>都以非常相似的方式改变了，修改了它们自己的<code class="fe lv lw lx ly b">init</code>和<code class="fe lv lw lx ly b">loadView</code>方法来传递依赖关系。</li><li id="3e6b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">如果我们改变<code class="fe lv lw lx ly b">log</code>签名或者删除日志记录，我们必须相应地改变所有的视图和所有的视图控制器。</li><li id="c1db" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">对于我们想要引入的相互交叉的关注点，我们必须修改整个代码库，以保持一致性。</li></ol><p id="9f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，很明显这个解决方案没有很好地扩展。我们可以在非常小的应用程序中或者在有限的时间跨度内保留它，并承诺尽快重构它。但是，在一个大的应用程序中，我们需要尽快偿还这个技术债务。</p><p id="18a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个更具可扩展性的解决方案。</p><h2 id="8c4b" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">可扩展实现</h2><p id="24bc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">可伸缩的实现使我们所有的视图和视图控制器保持不变，并且与它们的代码分离。</p><p id="2c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">策略是利用<code class="fe lv lw lx ly b">Composer</code>在我们需要的地方注入<code class="fe lv lw lx ly b">log</code>调用。让我们看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="42a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的作曲者接收一个<code class="fe lv lw lx ly b">LogService</code>和一个<code class="fe lv lw lx ly b">DateProvider</code>作为输入参数。<code class="fe lv lw lx ly b">DateProvider</code>是创造<code class="fe lv lw lx ly b">Date</code>价值的工厂。</p><p id="6164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码的其余部分与前面的几乎相同。在每次推送之前，我们调用<code class="fe lv lw lx ly b">logger</code>在控制台中打印一个事件。这个模式是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">Decorator</a></code>的匿名实现:原始闭包的代码是<code class="fe lv lw lx ly b">decoratee</code>而<code class="fe lv lw lx ly b">log</code>是装饰器的代码。</p><p id="1558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以运行应用程序并完成入职培训，以查看以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/dfc05fc595c03fa18f95259bb5c2d101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAiJwAficqvZYUE7f14tog.png"/></div></div></figure><p id="e50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组合级别注入横切关注点有几个好处:</p><ol class=""><li id="1fe1" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">所有的<code class="fe lv lw lx ly b">ViewControllers</code>和<code class="fe lv lw lx ly b">Views</code>不变。</li><li id="6238" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">横切关注点包含在<code class="fe lv lw lx ly b">Composer</code>中。如果<code class="fe lv lw lx ly b">log</code>签名发生变化，我们可以很容易地使用不同的记录器，只更新<code class="fe lv lw lx ly b">onboardingVC</code>方法。</li><li id="eeb0" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">如果我们需要引入其他横切关注点，我们可以用类似的方式更新<code class="fe lv lw lx ly b">onboardingVC</code>方法。</li></ol><h1 id="ae18" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">跟踪其他事件</h1><p id="080b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">到目前为止，我们已经看到了如何跟踪与从一个屏幕到另一个屏幕的导航相关的事件。从一个模块到另一个模块的导航是在模块边界的操作。拦截边界操作更容易:它们被明确定义为模块的公共API的一部分</p><p id="4964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，这些应该是我们唯一想要截取的函数。对于消费者来说，模块中发生的事情应该是一个黑盒。</p><p id="4cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可能需要检查我们实现的一些内部细节。我们可能需要它来检查错误，因为新的需求出现了，或者收集关于用户如何使用我们的应用程序的细粒度知识。</p><p id="9217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想再举两个例子:</p><ol class=""><li id="151b" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在<code class="fe lv lw lx ly b">AgeView</code>中跟踪上下按钮上的点击。</li><li id="8ad3" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">跟踪<code class="fe lv lw lx ly b">WelcomeViewController</code>的UIKit生命周期事件。</li></ol><h2 id="e408" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">跟踪年龄视图</h2><p id="9ea0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了跟踪在<code class="fe lv lw lx ly b">upArrow</code>或<code class="fe lv lw lx ly b">downArrow</code>上的点击，我们需要将<code class="fe lv lw lx ly b">LogService</code>注入视图。<code class="fe lv lw lx ly b">AgeView</code>或<code class="fe lv lw lx ly b">AgeViewController</code>没有暴露任何我们可以截取来添加日志的内容。</p><p id="5468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们知道注入日志程序有几个缺点，并且违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。</p><p id="865f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是将行为推到模块的边界。</p><p id="02af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个<code class="fe lv lw lx ly b">increase</code>和一个<code class="fe lv lw lx ly b">decrease</code>函数将行为封装在一个<code class="fe lv lw lx ly b">AgeManager</code>中。然后，我们可以将管理器作为一个依赖项传递，这样我们就可以用日志来修饰它。</p><p id="3a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建<code class="fe lv lw lx ly b">AgeManager</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="36b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管理器封装了曾经在<code class="fe lv lw lx ly b">AgeView</code>中定义的逻辑。该对象将视图从如何增加和减少年龄的业务逻辑中分离出来。</p><p id="1996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管理器有一个未在<code class="fe lv lw lx ly b">init</code>中初始化的<code class="fe lv lw lx ly b">ageDidChange</code>闭包。管理器由<code class="fe lv lw lx ly b">Composer</code>创建并注入到<code class="fe lv lw lx ly b">AgeViewController</code>中。然而，是<code class="fe lv lw lx ly b">ViewController</code>必须执行管理器和视图之间的绑定。我们使用属性注入来设置闭包并执行绑定。</p><blockquote class="oa ob oc"><p id="8332" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">注意: Combine是实现绑定机制的闭包的有效替代方案。</p></blockquote><p id="24cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们更新<code class="fe lv lw lx ly b">View</code>和<code class="fe lv lw lx ly b">ViewController</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AgeView</code>的主要变化有:</p><ol class=""><li id="4aaa" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">我们宣布关闭<code class="fe lv lw lx ly b">userDidTapUpArrow</code>和<code class="fe lv lw lx ly b">userDidTapDownArrow</code>。</li><li id="bb1e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们删除了属性<code class="fe lv lw lx ly b">age</code>的初始值。</li><li id="4855" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们更新了<code class="fe lv lw lx ly b">init</code>,让它接受<code class="fe lv lw lx ly b">age</code>和两个额外闭包的初始值</li><li id="db28" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在<code class="fe lv lw lx ly b">setup</code>方法中，我们用管理器的<code class="fe lv lw lx ly b">increase</code>和<code class="fe lv lw lx ly b">decrease</code>方法的调用替换了向上和向下按钮中的逻辑。</li></ol><p id="7d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变<code class="fe lv lw lx ly b">init</code>迫使我们更新<code class="fe lv lw lx ly b">ViewController</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="904a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们声明了一个新的<code class="fe lv lw lx ly b">ageManager</code>属性，我们在init中初始化它。<code class="fe lv lw lx ly b">loadView</code>方法现在将初始年龄值以及<code class="fe lv lw lx ly b">increase</code>和<code class="fe lv lw lx ly b">decrease</code>函数传递给<code class="fe lv lw lx ly b">View</code>。</p><p id="a3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在<code class="fe lv lw lx ly b">viewDidLoad</code>中，<code class="fe lv lw lx ly b">ViewController</code>为<code class="fe lv lw lx ly b">age</code>属性设置绑定。</p><p id="f236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步，我们在<code class="fe lv lw lx ly b">Composer</code>中组合所有内容。编译器建议<code class="fe lv lw lx ly b">AgeViewController</code>需要一个<code class="fe lv lw lx ly b">AgeManager</code>作为依赖项。我们可以直接通过<code class="fe lv lw lx ly b">LiveAgeManager</code>来实现原来的行为。但是，我们想引入日志调用。为了实现这一点，我们创建了一个<code class="fe lv lw lx ly b">LoggingAgeManagerDecorator</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="06fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用装饰模式的步骤是:</p><ol class=""><li id="407c" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">创建一个<code class="fe lv lw lx ly b">Decorator</code>类，实现我们需要修饰的服务的相同协议。</li><li id="62e7" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">添加装饰者需要的所有依赖项，再加上要装饰的服务的同一类型的一个<code class="fe lv lw lx ly b">decoratee</code>属性。</li><li id="0b11" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">通过依赖<code class="fe lv lw lx ly b">decoratee</code>的实现来实现我们不需要修饰的协议。</li><li id="9776" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在我们想要修饰的方法调用之前和/或之后应用修饰。</li></ol><p id="c5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们只想装饰一下<code class="fe lv lw lx ly b">increase</code>和<code class="fe lv lw lx ly b">decrease</code>方法。为此，我们:</p><ol class=""><li id="7f15" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在调用之前检索<code class="fe lv lw lx ly b">age</code>值。</li><li id="9417" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">调用<code class="fe lv lw lx ly b">decoratee</code>的方法。</li><li id="fbe9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在控制台中记录该行。</li></ol><p id="7ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以将所有内容组合在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只添加了第12行，在这里我们用decorator类创建了<code class="fe lv lw lx ly b">ageManager</code>，并将它传递给了<code class="fe lv lw lx ly b">AgeViewController</code>。</p><p id="53ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果现在我们运行应用程序并使用箭头，我们可以观察到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7a1661b4802ddc9028a4a176842ab057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uS4TPp5f-QT4Hr7uuRa-g.png"/></div></div></figure><p id="4080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AgeViewController</code>仍然不知道日志记录:我们必须改变一些细节来截取逻辑，但是类的功能没有改变。</p><h2 id="ae16" class="nl ma it bd mb nm nn dn mf no np dp mj li nq nr ml lm ns nt mn lq nu nv mp nw bi translated">跟踪ViewController生命周期</h2><p id="aa61" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，让我们跟踪UIKit生命周期事件。具体来说，就是视图加载和出现的时间。</p><p id="9e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拦截这些行为更加棘手。我们可以使用类似于<a class="ae ky" href="https://pspdfkit.com/blog/2019/swizzling-in-swift/" rel="noopener ugc nofollow" target="_blank">方法swizzing</a>的技术来拦截所有<code class="fe lv lw lx ly b">UIViewControllers</code>中的所有这些方法调用。</p><p id="42ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们很少想要记录所有ViewControllers的所有生命周期事件。更有可能的是，我们希望只记录某些特定视图控制器的事件。</p><p id="ff85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了截取某些特定事件的生命周期事件，我们可以创建一个子类，并使用它来代替原来的视图控制器。子类的代码如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个扩展了T2的T1。我们升级<code class="fe lv lw lx ly b">init</code>来接受一个<code class="fe lv lw lx ly b">LogService</code>和一个<code class="fe lv lw lx ly b">DateProvider</code>。然后，我们传递我们必须传递给<code class="fe lv lw lx ly b">super.init</code>的<code class="fe lv lw lx ly b">nextPressed</code>闭包。</p><p id="6c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们<code class="fe lv lw lx ly b">override</code>我们想要装饰的方法:在本例中，我们装饰了<code class="fe lv lw lx ly b">viewDidLoad</code>和<code class="fe lv lw lx ly b">viewDidAppear</code>方法。在这两种情况下，我们都在<code class="fe lv lw lx ly b">super.viewDidXXX</code>调用之前和之后添加了一个<code class="fe lv lw lx ly b">log</code>调用。</p><p id="241d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在composer中使用<code class="fe lv lw lx ly b">LoggingWelcomeViewController</code>来代替<code class="fe lv lw lx ly b">WelcomeViewController</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段中，我们声明了一个类型为<code class="fe lv lw lx ly b">WelcomeViewController</code>(父类型)的变量<code class="fe lv lw lx ly b">vc</code>，但是我们用上面代码片段中定义的子类初始化了它。</p><p id="b078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了<a class="ae ky" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原理</a>，系统会像以前一样工作，忽略了<code class="fe lv lw lx ly b">WelcomeViewController</code>实际上是另一种类型的事实。</p><p id="9ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台中的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/48abdd4f4035e1a98c079b7213e23d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALpsJHl1cQmKjjTFbRm7pQ.png"/></div></div></figure><h1 id="516e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="0af6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们探讨了横切关注点的概念:它们是什么，为什么它们很重要。我们试图在一个简单的应用程序中实现它们。</p><p id="456d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从简单的实现中，我们理解了我们必须处理的可伸缩性问题。有了这些知识，我们基于根级别的组合实现了一个更具可伸缩性的解决方案。</p><p id="4522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们探索了另外两种实现横切关注点的技术。当我们完全控制代码时，我们可以将有趣的逻辑委托给我们注入到应用程序中的专用管理器。当我们注入manage时，我们可以注入它的修饰版本。</p><p id="036e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们不控制整个代码库时，我们可以子类化我们想要观察的类，并在被覆盖的方法中注入关注点。</p><p id="acc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子的最终代码可以在<a class="ae ky" href="https://github.com/cipolleschi/iMeditate" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到。</p></div></div>    
</body>
</html>