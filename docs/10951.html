<html>
<head>
<title>How I Reindex Elasticsearch Without Downtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不停机的情况下重新索引弹性搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-reindex-elasticsearch-without-downtime-6e8a6a512070?source=collection_archive---------2-----------------------#2022-02-07">https://betterprogramming.pub/how-i-reindex-elasticsearch-without-downtime-6e8a6a512070?source=collection_archive---------2-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/27f16dbd714f2d5ab33509e8cc236a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD6zBUpnf2W221eut7Go4Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·温克勒在<a class="ae kf" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9d29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Elasticsearch (ES)是一个强大、灵活、可扩展的搜索引擎。它将数据作为键值对存储在文档中。它将许多文件组合成一个索引。实际上，ES使用了一种倒排索引数据结构，它允许我们通过文档包含的字段来查询文档。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/49e1190f9feb6fcb3c3fee26408104d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aSpnVTtBvPkoINWN.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">你知道，为了搜索！</p></figure><p id="19ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，您不应该使用ES作为您的主要数据存储。数据仍然应该存储在像MySQL这样的持久性数据库中。您必须编写代码来在数据存储和ES集群之间同步数据。</p><p id="7e44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持数据的一致性是一项挑战。随着业务的发展，您可能需要更新索引中现有字段的映射。或者，由于数据同步过程中的意外错误，索引中可能有许多脏数据。</p><p id="1e40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两种情况下，您都需要从头开始重建es索引。这就是所谓的重新索引。</p><p id="9dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将与您分享我如何在不停机的情况下执行ES重新索引。我们将讨论设计思想和一些重要的ES概念。我们开始吧！🏃</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="c4b6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">系统概况</h1><p id="a16d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在深入研究主要内容之前，我们应该对典型的ES系统有一个共识。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/b9bd8a272b5515d9a544fc5e4bbecc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2A9EpvHjgaD0Vvgs5xfRw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">带专家系统的系统架构</p></figure><p id="6560" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的系统中，我们的应用程序数据存储在主存储中。当有数据更改时，会触发一个管道来更新es索引。</p><p id="3f29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法可以实现管道。对于实时、异步的更新，你可以使用带有<a class="ae kf" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>的消息总线和一个消费者应用程序。在这篇文章中，细节并不重要。</p><p id="a6a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">reindex应用程序应该是什么样子？它在我们系统中的什么位置运行？</p><p id="b2da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，reindex应用程序执行批处理。它从数据存储中批量读取数据，并将<a class="ae kf" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" rel="noopener ugc nofollow" target="_blank">批量索引</a>到ES中。通过为每个请求处理更多的数据，我们可以大大提高重建索引的速度。</p><p id="b7f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，没有必要让reindex应用程序永远作为一个活动系统运行。我们只会在需要的时候执行它。</p><p id="ce49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，很明显，reindex应用程序是一个作业脚本。当我们需要做一些工作时，可以手动运行脚本。此外，我们可以公开命令行标志来配置脚本行为。</p><p id="e3d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们的reindex脚本的一个有用标志是布尔值<code class="fe mu mv mw mx b">dryRun</code>。如果<code class="fe mu mv mw mx b">true</code>，脚本将只批处理你的数据的相当大的一部分。这是为了测试重新索引对您的实时系统的影响。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/115d201a16f3d02ad8cfc0e98a39588f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQjHPQcrnKSgmWuYRSnzdg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">使用脚本重新编制索引</p></figure><p id="3030" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该脚本还应该将数据索引到新的ES索引中。当我们执行大规模数据迁移时，从逻辑上将新数据与旧数据分开总是一个好的做法。</p><p id="9aee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以减轻系统在同一位置与不同版本的数据交互时可能出现的冲突。此外，如果新数据有问题，我们可以很容易地回滚我们的查询API以使用旧的ES索引。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a8be" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">从旧索引过渡到新索引</h1><p id="3142" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们的设计有一个很大的缺点。转换我们的查询API以使用新的ES索引是很麻烦的。</p><p id="ce65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，如果新索引和旧索引共享同一个集群，它们就不能同名。</p><p id="d9bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，索引名可以硬编码在API代码中，也可以作为环境变量传递。无论哪种方式，我们都必须重启或重新部署我们的查询API来使用新的ES索引。</p><p id="ce70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何在不增加额外工作或停机的情况下将查询API指向新索引呢？这就是化名为的<a class="ae kf" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/aliases.html" rel="noopener ugc nofollow" target="_blank">可以帮助我们的地方！</a></p><p id="75d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ES别名是一个或多个索引的包装器。我们可以自由地从别名中添加或删除索引。对于大多数ES APIs来说，与alias交互相当于使用它的底层索引。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ffea0ba334c68286e472793750a989f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5qL3orOQV8KXyk4Bq9IUg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">别名是索引的次要名称</p></figure><p id="1e8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决我们的问题，查询API应该与别名而不是索引进行交互。重新建立索引后，我们可以将新索引添加到别名中，并删除旧索引。API将自动从新索引中读取数据。</p><p id="60a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要添加和删除索引，我们可以使用<code class="fe mu mv mw mx b"><a class="ae kf" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html" rel="noopener ugc nofollow" target="_blank">_aliases</a></code> API。</p><pre class="lf lg lh li gt na mx nb nc aw nd bi"><span id="bc6d" class="ne lr it mx b gy nf ng l nh ni">POST _aliases<br/>{<br/>  "actions": [<br/>    {<br/>      "remove": {<br/>        "index": "old_index",<br/>        "alias": "my_alias"<br/>      }<br/>    },<br/>    {<br/>      "add": {<br/>        "index": "new_index",<br/>        "alias": "my_alias"<br/>      }<br/>    }<br/>  ]<br/>}</span></pre><p id="f294" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的操作是原子性的，这意味着别名不会同时指向两个索引。为了减少手工操作，脚本可以在完成后自动执行切换。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/97d61ceea2b91292f68b4b89c19757b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYEU3GEIIZ6A4PARfD72jw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">带别名的重新索引</p></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="e75e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">保持新索引最新</h1><p id="6f3c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们的系统很好，但是还有一个问题。新的ES索引遗漏了来自管道的实时数据更新。</p><p id="0add" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是有问题的，因为我们的脚本从存储中顺序读取数据。对已被读取和索引的数据的任何更新都将被忽略。当这种情况发生时，陈旧的数据将堆积在新的ES索引中。</p><p id="4b68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们的系统需要执行“双写”。顾名思义，双写在两个不同的位置添加或更新数据。在我们的例子中，这就是我们的新旧ES指数。</p><p id="a589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能认为我们可以将新索引添加到旧索引所在的别名中。索引到别名会更新它的所有索引，对吗？</p><p id="b9c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，<a class="ae kf" href="https://github.com/elastic/elasticsearch/issues/68003" rel="noopener ugc nofollow" target="_blank">在写入</a>时，ES别名不支持多次写入不同的索引。在别名中，只能写入一个索引，而其他索引都是只读的。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/cc542f122c2dd4ceb18c160801860568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKzqoB5gLE8Hdlf2EHLmKA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">index_002是只读的</p></figure><p id="1811" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这种限制，我们别无选择，只能配置我们的管道，也将数据写入新的ES索引。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/f16c29b21d45822c7154f85db8d41b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlO31gKFWnH5hMNWkZONSg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">管道双重写入</p></figure><p id="5d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是……管道如何动态地知道何时应该执行双重写入？请记住，重新索引可以在任何时候发生，管道需要迎合这种灵活性。</p><p id="711c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种简单的方法是管道在每次接收到数据变化时检查是否存在新的ES索引。如果是，管道将数据写入两个索引。</p><pre class="lf lg lh li gt na mx nb nc aw nd bi"><span id="b245" class="ne lr it mx b gy nf ng l nh ni">// Date comes in...</span><span id="44a1" class="ne lr it mx b gy nm ng l nh ni">write_to_old()</span><span id="f2d3" class="ne lr it mx b gy nm ng l nh ni">// Sends request to ES<br/>exist = check_new_index_exist()</span><span id="1fae" class="ne lr it mx b gy nm ng l nh ni">if exist {<br/>    write_to_new()<br/>}</span></pre><p id="8d3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以想象，这种方法效率很低。如果管道经历高负载，它将向es发出大量额外请求，并给集群增加压力。</p><p id="1a76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的方法是让管道定期检查新索引是否存在。管道缓存结果，以便在一段时间内可以重用。根据您的编程语言，这种定期检查可以在后台线程中进行。</p><pre class="lf lg lh li gt na mx nb nc aw nd bi"><span id="91a3" class="ne lr it mx b gy nf ng l nh ni">// Pipeline init</span><span id="fb54" class="ne lr it mx b gy nm ng l nh ni">exist = false</span><span id="a002" class="ne lr it mx b gy nm ng l nh ni">start_background_thread {<br/>    for every 1 min {<br/>        exist = check_new_index_exist()<br/>    }<br/>}</span><span id="e7ec" class="ne lr it mx b gy nm ng l nh ni">// Data comes in...</span><span id="de29" class="ne lr it mx b gy nm ng l nh ni">writes_to_old()</span><span id="049f" class="ne lr it mx b gy nm ng l nh ni">if exist {<br/>    writes_to_new()<br/>}</span></pre></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="80ee" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">其他实施细节</h1><p id="19e0" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在我结束这篇文章之前，关于我们的设计，我想强调两点。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/578565a4ccff385e61f6fc504ad8595b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IkzWGM7biZpffFD3"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kf" href="https://unsplash.com/s/photos/write-notes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="2f3f" class="ne lr it bd ls no np dn lw nq nr dp ma kr ns nt me kv nu nv mi kz nw nx mm ny bi translated">索引命名</h2><p id="21ec" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">请记住，在es集群中不能有索引名称冲突。</p><p id="bde5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，您可能希望多次运行reindex脚本。但是，该脚本不能使用与以前运行相同的名称创建新索引。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/50961efc58be3fd9a306763bc3f1dcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3ysHwSmkVTFgPdGAZHcsg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">索引命名冲突</p></figure><p id="80bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，您可以简单地通过在每次运行时更新您的脚本以使用不同的名称来克服这个问题。但是，我认为我们可以做得更好！</p><p id="900b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的解决方案是在索引名后面添加一个Unix时间戳作为后缀。这保证了脚本的每次运行都会创建一个新的、唯一的索引。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/63ec61ffe41125a02e1c88255450c7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7wEomkrmGcavglNX5fBCQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">添加Unix时间戳作为后缀</p></figure><p id="b3d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果新索引有一个动态名称，那么管道如何知道应该将哪个索引重复写入？</p><p id="454f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们可以再次使用ES别名的地方！reindex脚本应该将新索引包装在一个临时别名<strong class="ki iu">中。然后，管道会定期检查别名是否存在，并在需要时写入别名。</strong></p><p id="364c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当脚本完成时，它需要删除临时别名，以便管道可以停止重复写入。</p><h2 id="5672" class="ne lr it bd ls no np dn lw nq nr dp ma kr ns nt me kv nu nv mi kz nw nx mm ny bi translated"><strong class="ak">自动创建索引</strong></h2><p id="8b62" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们的管道对双写的定期检查有一个小漏洞。</p><p id="3b71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">reindex脚本可以在<strong class="ki iu">定期检查的间隔</strong>中结束并移除别名。管道不会知道这一点，因为它依赖于缓存的信息来决定是否重复写入。</p><p id="817e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果发生这种情况，管道将写入临时别名，认为它仍然存在。如果没有，默认情况下，ES会自动为您创建一个新的别名索引！</p><p id="c5be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止这种情况发生，我们需要禁用索引的自动创建。</p><pre class="lf lg lh li gt na mx nb nc aw nd bi"><span id="be2b" class="ne lr it mx b gy nf ng l nh ni">PUT /_cluster/settings<br/>{<br/>    "persistent" : {<br/>        "action.auto_create_index": false<br/>    }<br/>}</span></pre><p id="d665" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些人可能不喜欢这个设置，因为它放弃了es提供的灵活性。我喜欢这种方式，因为它可以防止数据意外索引到错误的位置。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7ff7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">最后的想法</strong></h1><p id="4dd5" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">本文到此为止！这是我作为初级软件工程师完成的最具挑战性的技术项目之一。我学到了很多，我希望你能从我的旅程中学到一些东西。</p><p id="ce5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">欢迎在评论中挑战我的设计！总有改进的余地，从你的经历中学习将是我的荣幸。</p><p id="8080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，我们会再见的！</p></div></div>    
</body>
</html>