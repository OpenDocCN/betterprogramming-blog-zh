<html>
<head>
<title>Understand Threads and Threading in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解线程和Java中的线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-threads-and-threading-in-java-8f706fc44d13?source=collection_archive---------9-----------------------#2020-03-20">https://betterprogramming.pub/understand-threads-and-threading-in-java-8f706fc44d13?source=collection_archive---------9-----------------------#2020-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4578" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Java和JVM进行并发编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/485709b728e1799032e1f829462d0643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*avFmOjZfhjhmNYoU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@drmakete?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> drmakete lab </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="46a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编写复杂的应用程序时，我们经常会发现自己需要同时执行多个动作。幸运的是，Java和JVM被设计成支持并发编程，因为所有的执行都发生在线程的上下文中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6aee" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">JVM对多线程的支持</h1><p id="20f8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">由于Java是在90年代创建的，那时计算机已经有多个处理单元，它们的创造者决定包括对多线程的本地支持。</p><p id="6b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java运行在Java虚拟机中。当程序启动时，JVM创建执行<code class="fe mw mx my mz b">main()</code> <em class="na"> </em>方法的主线程。从这一点开始，程序可以按照层次结构创建任意多的线程。在Java中，线程可以处于以下任何状态:</p><ul class=""><li id="11f2" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">New: <strong class="ky ir"> </strong>当一个新线程被实例化时，就处于这种状态。处于这种状态时，线程还没有开始执行。</li><li id="c8ad" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">Runnable: <strong class="ky ir"> </strong>处于这种状态的线程可以是正在运行的，也可以是随时准备运行的。</li><li id="c72c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">阻塞/等待:<strong class="ky ir"> </strong>在这种状态下，线程是不活动的，等待一个资源。</li><li id="e6fc" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">Suspended: <strong class="ky ir"> </strong>线程在调用带有<code class="fe mw mx my mz b">timeout</code>参数的方法时处于这种状态，会暂时挂起。之后，它可以从停止的地方继续执行。</li><li id="304c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">终止:<strong class="ky ir"> </strong>当一个线程执行完它的<code class="fe mw mx my mz b">run()</code> <em class="na"> </em>方法时，它就处于终止状态。垃圾收集器将释放该线程使用的资源。</li></ul><p id="7d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，JVM为每个线程分配自己的方法调用堆栈，这允许这些线程跟踪局部变量、JVM传递给方法的参数以及方法的返回值。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="54ab" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">线程类</h1><p id="85a8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Java中创建线程的第一种方法是创建一个扩展<code class="fe mw mx my mz b">Thread</code>类的类，<strong class="ky ir"> </strong>用线程必须运行的代码覆盖<code class="fe mw mx my mz b">run</code>方法，然后实例化这个类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8751" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们创建了这个类，我们就可以实例化它并启动线程:</p><pre class="kg kh ki kj gt nr mz ns nt aw nu bi"><span id="cc4d" class="nv ma iq mz b gy nw nx l ny nz"><strong class="mz ir">MyThread</strong> thread = new <strong class="mz ir">MyThread</strong>();</span><span id="0719" class="nv ma iq mz b gy oa nx l ny nz">thread.<strong class="mz ir">start</strong>();</span></pre><p id="f273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们分配一个新的<code class="fe mw mx my mz b">MyThread</code>对象，然后我们调用<code class="fe mw mx my mz b">start</code>方法，以便JVM调用该线程的<code class="fe mw mx my mz b">run</code>方法。注意，严格禁止多次启动一个线程(线程一旦完成执行，就不能重新启动)。如果我们想再次运行那个线程，我们应该创建一个线程对象的新实例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ced3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">可运行接口</strong></h1><p id="1814" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">runnable接口应该由任何类来实现，这些类的实例应该由线程来执行。该类必须定义一个名为<code class="fe mw mx my mz b">run</code>的无参数方法。此外，runnable接口提供了激活一个类而不子类化<code class="fe mw mx my mz b">Thread</code>的方法。</p><p id="ae73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，当我们只想覆盖线程的<code class="fe mw mx my mz b">run</code>方法而不使用任何其他的<code class="fe mw mx my mz b">Thread</code>方法时，就应该使用这个接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4c2a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何多次运行一个线程</h1><p id="b796" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果我们想多次运行一个线程，在Java中我们该如何做呢？人们可能倾向于尝试以下方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5987" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我之前说过，这是不可能的。如果我们试图运行这段代码，将会抛出一个<code class="fe mw mx my mz b">IllegalThreadStateException</code>。</p><p id="d681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了多次运行它，应该实例化一个新线程。一种可能的方法是使用线程数组。在本例中，我将运行十个线程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d7ed" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">临界断面</h1><p id="e04d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Java中，<code class="fe mw mx my mz b">Object</code>类提供了一个锁，允许程序员管理对临界区的独占访问。锁允许两种操作:<code class="fe mw mx my mz b">open</code>和<code class="fe mw mx my mz b">close</code>。当一个锁被关闭时，任何其他关闭它的尝试都将被挂起，直到它被关闭它的线程打开。管理这些操作的Java方法是使用<code class="fe mw mx my mz b">synchronized</code>结构。使用该结构的第一种方法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">synchronized</code>构造的另一种方式是定义一个<code class="fe mw mx my mz b">synchronized</code>方法:</p><pre class="kg kh ki kj gt nr mz ns nt aw nu bi"><span id="8599" class="nv ma iq mz b gy nw nx l ny nz">public class <strong class="mz ir">MyClass</strong>{ </span><span id="28dd" class="nv ma iq mz b gy oa nx l ny nz">    public <strong class="mz ir">synchronized</strong> int <strong class="mz ir">methodOne</strong>(args){ </span><span id="cfa2" class="nv ma iq mz b gy oa nx l ny nz">        …… </span><span id="8acd" class="nv ma iq mz b gy oa nx l ny nz">    }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d749" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">同步线程</h1><p id="b653" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">Thread</code>类实现了几个方法，允许我们控制线程何时以及如何等待其他线程。</p><p id="0dc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法是<code class="fe mw mx my mz b">join()</code>。当一个线程希望等待另一个线程终止时，它会使用该线程的引用来调用此方法。当这个方法正在等待的线程被<code class="fe mw mx my mz b">interrupted()</code>方法中断时，这个方法抛出一个<code class="fe mw mx my mz b">InterruptedException</code>。</p><p id="37a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，主线程将等待<code class="fe mw mx my mz b">thread1</code>线程终止:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个重要的方法是<code class="fe mw mx my mz b">wait()</code>。这个方法应该在一个<code class="fe mw mx my mz b">synchronized</code>方法中被调用。如果执行<code class="fe mw mx my mz b">wait</code>方法的线程被中断，它会抛出一个<code class="fe mw mx my mz b">InterruptedException</code>。JVM将执行<code class="fe mw mx my mz b">wait</code>方法的线程添加到与进行调用的对象相关联的等待列表中。然后，与该对象相关联的锁被打开，当从调用返回时，它将被关闭。</p><p id="02c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将介绍的最后一个方法是<code class="fe mw mx my mz b">notify()</code>。当被调用时，它将激活一个正在等待列表中等待的线程。将要启动的线程还没有确定，但是必须等到可以再次关闭锁的时候。类似的方法是<code class="fe mw mx my mz b">notifyAll()</code>，激活等待列表中的所有线程。</p></div></div>    
</body>
</html>