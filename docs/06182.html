<html>
<head>
<title>Perfecting Drag and Drop in Pure, Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在纯普通JavaScript中完善拖放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/perfecting-drag-and-drop-in-pure-vanilla-javascript-a761184b797a?source=collection_archive---------4-----------------------#2020-09-08">https://betterprogramming.pub/perfecting-drag-and-drop-in-pure-vanilla-javascript-a761184b797a?source=collection_archive---------4-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c98" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无需库或框架的高效拖放功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8678c69c0768a4f07a9e1f19a4001568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*60BUHp9YaA-KjnzE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@alanrobertjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兰·琼斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拖放功能是现代网络UX的基础。这是API的一个方面，也是HTML标准的一部分。许多UI库都提供了开箱即用的功能。</p><p id="0f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有时我们不得不处理标准API或库都无法提供帮助的情况，我们必须自己实现功能。在本文中，我们将做到这一点—我们将实现:</p><ul class=""><li id="053e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">交叉输入(支持混合鼠标和触摸事件)</li><li id="263b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">跨浏览器友好</li><li id="c7fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">高性能(60帧/秒)</li><li id="f870" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">高效(没有浪费JavaScript处理)</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="46f4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.先决条件</h1><p id="12fa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">就本文而言，我们将在一个简单的HTML页面中的容器(div)元素周围拖动几个黑色方框(div ):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始HTML</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始CSS</p></figure><p id="31e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么特别的，但是请注意，我们应用了<code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action" rel="noopener ugc nofollow" target="_blank">touch-action: none;</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action" rel="noopener ugc nofollow" target="_blank"> CSS规则</a>来防止容器内事件的任何浏览器级别的操作(比如滚动或缩放)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cfa7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.添加输入侦听器</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/034f9498b5160c7a9a33d5889ff05ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YagEIckD83-cLm3Qs9O8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指针事件提供了支持两种输入类型的混合器</p></figure><p id="5a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们想要支持交叉输入，我们可以编写一些检测机制来检测用户是使用触摸输入还是鼠标输入，但是在现代世界中，用户可能会同时使用两种输入类型<strong class="lb iu"> </strong>(触摸屏笔记本电脑，有人吗？).</p><p id="be76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们应该致力于支持这两者。一种方法是附加两种类型的监听器，但是更好的方法是利用指针事件API ()——两种输入类型的混合体，现在得到了所有主流浏览器的支持。</p><p id="ed4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的拖放用户体验可以这样映射:</p><ul class=""><li id="d8ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">用户指向一个框，按下鼠标键/屏幕(<code class="fe np nq nr ns b">pointerdown</code>)</li><li id="1124" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用户通过在屏幕上移动鼠标/手指来拖动方框(<code class="fe np nq nr ns b">pointermove</code>)</li><li id="9da4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用户通过从屏幕上释放鼠标/手指来放下盒子(<code class="fe np nq nr ns b">pointerup</code> / <code class="fe np nq nr ns b">pointercancel</code> *)</li></ul><p id="d593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*触摸设备具有一个额外的<code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/touchcancel_event" rel="noopener ugc nofollow" target="_blank">touchcancel</a></code>事件，用于触摸事件被中断的情况(例如，当屏幕上有太多触摸点时)。</p><p id="df1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们编写一些JavaScript并添加我们的事件侦听器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">监听框元素的输入事件</p></figure><h2 id="9e5a" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">几个音符</h2><ul class=""><li id="872c" class="lv lw it lb b lc ni lf nj li og lm oh lq oi lu ma mb mc md bi translated">我们只是将<code class="fe np nq nr ns b">pointerdown</code>事件附加到容器上，并动态地添加/移除其他侦听器，以防止事件污染——我们根据需要使用侦听器，以保持严密。</li><li id="117f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">事件被附加到容器中，正如我们使用<a class="ae ky" href="https://javascript.info/event-delegation" rel="noopener ugc nofollow" target="_blank"> <em class="oj">事件委托</em> </a> <em class="oj">。</em></li><li id="a0e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们还使用了<code class="fe np nq nr ns b">passive</code>标志来确保我们的事件不会干扰我们的滚动事件。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d439" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.让箱子动起来</h1><p id="0ed0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的盒子以<code class="fe np nq nr ns b">absolute</code>定位为特色，并依靠<code class="fe np nq nr ns b">left</code> / <code class="fe np nq nr ns b">top</code>属性定位在容器内部。让我们添加实际移动盒子的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在我们可以移动箱子了</p></figure><p id="a386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这里发生了更多的事情:</p><ul class=""><li id="8b0d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在<code class="fe np nq nr ns b">userPressed</code>事件处理程序中，我们捕获移动起点的坐标以及box元素的<code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank">BoundingClientRect</a></code>；这两者都将有助于根据移动过程中指针经过的距离来计算我们需要应用于盒子的移动量。</li><li id="ddd1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在<code class="fe np nq nr ns b">userMoved</code>处理器中，我们利用<code class="fe np nq nr ns b">startX</code>和<code class="fe np nq nr ns b">startY</code>数据来计算盒子相对于其先前位置应该移动的<code class="fe np nq nr ns b">delta</code>。</li></ul><p id="3989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，现在用户可以通过触摸或鼠标输入来移动盒子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8b29" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.调谐性能</h1><p id="5b02" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以采用一些已知的方法来提高性能。在这个简单的例子中，我们不执行任何繁重的计算；因此，即使这样，性能看起来很好。但是我们可以考虑以下选择:</p><h2 id="0d82" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated"><strong class="ak">‘变形3d’</strong></h2><p id="86dd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这个技巧现在可能已经过时了，因为现代浏览器学会了优化布局变化，但是知道我们可以在<code class="fe np nq nr ns b">pointermove</code>期间应用<code class="fe np nq nr ns b">transform</code>，并且只在<code class="fe np nq nr ns b">pointerup</code>上应用实际的样式变化，而不是直接修改我们的盒子的<code class="fe np nq nr ns b">left</code>和<code class="fe np nq nr ns b">top</code>位置，这仍然是有用的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="eb13" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated"><strong class="ak">' RequestAnimationFrame '</strong></h2><p id="a17f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们还可以通过使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame API</a>在拖动时实现更平滑的动画(大约60 FPS):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用requestAnimationFrame API进行拖动</p></figure><h2 id="11f4" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">这里有一些注释</h2><ul class=""><li id="abce" class="lv lw it lb b lc ni lf nj li og lm oh lq oi lu ma mb mc md bi translated">我们添加了<code class="fe np nq nr ns b">raf</code>变量来帮助我们在<code class="fe np nq nr ns b">requestAnimationFrame</code>定时器的帮助下去抖<code class="fe np nq nr ns b">pointermove</code>事件，因为我们不希望JavaScript执行不会被使用的计算，因为动画帧已经被调度并且还没有完成。</li><li id="4b59" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们确保每秒触发多次的<code class="fe np nq nr ns b">pointermove</code>事件是轻量级的，只包含获取坐标信息和触发样式改变所必需的逻辑。</li><li id="daf7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更新:正如Daniel Faure指出的，在用户释放指针后重置deltaX/deltaY以确保任何新的移动从新的值开始是很重要的。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="64b6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.CSS规则:“将改变”和“包含”</h1><p id="25ad" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">除了上述内容，您还可以探索CSS规则来进一步优化性能。</p><p id="8617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" rel="noopener ugc nofollow" target="_blank"/><code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" rel="noopener ugc nofollow" target="_blank">will-change</a></code><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/will-change" rel="noopener ugc nofollow" target="_blank">CSS规则</a>向您的浏览器指示元素的属性将会改变，并允许浏览器执行额外的优化。但是正如文档所说——小心使用:</p><blockquote class="ok ol om"><p id="9335" class="kz la oj lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><strong class="lb iu">“重要:</strong> <code class="fe np nq nr ns b">will-change</code>意在作为最后手段使用，以便尝试处理现有的性能问题。它不应该用于预测性能问题。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有助于优化性能的其他CSS规则</p></figure><p id="140d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment" rel="noopener ugc nofollow" target="_blank"/><code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment" rel="noopener ugc nofollow" target="_blank">contain</a></code><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment" rel="noopener ugc nofollow" target="_blank">CSS规则</a>并不是所有浏览器都完全支持的，但是它可以帮助表明特定DOM的元素样式或布局变化不会影响另一个页面的元素，因此不会触发潜在的昂贵的重排版。</p><p id="d19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们简单的例子中，它并没有增加任何价值(假设我们的盒子被定位为<code class="fe np nq nr ns b">absolute</code>，但是在更复杂的UI和拖动情况下，它是一个有用的技巧。你可以观看<a class="ae ky" href="https://www.youtube.com/watch?v=iqcO-5_KkJ4&amp;t=983s" rel="noopener ugc nofollow" target="_blank">这个惊人的视频</a>了解更多细节。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="42da" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="ae85" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们讨论了如何在纯JavaScript中实现拖放功能的基础知识，并概述了一些性能优化的技术和方向。需要记住的主要事项:</p><ul class=""><li id="6b37" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">利用混合输入事件确保混合设备被覆盖。</li><li id="de97" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">动态附加/分离<code class="fe np nq nr ns b">move</code> / <code class="fe np nq nr ns b">up</code> / <code class="fe np nq nr ns b">cancel</code>事件。</li><li id="432f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">尽可能多地在<code class="fe np nq nr ns b">down</code>和<code class="fe np nq nr ns b">up</code>处理器的前面或内部提升重物，但保持<code class="fe np nq nr ns b">move</code>处理器轻便。</li><li id="5ddb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">拖动时利用<code class="fe np nq nr ns b">requestAnimationFrame</code>进行去抖动和平滑动画。</li><li id="8d61" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">探索有助于获得额外性能的CSS规则。</li></ul><p id="874c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此全面实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq no l"/></div></figure><p id="3cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读文章，祝您编码愉快！</p></div></div>    
</body>
</html>