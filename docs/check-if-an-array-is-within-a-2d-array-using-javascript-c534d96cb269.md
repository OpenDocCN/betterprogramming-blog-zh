# 使用 JavaScript 检查数组是否在 2D 数组中

> 原文：<https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269>

## 用算法解决引用传递问题

![](img/52379bea3de8da8265abbf144eb9710b.png)

劳拉·奥克尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

在某些时候，您可能遇到过比较数组的问题。由于按引用传递，我们不能简单地检查`[1,2,3]`是否与`[1,2,3]`相同。

当我试图解决一个 Leetcode 问题，目标是从一个给定的数组中得到所有的排列(可能的字符顺序)时，这对我来说是一个问题。我能够随机化我的数组，但是我不确定如何将它们放入另一个数组中一次，这是解决方案所要求的。

在本文中，我们将讨论解决这一困境的方法。通过遍历一个数组并比较相同索引处元素的值，我们可以看到它们是否真正相同。我想出了一个解决办法。它可能会被优化，但它的工作方式对我来说很简单，我会在深入研究时回顾一下我构建它的基本原理。我还将回顾我为减少运行时间而做的一些优化。

# 引用传递的问题是

在 JavaScript 中，引用传递会造成一个独特的问题。即使对象具有完全相同的值，它们也永远不会在传统意义上彼此相等(也就是看是否`a===b / a==b`)。

这是因为对象驻留在不同的内存地址中，这意味着除非一个对象是另一个对象的实例，否则它不会与另一个对象相等，即使它们拥有完全相同的值。

请考虑以下情况:

尽管`arr1`和`arr2`看起来是同一个东西，但它们在内存中的地址是不同的。由于 JavaScript 的设置方式，几乎不可能打印出*数组在内存中的实际位置，但是这里需要注意的是它们位于不同的区域。*

然而，当我们使一个变量引用另一个变量时，那个副本引用内存中的同一个地址，这就是为什么`arr1`与其副本相同。

这并不能真正帮助我们比较内存地址不同的数组，这是通常的情况。那么，如何才能解决这个问题呢？

# 使用迭代顺序比较每个值

我们必须采取更有条理的方法来进行数组比较。我们可以这样做的一个方法是检查给定索引处每个数组的值。我们将不得不在逐次逼近中确定它们的相同性。

假设我们有一个示例数组:

```
let arr1 = [[3,2,1],[2,1,3],[1,2,3]]
```

我们有一个要测试的数组，看看它是否包含在上面的 2D 数组中:

```
let test = [1,2,3]
```

我们如何测试`[1,2,3]`是否在数组中？我们已经知道，我们不能简单地看是否`[1,2,3] === [1,2,3]`，因为它总是假的，因为数组是按引用传递的。这意味着，即使数组中的值相同，它们也永远不会相等，因为它们位于不同的内存地址。

我们这里有一个名为`checker`的数组，用来记录给定索引处数组的值是否相同。每次比较这些值时，都会有一个布尔值传递给它。因此，如果`checker`只包含`true`，这意味着每个索引在两个数组中都有相同的值。

所以对于`arr1`，我们比较`[3,2,1]`和`[1,2,3]`。首先，我们查看是否有`3 === 1`，它没有，所以我们将`false`推送给我们的检查器。现在，checker 中还会出现什么已经不重要了，因为我们已经有了一个`false`。重要提示:参考下面的重构部分，看看我们如何利用这个事实来优化我们的运行时。

在将数组中的每个索引与测试数组进行比较之后，我们评估`checker`以查看它的所有检查是否都为真。如果是，我们知道数组有完全相同的值，可以通过返回`true`退出函数。

如果`checker`中有一个错误，我们知道数组中有一些索引没有相同的值。我们将`i`加 1，并继续移动到 2D 数组中的下一个数组。

最终，我们到达了 2D 数组中的`[1,2,3]`。我们比较这些指数:

*   因此我们将 true 推给我们的检查器。
*   因此我们将 true 推给我们的检查器。
*   因此我们将 true 推给我们的检查器。

现在我们可以看看`checker`是否为真。确实如此，这意味着`[1,2,3]`已经存在于数组中。厉害！

# 重构我们的解决方案

上面的解决方案是可行的，但是每次我们做比较时都要构建一个检查数组，这有点昂贵。当我们开始处理大型数组时，我们可能真的会增加它运行的时间！

一个真正简单的重构利用 break 关键字来逃离内部循环。我们也可以将`checker`设置为一个布尔值，稍后再评估它的值。如果在任何时候我们从比较结果中得到`false`，我们可以在重置`checker`的值后停止内部循环的运行。

这是大多数情况下将要发生的事情，因此我们可以在循环中花费更少的时间，并放弃进行一系列检查。我在本文前面说过，我们只关心在`checker`数组中有一个`false`的时候。我们仍然在利用这种逻辑，只是我们更加切题了。一旦我们遇到`false`，我们就可以继续前进，因为我们已经确定这两个数组不是完美的匹配。

因此，我们退出内循环的速度要比之前的算法快得多。我们仍然在每次通过外部循环时检查`checker`的值，如果为真，则提前终止。然而，这一次要快得多，因为我们只是看看它是真还是假，而不是我们以前做的迭代过程。

这对于向`permutations`数组添加独特的东西来说是很棒的，因为随着`permutations`数组的增长，我们将会得到很多`true`的情况。通过确定一个数组已经在其中，我们可以更快地移动它来测试下一个数组是否在其中。

# 结论

至此，我们已经讨论了一种比较数组的方法，通过遍历数组的内容来解决引用传递的问题。我们还提到了 2D 数组和重构方法，比如利用关键字`break`和在循环过程中组合条件关键字和关键字`return`。以此为指导，尝试一些你自己的练习。

编码快乐！