<html>
<head>
<title>3 Easy Ways to Simplify On-disk SwiftUI Data Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化磁盘SwiftUI数据管理的3种简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-3-ways-to-make-managing-on-disk-data-effortless-d42e1bc2cdd4?source=collection_archive---------17-----------------------#2022-06-15">https://betterprogramming.pub/swift-3-ways-to-make-managing-on-disk-data-effortless-d42e1bc2cdd4?source=collection_archive---------17-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="177b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">应用存储、自定义扩展、自定义属性包装</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54836901e64d8fa959bc7a83adb93ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tAtq7GQXqGeH8Fvy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马腾·范·登·霍维尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以在iOS环境中管理磁盘上的数据，比如像<a class="ae kv" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjSkYPGnZr4AhUSZd4KHZ5KDSoQFnoECA0QAQ&amp;url=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fcoredata&amp;usg=AOvVaw2FxOgffO2RE0YsrYYTlBME" rel="noopener ugc nofollow" target="_blank"> CoreData </a>和<a class="ae kv" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjB94K4nZr4AhUWEYgKHbtwAVAQFnoECAgQAQ&amp;url=https%3A%2F%2Frealm.io%2F&amp;usg=AOvVaw15npDRZX982bltpEvaLAV0" rel="noopener ugc nofollow" target="_blank"> Realm </a>这样的库。此外，那些使用简单项目或轻量级应用程序的人可以很容易地想到其他的选择:<code class="fe ls lt lu lv b">UserDefaults</code>和<code class="fe ls lt lu lv b">FileManager</code>。</p><p id="eddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">UserDefaults</code>和<code class="fe ls lt lu lv b">FileManager</code>是流行的本地API，可能足以满足大多数期望的规范。然而，除了它的可及性，还有一个不容忽视的问题。</p><p id="c54f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用起来很恐怖。</strong></p><p id="45e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下你不断从磁盘中保存和加载一个<code class="fe ls lt lu lv b">array</code>的情况。每次向<code class="fe ls lt lu lv b">array</code>添加一个元素，都要遵循加载、解码、追加、编码并最终保存数据的例程。太麻烦了。</p><p id="adb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这篇文章，我将向你展示我是如何处理这种枯燥、重复的工作，并使我的代码更加干净和健壮的。</p><p id="8996" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那我们开始吧！</p><h1 id="cda8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">摘要</h1><ol class=""><li id="88d0" class="mo mp iq ky b kz mq lc mr lf ms lj mt ln mu lr mv mw mx my bi translated">原生功能:<code class="fe ls lt lu lv b">AppStorage</code> (iOS 14+)</li><li id="44d4" class="mo mp iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">自定义<code class="fe ls lt lu lv b">extension</code></li><li id="063c" class="mo mp iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">自定义属性包装</li></ol></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="567c" class="lw lx iq bd ly lz nl mb mc md nm mf mg jw nn jx mi jz no ka mk kc np kd mm mn bi translated">应用存储(iOS 14以上版本)</h1><p id="b62b" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">事实上，我们已经有了一个很好的解决方案<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.apple.com/documentation/swiftui/appstorage" rel="noopener ugc nofollow" target="_blank">AppStorage</a></code>。随着iOS 14的发布，苹果带来了一个名为<code class="fe ls lt lu lv b">AppStorage</code>的属性包装器，它简化了很大一部分磁盘数据处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的例子，展示了一个根据存储值<code class="fe ls lt lu lv b">isFirst</code>的状态而变化的UI组件。</p><p id="4ba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我需要做的就是用<code class="fe ls lt lu lv b">@Appstorage</code>包装一个变量，并给它一个唯一的字符串键。然后，它将为我们处理大多数烦人的I/O任务，最终，即使在应用程序被终止后，数据也可以持续存在。</p><p id="eb43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它似乎是一个伟大的解决方案，带来了<code class="fe ls lt lu lv b">UserDefault</code>的所有优点，并消除了大部分缺陷。然而，在使用它之前有一些信息要知道。</p><p id="3801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">仅支持</strong><code class="fe ls lt lu lv b"><strong class="ky ir">Int</strong></code><strong class="ky ir"/><code class="fe ls lt lu lv b"><strong class="ky ir">Double</strong></code><strong class="ky ir"/><code class="fe ls lt lu lv b"><strong class="ky ir">String</strong></code><strong class="ky ir"/><code class="fe ls lt lu lv b"><strong class="ky ir">URL</strong></code><strong class="ky ir"/><code class="fe ls lt lu lv b"><strong class="ky ir">Data</strong></code><strong class="ky ir">(含可选)。</strong>表示如果要保存<code class="fe ls lt lu lv b">struct</code>、<code class="fe ls lt lu lv b">class</code>或<code class="fe ls lt lu lv b">array</code>，还是要再做<code class="fe ls lt lu lv b">encoding</code>、<code class="fe ls lt lu lv b">decoding</code>。</p><p id="48bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从iOS 14开始支持。这就是我们一直以来所遭受的痛苦。另外，还得用<strong class="ky ir"> SwiftUI </strong>才能使用。</strong></p><h1 id="c680" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">自定义扩展</h1><p id="4a47" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">自定义扩展的概念是尽可能保持方法最初编写的方式。为此，我们需要能够向磁盘存储的数组添加一个元素，例如:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="9ec9" class="nz lx iq lv b gy oa ob l oc od">var testArray = [Int]()<br/>testArray.append(3, storage: "testArrayKey")</span></pre><p id="ae56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="88e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我重载了两个常用的方法<code class="fe ls lt lu lv b">append</code>和<code class="fe ls lt lu lv b">removeAll</code>。与原始版本的唯一区别是它有一个额外的参数<code class="fe ls lt lu lv b">storage</code>，该参数将用于<code class="fe ls lt lu lv b">FileManager</code>存储的路径。</p><p id="d66c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是测试代码的简单用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/95495e1bb37846dcd218bd83161f24fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDgUGnmNVXLFwSVcRHV5dA.png"/></div></div></figure><p id="bbb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们似乎没有问题。然而，有几个问题很容易被忽略。</p><p id="5900" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一，预测初值比较混乱。</strong>我们来看一个<strong class="ky ir"> </strong>这次的失败案例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/85a7a97ba5374a3872ac56bc19d093ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PNt7UKe3_Ubf3Q_w5XM1g.png"/></div></div></figure><p id="986e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子表明，当你试图改变一个已经在某处初始化的变量的值时，你可能会得到意外的错误。发生这种情况是因为它忽略新值并加载保存的数据，而不是用新值重新定义变量。<code class="fe ls lt lu lv b">AppStorage</code>也有同样的问题。</p><p id="5e74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要解决这个问题，您可以选择请求更多的参数，或者只是警告用户将要发生错误。</p><p id="9a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二个</strong>，<strong class="ky ir">你要把你需要的东西都一一实现。</strong>我这次只写了<code class="fe ls lt lu lv b">Codable</code>数组的代码，但是如果你想要更多的方法，比如<code class="fe ls lt lu lv b">filter</code>、<code class="fe ls lt lu lv b">map</code>甚至<code class="fe ls lt lu lv b">struct</code>、<code class="fe ls lt lu lv b">class</code>，你应该重复同样的事情来写大量的代码。</p><h1 id="0d2e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">自定义属性包装</h1><p id="4892" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">为了解决这些挑战，我想出了一个新的解决方案:<strong class="ky ir">属性包装器。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是测试代码的一些用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b0e5ef9a9c2845471b3c9b272ec46f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cp38xoL_2l1CTDxytmZulg.png"/></div></div></figure><p id="6d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比<code class="fe ls lt lu lv b">extension</code>，它有三个优点。</p><p id="5732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">首先</strong>，你不必重载所有你需要的方法。用<code class="fe ls lt lu lv b">Stored</code>包装一个变量，你将得到一个持久存储，它拥有该类型最初拥有的所有特性，因为它使用了泛型类型。</p><p id="1647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二个</strong>，它防止我们得到在定制<code class="fe ls lt lu lv b">extension</code>中看到的“不可预测的初始值误差”。下面是验证它的测试代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/0ed7e43ebb405120b137e03a07a18405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2-v-LVdaw0WSSGOa56fGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">解决了！</p></figure><p id="7d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第三个</strong>，因此变得更加健壮。我们可以通过引发异常来处理特定错误。例如，当试图使用未初始化的值时，我们可以使应用程序崩溃。</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="2af1" class="nz lx iq lv b gy oa ob l oc od">func testStoredWrapperNotStoredBefore() throws {<br/>    <a class="ae kv" href="http://twitter.com/Stored" rel="noopener ugc nofollow" target="_blank">@Stored</a>("NotInitialized") var storedQueue: [String]<br/>} // Throws fatalError</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/f3df12d13c05f499cc26684c056242e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ILYEFK3wMR-oyDWBLUGtQ.png"/></div></div></figure><p id="8481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这又取决于你是否通过在其他地方抛出和捕捉错误来给第二次机会，或者只是保持严格限制应用程序不可接受的行为的策略。</p></div></div>    
</body>
</html>