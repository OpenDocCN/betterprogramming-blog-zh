<html>
<head>
<title>Build a Custom iOS Segmented Control With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI构建自定义iOS分段控件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-ios-segmented-control-with-swiftui-473b386d0b51?source=collection_archive---------2-----------------------#2020-05-18">https://betterprogramming.pub/custom-ios-segmented-control-with-swiftui-473b386d0b51?source=collection_archive---------2-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba02" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们比苹果默认的分段控制更进一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc6541b0700eb50315a058775b9b7edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_wp-KGLnkl1qfPgVpTALA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是我们将在本教程中构建的东西(作者拍摄)。</p></figure><p id="0c65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将分享我在SwiftUI中自定义<code class="fe lu lv lw lx b">SegmentedPicker</code>的实现。您可能会问，“为什么要自己经历实现这一点的痛苦？”</p><p id="0a6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，使用带有<code class="fe lu lv lw lx b">.pickerStyle(SegmentedPickerStyle())</code>的SwiftUI <code class="fe lu lv lw lx b">picker</code>是一种获得分段控制功能的本地方式，并且没有太多的开销:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/99b0ee420dd4b98435333d6d2e699eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tty7PxueoNtS0sxzdCnYPw.png"/></div></div></figure><p id="287d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是有一个巨大的缺点:自带的动画意味着很难在没有一些有趣行为的情况下封装选择变量。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/6af22213c3cb41c94158ff647fe52a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*EVvBoaFDeb8j3RnCU0U_RA.gif"/></div></figure><p id="7944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到那个烦人的闪烁了吗？</p><p id="e592" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定制选择器的外观也几乎是不可能的，所以为了超越这些限制，我决定在SwiftUI中实现自己的分段控件。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2f3c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.概观</h1><p id="d83c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">所以，这是我们要建造的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ed0dfb40328fff9fa92757c9723e0a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgIvGftgChVg2ary-662MA.png"/></div></div></figure><p id="1b09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可能会尝试这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8d39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这实际上只是给当前选中的索引添加了一个白色的<code class="fe lu lv lw lx b">RoundedRectangle</code>背景。这对于简单的用例很有效，但是不支持选择转换之间的漂亮的滑动动画。</p><p id="2b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使这更优雅，我们有三个分段控件的基本元素:</p><ol class=""><li id="b078" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">圆角矩形背景视图</li><li id="24f8" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">每个项目的文本</li><li id="8a5c" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">表示当前选择的圆角矩形</li></ol></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d03d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.创建容器和项目</h1><p id="fc3b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">让我们定义一个简单的视图，该视图仅枚举分段控件的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8e58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是相当多的代码。让我们过一遍:</p><ol class=""><li id="4c59" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">我总是努力保持视图常量，如填充、字体和文本颜色整洁有序。这允许我调整视图，而无需重新研究视图本身的实现。这些静态常量允许我轻松地查看和编辑次要视图细节。</li><li id="5c11" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">很像本地SwiftUI <code class="fe lu lv lw lx b">Picker</code>的输入，我们需要一些要显示的项目和一个<code class="fe lu lv lw lx b">@Binding</code>选择属性，以便我们可以将状态更改传播到父视图。</li><li id="aec6" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">视图本身很简单。它是一个<code class="fe lu lv lw lx b">HStack</code>，水平放置等宽的项目。对于<code class="fe lu lv lw lx b">items</code>中的每一项，我们调用一个函数来检索一个<code class="fe lu lv lw lx b">Text</code>视图元素。</li><li id="6815" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">函数<code class="fe lu lv lw lx b">getSegmentView</code>返回一个<code class="fe lu lv lw lx b">Text</code>元素，带有指定索引的项目名称。我们在这里应用了一些视图修饰符，并确保检查使用的索引实际上在我们的数组的边界内。值得注意的几点:我们计算当前索引是否被选中，并使用稍微暗一点的文本来表示选择。我们使用<code class="fe lu lv lw lx b">.frame(minWidth: 0, maxWidth: .infinity)</code>,这样可点击的框架就占据了所有的可用空间，而不是包裹<code class="fe lu lv lw lx b">Text</code>元素。</li><li id="3f83" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">我们定义一个<code class="fe lu lv lw lx b">onItemTap</code>方法。这允许我们在点击文本元素时更改当前选择。</li></ol><p id="76ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们得到的。还不错！我们只是缺少活动元素指示器，它是一个简单的白色<code class="fe lu lv lw lx b">RoundedRectangle</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6222fa2f6e8f1acee7edf43461fa5679.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*5czA1z9iGGc1yeIXuFHSPw.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="738f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.主动选择指示器</h1><p id="225e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">选定元素的背景是一个<code class="fe lu lv lw lx b">RoundedRectangle</code>。为了显示可用选项后面的矩形，我们将<code class="fe lu lv lw lx b">HStack</code>包装在<code class="fe lu lv lw lx b">ZStack</code>中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f8a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在在背景中看到一个圆角矩形，但是我们需要根据当前活动的选择来定义矩形的大小及其相对位置。</p><p id="42c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了定义大小和偏移量，我们需要以某种方式获取每个项目的大小。为了在SwiftUI中做到这一点，我们利用了<code class="fe lu lv lw lx b">PreferenceKey</code>。</p><h2 id="a0ae" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">3.1 PreferenceKey键获取项目宽度</h2><p id="a02f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><a class="ae oi" href="https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>回顾了SwiftUI <code class="fe lu lv lw lx b">PreferenceKeys</code>。简而言之，我们可以定义一个<code class="fe lu lv lw lx b">PreferenceKey</code>来将属性从子视图传递给它的子视图。在我们的例子中，我们需要传递每个文本项的大小。我们的<code class="fe lu lv lw lx b">HStack</code>将每个项目分成相等的宽度，所以我们基本上只需要在<code class="fe lu lv lw lx b">ForEach</code>循环中创建的一个片段视图的宽度。</p><p id="2a6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个<code class="fe lu lv lw lx b">PreferenceKey</code>来检索尺寸。然后，我们可以使用一个简单的小技巧，通过在视图的背景上定义一个<code class="fe lu lv lw lx b">GeometryReader</code>来获得视图的固有大小。然后，我们使用一个定制的<code class="fe lu lv lw lx b">ViewModifier</code>来封装检索视图大小和更新绑定所需的所有操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="eb97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浏览项目:</p><ol class=""><li id="c399" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">这是检索尺寸的<code class="fe lu lv lw lx b">PreferenceKey</code>。我们将检索到的值的类型定义为一个<code class="fe lu lv lw lx b">CGSize</code>，它包含宽度和高度信息。</li><li id="5d28" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">我们定义了一个助手视图(<code class="fe lu lv lw lx b">BackgroundGeometryReader</code>)，它将作为我们文本项的背景。这使用了我前面提到的技巧——在背景上定义一个<code class="fe lu lv lw lx b">GeometryReader</code>给我们视图的固有大小。请注意，我们附加了<code class="fe lu lv lw lx b">SizePreferenceKey</code>，并向其传递了视图大小。</li><li id="733b" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">我们定义<code class="fe lu lv lw lx b">SizeAwareViewModifier</code>来封装所有这些逻辑。它将一个<code class="fe lu lv lw lx b">Binding</code>作为<code class="fe lu lv lw lx b">viewSize</code>的输入。这是为了使大小的更新可以在视图层次结构中向上传播。注意，我们附加了背景<code class="fe lu lv lw lx b">BackgroundGeometryReader</code>，它将<code class="fe lu lv lw lx b">SizePreferenceKey</code>附加到视图上。然后我们通过调用<code class="fe lu lv lw lx b">onPreferenceChange</code>来观察<code class="fe lu lv lw lx b">PreferenceKey</code>值的变化。回调监视<code class="fe lu lv lw lx b">SizePreferenceKey</code>值的更新，然后相应地更新绑定。</li></ol><p id="d09a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！现在我们只需附上新的<code class="fe lu lv lw lx b">ViewModifier</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2ca1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经获得了其中一个段的固有大小，我们就可以正确地构建活动选择指示器了。</p><h2 id="44bc" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">3.2使用视图大小创建活动选择指示器</h2><p id="6539" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">概括一下，这就是我们最终产品的样子。活动的选择指示器是与当前选择一起滑动的白色背景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ed0dfb40328fff9fa92757c9723e0a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgIvGftgChVg2ary-662MA.png"/></div></div></figure><p id="d82f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们面临两大挑战:</p><ol class=""><li id="595c" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">为活动选择指示器定义适当的大小。</li><li id="988a" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">根据当前选择确定指示器的正确位置。</li></ol><p id="ad28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前，我们在一个<code class="fe lu lv lw lx b">ZStack</code>中定义了一个简单的<code class="fe lu lv lw lx b">RoundedRectangle</code>作为我们的活动段视图。让我们执行以下操作:</p><ol class=""><li id="7462" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">提取视图作为一个变量来保持事物的整洁。</li><li id="44c8" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">将<code class="fe lu lv lw lx b">ZStack</code>校准改为<code class="fe lu lv lw lx b">.leading</code>。这意味着<code class="fe lu lv lw lx b">ZStack</code>中的所有视图将对齐框架的前沿(而不是中心)。这使得计算活动段的位置变得容易多了！</li><li id="bf6a" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">定义一个叫做<code class="fe lu lv lw lx b">computeActiveSegmentHorizontalOffset</code>的方法。这为我们提供了活动段指示器的位置。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="7ba1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码应该相对简单，除了<code class="fe lu lv lw lx b">computeActiveSegmentHorizontalOffset()</code>。在这种方法中，我们假设我们的<code class="fe lu lv lw lx b">ZStack</code>与前沿对齐(大多数地区是左沿)。我们知道提货器中每个商品的有效水平宽度是<code class="fe lu lv lw lx b">(self.segmentSize.width + SegmentedPicker.SegmentXPadding / 2)</code>。因此，从前缘偏移的值就是索引选择乘以此宽度。</p><p id="1995" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！我们现在看到这个结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/519001eb2e3c46f9e6562a919a95072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*bHJLS85ySeR6zRg7aw-Mxg.gif"/></div></figure><p id="bd7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要获得完整的代码，见这个<a class="ae oi" href="https://gist.github.com/frankfka/2784adff55be72a4f044d8c2bcc9fd3f" rel="noopener ugc nofollow" target="_blank">要点</a>。编码快乐！</p></div></div>    
</body>
</html>