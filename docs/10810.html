<html>
<head>
<title>8 JavaScript Practices To Avoid — And What to Do Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的8种JavaScript实践——以及应该怎么做</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-horrifying-practices-you-really-must-not-do-in-javascript-5e9ef2a07b27?source=collection_archive---------4-----------------------#2022-01-28">https://betterprogramming.pub/8-horrifying-practices-you-really-must-not-do-in-javascript-5e9ef2a07b27?source=collection_archive---------4-----------------------#2022-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="72f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这些建议拯救你自己和你周围的人</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d32cf362ef7a10d9d472f45d49bdf92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fFVnUSAEf7Fmas52"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄</p></figure><p id="82c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发代码时，JavaScript可能是一种非常灵活但强大的语言，但要知道我们应该避免哪些实践并不总是那么简单。</p><p id="6d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将讨论一些你应该避免的JavaScript实践，以免为时过晚。</p><p id="da15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的一些(或全部)例子<em class="lv">对你们中的一些人来说可能已经是旧闻了。但是当我看到人们使用这些方法时，就像这篇文章中列出的，我认为这是值得重新审视的，这样我们中的更多人(包括你)就可以在晚上睡觉了。</em></p><p id="3811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧！</p><h1 id="23dd" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.深度查找…无需验证</h1><p id="0c4c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是可以用TypeScript这样的工具轻松避免的实践之一，但令人惊讶的是，开发人员今天正在犯这个错误。</p><p id="6ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最近有人在生产中制作的一个真实场景示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="878c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种做法的问题是，如果我们对一个对象进行深度查找，而其中一个对象的中间值为空，就会产生一个错误，导致应用程序崩溃，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="55cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在对象上查找深层属性时，在继续下一步之前，最好总是验证查找产生的数据类型是预期的(或者至少确保查找产生的每个值总是<em class="lv">或者</em>是预期的数据类型<em class="lv">或者</em>某个假值):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带可选链接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="be20" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.过度使用你的文件夹结构</h1><p id="07a1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我知道当我们开始开发我们的应用程序时，特别是当我们开始使用一个像redux这样随时间扩展的库时，一开始就追求完美和追求卓越是很诱人的。</p><p id="4a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，为你的项目成为市场上的下一个最大的东西做准备是很好的，但是如果你决定休息一下或者分支到另一个项目，如果你试图在未来重新开始，你可能会让你自己(甚至其他人，如果他们会阅读你的代码的话)变得更加困难。</p><p id="2198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就拿redux来说吧。如果我们正在构建一个React应用程序，并考虑我们希望我们的文件夹结构是什么样的(同时记住一个常见的惯例是将组件分离到它们自己的文件夹中)，我们可能会得到类似于<a class="ae ky" href="https://github.com/erikras/react-redux-universal-hot-example/tree/master/src/components" rel="noopener ugc nofollow" target="_blank"> this </a>的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/fc7edd8e6f5378aa4100089ffc7d0e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18EUGxcqvKiLEMBRfZW1UA.png"/></div></div></figure><p id="b56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是<code class="fe mw mx my mz b">CounterButton</code>、<code class="fe mw mx my mz b">GithubButton</code>和/或<code class="fe mw mx my mz b">Flex</code>可能<em class="lv">永远不会</em>被再次改变。</p><p id="8a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们快进到4个月后，我们的回购包含几十个文件夹中的文件夹，包含文件夹中的组件，这是不必要的复杂。我们不需要通过点击几个文件夹来寻找我们正在寻找的组件。</p><p id="0b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这是一个更好的方法，而且有意义，那么就去做(不是因为reddit上有人告诉你要这么做):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/ffcfe260fb7aefb0a82a78cbbfe06d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prZv0Gvt1jafiBz3ikqLlw.png"/></div></div></figure><p id="7f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它应该是简单的，并且对你目前正在进行的项目来说感觉是正确的，类似于丹·阿布拉莫夫(<code class="fe mw mx my mz b">redux</code>的创作者)所说的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/46d62d33062aa1ff2ab54a95460d134b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lY0nnuIHj_L3oMst.png"/></div></div></figure><h1 id="4c93" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.在盒子里思考</h1><p id="acef" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我们正在编写人们会阅读的代码(例如当与你的队友一起调试问题时)<em class="lv">不要</em>在盒子里思考！</p><p id="90b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道快速、直截了当地编写函数很有诱惑力。我承认我仍然会时不时地犯这样的错误，尽管大多数时候我都能控制住自己。</p><p id="0992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ab52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都很好，但当你仔细看看，你怎么知道什么<code class="fe mw mx my mz b">serviceResponse?.getCode()</code>会回来？如果它返回<code class="fe mw mx my mz b">0</code>呢？</p><p id="a920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些传统实践中，我们被告知<code class="fe mw mx my mz b">0</code>是成功的代码(尽管语言将其解释为虚假，但这是我的观点)，所以我们必须考虑仔细编写我们的实现，因为人们将无法读懂我们的思想，也无法清楚地理解代码在做什么。如果它返回<code class="fe mw mx my mz b">1</code>，或者<code class="fe mw mx my mz b">5</code>，<code class="fe mw mx my mz b">9</code>呢？在这一点上，最好不要碰代码，去找开发人员解释。</p><p id="7043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以一种更易于阅读的方式来编写代码的一个好的解决方案是将代码赋值给描述代码的常量变量，然后在我们的项目中使用它们。</p><p id="2faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有用的实践，你通常会在许多图书馆看到，例如<a class="ae ky" href="https://github.com/twilio/twilio-video.js/blob/master/lib/util/constants.js" rel="noopener ugc nofollow" target="_blank"> twilio-video </a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="b25a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">4.循环时的隧道视觉</h1><p id="52d1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然循环在快速完成工作时很好，但是当它们不考虑条件不满足时，它是难以置信的毁灭性的！</p><p id="7c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题不是针对<em class="lv">故障条件</em>增加<code class="fe mw mx my mz b">startCount</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="56cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着while循环将永远不会结束，因为如果在下一个程序块增加<code class="fe mw mx my mz b">startCount</code>达到了<code class="fe mw mx my mz b">numComponents</code>，那么<code class="fe mw mx my mz b">startCount</code>将永远不会增加。</p><p id="05d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以理解为什么有人会忘记这一点。</p><p id="ad18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，也许开发人员习惯于用失败案例的简单日志来处理代码(这实际上对于我们面临的大多数问题来说已经足够了),并且可能意外地认为他们的程序仍然会运行。</p><p id="bfbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我的第二个想法是，当我们编写代码时，这通常是自然发生的，每次条件<em class="lv">通过</em>时，我们最终都会增加或更新一些变量(因为我们不需要做任何进一步的事情):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，可以理解前面例子中的开发者如何让<em class="lv">隧道预见到</em>通过条件的阻碍。</p><h1 id="9049" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">5.<code class="fe mw mx my mz b">@ts-ignore</code></h1><p id="967f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您已经使用了TypeScript，并且发现自己正在使用它来忽略代码中令人讨厌的错误，请相信我，这不是应该做的事情！</p><p id="870f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript提供了一个更强大、更安全的关键字来消除林挺错误。</p><p id="f91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe mw mx my mz b">@ts-expect-error</code>,它的工作方式和<code class="fe mw mx my mz b">@ts-ignore</code>(或者ESLint中的<code class="fe mw mx my mz b">eslint-disable-next-line</code>)一样，除了当<em class="lv">不再认为没有它就是错误</em>时，它会给你一个林挺错误。</p><blockquote class="nc nd ne"><p id="fd0b" class="kz la lv lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><em class="it">没有</em> <code class="fe mw mx my mz b"><em class="it">@ts-expect-error</em></code> <em class="it">上一个排版错误:</em></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/cf07ba338a64454cf45f64acdfd0f434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lTv1NoX0ydowaq9s.png"/></div></div></figure><blockquote class="nc nd ne"><p id="c364" class="kz la lv lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><em class="it">使用</em> <code class="fe mw mx my mz b"><em class="it">@ts-expect-error</em></code> <em class="it">上一个排版错误</em></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d67243a30287b244162972c06fad6bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*nM4-6GSOmgJ4ootF.png"/></div></figure><blockquote class="nc nd ne"><p id="6db7" class="kz la lv lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><em class="it">有效时使用</em><code class="fe mw mx my mz b"><em class="it">@ts-expect-error</em></code><em class="it">:</em></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/816edec0f4f977f78fc57a5f09b00f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*e7n5uttBKsBYa4X6.png"/></div></figure><p id="d819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么为什么不使用<code class="fe mw mx my mz b">@ts-expect-error</code>方法呢？它保护你和你周围的人。</p><h1 id="7e68" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">6.初始化无效值的默认参数</h1><p id="fbc1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我在之前的一篇文章中提到过这个话题，但是这是那些令人毛骨悚然的“陷阱”之一，可以在一个阴沉的星期五愚弄一个粗心的开发者！毕竟，应用崩溃不是一个笑话——如果处理不当，任何类型的崩溃都可能导致金钱损失。</p><p id="60b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我曾经因为花了大量时间调试类似的东西而感到内疚:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="10a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mw mx my mz b">init</code>内部，如果<code class="fe mw mx my mz b">value</code>最终是<code class="fe mw mx my mz b">falsey</code>，它将被初始化为<code class="fe mw mx my mz b">null</code>。</p><p id="b613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你和我一样，我们的直觉告诉我们，如果<code class="fe mw mx my mz b">value</code>是一个<code class="fe mw mx my mz b">falsey</code>值，默认情况下它应该被初始化为一个空的对象文字。但是当值为<code class="fe mw mx my mz b">falsey</code>时，我们的应用程序会崩溃，因为<code class="fe mw mx my mz b">value</code>是<code class="fe mw mx my mz b">null</code>。<em class="lv">什么</em>？</p><p id="4a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<em class="lv">没有值</em>或<code class="fe mw mx my mz b">undefined</code>被传递，默认函数参数允许命名参数用默认值初始化！</p><p id="8bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，即使<code class="fe mw mx my mz b">null</code>是<code class="fe mw mx my mz b">falsey</code>，它仍然是一个值！</p><p id="b9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以下次你设置默认值为<em class="lv"> null </em>时，一定要三思而后行。</p><p id="185a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常的做法是这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它很短，只用一行就可以完成。</p><p id="64b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还提供了关于函数可能收到的预期数据类型的更多信息，这是一个优点，因为您少了一个需要担心的数据类型。</p><h1 id="9c4a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">7.<code class="fe mw mx my mz b">instanceof</code>不知何时它不起作用</h1><p id="87b2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我以前也是这种情况的受害者，如果你是JavaScript新手，你很可能不知道如果你在一个单独的执行环境(不同的浏览器上下文，全局对象等)中创建对象，那么<code class="fe mw mx my mz b">instanceof</code>将不起作用。</p><p id="ce03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">mdn文档展示了这种行为在实践中的一个很好的例子:</p><p id="a406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mw mx my mz b">[] instanceof window.frames[0].Array</code>将返回false，因为<code class="fe mw mx my mz b">Array.prototype !== window.frames[0].Array.prototype</code>和数组继承了前者</p><p id="c3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是要小心的，因为它不会报告任何错误，它只会默默地让条件失败并继续，使调试变得更加困难。TypeScript不会<em class="lv">也不会</em>捕捉到这一点，所以这一次你只能靠自己了！</p><h1 id="29e1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">8.<code class="fe mw mx my mz b">async</code>在forEach中</h1><p id="fe86" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我最近看到有人这样做，实际上关键是<em class="lv">不要做</em>，因为<em class="lv">你</em>有责任不犯这个错误。</p><p id="fc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，<code class="fe mw mx my mz b">async</code>在<code class="fe mw mx my mz b">forEach</code>调用中使用时并不像我们预期的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="705c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个函数只会返回一个空数组，因为它不会等待异步调用完成。它不会跳过获取，而是不会等待调用完成，所以不会返回任何结果。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="d329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>