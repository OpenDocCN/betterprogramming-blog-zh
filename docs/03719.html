<html>
<head>
<title>Enums and Pattern Matching in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的枚举和模式匹配</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-enums-and-pattern-matching-177b03a4152?source=collection_archive---------1-----------------------#2020-02-29">https://betterprogramming.pub/rust-enums-and-pattern-matching-177b03a4152?source=collection_archive---------1-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7926" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">铁锈基础知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd9fe5a7ea5bdfd6fc7ef6c2ab2c7255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_cv6T_EXcdgO62xA3TiaA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帕特里克·托马索在<a class="ae kv" href="https://unsplash.com/s/photos/pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6da9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的代码可以在<a class="ae kv" href="https://github.com/abhirockzz/learning-rust" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d962" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">列举型别</h1><p id="8999" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">从某种意义上说，<code class="fe mw mx my mz b">enum</code>类似于<code class="fe mw mx my mz b">struct</code>,因为它是一种可以有多个变量的类型(与类及其实例的类型相同)。但是<code class="fe mw mx my mz b">enum</code>的变体是固定的，并且在<code class="fe mw mx my mz b">enum</code>本身中定义。</p><p id="857f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe mw mx my mz b">Player</code>可以用一个<code class="fe mw mx my mz b">struct</code>来表示:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="1639" class="ne ma iq mz b gy nf ng l nh ni">struct Player {<br/>    name: String,<br/>    rank: i32,<br/>}</span></pre><p id="c077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以实例化一个<code class="fe mw mx my mz b">Player</code>的多个实例。但是我们来看一个稍微小众一点的类型。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="ca23" class="ne ma iq mz b gy nf ng l nh ni">enum PlayerAccountType {<br/>    Free,<br/>    Paid,<br/>}</span></pre><p id="0484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你只有两种账户——免费账户和付费账户。你可以用一个<code class="fe mw mx my mz b">enum</code>来表示这个概念。而且，由于它只是另一种类型，你可以在<code class="fe mw mx my mz b">Player</code>结构中使用它。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d1ff" class="ne ma iq mz b gy nf ng l nh ni">struct Player {<br/>    name: String,<br/>    rank: i32,<br/>    acc_type: PlayerAccountType,<br/>}</span></pre><p id="bfa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以用一个<code class="fe mw mx my mz b">struct</code>来表示<code class="fe mw mx my mz b">PlayerAccountType</code>类型，但是您不必这样做，因为它可能的变体已经是已知的了。</p><p id="b4bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe mw mx my mz b">::</code>引用枚举变量。例如，为了实例化具有付费账户的<code class="fe mw mx my mz b">Player</code>:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="19ef" class="ne ma iq mz b gy nf ng l nh ni">let paid_member = Player{acc_type: PlayerAccountType::Paid, name: String::from("john"), email: String::from("john@doe.com")};</span></pre><p id="7dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以向<code class="fe mw mx my mz b">enum</code>变量添加数据。例如:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="e02d" class="ne ma iq mz b gy nf ng l nh ni">enum foo {<br/>    foo1(String),<br/>    foo2(String),<br/>}</span></pre><p id="4d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:</p><ul class=""><li id="4a00" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">除了数据，<code class="fe mw mx my mz b">enum</code> s还可以有方法</li><li id="3038" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe mw mx my mz b"><a class="ae kv" href="https://doc.rust-lang.org/std/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option&lt;T&gt;</a></code>和<code class="fe mw mx my mz b"><a class="ae kv" href="https://doc.rust-lang.org/std/result/enum.Result.html" rel="noopener ugc nofollow" target="_blank">Result&lt;T,E&gt;</a></code>被广泛使用<code class="fe mw mx my mz b">enum</code> s，是<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>标准库的一部分。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3099" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模式匹配</h1><p id="963a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust提供了<code class="fe mw mx my mz b">match</code>关键字，其行为方式与<code class="fe mw mx my mz b">switch</code>语句相同(Rust没有<code class="fe mw mx my mz b">switch</code>)。在探索<code class="fe mw mx my mz b">match</code>之前，让我们看一个简单的<code class="fe mw mx my mz b">if-else-if</code>例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="190e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有惊喜！但是你<em class="nz">不能</em>用<code class="fe mw mx my mz b">match</code>写这个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是不可能的，因为<code class="fe mw mx my mz b">match</code>操作符需要一个值来执行匹配过程。它不会为您执行给定的表达式。</p><p id="1fe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新</strong>:根据<a class="ae kv" href="https://medium.com/@rpring9/your-if-else-if-is-possible-with-guards-843c312d281" rel="noopener">此注释</a>，使用<a class="ae kv" href="https://doc.rust-lang.org/stable/rust-by-example/flow_control/match/guard.html" rel="noopener ugc nofollow" target="_blank">防护装置</a>可以实现<code class="fe mw mx my mz b">if-else-if</code>。谢谢，<a class="ae kv" href="http://twitter.com/rpring9" rel="noopener ugc nofollow" target="_blank"> @rpring9 </a>！</p><p id="cd07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般格式如下:</p><ul class=""><li id="5e7d" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">您有一个想要与之匹配的值和一堆可能的选项，也称为<code class="fe mw mx my mz b">match arm</code>。</li><li id="e3e0" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">每个机械手都是要匹配的模式和匹配成功时要运行的相应<code class="fe mw mx my mz b">expression</code>的组合。</li></ul><p id="27cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些听起来都很抽象，所以让我们来看一个用<code class="fe mw mx my mz b">enum</code>进行<code class="fe mw mx my mz b">match</code>运算的例子。</p><h2 id="bf52" class="ne ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">匹配枚举</h2><p id="618d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们从定义一个<code class="fe mw mx my mz b">enum</code>开始:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="822a" class="ne ma iq mz b gy nf ng l nh ni">enum Choice {<br/>    One,<br/>    Two,<br/>    Three,<br/>}</span></pre><p id="8555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并与<code class="fe mw mx my mz b">Choice</code> s匹配。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2131" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，变量<code class="fe mw mx my mz b">choice</code>是被<code class="fe mw mx my mz b">match</code> ed的值，后跟三个<code class="fe mw mx my mz b">match</code>臂。对于每个手臂，都有一个模式，例如<code class="fe mw mx my mz b">Choice::One</code>和相应的表达式，例如由<code class="fe mw mx my mz b">=&gt;</code>分隔的<code class="fe mw mx my mz b">println!("Option 1")</code>。</p><p id="adbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，输出将是<code class="fe mw mx my mz b">Option 1</code>。</p><h2 id="66e8" class="ne ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">匹配一个选项</h2><p id="c2fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust标准库提供了<code class="fe mw mx my mz b">Option</code> <code class="fe mw mx my mz b">enum</code>，其目的是定义一个类型来表示一个场景，其中<em class="nz">可能有值，也可能</em>没有值。</p><p id="52da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得代码显而易见，并且比使用<code class="fe mw mx my mz b">null</code>、<code class="fe mw mx my mz b">nil</code>或类似选项来表示缺少值更好</p><p id="7210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类似于Java 中的<code class="fe mw mx my mz b"><a class="ae kv" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code> <a class="ae kv" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="2d69" class="ne ma iq mz b gy nf ng l nh ni">pub enum Option&lt;T&gt; {<br/>    Some(T),<br/>    None,<br/>}</span></pre><p id="4534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心<code class="fe mw mx my mz b">T</code>符号。只需理解它是一个<code class="fe mw mx my mz b">generic</code>类型参数，允许<code class="fe mw mx my mz b">enum</code>与各种类型一起工作，而不是将其绑定到一个特定的类型，例如<code class="fe mw mx my mz b">String</code>。</p><p id="3be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用一个例子来理解这个。</p><p id="f986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的CLI程序，它接受来自用户的参数(名称),并使用它来显示问候语。</p><p id="88d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户没有传递任何东西，它使用默认的问候。这是一个如何使用<code class="fe mw mx my mz b">Option</code>的合理例子，因为我们可能有也可能没有用户传入的参数(这是可选的！咄！).</p><p id="4770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是相应的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="985b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">parse_name_arg</code>函数将传入的参数转换成向量(<code class="fe mw mx my mz b">Vec&lt;String&gt;</code>)并返回一个<code class="fe mw mx my mz b">Option</code>。</p><p id="a3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个参数没有被传递，它返回<code class="fe mw mx my mz b">None</code>或<code class="fe mw mx my mz b">Some</code>(带有值)——两者都是<code class="fe mw mx my mz b">Option</code>的变体。现在我们可以这样使用这个函数:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="ea43" class="ne ma iq mz b gy nf ng l nh ni">let name = parse_name_arg();<br/>match name {<br/>   Some(n) =&gt; println!("Hello {}!", n),<br/>   None =&gt; println!("Hello there!"),<br/>}</span></pre><p id="1853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mw mx my mz b">parse_name_arg</code>的结果存储在一个名为<code class="fe mw mx my mz b">name</code>(这是一个<code class="fe mw mx my mz b">Option</code>)的变量中，匹配不同的可能性，并相应地执行问候。</p><p id="4d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你将<code class="fe mw mx my mz b">john</code>作为一个参数传递，你将返回<code class="fe mw mx my mz b">Hello john!</code>。如果你没有传递一个参数，你将得到一个通用的问候<code class="fe mw mx my mz b">Hello there!</code></p><p id="573a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要尝试这一点，只需<a class="ae kv" href="https://github.com/abhirockzz/learning-rust" rel="noopener ugc nofollow" target="_blank">克隆GitHub repo </a>，切换到正确的目录，即<code class="fe mw mx my mz b">cd learning-rust/enums-match</code>，并使用<code class="fe mw mx my mz b">cargo run</code>。要传递一个论点，可以用<code class="fe mw mx my mz b">cargo run &lt;your argument</code>。</p><p id="5483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">枚举的值在<code class="fe mw mx my mz b">match</code>子句中可用(也称为<code class="fe mw mx my mz b">arm</code>)。这就是为什么我们能够使用<code class="fe mw mx my mz b">Some(n) =&gt; println!("Hello {}!", n),</code>提取传入的参数。</p><h2 id="b1e5" class="ne ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated"><strong class="ak">使用let with match </strong></h2><p id="eb8b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">将问候语存储在变量中怎么样？您也可以将<code class="fe mw mx my mz b">let</code>与<code class="fe mw mx my mz b">match</code>一起使用来返回值。让我们稍微调整一下程序。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="8401" class="ne ma iq mz b gy nf ng l nh ni">let greeting = match name {<br/>        Some(n) =&gt; n,<br/>        None =&gt; String::from("there"),<br/>    };<br/>    println!("Hello {}!", greeting)</span></pre><p id="65e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将比赛结果存储在一个名为<code class="fe mw mx my mz b">greeting</code>的变量中，并与<code class="fe mw mx my mz b">println!</code>宏一起使用，这使得程序更加简单！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eb41" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用尽你的选择！</h1><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">默认情况下，<code class="fe mw mx my mz b">match</code>要求您履行或说明<em class="nz">所有</em>可能的选项。让我们看一个例子。这是另一个<code class="fe mw mx my mz b">enum</code>，我们将对比它的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="34b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们想要的匹配方式(在这种情况下，我们只对<code class="fe mw mx my mz b">Friday</code>感兴趣):</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="c6d9" class="ne ma iq mz b gy nf ng l nh ni">let today = Days::Friday;<br/>match today {<br/>   Days::Friday =&gt; println!("thank god its Friday!"),<br/>}</span></pre><p id="1138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这不会编译。您将看到如下错误:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d1fb" class="ne ma iq mz b gy nf ng l nh ni">error[E0004]: non-exhaustive patterns: `Monday`, `Tuesday`, `Wednesday` and 3 more not covered</span></pre><p id="da97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们可以使用<code class="fe mw mx my mz b">_</code>占位符:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d09a" class="ne ma iq mz b gy nf ng l nh ni">match today {<br/>        Days::Friday =&gt; println!("thank god its Friday!"),<br/>        _ =&gt; (),<br/>    }</span></pre><p id="de2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这仅仅是<em class="nz">忽略了</em>其他的可能性。在这种情况下，你也可以使用<code class="fe mw mx my mz b">if let</code>来保持简洁。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d541" class="ne ma iq mz b gy nf ng l nh ni">let today = Days::Monday;<br/>    if let today = Days::Monday {<br/>        println!("its Monday already! :(");<br/>    }</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="539c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="511d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">不要忘记查看这些资源:</p><ul class=""><li id="dd80" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/#the-rust-programming-language" rel="noopener ugc nofollow" target="_blank">Rust编程语言</a>书</li><li id="72b0" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/std/" rel="noopener ugc nofollow" target="_blank">锈标准库</a>文档</li><li id="2e3b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/stable/rust-by-example/" rel="noopener ugc nofollow" target="_blank">铁锈示例</a></li></ul><p id="9053" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是对<code class="fe mw mx my mz b">enum</code>的快速浏览以及如何使用模式匹配的全部内容。敬请关注更多内容！</p></div></div>    
</body>
</html>