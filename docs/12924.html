<html>
<head>
<title>3 Things to Consider When You Define Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定义函数时要考虑的3件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-things-to-consider-when-you-define-functions-6a964dbe388f?source=collection_archive---------21-----------------------#2022-07-11">https://betterprogramming.pub/3-things-to-consider-when-you-define-functions-6a964dbe388f?source=collection_archive---------21-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fca4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升您的Python技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0b832c40e702b8861e8ca7073e3f316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FegEKvlFJbVtJIap"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/es/@asyrafunk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Asyrafunk RKTW </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何应用的核心都是数据。如果你正在建立一个社交网站，用户和他们的友谊就是数据。如果你在开发一个游戏，图形和用户操作就是数据。如果你正在建立一个网上商店，产品和客户信息就是数据。这些只是我们日常生活中的几个例子。</p><p id="7e5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些数据是以原始形式呈现的，那么它们就没有多大意义。您必须定义特定的操作来处理数据，然后才能显示这些数据。这些特定的操作通常采用函数的形式，即接受输入、应用操作并生成输出的代码块。我认为函数是任何编程项目的潜在驱动力。</p><p id="60db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想总结三件事，作为一名Python程序员，在编写函数时可以考虑。</p><p id="e863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在定义函数时，我不会包括一些常见的最佳实践，比如合理的名称、专用目的(不是混合关注点)和正确的文档字符串。反而我的角度更多的是从技术角度出发。</p><p id="2b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p><h1 id="158d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用默认参数</h1><p id="e7f4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个函数不需要任何输入是最理想的。当用户调用这个函数时，他们不需要担心设置任何参数。然而，在大多数情况下，函数确实需要特定的输入才能执行预期的操作。</p><p id="ac94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个函数接受多个参数时，一种使函数调用更容易的技术是设置默认参数。这个特性在标准Python库中被广泛使用。比如下面是内置<code class="fe ms mt mu mv b">sorted</code>函数的调用签名。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4763" class="na lw it mv b gy nb nc l nd ne">sorted<!-- -->(<em class="nf">iterable</em>, <em class="nf">/</em>, <em class="nf">*</em>, <em class="nf">key=None</em>, <em class="nf">reverse=False</em>)</span></pre><p id="d463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个函数中，<code class="fe ms mt mu mv b">key</code>和<code class="fe ms mt mu mv b">reverse</code>参数有各自的默认值——<code class="fe ms mt mu mv b">key</code>参数指定如何进行排序(<code class="fe ms mt mu mv b">None</code>表示使用默认的字典顺序或数字顺序),<code class="fe ms mt mu mv b">reverse</code>参数指定顺序是否是降序。大多数情况下，当我们调用这个函数时，不需要担心设置<code class="fe ms mt mu mv b">key</code>和<code class="fe ms mt mu mv b">reverse</code>。但是，当我们想要定义一个自定义排序操作时，可以设置<code class="fe ms mt mu mv b">key</code>参数，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1cf0" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; objects = [-1, -5, 3]<br/>&gt;&gt;&gt; sorted(objects, key=abs)<br/>[-1, 3, -5]</span></pre><p id="4fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以考虑在定义自己的函数时设置默认参数。原则是，如果任何参数在大多数函数调用中没有变化，您应该用默认值设置这些参数。请注意，这些参数被放在没有默认值的其他参数之后，正如您在<code class="fe ms mt mu mv b">sorted</code>函数中看到的那样。</p><h1 id="c24a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用类型提示</h1><p id="eab7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们使用一个新函数时，我们很可能不确定该函数所采用的参数的确切形式。考虑以下可以定义的功能头:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="662a" class="na lw it mv b gy nb nc l nd ne">def greeting(person, message):<br/>    pass</span></pre><p id="0fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你遇到这个函数时，如果你不看它的实现细节，你就不知道应该发送什么样的参数。你可以这样调用这个函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9318" class="na lw it mv b gy nb nc l nd ne">greeting("John Smith", "Hi")</span></pre><p id="d59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也有可能有一个类<code class="fe ms mt mu mv b">Person</code>，你应该用一个<code class="fe ms mt mu mv b">Person</code>类的实例来调用这个函数，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f634" class="na lw it mv b gy nb nc l nd ne">class Person:<br/>    def __init__(self, first_name, last_name):<br/>        self.first_name = first_name<br/>        self.last_name = last_name</span><span id="712a" class="na lw it mv b gy ng nc l nd ne"><br/>person = Person("John Smith")<br/>greeting(person, "Hi")</span></pre><p id="f8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，有时一个功能会让用户感到困惑。消除这种模糊性的一种方法是对函数应用类型提示。例如，如果这个函数接受一个字符串作为<code class="fe ms mt mu mv b">person</code>参数，您可以这样做:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6591" class="na lw it mv b gy nb nc l nd ne">def greeting(person: str, message: str):<br/>    pass</span></pre><p id="4b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个函数取了一个<code class="fe ms mt mu mv b">Person</code>的实例，你也可以这样做:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="562c" class="na lw it mv b gy nb nc l nd ne">class Person:<br/>    pass</span><span id="88f7" class="na lw it mv b gy ng nc l nd ne">def greeting(person: Person, message: str):<br/>    pass</span></pre><p id="2a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在函数定义中设置类型提示，用户可以享受到的一个好处是当他们在IDE中调用您的函数时得到有意义的提示，比如PyCharm。下面提供了一个屏幕截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/152973da5f6d75c348d1f0bf9ea111a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBVO-L-KrU8OGu-BVx7TwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PyCharm中有意义的提示(作者截图)</p></figure><p id="f027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyCharm或VSC的任何代码分析插件使用类型提示来分析你的代码以提供提示。</p><p id="e798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要知道的事情是，如果你的函数返回值，你可以提供返回值的类型提示，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b000" class="na lw it mv b gy nb nc l nd ne">def greeting(person: Person, message: str) -&gt; str:<br/>    return f"{message}, {person.first_name}!"</span></pre><p id="c5e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的类型提示的格式是<code class="fe ms mt mu mv b">-&gt; type</code>，跟在函数头的括号后面。</p><h1 id="0ca7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用*args和**kwargs</h1><p id="a750" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的函数通常包含一定数量的参数。然而，有时您可能不知道用户会发送什么样的参数。以内置的<code class="fe ms mt mu mv b">print</code>函数为例，它可以接受任意数量的对象。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5b62" class="na lw it mv b gy nb nc l nd ne">message0 = "Hello"<br/>message1 = "World"<br/>ending_symbol = "!"<br/><br/>print(message0, message1, ending_symbol)</span><span id="b395" class="na lw it mv b gy ng nc l nd ne"># output: Hello World !</span></pre><p id="50db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们可以用<code class="fe ms mt mu mv b">print</code>函数来实现呢？让我们来看看呼叫签名:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ecaf" class="na lw it mv b gy nb nc l nd ne">print<!-- -->(<em class="nf">*objects</em>, <em class="nf">sep=' '</em>, <em class="nf">end='\n'</em>, <em class="nf">file=sys.stdout</em>, <em class="nf">flush=False</em>)</span></pre><p id="4bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之所以可以打印任意数量的对象，都在于<code class="fe ms mt mu mv b">*objects</code>参数。请注意，参数名带有星号前缀，这意味着我们可以向函数发送可变数量的位置变量。如您所见，它提高了<code class="fe ms mt mu mv b">print</code>功能的灵活性。我们可以在自己的函数中使用这个特性。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e351" class="na lw it mv b gy nb nc l nd ne">def stringify(*objects) -&gt; list[str]:<br/>    print(type(objects), objects)<br/>    return [str(object) for object in objects]</span></pre><p id="69d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在stringify函数中，我们允许用户发送数量可变的参数，并将每个参数转换为一个<code class="fe ms mt mu mv b">str</code>对象。需要注意的一点是，当用户用多个位置参数调用这个函数时，这些参数形成了一个<code class="fe ms mt mu mv b">tuple</code>对象。</p><p id="631f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，<code class="fe ms mt mu mv b">objects</code>是一个<code class="fe ms mt mu mv b">tuple</code>对象，因此我们可以在一个<code class="fe ms mt mu mv b">for</code>循环中使用它，并且我们可以通过使用几个参数调用这个函数来验证它:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="846d" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; stringify(1, (2, 4), False, {2, 3, 5, 7})<br/>&lt;class 'tuple'&gt; (1, (2, 4), False, {2, 3, 5, 7})<br/>['1', '(2, 4)', 'False', '{2, 3, 5, 7}']</span></pre><p id="7014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以类似的方式，我们可以定义可变数量的关键字参数。这种技术通常缩写为<code class="fe ms mt mu mv b">**kwargs</code>——在参数名前使用两个星号。当你在函数中看到这一点时，这意味着它可以接受任意数量的关键字参数。</p><p id="b3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。我们想为一个学生的课程生成一张成绩单，我们可能会想到如下函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="280e" class="na lw it mv b gy nb nc l nd ne">def create_report(name, **grades):<br/>    print(f"Grade Report for {name}")    <br/>    for course, grade in grades.items():<br/>        print(f"{course}: {grade}")</span></pre><p id="5d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为学生可能会选择不同的课程，使用<code class="fe ms mt mu mv b">**grades</code>提供了这样的灵活性。您可能也注意到了，<code class="fe ms mt mu mv b">grades</code>参数是一个<code class="fe ms mt mu mv b">dict</code>对象，您可以使用items来访问它的键值对，并在<code class="fe ms mt mu mv b">for</code>循环中使用它们。一些来电显示如下:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6f2a" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; create_report("John", math=95, chemistry=100, physics=98)<br/># output the following lines:<br/>Grade Report for John<br/>math: 95<br/>chemistry: 100<br/>physics: 98</span><span id="a0cf" class="na lw it mv b gy ng nc l nd ne">&gt;&gt;&gt; create_report("Zoe", biology=93, geography=97)<br/># output the following lines:<br/>Grade Report for Zoe<br/>biology: 93<br/>geography: 97</span></pre><p id="86b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您调用这个函数时，您将参数作为关键字参数列出，Python将这些参数打包成一个<code class="fe ms mt mu mv b">dict</code>对象，在函数体中使用。</p><p id="9ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe ms mt mu mv b">*args</code>和<code class="fe ms mt mu mv b">**kwargs</code>为您的函数定义提供了灵活性，但是您必须证明您的用法，比如这里讨论的使用场景。也就是说，不要滥用这个特性，因为命名的、明确的参数是最直接的。</p><h1 id="083b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">讨论</h1><p id="a17c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们回顾了在定义自定义函数时可以考虑的三种技术。当你在适当的场景中使用它们时，你会使你的函数更容易使用。</p><p id="b92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。</p></div></div>    
</body>
</html>