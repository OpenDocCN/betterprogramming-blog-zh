<html>
<head>
<title>A Layman’s Introduction to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归的外行介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-laymans-introduction-to-recursion-9d5c6727f83a?source=collection_archive---------14-----------------------#2019-08-20">https://betterprogramming.pub/a-laymans-introduction-to-recursion-9d5c6727f83a?source=collection_archive---------14-----------------------#2019-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5a99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">“人生只能倒着理解；但它必须向前生活。”</em> —索伦·克尔凯郭尔</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c2de2633ed79b8e122e0e63c5135c94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3R3QRHoEtevVEQrR-4sKQ.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@jantined?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae lf" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="76f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ruby最灵活的方面之一是它不可思议的可枚举方法套件，它以其轻松剖析数据的强大能力打开了许多编程之门。</p><p id="45ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，用迭代可以解决如此多的问题，以至于我们经常不去关注它稍微有点吓人的表亲:递归。</p><p id="0531" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归到底是什么意思？根据韦氏词典，它的定义是:</p><blockquote class="lg"><p id="06d7" class="lh li it bd lj lk ll lm ln lo lp kn dk translated">"根据包含有限步数的规则或公式，通过对一个或多个在前元素的运算来确定一系列元素(如数字或函数)。"</p></blockquote><p id="1553" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">我不知道你怎么想，但对我来说这有点过了。从编码的角度来说，这个定义是“调用自身的方法”的一种复杂表达方式。</p><p id="7041" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像一个俄罗斯洋娃娃有许多层，可以重复打开以揭示其中几乎相同但稍微更具体的“问题”一样，递归编程依靠一套相对简单的原则来解决问题，否则这些问题可能具有挑战性，方法是将问题分成尽可能小的部分，然后使用这些部分作为我们最终答案的构建块。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lv"><img src="../Images/a6f9dcd1152c0c56b4c99d4783c23fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpCAqm8HdKuBhyRs9NYCOg.png"/></div></div></figure><p id="cfe5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归方法分为两个截然不同且极其重要的方面。</p><p id="c08d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是<em class="ko">递归调用</em>，它(您猜对了)是负责方法调用本身的代码行。递归方法必须返回一个值，代码的任何层都可以将它作为参数处理，因为它必须处理更深层的返回值，并向它上面的层提供返回值。</p><p id="2744" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归调用的第二个非常重要的方面是<em class="ko">基础用例</em>，<strong class="js iu"> </strong>，这是一个允许无限调用链自行停止的条件。如果一个方法不断地调用自己(因此重新开始这个方法，最终重复这个过程)，它应该如何停止自己呢？</p><p id="2997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不能让相同的代码一次又一次地重复，我们必须创建一个条件，将问题的最小可能部分隔离出来，然后可以用来解决一个稍微大一点的问题，可以用来做同样的事情，等等。</p><p id="cb32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，这采用了<code class="fe lw lx ly lz b">if</code>语句的形式(或其表亲条件句，除非和<code class="fe lw lx ly lz b">case</code> / <code class="fe lw lx ly lz b">when</code>)，但无论如何，至少有两种可能的结果:一种导致额外的调用，另一种说“够了”。</p><p id="a2fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们可以看到有无基本用例的方法之间的理论差异:当没有基本用例执行时，我们可能会一直这样下去。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ma"><img src="../Images/64c5003aa57267d9fc2690b843e91c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIHGidZ_C3iAnrtJq9IsOA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">一种具有基本情况的递归方法</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ma"><img src="../Images/b4405e24a55cb3de5ef7e6cfb3196e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSsF3WDPsDRxXizyZWLHrA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">一种没有基本用例的递归方法</p></figure><p id="4432" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本情况最重要的方面是问题<em class="ko">不能再简单了</em>，因此答案几乎是微不足道的。这意味着潜在的返回值通常是非常简单的数据类型，比如基本的整数、字符串或数组。</p><p id="7be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在大范围内讨论时，递归是可怕的，但是如果你把它分解成上述概念，它可能看起来奇怪地熟悉。</p><p id="e358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我告诉你一个秘密:它应该是！这是因为当你使用一个可枚举的数组进行迭代时，你利用了某种形式的递归调用和基本情况！</p><p id="0558" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些方面，你甚至不知道<em class="ko">已经在实现递归编程概念</em>。</p><p id="9ac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一些简单的代码。问问你自己:“为什么这个会无限循环？”</p><pre class="kq kr ks kt gt mb lz mc md aw me bi"><span id="8608" class="mf mg it lz b gy mh mi l mj mk">total = 0<br/>i = 5</span><span id="633d" class="mf mg it lz b gy ml mi l mj mk">while x &gt; 2<br/>    total += 1<br/>    i += 1<br/>end</span></pre><p id="8661" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你猜对了:这是因为<code class="fe lw lx ly lz b">while</code>循环的条件永远不会被满足，所以永远不会有循环无法继续的场景(如果你愿意，可以称之为<em class="ko">基础案例</em>)。</p><p id="01ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当<code class="fe lw lx ly lz b">while</code>循环的新迭代被触发时，块中的所有代码都将顺序触发:就像已经被<em class="ko">递归调用过的</em>方法将重复一样。</p><p id="78d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们并排比较一下用迭代和递归解决问题的过程。</p><p id="edcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我们试图找到一个数组中整数的和(是的，我们假装这个方法还没有内置到Ruby类中)。让我们从迭代解开始:</p><pre class="kq kr ks kt gt mb lz mc md aw me bi"><span id="2234" class="mf mg it lz b gy mh mi l mj mk"><em class="ko">array = [1, 2, 3, 4]</em></span><span id="14fc" class="mf mg it lz b gy ml mi l mj mk">def iterative_sum(array)<br/>    total = 0<br/>    i = 0</span><span id="1be0" class="mf mg it lz b gy ml mi l mj mk">while i &lt; array.length<br/>        total += array[i]<br/>        i +=1<br/>    end<br/>    <br/>    total<br/>end</span></pre><p id="0dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在对于递归方法:</p><pre class="kq kr ks kt gt mb lz mc md aw me bi"><span id="2b4c" class="mf mg it lz b gy mh mi l mj mk"><em class="ko">array = [1, 2, 3, 4]</em></span><span id="0195" class="mf mg it lz b gy ml mi l mj mk">def recursive_sum(array)<br/>    <br/>    #base case<br/>    return 0 if array.empty?</span><span id="5ba4" class="mf mg it lz b gy ml mi l mj mk">    #recursive call<br/>    array[0] + recursive_sum(array[1..-1])<br/>end</span></pre><p id="c90b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些解决方案具有相同的总体结构:</p><ol class=""><li id="089b" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">隔离数组中每个元素的方法。</li><li id="555a" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">对每一个孤立的元素进行操作</li><li id="279d" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">记录总金额。</li><li id="0683" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">在给定元素处或之后停止循环。</li></ol><p id="5e4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些方法中的每一种都找到了<em class="ko">隔离数组</em>中每个元素的方法。</p><p id="2f21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于可枚举的，它是<code class="fe lw lx ly lz b">array[i]</code>，其中<code class="fe lw lx ly lz b">i</code>只是在<code class="fe lw lx ly lz b">while</code>循环中的当前迭代。</p><p id="c55e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于递归的例子，我们使用<code class="fe lw lx ly lz b">array[0]</code>,如果你仔细想想，它反映了这个方法被调用了多少次，因为我们每次都是从数组的一个稳定的较小部分中获取第一项。</p><pre class="kq kr ks kt gt mb lz mc md aw me bi"><span id="77b1" class="mf mg it lz b gy mh mi l mj mk">Iteration 1: [1, 2, 3, 4]      # array[0] = 1</span><span id="3eb4" class="mf mg it lz b gy ml mi l mj mk">Iteration 2: [2, 3, 4]         # array[0] = 2</span><span id="929e" class="mf mg it lz b gy ml mi l mj mk">Iteration 3: [3, 4]            # array[0] = 3</span><span id="4ca9" class="mf mg it lz b gy ml mi l mj mk">Iteration 4: [4]               # array[0] = 4</span></pre><p id="1159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些实现中的每一个然后<em class="ko">在那些隔离的元素中的每一个上操作。</em>同样，制造工艺有所不同，但核心概念保持不变。</p><p id="d484" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于迭代示例，行<code class="fe lw lx ly lz b">total += array[i]</code>完成了所有工作。我们简单地将预先确定的总变量增加给定的量，看看这个，我们有一个累积和！</p><pre class="kq kr ks kt gt mb lz mc md aw me bi"><span id="b5dc" class="mf mg it lz b gy mh mi l mj mk">array[0] = 1</span></pre><p id="8031" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果我们知道在这个例子中递归调用的第一次迭代中的<code class="fe lw lx ly lz b">array[0]</code>将是<code class="fe lw lx ly lz b">1</code>，那么我们可以重新解释递归调用听起来像这样:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/976b33e11dcd439acd8e64d9f75cdc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-D6l_wrYdRta4ArtjhtiQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">重新想象递归调用</p></figure><p id="52e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意到相似之处了吗？如果我们使用相同的逻辑重构迭代示例，我们可以这样理解:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nb"><img src="../Images/22512432ad0e275caafa8c567c44863b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEtci1KaZXDBXRAdhMPrKw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">重新想象的迭代增量</p></figure><p id="ba26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们代码的两个例子都设法<em class="ko">跟踪总数。</em></p><p id="9c2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种方法之间最后一个显著的相似之处是<em class="ko">都在给定元素处或之后停止循环。这以两种不同但明确的方式表达。</em></p><p id="5495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们基于可枚举的实现中(见上文)，我们使用条件行<code class="fe lw lx ly lz b">while i &lt; array.length</code>和递增动作<code class="fe lw lx ly lz b">i += 1</code>来精确命中数组的每个索引一次:不多也不少。</p><p id="b5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们仔细观察递归调用，我们可以看到，我们实际上是通过使用参数<code class="fe lw lx ly lz b">(array[1..-1])</code>对数组的<em class="ko">余数</em>(所有非<code class="fe lw lx ly lz b">0</code>索引)调用函数来对增量进行硬编码。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nc"><img src="../Images/a778779510791ff8fc99b6566a251369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC-_qPUUdm_3ycKSd1dnZg.png"/></div></div></figure><p id="fffd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实是递归和迭代非常相似，尽管它们看起来是截然相反的实现。</p><p id="d582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我告诉你第二个秘密:<em class="ko">任何可以用迭代解决的问题也可以用递归来解决，反之亦然。</em>轰。强大。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="e332" class="nk mg it bd nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of og bi translated">用史蒂芬·霍金的话说</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/47a610b43b426d93cd722fcdc3cd2137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHh7-5X-LmgELwNfZ9l_Mw.jpeg"/></div></div></figure><p id="d483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且，如果你有兴趣了解更多这方面的知识，一定要在谷歌搜索中输入“递归”。(有好玩的小复活节彩蛋等着你。)</p></div></div>    
</body>
</html>