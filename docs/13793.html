<html>
<head>
<title>Java Is Still Popular for This One Reason</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">因为这个原因，Java仍然很受欢迎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-is-still-popular-for-this-one-reason-d9c4153802fe?source=collection_archive---------3-----------------------#2022-09-28">https://betterprogramming.pub/java-is-still-popular-for-this-one-reason-d9c4153802fe?source=collection_archive---------3-----------------------#2022-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1300" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java的过去、现在和未来</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/78ee03f7a9c942795f839c48c49abeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygPYa7MD7eZvJ5dA-SFVQg.png"/></div></div></figure><p id="5b2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是发表这篇文章的好时机——正好在Java 19发布的时候。是的，又一篇《我的语言更好》的文章。不，我不想写。但是有时候人们的不良预测会让我好过一些。在这种情况下，文章开始是评论，我最终决定把它变成一篇文章。这个帖子加强了这一点，这个帖子主要抱怨Quarkus(如果我可以补充的话，有点不公平)。</p><p id="dc4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一篇文章大多是废话和过时的clickbait。我会在下面的权利要求中总结给你:</p><ul class=""><li id="c6a5" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">getter/setter</li><li id="8220" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">缺少专门针对集合上的<code class="fe mc md me mf b">[]</code>和任何东西上的<code class="fe mc md me mf b">+</code>的运算符重载</li><li id="b704" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">检查异常</li><li id="8c2c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">依赖性管理</li></ul><p id="763e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二篇文章抱怨更多的是关于Jakarta EE和JVM中的一般程序员美学。特别是在验证和类似声明中使用注释。这是一篇消息灵通得多的文章，但有几个缺陷，我将在接近尾声时解决。</p><h1 id="e858" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Getters和Setters</h1><p id="7f93" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">现代Java不需要Getters和setters。我们从Java 14开始就有记录了，尽管有些人声称相反，但Lombok仍然很好。我们唯一需要getter/setter的地方是在非常特殊的设置中(例如JPA ), Lombok完美地解决了这个问题。</p><p id="1ada" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章长篇大论地讨论了Java缺乏语法糖特性的问题。这是故意的。如果您对最新的语法细微差别感兴趣，可以看看Kotlin。Java讲究的是“慢而稳”。这是一件好事，也是Java长寿的主要原因。</p><h1 id="1182" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语法糖和运算符重载</h1><p id="1a15" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">现代Java包括<code class="fe mc md me mf b">switch</code>、<code class="fe mc md me mf b">var</code>、多行字符串等模式。一些即将推出的功能包括字符串模板。字符串模板支持需要一段时间，因为Java希望“做对”在API层面上有一些支持(已经有一段时间了)。这不是表演。字符串模板的目标是创建一个激进的可重写语法，这样<a class="ae ln" href="https://openjdk.org/jeps/8273943" rel="noopener ugc nofollow" target="_blank">将允许</a>这样的东西:</p><pre class="kg kh ki kj gt nd mf ne nf aw ng bi"><span id="65d7" class="nh mh iq mf b gy ni nj l nk nl">ResultSet rs = DB."SELECT * FROM Person p WHERE p.last_name = \{name}";</span></pre><p id="38e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更新:自本文发表以来，开发人员错误地认为上面的代码是一个SQL注入漏洞。它不是。这看起来像字符串替换，但它是使用该语法生成参数化SQL调用的代码。</p><p id="fe98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe mc md me mf b">name</code>是一个变量，编译器将动态检查并从作用域中获取它！</p><p id="d621" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以由开发人员自定义实现，不需要“内置”,因此您可以就地构建复杂的模板。</p><p id="bb8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，让我们谈谈我们今天拥有的Java，而不是六个月后即将到来的Java。使用<code class="fe mc md me mf b">append</code>已经十多年没有推荐给<code class="fe mc md me mf b">String</code>了。使用性能最好且更容易阅读的<code class="fe mc md me mf b">+</code>。关于收藏，<code class="fe mc md me mf b">get()</code>和<code class="fe mc md me mf b">[]</code>的区别就是字面上的四个字。这些角色很重要。</p><p id="598b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以很容易地忽略它。我们也能理解语义上的差异。Java数组非常快；在许多情况下，本地速度很快。收藏不能那么快，这点我们看得出来是很有价值的。</p><p id="8e68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">操作符不能过载是一个巨大的好处。如果我看到<code class="fe mc md me mf b">a + b</code>，我知道这要么是一个字符串，要么是一个数字，而不是一些隐藏的方法。这是Java最大的优势之一，也是它流行了近30年而其他语言被抛在一边的原因之一。Java的语法是为大规模阅读而设计的。</p><p id="a3c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你有一个有100万行代码甚至100k行代码的项目时，问题就转移了。此时，当您调试问题时，很难发现程序员X在模块Y中错误地重写了一个运算符。在这一点上，语法应该是简单的，你最初节省的任何小成本都将获得10倍的利息。随着代码变得越来越复杂和老化，简单翻转的定义也发生了变化。再加上工具在大规模解析严格简单的代码的能力，这将成为一个更大的优势。</p><h1 id="c8e2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">检查异常</h1><p id="aed5" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">选中的异常是可选的。但是它们是Java中最好的特性之一。这么多代码意外失败。当你把建造东西作为一种爱好时，这可能是好的。当你想构建一个专业的应用程序时，你需要处理每一个错误。检查异常有助于避免这种无意义的情况。人们讨厌检查异常是因为懒惰。Java让你防备自己。</p><p id="d565" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不应该出现我建立网络连接、数据库连接、打开文件等情况。，并且不需要处理潜在的错误。我可以踢它，但然后检查异常迫使我继续踢它在某个地方。这是一个惊人的功能。</p><h1 id="8fe5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">属国</h1><p id="afdf" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">我对梅文和格雷尔有很多问题。但是当你把它和几乎所有其他的依赖系统进行比较的时候，你会发现他们做得很好。他们有问题，但你不能把他们比作年轻的东西，比如相比之下几乎没有包装的货物。Maven central非常庞大，有27tb的jar和4960亿个请求。它运行良好，几乎没有停机时间。</p><p id="2728" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像NPM这样的其他工具完美地展示了maven的优势。如果maven中的依赖性是一个问题，那么NPM有100倍的问题并且没有监督。随着这些东西的增长，情况变得复杂了。尤其是市场上有多个版本的maven。然而，maven和gradle的优势之一是工具。在许多情况下，ide有助于解决问题并找到现成的修复方法。</p><h1 id="4ae9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Java中的文化问题</h1><p id="19a4" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">第二篇文章更有趣，在某种程度上，我同意。Java开发人员倾向于把每个问题都变成更复杂的问题。在某些情况下，这是必要的，Java是编程平台中800磅重的大猩猩，它的解决方案经常被过度设计。这往往比动力不足要好，但它也有代价。</p><h1 id="f047" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">为什么要对验证进行注释</h1><p id="5c8c" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">这篇文章确实提出了一个有趣的例子，对于不经意的观察者来说，这似乎是“正确的事情”，但却是有问题的。</p><pre class="kg kh ki kj gt nd mf ne nf aw ng bi"><span id="540b" class="nh mh iq mf b gy ni nj l nk nl">@NotNull @Email<br/>String noReplyEmailAddress</span></pre><p id="72ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作者声称这是不好的，应该实现自定义类型，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bee2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在Java中是完全可能的，因为上面的代码是有效的Java代码。但是它有几个问题，这就是为什么我们有bean验证。</p><ul class=""><li id="29c7" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">这是无法优化的——Bean验证可能会被框架移到验证链的上游。它甚至可以在客户端代码中无缝验证，因为它是一个声明式API。这里我们需要实际执行构造函数来执行验证。</li><li id="e46b" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">声明性注释可以沿着链向下移动，无缝地应用数据库约束，等等。</li><li id="0579" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">我们可以一次应用多个注释</li><li id="ac9c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">语法更简洁</li></ul><p id="28e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，注释可能会感觉奇怪，并且不强制输入。确实如此。但是它们提高了性能和功率。它们的用法背后有很多思考和常识。我理解作者的观点:我也不是国际奥委会的忠实粉丝，但在这个具体的例子中，他是不正确的。</p><h1 id="0acc" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">最后的想法</h1><p id="d98c" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">这篇文章花了太多时间进行辩护。该换挡了。Java已经存在了将近30年，并且仍然与Java 1.0兼容。太棒了，无与伦比！</p><p id="2fc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的保守方法的一个优点是，它可以进行惊人的“幕后”优化，而不会引起任何人的注意。Java 9完全无缝地取代了字符串在内存中的表示方式，并显著减少了RAM的使用。类似地，Loom将提高Java同步应用程序的吞吐量。Valhalla将进一步提高收集性能，统一对象/图元划分。Panama将最终使我们摆脱JNI，并使与本地代码集成的过程变得更加愉快。</p><p id="e703" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的一面是JVM是一个大帐篷。如果你不是Java迷，Kotlin或Scala可能适合你的口味。JVM的好处是普遍适用的，我在这里提到的大多数特性都将有益于我们整个联合生态系统。</p></div></div>    
</body>
</html>