<html>
<head>
<title>React Native: Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本土:引擎盖下</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-native-under-the-hood-281df5f548f?source=collection_archive---------0-----------------------#2021-07-07">https://betterprogramming.pub/react-native-under-the-hood-281df5f548f?source=collection_archive---------0-----------------------#2021-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ba8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解JavaScript代码如何在Android/iOS设备上运行，如何转换为本机代码，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85330c877c16b21f59f60de203b10fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DkDSVzb4fpxFjJQh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="379a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React Native是一个JavaScript库，允许我们创建可以在Android和iOS上运行的移动应用。正如他们推销的那样，“学一次，随处写。”在过去的两年里，它一直引领着市场，而且似乎没有放缓的趋势。不管我以前有多爱Flutter(现在仍然如此)，在某些时候，我不得不承认React Native非常酷，如果你知道如何使用它，你可以做一些非常好的事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a6138f765e3c1f61e710ac61919c05e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKvASx4iO-PrE8rmR-UmZA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.statista.com/statistics/869224/worldwide-software-developer-working-hours/" rel="noopener ugc nofollow" target="_blank"> statista </a></p></figure><p id="cbbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，让我们看看这个库是如何在Android和iOS设备上运行JavaScript的。</p><p id="9309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要报道什么？</p><ol class=""><li id="55d4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">React原生应用的UI是如何呈现的。</li><li id="bbd6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">JavaScript代码是如何捆绑并转化为Android/iOS应用程序的。</li><li id="a972" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">Android/iOS设备如何理解JavaScript。</li><li id="38e6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">本机线程如何与JavaScript线程通信。</li><li id="68eb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">React原生应用程序的简要性能分析。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7567" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">1.呈现用户界面</h1><p id="7f5a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，让我们弄清楚两件事:</p><ul class=""><li id="e6e0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu no mc md me bi translated">是的，React原生应用将使用原生视图进行渲染。</li><li id="6b48" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu no mc md me bi translated">不，JavaScript代码没有被编译成平台的本地语言。</li></ul><p id="077c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？这很清楚:您的手机如何能够将JavaScript这样的松散类型语言翻译成Java或Objective C这样的强类型语言？</p><p id="4148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将使用组件并遵循React特有的单向原则在React Native中编写UI。你会有一个组件树。这些组件之间的通信将通过属性和回调来实现。如果父组件需要某样东西，您将把回调传递给子组件。以同样的方式，如果孩子需要从他的父母那里得到什么，你可以把财产传给孩子。</p><p id="f72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要您遵循这个原则，并且不需要将React创建组件的本地方式与本地编写的视图混淆，您就不会有太多的开销来设计您漂亮的UI。然而，如果你真的必须为类似于<code class="fe np nq nr ns b">MapView</code>的东西写一些本机代码，库也将<a class="ae ky" href="https://reactnative.dev/docs/communication-ios" rel="noopener ugc nofollow" target="_blank">帮助你</a>从本机到RN的通信，反之亦然。</p><p id="3c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利。但是操作系统如何理解JavaScript代码呢？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="368b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">2.捆绑过程</h1><p id="fffd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">将使用特定于该平台的编程语言来开发本地移动应用。当使用React Native进行开发时，您几乎可以不用编写任何客观的C/Java代码——除非您需要做一些库没有涵盖的事情，例如集成一个只为Android和iOS提供SDK的支付提供商。</p><p id="14ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，任何React本地项目都包含一个<code class="fe np nq nr ns b">ios</code>目录和一个<code class="fe np nq nr ns b">android</code>目录。这些目录充当每个平台的入口点——它们基本上是本地引导反应。它们包含特定于每个平台的代码，这里是每个平台的JS代码的桥梁。</p><p id="9a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了启动你的应用程序，你通常会运行<code class="fe np nq nr ns b">yarn android</code>或<code class="fe np nq nr ns b">yarn ios</code>，然后你会等待，直到应用程序神奇地在你想要的设备上打开。但是当你等待的时候会发生什么呢？</p><p id="64fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你输入其中一个命令(分别是<code class="fe np nq nr ns b">react-native run-android</code>和<code class="fe np nq nr ns b">react native run-ios</code>，你就启动了打包程序。一个这样的包装商是<a class="ae ky" href="https://facebook.github.io/metro/" rel="noopener ugc nofollow" target="_blank"> Metro </a>。打包程序将你所有的JS代码放到一个文件中:<code class="fe np nq nr ns b">main.bundle.js</code>。当你的应用程序最终在你的手机上打开时，手机会在它熟悉的地方寻找:或者是<code class="fe np nq nr ns b">android</code>或者是<code class="fe np nq nr ns b">ios</code>目录。这就是我上面提到的本机入口点。这个本地入口点将在一个线程中启动JavaScript虚拟机。包含在<code class="fe np nq nr ns b">main.bundle.js</code>中的捆绑代码将在这个线程上运行。</p><p id="f4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在这个JavaScript VM线程中运行的代码将使用React本机桥与本机线程通信。</p><p id="dcb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在跳到RN桥，然后分析RN应用程序的性能之前，让我们了解一下您的手机是如何运行JavaScript代码的。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4314" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">3.JavaScriptCore</h1><p id="95ce" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">例如，JavaScriptCore是一个允许JavaScript代码在移动设备上运行的框架。在iOS设备上，这个框架是由OS直接提供的。Android设备没有该框架，因此React Native将其与应用程序本身捆绑在一起。这只是增加了一点点应用程序的大小，但最终几乎没有关系。</p><p id="7345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点我想指出，可能会节省你一些调试时间。当应用程序在设备上运行时，JavaScriptCore用于运行JS代码。然而，如果你选择调试你的应用程序，JS代码将在Chrome内部运行。Chrome使用V8引擎，并使用WebSockets与本机代码进行通信，因此您将能够看到重要信息，如正确格式化的日志和正在发出的网络请求。请记住，V8引擎和JavaScriptCore之间存在差异——它们是不同的环境，您可能会遇到只有在附加调试器时才会出现的错误，而当您的应用程序在您的设备上正常运行时则不会出现！</p><p id="404f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非万不得已，否则我会避免使用调试器。我见过当调试器连接时应用程序行为失常。其中一种情况是当我使用Wix的<a class="ae ky" href="https://github.com/wix/react-native-calendars" rel="noopener ugc nofollow" target="_blank"> react-native-calendar </a>库创建日历时。这种方法根本不起作用。我不明白我做错了什么！我调查并重读了图书馆的文件。应该是有效的。然而，我连接了调试器，在调试代码时，该方法不起作用。</p><p id="3aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当您的应用程序在调试时以一种奇怪的方式出错时，只需花一点时间，看看在没有附加调试器的情况下，行为是否相似。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c697" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">4.React本机桥</h1><p id="7de5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">RN桥是用Java/C++编写的，它允许应用程序的主线程和JavaScript线程之间的通信。它使用自定义的消息传递协议来允许这种通信发生。</p><p id="9553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript线程将决定什么必须呈现在屏幕上。它会对主线程说，“嘿，我需要你渲染一个按钮和一个文本。谢谢。”它会用桥来表示这一点。该消息将作为序列化的JSON发送。但是除了需要在屏幕上呈现的内容之外，消息还必须说明它将在哪里呈现。这就是影子线发挥作用的地方。shadow线程与JavaScript线程一起启动，它帮助计算视图的位置。结果在前面提到的消息中传递，通过桥发送到主线程。</p><p id="79f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户在UI上的任何操作都将发生在主线程上。点击按钮、切换开关——任何动作都必须序列化，并通过桥发送到JavaScript线程。应用程序的所有逻辑都在这里发生。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f8f8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">5.性能如何受到影响</h1><p id="0a1d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们回顾一下到目前为止我们已经讲过的内容。用户点击一个按钮。这个动作被主线程理解，并作为消息传递给JavaScript线程。这里处理了一些逻辑，然后UI必须相应地改变。影子线程决定这些变化发生在哪里，然后更新作为消息发送回本地线程。由于用户不会太快地点击屏幕，我们在正常的使用场景中一般不会有任何性能问题——桥处理通信相当快。</p><p id="7ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React Native的酷之处(与Cordova等其他平台相比)在于它不在<code class="fe np nq nr ns b">WebView</code>中运行代码。它使用本地视图。这一优势意味着我们将能够开发出流畅而快速的应用程序，能够以60 FPS的速度运行。如果你修改了一个在树中很高的组件的状态(并且你没有花费太多的时间来防止无用的重新渲染)，那么整个组件树将被重新渲染。在大多数情况下，用户看不到这一点。然而，如果这些后代计算量很大，那么你会注意到你的应用程序有一点口吃。关于React原生应用的性能，我还有很多要说的，所以我们将在另一篇文章中详细讨论。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="da66" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="5e4b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们无法客观地决定哪种移动开发方法是最好的——每个框架和每个库都有自己的优点和缺点。我们必须根据当前需求、预算、团队可用性和许多其他因素来选择技术。然而，总的来说，React Native将以一种高性能的方式满足大部分需求。</p><p id="c49e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您现在对React原生应用程序中发生的事情更加熟悉，从捆绑过程开始，直到应用程序在您的移动设备上运行。我真的很好奇React原生生态系统未来的改进。我们会有一段美好的旅程！</p><p id="c6c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你的阅读！你有什么想法？接下来你想读什么话题？</p><h2 id="c448" class="nt ms it bd mt nu nv dn mx nw nx dp nb li ny nz nd lm oa ob nf lq oc od nh oe bi translated"><strong class="ak">消息来源</strong></h2><div class="of og gp gr oh oi"><a href="https://www.reactnative.guide/3-react-native-internals/3.1-react-native-internals.html" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">React使原生变得容易</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">Edit React Native是一个允许开发者使用Javascript构建本地应用的框架。等等！科尔多瓦已经…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.reactnative.guide</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://dev.to/wjimmycook/how-the-react-native-bridge-works-and-how-it-will-change-in-the-near-future-4ekc" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">React本机桥如何工作以及它在不久的将来将如何变化</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">React原生应用由两部分组成，JavaScript端和原生端。原生面可能是…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">开发到</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://reactnative.dev/docs/optimizing-flatlist-configuration" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">优化平面列表配置反应本机</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">virtualized List:flat List背后的组件(React Native对虚拟列表概念的实现。)内存…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">反应性发展</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>