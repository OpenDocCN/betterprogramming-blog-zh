<html>
<head>
<title>Why Token-based Pagination Performs Better Than Offset Based?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么基于标记的分页比基于偏移量的分页性能更好？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-token-based-pagination-performs-better-than-offset-based-465e1139bb33?source=collection_archive---------1-----------------------#2022-09-07">https://betterprogramming.pub/why-token-based-pagination-performs-better-than-offset-based-465e1139bb33?source=collection_archive---------1-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d45d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">几乎快了1.5倍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ac8f53727fb3ec457892b1e48d980cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xNZHrbeCeI2rTPWF0vau3A.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者授权。来自Canva</p></figure><p id="a104" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">几乎所有现代数字产品都必须包含某种分页API。该API的主要作用是从一个大表中逐块检索数据，这样您的前端应用程序就不需要进行具有巨大负载的API调用。较小的有效负载导致较少的延迟。</p><h1 id="7a83" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">基于偏移量的分页</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/f9d1b04e70728c52657e83090ab1f386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjqTIRK-a8tzMbeayS0P5w.png"/></div></div></figure><p id="f4aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开发分页API的一种常见方法是基于偏移量的。这里，前端要求<em class="mk">产品</em>表的<em class="mk">第100th】行后的<em class="mk"> 10行</em>。当表很小时，这是无害的。然而，延迟随着<em class="mk">偏移值的增加而增加。</em></em></p><p id="bb31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">为什么？</strong>因为数据库(不是所有种类的数据库)实际上为这个查询准备了<code class="fe ml mm mn mo b">offset+limit</code>个行数。因此，当偏移值变大时，数据库必须经历<code class="fe ml mm mn mo b">offset+limit</code>行。</p><p id="5103" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们做一个快速实验。我在PostgreSQL数据库中准备了一个名为<em class="mk"> products </em>的表，表中有<code class="fe ml mm mn mo b">110001</code>行。它有三列；即<code class="fe ml mm mn mo b">id</code>、<code class="fe ml mm mn mo b">name</code>和<code class="fe ml mm mn mo b">created_at</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3c2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们运行这个查询，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6875" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据库响应:</p><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="5be0" class="mv ls iq mo b gy mw mx l my mz">Limit  (cost=1.74..1.91 rows=10 width=27) (actual time=0.552..0.554 rows=10 loops=1)<br/>  -&gt;  Seq Scan on products  (cost=0.00..1909.01 rows=110001 width=27) (actual time=0.541..0.548 rows=110 loops=1)<br/>Planning Time: 1.231 ms<br/>Execution Time: 0.580 ms</span></pre><p id="0bdc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们可以看到数据库已经处理了<em class="mk"> 110行</em>，然后返回了<em class="mk"> 10行</em>。现在，让我们通过将偏移数增加到<em class="mk"> 90000 </em>来抑制这种情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="1f38" class="mv ls iq mo b gy mw mx l my mz">Limit  (cost=1561.90..1562.08 rows=10 width=27) (actual time=10.275..10.277 rows=10 loops=1)<br/>  -&gt;  Seq Scan on products  (cost=0.00..1909.01 rows=110001 width=27) (actual time=0.425..6.666 rows=90010 loops=1)<br/>Planning Time: 1.070 ms<br/>Execution Time: 10.302 ms</span></pre><p id="26bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，你可以看到它已经读取了<em class="mk"> 90010行</em>，因为只返回了<em class="mk"> 10行</em>！执行时间也占用了大量的<code class="fe ml mm mn mo b">10.302ms</code>。</p><h1 id="e7d9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">基于令牌的分页</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/94a8b92fc94329104cc84911a8a1168d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPb6lQeTBrvBbCDDooQjFA.png"/></div></div></figure><p id="9a92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种类型的分页中，API在每个页面上都向消费者发送一个<code class="fe ml mm mn mo b">next_token</code>。这个令牌用于下一个API调用，依此类推。列或属性用于透视表中的数据。您可以选择任何符合要求的列。主要的想法是你必须提出<em class="mk">条件和参数</em>来帮助你浏览表格。如果创建时间是唯一的，那么通常的做法是选择行创建时间作为令牌。在上图中，<code class="fe ml mm mn mo b">products</code>表的<code class="fe ml mm mn mo b">created_at</code>列被用作令牌。您可以看到API已经将第<em class="mk">111</em>行的<code class="fe ml mm mn mo b">created_at</code>作为<code class="fe ml mm mn mo b">next_token</code>连同10个产品一起发送。然而，如果表变得更大，基于令牌的分页需要更少的延迟。</p><p id="1455" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">为什么？</strong>因为该查询使用查询中的条件过滤表，并从条件匹配的行开始扫描。简而言之，它只读取<code class="fe ml mm mn mo b">limit</code>个行数。</p><p id="3149" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">让我们在之前创建的<code class="fe ml mm mn mo b">products</code>表上做一些实验</strong>。我们将查询在早期实验中得到的相同结果。请注意，正确的索引会带来更好的性能。我让事情变得简单。</p><p id="a131" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们对第<em class="mk">100</em>到第<em class="mk">110</em>行运行这个查询，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们已经可以看到它的执行时间比以前少了。数据库已经过滤掉并且只计算了<em class="mk"> 10行</em>而不是<em class="mk"> 110行</em>。</p><p id="65b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们用更大的令牌值来限制查询。该查询的目标是第90000到第90010行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="a0e3" class="mv ls iq mo b gy mw mx l my mz">Limit  (cost=0.00..1.11 rows=10 width=27) (actual time=6.587..6.589 rows=10 loops=1)<br/>  -&gt;  Seq Scan on products  (cost=0.00..2184.01 rows=19735 width=27) (actual time=6.586..6.587 rows=10 loops=1)<br/>        "Filter: (created_at &gt;= '1662535267497'::bigint)"<br/>        Rows Removed by Filter: 90000<br/>Planning Time: 1.314 ms<br/>Execution Time: 6.617 ms</span></pre><p id="3e8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你注意到巨大的不同了吗？执行该查询仅用了<em class="mk">6.617毫秒</em>。数据库不必遍历<em class="mk"> 90000 </em>行，相反，它通过表过滤，只读取<em class="mk"> 10 </em>所需的行。</p><h1 id="4127" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="cf94" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">基于偏移量分页的数据库查询需要读取<code class="fe ml mm mn mo b">offset+limit</code>行数，而基于令牌的查询只需要读取<code class="fe ml mm mn mo b">limit</code>行数，并对条件进行额外处理。</p><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="b740" class="mv ls iq mo b gy mw mx l my mz">Want to Connect?</span><span id="7994" class="mv ls iq mo b gy ng mx l my mz">If you have any feedback, please ping me on my LinkedIn: <a class="ae nh" href="https://linkedin.com/in/shuhan-mirza/" rel="noopener ugc nofollow" target="_blank">https://linkedin.com/in/shuhanmirza/</a></span></pre></div></div>    
</body>
</html>