<html>
<head>
<title>The Art of Choosing the Right Index in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL中选择正确索引的艺术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-art-of-choosing-the-right-index-in-mysql-968461bcabe8?source=collection_archive---------12-----------------------#2021-07-09">https://betterprogramming.pub/the-art-of-choosing-the-right-index-in-mysql-968461bcabe8?source=collection_archive---------12-----------------------#2021-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何索引MySQL以获得高性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f997b8e5f93b9097f06bab2f2faaad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hluU6a6yyivUCa2l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aoddeh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ahmad Odeh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="9941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经使用过MySQL、Percona Server或MariaDB，那么您可能想知道如何提高数据库实例的性能。如果你在这个问题上寻求建议，你可能听说过索引。</p><p id="a2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL中的索引可以分为几种类型:</p><ol class=""><li id="73d9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">平衡树(B树)索引是最常用的索引类型。这种索引类型可以与使用<code class="fe me mf mg mh b">=</code>、<code class="fe me mf mg mh b">&gt;</code>、<code class="fe me mf mg mh b">&gt;=</code>、<code class="fe me mf mg mh b">&lt;</code>、<code class="fe me mf mg mh b">&lt;=</code>和<code class="fe me mf mg mh b">BETWEEN</code>关键字的搜索查询一起使用(也可以与<code class="fe me mf mg mh b">LIKE</code>查询一起使用)。</li><li id="2efd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">空间(R-Tree)索引可以和MySQL几何数据类型一起使用来索引地理对象。</li><li id="6688" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">散列索引通常只用于使用<code class="fe me mf mg mh b">=</code>或<code class="fe me mf mg mh b">&lt;=&gt;</code>搜索操作符的查询。它们速度很快，但只能在使用内存存储引擎时使用。</li><li id="579b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">覆盖索引覆盖了完成查询所需的所有列。</li><li id="6d16" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">聚集索引存储行数据(通常是<code class="fe me mf mg mh b">PRIMARY KEYs</code>，如果不存在，则是<code class="fe me mf mg mh b">UNIQUE</code>索引)。</li><li id="84cd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">多列(复合)索引是在多个列上创建的。</li><li id="f753" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">前缀索引只允许您索引列的前缀。因此，索引不会索引列的全部值。它们经常被用来节省空间。</li></ol></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="faf1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">b树索引和MySQL</h1><p id="c4dd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">B树索引是MySQL、MariaDB和Percona服务器中最常用的索引。当使用这种索引时，MySQL可以利用使用<code class="fe me mf mg mh b">=</code>、<code class="fe me mf mg mh b">&gt;</code>、<code class="fe me mf mg mh b">&gt;=</code>、<code class="fe me mf mg mh b">&lt;</code>、<code class="fe me mf mg mh b">&lt;=</code>或<code class="fe me mf mg mh b">BETWEEN</code>关键字或<code class="fe me mf mg mh b">LIKE</code>查询的搜索查询。可以将这种索引添加到列中的主要原因之一是为了加快搜索查询。使用b树索引时，存储引擎不会扫描整个表来查找相关行。</p><p id="9749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些可能使用这种索引的查询示例:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="3ca8" class="nv mv it mh b gy nw nx l ny nz">SELECT * FROM demo_table WHERE column [ = | &gt; | &gt;= | &lt; | &lt;= ] 'value';</span><span id="8c7e" class="nv mv it mh b gy oa nx l ny nz">SELECT * FROM demo_table WHERE column_a BETWEEN 100 AND 200;</span><span id="745b" class="nv mv it mh b gy oa nx l ny nz">SELECT * FROM demo_table WHERE column LIKE 'value%';</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6346" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">空间索引和MySQL</h1><p id="358c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">空间索引(有时也称为R树索引)用于访问空间(地理)对象。要使用这样的索引，您必须使用MySQL提供的GIS功能。这些功能包括<code class="fe me mf mg mh b">MBRContains</code>、<code class="fe me mf mg mh b">MBRCovers</code>或<code class="fe me mf mg mh b">MBREquals</code>。这些函数可以指示一个参数的最小外接矩形是否包含、覆盖或等于另一个参数的最小外接矩形。</p><p id="affb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将这样的索引添加到表中，可以像这样使用<code class="fe me mf mg mh b">SPATIAL</code>关键字:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="b6ef" class="nv mv it mh b gy nw nx l ny nz">CREATE SPATIAL INDEX spatial_idx ON demo_table (demo_column);</span></pre><p id="5e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="04ad" class="nv mv it mh b gy nw nx l ny nz">ALTER TABLE demo_table ADD SPATIAL INDEX(spatial_idx);</span></pre><p id="c14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些可能使用这种索引的查询示例:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="93cb" class="nv mv it mh b gy nw nx l ny nz">SELECT MBRContains(@variable_1, @variable_2);</span><span id="7df6" class="nv mv it mh b gy oa nx l ny nz">SELECT MBRWithin(@variable_2, @variable_1);</span></pre><p id="9cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，在使用像<code class="fe me mf mg mh b">variable_1</code>或<code class="fe me mf mg mh b">variable_2</code>这样的变量之前，您应该首先定义它们(参数<code class="fe me mf mg mh b">WKT value</code>代表一个众所周知的文本格式值，它代表几何对象):</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="c2e3" class="nv mv it mh b gy nw nx l ny nz">SET @variable_1 = ST_GeomFromText('WKT value');</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9d62" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">哈希索引和MySQL</h1><p id="90a3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">MySQL中的散列索引有一些明显的优点和缺点。哈希索引的主要优点是非常快，但缺点是它们只用于相等比较，并且只在内存存储引擎上工作。它们也不支持范围搜索。要在表上创建这样的索引，请在查询末尾使用<code class="fe me mf mg mh b">USING HASH</code>选项:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="e08e" class="nv mv it mh b gy nw nx l ny nz">CREATE INDEX idx_name ON demo_table (demo_column) USING HASH;</span></pre><p id="3c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希索引如此之快的原因是哈希索引通常非常紧凑，并且它们的主键只访问哈希表中的元素。但是，这也意味着您不能使用范围搜索。散列索引应该只与<code class="fe me mf mg mh b">=</code>或<code class="fe me mf mg mh b">&lt;=&gt;</code>操作符一起使用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="00e3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">覆盖MySQL中的索引</h1><p id="0a68" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">使用MySQL时，有时您可能会遇到一些需要以不同方式使用索引的情况。这就是覆盖指数的用武之地。</p><p id="23c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，覆盖索引是覆盖成功执行查询所需的所有字段的索引。因此，当使用覆盖索引时，查询可以从索引本身检索结果，而不是访问磁盘来节省磁盘I/O。例如，假设您有这样一个查询:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="7c02" class="nv mv it mh b gy nw nx l ny nz">SELECT column_1, column_2 FROM demo_table WHERE column_3 = 'value';</span></pre><p id="47f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的索引已经包含您要搜索的列的值，MySQL将不会访问磁盘。相反，它将直接从索引中提供结果。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2453" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">MySQL中的聚集索引</h1><p id="cbb8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">聚簇索引本身并不是一种独立的MySQL索引类型。它们只是存储数据的不同方法。这种索引存储行数据。如果您的表有一个<code class="fe me mf mg mh b">PRIMARY KEY</code>，那么<code class="fe me mf mg mh b">PRIMARY KEY</code>就是聚集索引。如果您的表没有<code class="fe me mf mg mh b">PRIMARY KEY</code>，聚集索引是第一个<code class="fe me mf mg mh b">UNIQUE INDEX</code>，它的所有键列都被定义为<code class="fe me mf mg mh b">NOT NULL</code>。</p><p id="43c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用这种索引时，表中的所有行都根据索引键值进行存储和排序。由于行只能有一种排序顺序，所以表不能有多个聚集索引。</p><p id="9c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚集索引很容易区分。在MySQL中，金钥匙通常代表这样的索引。相比之下，平衡树索引由银色轮廓的键表示(在这种情况下，带有“金色键”的列是带有聚集索引的列，而带有“银色键”的列是带有平衡树索引的列):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a9c45d5e547194b6f7669174899e5f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yv8AHBDPvQjki8y8.png"/></div></div></figure><p id="b04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在创建表时定义聚集索引，请向列添加一个<code class="fe me mf mg mh b">AUTO_INCREMENT</code>，并将其定义为<code class="fe me mf mg mh b">PRIMARY KEY</code>。要在创建表时定义平衡树索引，请在列中添加一个<code class="fe me mf mg mh b">INDEX</code>并指定要索引的列(如果需要，还可以指定索引的名称):</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="c42e" class="nv mv it mh b gy nw nx l ny nz">CREATE TABLE arctype ( clustered_index INT(255) NOT NULL AUTO_INCREMENT PRIMARY KEY, demo_index VARCHAR(255) NOT NULL, INDEX idx_name(demo_index));</span></pre><p id="a509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有键列都定义为<code class="fe me mf mg mh b">NOT NULL</code>的<code class="fe me mf mg mh b">UNIQUE INDEX</code>也可以是聚集索引。顾名思义，在这种情况下，带有<code class="fe me mf mg mh b">UNIQUE INDEX</code>的列中的所有值都是唯一的(即没有重复)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0d39" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">MySQL中的复合索引</h1><p id="97d5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">复合索引是跨越多列的索引。这是不言自明的:如果我们有一个多列索引，我们有一个复合索引。向表中添加这样的索引可能是这样的(在本例中，<code class="fe me mf mg mh b">c1</code>、<code class="fe me mf mg mh b">c2</code>和<code class="fe me mf mg mh b">c3</code>是列名):</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="36a8" class="nv mv it mh b gy nw nx l ny nz">CREATE INDEX composite_idx ON demo_table(c1,c2,c3);</span></pre><p id="2375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们处理可能使用索引字段进行选择、连接或过滤操作的查询，复合索引会很有用。例如，如果您希望满足如下查询，那么列<code class="fe me mf mg mh b">c1</code>和<code class="fe me mf mg mh b">c2</code>上的复合索引可能会很有用:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="58d5" class="nv mv it mh b gy nw nx l ny nz">SELECT * FROM demo_table WHERE c1 = 5 AND c2 = 10;</span></pre><p id="34dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在MySQL中，复合索引可以由多达16列组成，但是要记住MySQL从左到右使用索引，反之亦然。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="56cf" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">MySQL中的前缀索引</h1><p id="ae67" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有时，您可能会遇到需要索引很长的列的情况，这使得您的索引非常大。在这些情况下，您也可以索引列的前几个字符，而不是索引整个值。这种索引称为前缀索引。</p><p id="c22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在MySQL的表上创建前缀索引，可以使用如下查询:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="0690" class="nv mv it mh b gy nw nx l ny nz">CREATE INDEX prefix_idx ON demo_table(column_name(length));</span></pre><p id="73a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，<code class="fe me mf mg mh b">prefix_idx</code>是索引的名称，<code class="fe me mf mg mh b">demo_table</code>是表的名称，<code class="fe me mf mg mh b">column_name</code>是列的名称，<code class="fe me mf mg mh b">length</code>是索引的长度。</p><p id="5f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用前缀索引时，重要的是要记住，您应该以一种提供适当的选择性并同时节省空间的方式来索引列。所以让我们试着去做。</p><p id="4926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要找到列的选择性。我们将列中的不同(唯一)值除以表中的所有值。理想的指数选择性是<code class="fe me mf mg mh b">1</code>的值:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="dfb1" class="nv mv it mh b gy nw nx l ny nz">SELECT COUNT(DISTINCT column) / COUNT(*) FROM demo_table;</span></pre><p id="9cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们应该尝试使前缀索引的选择性尽可能接近该值。为此，我们可以发出如下查询:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="d72c" class="nv mv it mh b gy nw nx l ny nz">SELECT COUNT(DISTINCT LEFT(column, 5)) / COUNT(*) AS selectivity_5;</span></pre><p id="1ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将显示的值是前缀为五个字符的索引的选择性(要评估不同的字符长度，请调整查询)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9a25" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">摘要</h1><p id="c525" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在本文中，我们浏览了一些与MySQL中某些索引相关的用例。为您的用例选择一个好的索引可能确实是一件麻烦的事情。毕竟，你有这么多选择。但是一旦您理解了项目的需求以及在MySQL中使用某些索引选项的优缺点，选择合适的选项就变得更容易了。</p><p id="799b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章为您提供了一些关于MySQL中索引的有价值的见解。请继续关注MySQL世界的更多内容。</p></div></div>    
</body>
</html>