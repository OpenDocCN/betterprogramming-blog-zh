<html>
<head>
<title>Boost Performance of Your React App With Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过记忆提升React应用的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/boost-performance-of-your-react-app-with-memoization-e414f4f64c05?source=collection_archive---------20-----------------------#2020-01-28">https://betterprogramming.pub/boost-performance-of-your-react-app-with-memoization-e414f4f64c05?source=collection_archive---------20-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a189" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于<code class="fe kf kg kh ki b">React.memo()</code>和useMemo()钩子何时有用的全面的解释</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b81f61c0843aab645ebb6bf910032742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Mq-kGcvtytRgJ4ARmuWmA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@kushagrakevat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kushagra Kevat </a>在<a class="ae kz" href="https://unsplash.com/s/photos/boost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="la"><p id="a523" class="lb lc iq bd ld le lf lg lh li lj lk dk translated">“英国广播公司发现，他们的网站加载时间每增加一秒钟，就会多损失10%的用户。”— <a class="ae kz" href="https://developers.google.com/web/fundamentals/performance/why-performance-matters" rel="noopener ugc nofollow" target="_blank">谷歌开发者</a></p></blockquote><p id="5e96" class="pw-post-body-paragraph ll lm iq ln b lo lp jr lq lr ls ju lt lu lv lw lx ly lz ma mb mc md me mf lk ij bi translated">我也不喜欢慢的网站，因为那是在浪费我的时间。当然，毫无疑问，一个网站的表现会对其受欢迎程度和收入产生影响。</p><p id="2285" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果你开始钻研你的网站的性能优化，你遇到一种叫做<em class="ml">记忆化</em>的技术只是时间问题。</p><p id="19ff" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">在我们开始举例之前，让我解释一下什么是记忆以及什么时候应该考虑使用记忆。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="489f" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">什么是记忆化</h1><p id="c17e" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">这是一种特定形式的缓存，在这种缓存中，具有相同值的重复函数的执行速度要快得多，因为这些值存储在缓存中。</p><p id="8942" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">也就是说，如果我们向memoized函数中输入相同的值，它将从缓存中返回该值，而不是再次运行该函数。</p><p id="1cdc" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">它显著提高了性能，尤其是在使用计算量大的函数或者有大量UI元素的函数时。</p><h2 id="005f" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lu nv nw nf ly nx ny nh mc nz oa nj ob bi translated">这在反应方式上意味着什么？</h2><p id="0e8e" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">在React v16.8及更高版本中，建议使用带钩子的功能组件。这意味着每个组件都是一个函数，可以被<em class="ml">记忆</em>。</p><p id="d953" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">使用记忆化，会使你的React应用程序性能更好，因为记忆化的组件只有在给定的属性改变时才会被重新渲染。</p><p id="9c0b" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">在功能组件中，我们可以使用高阶组件<code class="fe kf kg kh ki b">React.memo()</code>或钩子<code class="fe kf kg kh ki b">useMemo()</code>。</p><p id="a1a5" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">在基于类的组件中，使用记忆有两种选择:</p><ul class=""><li id="c035" class="oc od iq ln b lo mg lr mh lu oe ly of mc og lk oh oi oj ok bi translated">使用生命周期挂钩<code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate()</a></code>。</li><li id="626a" class="oc od iq ln b lo ol lr om lu on ly oo mc op lk oh oi oj ok bi translated">使用一个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">PureComponent</a></code>。</li></ul><p id="1926" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">然而，我们将关注记忆功能组件，因为它们是React创建者的首选。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="f6eb" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">何时使用它</h1><p id="4b28" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">记忆化可以提高你的应用程序的性能，但是必须小心使用。在某些情况下，这种技术的实现可能是无用的，或者可能会产生相反的效果——对应用程序的运行产生负面影响。</p><p id="047f" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">这里有几个你可能会用到它的例子:</p><ul class=""><li id="0e83" class="oc od iq ln b lo mg lr mh lu oe ly of mc og lk oh oi oj ok bi translated">纯功能组件——给定相同的属性，它总是呈现相同的输出，而不会产生副作用。</li><li id="58af" class="oc od iq ln b lo ol lr om lu on ly oo mc op lk oh oi oj ok bi translated">组件经常使用相同的道具进行渲染。</li><li id="a632" class="oc od iq ln b lo ol lr om lu on ly oo mc op lk oh oi oj ok bi translated">大的或者繁重的计算功能——它包含大量的UI元素或者必须进行繁重的计算。</li></ul><p id="a0e4" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果你不确定它是否会给你带来想要的好处，你可以使用Chrome Performance标签  <em class="ml">中的<a class="ae kz" href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" rel="noopener ugc nofollow" target="_blank"> <em class="ml">评测组件来测试你的应用。</em></a></em></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="a388" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">React.memo()</h1><p id="bfcd" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">假设我们有一个简单的功能组件叫做<code class="fe kf kg kh ki b">Employee</code>，它有道具<code class="fe kf kg kh ki b">name</code>和<code class="fe kf kg kh ki b">position</code>。我们将把这个组件包装到<code class="fe kf kg kh ki b">React.memo()</code>中，所以它看起来像这样:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="6751" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated"><code class="fe kf kg kh ki b">React.memo(Employee)</code>返回新的记忆组件<code class="fe kf kg kh ki b">MemoizedEmployee</code>。它将输出与原来的<code class="fe kf kg kh ki b">Employee</code>组件相同的内容，但是有一点不同。</p><p id="8216" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated"><code class="fe kf kg kh ki b">MemoizedEmployee</code>渲染输出被记忆。只要<code class="fe kf kg kh ki b">name</code>或<code class="fe kf kg kh ki b">position</code>道具在下一次渲染中是相同的，记忆的内容就会被重用。</p><p id="1a58" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">注意:也可以从React导入<code class="fe kf kg kh ki b">memo</code>来提高可读性。</p><h2 id="a7ca" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lu nv nw nf ly nx ny nh mc nz oa nj ob bi translated">自定义检查道具的相等性</h2><p id="0af7" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">默认情况下，<code class="fe kf kg kh ki b">React.memo()</code>使用浅层比较检查下一次重新渲染时所有道具是否相等。我们可以使用第二个参数来自定义应该检查哪些道具:</p><pre class="kk kl km kn gt os ki ot ou aw ov bi"><span id="2825" class="nq mu iq ki b gy ow ox l oy oz">React.memo(Component, [areEqual(prevProps, nextProps)]);</span></pre><p id="bd39" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果<code class="fe kf kg kh ki b">prevProps</code>和<code class="fe kf kg kh ki b">nextProps</code>相等，则<code class="fe kf kg kh ki b">areEqual(prevProps, nextProps)</code>函数必须返回<code class="fe kf kg kh ki b">true</code>。</p><p id="0759" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">例如，让我们用一个函数来检查雇员的<code class="fe kf kg kh ki b">name</code>是否等于:</p><pre class="kk kl km kn gt os ki ot ou aw ov bi"><span id="f507" class="nq mu iq ki b gy ow ox l oy oz">const employeePropsNameEqual = (prevEmployee, nextEmployee) =&gt; {<br/>  return prevEmployee.name === nextEmployee.name<br/>}</span><span id="684c" class="nq mu iq ki b gy pa ox l oy oz">const MemoizedEmployee2 = React.memo(Employee, employeePropsNameEqual);</span></pre><p id="cd12" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果上一次渲染的<code class="fe kf kg kh ki b">name</code>等于下一次渲染的<code class="fe kf kg kh ki b">name</code>，则<code class="fe kf kg kh ki b">employeePropsNameEqual()</code>函数返回<code class="fe kf kg kh ki b">true</code>。这意味着只有当<code class="fe kf kg kh ki b">name</code>属性改变时，组件才会被重新渲染。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="46af" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">使用备忘录挂钩</h1><p id="3b0e" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">这个钩子相当于前面的技术。如果依赖关系保持不变，它会为昂贵的计算记忆并返回相同的值。该方法具有以下结构:</p><pre class="kk kl km kn gt os ki ot ou aw ov bi"><span id="b30c" class="nq mu iq ki b gy ow ox l oy oz">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><ul class=""><li id="d5e8" class="oc od iq ln b lo mg lr mh lu oe ly of mc og lk oh oi oj ok bi translated">第一个参数总是一个函数(或组件)，在那里执行繁重的计算。</li><li id="6026" class="oc od iq ln b lo ol lr om lu on ly oo mc op lk oh oi oj ok bi translated">第二个参数是一组依赖项。当其中一个依赖关系改变时，<code class="fe kf kg kh ki b">useMemo()</code>重新计算该值。如果没有，它返回最后一个记忆的值。</li></ul><p id="b6ea" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果我们将这一知识实现到我们的<code class="fe kf kg kh ki b">Employee</code>组件中，它将看起来像这样:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="c1a4" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">注意:这个钩子很像<code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code>。不同之处在于<code class="fe kf kg kh ki b">useCallback</code>返回一个内存化的回调函数，而<code class="fe kf kg kh ki b">useMemo</code>返回一个内存化的值，这是函数调用的结果。</p><p id="deff" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated"><code class="fe kf kg kh ki b">useCallback(fn, deps)</code>相当于<code class="fe kf kg kh ki b">useMemo(() =&gt; fn, deps)</code>。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="79ce" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">包扎</h1><p id="5778" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">记忆是提高性能的一项伟大技术。如果应用正确，它可以防止组件在下一个属性等于前一个属性时进行无用的渲染。你可以使用<code class="fe kf kg kh ki b">React.memo()</code>或<code class="fe kf kg kh ki b">useMemo()</code>挂钩。</p><p id="5068" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">但是，您应该采取预防措施并明智地实施这种技术。组件的呈现可能会影响子组件。</p><p id="f06a" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">或者它会导致代码的可读性和理解性变差，这也可能对开发产生负面影响。</p><p id="a9e3" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">因此，一个好的开发人员应该首先考虑这样的实现，并为开发团队提供好的论据，说明为什么这样做是值得的。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="0b9b" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">接下来去哪里</h1><p id="2c87" class="pw-post-body-paragraph ll lm iq ln b lo nl jr lq lr nm ju lt lu nn lw lx ly no ma mb mc np me mf lk ij bi translated">记忆只是提高性能的众多技术之一。</p><p id="e504" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果你的应用中有很多路线，你也应该考虑实现一种叫做<em class="ml">代码分割</em>的技术。</p><div class="pb pc gp gr pd pe"><a href="https://medium.com/better-programming/routing-and-code-splitting-in-react-fc7315f0bde4" rel="noopener follow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">React中的路由和代码拆分</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">用React.lazy()和悬念正确实现React路由器</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">medium.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps kt pe"/></div></div></a></div><p id="5e36" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">如果你想有一个快速的、非动态的网站，你应该考虑用Gatsby的<em class="ml">静态渲染</em>方法。</p><div class="pb pc gp gr pd pe"><a href="https://levelup.gitconnected.com/learn-gatsby-by-building-your-own-blog-website-ff5aaa8e90b8" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">通过建立自己的博客网站来学习盖茨比</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">静态渲染方法介绍。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps kt pe"/></div></div></a></div></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="bb32" class="pw-post-body-paragraph ll lm iq ln b lo mg jr lq lr mh ju lt lu mi lw lx ly mj ma mb mc mk me mf lk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>