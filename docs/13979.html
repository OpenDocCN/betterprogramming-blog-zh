<html>
<head>
<title>UIView/NSView Styling With @propertyWrapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用@propertyWrapper的UIView/NSView样式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/view-styling-with-propertywrapper-92d8476e96a7?source=collection_archive---------9-----------------------#2022-10-21">https://betterprogramming.pub/view-styling-with-propertywrapper-92d8476e96a7?source=collection_archive---------9-----------------------#2022-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将样式从布局中分离出来，使代码更具可读性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7c95318bbbc3ab3bf6c134e6e3fb0f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wXiJ6A2_i1755ZfD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯汀娜·戈塔迪在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感觉很自然地将UIView样式代码从布局逻辑中移出，同时使样式可重用。</p><p id="b681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑带有一些嵌入式布局代码的标准<code class="fe ls lt lu lv b">UIViewController</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们甚至还没有看到布局代码，我们的视图控制器已经一团糟。</p><p id="c1d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们经常将这些分解成更小的函数，或者编写扩展UIView的助手函数，比如<code class="fe ls lt lu lv b">.configure { }</code>，但是即使这样，我们还是会遇到不可避免的麻烦。</p><p id="3f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也看到有人通过创建每个视图类型的子类来解决这个问题，只有当我们修改行为而不仅仅是为了移动一些样式逻辑时，才应该这样做。</p><p id="978f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我参与的一些较好的项目已经定义了样式表。因此，每个视图初始化器可能采用一个<code class="fe ls lt lu lv b">Style&lt;UITextField&gt;</code>或一个<code class="fe ls lt lu lv b">apply(Style&lt;UITextField&gt;)</code>，这肯定是更好的方法——但我突然明白，为什么不去掉拥有初始化器或自定义函数的需要，而只使用一个<code class="fe ls lt lu lv b">@propertyWrapper</code>？</p><blockquote class="ly lz ma"><p id="4e63" class="kw kx mb ky b kz la jr lb lc ld ju le mc lg lh li md lk ll lm me lo lp lq lr ij bi translated">每个功能可以有自己的<code class="fe ls lt lu lv b">@propertyWrapper</code>风格，共享的风格可以放在一个公共的包中。</p></blockquote><p id="009a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码可以移动到一个包含三个<code class="fe ls lt lu lv b">@propertyWrappers</code>的<em class="mb">样式表</em>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="afd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在另一个屏幕中重用这个<code class="fe ls lt lu lv b">SubmitStyle</code>，因为它是从我们的<code class="fe ls lt lu lv b">LoginViewController</code>中提取出来的。</p><p id="2f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再来看看我们修改后的<code class="fe ls lt lu lv b">LoginViewController</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e3ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这当然是一个巨大的进步！</p><p id="bf4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的属性包装器甚至可以处理视图的初始化，并且不需要指定类型。</p><p id="a571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当状态改变，我们想改变风格时怎么办？这就是我在视图或视图扩展的子类中引入属性的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="40e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类似于其他UI组件的工作方式，例如UIButton，您预先为不同的状态定义每种样式，然后设置状态(即<code class="fe ls lt lu lv b">isEnabled = false</code>)。</p><h2 id="4a06" class="mf mg iq bd mh mi mj dn mk ml mm dp mn lf mo mp mq lj mr ms mt ln mu mv mw mx bi translated">懒惰的</h2><p id="fa09" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个难题还缺少一部分，即视图的惰性初始化，所以它们只在我们的ViewController准备好布局时创建，比如在<code class="fe ls lt lu lv b">viewDidLoad</code>之后。</p><p id="61c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了重新添加这部分功能，我们需要使用一个<code class="fe ls lt lu lv b">@Lazy</code>属性包装器。如<a class="ae kv" href="https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md" rel="noopener ugc nofollow" target="_blank"> swift提案0258 </a>所述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c1e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持语法简洁，我们需要将它的初始化器包装在一个<code class="fe ls lt lu lv b">configure</code>函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看上面的<code class="fe ls lt lu lv b">EmailStyle</code>用懒惰初始化修改过的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ed24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！现在这个<code class="fe ls lt lu lv b">FormTextField</code>不会被初始化，直到我们第一次尝试访问它，这通常是在<code class="fe ls lt lu lv b">viewDidLoad</code>。</p><p id="be07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经创建了一个项目，包括这个和其他概念<a class="ae kv" href="https://github.com/cjnevin/IdealCleanArchitecture" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="a69c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>