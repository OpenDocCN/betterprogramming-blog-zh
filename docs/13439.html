<html>
<head>
<title>When and How to Use the Go Channel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时以及如何使用Go频道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-and-how-to-use-the-go-channel-58f82605156c?source=collection_archive---------3-----------------------#2022-08-26">https://betterprogramming.pub/when-and-how-to-use-the-go-channel-58f82605156c?source=collection_archive---------3-----------------------#2022-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通道==信号量+缓冲区</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8312cff638e76e34c20dbd928726f314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d7qa3dPInYru7ypk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:unsplash，<a class="ae ky" href="https://unsplash.com/photos/pfDcvn8AX98" rel="noopener ugc nofollow" target="_blank"> @bdv91 </a></p></figure><p id="07e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go简洁的结构和强大的原生库使我们能够轻松地进入状态。在实现相同功能时比Java或Python更高效，尤其是它的并发编程，由于它的<code class="fe lv lw lx ly b">goroutine</code>和<code class="fe lv lw lx ly b">channel</code>，非常得心应手，广受推崇。</p><p id="aae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">goroutine</code>和<code class="fe lv lw lx ly b">channel</code>有很多可以挖掘的地方，让我们从<code class="fe lv lw lx ly b">channel</code>开始，我曾经狭隘地认为它是一个在<code class="fe lv lw lx ly b">goroutines</code>之间传输数据并支持数据同步的消息队列，但它确实拥有一个更大的舞台。</p><h1 id="1470" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">通道==信号量+缓冲区</h1><p id="9fe8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Channel是类似<code class="fe lv lw lx ly b">slice</code>和<code class="fe lv lw lx ly b">map</code>的数据类型，等式<code class="fe lv lw lx ly b">channel == Semaphore + Buffer</code>揭示了它的本质。信号量是核心概念，其次是两个主要特性，<em class="mw">交付保证</em>和<em class="mw">状态</em>。</p><p id="4a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交付保证</strong>为goroutine扫清了道路，使其不必关注信号是否可以通过通道传输，或者依赖通道是否可以接收信号，而只关注逻辑实现。在下面的例子中，<code class="fe lv lw lx ly b">ch1</code>和<code class="fe lv lw lx ly b">ch2</code>的交付保证决定了goroutine的成功。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="9c28" class="nb ma it ly b gy nc nd l ne nf">go func() {<br/>   for {<br/>      i,ok := &lt;-ch1 // blocked if ch1 is empty<br/>      if ok {<br/>         ch2 &lt;- i*i<br/>      } else {<br/>         break<br/>      }<br/>   }<br/>}()</span></pre><p id="624e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道是否可以发送或接收数据是由其状态决定的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2fca7287597ab1ca255b74e17c99a7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mY7YKqnq1QiHBdgjcaKF9A.png"/></div></div></figure><ul class=""><li id="10de" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><strong class="lb iu"> Nil </strong>，未初始化的通道，<code class="fe lv lw lx ly b">var ch chan int</code>。没有接收或发送任何信号。操作受阻，关闭时死机。</li><li id="18bb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">打开</strong>，初始化通道，<code class="fe lv lw lx ly b">ch = make(chan int)</code>。它可以接收和发送任何信号。</li><li id="394c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">关闭</strong>，关闭通道，<code class="fe lv lw lx ly b">close(ch)</code>，<strong class="lb iu">只接收信号，发送时死机。</strong></li></ul><p id="20d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Buffer将信道从信号量改为先进先出队列，这很好地解释了“信道”这个名称然而，缓冲区也会危及交付保证并导致错误。如果通道关闭时缓冲器仍有一个以上的项目，这些信号将<a class="ae ky" href="https://go.dev/play/p/QpYQINctBWi" rel="noopener ugc nofollow" target="_blank">无法</a>传送。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="f96e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">通道简化了并发性</h1><p id="541b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">并发编程基于多线程的思想:线程独立运行，而数据是共享和同步的。数据处理始终是一个难点，但合理使用通道可以简化并发。</p><h2 id="62f0" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated">定义频道</h2><blockquote class="oi oj ok"><p id="53a1" class="kz la mw lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated">channel type =(" chan " | " chan " "element type。</p></blockquote><p id="1fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据内部<code class="fe lv lw lx ly b">recvq</code>和<code class="fe lv lw lx ly b">sendq</code>队列是否允许存储相应的等待者，即<code class="fe lv lw lx ly b">goroutines</code>，通道可以分为发送-接收、只读和仅发送。</p><p id="35c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，只读和只发送通道不直接使用，而是作为函数参数或返回，约束通道在函数中的角色。举个例子，</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="5041" class="nb ma it ly b gy nc nd l ne nf">func send(ch chan&lt;- int) {<br/>   for i := 0; i &lt; 5; i++ {<br/>      ch &lt;- i<br/>   }<br/>}<br/><br/>func recv(ch &lt;-chan int) {<br/>   for i := range ch {<br/>      fmt.Println(i)<br/>   }<br/>}<br/><br/>func rc(int n) &lt;- chan int {<br/>   ch := make(chan int)<br/>   go func(){<br/>      <em class="mw">// do some work<br/>      </em>ch &lt;- v<br/>   }<br/>   return ch<br/>}</span></pre><p id="cbd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将<code class="fe lv lw lx ly b">send(ch chan&lt;- int)</code>改为<code class="fe lv lw lx ly b">send(ch &lt;- chan int)</code>，代码将无法编译。</p><h2 id="9579" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated">使用频道</h2><p id="7a6e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">使用通道的方法太多了，如果你想记住所有的模式，效率很低。但关键是要记住使用通道的核心，<strong class="lb iu">go routines</strong>之间的信号传输。</p><ul class=""><li id="79fd" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">至少涉及一个goroutine。</li><li id="67d7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">必须有发送者和接收者。</li><li id="950f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">发送方和接收方都可以是多路由的。</li><li id="b4b7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">双方都可能发生阻塞。</li><li id="eafb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">缓冲区可以存储多余的信号量。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d993a3d8bc4d1f521d8b21ce294fb84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7botFtrJhid0KWeKB4AYg.png"/></div></div></figure><p id="3587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据发送和接收模式，让我们将信道分为3组，同步和阻塞，非阻塞和其他。</p><p id="6b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">同步和闭锁</strong></p><p id="19bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道通过<code class="fe lv lw lx ly b">&lt;-</code>操作器一个接一个地发送和接收信号。在某些情况下，即使有缓冲区，发送和接收都可能被阻塞，尽管缓冲区可以在某种程度上增强并发性。所以我们经常一起使用<code class="fe lv lw lx ly b">goroutines</code>和<code class="fe lv lw lx ly b">for</code>循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="caf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发送方和接收方可以是一对一、一对多、多对一、多对多，而这里的“一”可以是一个或多个goroutines，甚至是<code class="fe lv lw lx ly b">for</code>循环中包含的多个发送和接收。我们根据对并发性的需求选择模式，包括数据量和并发延迟。</p><ul class=""><li id="177c" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">一对一无缓冲通道。阻挡是不可避免的(可以是看不见的)，但是信号是可以100%传递的。</li><li id="33fd" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">一对多。使用缓冲区时，它类似于一个工作池，只有在工作负载较重且缓冲区被完全占用时，发送方(生产者)才能被阻塞。当没有缓冲区时，最大并发数是工作线程数(goroutines)。</li><li id="05e0" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">多对一。虽然可以保证执行顺序，但是发送方很可能会被阻止。</li><li id="ab32" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">多对多。这是最高效的设计，具有最快的处理速度和最低的阻塞，但也消耗最多的内存。但是，仍然需要估计发送者和接收者的数量，以实现最高的性能，否则要么发送被阻塞，要么接收“饥饿”</li></ul><p id="d666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">无阻塞</strong></p><p id="9ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">&lt;-</code>操作符和<code class="fe lv lw lx ly b">for range </code>都用于一个通道。而Go提供了<code class="fe lv lw lx ly b">select</code>操作符来方便通道操作。</p><ul class=""><li id="486b" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">支持同时接收多个频道</li><li id="07be" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">支持同时发送和接收</li><li id="7ab5" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">支持添加超时以防止通道等待时间过长</li><li id="b9d9" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">通道满时支持<code class="fe lv lw lx ly b">Drop</code>信号</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">其他</strong></p><p id="c895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道可以与其他Go语言特性相结合，以更好地设计并发代码。</p><ul class=""><li id="385a" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">验证“结束”</li></ul><p id="7daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">if v, ok := &lt;- ch; ok{}</code>，可以判断通道是否已经关闭，让接收者可以优雅地结束。</p><ul class=""><li id="e5b8" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">来保证“结束”</li></ul><p id="b4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们使用了<code class="fe lv lw lx ly b">time.Sleep</code>并在<code class="fe lv lw lx ly b">main</code>方法中等待goroutine结束，这显然不符合生产标准。而有了<code class="fe lv lw lx ly b">waitGroup</code>的结合，<code class="fe lv lw lx ly b">channel</code>和<code class="fe lv lw lx ly b">goroutine</code>，这种经典的“生产者-消费者”模式，可以完美收场。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="aec9" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">取消</li></ul><p id="7166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像我们在<code class="fe lv lw lx ly b">select</code>示例中所做的那样，在一定时间后使用<code class="fe lv lw lx ly b">After</code>取消频道在实践中并不常见。在生产上，我们不是限制渠道，而是限制整个业务的执行时间。这就是<code class="fe lv lw lx ly b">context</code>的作用:我们使用<code class="fe lv lw lx ly b">context</code>链接整个逻辑的每个方面，设置一个超时，并决定在<code class="fe lv lw lx ly b">context</code>结束时结束<code class="fe lv lw lx ly b">channel</code>块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="68bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发送的goroutine超时并且<code class="fe lv lw lx ly b">main</code>结束时，我们将缓冲区设置为<code class="fe lv lw lx ly b">1</code>以避免内存泄漏。</p><h1 id="9065" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">何时使用频道</h1><p id="da68" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">很难判断什么时候使用<code class="fe lv lw lx ly b">channel</code>，但这主要取决于经验，尤其是您在并发开发方面的经验。</p><p id="dd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在Kubernetes代码库中找到许多用例，但是在这里我只能列出最常见的场景。</p><ul class=""><li id="63a1" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">触发信号，包括结束和开始</li><li id="68eb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">异步传输数据。非紧急的异步工作进程一个接一个</li><li id="e6f9" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">故意阻挡。对于关键步骤，您需要阻塞并等待</li><li id="d8b6" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">工人池。工人要么被任务唤醒，要么被长时间阻塞，直到任务到来</li></ul><h2 id="2f18" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated"><strong class="ak">信号通道</strong></h2><p id="7649" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">channel</code>作为结束某些任务的信号。<code class="fe lv lw lx ly b">{name} chan struct{}</code>用于定义一个没有任何数据的<code class="fe lv lw lx ly b">channel</code>，因为<code class="fe lv lw lx ly b">struct{}</code>占用最低的内存。用<code class="fe lv lw lx ly b">&lt;- {name}</code>通知结束和关闭频道。</p><p id="fd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">kuberentes/controller-runtime</code>管理器中<a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/c7a98aa706379c4e5c79ea675c7f333192677971/pkg/manager/internal.go#L118" rel="noopener ugc nofollow" target="_blank">被多次使用</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/24c38daf281d21d5fe580eadca89e1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/0*WQKbSvHB6K1nERMT"/></div></figure><p id="4a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/controller-runtime/blob/c7a98aa706379c4e5c79ea675c7f333192677971/pkg/manager/internal.go#L561" rel="noopener ugc nofollow" target="_blank">发送信号</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/e9a8e0a59122ec5d0ea814172c59e763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2MYP36VXekquhZiQ"/></div></div></figure><p id="93e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">controllerManager</code>中，还有<code class="fe lv lw lx ly b">elected chan struct{}</code>和<code class="fe lv lw lx ly b">internalProceduresStop chan struct{}</code>的另外两个<em class="mw">信号通道</em>。</p><h2 id="328d" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated"><strong class="ak">异步处理</strong></h2><p id="c3d0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">channel</code>作为数据通道，也可以传输数据，方便异步处理，比如<code class="fe lv lw lx ly b">controllerManager</code>中的错误处理。所有错误将被放入<code class="fe lv lw lx ly b">errChan chan error</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/df5f5a7d1a5cac861f85151b51053ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/0*lPGuaDMPrzJEmhZK"/></div></figure><p id="5f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当<code class="fe lv lw lx ly b">channel</code>结束时，该err通道才会被清空并异步处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/67e5920cca849421a3860c19349551a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dPvHk8ue6iCNYMfL"/></div></div></figure><p id="c26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步处理错误在Go代码中很常见，在种类<a class="ae ky" href="https://github.com/kubernetes-sigs/kind/blob/b6bc112522651d98c81823df56b7afa511459a3b/pkg/errors/concurrent.go#L42" rel="noopener ugc nofollow" target="_blank">代码中也可以找到类似的处理，</a>结合<code class="fe lv lw lx ly b">waitGroup</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ad5aee9537a9f30fbc4b72517df46aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Atz4UQUpIwzti55a"/></div></div></figure><h2 id="829f" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated"><strong class="ak">“挨饿”的工人</strong></h2><p id="c65b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在并发工作器模式中，通道触发任务执行，工作器在没有任务时被阻塞，避免了创建和销毁goroutines的开销增加。</p><p id="14a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看Kubernetes观察器是如何工作的。</p><ul class=""><li id="4f9b" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">在收到停止信号之前，将所有事件转发到通道。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c2a01008c4a26e9eaa2de3a560d2d95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/0*OzsNHNOIfcn4LATP"/></div></figure><ul class=""><li id="7ada" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">启动<code class="fe lv lw lx ly b">for</code>循环<code class="fe lv lw lx ly b">select</code>等待任务</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/4b420005be610b29b23bb1bb69026979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A-7dz3oAf_jBY6dF"/></div></div></figure><h2 id="49a4" class="nb ma it bd mb nx ny dn mf nz oa dp mj li ob oc ml lm od oe mn lq of og mp oh bi translated"><strong class="ak">要执行的任务</strong></h2><p id="0e22" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">另一个常见的例子是异步执行任务并等待完成。这种模式经常应用于代码的关键步骤，比如kubelet中的图片<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/fbffe056dd03bd9c746e8819ad22043d640a4489/pkg/kubelet/images/image_manager.go#L143" rel="noopener ugc nofollow" target="_blank">下载</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/5d3a22681bd20f9d9c951bc00a6c0dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zIW6wRp-lx7QxQmH"/></div></div></figure><p id="abee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe lv lw lx ly b">pullImage</code>是一个异步执行的阻塞作业，由<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/fbffe056dd03bd9c746e8819ad22043d640a4489/pkg/kubelet/images/puller.go#L47" rel="noopener ugc nofollow" target="_blank"> puller.go </a>中的goroutine执行，并将结果发送给通道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/e460023d3dc5e36301e4f7313a53740f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKK8__8Ipp0yapjT"/></div></div></figure><p id="012c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会奇怪:为什么要屏蔽？为什么异步？为什么不集成代码并依次执行呢？</p><p id="3965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是一个典型的例子，通过通道分割同步任务，并抽象代码，以提高代码的灵活性，满足后续提高并发性的需求。</p><h1 id="d20b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="1132" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">通道简化了并发性并提供了很大的灵活性，但是只有当我们知道如何以及何时使用它时。因此，理解信道=信号量+缓冲区的核心，并确定何时需要信号量或缓冲区，以及在哪些情况下发送和接收被阻塞，这是非常重要的。为了提高编码效率，我们应该将它集成到并发思维中，以使它更好地服务于我们的实践。</p></div></div>    
</body>
</html>