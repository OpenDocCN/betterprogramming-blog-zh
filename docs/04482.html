<html>
<head>
<title>How to Maximize Reusability for Your React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何最大化React组件的可重用性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-maximize-reusability-for-your-react-components-d9607c04f2aa?source=collection_archive---------16-----------------------#2020-04-15">https://betterprogramming.pub/how-to-maximize-reusability-for-your-react-components-d9607c04f2aa?source=collection_archive---------16-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有用但通用的组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf2f271b9c566a31e3aa927ad974a9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mPm2c9_OMC_IVfa9-4bXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由</em> <a class="ae kz" href="https://unsplash.com/@donramxn" rel="noopener ugc nofollow" target="_blank"> <em class="ky">拉蒙·萨利内罗</em> </a> <em class="ky">上</em><a class="ae kz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">Unsplash</em></a></p></figure><p id="03af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">React是一个流行的库，开发人员可以用它来为web应用程序构建高度复杂和交互式的用户界面。许多开发人员利用这个库来构建他们的应用程序，也只是因为许多重要的原因而觉得使用它很有趣。例如，它的声明性质使构建web应用程序不那么痛苦，更有趣，因为代码在我们的能力范围内变得可预测和更可控。</p><p id="5fbe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">那么，是什么让它不那么痛苦呢？有哪些例子可以帮助演示React如何用于构建高度复杂和交互式的用户界面呢？</p><p id="fa78" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文将介绍React中最大化可重用性的能力，并提供一些你现在可以在React应用上使用的技巧和诀窍。它将通过构建一个实际的React组件来演示，并一步一步地解释为什么要采取一些步骤，以及可以做些什么来提高它们的可重用性。我想强调的是，有很多方法可以让一个组件变得可重用。虽然本文将解释实现这一点的重要方法，但并没有涵盖所有的方法。</p><p id="4201" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文面向初级、中级和高级React开发人员——尽管它对初级和中级开发人员更有用。</p><p id="308f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">事不宜迟，我们开始吧！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ecde" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">该组件</h1><p id="4354" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">让我们构建一个<code class="fe na nb nc nd b">List</code>组件，并尝试从那里扩展它的功能。</p><p id="064d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们正在构建一个页面，用户在注册成为医疗专业人士社区的一员后会被重定向到这个页面。该页面应该显示医生可以创建的组列表，新注册的医生可以查看。每个列表应该显示某种类型的标题、描述、组的创建者、代表他们的组的图像以及一些基本的重要信息，如日期。</p><p id="b788" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以创建一个简单的<code class="fe na nb nc nd b">List</code>组件来表示这样一个组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f79b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，我们可以轻松地渲染它，然后就到此为止:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e245" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">显然，组件是不可重用的，所以我们可以通过由孩子提供一些基本的可重用性来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="610b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但这没有多大意义，因为<code class="fe na nb nc nd b">List</code>组件甚至不再是列表组件，也不应该被命名为列表，因为它只是一个返回<code class="fe na nb nc nd b">div</code>元素的组件。我们还不如直接把代码移到<code class="fe na nb nc nd b">App</code>组件中。</p><p id="81e9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是这很糟糕，因为现在我们已经将组件硬编码到了<code class="fe na nb nc nd b">App</code>中。如果我们确定该列表是一次性使用的，这可能没问题。但是我们知道会有多种用途，因为我们用它在网页上呈现不同的医疗团体。</p><p id="40f1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以我们可以重构<code class="fe na nb nc nd b">List</code>来为它的列表元素提供更窄的道具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5bf0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这看起来好一点了，现在我们可以像这样重用<code class="fe na nb nc nd b">List</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/89c27ef68ccd69d3482fe5a519976074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZHncZ7CV6XPROzLj.jpg"/></div></div></figure><p id="d320" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里没有太多的样式，但为了避免混淆，这里列出了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e46e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个仅限于这个网页的小应用程序可能只需要这个简单的组件就可以了。但是，如果我们处理潜在的大型数据集，列表需要呈现数百行，该怎么办呢？我们最终会让页面试图显示所有的元素，这可能会导致崩溃、延迟、元素错位或重叠等问题。</p><p id="d987" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这不是一个很好的用户体验，所以我们可以提供一种方法在成员数量达到一定数量时扩展列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f96940c889eb7bae6d65ee0cccecaee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UwZnKKUULnkLls45.gif"/></div></div></figure><p id="fe40" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们似乎有了一个非常好的可重用组件来呈现组列表。</p><p id="cead" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们绝对可以做得更好。我们并不真的必须专门为组织的组使用这个组件。</p><p id="1251" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们可以把它用于其他目的呢？为标签提供一个道具(在我们的例子中是<code class="fe na nb nc nd b">Group</code>)在逻辑上可以实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="459c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，您可以将它用于其他目的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="11b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当考虑如何使React组件更加可重用时，一个简单但强大的方法是重新考虑如何命名prop变量。大多数时候，一个简单的重命名可以产生巨大的影响。</p><p id="2fe6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们的<code class="fe na nb nc nd b">App</code>组件中，我们还可以为<code class="fe na nb nc nd b">Members</code>部分提供一个自定义道具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d911ddcfd62972f3a3c1142ad31828f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O9npeHJrni3qlcxH.jpg"/></div></div></figure><p id="a78f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，如果我们看看我们的组件，只提供了<code class="fe na nb nc nd b">members</code>道具，让我们看看我们得到了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a1eb3c042a94b78b95a0c26146dc3f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hgofRBnSF4EmwWXM.jpg"/></div></div></figure><p id="d403" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我不知道你，但我在这里看到的是，列表实际上可以用于任何事情！</p><p id="7af0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以重用相同的组件来表示等待下一次预约的专利:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b958c4e6fbb07df7581ae193cb180e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xKABYhaqzx3GxF6L.jpg"/></div></div></figure><p id="a49a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">或者我们可以用它来竞价拍卖:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/2179c9dd09d6473217b82c5317a27c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_07X8Lxihv1_Ju5O.jpg"/></div></div></figure><p id="11de" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不要低估命名变量的力量。一个简单的命名修正可以改变游戏规则。</p><p id="7af7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们回到代码。我们在扩展其可重用性方面做得很好。但在我看来，我们实际上可以做得更多。</p><p id="48ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">既然我们知道我们的<code class="fe na nb nc nd b">List</code>组件可以兼容地被完全不相关的原因重用，我们可以决定将组件分成子组件来支持不同的用例，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b8d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从功能上讲，它的工作方式是一样的，但是现在我们将不同的元素分成列表子组件。</p><p id="9283" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这提供了一些好处:</p><ul class=""><li id="4444" class="nm nn it lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated">我们现在可以分别测试每个组件。</li><li id="0b4d" class="nm nn it lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">它变得更加可伸缩(维护、代码大小)。</li><li id="a845" class="nm nn it lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">它变得更加可读，即使代码变得更大。</li><li id="8926" class="nm nn it lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated">我们可以使用像<code class="fe na nb nc nd b">React.memo</code>这样的技术，通过记忆来优化每个组件。</li></ul><p id="05f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，大部分实现细节保持不变，但现在更加可重用。</p><p id="7c35" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可能已经注意到了<code class="fe na nb nc nd b">collapsed</code>状态被移到了<code class="fe na nb nc nd b">ListComponent</code>。我们可以通过props将状态控件移回父控件，轻松地使<code class="fe na nb nc nd b">ListComponent</code>可重用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9ff2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">知道了通过props提供<code class="fe na nb nc nd b">collapse</code>状态管理,<code class="fe na nb nc nd b">ListComponent</code>变得更加可重用，我们可以对<code class="fe na nb nc nd b">List</code>做同样的事情，这样使用我们组件的开发者就可以控制它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/53db1f513f591bc57cde7133ac9a24ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*atDsivBAWbpMPKes.gif"/></div></div></figure><p id="b12a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们开始看到这里出现了一种模式。看起来<code class="fe na nb nc nd b">props</code>与可重用性有很大关系——这是完全正确的！</p><p id="6ef0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">实际上，开发人员想要覆盖子组件的实现来提供他们自己的组件并不罕见。我们可以让我们的<code class="fe na nb nc nd b">List</code>组件通过提供一个来自props的覆盖来考虑到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b40d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是许多React库中使用的一种非常常见但功能强大的模式。在可重用性方面，始终保持默认实现是非常重要的。例如，如果开发人员想要覆盖<code class="fe na nb nc nd b">ListHeader</code>，他们可以通过传入<code class="fe na nb nc nd b">renderHeader</code>来提供自己的实现。否则，它将默认渲染原始的<code class="fe na nb nc nd b">ListHeader</code>。这是为了保持列表组件的功能不变，并且不可破坏。</p><p id="8671" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是，即使在没有使用覆盖的情况下提供默认实现，提供一种方法来移除或隐藏组件中的某些内容也是很好的。</p><p id="2e74" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，如果我们想为开发人员提供一种根本不呈现任何header元素的方法，那么通过props提供一个开关是一个有用的策略。我们不想污染道具中的命名空间，所以可以重用<code class="fe na nb nc nd b">header</code>道具。这样，如果它们传入<code class="fe na nb nc nd b">null</code>，它就根本不会呈现列表头:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/84b030dc883e910c2947d5a4195e1fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*77CQ98umbLC52VQh.jpg"/></div></div></figure><p id="7240" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用可重用的<code class="fe na nb nc nd b">List</code>组件走得更远。我们不局限于为<code class="fe na nb nc nd b">ListHeader</code>和<code class="fe na nb nc nd b">ListComponent</code>提供覆盖。我们还可以为他们提供一种覆盖<code class="fe na nb nc nd b">Root</code>组件的方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e424" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请记住，当我们提供像这样的可定制选项时，我们总是默认一个默认实现，就像我们默认它使用原始的<code class="fe na nb nc nd b">ListRoot</code>组件一样。</p><p id="f778" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，父节点可以轻松地提供自己的时尚容器组件，将<code class="fe na nb nc nd b">List</code>呈现为其子节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/6d44d20842668d0310ca181a435277ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6OH11gftMyopSXCJ.gif"/></div></div></figure><p id="a7e1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有时开发人员也想提供他们自己的列表行。使用我们在本文中讨论的相同概念，我们可以做到这一点。首先，让我们将<code class="fe na nb nc nd b">li</code>元素抽象成它们自己的<code class="fe na nb nc nd b">ListItem</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="51dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后更改<code class="fe na nb nc nd b">List</code>以提供一个可定制的渲染器来覆盖默认的<code class="fe na nb nc nd b">ListItem</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="52b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">并稍微修改<code class="fe na nb nc nd b">ListComponent</code>以支持该定制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="950d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意:我们将对<code class="fe na nb nc nd b">renderListItem(member)</code>的调用包装在<code class="fe na nb nc nd b">React.Fragment</code>中。这样，我们可以为他们分配<code class="fe na nb nc nd b">key</code>，这样他们就不必这么做了。这个简单的改变可以使试用我们组件的用户获得积极的评价，因为这将省去他们自己处理的麻烦。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="b1c4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为一名React开发人员，我仍然看到更多的机会来最大限度地发挥我们的<code class="fe na nb nc nd b">List</code>组件的可重用性的全部潜力。但是由于这篇文章在这一点上太长了，我将用几篇文章来结束它，以开始你的旅程。</p><p id="bdb7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我想强调的是，我们利用像<code class="fe na nb nc nd b">renderListItem</code>或<code class="fe na nb nc nd b">renderHeader</code>这样的渲染器道具将参数传递回调用者是很重要的。这是一个强大的模式，也是render prop模式在React Hooks发布之前被广泛采用的原因。</p><p id="c00a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">回到命名我们的prop变量，我们可以意识到这个组件实际上不需要每次都表示一个列表。实际上，我们可以让它兼容许多不同的情况，而不仅仅是呈现列表。我们真正需要注意的是组件是如何在代码中实现的。</p><p id="f4b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它本质上所做的就是获取一个项目列表，并在支持折叠等奇特功能的同时呈现它们。可能感觉折叠部分只是下拉列表、列表、菜单等特有的。但是任何东西都可以被折叠。我们组件中的任何东西都不仅仅是特定于这些组件的。</p><p id="6441" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，我们可以很容易地重用导航条的组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/e26aa37b4676235f01fe4d3b59c4a1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W1zbq8b-jr-sRM6s.gif"/></div></div></figure><p id="8e61" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们的组件基本上和以前一样，除了我们提供了一些道具，比如<code class="fe na nb nc nd b">renderCollapser</code>和<code class="fe na nb nc nd b">renderExpander</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5bd8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是最大化可重用性的力量！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c636" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="8624" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">本文到此结束。我希望你发现这是有价值的，并在未来寻找更多。</p></div></div>    
</body>
</html>