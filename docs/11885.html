<html>
<head>
<title>How to Implement a Distributed Transaction Across Mysql, Redis, and Mongo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现跨Mysql、Redis和Mongo的分布式事务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-a-distributed-transaction-across-mysql-redis-and-mongo-9f6c7448b3b5?source=collection_archive---------2-----------------------#2022-04-25">https://betterprogramming.pub/how-to-implement-a-distributed-transaction-across-mysql-redis-and-mongo-9f6c7448b3b5?source=collection_archive---------2-----------------------#2022-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="21d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">组合多个存储引擎以形成分布式事务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bb2be33724e49e6494dde8cff9eb2186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YI-TLYArpwn-fWBi"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简·安东宁·科拉尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="170c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mysql、Redis、Mongo都是很受欢迎的商店，各有各的优势。在实际应用中，同时使用多个存储是很常见的，确保跨多个存储的数据一致性成为一个需求。</p><p id="32a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文给出了一个跨多个存储引擎实现分布式事务的例子:Mysql、Redis和Mongo。这个例子是基于https://github.com/dtm-labs/dtm<a class="ae kv" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank">的分布式事务框架</a>的，希望能帮助你解决跨微服务的数据一致性问题。</p><p id="659b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">灵活组合多个存储引擎形成一个分布式事务的能力是由DTM首先提出的，没有其他分布式事务框架像这样陈述过这种能力。</p><h1 id="50e5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们试图解决什么问题？</h1><p id="7bfa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设一个用户现在正在参加一个促销活动:他们有余额，充值话费，促销会赠送商城积分。余额存储在Mysql，账单存储在Redis，商城积分存储在Mongo。因为提升有时间限制，所以有参与可能失败的可能，所以需要回滚支持。</p><p id="d016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于上述问题场景，您可以使用DTM的Saga事务，我们将在下面详细解释解决方案。</p><h1 id="03aa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">准备数据</h1><p id="434a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一步是准备数据。为了方便用户快速上手示例，我们在<a class="ae kv" href="https://en.dtm.pub/" rel="noopener ugc nofollow" target="_blank"> en.dtm.pub </a>准备了所有数据，包括Mysql、Redis、Mongo，具体连接用户名和密码可以在<a class="ae kv" href="https://github.com/dtm-labs/dtm-examples" rel="noopener ugc nofollow" target="_blank"> dtm-labs/dtm-examples </a>找到。</p><blockquote class="mp mq mr"><p id="2e9c" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">如果想自己在本地准备数据环境，可以使用<a class="ae kv" href="https://github.com/dtm-labs/dtm/blob/main/helper/compose.store.yml" rel="noopener ugc nofollow" target="_blank">DTM-labs/DTM/blob/main/helper/compose . store . yml</a>启动Mysql、Redis、Mongo然后执行<a class="ae kv" href="https://github.com/dtm-labs/dtm/tree/main/sqls" rel="noopener ugc nofollow" target="_blank">dtm-labs/DTM/tree/main/sqls</a>中的脚本，为这个例子准备数据，其中<code class="fe mw mx my mz b">busi.*</code>是业务数据，<code class="fe mw mx my mz b">barrier.*</code>是DTM使用的辅助表</p></blockquote><h1 id="0c55" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编写业务代码</h1><p id="a00c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们从最熟悉的商店引擎Mysql的业务代码开始</p><blockquote class="mp mq mr"><p id="7e10" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">以下代码是Golang语言。其他语言如C#、PHP、Java都可以在这里找到:【https://en.dtm.pub/ref/sdk.html SDKs】(<a class="ae kv" href="https://en.dtm.pub/ref/sdk.html" rel="noopener ugc nofollow" target="_blank"/>)</p></blockquote><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="9654" class="ne lt iq mz b gy nf ng l nh ni">func SagaAdjustBalance(db dtmcli.DB, uid int, amount int) error {<br/>  _, err := dtmimp.DBExec(db, "update dtm_busi.user_account set balance = balance + ? where user_id = ?" , amount, uid)<br/>  return err<br/>}</span></pre><p id="7968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码主要执行数据库中用户余额的调整。在我们的示例中，这部分代码不仅用于Saga的正向操作，还用于补偿操作，在补偿操作中，只需要为补偿传递一个负数。</p><p id="a2ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Redis和Mongo，业务代码的处理类似，只是增加或减少相应的余额。</p><h1 id="4883" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何保证幂等性</h1><p id="206a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于Saga事务模式，当我们在子事务服务中出现临时故障时，将重试失败的操作。这种失败可能发生在子事务提交之前或之后，因此子事务操作需要是幂等的。</p><p id="3dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DTM提供了帮助表和帮助函数，帮助用户快速实现幂等。对于Mysql，它会在业务数据库中创建一个辅助表<code class="fe mw mx my mz b">barrier</code>，当用户启动一个交易来调整余额时，它会先在<code class="fe mw mx my mz b">barrier</code>表中插入<code class="fe mw mx my mz b">Gid</code>。如果有重复行，那么插入会失败，然后跳过平衡调整，保证等幂。使用helper函数的代码如下:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="d197" class="ne lt iq mz b gy nf ng l nh ni">app.POST(BusiAPI+"/SagaBTransIn", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>  return MustBarrierFromGin(c).Call(txGet(), func(tx *sql.Tx) error {<br/>    return SagaAdjustBalance(tx, TransInUID, reqFrom(c).Amount, reqFrom(c).TransInResult)<br/>  })<br/>}))</span></pre><p id="4e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mongo处理幂等性的方式和Mysql类似，我就不再赘述了。</p><p id="ef41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis对幂等性的处理与Mysql不同，主要是因为事务的原理不同。Redis事务主要通过Lua的原子执行来保证。DTM助手函数将通过Lua脚本调整平衡。在调整余额之前，它会在Redis中查询<code class="fe mw mx my mz b">Gid</code>。如果<code class="fe mw mx my mz b">Gid</code>存在，将跳过平衡调整；如果不是，它将记录<code class="fe mw mx my mz b">Gid</code>并执行平衡调整。用于helper函数的代码如下:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="633c" class="ne lt iq mz b gy nf ng l nh ni">app.POST(BusiAPI+"/SagaRedisTransOut", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>  return MustBarrierFromGin(c).RedisCheckAdjustAmount(RedisGet(), GetRedisAccountKey(TransOutUID), -reqFrom(c).Amount, 7*86400)<br/>}))</span></pre><h1 id="c7ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">怎么做补偿</h1><p id="2f35" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于佐贺来说，也需要处理补偿操作，但补偿不是简单的反向调整，有很多陷阱需要注意。</p><p id="5279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一方面，补偿需要考虑幂等性，因为上一小节描述的失败和重试在补偿中也存在。</p><p id="4e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，补偿也需要考虑“零补偿”，因为Saga的正向操作可能返回失败，这可能发生在数据调整之前或之后。对于已经提交调整的故障，我们需要执行反向调整，但是对于尚未提交调整的故障，我们需要跳过反向调整。</p><p id="56bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在DTM提供的helper函数中，一方面会根据forward操作插入的Gid判断补偿是否为空补偿，另一方面会再次插入Gid+'compensate '判断补偿是否为重复操作。如果有正常的补偿操作，则执行业务上的数据调整；如果存在空补偿或重复补偿，将跳过对该业务的调整。</p><p id="605e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Mysql代码如下。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="0c7b" class="ne lt iq mz b gy nf ng l nh ni">app.POST(BusiAPI+"/SagaBTransInCom", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>  return MustBarrierFromGin(c).Call(txGet(), func(tx *sql.Tx) error {<br/>    return SagaAdjustBalance(tx, TransInUID, -reqFrom(c).Amount, "")<br/>  })<br/>}))</span></pre><p id="3613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis的代码如下。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="c781" class="ne lt iq mz b gy nf ng l nh ni">app.POST(BusiAPI+"/SagaRedisTransOutCom", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>  return MustBarrierFromGin(c).RedisCheckAdjustAmount(RedisGet(), GetRedisAccountKey(TransOutUID), reqFrom(c).Amount, 7*86400)<br/>}))</span></pre><p id="c7b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">补偿服务代码与前一步操作的代码几乎相同，只是金额乘以-1。DTM助手函数自动正确处理幂等和空补偿。</p><h1 id="e2da" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">其他例外</h1><p id="010a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在写向前操作和补偿操作的时候，其实还有一个例外叫做“暂停”。当超时或重试次数达到配置的限制时，全局事务将回滚。正常情况是在补偿之前执行正向操作，但是在“过程暂停”的情况下，补偿可以在正向操作之前执行。因此，forward操作还需要确定补偿是否已经执行，如果已经执行，也需要跳过数据调整。</p><p id="5dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于DTM用户来说，这些异常已经被优雅而恰当地处理了，作为一个用户，你只需要遵循上面描述的<code class="fe mw mx my mz b">MustBarrierFromGin(c).Call</code>调用，根本不需要关心它们。DTM处理这些异常的原理在此详细描述:<a class="ae kv" href="https://dtm.pub/practice/barrier.html" rel="noopener ugc nofollow" target="_blank">异常和子交易障碍</a></p><h1 id="ed3d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动分布式事务</h1><p id="b9bd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在编写了各个子交易服务之后，下面的代码启动了一个Saga全局交易。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="4db6" class="ne lt iq mz b gy nf ng l nh ni">saga := dtmcli.NewSaga(dtmutil.DefaultHTTPServer, dtmcli.MustGenGid(dtmutil.DefaultHTTPServer)).<br/>  Add(busi.Busi+"/SagaBTransOut", busi.Busi+"/SagaBTransOutCom", &amp;busi.TransReq{Amount: 50}).<br/>  Add(busi.Busi+"/SagaMongoTransIn", busi.Busi+"/SagaMongoTransInCom", &amp;busi.TransReq{Amount: 30}).<br/>  Add(busi.Busi+"/SagaRedisTransIn", busi.Busi+"/SagaRedisTransOutIn", &amp;busi.TransReq{Amount: 20})<br/>err := saga.Submit()</span></pre><p id="8c7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这部分代码中，创建了一个由3个子事务组成的Saga全局事务。</p><ul class=""><li id="e67e" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">从Mysql转出50</li><li id="5937" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">30分钟后转移到Mongo</li><li id="70a4" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">20分钟后转到Redis</li></ul><p id="51d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在整个事务中，如果所有子事务都成功完成，则全局事务成功；如果其中一个子事务返回业务失败，则全局事务回滚。</p><h1 id="1314" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">奔跑</h1><p id="593f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想运行一个以上的完整例子，步骤如下。</p><ol class=""><li id="7045" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr nx np nq nr bi translated">运行DTM</li></ol><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="cac6" class="ne lt iq mz b gy nf ng l nh ni">git clone https://github.com/dtm-labs/dtm &amp;&amp; cd dtm<br/>go run main.go</span></pre><ol class=""><li id="204b" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr nx np nq nr bi translated">运行一个成功的例子</li></ol><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="548d" class="ne lt iq mz b gy nf ng l nh ni">git clone https://github.com/dtm-labs/dtm-examples &amp;&amp; cd dtm-examples<br/>go run main.go http_saga_multidb</span></pre><ol class=""><li id="e0f1" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr nx np nq nr bi translated">运行一个失败的例子</li></ol><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="f959" class="ne lt iq mz b gy nf ng l nh ni">git clone https://github.com/dtm-labs/dtm-examples &amp;&amp; cd dtm-examples<br/>go run main.go http_saga_multidb_rollback</span></pre><p id="09c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以修改该示例，以模拟各种临时故障、空补偿情况和各种其他异常，在这些情况下，当整个全局事务完成时，数据是一致的。</p><h1 id="a5e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="a7ce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本文给出了一个跨Mysql、Redis和Mongo的分布式事务的例子。它详细描述了需要处理的问题以及解决方案。</p><p id="5fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中的原则适用于所有支持ACID事务的存储引擎，您可以很快将其扩展到其他引擎，比如TiKV。</p><p id="2ec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎参观github.com/dtm-labs/dtm。这是一个致力于使微服务中的分布式事务更容易的项目。它支持多种语言和多种模式，如两阶段消息、Saga、Tcc和Xa。</p></div></div>    
</body>
</html>