<html>
<head>
<title>Build a Modern Networking Layer in Swift Using Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Async/Await在Swift中构建现代网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-api-layer-in-swift-with-async-await-abe8a5ca75da?source=collection_archive---------4-----------------------#2022-10-03">https://betterprogramming.pub/build-an-api-layer-in-swift-with-async-await-abe8a5ca75da?source=collection_archive---------4-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个Async/Await API层，帮助您轻松应对现场编码面试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2bed9796fd763c134981052b184964c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DT84ORsKDwD74kBm401-hQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=788002" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="a3f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iOS开发人员现场编码访谈中的一个常见要求是能够在设定的时间框架内从头开始实现网络层。虽然它可能不会经常出现在专业工作中，因为大多数应用程序都已经包含了一个已建立的网络层，但当想要原型化某个东西时，知道如何快速建立一个网络层是非常有用的。</p><p id="e878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想演示一个快速简单的网络层，您可以使用它来进行现场编码面试，它符合坚实的原则，使用泛型，实现Async/Await，具有适当的错误处理，在UIKit和SwiftUI应用程序中工作，如果您从头开始练习编写它，可以在10分钟内启动并运行，这使您在技术面试中有更多的时间专注于其余的功能。</p><p id="35cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="21bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要一个API来提取数据，最好是有几个不同的端点来返回不同类型的数据。英国政府的食品卫生评级API是一个很好的起点。</p><p id="1626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请花些时间熟悉它，但了解它并不重要，因为作为本指南的一部分，我们将特别关注几个端点。</p><p id="da62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一些编码上:</p><p id="3d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将开始用一个<code class="fe lz ma mb mc b">enum</code>对<code class="fe lz ma mb mc b">APIRouter</code>进行编码，作为我们的路由器对象，它将包含构建每个请求所需的组件。在本指南中，我们将创建3个不同的请求:</p><ol class=""><li id="1052" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">getAuthorities</code> —返回英国不同当局(即地区)的详细信息</li><li id="5901" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">getRatings</code> —返回食品卫生部门使用的评级系统的详细信息</li><li id="561d" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">getEstablishments</code> —返回机构的详细信息，我们将向其传递一个ID以返回特定机构(地区)内的机构</li></ol><p id="5139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把我们在这个枚举中设置的组件转换成URLComponents，作为<code class="fe lz ma mb mc b">APIRequestDispatcher</code>的一部分，但是我们需要一些东西:</p><ol class=""><li id="b5d4" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">host——这是你的API请求的公共根，想想<code class="fe lz ma mb mc b">medium.com</code></li><li id="94ce" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">scheme —这是您的API的web服务器协议(HTTP / HTTPS)</li><li id="7fe0" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">path——这是我们请求的特定资源端点，想想<code class="fe lz ma mb mc b">{host}/@soaringearth</code></li><li id="e626" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">方法—您用来发出请求的API方法(发布/上传/修补/获取/删除)</li><li id="2efe" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">参数—这些是您想要发送给API的任何查询参数</li></ol><p id="df8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会注意到我没有涉及身体对象，我从未在面试中被要求亲自执行<code class="fe lz ma mb mc b">POST</code>请求，这是因为与更简单的<code class="fe lz ma mb mc b">GET</code>请求相比，设置和配置需要额外的时间。如果我们确实想添加主体数据，它将作为<code class="fe lz ma mb mc b">URLRequestDispatcher</code>的一部分被添加，因为iOS中的<code class="fe lz ma mb mc b">URLComponents</code>只处理URL的构造(这似乎是显而易见的)——它将是我们需要添加数据的<code class="fe lz ma mb mc b">URLRequest</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到上面的完整路由器，它与之前讨论的内容相匹配。你可能想知道为什么我们决定使用一个<code class="fe lz ma mb mc b">enum</code>，原因很简单。如果我们决定添加第四个请求，编译器将在每个计算出的变量中抛出错误，以表明我们缺少一个已处理的案例，这可以防止您忘记实现它的scheme/path/method等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/65b7fd7062e85dde4bd0f83675073ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DS0uwHqm3hItkiw9yULqMg.png"/></div></div></figure><p id="c6d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe lz ma mb mc b">APIRouter</code>的一个注意事项—由于我提到了可靠的原则，拥有一个包含应用程序想要发出的每个请求的所有组件的单一路由器不太符合单一责任原则，在生产应用程序中，如果每个端点有多条路径，即(/ratings，/ratings/{id}，/ratings/{id}/xxxYYY)，您可能需要考虑为每个端点配备不同的路由器，但是请记住本指南的上下文，即能够在有时间限制的技术面试中制作一些东西，本指南中的方法就足够了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="447c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在进入<code class="fe lz ma mb mc b">APIRequestDispatcher</code>。这可能是指南中最复杂的部分，包含一些您可能不熟悉的功能，即<code class="fe lz ma mb mc b">generics</code>和<code class="fe lz ma mb mc b">async/await</code>，我将包含一些文档链接:</p><ul class=""><li id="b31b" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mu mj mk ml bi translated">泛型:<a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/generics . html</a></li><li id="9dca" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mu mj mk ml bi translated">async/Await:<a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/concurrency . html</a></li></ul><p id="2a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还会有自定义错误处理的元素，但是很容易看出发生了什么。</p><p id="a8ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类本身很简单，只包含一个类函数<code class="fe lz ma mb mc b">request&lt;T: Codable&gt;(router: APIRouter) async throws -&gt; T</code>。对于大多数情况，处理简单的API请求已经足够了。分解一下，你可以看到它期望并将返回符合可编码协议的对象，你需要提供一个<code class="fe lz ma mb mc b">APIRouter</code>作为参数，函数异步运行，也可以抛出错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5cb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来分解上面的片段:</p><ol class=""><li id="5665" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">URLComponent</code>是我们将基于之前创建的<code class="fe lz ma mb mc b">enum</code>构造的，这也是为什么我们需要向函数传递一个<code class="fe lz ma mb mc b">APIRouter</code>。</li><li id="5821" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">URLComponent</code>包含一个属性，允许您获取一个可选的URL，如果该URL不能基于它所设置的各种组件来构造，它将返回nil。如果我们无法获得完整的URL，我们还想在这里抛出一个自定义错误。</li><li id="537d" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">这是食品卫生API的一个细微差别，它要求所有请求都包含一个<code class="fe lz ma mb mc b">x-api-version</code>头，其他API不需要这个。</li><li id="a46d" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">try await withCheckedThrowingContinuation { continuation</code> —这是一个Async/Await函数，它挂起当前任务，并使用<code class="fe lz ma mb mc b">checked throwing continuation</code>调用闭包，这是一种奇特的说法，可以用异步工作的结果来调用闭包。闭包的内容与常规的URLSession请求基本相同。</li><li id="5e2a" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">如果我们的<code class="fe lz ma mb mc b">dataTask</code>没有获得任何数据，我们可以在这里抛出我们的其他自定义错误来指示一个<code class="fe lz ma mb mc b">noData</code>响应，适当地处理错误。</li><li id="ff84" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><code class="fe lz ma mb mc b">DispatchQueue.main.async</code>将使我们回到主线程上。</li><li id="cf66" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">使用Async/Await的主要区别是，我们需要调用<code class="fe lz ma mb mc b">continuation.resume(with:</code>并提供我们的结果(成功/失败)，而不仅仅是返回。</li></ol><p id="ac3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于请求调度程序来说，这就差不多了，我们的泛型被解码并返回，任何错误都被相应地处理和抛出。</p><p id="1e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建自定义错误就像定义新的枚举一样简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="35f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将制作的API客户端是用户/应用程序交互与API通信的方式。我们将使用POP(面向协议编程)方法为每个请求创建一个客户端。每个请求都有自己的协议和符合它的类，我们这样做是为了方便模仿API客户端和更好地分离关注点，因为一些屏幕可能只想访问权威列表，而其他屏幕可能只想访问评级。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到上面的实现，您可能会注意到，使用<code class="fe lz ma mb mc b">RatingClient</code>我们传递了一个参数，但没有传递给路由器，这是因为API中有一个限制，评级端点不接受和查询参数，因此过滤必须在设备上完成。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f22a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个实现中使用的模型对象很容易理解，它们是符合codable的基本结构。为了提高使用对象时的可读性，使用了两个<code class="fe lz ma mb mc b">CodingKeys</code>,它们将接收到的对象的键转换为模型对象中存在的属性的名称。更多信息可以在<a class="ae kv" href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types" rel="noopener ugc nofollow" target="_blank">这里找到</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a9f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，这里有一个使用Async/Await方法获取数据的例子。这只是将API请求封装在<code class="fe lz ma mb mc b">Task.init</code>中并使用do/catch来处理错误的一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="02bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，我真的希望所有的东西都被清楚地解释和理解，我在几次采访中使用了这种方法，一旦您练习了几次，您就可以真正地在大约10分钟内编写好API层。如果您对本指南或iOS职位面试有任何疑问，请随时联系我们。</p></div></div>    
</body>
</html>