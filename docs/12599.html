<html>
<head>
<title>Introduction to Angular Template-Driven Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度模板驱动的表单简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-angular-template-driven-forms-cd3a1b10380a?source=collection_archive---------13-----------------------#2022-06-15">https://betterprogramming.pub/introduction-to-angular-template-driven-forms-cd3a1b10380a?source=collection_archive---------13-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4305" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">有角度的</a></h2><div class=""/><div class=""><h2 id="1136" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">通过逐步构建一个简单的表单来探索角度模板驱动的表单</h2></div><p id="9deb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Angular提供了两种通过表单处理用户输入的主要方法:反应式和模板驱动式。这两种方法都建立在通用表单API之上。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/2b1f3e95ca377fe1712ed0577b4cb9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*DNVCQH2IK9NsWt8reAsNcw.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">这是您将构建的表单。够基本的了。</p></figure><p id="5054" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这篇文章中，我将按照模板驱动的方法构建一个表单。</p><p id="d8aa" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可以在<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/intro-to-angular-reactive-forms-fc5cd636ce1f">角反馈形式介绍</a>中使用反馈方法找到相同的形式。</p><h1 id="f354" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">模板驱动方法概述</h1><blockquote class="mp mq mr"><p id="1bc5" class="ko kp ms kq b kr ks ka kt ku kv kd kw mt ky kz la mu lc ld le mv lg lh li lj ij bi translated">根据<a class="ae lw" href="https://angular.io/guide/forms-overview#choosing-an-approach" rel="noopener ugc nofollow" target="_blank">文档</a>，</p><p id="0444" class="ko kp ms kq b kr ks ka kt ku kv kd kw mt ky kz la mu lc ld le mv lg lh li lj ij bi translated">模板驱动的表单"<em class="iq">依靠模板中的指令来创建和操作底层对象模型。[…].</em></p><p id="2150" class="ko kp ms kq b kr ks ka kt ku kv kd kw mt ky kz la mu lc ld le mv lg lh li lj ij bi translated"><em class="iq">它们很容易添加到应用程序中，但它们的扩展性不如反应式表单。</em></p><p id="cf75" class="ko kp ms kq b kr ks ka kt ku kv kd kw mt ky kz la mu lc ld le mv lg lh li lj ij bi translated"><em class="iq">如果您有非常基本的表单需求和逻辑，可以在模板中单独管理，模板驱动的表单可能是一个很好的选择</em>。</p></blockquote><p id="2c25" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在构建表单时，我将大致按照<a class="ae lw" href="https://angular.io/guide/forms#building-a-template-driven-form" rel="noopener ugc nofollow" target="_blank">构建一个模板驱动的表单</a>。然而，我将简化一些方面，并省去大部分造型。</p><h1 id="6565" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">FormsModule &amp;两条指令</h1><p id="77a3" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">首先，我们需要记住导入<a class="ae lw" href="https://angular.io/api/forms/FormsModule" rel="noopener ugc nofollow" target="_blank"> FormsModule </a>，因为它“导出模板驱动表单所需的提供者和指令”</p><p id="d517" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，我们在<code class="fe nb nc nd ne b">app.module.ts</code>中导入FormsModule。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="c2ca" class="nj ly iq ne b gy nk nl l nm nn">import { <a class="ae lw" href="https://angular.io/api/forms/FormsModule" rel="noopener ugc nofollow" target="_blank">FormsModule</a> } from '@angular/forms';</span></pre><p id="d18b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">并在<code class="fe nb nc nd ne b">@NgModule.</code>的进口中申报</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="16e2" class="nj ly iq ne b gy nk nl l nm nn">imports: [BrowserModule, FormsModule],</span></pre><p id="202c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这很重要，因为<code class="fe nb nc nd ne b">NgModel</code>和<code class="fe nb nc nd ne b">NgForm</code>指令都是从<code class="fe nb nc nd ne b">FormsModule</code>导出的，我们稍后会看到。</p><p id="d358" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">其次，在使用模板驱动的表单时，我们需要记住两条指令:</p><ol class=""><li id="006c" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj nt nu nv nw bi translated"><code class="fe nb nc nd ne b">NgModel</code>允许双向数据绑定。“模板驱动的表单使用<a class="ae lw" href="https://angular.io/guide/architecture-components#data-binding" rel="noopener ugc nofollow" target="_blank">双向数据绑定</a>在模板发生变化时更新组件中的数据模型，反之亦然”。</li><li id="f1f2" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><code class="fe nb nc nd ne b">NgForm</code>跟踪“汇总表单值和验证状态”。一旦您导入<code class="fe nb nc nd ne b"><a class="ae lw" href="https://angular.io/api/forms/FormsModule" rel="noopener ugc nofollow" target="_blank">FormsModule</a></code>，默认情况下，该指令将在所有<code class="fe nb nc nd ne b">&lt;form&gt;</code>标签上生效。</li></ol><p id="6a29" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将从使用<code class="fe nb nc nd ne b">NgModel</code>构建一个收集用户输入的元素开始。</p><h1 id="c202" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">构建表单元素</h1><p id="13d0" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">理论上，我们可以从类或者模板开始。</p><p id="1fd2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，“在模板驱动的表单中，表单模型是隐式的，而不是显式的。指令<code class="fe nb nc nd ne b">NgModel</code>为给定的表单元素创建并管理一个<code class="fe nb nc nd ne b">FormControl</code>实例</p><p id="618d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在模板驱动的表单中，从模板开始更自然，我将遵循这种方法。</p><h1 id="534a" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">通用表单元素</h1><p id="7cd7" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">角度形状中的一般形状元素可能如下所示:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="oc od l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">角度模板驱动表单中的通用表单元素</p></figure><p id="5492" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这几乎是普通的HTML，除了第7行<code class="fe nb nc nd ne b">[(ngModel)]="email"</code>引入了上面提到的第一个指令<code class="fe nb nc nd ne b">ngModel</code>，以添加双向数据绑定。</p><p id="1ded" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe nb nc nd ne b">ngModel</code>指令通过双向数据绑定将输入控件绑定到相应的<code class="fe nb nc nd ne b">email</code>属性，以更新组件中的数据模型。</p><p id="09f4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">注意标签的<code class="fe nb nc nd ne b">for</code>属性和输入的<code class="fe nb nc nd ne b">id</code>属性不会影响元素，但是，将标签链接到控件会提高<a class="ae lw" href="https://www.a11yproject.com/checklist/#forms" rel="noopener ugc nofollow" target="_blank">可访问性</a>。</p><p id="617b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由于我们没有名为<code class="fe nb nc nd ne b">email</code>的属性，我们需要在<code class="fe nb nc nd ne b">template-form.component.ts</code>中创建它。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="ea5c" class="nj ly iq ne b gy nk nl l nm nn">import { Component, OnInit } from '@angular/core';</span><span id="c6b2" class="nj ly iq ne b gy oe nl l nm nn">@Component({...})<br/>export class TemplateFormComponent {</span><span id="c430" class="nj ly iq ne b gy oe nl l nm nn">  email: string | undefined;</span><span id="e605" class="nj ly iq ne b gy oe nl l nm nn">}</span></pre><p id="9140" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一旦属性就位，当通过输入元素在模板中或者以编程方式在组件类中进行更改时，<code class="fe nb nc nd ne b">email</code>的值就会更新。</p><p id="6bba" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">附注:如果在<code class="fe nb nc nd ne b">form</code>元素之外使用双向数据绑定，那么<code class="fe nb nc nd ne b">name</code>属性是不必要的，但是对于模板驱动的表单，即在<code class="fe nb nc nd ne b">form</code>标记之内，它是必要的。</p><h2 id="6c14" class="nj ly iq bd lz of og dn md oh oi dp mh kx oj ok mj lb ol om ml lf on oo mn iw bi translated">是否意味着我们的元素不是一种形式？</h2><p id="1664" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">嗯，是也不是。</p><p id="f806" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果您有一个非常简单的“表单”，比如说一个输入字段来收集用户的电子邮件，就是这样！你可以添加一个按钮来触发一个点击事件，就此打住，开心就好！</p><p id="a4d7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">您还可以使用相同的模式添加更多的元素。它会工作得很好！</p><p id="c571" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，由于这些元素是相互独立的，我们并没有真正的形式。它是一堆行为类似于表单的元素。</p><p id="d3e6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，您可能最终需要检查每个元素的有效性，比如说是必需的，以激活提交按钮。</p><p id="c838" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们朝着这个方向更进一步。</p><h1 id="0574" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">从一种元素到一种形式</h1><p id="512f" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">从上面的通用元素开始，我们可以创建以下形式:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="oc od l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">角度模板驱动的表单</p></figure><p id="8275" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">大多数元素类似于我们上面看到的通用构建块。</p><p id="4d62" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它们被包装在一个常规的HTML <code class="fe nb nc nd ne b">form</code>实体中。然而，由于我们在<code class="fe nb nc nd ne b">app.module.ts</code>中导入了<code class="fe nb nc nd ne b">FormsModule</code>，<code class="fe nb nc nd ne b">form</code>在幕后创建了一个新的<code class="fe nb nc nd ne b">NgForm</code>实例。</p><p id="3e7a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">目前，我们不关心这个。但是请注意带有事件监听器的<code class="fe nb nc nd ne b">form</code>标签。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="40b8" class="nj ly iq ne b gy nk nl l nm nn">&lt;form (ngSubmit)="onSubmit()"&gt;</span></pre><p id="abce" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，表单监听“ngSubmit”事件。“ngSubmit”事件由类型为<code class="fe nb nc nd ne b">submit</code>的按钮触发。</p><p id="4556" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在<code class="fe nb nc nd ne b">template-form.component.ts</code>中，我们需要为每个表单元素添加一个属性:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d49a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们还可以创建一个对象来模拟表单的形状，这样就更好了。参见<a class="ae lw" href="https://angular.io/guide/forms#bind-input-controls-to-data-properties" rel="noopener ugc nofollow" target="_blank">将输入控件绑定到数据属性</a>获取示例。</p><h1 id="b167" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">Angular阻止本机DOM验证</h1><p id="7b35" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">值得一提的是，在使用模板驱动的方法时，Angular会将<code class="fe nb nc nd ne b">novalidate</code>属性添加到表单标签中。</p><blockquote class="mp mq mr"><p id="b039" class="ko kp ms kq b kr ks ka kt ku kv kd kw mt ky kz la mu lc ld le mv lg lh li lj ij bi translated">来自<a class="ae lw" href="https://angular.io/api/forms/NgForm#native-dom-validation-ui" rel="noopener ugc nofollow" target="_blank">文档</a>:“为了防止原生DOM表单验证UI干扰Angular的表单验证，每当<code class="fe nb nc nd ne b">FormModule</code>或<code class="fe nb nc nd ne b">ReactiveFormModule</code>被导入到应用中时，Angular自动在任何<code class="fe nb nc nd ne b">&lt;form&gt;</code>上添加<code class="fe nb nc nd ne b">novalidate</code>属性”。</p></blockquote><p id="8ac9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，如果您尝试上面的代码，您会发现即使没有填写必填字段也可以提交表单。在<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/intro-to-angular-reactive-forms-fc5cd636ce1f">角无功形式介绍</a>中，我们看到了使用无功方法的相同行为。</p><p id="b494" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，这有两个原因:</p><ul class=""><li id="e282" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj op nu nv nw bi translated">默认情况下，浏览器的本机表单验证被禁用<code class="fe nb nc nd ne b">novalidate</code></li><li id="abe9" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">提交按钮触发ngSubmit”事件。然而，我们并不要求提交的表单是有效的。</li></ul><h2 id="0732" class="nj ly iq bd lz of og dn md oh oi dp mh kx oj ok mj lb ol om ml lf on oo mn iw bi translated">ngNativeValidate:浏览器的本机验证</h2><p id="3082" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">顺便提一下，您可能想尝试一下浏览器的原生表单验证。</p><p id="410d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">您可以通过向表单标签添加<code class="fe nb nc nd ne b">ngNativeValidate</code>属性来启用本地验证。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="687f" class="nj ly iq ne b gy nk nl l nm nn">&lt;form (ngSubmit)="onSubmit()" ngNativeValidate&gt;</span></pre><p id="c23a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe nb nc nd ne b">ngNativeValidate</code>属性启用浏览器的原生表单验证，您可以在下面看到一个例子。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi oq"><img src="../Images/2c796d4d2aa7a1a3cf2cc20c670dfba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6w0GyEZUjY3j2a5hIxFCBg.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">由<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#the_required_attribute" rel="noopener ugc nofollow" target="_blank"> MDN </a>进行的浏览器本机验证</p></figure><p id="2ccb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#the_required_attribute" rel="noopener ugc nofollow" target="_blank"> MDN </a>的例子中，input元素有一个<code class="fe nb nc nd ne b">required</code>属性，当用户在输入没有值的情况下点击提交按钮时，该属性触发浏览器的本地验证。</p><p id="7958" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">您可能不喜欢它，但它是一个简单的工作验证和错误消息。</p><h2 id="fcc4" class="nj ly iq bd lz of og dn md oh oi dp mh kx oj ok mj lb ol om ml lf on oo mn iw bi translated">回到我们的状态</h2><p id="d56f" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">我们仍然在处理一堆独立的元素。</p><p id="ebe5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们提交表单，我们很容易得到底层元素的值，但不是它们的属性，也不是表单的整体状态。</p><p id="8451" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果那些要素都是奴才，你更愿意和老板谈，对吗？</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi ov"><img src="../Images/4b108dfa1042fd5dadbf4e9869f18137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sh0Jg1FgB7pgOn3L"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lw" href="https://unsplash.com/@alison_wang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾莉森·王</a>在<a class="ae lw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1d11" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">使用模板参考</h1><p id="ea43" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">所以，所有这些奴才的老板就是形态元素。我们想解决这个问题。</p><p id="2a30" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">记住，因为我们导入了<code class="fe nb nc nd ne b">FormsModule</code>，<code class="fe nb nc nd ne b">form</code>在幕后创建了一个新的<code class="fe nb nc nd ne b">NgForm</code>实例。</p><p id="f12e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了访问<code class="fe nb nc nd ne b">NgForm</code>实例和表单状态，我们需要使用一个<a class="ae lw" href="https://angular.io/guide/template-reference-variables" rel="noopener ugc nofollow" target="_blank">模板引用变量</a>，稍后我们会看到。</p><p id="be2a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">多亏了模板引用变量，我们将可以访问表单的值和状态，“以及像<code class="fe nb nc nd ne b">dirty</code>和<code class="fe nb nc nd ne b">touched</code>这样的用户交互属性。”</p><p id="cf10" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">几个例子:</p><ul class=""><li id="d34f" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj op nu nv nw bi translated">如果表单中的任何元素无效，表单本身也将无效</li><li id="7078" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">如果表单中的任何元素已经被<code class="fe nb nc nd ne b">touched</code>，表单将产生<code class="fe nb nc nd ne b">touched</code></li></ul><p id="03c2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在我们的例子中，<code class="fe nb nc nd ne b">f</code>是模板引用变量。换句话说，<code class="fe nb nc nd ne b">f</code>代表我们在模板中创建的表单。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="5919" class="nj ly iq ne b gy nk nl l nm nn">#f="ngForm"</span></pre><p id="abc5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由于模板变量，我们可以在模板的另一部分使用表单中的数据，或者我们可以将它传递给类。</p><p id="6b9e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将遵循后者。因此，表单标签变成了</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="251c" class="nj ly iq ne b gy nk nl l nm nn">&lt;form (ngSubmit)="onSubmit(f)" #f="ngForm"&gt;</span></pre><p id="c4f9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这样，我们在提交时将表单的值和状态传递给类。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="oc od l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">使用ngForm的角度模板驱动表单</p></figure><p id="1f64" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们需要更改<code class="fe nb nc nd ne b">onSubmit</code>方法来接收表单。所以，这个类变成了:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b2a0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">记住Angular将<code class="fe nb nc nd ne b">novalidate</code>属性添加到模板中的表单标签。</p><p id="ec79" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，即使没有填写必填字段，也可以提交表单。</p><p id="4b98" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是这一次是不同的，因为我们可能想要建立在<code class="fe nb nc nd ne b">FormsModule</code>带来的确认之上！</p><p id="abd1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们看看日志:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi ow"><img src="../Images/014ba71196cf51ba5663641efa5d17c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGQdMBwg83eaOYytiFvWZA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">表单的状态无效</p></figure><p id="0ddd" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">表单的状态无效，因为某些必需的控件无效。</p><p id="f4bc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果表单状态无效，禁用按钮的一个简单方法是将按钮的状态绑定到按钮的<code class="fe nb nc nd ne b">disabled</code>属性。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="355b" class="nj ly iq ne b gy nk nl l nm nn">&lt;button <br/>  type="submit" <br/>  [disabled]="f.status === 'INVALID'"<br/>&gt;<br/>  Submit<br/>&lt;/button&gt;</span></pre><p id="ba87" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">值得一提的是，既然我们使用了<code class="fe nb nc nd ne b">ngModel</code>，</p><p id="f054" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">“NgModel指令[…]跟踪该控件的状态。<br/>它告诉你用户是否:</p><ul class=""><li id="9177" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj op nu nv nw bi translated">触动了控制器，</li><li id="7da4" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">如果值改变了，</li><li id="6186" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">或者值是否变得无效。</li></ul><p id="3b6d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Angular在控制元素上设置特殊的CSS类，以反映状态[…]"，angular.io。</p><h1 id="6a5d" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">特殊的CSS类？</h1><p id="c9c0" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">Angular根据用户与表单的交互向表单标签添加和移除类！因此，正如文件中所报告的，</p><ul class=""><li id="b3ec" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj op nu nv nw bi translated">如果控件已被访问:<code class="fe nb nc nd ne b">ng-touched</code>，否则<code class="fe nb nc nd ne b">ng-untouched</code></li><li id="11bf" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">如果控件的值已经改变:<code class="fe nb nc nd ne b">ng-dirty</code>，否则<code class="fe nb nc nd ne b">ng-pristine</code></li><li id="7ae6" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj op nu nv nw bi translated">如果控件的值有效:<code class="fe nb nc nd ne b">ng-valid</code>否则<code class="fe nb nc nd ne b">ng-invalid</code></li></ul><p id="b171" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们举个简单的例子。</p><p id="d275" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们将下面的类添加到<code class="fe nb nc nd ne b">template-form.component.css</code>中:</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="eb3e" class="nj ly iq ne b gy nk nl l nm nn">// template-form.component.css</span><span id="542b" class="nj ly iq ne b gy oe nl l nm nn">.ng-invalid {<br/>  border-left: 5px solid #a94442; /* red */<br/>}</span></pre><p id="c224" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在我们的模板中，我们需要名称和首选项。</p><p id="31b1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，在开始时，Angular会将<code class="fe nb nc nd ne b">ng-invalid</code>类添加到这两个类中，我们会看到左边的边框是红色的。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5067199e73b2a87483daf449e86e1ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*vc4iR53mXXIs7VpoJaNcnA.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">Angular添加了ng-invalid类</p></figure><p id="b772" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">可以看到，整个表单的左边界也是红色的！这是有意义的，因为在这一点上，整个表单是无效的。</p><p id="8397" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正如在<a class="ae lw" href="http://The control has been visited.&#9;ng-touched&#9;ng-untouched The control's value has changed.&#9;ng-dirty&#9;ng-pristine The control's value is valid.&#9;ng-valid&#9;ng-invalid" rel="noopener ugc nofollow" target="_blank">文档</a>中一样，我们可以添加<code class="fe nb nc nd ne b">:not(form)</code> <a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not" rel="noopener ugc nofollow" target="_blank"> CSS伪类</a>来选择任何不是表单的元素。</p><pre class="ll lm ln lo gt nf ne ng nh aw ni bi"><span id="3732" class="nj ly iq ne b gy nk nl l nm nn">// template-form.component.css</span><span id="420a" class="nj ly iq ne b gy oe nl l nm nn">.ng-invalid:not(form) {<br/>  border-left: 5px solid #a94442; /* red */<br/>}</span></pre><p id="8361" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，关键是我们现在将表单作为一个整体来处理，Angular通过提供默认类来支持它，这些默认类可以简化我们的常见验证工作。</p><p id="8d17" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">添加一些基本的CSS，我们得到:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/2b1f3e95ca377fe1712ed0577b4cb9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*DNVCQH2IK9NsWt8reAsNcw.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">最后形状</p></figure><p id="5714" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请随意查看GitHub 上的<a class="ae lw" href="https://github.com/lorenzojkrl/formication/tree/main/src/app/components/template-form" rel="noopener ugc nofollow" target="_blank">代码。如果你想改进CSS，请随意投稿！</a></p><h1 id="3b97" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">快速小结</h1><p id="09e2" class="pw-post-body-paragraph ko kp iq kq b kr mw ka kt ku mx kd kw kx my kz la lb mz ld le lf na lh li lj ij bi translated">Angular提供了两种主要的构建表单的方法:反应式和模板驱动式。在这篇文章中，我们探索了模板驱动的方法。</p><p id="e6de" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这两种方法都建立在通用表单API之上。</p><ol class=""><li id="475a" class="no np iq kq b kr ks ku kv kx nq lb nr lf ns lj nt nu nv nw bi translated">在<code class="fe nb nc nd ne b">app.module.ts</code>中导入表单模块</li><li id="d30d" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated">使用<code class="fe nb nc nd ne b">[(ngModel)]=’property’</code>获得双向数据绑定</li><li id="f3bb" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated"><code class="fe nb nc nd ne b"><em class="ms">&lt;form&gt;</em></code> <em class="ms"> </em>标签导入<code class="fe nb nc nd ne b">FormsModule</code>后默认实现<code class="fe nb nc nd ne b">NgForm</code></li><li id="bcd0" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated">默认情况下，Angular阻止浏览器的本机表单验证</li><li id="5038" class="no np iq kq b kr nx ku ny kx nz lb oa lf ob lj nt nu nv nw bi translated">使用模板引用<code class="fe nb nc nd ne b">#f='ngForm'</code>来访问<code class="fe nb nc nd ne b">NgForm</code>实例</li></ol><p id="52f4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请随意查看GitHub 上的<a class="ae lw" href="https://github.com/lorenzojkrl/formication/tree/main/src/app/components/template-form" rel="noopener ugc nofollow" target="_blank">代码，或者阅读</a><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/intro-to-angular-reactive-forms-fc5cd636ce1f">角度反应形式介绍</a>中的反应方法。</p></div></div>    
</body>
</html>