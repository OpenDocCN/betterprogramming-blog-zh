<html>
<head>
<title>Mastering the Flyweight Pattern in Swift 5.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5.5中掌握Flyweight模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-the-flyweight-pattern-in-swift-5-5-322140dd195a?source=collection_archive---------2-----------------------#2021-11-26">https://betterprogramming.pub/mastering-the-flyweight-pattern-in-swift-5-5-322140dd195a?source=collection_archive---------2-----------------------#2021-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f563" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">结构设计模式实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3d9f01b7204b12b7a0cdb114c9208601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xsjn5oFFATj1HAN7ldQSGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:Undraw.co</p></figure><p id="d689" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Flyweight模式节省了内存，降低了创建依赖于相同不可变属性的相似对象的成本。</p><h1 id="d90c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么时候我应该使用轻量级？</h1><p id="1d5d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当您在多个类中重复相同的不可变属性集时，Flyweights是一个很好的解决方案，尤其是当对象的创建成本很高时。</p><h1 id="e9db" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么时候我应该避免使用轻量级？</h1><p id="6475" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当你需要一个以上的内在状态对象时，不要使用flyweights。相反，使用单例或工厂模式与共享状态实例进行交互。</p><blockquote class="mo mp mq"><p id="fab2" class="kv kw mr kx b ky kz jr la lb lc ju ld ms lf lg lh mt lj lk ll mu ln lo lp lq ij bi translated">“在创建flyweight时，要注意你的flyweight内存增长了多少。如果你存储几个flyweight，你可以最小化同一个对象的<strong class="kx ir">的内存使用，但是你仍然可以在flyweight存储中使用太多的内存。</strong></p><p id="7adb" class="kv kw mr kx b ky kz jr la lb lc ju ld ms lf lg lh mt lj lk ll mu ln lo lp lq ij bi translated">为了减轻这种情况，设置使用多少内存的界限，或者注册内存警告，并通过从内存中移除一些flyweights来响应。您可以使用LRU(最近最少使用的)缓存来处理这个问题。"</p><p id="35a1" class="kv kw mr kx b ky kz jr la lb lc ju ld ms lf lg lh mt lj lk ll mu ln lo lp lq ij bi translated"><a class="ae mv" href="https://www.raywenderlich.com/books/design-patterns-by-tutorials/v3.0/chapters/18-flyweight-pattern" rel="noopener ugc nofollow" target="_blank">雷·温德里奇</a></p></blockquote><h1 id="6afb" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">基本设计</h1><p id="0309" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在高层次上，设计既有内在状态，也有外在状态。使用内部状态的引用类型。</p><p id="de12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您不能使用<em class="mr"> Struct </em>或<em class="mr"> Enum </em>，因为它们会自动被引用复制，导致Flyweight试图解决的问题。在这种情况下，外在状态将包含可变属性。</p><h1 id="89bc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">例子</h1><p id="80e9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated"><code class="fe mw mx my mz b">UIColor</code>使用Flyweight模式，因为颜色不会发生变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="c333" class="ng ls iq mz b gy nh ni l nj nk">Console Output:</span><span id="86d6" class="ng ls iq mz b gy nl ni l nj nk">Same instance!</span></pre><p id="1751" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe mw mx my mz b">===</code>我们可以比较两边在内存中是完全相同的实例，而不仅仅是彼此的副本。所以，我们已经证明了<code class="fe mw mx my mz b">redColorOne</code>和<code class="fe mw mx my mz b">redColorTwo</code>指向内存中的同一个地址。</p><h1 id="aa83" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">如何重构现有代码</h1><p id="8673" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们把轻量级模式付诸实践。在Xcode 中创建一个新的游乐场，并定义一个名为<code class="fe mw mx my mz b">Tesla</code>的类。我们将从这个类开始，然后重构使用Flyweight模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4b37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一步是将对象的不可变部分从可变属性集中分离出来。</p><p id="69fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">永远不会改变的部分可以存储在Flyweight中，客户机可以管理可变属性，在必要时将它们传递给Flyweight。</p><p id="e511" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要一个地方来存储初始化的flyweight对象。<code class="fe mw mx my mz b">HashMap</code>使用键/值配对(KVP ),在访问内存中的底层值时比数组有效得多，所以让我们在这个例子中使用HashMap。</p><p id="0f03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为奖励，我们可以使用<code class="fe mw mx my mz b">identifier</code>作为键，这样更容易维护。添加名为<code class="fe mw mx my mz b">gigaFactory</code>的新私有收藏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="14d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在UIColor示例中，<code class="fe mw mx my mz b">UIColor.red</code>是一个静态函数。在分配属性时，最佳实践是依靠类型推断，所以添加类型的三个静态属性:<code class="fe mw mx my mz b">Tesla</code>。(我们还没有写<code class="fe mw mx my mz b">build(_:)</code>方法。但不用担心，这是下一步)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="467a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步是管理对flyweights的访问。让我们制定那个<code class="fe mw mx my mz b">build(_:)</code>方法。它将检查我们的<code class="fe mw mx my mz b">gigafactory</code>,查看请求的车辆是否已经存在。</p><p id="ad9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果是，则返回它，否则，实例化一个新的，并在更新集合以包含新车辆后返回它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">工厂方法返回先前存储的Tesla实例或实例化/返回新实例。</p></figure><p id="03a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构建并运行应用程序。每个<code class="fe mw mx my mz b">Tesla</code>只加载一次，不会注册多次。</p><p id="4637" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您已经成功缩短了应用的处理和加载时间！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="cb83" class="ng ls iq mz b gy nh ni l nj nk">Console Output:<br/>true   // 1<br/>false  // 2<br/>false  // 3<br/>true   // 4</span></pre></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="2200" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望你对轻量级结构模式的理解更加自信。</p><h1 id="186c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">纪念</h1><ul class=""><li id="8b2d" class="nt nu iq kx b ky mj lb mk le nv li nw lm nx lq ny nz oa ob bi translated">Flyweight模式最小化了内存使用和处理。</li><li id="2965" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">这个模式有称为flyweights的对象，以及返回它们的静态方法。这是单例模式的变体。</li><li id="a170" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">当创建flyweight时，要注意你的flyweight内存的大小。如果你存储了几个flyweight，仍然有可能在flyweight存储中使用太多的内存。</li><li id="5709" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">flyweights的例子包括缓存图像等对象，或者在内存中保存一个对象池以便快速访问。</li><li id="c753" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">轻量级在UIKit中很常见。<code class="fe mw mx my mz b">UIColor</code>、<code class="fe mw mx my mz b">UIFont</code>和<code class="fe mw mx my mz b">UITableViewCell</code>都是带有flyweights的类的例子。</li></ul></div></div>    
</body>
</html>