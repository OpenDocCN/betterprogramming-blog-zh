<html>
<head>
<title>8 Best Practices Every React Developer Should Follow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个React开发人员应该遵循的8个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-best-practices-every-react-developer-should-follow-44177670c646?source=collection_archive---------1-----------------------#2021-10-12">https://betterprogramming.pub/8-best-practices-every-react-developer-should-follow-44177670c646?source=collection_archive---------1-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c41d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写更好的React代码的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c04206867e09edf832456396c364eb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgoipL3m00_D1uDBRg6FIg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://www.freepik.com/" rel="noopener ugc nofollow" target="_blank"> Freepik </a></p></figure><h1 id="7d1a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.使用状态更新的回调语法</h1><p id="5c07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当一个组件的下一个状态依赖于前一个状态时，总是传递一个函数给<code class="fe mn mo mp mq b">setState</code>，不要直接设置状态。下面的代码向您展示了原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4300" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">组件分解</p><ul class=""><li id="22c2" class="my mz it lt b lu mt lx mu ma na me nb mi nc mm nd ne nf ng bi translated">我们有一个状态变量<code class="fe mn mo mp mq b">count</code></li><li id="cee7" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated"><code class="fe mn mo mp mq b">count</code>可以通过两个按钮递增</li><li id="f24e" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated"><code class="fe mn mo mp mq b">Increment</code>按钮会立即更新状态</li><li id="f8bd" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated"><code class="fe mn mo mp mq b">Increment Lazy</code>按钮模仿异步操作，并在一秒半后更新状态</li></ul><p id="d1bc" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">这很简单，不是吗？但这里的问题如下:</p><ul class=""><li id="c4e9" class="my mz it lt b lu mt lx mu ma na me nb mi nc mm nd ne nf ng bi translated">假设当前计数是2</li><li id="82b9" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">我点击<code class="fe mn mo mp mq b">Increment Lazy</code>按钮，点击该按钮后，我立即点击<code class="fe mn mo mp mq b">Increment</code>按钮</li><li id="ab0b" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated"><code class="fe mn mo mp mq b">Increment</code>按钮将当前计数更新为3</li><li id="34e2" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">因为我点击了<code class="fe mn mo mp mq b">Increment Lazy</code>按钮，它应该在一秒半后将计数增加到四</li></ul><p id="0952" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">但是这并没有发生，因为当我点击<code class="fe mn mo mp mq b">Increment Lazy</code>按钮时，<code class="fe mn mo mp mq b">count</code>是2，JavaScript将使用这个值来递增。因此，一秒半后，<code class="fe mn mo mp mq b">Increment Lazy</code>处理器再次将状态设置为3。</p><p id="a7ce" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">这不是我们想要的，并且会导致很难捕捉的错误。因此，作为最佳实践，当下一个值依赖于前一个值时，总是使用回调语法。</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="eab9" class="nq la it mq b gy nr ns l nt nu">// follow this approach<br/>&lt;button onClick={() =&gt; {<br/>  setTimeout(() =&gt; {<br/>    <strong class="mq iu">setCount(prevCount =&gt; prevCount + 1);</strong><br/>    }, 1500);<br/>  }}&gt;<br/>  Increment lazy<br/>&lt;/button&gt;</span></pre><p id="f573" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated"><code class="fe mn mo mp mq b">prevCount</code>参数确保您每次都能获得<code class="fe mn mo mp mq b">count </code>的正确值。</p><p id="af3a" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated"><a class="ae ky" href="https://codesandbox.io/s/xenodochial-ardinghelli-5be8m?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">这里是上面代码</a>的沙箱。</p><h1 id="1e82" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.用正确的数据结构初始化状态</h1><p id="4904" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用正确类型的数据结构作为状态变量的初始值是很重要的。下面是许多初学者和开发人员遇到的一个常见问题的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6750" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们没有为todos设置任何初始值。因为React首先渲染JSX，然后运行导致错误的效果。我们可以通过设置一个空数组作为初始值来解决这个错误。</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="3916" class="nq la it mq b gy nr ns l nt nu">const [todos, setTodos] = useState([]);</span></pre><p id="27b5" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">注意，我给了一个数组作为初始值，而不是一个对象。如果给定一个空对象作为数组数据结构的初始值，在映射数据时可能会出错。</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="8040" class="nq la it mq b gy nr ns l nt nu"><strong class="mq iu">// using wrong data structure as initial value</strong><br/>const [todos, setTodos] = useState(<strong class="mq iu">{}</strong>);</span><span id="2b52" class="nq la it mq b gy nv ns l nt nu">return (<br/> <strong class="mq iu">// throws error: todos.map is not a function</strong><br/> {todos.map()}<br/>);</span></pre><p id="9fae" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">因此，请始终使用您以后希望用于状态变量的数据结构。</p><p id="284e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如果您最初需要以编程方式计算数据的类型，请向<code class="fe mn mo mp mq b">useState</code>钩子传递一个回调函数</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="ba8c" class="nq la it mq b gy nr ns l nt nu">const [todos, setTodos] = useState(() =&gt; {<br/>  // whatever you return from this function<br/>  // will be used as the initial value</span><span id="c0a0" class="nq la it mq b gy nv ns l nt nu">  return [];<br/>});</span></pre><p id="6424" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">它还提高了代码的可读性。您可以看到状态变量的定义，并知道它包含什么类型的数据。</p><h1 id="030c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.使用关键道具</h1><p id="b139" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">属性让React识别列表中的每个元素。由于DOM操纵操作开销很大，React在内存中维护了一个虚拟DOM的副本。</p><p id="c7d3" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">考虑下面的待办事项列表:</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="9e45" class="nq la it mq b gy nr ns l nt nu">&lt;ul&gt;<br/>  &lt;li&gt;Breakfast&lt;/li&gt;<br/>  &lt;li&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="4c1c" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">现在，让我们向列表中添加一个新项目:</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="2266" class="nq la it mq b gy nr ns l nt nu">&lt;ul&gt;<br/>  &lt;li&gt;Exercise&lt;/li&gt;<br/>  &lt;li&gt;Breakfast&lt;/li&gt;<br/>  &lt;li&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="3d85" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">当新项目添加到列表中时，会发生以下情况</p><ul class=""><li id="1a6f" class="my mz it lt b lu mt lx mu ma na me nb mi nc mm nd ne nf ng bi translated">React将虚拟DOM中的<code class="fe mn mo mp mq b">&lt;li&gt;Breakfast&lt;/li&gt;</code>与更新后的虚拟DOM中的<code class="fe mn mo mp mq b">&lt;li&gt;Exercise&lt;/li&gt;</code>进行比较</li><li id="4b53" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">这个比较告诉React列表项被改变了</li><li id="60e6" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">React将重新绘制DOM中的所有列表项</li></ul><p id="b28c" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">这是非常低效的，因为React必须重新绘制所有的列表项。为了解决这个问题，我们可以给一个<code class="fe mn mo mp mq b">key</code>属性一个值，这个值在它的兄弟中唯一地标识一个列表项。</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="3f8b" class="nq la it mq b gy nr ns l nt nu">&lt;ul&gt;<br/>  &lt;li key="ex"&gt;Exercise&lt;/li&gt;<br/>  &lt;li key="bf"&gt;Breakfast&lt;/li&gt;<br/>  &lt;li key="lu"&gt;Lunch&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="ddb7" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">现在，当您添加一个带有键的列表项时，React将只是向DOM添加新元素，而不是再次操作DOM中的所有项。对大型列表不使用key prop会导致呈现问题。</p><h1 id="40c1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.使用去抖</h1><p id="9502" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这并不是React特有的做法，但是我见过许多开发人员不利用去抖功能。下面是从<a class="ae ky" href="https://stackoverflow.com/a/25991510/2924393" rel="noopener ugc nofollow" target="_blank">这个栈溢出的反跳答案</a>:</p><blockquote class="nw nx ny"><p id="28a2" class="lr ls nz lt b lu mt ju lw lx mu jx lz oa mv mc md ob mw mg mh oc mx mk ml mm im bi translated">“去抖将把对一个函数的一系列连续调用串成对该函数的单个调用。它可以确保针对多次触发的事件发出一次通知。</p></blockquote><p id="0167" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">让我们考虑下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="635b" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">假设每次输入值发生变化时，您都请求搜索客户列表。如果您不去抖这个函数，那么您将会收到大量无用的请求，因为<code class="fe mn mo mp mq b">onChange</code>事件触发得如此频繁。</p><p id="1bd4" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">要在React中消除事件处理程序的抖动，您可以执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="345d" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">现在，我们只在用户一秒钟没有输入任何内容的情况下向服务器发出一个请求。</p><p id="c7d5" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们必须在<code class="fe mn mo mp mq b">useMemo</code>中包装我们的公开回调，以防止React在每次重新渲染时创建新的函数引用。我用的是lodash 的<a class="ae ky" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖，你也可以自己创建。</a></p><h1 id="c450" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.效果清理</h1><p id="e561" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当效果的依赖关系发生变化或定义该效果的组件被卸载时，将调用效果的清理功能。在类组件中，通常会使用生命周期方法<code class="fe mn mo mp mq b">componentWillUnmount</code>来执行清理。</p><p id="5f98" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">让我们考虑一个添加和删除事件侦听器的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="29f3" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">这样，我们也避免了内存泄漏。</p><h1 id="a159" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.使用道具类型</h1><p id="8a87" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用prop类型可以避免许多愚蠢的错误。如果你已经在使用typescript，那么不使用prop类型也可以，但是对于JavaScript，prop类型是必须的。</p><p id="2ba1" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">安装一个包<code class="fe mn mo mp mq b">prop-types</code>并给组件分配一个特殊的属性<code class="fe mn mo mp mq b">propTypes</code>，用于定义组件属性的类型定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="75f2" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如果您不小心将此人的<code class="fe mn mo mp mq b">age</code>作为字符串传递，您将在浏览器控制台中看到一条警告。</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="3465" class="nq la it mq b gy nr ns l nt nu">// throws a warning that age is not a number<br/>&lt;Person name="Haseeb" age="15" /&gt;</span></pre><p id="a13d" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">此外，它还帮助您的代码编辑器自动完成。如果定义了组件的属性类型，那么VSCode会建议您可以传递给组件的属性列表。</p><p id="e6e2" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如果你不太了解道具类型，那么<a class="ae ky" href="https://javascript.plainenglish.io/the-complete-guide-to-prop-types-in-react-9baa22e80ce4" rel="noopener ugc nofollow" target="_blank">这里有一个完整的道具类型指南。</a></p><h1 id="807b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.用React方式构建您的代码库</h1><p id="8caf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">始终遵循React构建React应用程序的方式。以下是我喜欢在任何React应用程序中使用的结构:</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="f0e6" class="nq la it mq b gy nr ns l nt nu">public<br/>src<br/>  └── components<br/>     └── customers<br/>           - customer related components<br/>     └── orders<br/>           - order related components<br/>  └─ hocs<br/>        - any higher order components<br/>  └── pages<br/>        - app pages<br/>  └── styles<br/>        - stylesheets<br/>  └── utils<br/>        - utility related files</span></pre><p id="02b6" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">有些人尝试使用Angular的服务和组件方法，如下所示:</p><pre class="kj kk kl km gt nm mq nn no aw np bi"><span id="32b5" class="nq la it mq b gy nr ns l nt nu">// wrong component name<br/>my-component.component.js</span><span id="0c0c" class="nq la it mq b gy nv ns l nt nu">// should be<br/>MyComponent.js</span><span id="28a1" class="nq la it mq b gy nv ns l nt nu">// AND do not create services<br/>john-doe.service.js</span></pre><p id="a24e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">这是不好的反应。我读过的所有React文档(以及我目前参加的课程)都没有展示过这种命名文件的方法。一个结构良好的代码库更容易理解，对开发者体验(DX)非常重要。</p><h1 id="60e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">8.保持你的组件简短</h1><p id="b28b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">冗长的组件使得逻辑更难理解，调试更糟糕。保持组件简短并专注于做一件事总是一个好的实践。</p><p id="744d" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">以下是您应该将一个大组件分解成小组件的时机:</p><ul class=""><li id="b462" class="my mz it lt b lu mt lx mu ma na me nb mi nc mm nd ne nf ng bi translated">当逻辑变得难以理解时</li><li id="5ba7" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">当您的组件做得太多时</li><li id="8c86" class="my mz it lt b lu nh lx ni ma nj me nk mi nl mm nd ne nf ng bi translated">由此产生的小组件可以重复使用</li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="04b0" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">感谢阅读。我希望你觉得这篇文章很有用，并从中学到了一些东西。</p><h1 id="3bc3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">进一步阅读</h1><div class="ok ol gp gr om on"><a href="https://haseeb-anwar.medium.com/react-router-6-features-upgradation-guide-886b9bc2fb71" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">React路由器6功能和升级指南</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">迄今为止最强大的React客户端路由器</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">haseeb-anwar.medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-keys-virtual-dom-reconciliation-and-diffing-in-react-e65a9bee316f"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">理解键、虚拟DOM、协调和差异</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">React开发人员的基本概念</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>