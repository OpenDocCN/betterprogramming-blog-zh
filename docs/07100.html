<html>
<head>
<title>How to Follow the Dependency Inversion Principle in NestJS and Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何遵循NestJS和Angular中的依存倒置原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-follow-the-dependency-inversion-principle-in-nestjs-and-angular-8d344303dc3b?source=collection_archive---------8-----------------------#2020-12-07">https://betterprogramming.pub/how-to-follow-the-dependency-inversion-principle-in-nestjs-and-angular-8d344303dc3b?source=collection_archive---------8-----------------------#2020-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5725" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持你的模块独立，抽象无细节</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/504c972c7162afd1ab22d2a3e058c930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlE9mdnSmRLX6znCh9UAcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="11c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae lr" href="https://docs.nestjs.com/#philosophy" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中，我们可以找到下面这句话:</p><blockquote class="ls lt lu"><p id="a910" class="kv kw lv kx b ky kz jr la lb lc ju ld lw lf lg lh lx lj lk ll ly ln lo lp lq ij bi translated">“Nest提供了开箱即用的应用程序架构，允许开发人员和团队创建高度可测试、可伸缩、松散耦合且易于维护的应用程序。”</p></blockquote><p id="ede5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过检查Nest是否允许我们容易地遵循一个可靠的原则来测试这个声明:依赖倒置原则。</p><p id="0d59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Nest深受Angular的启发，因此本文中的所有食谱也适用于Angular。</p><p id="3bd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快速提醒一下，<a class="ae lr" href="https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf" rel="noopener ugc nofollow" target="_blank">原则</a>规定:</p><ol class=""><li id="4ef6" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。</li><li id="b488" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq me mf mg mh bi translated">抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。</li></ol></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="2c1d" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">例子</h1><p id="f478" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">为了解释如何实现DIP，让我们首先考虑下面的例子。<br/>我们创建了一个应用程序，它将分析关于GitHub平台上的存储库的数据。我们当前的任务是实现一个端点，它将返回给定存储库的活动pull请求的数量。</p><p id="daee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该功能可以快速实现，如下所示，但它不符合我们的原则:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="78e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使将HTTP调用转移到专用服务，也不是对控制器隐藏实现的适当方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="69e5" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">依赖倒置原则的实现</h1><p id="ddba" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">正确的实现应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ol class=""><li id="439c" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq me mf mg mh bi translated">我们需要创建一个抽象层来获取拉请求的集合。这个抽象是通过<code class="fe nt nu nv nw b">RepositoryService</code>抽象类实现的。</li><li id="4377" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq me mf mg mh bi translated">对于<code class="fe nt nu nv nw b">AppController</code>，我们试图注入一些被<code class="fe nt nu nv nw b">RepositoryService</code>注入令牌隐藏的东西。</li><li id="6210" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq me mf mg mh bi translated"><code class="fe nt nu nv nw b">GithubInfrastructureModule</code>说在那个地方，应该提供一个<code class="fe nt nu nv nw b">GithubRepositoryService</code>级。</li></ol><p id="562e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，但是为什么我们不能使用一个普通的接口作为抽象层呢？</p><p id="db6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">答案是在从TypeScript到JavaScript的转换过程中接口会发生什么。问题是，我们将丢失所有关于<code class="fe nt nu nv nw b">RepositoryService</code>接口存在的信息以及应该注入到<code class="fe nt nu nv nw b">AppController</code>中的信息，而且基本上，不可能在模块提供者内部将接口作为属性值传递。</p><p id="1484" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上课的时候情况就完全不一样了。即使是transpilation后的抽象类，也会是一个普通的类，可以作为注入令牌使用。在TypeScript中，我们可以通过与接口相同的另一个类来实现一个类。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="5622" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">为什么这如此重要？</h1><p id="ca98" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">假设我们的应用程序的需求发生了变化。我们还需要支持存储在Bitbucket上的存储库作为专用的应用程序实例。如果我们没有更早地添加它，现在我们将不得不在我们的服务和控制器中添加许多<code class="fe nt nu nv nw b">ifs</code>来为所需的数据准备一个适当的HTTP调用。</p><p id="aa7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个优雅隐藏的数据源层，我们就可以为Bitbucket的服务创建一个专用模块，并正确地导入我们的特征模型，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="09bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在<code class="fe nt nu nv nw b">GithubRepositoryService</code>或<code class="fe nt nu nv nw b">BitbucketRepositoryService</code>将根据环境注入到<code class="fe nt nu nv nw b">AppController</code>中，外层代码没有任何变化。</p><p id="2972" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在角度应用中，这一点适用于以下情况:</p><ul class=""><li id="f5fb" class="lz ma iq kx b ky kz lb lc le mb li mc lm md lq nx mf mg mh bi translated">我们正在创建web和移动应用程序，它们以不同的方式加载数据。</li><li id="3f0a" class="lz ma iq kx b ky mi lb mj le mk li ml lm mm lq nx mf mg mh bi translated">我们正在用SSR构建一个应用程序。在服务器端接收数据的同时，我们也想将它们保存在<code class="fe nt nu nv nw b">TransferState</code>中。而在浏览器端，我们希望从它那里获得。</li></ul><p id="754b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这两种情况下，遵循依赖倒置原则将帮助我们实现并减少使用我们的数据访问层的高级模块中的更改和逻辑。唯一的区别是，我们基本上不应该依赖环境来决定应该导入哪个模块。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="1255" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">摘要</h1><p id="d9fa" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">遵循坚实的原则会给我们带来很多好处。此外，它们使我们的系统可重用、可维护、可伸缩、可测试，等等。Nest和Angular允许我们以一种简单而优雅的方式使用它们。</p><p id="d237" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你对我们如何在同一个应用实例中使用<code class="fe nt nu nv nw b">GithubRepositoryService</code>和<code class="fe nt nu nv nw b">BitbukcetRepositoryService</code>感兴趣，请查看<a class="ae lr" href="https://github.com/valueadd-poland/pimp-my-pr/blob/2.0.1/libs/server/repository/core/application-services/src/lib/queries/get-repository-statistics/get-repository-statistics.handler.ts#L27" rel="noopener ugc nofollow" target="_blank">这个报告</a>。</p><p id="276e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">毕竟Nest的文档里的说法可以认为是一个真理！</p></div></div>    
</body>
</html>