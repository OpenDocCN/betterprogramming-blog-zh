<html>
<head>
<title>Implementing Type-level Computation in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Haskell中实现类型级计算</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-level-computation-in-haskell-e96203cf4b9a?source=collection_archive---------8-----------------------#2022-12-02">https://betterprogramming.pub/type-level-computation-in-haskell-e96203cf4b9a?source=collection_archive---------8-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">静态检查数学运算的有效性，并对一般数据类型实施约束</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f633c68fe0a074a59f132d10603fbb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kCdAY1D4YHfBKQ9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@volkanolmez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沃尔坎·奥尔梅斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ce9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Haskell是一种静态类型的函数式编程语言，以其类型级的计算能力而闻名。</p><p id="35d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我们将探索如何在Haskell中实现类型级算法，它允许我们在类型级执行计算，并将它们编码为类型。</p><p id="c129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在各种场景中都很有用，比如静态检查数学运算的有效性、对通用数据类型施加约束等等。要理解Haskell中的类型级运算，首先理解什么是类型级计算是很重要的。</p><p id="6e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Haskell中，类型系统是一个强大的工具，它允许我们对程序的各种静态保证进行编码。</p><p id="3eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用类型系统来定义新的类型，并指定它们之间的关系，使编译器能够在编译时而不是运行时捕捉错误。</p><p id="945f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型级计算是一种类型级编程范式，它允许我们像处理一级值一样处理类型。这意味着我们可以定义对类型进行操作并返回新类型作为结果的函数。我们还可以定义类型类和实例，使我们能够以模块化和可扩展的方式执行类型级计算。</p><p id="5aa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Haskell中类型级计算的一个关键特性是定义类型级数字的能力。这些是在类型级别表示自然数的特殊类型，它们使我们能够执行类型级别的算术。Haskell中的类型级数字通常使用一种称为“peano numbers”的技术来定义，这是一种使用一系列嵌套数据类型声明来表示自然数的方法。</p><p id="b094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个例子，说明我们如何使用peano表示在Haskell中定义类型级别的数字:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="f8ef" class="lx ly iq lt b be lz ma l mb mc">data Zero<br/>data Succ a</span></pre><p id="22aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些声明定义了两种新的数据类型:<code class="fe md me mf lt b">Zero</code>和<code class="fe md me mf lt b">Succ a</code>。<code class="fe md me mf lt b">Zero</code>类型表示数字0，而<code class="fe md me mf lt b">Succ a</code>类型用于表示类型级别数字<code class="fe md me mf lt b">a</code>的后继者。例如，类型<code class="fe md me mf lt b">Succ Zero</code>代表数字1，<code class="fe md me mf lt b">Succ (Succ Zero)</code>代表数字2，依此类推。</p><p id="cf30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们定义了类型级别的数字，我们就可以通过定义操作它们的函数来实现类型级别的算术。例如，我们可以如下定义类型级加法函数:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="361b" class="lx ly iq lt b be lz ma l mb mc">type family Add a b where<br/>  Add Zero b = b<br/>  Add (Succ a) b = Succ (Add a b)</span></pre><p id="a86b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数是使用类型族定义的，类型族是Haskell中的一个特殊构造，它允许我们定义对类型进行操作的函数。<code class="fe md me mf lt b">Add</code>类型族将两个类型级别编号<code class="fe md me mf lt b">a</code>和<code class="fe md me mf lt b">b</code>作为其参数，并返回一个新的类型级别编号作为其结果。</p><p id="db28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe md me mf lt b">Add</code>的定义使用了两个等式，它们定义了对于不同的输入类型，函数应该如何表现。第一个等式说，如果<code class="fe md me mf lt b">a</code>是<code class="fe md me mf lt b">Zero</code>，那么<code class="fe md me mf lt b">Add a b</code>的结果应该是<code class="fe md me mf lt b">b</code>。这个等式编码了一个数学事实，即任何数字加0都不会改变它的值。</p><p id="e28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个等式说如果<code class="fe md me mf lt b">a</code>是<code class="fe md me mf lt b">Succ a'</code>，那么<code class="fe md me mf lt b">Add a b</code>的结果应该是<code class="fe md me mf lt b">Succ (Add a' b)</code>。这个等式编码了一个数学事实，即一个数加1等于加1。</p><p id="be37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明Haskell中类型级算法的强大功能，让我们考虑一个更复杂的例子。假设我们想要定义一个通用的<code class="fe md me mf lt b">Vector</code>数据类型，它存储一个固定长度的数字列表。我们可以使用类型级算术来静态地确保列表的长度总是正确的，即使向量是由类型级数字参数化的。</p><p id="7832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们如何定义<code class="fe md me mf lt b">Vector</code>数据类型:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="df65" class="lx ly iq lt b be lz ma l mb mc">data Vector (n :: Nat) a where<br/>  Nil  :: Vector Zero a<br/>  Cons :: a -&gt; Vector n a -&gt; Vector (Succ n) a</span></pre><p id="fc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该声明使用种类为<code class="fe md me mf lt b">Nat</code>(自然数的缩写)的类型参数<code class="fe md me mf lt b">n</code>定义了<code class="fe md me mf lt b">Vector</code>数据类型，表示向量的长度。<code class="fe md me mf lt b">Vector</code>数据类型有两个构造函数:<code class="fe md me mf lt b">Nil</code>，表示空向量，和<code class="fe md me mf lt b">Cons</code>，在向量前面加一个元素。</p><p id="bf15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe md me mf lt b">Nil</code>构造函数有一个<code class="fe md me mf lt b">Vector Zero a</code>类型，这意味着它只能用来创建长度为0的向量。类似地，<code class="fe md me mf lt b">Cons</code>构造函数有一个<code class="fe md me mf lt b">Vector (Succ n) a -&gt; Vector n a -&gt; Vector (Succ n) a</code>类型，这意味着它只能用来创建长度比它要添加的向量的长度大一的向量。</p><p id="cecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着<code class="fe md me mf lt b">Vector</code>的长度是静态编码在它的类型中的。例如，如果我们有一个类型为<code class="fe md me mf lt b">Vector (Succ (Succ Zero)) Int</code>的值，我们知道它是一个长度为2的向量，用来存储<code class="fe md me mf lt b">Int</code>的值。这意味着我们可以使用类型级算法对向量的长度进行静态检查。</p><p id="377d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们想要定义一个将两个相同长度的向量相加的函数。我们可以使用类型级算术来确保向量具有相同的长度，并计算结果向量的长度。下面是我们实现这个函数的方法:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="332a" class="lx ly iq lt b be lz ma l mb mc">addVectors :: Vector n a -&gt; Vector n a -&gt; Vector n a<br/>addVectors Nil Nil = Nil<br/>addVectors (Cons x xs) (Cons y ys) = Cons (x + y) (addVectors xs ys)</span></pre><p id="d20c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe md me mf lt b">addVectors</code>的实现使用模式匹配来解构输入向量，并递归地添加它们的元素。注意，<code class="fe md me mf lt b">addVectors</code>的类型是<code class="fe md me mf lt b">Vector n a -&gt; Vector n a -&gt; Vector n a</code>，这意味着它期望其输入向量具有相同的长度<code class="fe md me mf lt b">n</code>。这个长度被静态地编码在输入向量的类型中，因此编译器可以确保向量在编译时具有相同的长度。</p><p id="0397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以使用类型级算法来计算结果向量的长度。由于<code class="fe md me mf lt b">addVectors</code>函数简单地将输入向量的相应元素相加，结果向量的长度将与输入向量的长度相同。我们可以通过将结果类型设置为<code class="fe md me mf lt b">Vector n a</code>来将这一事实编码到<code class="fe md me mf lt b">addVectors</code>的类型中，其中<code class="fe md me mf lt b">n</code>是出现在输入类型中的同一类型级别编号。</p><h1 id="bb88" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="7757" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">总之，在Haskell中实现类型级算术允许我们在类型级执行计算，并将它们编码为类型。这对于静态检查数学运算的有效性和对通用数据类型实施约束来说是一个强大的工具。通过对类型级别的数字使用peano表示，并定义类型族来对它们执行算术运算，我们可以很容易地在Haskell中实现各种类型级别的算术函数。</p><p id="8774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还看到了这对于实现通用数据类型是如何有用的，比如我们的<code class="fe md me mf lt b">Vector</code>数据类型。通过在类型级别对向量的长度进行编码，我们可以使用类型级别的算术来静态地确保我们的<code class="fe md me mf lt b">addVectors</code>函数只应用于相同长度的向量。这有助于防止运行时错误，并使我们的程序更加健壮和正确。</p></div></div>    
</body>
</html>