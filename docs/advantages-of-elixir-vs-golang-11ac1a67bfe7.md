# 长生不老药相对于 Golang 的优势

> 原文：<https://betterprogramming.pub/advantages-of-elixir-vs-golang-11ac1a67bfe7>

## 两种较新的语言，我们来比较一下

![](img/085d9430cf03094753dbc655865a2910.png)

照片由[耶鲁安穴獭](https://unsplash.com/@jeroendenotter?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/comparison?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

一个潜在客户最近问我[仙丹](https://elixir-lang.org/)比 [Golang](https://golang.org/) 有什么优势。

简单的答案是*生产力*。你得到了两个世界的最好的东西:高级语言的生产力和成熟的 Erlang 平台的伸缩能力。

Go 是一种低级语言，性能很好，但是它缺乏现代语言的生产力特性。它是为谷歌规模的相对低级的服务开发的，例如 HTTP 路由基础设施。

当你以他们的规模操作时，你需要性能，但是 C++的复杂性很难处理。您需要并发，但是多线程网络编程容易出错。我花了几年时间用 C++做 VoIP 应用，所以我知道这种痛苦。

这也是对智能 C++和 Java 程序员创建抽象概念的趋势的一种反应，随着时间的推移，这些抽象概念会使系统更难维护。这些层次使得很难跳入一个大的代码库并解决问题。

对于不仅仅是程序员的 sre 来说，这是一个特别的问题，他们还必须应对云基础架构、网络、存储等挑战。

像 Python 这样的高级脚本语言很难大规模操作。它们受到性能差和缺乏并发性的困扰。动态类型使得运行时很难避免错误，需要大量的测试。

依赖性使得它们很难部署，所以简单地将二进制文件复制到服务器的能力非常有吸引力。

Go 基本上是 C++的简化版，c++是一种“蓝领”语言。[Go 编程语言](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440)是这样描述的:

> “Go 项目包括语言本身、它的工具和标准库，最后但同样重要的是，一个彻底简单的文化议程。
> 
> 作为一门新兴的高级语言，Go 具有后知之明，而且基础做得很好:它有垃圾收集、包系统、一流的函数、词法范围、系统调用接口和不可变的字符串，其中文本通常以 UTF-8 编码。
> 
> 但它的功能相对较少，不太可能增加更多。例如，它没有隐式数字转换，没有构造函数或析构函数，没有运算符重载，没有默认参数值，没有继承，没有泛型，没有异常，没有宏，没有函数注释，没有线程本地存储。
> 
> 这种语言是成熟和稳定的，并保证了向后兼容性:旧的 Go 程序可以用新版本的编译器和标准库编译和运行。"

围棋中有一种“抱残守缺”的态度。大规模部署大型系统很糟糕，所以我们选择简单的工具，这些工具将一直工作并解决问题。

我能理解这种视角，但我没有那么愤世嫉俗。它忽略了我们可以通过现代编程语言特性获得的生产力和安全性的提高。

爱立信在创建 Erlang(长生不老药的基础)时也遇到了类似的问题。他们一直在用低级语言构建他们的电话交换机，这种情况正在失去控制。这些系统复杂、漏洞百出，而且开发成本高昂。

他们的解决方案是将低级运行时与高级语言和框架相结合，以一劳永逸地处理网络和并发性问题，从而使编程更容易。

Erlang 的显著特点是并发性和容错性。轻量级流程模型使得创建可扩展到数百万有状态连接的系统变得简单，例如 WhatsApp。

该平台拥有丰富的工具来创建、调试和管理大型生产系统。OTP 框架标准化了用组件构建服务的模式。

该平台包括内存中的键/值存储、进程注册表等特性。，以及针对生产系统跟踪、大容量日志记录、警报和指标等问题的内置解决方案。

Elixir 从成熟的 Erlang 平台开始，并添加了强大的语言特性，如 lisp 风格的宏和协议。我们获得了面向对象语言的易用性，没有组件之间的紧密耦合。

函数式编程为我们提供了适用于所有数据的通用算法。模式匹配使逻辑更简单。二进制匹配语法使得以高性能可靠地实现网络协议变得容易。

不变性和无副作用使得系统更容易推理和调试。与学术函数式语言不同，如 Haskell T1，这种语言专注于实用的工业编程，而不是类型理论。

数据结构简单易懂。每个人都在谈论并发性，因为它很特别，但是这种语言本身确实是一种编程乐趣。

作为一个例子，Go [中的错误处理看起来像这样](https://github.com/confluentinc/confluent-kafka-go):

```
c, err := foo.Client()
if err != nil {
    panic(err)
}
msg, err := c.Request(foo, bar)
if err == nil {
    fmt.Printf("Message on %s: %s\n", msg.Topic, string(msg.Value))
} else {
    fmt.Printf("Client error: %v (%v)\n", err, msg)
    break
}
```

Elixir 中的等价代码简单地说就是:

```
{:ok, conn} = Foo.Client.connect()
{:ok, result} = Foo.Client.request(conn, foo, bar)
```

Elixir 的模式匹配让我们为成功案例编程。如果我们得到一个错误返回(例如`{:error, reason}`，那么未处理的匹配将失败，线程将退出。它会将调用的所有上下文写回日志，这样我们就可以在我们的开发环境中重现这个问题。

主管监控流程并管理所有错误，包括我们可能遗漏的错误。这不同于异常，因为它允许我们实际处理错误，例如，在连接超时时重试调用。

Elixir 正在借此机会重新思考和完善一个已建立的系统。成熟的语言是随着时间积累的。

例如，Java 有多个日期-时间类(`java.util.Date`、`java.sql.Date`、`Calendar`)，我们必须在它们之间进行转换。函数有不同顺序的参数，所以我们必须继续查看文档。

当微软创造 C#和。NET，他们受益于从 Java 中学习，这帮助他们快速创建一个完整的、一致的标准库和虚拟机。

Elixir 为 Erlang 做到了这一点，但也可以利用所有现有的 Erlang 库。

类似地，很多 Elixir 社区来自 Rails，因为 Elixir 的创建者 José Valim 是 Rails 的提交者。他从成熟的 Rails 系统开始，又做了一次，做得更好，专注于他在维护大型 Rails 项目时遇到的问题，这些项目随着时间的推移而发展。

该平台具有更好的性能和可靠性，但也在“魔法”上后退了一步，因为一些使简单项目变得容易的功能最终会在项目变大时引发问题。

除了标准的 MVC，[凤凰网框架](http://phoenixframework.org/)提供了一个“通道”抽象，使得创建有状态的网络应用变得容易，例如，网络聊天系统。还有一个与 Phoenix 集成的 GraphQL 服务器。

和 Ruby on Rails 一样，程序员的生产力和易用性是社区关注的焦点。一切开箱即用，并且有标准的、集成良好的工具用于测试、资产管道、部署等。

人们从 Ruby 那里获得了他们喜欢的库，并在 Elixir 中实现了它们。还有来自学术界的用于静态分析和属性测试的尖端工具。

对我来说，Golang 最有趣的应用是网络服务，它们需要非常快，也就是说，它们受 CPU 的限制。垃圾收集避免了一大类错误，使其更加安全。

Go 内置了使用 CSP 模型的并发性，它可以非常高效地调用 C 库。好的应用程序是像深度内容检查或运行机器学习模型这样的东西。

当你在大规模运营时，硬件成本实际上开始比程序员的时间更重要。

我们中的大多数人并没有像 Google 那样编写应用程序，但是我们仍然需要有效地使用我们现有的硬件。要做到这一点，我们需要能够处理并发的语言，但当前的语言和平台面临着挑战。

很难让现有的语言和库变得安全，因为它打破了程序员的假设。网络通信库需要重写为非阻塞的或者使用线程。

更糟糕的是，共享数据需要加锁来保护并发访问。这使得现有的脚本语言如 Python、Ruby 和 PHP 很难支持并发性。

Node.js 是围绕非阻塞 IO 构建的，但是如果没有像多进程这样的攻击，就无法利用多个 CPU。暴露的机制太多，语言缺乏类型安全性。

Java 使用与 C++类似的基于线程的并发方法，但是普遍的面向对象给每个对象带来了潜在的锁定问题。

Rust 有潜力作为 C 语言的安全替代品来进行系统编程，并具有并发性。但是，对于一般的应用程序开发效率来说，这个水平太低了。

Elixir 从第一天起就支持并发性，并且拥有 30 多年为 Erlang 开发的工具。虽然绝对性能不如编译语言，但并行化任务以利用机器是很容易的。

如果这还不够，我们可以将应用程序部署到一个服务器集群上，只需稍作修改。这就是*速度*和*扩展性*的区别。Go 关注的是底层性能，依靠 Kubernetes 这样的系统进行扩展。不过，这也有它自己的复杂问题要处理。

在 Elixir 中添加库来完成实际的 web 编程任务比让其他系统并发和可靠要容易得多。

我们现在用它来构建大型系统，我们知道它是有效的。我们可以继续构建下一代系统，而不是为现有语言的并发性而奋斗。