<html>
<head>
<title>Is Recursion Really Slower Than Iteration?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归真的比迭代慢吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-recursion-really-slower-than-iteration-dcd0df3f30d6?source=collection_archive---------13-----------------------#2021-02-18">https://betterprogramming.pub/is-recursion-really-slower-than-iteration-dcd0df3f30d6?source=collection_archive---------13-----------------------#2021-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cedf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一如既往，答案取决于你如何使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be4dff210c4afbecc7fe4fc180624200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EiyMto2n9gK6yTGf.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="49df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们一直在处理这两种编写复杂程序的方法。例如，如果你想反转一个链表，有两种方法。如果你要计算你的博客文章中的赞数，有迭代和递归的算法。</p><p id="6597" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，就速度而言，迭代解法通常比递归解法更快。</p><p id="57cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样——如果你愿意，你可以从这里停止阅读……或者你可以阅读长答案，看看为什么要看情况。</p><p id="e35a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编译器没有尾部递归优化的标准编程语言中，递归调用通常比迭代慢。例如，在Java中，递归调用的代价很高，因为它们不能进行去尾优化。</p><p id="df4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一些函数式编程语言实现中，迭代可能是昂贵的，因为所有的值都是不可变的，并且您需要复制所有的折扣并改变数据。在多线程环境中，迭代的代价可能很高，因为您必须同时处理赋值函数和垃圾收集器。许多函数式语言将递归调用视为跳转，而不是放入堆栈。</p><p id="63b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键是你写的那些值是如何在汇编语言中生成的。</p><p id="c7fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您从零开始构建一个计算值，迭代通常首先作为一个构建块出现，它用在比递归更少资源密集的计算中。</p><p id="466c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于编写计算值的最初方式是过程化的，所以我们首先想到的是创建状态和内存。例如，为了在程序上做一些有用的事情，我们需要存储一些中间或最终的内存。它可以是内存值的数组。</p><p id="c9a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二，如果我们没有任何指令，计算出的值将是无用的。在我的汇编语言课上，ARM汇编语言有MOV、ADD和其他指令来改变你的计算值的状态。然后，我们添加顺序指令(例如跳转和条件语句)来跳转到特定的执行。一个循环中的多个跳转值称为迭代。</p><p id="20a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想写更复杂的计算指令，我们需要有一个子程序来跳转并执行这些步骤。更好的实现是使用堆栈来使用多个嵌套调用。你可以用一个子程序调用另一个子程序，我们称之为函数。</p><p id="b859" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，当子程序调用自己时会发生什么？</p><p id="1735" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">维拉，你得到递归。</p><p id="d2dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，在设计的概念中迭代是第一位的，在过程化的环境中更容易推理。在迭代中，我们不需要在堆栈中存储即时结果。它意味着更少的指导。因此，它的CPU周期更少。</p><p id="5e28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这是在装配线级别。在高级代码中，情况可能不是这样。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8d89" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">当递归调用可以像迭代一样高效时</h1><p id="e373" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">你可以把你的程序构造成尾递归的，让编译器优化，并把它当作一个迭代调用。</p><p id="8dec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尾递归调用是指子例程调用作为过程的最终动作执行。</p><p id="7f1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下。我们有三个函数:A，B，C，函数A调用函数B，函数B调用函数C，如果函数A返回函数B的值，函数B返回函数C的值，那么这个指令就可以归类为尾递归调用。请记住，在每个函数调用中，我们都是将之前的进程存储到一个堆栈中。如果我们在调用函数C后不做任何额外的操作，保持那个值就是浪费空间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/83bba80e3a889126a6e2bc0a603f8fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NJMuYRcXnbZZAY9c.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="739f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不需要任何变量来存储函数A和函数B，函数C也不需要返回函数B，可以直接跳过函数B和函数A，重用A和B都有的变量。当编译器知道这一点时，它们可以重用堆栈帧，而不是在每次递归调用时都占用一个新的堆栈，这就像一次迭代调用。</p><p id="f846" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一些语言中，我们告诉编译器这样做。该语言中的一些编译器可以自动检测我们的代码是递归的，并代表我们帮助优化它。Scala编程中有<code class="fe mz na nb nc b">@tailRec</code>注释，指定编译器将当前函数优化为尾递归调用。如果过程不是尾递归的，它将在编译时给出一个错误。</p><p id="b882" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们能够以尾递归的方式执行函数，编写递归解决方案与迭代解决方案只是算法风格的问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5cff" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结束语</h1><p id="c2da" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当谈到递归和迭代代码库性能时，它归结于语言和代码所有者如何编写程序。你可以写一个比迭代方式更快的递归解。就汇编代码而言，迭代解决方案代表更少的指令，因此它们比递归解决方案更有性能。</p><p id="07ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，现代编译器利用递归优化来优化递归计算，以便与迭代解决方案一样高效。</p><p id="59ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望您了解了一些递归和迭代函数之间的关系，以及如何在下一个编码项目中利用尾部递归。</p><p id="e75b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是一些关于递归的有用参考:</p><ul class=""><li id="7e9f" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><a class="ae nm" href="https://lispcast.com/what-is-tail-recursion/" rel="noopener ugc nofollow" target="_blank">什么是尾递归？— LispCast </a></li><li id="d4e3" class="nd ne it la b lb nn le no lh np ll nq lp nr lt ni nj nk nl bi translated"><a class="ae nm" href="https://2ality.com/2015/06/tail-call-optimization.html" rel="noopener ugc nofollow" target="_blank">ECMAScript 6中的尾部调用优化</a></li></ul><p id="fce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ns">原载于</em><a class="ae nm" href="https://edward-huang.com/2021/02/17/is-recursion-really-slower-than-iteration/" rel="noopener ugc nofollow" target="_blank"><em class="ns"/></a><em class="ns">。</em></p></div></div>    
</body>
</html>