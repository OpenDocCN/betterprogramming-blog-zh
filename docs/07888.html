<html>
<head>
<title>Learn React Hooks in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年学React钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-react-hooks-in-2021-405061b76c24?source=collection_archive---------6-----------------------#2021-03-02">https://betterprogramming.pub/learn-react-hooks-in-2021-405061b76c24?source=collection_archive---------6-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">过渡到反应钩的实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/534a5d3b9515b616fa6aff495eeccc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y4kEYIy9WEhSMWex"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@karishea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kari Shea </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e9bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还在用基于类的React组件吗？你没机会用React钩子吗？你并不孤单——尽管React挂钩已经存在了一段时间，但一些开发人员仍然没有时间使用它们。</p><p id="5062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将向您展示如何将基于类的组件转换成React钩子。我们还将详细介绍每个挂钩，并使用代码示例和练习来解释它的功能。到本文结束时，您应该已经掌握了基本的React钩子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应组分</h1><p id="d047" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">确保遵循示例，并在演示React应用程序中创建它们。你获得的实践经验越多，你就会越习惯语法和概念。</p><h2 id="fbdb" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">反应基于类的组件</h2><p id="21c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们来看看一个简单的基于类的组件，看看如何使用钩子将它转换成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个典型的基于类的组件。让我们来看看功能组件的构建模块。我们将有一个处理所有事情的函数，而不是一个类。这个函数不是单独有一个<code class="fe nn no np nq b">render</code>方法，而是你新的<code class="fe nn no np nq b">render</code>方法。</p><h2 id="bb5c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">功能组件模板</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f2cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这么简单！这类似于接收道具作为参数的渲染方法。让你的道具更具可读性的一个常用方法是使用spread操作符来析构它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="adc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样我们就能清楚地看到我们期望的道具。如果我们与TypeScript结合使用，这可能会使React <code class="fe nn no np nq b">PropTypes</code>变得多余。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应状态挂钩</h1><p id="6d75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们正在使用函数，所以我们实际上并不像过去在基于类的组件中那样有<code class="fe nn no np nq b">this</code>可用。为了解决这个问题，React想出了<code class="fe nn no np nq b">hooks</code>。这些代码可以在您的功能组件中用来访问以前可用的概念。</p><p id="c4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于状态的情况，我们可以使用React的<code class="fe nn no np nq b">useState</code>钩子。如果你感兴趣，这里有关于使用状态的官方文档。首先，让我们按照文档中的定义来定义<code class="fe nn no np nq b">useState</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会立即注意到<code class="fe nn no np nq b">useState</code>语法看起来很奇怪。那是因为我们立即破坏了它。<code class="fe nn no np nq b">useState</code>钩子返回一个包含两个条目的数组。第一项是状态变量的<code class="fe nn no np nq b">value</code>。第二项是状态变量的<code class="fe nn no np nq b">setter method</code>。假设我们想要更新州中的<code class="fe nn no np nq b">headingText</code>值。为此，我们可以使用第二项中返回的变量。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="258f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多个状态变量时会是什么样子？对于每个状态变量，我们需要使用<code class="fe nn no np nq b">useState</code>钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样重要的是要注意，我们总是将一个字符串传递给<code class="fe nn no np nq b">useState</code>方法。<code class="fe nn no np nq b">UseState</code>将使用它作为状态变量的默认值，因此它不必是一个字符串——它可以是一个布尔值、一个对象或任何你喜欢的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="73c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">练习:useState —用钩子实现一个点击计数器</h1><p id="376e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们回头看前面的例子，我们可以看到如何使用状态，但它在这个例子中不是特别有用。让我们一起完成<code class="fe nn no np nq b">useState</code>上的一个练习。</p><p id="2285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用功能组件中的<code class="fe nn no np nq b">useState</code>钩子创建一个点击计数器。该组件应该呈现一个按钮，每次按钮被按下时，一个段落显示按钮的点击次数。你必须使用<code class="fe nn no np nq b">useState</code>钩子来保持点击的数量。</p><p id="97fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，实现一个将初始点击量设置为指定值的prop如果给了组件<code class="fe nn no np nq b">20</code>,那么组件应该从一开始就显示<code class="fe nn no np nq b">20 clicks</code>。</p><p id="e769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你准备好了，向下滚动图片找到解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/2e456364a1f86062d17d3a4fe6b9399c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eHqznNZ2JUxvQzq4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">普通技术人员在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你遇到什么困难了吗？请在评论中告诉我们！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应生命周期和使用效果</h1><p id="9756" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在知道如何创建功能组件并使用<code class="fe nn no np nq b">useState</code>钩子。但是生命周期事件呢？</p><h2 id="366c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">React componentDidUpdate</h2><p id="a043" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用基于类的<code class="fe nn no np nq b">componentDidUpdate</code>函数，我们可以监听组件属性的变化。我们如何用钩子做到这一点？</p><p id="0028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe nn no np nq b">useEffect</code>钩子的用处。每当依赖项的值发生变化时，它就会触发一个给定的函数。这个钩子不返回一个数组，相反，它允许你在执行过程中当特定的变量改变时运行特定的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">useEffect</code>需要两个参数:要运行的函数和依赖列表。依赖列表是变量列表。每当这些变量中的任何一个发生变化，第一个参数中的给定函数就会运行。</p><h2 id="2ab8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">反应组件安装</h2><p id="a819" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还记得在基于类的React中，我们有函数<code class="fe nn no np nq b">componentDidMount</code>吗？每当组件被装载到页面上时，函数就会运行。对于<code class="fe nn no np nq b">useEffect</code>，我们需要提供一个依赖列表，所以它不适合替换<code class="fe nn no np nq b">componentDidMount</code>，对吗？不完全是——它有锦囊妙计。</p><p id="c70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传递一个空列表作为依赖列表，那么作为第一个参数给出的函数将以类似于<code class="fe nn no np nq b">componentDidMount</code>的方式运行。让我们尝试一下，并扩展我们以前的点击计数器的例子！请注意，空列表对于此行为是强制性的。开发人员的一个常见错误是忘记定义列表。如果给出的是<code class="fe nn no np nq b">undefined</code>而不是<code class="fe nn no np nq b">[]</code>，那么<code class="fe nn no np nq b">useEffect</code>的行为将不会像<code class="fe nn no np nq b">componentDidMount</code>一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="077e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应上下文挂钩</h1><p id="7956" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React团队归类为<code class="fe nn no np nq b">basic</code>的第三个也是最后一个钩子是<code class="fe nn no np nq b">context</code>钩子。这允许您将数据从应用程序的顶层传递给所有递归子级。这通常对创建提供者很有用，比如主题提供者，所以每个组件都可以访问应用程序的主题风格。</p><p id="70ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，虽然我们可以使用<code class="fe nn no np nq b">useContext</code>钩子传递上下文，但是我们不能更新它！如果您的应用程序需要这样做，您可能需要查看状态管理器，比如Redux。</p><p id="d962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会对这个钩子进行过多的描述，但是这里有一个React文档中的使用示例，以及注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React useMemo Hook:性能优化</h1><p id="6309" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React给了我们<code class="fe nn no np nq b">useMemo</code>钩子来提高应用程序的性能。与<code class="fe nn no np nq b">useEffect</code>类似，<code class="fe nn no np nq b">useMemo</code>钩子接受两个参数:一个要执行的函数和一个依赖列表。与<code class="fe nn no np nq b">useEffect</code>的一个区别是这个钩子将返回函数的值，所以它的值可以在函数组件中使用。</p><p id="115a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">UseMemo</code>将缓存方法的值，只要依赖列表不改变。这意味着计算值的方法将不会运行，除非依赖列表中的某个值发生变化。</p><p id="d8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在通过引用处理变量时特别有用。如果在你的函数组件中定义了一个数组，那么在重新渲染时引用将会不断变化。如果这个数组被传递给子组件，这些子组件将继续重新渲染，而实际上并不需要。</p><p id="d009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe nn no np nq b">useMemo</code>时，我们可以通过缓存数组及其引用来避免这种行为，直到用于计算其值的一个依赖项发生变化。让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传递引用变量，<code class="fe nn no np nq b">useMemo</code>可以避免在每次渲染主组件时重新渲染子组件。这是因为我们缓存了变量引用，而不是在每次渲染时重新定义它。这是使用<code class="fe nn no np nq b">useMemo</code>的唯一理由吗？不完全是。这对于大型处理非常有用。</p><p id="2baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我的文章<a class="ae ky" href="https://medium.com/swlh/should-you-use-usememo-in-react-a-benchmarked-analysis-159faf6609b7" rel="noopener">你应该在React中使用备忘录吗？一个基准分析</a>来找出你什么时候应该在你的React应用中使用<code class="fe nn no np nq b">useMemo</code>。</p><p id="1785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在官方文档页面查看更多关于<code class="fe nn no np nq b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code> <a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">钩子的信息。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="49de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应使用回调挂钩</h1><p id="35f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nn no np nq b">useCallback</code>钩子类似于<code class="fe nn no np nq b">useMemo</code>钩子，但是它不是记忆变量值，而是记忆函数。它基于相同的概念工作，为了避免函数的引用在每次渲染时改变，缓存函数直到它的一个依赖项改变。</p><p id="596f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这避免了从接收此函数作为道具的子组件进行不必要的重新渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d5ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React挂钩列表</h1><p id="2ae8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面解释的钩子是React中使用的一些比较重要的钩子。当然，React还有其他挂钩——这里是它们每种类型的列表，如React在<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中定义的。</p><h2 id="cce7" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">基本挂钩</h2><ul class=""><li id="d934" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useState</code>用于管理组件的状态</li><li id="80e7" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useEffect</code>针对组件的生命周期事件，如果特定的依赖关系发生变化，则触发特定的功能</li><li id="7231" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useContext</code>为了将上下文传递给所有子组件</li></ul><h2 id="c469" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">高级挂钩</h2><ul class=""><li id="bb66" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useMemo</code>用于记忆变量值。</li><li id="6f43" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useCallback</code>用于记忆功能。</li><li id="b593" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useReducer</code>用于创建和使用定制的减速器。</li><li id="df5d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useRef</code>用于定义对DOM中组件的引用。</li><li id="096f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useImperativeHandle</code>可用于自定义<code class="fe nn no np nq b">useRef</code>返回的值。</li><li id="52d9" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useLayoutEffect</code>与<code class="fe nn no np nq b">useEffect</code>相似，但只在所有DOM更新后触发。</li><li id="20b2" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useDebugValue</code>用于开发定制钩子时显示调试数据。</li></ul><h2 id="dd5d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">第三方挂钩</h2><p id="bcf9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">任何人都可以为React创建额外的挂钩。Redux是一个流行的React状态管理器，它创建了<code class="fe nn no np nq b">useSelector</code>钩子来从功能组件中检索Redux状态数据。如果您已经设置了Redux，那么使用这个钩子检索Redux数据是小菜一碟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">钩子小抄</h1><ul class=""><li id="a46f" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useState</code> : <code class="fe nn no np nq b">const [value, setter] = setState(defaultValue);</code></li><li id="d3c8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useEffect</code> : <code class="fe nn no np nq b">useEffect(myFunction, dependencyArray);</code></li><li id="07f2" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useEffect</code>:did mount的用法<code class="fe nn no np nq b">useEffect(myFunction, []);</code></li><li id="00b5" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useContext</code> : <code class="fe nn no np nq b">React.createContext(object)</code>和<code class="fe nn no np nq b">useContext(MyContext);</code></li><li id="661e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useMemo</code> : <code class="fe nn no np nq b">const myValue = useMemo(calculateFunction, dependencyList);</code></li><li id="c92c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useCallback</code> : <code class="fe nn no np nq b">const myFunction = useMemo(callbackFunction, dependencyList);</code></li><li id="24c9" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe nn no np nq b">useSelector</code> : <code class="fe nn no np nq b">const result = useSelector(state =&gt; state.item);</code></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b2d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="6c1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React开发的当前趋势是转向使用钩子。钩子和基于类的组件是互操作和兼容的！您可以将较新的组件作为功能组件，同时保持较旧的组件基于类。</p><p id="4f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不用担心，React不会很快移除基于类的组件。</p><blockquote class="og"><p id="a2d6" class="oh oi it bd oj ok ol om on oo op lu dk translated">没有从React中移除类的计划——我们都需要继续发布产品，并且负担不起重写。</p><p id="3ac1" class="oh oi it bd oj ok ol om on oo op lu dk translated">—官方<a class="ae ky" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">下一步是什么？</h1><p id="ce1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">练习，练习，练习！你用钩子获得的实践经验越多，你就会越快适应它们。使用React挂钩创建一些宠物项目。这很有趣，你会得到一个很好的项目！</p><p id="4260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续关注关于React挂钩的下一篇文章，在这篇文章中，我们将创建自己的自定义React挂钩。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4be6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">额外学习资源</h1><ul class=""><li id="1569" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated">你真的应该在React中使用UseMemo吗？基准分析。</li><li id="de5a" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React Hooks官方文档页面</a></li><li id="6c28" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank"> React Redux第三方挂钩</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kevinvr.medium.com/membership" rel="noopener">订阅我的媒介</a>到<strong class="lb iu">解锁</strong> <strong class="lb iu">所有</strong> <strong class="lb iu">文章</strong>。通过使用我的链接订阅，你是支持我的工作，没有额外的费用。你会得到我永远的感激。</p></div></div>    
</body>
</html>