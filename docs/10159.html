<html>
<head>
<title>How to Configure a Swift Package to Expose CoreData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何配置Swift包以公开CoreData</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-coredata-from-an-spm-package-e82c465d5d02?source=collection_archive---------1-----------------------#2021-12-07">https://betterprogramming.pub/use-coredata-from-an-spm-package-e82c465d5d02?source=collection_archive---------1-----------------------#2021-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用SPM包中的CoreData</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39493a7c0787178b9d5152fbb82fd50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5aMEx5OGL-Ya9BYI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@feliixlam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费利克斯·拉姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3dee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我一直在帮助<em class="lv">公益</em>抗击中风<a class="ae ky" href="https://www.fightthestroke.org/home-eng" rel="noopener ugc nofollow" target="_blank">协会维护和改进</a><a class="ae ky" href="https://www.fightthestroke.org/mirrorhr-eng" rel="noopener ugc nofollow" target="_blank"> MirrorHR iOS应用</a>。是一个非营利性协会，其目标是改善有脑瘫儿童的家庭的生活。</p><p id="92ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">MirrorHR — Epilepsy Research Kit</code>旨在减少儿童癫痫发作的数量和严重性，帮助家庭更好地跟踪癫痫发作、症状和事件，同时帮助医生更好地识别癫痫发作的潜在触发因素<em class="lv">。</em>这使得护理人员能够尽早介入处理癫痫发作，减少其影响，并避免家人整天待在医院。</p><p id="8c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这几个月里，这款应用的功能和复杂性都有所增加。我们面临的挑战之一是将它分成更小的模块。众所周知，模块化有几个好处:</p><ol class=""><li id="69ab" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">可读性和可维护性更强的代码库。</li><li id="24a0" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">它支持并行开发。</li><li id="7ab2" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">模块是隔离的，因此如果一个模块没有改变，它就不会崩溃。</li><li id="dcb1" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">代码构建得更快。</li></ol><p id="3f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们提取的模块之一是负责跟踪症状的模块。为了跟踪他们，它利用CoreData。关于如何使用Swift软件包中的CoreData的文档非常少，因此值得分享我们为使其工作所做的工作。</p><h1 id="febb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">该应用程序</h1><p id="12a3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为了展示将CoreData导出到Swift包中的流程，我们准备了一个模拟症状跟踪的示例应用程序。这不是真正的<code class="fe lw lx ly lz b">MirrorHR</code>应用程序，但类似的东西是为本文特别创建的。</p><p id="fcf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序从CoreData数据库加载一些症状，并将其呈现在SwiftUI列表中。然后，我们可以添加一个具有强度的新症状。症状的日期对应于记录症状的时刻。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0003d13352b8f59286c16a5736ecad5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*kSFD2izKbd1TG6HoNONyCA.gif"/></div></figure><p id="a2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GIF展示了工作中的示例应用程序。当它开始时，它会显示症状列表。点击<code class="fe lw lx ly lz b">Log Symptom</code>按钮，出现一张表单。通过点击<code class="fe lw lx ly lz b">Save</code>按钮，症状被记录。如果我们取消工作表，什么都不会发生。</p><h1 id="9f28" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">创建主应用程序</h1><p id="0f47" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">作为第一步，让我们专注于创建一个工作应用程序。然后，我们可以专注于在一个单独的包中移动特性。</p><p id="ba82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从创建UI开始。然后，我们实现了CoreDataManager和SymptomManager。为了简洁起见，我们将只关注每个部分的相关代码。</p><h2 id="cf01" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">症状列表视图</h2><p id="0cf5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">第一个屏幕是<code class="fe lw lx ly lz b">SymptomList</code>视图。<code class="fe lw lx ly lz b">View</code>的完整代码可以在这个<a class="ae ky" href="https://gist.github.com/cipolleschi/64e5e57294642c795a3eae6b4818bd86" rel="noopener ugc nofollow" target="_blank">要点</a>中探索。该视图的相关部分是数据如何从一个屏幕流向另一个屏幕。</p><p id="f09b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个清单只显示了这些部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lw lx ly lz b">View</code>需要一个症状列表和一个闭包来保存一个新症状。组件不知道，也不关心闭包是如何实现的，或者是什么实现了它。<code class="fe lw lx ly lz b">View</code>必须只在屏幕上显示信息。</p><p id="8042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击<code class="fe lw lx ly lz b">Log Symptom</code>按钮时，我们使用<code class="fe lw lx ly lz b">.sheet</code>视图修改器呈现一个表单。工作表由<code class="fe lw lx ly lz b">showAddItem</code>绑定控制，并呈现<code class="fe lw lx ly lz b">AddSymptom</code> SwiftUI视图。</p><p id="492d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建<code class="fe lw lx ly lz b">AddSymptom</code>视图，我们需要传递一个<code class="fe lw lx ly lz b">saveItem</code>闭包。我们通过结合两种功能创造了一种新的封闭:</p><ul class=""><li id="b78d" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">我们驳回起诉，</li><li id="ee95" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu oa mg mh mi bi translated">我们调用最初的<code class="fe lw lx ly lz b">saveItem</code>。</li></ul><p id="dbdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">装饰器</strong> </a>模式的匿名实现:<code class="fe lw lx ly lz b">SymptomList</code>知道如何以及何时必须关闭表单；<code class="fe lw lx ly lz b">AddSymptom</code>视图只负责添加症状。</p><h2 id="db69" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">AddSymptom视图</h2><p id="749f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">该视图包含两个<code class="fe lw lx ly lz b">Picker</code>和一个保存症状的按钮。完整的代码可以在这里找到<a class="ae ky" href="https://gist.github.com/cipolleschi/a0433e236e0cdabede62cc08dddfb110" rel="noopener ugc nofollow" target="_blank">，但是我们将只关注最相关的部分。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="552b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图需要一个<code class="fe lw lx ly lz b">saveItem</code>闭合。它还有几个<code class="fe lw lx ly lz b">@State</code>变量来管理拣选器。当按下<code class="fe lw lx ly lz b">save</code>按钮时，它创建一个新的症状并调用关闭。</p><h2 id="f520" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">核心数据管理器</h2><p id="32a8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在让我们来关注一下<code class="fe lw lx ly lz b">CoreDataManager</code>。该组件的主要职责是包装CoreData的细节，公开一个简单的API来存储和检索一个<code class="fe lw lx ly lz b">SymptomEntity</code>:症状的数据库表示。</p><blockquote class="ob oc od"><p id="a752" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>有关如何实现CoreData堆栈的更多信息，请参考官方<a class="ae ky" href="https://developer.apple.com/documentation/coredata" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该清单实现了基本的CoreData配置。</p><ol class=""><li id="a8d5" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">该类扩展了<code class="fe lw lx ly lz b">NSPersistentContainer</code>。</li><li id="4ba6" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">在<code class="fe lw lx ly lz b">init</code>中，我们从包中检索对象模型文件，创建<code class="fe lw lx ly lz b">NSManagedObjectModel</code>，初始化容器，并调用初始化函数。</li><li id="319b" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">在<code class="fe lw lx ly lz b">initialize</code>函数中，我们加载持久存储。这一步的失败表明了开发的错误配置:我们希望快速失败，所以一个<code class="fe lw lx ly lz b">fatalError</code>是可以的。</li><li id="2718" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe lw lx ly lz b">CoreDataManager</code>公开了一个<code class="fe lw lx ly lz b">symptoms()</code>方法来检索<code class="fe lw lx ly lz b">SymptomsEntity</code> s</li><li id="23cb" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">管理器公开一个<code class="fe lw lx ly lz b">saveSymptom(entity:)</code>方法来保存一个新症状。</li></ol><h2 id="32ec" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">症状管理器</h2><p id="104e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这是连接<code class="fe lw lx ly lz b">CoreData</code>和领域模型的类。它将<code class="fe lw lx ly lz b">SymptomEntity</code>转换为<code class="fe lw lx ly lz b">Symptom</code>，并隐藏所有的<code class="fe lw lx ly lz b">CoreData</code>细节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="153e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类将一个<code class="fe lw lx ly lz b">CoreDataManager</code>对象作为属性，它发布症状列表，因此其他组件可以监听它。它有几个初始化器:</p><ul class=""><li id="e92d" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">一个接受一个<code class="fe lw lx ly lz b">CoreDataManager</code>；</li><li id="d4ae" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu oa mg mh mi bi translated">一个是无参数的。</li></ul><p id="24f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前者可用于测试类，而另一个用于生产。</p><p id="007e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">init</code>中，它通过从数据库中检索症状来准备由其他元素使用的<code class="fe lw lx ly lz b">Symptoms</code>数组。最后，它公开了一个<code class="fe lw lx ly lz b">save(symptom:)</code>方法和一个<code class="fe lw lx ly lz b">refresh</code>函数来更新症状列表。</p><blockquote class="ob oc od"><p id="e169" class="kz la lv lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在实际应用中，<code class="fe lw lx ly lz b">CoreDataManager</code>应该利用一个适当的<code class="fe lw lx ly lz b">Storage</code>抽象。通过这种方式，我们可以将CoreData实施替换为利用不同支持的另一种存储。为了简洁起见，我们决定将这些类型结合在一起。可测试性和极端模块化不是本文的重点。</p></blockquote><h2 id="8d46" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">症状地图</h2><p id="6abf" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们现在有了所有的组件来组装这个应用程序。<code class="fe lw lx ly lz b">SymptomApp.swift</code>文件的代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序创建一个<code class="fe lw lx ly lz b">symptomsManager</code>作为<code class="fe lw lx ly lz b">@StateObject</code>:这样，每当<code class="fe lw lx ly lz b">symptoms</code> <code class="fe lw lx ly lz b">@Published</code>属性被更新时，这些变化会自动传播到<code class="fe lw lx ly lz b">SymptomList</code>视图。</p><p id="a637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过传递症状列表来初始化<code class="fe lw lx ly lz b">SymptomList</code>视图，我们通过调用<code class="fe lw lx ly lz b">symptomsManager</code>的save方法来实现<code class="fe lw lx ly lz b">saveItem</code>闭包。</p><h1 id="c25b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">在Swift包中移动症状功能</h1><p id="8309" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">至此，我们有了一个正常运行的小应用程序。现在让我们将该特性转移到一个专用的包中。</p><p id="0adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程需要几个不同的步骤。让我们一个一个来看:</p><h2 id="6325" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">创建包</h2><p id="2978" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">首先，让我们创建包。</p><ol class=""><li id="748b" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">点击<code class="fe lw lx ly lz b">File</code> &gt; <code class="fe lw lx ly lz b">New</code> &gt; <code class="fe lw lx ly lz b">Package</code></li><li id="fc7d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">在对话框中，我们将其命名为<code class="fe lw lx ly lz b">CoreDataSymptoms</code>。如果您的项目已经由git管理，就不要勾选“<em class="lv">创建git存储库”</em>。记得使用<strong class="lb iu">添加到:</strong>和<strong class="lb iu">组:</strong>下拉控件将其添加到适当的项目中。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/968bdb7d011d6218163529806eff0b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qBLmVehdRyj0fg6VXpa1A.png"/></div></div></figure><p id="297e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们点击<strong class="lb iu">创建</strong>，等待Xcode完成它的工作。</p><p id="0462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在project navigator中，我们应该会看到一个包的图标，带有它的<code class="fe lw lx ly lz b">README</code>、<code class="fe lw lx ly lz b">Package.swift</code>文件以及<code class="fe lw lx ly lz b">Sources</code>和<code class="fe lw lx ly lz b">Tests</code>文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2dc62023773bacd861612fa47a4daab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*kjHMKrfmeCV0_1226auwCA.png"/></div></figure><h2 id="5050" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">配置程序包文件</h2><p id="c5ac" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在是时候更新<code class="fe lw lx ly lz b">Package.swift</code>文件了。我们希望仅支持iOS，并希望将我们将在接下来的步骤中创建的<code class="fe lw lx ly lz b">Resources</code>文件夹中的所有内容添加到包中。更新文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的行是:</p><ul class=""><li id="1c34" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">第5行，我们定义了支持的平台</li><li id="0207" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu oa mg mh mi bi translated">第15行，我们决定将包含在<code class="fe lw lx ly lz b">Resource</code>文件夹中的所有内容<code class="fe lw lx ly lz b">process</code>。</li></ul><h2 id="8e48" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">将包添加到应用程序</h2><p id="a5f6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们需要将<code class="fe lw lx ly lz b">Package</code>添加到<code class="fe lw lx ly lz b">SymptomApp</code>中。否则，我们无法访问包内容。</p><ol class=""><li id="c068" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">打开项目导航器(<code class="fe lw lx ly lz b">⌘+1</code>)并点击项目。</li><li id="2854" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">滚动直到我们找到<code class="fe lw lx ly lz b">Frameworks, Libraries, and Embedded Content </code>部分</li><li id="9ac1" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">点击<code class="fe lw lx ly lz b">+</code>按钮</li><li id="637a" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">选择<code class="fe lw lx ly lz b">CoreDataSymptoms</code>库。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/7649e18af0d04d9d8f5fc45639710ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyNsxzXlOgEpJeGrgR0LLw.png"/></div></div></figure><p id="a494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更改结束时，我们应该看到以下设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/fa77ee2e04bf452ad00878b3282fe42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfcKVA54uAucRrF-VoNz9w.png"/></div></div></figure><h2 id="e781" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">移动包源文件夹中的代码</h2><p id="113a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在，我们可以将文件从应用程序拖放到包中。</p><p id="22d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的源代码必须放在<code class="fe lw lx ly lz b">Source</code>文件夹中。如果需要，我们可以创建子文件夹来将UI从管理器中分离出来。</p><p id="ac12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据模型应该放在<code class="fe lw lx ly lz b">Resources</code>文件夹中。</p><p id="6b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的包应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2cdaf89887a0ed56bcadd4426b730ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*iS_CwitWg9YjmHKrSD9EPA.png"/></div></figure><p id="f684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源文件与<code class="fe lw lx ly lz b">Resources</code>文件夹在同一层，而不是在里面。</p><h2 id="b7b5" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">设置公共修饰符并导入包</h2><p id="9097" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果我们现在尝试构建项目，它将无法编译。将所有源代码移动到一个单独的包中，会对使用它们的其他文件隐藏所有的内部实现。我们需要公开应用程序需要什么。</p><ul class=""><li id="c674" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">更新<code class="fe lw lx ly lz b">SymptomsManager</code>。我们需要在下面几行中添加<code class="fe lw lx ly lz b">public</code>修饰符:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意,<code class="fe lw lx ly lz b">@Published</code>属性有一个<code class="fe lw lx ly lz b">private(set)</code>修饰符。这意味着除了<code class="fe lw lx ly lz b">SymptomsManager</code>本身，没有人可以更新数组。</p><ul class=""><li id="092b" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">更新<code class="fe lw lx ly lz b">SymptomsList</code>视图。这是该包公开的唯一其他组件，应用程序需要它来呈现症状列表。在更新代码时，我们还需要创建一个<code class="fe lw lx ly lz b">public init</code>。代码如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="64b4" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">制作<code class="fe lw lx ly lz b">Symptom</code>型号<code class="fe lw lx ly lz b">public</code>。我们最终需要暴露症状模型。这是一个简单的对象模型，因此创建它没有任何风险。数据模型如下:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="ad02" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">在<code class="fe lw lx ly lz b">SymptomsApp.swift</code>中增加<code class="fe lw lx ly lz b">import</code>语句。最后，我们可以<code class="fe lw lx ly lz b">import</code>这个包来访问它所有的公共成员。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="da87" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">运行应用程序</h1><p id="4da4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在应用程序构建完成了，但是如果我们运行它，它就会崩溃。我们遇到了两种必须解决的错误。</p><h2 id="9ba5" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">Xcode找不到数据模型的路径</h2><p id="745b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">即使我们将数据模型添加到资源中，Xcode也找不到它。</p><p id="fcfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种情况是因为我们试图使用<code class="fe lw lx ly lz b">Bundle.main</code> singleton，但是现在数据模型已经不在<code class="fe lw lx ly lz b">main</code> <code class="fe lw lx ly lz b">Bundle</code>中了。</p><p id="f228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个swift包在<code class="fe lw lx ly lz b">Bundle</code>类中合成了一个<code class="fe lw lx ly lz b">.module</code>静态属性来访问正确的包。我们可以用下面一行来更新<code class="fe lw lx ly lz b">CoreDataManager</code>的<code class="fe lw lx ly lz b">init</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="729e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们更新了第5行，用<code class="fe lw lx ly lz b">Bundle.module</code>代替<code class="fe lw lx ly lz b">Bundle.main</code>。</p><h2 id="7e0f" class="nm mp it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">由于<code class="fe lw lx ly lz b">NSInvalidArgumentException</code>导致崩溃</h2><p id="957f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">另一个常见问题是下面的异常。</p><pre class="kj kk kl km gt om lz on oo aw op bi"><span id="55a0" class="nm mp it lz b gy oq or l os ot">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'An NSManagedObject of class 'SymptomsEntity' must have a valid NSEntityDescription.'</span></pre><p id="14fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，CoreData会自动合成代表数据库实体的类。当将模型移动到包中时，在这个过程中出现了错误。我们可以采取不同的措施来解决这个问题。</p><ul class=""><li id="cedf" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">用<code class="fe lw lx ly lz b">⌘+⇧+K</code>清理项目并重新构建</li><li id="c5e8" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu oa mg mh mi bi translated">打开<code class="fe lw lx ly lz b">SymptomData</code>模型，选择<code class="fe lw lx ly lz b">Symptom</code>实体。在右侧面板中，选择<code class="fe lw lx ly lz b">Data Model Inspector</code>。在<code class="fe lw lx ly lz b">Class</code>面板中，手动输入<code class="fe lw lx ly lz b">Module</code>的名称。在我们的例子中，包的名字是<code class="fe lw lx ly lz b">CoreDataSymptoms</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bb559513e720cfc8e4ba1c151f4377db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKN3tbFEZyWDiIMrJ5Pbag.png"/></div></div></figure><ul class=""><li id="bc91" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu oa mg mh mi bi translated">如果仍然失败，创建一个<code class="fe lw lx ly lz b">SymptomEntity</code>实体的扩展并覆盖<code class="fe lw lx ly lz b">description</code>属性，使其返回实体名称。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一项更改有助于CoreData使用正确的实体名称。</p><p id="5d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过这些更改后，应用程序应该能够正确运行，检索以前存储的症状，并允许用户记录新的症状。</p><h1 id="5f2b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="1c71" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在今天的文章中，我们探讨了如何将基于CoreData的功能从应用程序代码导出到专用的Swift包中。这有很多好处，但是加快构建时间对我们来说是最重要的。</p><p id="006c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们描述了如何构建特性来简化导出过程。在将它移动到另一个包之后，我们只需要添加<code class="fe lw lx ly lz b">import</code>语句，并创建必需的字段和类型<code class="fe lw lx ly lz b">public</code>。但是我们不需要改变实际实现的任何东西。</p><p id="a27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们描述了如何解决最常见的CoreData问题。我们想强调的是，将代码和数据模型移动到不同的包中不会破坏运行时的任何东西。</p><p id="438f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库仍然存储在相同的位置，用于表示实体的模型以相同的方式工作，应用程序仍然能够检索先前存储的症状并存储新的症状。不需要数据迁移，这是一个巨大的解脱。</p></div></div>    
</body>
</html>