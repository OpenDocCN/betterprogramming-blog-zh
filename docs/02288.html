<html>
<head>
<title>How To Create Fun Card Animations in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中创建有趣的卡片动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-fun-animations-in-swiftui-1c08adcb93ce?source=collection_archive---------6-----------------------#2019-11-19">https://betterprogramming.pub/how-to-create-fun-animations-in-swiftui-1c08adcb93ce?source=collection_archive---------6-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的想象力是唯一的限制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93baad44a17afe801a971a6ab0901bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWXpKt0MQhpgVqiDk0Wewg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@joshstyle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔舒亚·柯尔曼</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="41d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:这里用的银行卡都是假的，当然</em></p><h1 id="f796" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">介绍</h1><p id="22bf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">iOS 13发布已经有几个月了，尽管在我们的应用程序中完全支持还为时过早，但还是有必要看看这个新版本中引入的两个主要框架:SwiftUI和Combine。毫无疑问，它们是iOS发展的未来。</p><p id="da4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几个月里，我一直在玩SwiftUI。即使我觉得还缺少一些东西，我还是惊喜地发现定制用户界面和制作动画是如此简单。在UIkit中需要大量代码的事情，在SwiftUI中只需几行代码就可以完成。最棒的是，它进行得既顺利又迅速！它绕过核心动画，直接进入金属。</p><p id="1691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">忘掉UIkit，继续前进，因为你已经落后了，伙计！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="41a3" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">银行卡:快速概览</h1><p id="30b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://github.com/fermoya/BankCards" rel="noopener ugc nofollow" target="_blank">银行卡</a>是您可以使用SwiftUI做什么的一个小例子。有一天，我突然有了灵感，开始着手做这件事。有时候，老实说，想出一个好主意来尝试一个新的框架比实现更困难；我相信你抓到我了。</p><p id="8700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下我的回购中的<a class="ae ky" href="https://github.com/fermoya/BankCards/tree/master/starter" rel="noopener ugc nofollow" target="_blank">启动项目</a>，有几个文件你可能想先检查一下，因为它们是我们将要处理的:<code class="fe nf ng nh ni b">Wallet.swift</code>和<code class="fe nf ng nh ni b">WalletView.swift</code>。第一个模型是一个钱包，基本上包含了一堆卡片，并公开了助手方法。第二个示例将卡片一张一张地堆叠起来，并应用一些UI更改来漂亮地显示您钱包中的卡片:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WalletView.swift片段</p></figure><p id="ade8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/8ff2f143fd044cd5cc9a8f54c0fe9142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGyLY1j9jSalK_Cbcj2kjw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WalletView.swift</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="9cfc" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">动画您的钱包过渡</h1><p id="a119" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如我之前提到的，SwiftUI让你构建非凡的设计变得极其容易。那么它是如何工作的呢？SwiftUI在后台使用Combine，并提供了三个属性包装器(Swift 5.1中的新功能)来帮助您完成这个过程。它们基本上会告诉视图有些东西发生了变化，这将触发视图更新。这些属性包装是:</p><ul class=""><li id="7d8b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe nf ng nh ni b">@State</code>:它代表了一个视图属性，保存了视图所依赖的一些状态。</li><li id="be70" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nf ng nh ni b">@ObservedObject</code>:这是一个由视图观察其属性的对象。</li><li id="0bea" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nf ng nh ni b">@EnvironmentObject</code>:与<code class="fe nf ng nh ni b">@ObservedObject</code>相似，但是视图及其子视图可以全局访问。</li></ul><p id="9541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始工作吧！现在，钱包显示在屏幕上，没有任何动画——没有发生什么事情。我们为什么不做个过渡来展示钱包呢？声明一个新属性<code class="fe nf ng nh ni b">isPresented</code>，并将其初始设置为false:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="cd13" class="oe lx it ni b gy of og l oh oi">@State var isPresented = false</span></pre><p id="0808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nf ng nh ni b">isPresented</code>为真，更改<code class="fe nf ng nh ni b">ZStack</code>中的代码以显示卡片。然后，使用<code class="fe nf ng nh ni b">onAppear</code>切换标志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">建议切换以展示卡片</p></figure><p id="9c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，添加一个隐式动画来制作<code class="fe nf ng nh ni b">CardView</code>过渡的动画:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过渡WalletView子视图</p></figure><ol class=""><li id="6e3f" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu oj ns nt nu bi translated">调用<code class="fe nf ng nh ni b">transition</code>,这样每当一张卡被添加到<code class="fe nf ng nh ni b">WalletView</code>时，它就被呈现为向上移动，同时淡入。</li><li id="f0ff" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu oj ns nt nu bi translated">使用<code class="fe nf ng nh ni b">animation</code>隐含地说明每个卡片及其子视图应该如何动画。</li></ol><p id="da9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是使用明确的动画:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="0792" class="oe lx it ni b gy of og l oh oi">withAnimation {<br/>     self.isPresented.toggle()<br/>}</span></pre><p id="b776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为了简单起见，我们将总是使用默认的动画，尽管有不同的延迟(您稍后会看到)。</p><p id="1e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，您应该会看到这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/707710a38cf66c095980487155a5f1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*v3Aw7uptY2ZiKKB4-D7PyA.gif"/></div></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="fe54" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">拖动你的卡片来整理你的钱包</h1><p id="5b49" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的钱包现在看起来更好了，但还不够好。这是我们现在要做的。我们将使我们的<code class="fe nf ng nh ni b">CardView</code>可拖动，这样我们就可以通过向上或向下拖动前面的卡来对钱包中的卡进行排序。为此，我们需要向第一个<code class="fe nf ng nh ni b">CardView</code>实例添加一个<code class="fe nf ng nh ni b">DragGesture</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将DragGesture添加到第一张卡片</p></figure><p id="719a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">DragGesture</code>配有两块。每当<code class="fe nf ng nh ni b">DragGesture</code>更新它的翻译时<code class="fe nf ng nh ni b">onChanged</code>被调用，而每当手势完成时<code class="fe nf ng nh ni b">onEnded</code>被调用。我们将在后面的卡片上禁用用户交互，这样只有第一张卡片是可拖动的。</p><p id="905f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本节中使用的文件中已经定义了一些属性和助手方法。看一看<code class="fe nf ng nh ni b">offset(for:)</code>:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="49da" class="oe lx it ni b gy of og l oh oi">private func offset(for card: Card) -&gt; CGFloat {<br/>    guard !wallet.isFirst(card: card) else { return draggingOffset }<br/>    let cardIndex = CGFloat(wallet.index(of: card))<br/>    return cardIndex * Self.cardOffset<br/>}</span></pre><p id="80bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是根据卡片在钱包中的位置来偏移卡片的函数。<code class="fe nf ng nh ni b">dragginOffset</code>在文件顶部声明，并初始化为<code class="fe nf ng nh ni b">0</code>。我们将使用<code class="fe nf ng nh ni b">onChanged</code>来更新它的值:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="e6b9" class="oe lx it ni b gy of og l oh oi">self.draggingOffset = value.translation.height</span></pre><p id="646a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，等等！我们得到一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fb188f84702e29d74ab6aae2385117ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwoGDSNyaNgFBTkq8o5ELw.png"/></div></div></figure><p id="49f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">WalletView</code>和SwiftUI中的任何其他<code class="fe nf ng nh ni b">View</code>都是一个<code class="fe nf ng nh ni b">struct</code>，这意味着它们是不可变的。幸运的是，SwiftUI允许我们修改它们的属性，只要我们用<code class="fe nf ng nh ni b">@State</code>包装它们。</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="59d6" class="oe lx it ni b gy of og l oh oi">@State var draggingOffset: CGFloat = 0</span></pre><p id="1d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将触发一个动画视图更新，这是我们隐式延迟的。前往<code class="fe nf ng nh ni b">ForEach</code>内心的你<code class="fe nf ng nh ni b">WalletView</code>添加:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="4a78" class="oe lx it ni b gy of og l oh oi">ForEach(self.wallet.cards) {<br/>    // code here<br/>}.onAppear {<br/>    self.shouldDelay = false<br/>}</span></pre><p id="34db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使帮助器方法<code class="fe nf ng nh ni b">transitionDelay(card:)</code>在<code class="fe nf ng nh ni b">ForEach</code>出现后返回<code class="fe nf ng nh ni b">0</code>。不要忘记包装<code class="fe nf ng nh ni b">shouldDelay</code>以消除编译器错误:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="416d" class="oe lx it ni b gy of og l oh oi">@State var shouldDelay = true</span></pre><p id="7968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用<code class="fe nf ng nh ni b">onEnded</code>将<code class="fe nf ng nh ni b">draggingOffset</code>设置回<code class="fe nf ng nh ni b">0</code>:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="752e" class="oe lx it ni b gy of og l oh oi">onEnded ({ _ in<br/>    self.draggingOffset = 0<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/546b615ab86f4819474a6ac36a54ba6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*mVkTxUzRkl92h_qiH0sbXw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可拖动卡片</p></figure><p id="d490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要对钱包中的卡进行排序，请将以下代码添加到<code class="fe nf ng nh ni b">onEnded</code>:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="2b47" class="oe lx it ni b gy of og l oh oi">let newCards = [card] + Array(self.wallet.cards.dropLast())<br/>self.wallet.cards = newCards</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/fb3232f150caad2b23a3886b0519ce80.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*cs8xLBNhlWDFlRGGnmo5Fg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拖移以排序卡片</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="1304" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">最后一步:点击一张卡片，将它放到最前面</h1><p id="1008" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了完成本教程，让我们给我们的卡添加一个<code class="fe nf ng nh ni b">TapGesture</code>来将拾取的卡带到牌堆的前面。首先，去掉这条线</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="b8d0" class="oe lx it ni b gy of og l oh oi">.disabled(!self.wallet.isFirst(card: card))</span></pre><p id="8a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并修改<code class="fe nf ng nh ni b">DragGesture</code> <code class="fe nf ng nh ni b">onChanged</code>和<code class="fe nf ng nh ni b">onEnded</code>以使只有前卡仍可拖动:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="c96c" class="oe lx it ni b gy of og l oh oi">onChanged ({ _ in<br/>    if self.wallet.isFirst(card: card) {<br/>        // code here<br/>    }<br/>})<br/>.onEnded ({ _ in<br/>    if self.wallet.isFirst(card: card) {<br/>        // code here<br/>    }<br/>})</span></pre><p id="db31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，使用<code class="fe nf ng nh ni b">onTapGesture</code>再次对卡片进行分类:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="2288" class="oe lx it ni b gy of og l oh oi">.gesture(<br/>    DragGesture()<br/>        // ...<br/>).onTapGesture {<br/>    let newCards = self.wallet.cards.filter { $0 != card } + [card]<br/>    self.wallet.cards = newCards<br/>}</span></pre><p id="6d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建并运行。没有得到你期望的结果？尝试用<code class="fe nf ng nh ni b">@State</code>包裹<code class="fe nf ng nh ni b">wallet</code>。还是什么都没有？事情是这样的。<code class="fe nf ng nh ni b">WalletView</code>不知道它必须更新。我们需要为<code class="fe nf ng nh ni b">wallet</code>、<code class="fe nf ng nh ni b">@ObservedObject</code>添加不同的包装器:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="d45a" class="oe lx it ni b gy of og l oh oi">@ObservedObject var wallet: Wallet = Wallet(cards: cards)</span></pre><p id="4f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器应该在这一点上抱怨:<em class="lv">在“ObservedObject”上引用初始值设定项“init(wrappedValue:)”要求“Wallet”符合“ObservableObject”</em></p><p id="aa33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nf ng nh ni b">Wallet.swift</code>并执行<code class="fe nf ng nh ni b">ObservableObject</code>:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="0488" class="oe lx it ni b gy of og l oh oi">class Wallet: ObservableObject {<br/>    // ...<br/>}</span></pre><p id="7e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，SwiftUI到底应该观察什么呢？我们需要明确哪些属性应该被观察，或者换句话说，哪些属性将被发布:</p><pre class="kj kk kl km gt oa ni ob oc aw od bi"><span id="b493" class="oe lx it ni b gy of og l oh oi">@Published var cards: [Card]</span></pre><p id="1f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建并运行。这一次我们应该有预期的结果。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7be1" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">从这里去哪里？</h1><p id="7c91" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你可以做很多事情来改善你的钱包体验。starter项目附带了额外的变量<code class="fe nf ng nh ni b">isDragging</code>和<code class="fe nf ng nh ni b">firstCardScale</code>，您可以使用它们来丰富您的动画。试着使用这些变量(或者你可能想到的其他变量)来改变<code class="fe nf ng nh ni b">rotationEffect</code>、<code class="fe nf ng nh ni b">offset</code>、…或者任何其他修改器。</p><p id="f559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我在本教程的<a class="ae ky" href="https://github.com/fermoya/BankCards/tree/master/final" rel="noopener ugc nofollow" target="_blank">最终版本</a>中所做的改进。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/aaa9dca3a5f28564bad7e9859557eba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*eSHPRtoTV3CyWPR2wFbLQg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">回购的最终版本</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e1c9" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">结论</h1><p id="ff56" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">SwiftUI是一个非常强大的工具，它将使您的生活更加轻松，并将使您的设计更上一层楼。以下是一些优点:</p><ul class=""><li id="e527" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">它使用金属，因此速度非常快，非常平稳。</li><li id="3073" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">简单易用。</li><li id="21f8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">与XIB或故事板的基本代码相比，它是可以理解的。冲突可以更容易解决。</li><li id="e4ac" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">比编码约束更易读。</li><li id="1518" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">较少的代码行</li></ul><p id="4dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，这里有一些缺点:</p><ul class=""><li id="586f" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">它是相当新的，所以它是不断变化的。</li><li id="bba6" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">一些在UIkit中经常使用的视图在SwiftUI中没有对应的视图。比如<code class="fe nf ng nh ni b">UICollectionView</code>或者<code class="fe nf ng nh ni b">TextView</code>。</li><li id="70fb" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">集成到您的应用程序中，因为SwiftUI仅受iOS 13+支持。</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="105e" class="lw lx it bd ly lz na mb mc md nb mf mg jz nc ka mi kc nd kd mk kf ne kg mm mn bi translated">资源</h1><ul class=""><li id="ce5b" class="nm nn it lb b lc mo lf mp li om lm on lq oo lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.apple.com/tutorials/swiftui/tutorials" rel="noopener ugc nofollow" target="_blank">学习用SwiftUI制作应用</a></li><li id="a485" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.hackingwithswift.com/quick-start/swiftui" rel="noopener ugc nofollow" target="_blank"> SwiftUI示例</a></li></ul></div></div>    
</body>
</html>