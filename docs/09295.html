<html>
<head>
<title>We Migrated From AWS Lambda to ECS, but Hope to Eventually Migrate Back</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们从AWS Lambda迁移到ECS，但希望最终迁移回来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/we-migrated-from-aws-lambda-to-ecs-but-hope-to-eventually-migrate-back-8ad25a60501b?source=collection_archive---------0-----------------------#2021-08-09">https://betterprogramming.pub/we-migrated-from-aws-lambda-to-ecs-but-hope-to-eventually-migrate-back-8ad25a60501b?source=collection_archive---------0-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Lambda的陷阱让我们放弃了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb8afe1a26d4a8e58345ea70047c7fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DT3eG4-ggpZr-be5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://unsplash.com/@attentieattentie" rel="noopener ugc nofollow" target="_blank">出席者</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="8835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">作者注:本文表达的观点是我个人的，不一定代表我雇主的观点。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="f786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个关于我们如何从Lambda迁移到ECS的故事，因为2%的错误率和有限的并发控制。还有，关于AWS最近如何修复他们的错误率问题，以及并发控制的增强如何让我们回到Lambda。</p><p id="8e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在2018年第一次开始在<a class="ae ky" href="https://www.knockcrm.com/" rel="noopener ugc nofollow" target="_blank"> Knock </a>工作时，我们正在手动管理的AWS EC2实例上运行我们的整个堆栈。</p><p id="2934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，扩展和维护我们的基础架构非常困难，而且由于我们无法分配资源消耗，我们正在浪费资金。我们正在考虑像AWS弹性容器服务(ECS)和AWS最近的无服务器选项Lambda这样的托管容器服务。</p><p id="dce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS声称Lambda是一个可靠的、功能丰富的环境，它抽象出任何必须管理服务器的概念，我们对能够专注于代码的前景感到兴奋。</p><p id="e3d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在生产中使用Lambda一年后，我们发现Lambda是一种相对不可靠的技术，当它用于交付面向客户的功能时，AWS层2%的错误率导致了非常差的用户体验。因此，我们决定将一些面向客户的Lambdas迁移到ECS。</p><p id="7b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入细节之前，我想澄清一下，这篇文章并不是给AWS的关于Lambda的恐吓信。</p><p id="9fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你将在后面读到的，在2020年，AWS对Lambda网络进行了改进，这几乎完全降低了我们看到的错误率。</p><p id="c524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就剩下了对并发性的关注，在某些用例中，并发性是可以减轻的，但不是全部。</p><p id="e4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为所有的lambda都有一个共享的并发池，所以任何一个lambda中的突发活动都很容易导致关键任务功能的严重阻塞，从而导致不可接受的用户体验。</p><p id="48ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我希望AWS最终会增强Lambda的并发模型，并继续致力于工程师花更少时间管理服务器的承诺。</p><h1 id="2bb0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们在Lambda上运行的是什么？</h1><p id="d5e8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们从描述我们在Lambda上运行的服务类型开始，毕竟，在某些用例中，我们有时可以容忍延迟和故障。</p><p id="16be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一类服务由RESTful APIs的后端组成，前端是API Gateway，后端是每个路由的Lambda函数。</p><p id="f59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这一层同时运行Node.js (Typescript)和Python代码。虽然这里的编程语言选择对我们在本文中讨论的内容没有什么影响，但它们确实会影响成本和整体Lambda并发性和延迟。</p><p id="6b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里主要说明的是，这些API中的大多数是由前端同步调用的，因此，显著的延迟和故障是不可接受的，因为它对用户来说表现为停机时间。</p><p id="0cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二类服务主要由后台任务组成，这些任务从SQS队列中读取消息，然后在RDS实例和S3桶上执行IO操作。</p><p id="dd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这个管道中没有任何东西对时间太敏感，所以如果这些后台任务偶尔失败，一个重试机制就足以保持我们的系统健康和每个人都满意。</p><h1 id="7da2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">从2019年到2020年，Lambda误差率高达2%</h1><p id="9920" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">直到我们在产品中推出RESTful APIs，我们才开始注意到AWS Lambda的AWS层中的瞬时错误很常见。特别是，我们开始注意到CloudWatch中的错误，Lambda甚至会在运行任何应用层代码之前超时。我们知道应用程序代码没有运行，因为我们的应用程序代码做的第一件事就是记录传入的请求，而来自我们的应用层的这些日志语句丢失了。换句话说，由于问题发生在AWS层，我们无法调整来防止这种情况发生。例如:</p><blockquote class="na nb nc"><p id="34f1" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">开始请求id:56 a12 BF 8–43e b-4b6c-8a 20-c73fa 2152 c6b版本:$最新</p><p id="7d89" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated"><strong class="lb iu">【应用程序日志中缺失的条目】</strong></p><p id="5b46" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">结束请求id:56 a12 BF 8–43e b-4b6c-8a 20-c73fa 2152 c6b</p><p id="9dc4" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">报告请求id:56 a12 BF 8–43e b-4b6c-8a 20-c73fa 2152 c6b持续时间:30019.42毫秒计费持续时间:30000毫秒内存大小:1024 MB最大已用内存:77 MB</p><p id="f488" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">2019–08–22t 20:10:31.270 z 56 a12 BF 8–43eb-4b6c-8a 20-c 73 fa 2152 c 6b<strong class="lb iu">任务30.02秒后超时</strong></p></blockquote><p id="d35d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年8月28日，我们通过支持票联系了AWS，他们确认1–2%的故障率有些正常:</p><blockquote class="na nb nc"><p id="4b33" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">总结一下对话，我们谈到了1%-2%的失败率并非超出峰值的可能性范围，建议的实施是在客户端回退并重试</p></blockquote><p id="5c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS推荐一种重试机制，但在实践中，检测这些问题的唯一方法是设置一个更积极的超时，然后重试。</p><p id="68b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键代码路径中的一些遗留代码在负载繁重时可能需要几秒钟才能运行，Lambda冷启动曾经相当重要。</p><p id="0038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，假设我们实现了五秒钟的超时，然后在此时重试。这将导致用户不得不等待至少五秒钟，当这种情况发生率为2%时，这是不可接受的！</p><p id="280e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们的后端是分布式的，因此操作并不总是原子的，这意味着当中止Lambda调用并重试请求时，重复请求的可能性会增加。</p><p id="5f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对我们来说是一个重大的交易破坏者，所以我们决定在2019年底开始从Lambda迁移出去。</p><h1 id="61ce" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">共享并发导致执行受限和用户受挫</h1><p id="4578" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有人可能会说Lambda的并发控制能力严重不足，因为每个AWS帐户的Lambda货币都有一个区域上限。</p><p id="4409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着任何突发的Lambda活动都可能导致面向客户的Lambda被抑制。在这里，我将面向客户的Lambdas定义为那些通过UI处理来自用户的同步请求的Lambdas。</p><p id="92fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，Lambda驱动的后台任务会让这些面向客户的Lambda变得饥饿，并会导致你的应用程序变得无响应。这对您的用户来说表现为停机，如果频繁发生，这是完全不可接受的。</p><p id="4a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下组图表所示，您可以看到面向客户的错误峰值大致与我们客户的Lambda并发峰值相关:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8cc5ebd7f2a08a65818b5a3fc41f6a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jNJgJpD69taJZVtt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">达到最大并发时出现的错误。图片来源:作者</p></figure><p id="6999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不容易避免，因为我们的帐户上有1，000个并发Lambda的限制，绑定Lambda执行的唯一方法是保留1，000个池的一部分。换句话说，每次你为一个Lambda保留并发性，你就永远带走了其他Lambda的潜在并发性，导致一个尴尬的杂耍行为，其中你有一些Lambda是静态有界的，而其他的不是。</p><p id="0b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您熟悉AWS弹性容器服务(ECS)或弹性Kubernetes服务(EKS)，您会知道通过增加或减少为服务运行的任务数量来控制容器(工作池)的数量是相当简单的。换句话说，您可以完全控制如何分配您的资源，而不会像Lambda那样被锁定在一个原始的每个功能的并发模型中。在本文的后面部分，我们将研究我认为AWS如何改进其并发控制以促进更好的资源共享。</p><p id="dcda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定Lambda的基本并发控制，我们能做些什么来防止限制我们面向用户的Lambda呢？是的，您可以:</p><ol class=""><li id="98be" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">使用保留并发临时约束更多Lambdas的并发</li><li id="f4be" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">向AWS支持部门提交请求，将您的并发限制从1，000提高到1，000</li><li id="ef73" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">将SQS读数的批量最大增加到10。这意味着用更少的兰博达服务同样的SQS交通。让我们只希望在你的Lambdas被抑制之前，你的代码能以这种方式工作</li><li id="954c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">为面向用户的Lambdas设置保留或提供的并发性。如果只有几个lambda，这没什么，但是如果每个RESTful API路径都有一个lambda，那么可能会有数百个lambda，很快就会陷入实际上锁定所有并发性的境地。例如，假设您只有10个lambda/routes，并将每个lambda的保留并发数设置为20，则总的保留并发数为20 x 10 = 200(回想一下，您整个AWS帐户的最大并发数为1，000)。这个数字可以很快增加，更重要的是，这些Lambda中的每一个现在都被绑定到最大并发数20，这意味着您面向用户的Lambda不会随着您的流量增加而扩展，这是您最初使用Lambda的一个重要原因。</li><li id="2d35" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">对于资源密集型和/或可以异步处理的事情，例如发送电子邮件和生成报告，在API端点前建立一个SQS队列。这允许面向客户的Lambdas更快地完成它们的执行，因为资源密集型工作被推迟了。虽然这通常是一个很好的模式，因为它减少了用户的延迟，但它并不总是足以将Lambda并发性保持在足够低的水平以防止节流，如果您使用Lambda运行后台任务，它可能只会增加后台任务的并发性。</li><li id="0f6d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">将面向用户的Lambdas移动到不同的区域，这样您就可以访问不同的1000个并发池。这可能会大大增加部署的复杂性，甚至可能意味着其他服务，如Cognito、DynamoDB、SQS等。，将需要移动到另一个区域。</li></ol><p id="e447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用Lambda时，这些缓解措施中有很多是值得考虑的，但是它们没有解决导致节流的非常有限的并发控制的根本问题。如果你使用这些缓解措施，你基本上只是在招致技术债务，你以后会陷入困境。</p><p id="00c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">差错率和不可避免的节流？这两个都是交易破坏者，所以我们别无选择，只能从Lambda迁移出去。</p><h1 id="c1d3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">重构我们的代码，使其可以在Lambda和ECS上运行</h1><p id="8be3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">既然我们已经决定从Lambda迁移出去，我们想知道是否有一种方法可以对我们的代码进行最小的修改，这样它也可以在Docker环境中运行。</p><p id="b285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们选择AWS的弹性容器服务(ECS)来运行我们的容器，因为它相对容易管理，并且我们的DevOps团队有带宽来支持。幸运的是，我们注意到我们已经实现的Lambda处理程序利用了一个很好的抽象，可以用来从Docker支持的框架转换到Lambda框架，反之亦然。我们需要做的只是创建一个包装器，它将:</p><ol class=""><li id="b841" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">将ExpressJS请求有效负载转换为Lambda处理程序所需的<em class="lv">事件</em>有效负载</li><li id="3eba" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">将Lambda响应转换为ExpressJS响应</li><li id="1d51" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">使用一个包装器，允许我们重用所有现有的Lambda处理程序代码，并在ExpressJS框架上运行它！我们选择使用ExpressJS来构建RESTful API，因为我们使用Node.js，而ExpressJS是一个久经考验的框架。下面的实现是用JS编写的，但是该模式可以在任何web框架和任何编程语言中使用。(我们的实际实现是在TypeScript中。)</li></ol><p id="0e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些代码，看看我们是如何做到这一点的。考虑一个简化版本的Lambda处理程序，它实现了一个<code class="fe nv nw nx ny b">POST /lead/:leadId</code>路由，接受一个<code class="fe nv nw nx ny b">{ name, email }</code>的JSON主体:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用下面的代码创建了一个<code class="fe nv nw nx ny b">lambdaToExpress</code>函数，它可以在ExpressJS和Lambda之间来回转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用新的包装器注册了ExpressJS路由。下面是它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅用几行代码，我们就增强了单一代码库，以支持Lambda和ExpressJS。需要注意的一点是，<code class="fe nv nw nx ny b">lambdaToExpress</code>和<code class="fe nv nw nx ny b">handler</code>函数都在执行<code class="fe nv nw nx ny b">JSON.stringify() </code>和<code class="fe nv nw nx ny b">JSON.parse()</code>，这增加了一点额外的开销。也就是说，这些操作非常迅速，在大的计划中是不明显的。</p><p id="462d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码都设置好了，但是AWS的API网关提供的东西呢？</p><p id="bcf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的API的一部分是面向外部的，我们需要支持速率限制。为了实现这一点，我们引入了<a class="ae ky" href="https://github.com/animir/node-rate-limiter-flexible/wiki/Overall-example#authorized-and-not-authorized-users" rel="noopener ugc nofollow" target="_blank">节点速率限制器-灵活的</a>(由ElasticCache支持)来实现速率限制。并且，我们简单地将这个速率限制检查添加到我们的<code class="fe nv nw nx ny b">lambdaToExpress</code>包装器中，以便在一个地方实现它。</p><p id="a98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<a class="ae ky" href="https://www.google.com/search?q=severless+framework&amp;oq=severless+framework&amp;aqs=chrome..69i57j0i10i433j0i10l8.3121j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>来部署我们的Lambdas，你可能会使用这个框架来部署代码到ECS，但是我们发现<a class="ae ky" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一个稍微更通用的工具，用于配置非无服务器基础设施，并且已经使用Terraform来部署其他微服务。</p><p id="70a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们在我们的<code class="fe nv nw nx ny b">serverless.yml</code>配置旁边创建了<a class="ae ky" href="https://www.terraform.io/docs/language/modules/develop/index.html" rel="noopener ugc nofollow" target="_blank">地形模块</a>，并用<a class="ae ky" href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/" rel="noopener ugc nofollow" target="_blank"> Jenkinsfiles </a>部署它们。</p><p id="7eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们在ECS上运行！</p><p id="90bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在AWS Lambda上愉快地运行了一年多的RESTful API后端，并且发现我们已经降低了90%的计算成本！在以后的文章中，我将深入Lambda和ECS之间的成本比较。</p><h1 id="b70d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Lambda将其错误率从2%降至0.0000625%</h1><p id="4f7f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你还记得更早的时候，2019年8月，我们发现AWS Lambda的错误率高达2%！</p><p id="0768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2019年9月，AWS发布了一篇blob帖子，吹捧Lambda 的联网改进，这将减少冷启动引起的延迟。我们对这个消息感到非常兴奋，因为这意味着AWS已经承认了这个问题，并正在积极地解决这个问题。</p><p id="bce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将一些后端从Lambda迁移到ECS，但是在Lambda上还有很多剩余的功能。</p><p id="f4fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2021年，我们进行了另一项分析，发现Lambda的最新版本导致的错误率仅为0.0000625%。这比2%有了显著的提高！</p><p id="2a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们对auth-service的分析，auth-service是一个RESTful API，负责我们系统中的认证和授权功能。在七天的时间里，auth-service有大约160万次调用，只有一次导致超时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d2954d95c63ccd51529108d9bdb3337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i8vbNdiUPimCOjSa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">授权服务调用。图片来源:作者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/85ef0222348938492b06eb3a811832ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N-obFGuKKMdP9IIM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">授权服务错误。图片来源:作者</p></figure><p id="7165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于错误率如此之低，我们对面向用户的Lambdas的错误率担忧已经消除！但是对并发控制的持续关注呢？</p><h1 id="4d50" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">AWS如何改进其并发控制？</h1><p id="5456" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果您还记得，我们最终执行了上面提到的许多并发缓解措施，并将许多Lambdas转移到了ECS。</p><p id="2712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们得到了一个相对舒适的大约200个Lambdas的集合，因此，并发性现在不再是一个问题。</p><p id="6684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们现在避免对任何新的面向用户的服务使用Lambda。而且，我们通常避免在大量后台工作中使用它，因为我们担心过度使用会导致我们剩下的几个面向用户的Lambdas受到限制。</p><p id="4519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管目前的策略如此，我还是希望有一天AWS能够实现一个功能更加丰富的Lambda并发控制实现，更好地模仿ECS环境。以下是一些会带来巨大变化的增强功能:</p><h2 id="991e" class="oc me it bd mf od oe dn mj of og dp mn li oh oi mp lm oj ok mr lq ol om mt on bi translated">最大并发</h2><p id="6abe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们将Lambda的最大并发性定义为特定Lambda的最大并发调用设置。这个值<strong class="lb iu">不同于</strong>保留并发，因为最大并发的值不会从AWS帐户可用的总并发中减去。</p><p id="4741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:假设Lambda的最大并发数是100，而你的帐户的全局最大并发数是1000(AWS的默认值)。</p><p id="a3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到有超过100个Lambda实例同时运行时，Lambda才会被调节。其他Lambda，例如Lambda B/C，如果Lambda没有正在运行的实例，则仍然可以消耗多达1，000个实例。</p><p id="3351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实质上意味着，无论如何，Lambda A不能消耗总数1000个实例中的100个以上，但不要求我们从总数1000个实例中为Lambda A留出100个实例</p><p id="6672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个设置有点类似于ECS服务，它可以突发到最大任务的上限，但不要求我们保留一部分集群，即使该服务没有运行所有实例。</p><h2 id="dd57" class="oc me it bd mf od oe dn mj of og dp mn li oh oi mp lm oj ok mr lq ol om mt on bi translated">组最大并发数</h2><p id="97d6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们认为服务是一组相关的Lambdas。例如，考虑包含服务的10个RESTful端点的10个Lambdas。或者，定义ETL管道的工人的10个Lambdas。通常，我们希望为一组Lambda定义一个并发上限，例如，我们不希望我们的ETL管道消耗当前1000个Lambda调用中的100个以上。</p><p id="2e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过首先允许您将Lambdas标记为组的一部分，可以有效地实现组最大并发。其次，您可以设置该组的最大并发数。或者AWS甚至可以重用“堆栈”的概念，并拥有堆栈最大并发性。</p><p id="3897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个组最大并发性类似于您可能拥有的ECS服务，其中每个容器执行多个(一组)操作，例如，web服务器为多个RESTful API端点发送请求。</p><h2 id="85fe" class="oc me it bd mf od oe dn mj of og dp mn li oh oi mp lm oj ok mr lq ol om mt on bi translated">无需联系AWS支持即可提高全客户最大并发能力</h2><p id="9b50" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有些人会指出，你总是可以通过联系AWS支持来增加你的总Lambda并发性。</p><p id="731e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们这样做是为了将我们的<em class="lv">完全账户并发数</em>从1000提高到2000。AWS支持人员对此相当顺从，但是他们花了几天时间来进行更改，我们需要提供理由。</p><p id="cfb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一直以来，我们面向用户的Lambdas都受到了限制，我们的用户很不高兴。我甚至听说过一些公司能够让AWS将其最大并发数增加到几十万个Lambdas。</p><p id="0690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是为什么还需要特别批准呢？一家公司愿意为增加的使用量付费这一事实还不够吗？</p><p id="7d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与ECS相比，每个帐户的最大并发数设置类似于如何轻松自定义ECS群集中的节点数量，这实际上定义了可以并发运行的ECS任务的最大数量。</p><p id="4178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，ECS具有自动扩展功能，允许您根据自己的需求扩展群集。所有这些扩展都不需要AWS的特别批准。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="fc1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果AWS能够实现这些控制，它将使AWS Lambda的并发控制与ECS和EKS的并发控制平起平坐，我将再次倡导在我们系统的更多领域使用Lambda。</p><h1 id="6a3b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Lambda什么时候发光？</h1><p id="da64" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">即使有其有限的并发控制，Lambda仍在以下领域大放异彩:</p><ol class=""><li id="8650" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">用于后台任务，例如朗读SQS的任务。当然，你可以竖起类似于<a class="ae ky" href="https://docs.celeryproject.org/en/stable/" rel="noopener ugc nofollow" target="_blank">芹菜</a>或<a class="ae ky" href="https://github.com/OptimalBits/bull" rel="noopener ugc nofollow" target="_blank">公牛</a>的东西来得到类似的东西，但是将Lambda连接到SQS队列或许多其他AWS触发器中的一个，是一件非常简单的事情。注意:Lambda的最大超时是15分钟，所以它只适合运行相对快速的任务。</li><li id="52c7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当您有其他Lambda没有突发到消耗所有可用并发时，比如当您有相对少量的Lambda活动时。</li><li id="1a3c" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当您希望优化自动缩放，以便只为您使用的内容付费时。Lambda在单个调用层自动伸缩，因此在低流量期间可以节省大量资金</li><li id="3bb2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">作为运行代码的地方，无需管理基础设施</li></ol><h1 id="8165" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="abe8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">无服务器的承诺——开发者不需要管理基础设施——非常有吸引力，我不想让这个梦想破灭。</p><p id="147e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS已经修复了Lambdas的错误率问题，但Lambda仍然缺乏更好的并发控制。</p><p id="05ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些并发控制得到增强之前，如果您的Lambda使用量很大并且会导致节流，您可能会希望将ECS或EKS用于面向用户的服务。</p><p id="45de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我怀疑AWS将继续发展Lambda技术，直到它成为ECS的强大替代品，当它实现时，我将再次宣扬在任何地方使用Lambda的优点。</p><p id="96de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="52e2" class="oc me it bd mf od oe dn mj of og dp mn li oh oi mp lm oj ok mr lq ol om mt on bi translated">关于作者</h2><p id="9364" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">杰夫·考克斯是<a class="ae ky" href="https://www.knockcrm.com/" rel="noopener ugc nofollow" target="_blank"> Knock </a>的软件架构总监，也是<a class="ae ky" href="https://github.com/redgeoff/mson" rel="noopener ugc nofollow" target="_blank"> MSON </a>的创造者，这是一种新的声明式编程语言，它将允许任何人可视化地开发软件。</p></div></div>    
</body>
</html>