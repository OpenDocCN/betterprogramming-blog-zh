<html>
<head>
<title>Exploring the Underused Web Performance API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索未被充分利用的Web性能API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-underused-web-performance-api-9eb9946ac30d?source=collection_archive---------4-----------------------#2022-12-07">https://betterprogramming.pub/the-underused-web-performance-api-9eb9946ac30d?source=collection_archive---------4-----------------------#2022-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d043" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个使web性能分析更加简单的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/337790e7666f1508dc9898ccc5661635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VAFsw5aY2tZUnm_siUdng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@maxwbender?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克斯·本德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><blockquote class="kz la lb"><p id="715f" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这篇文章是处理未被充分利用的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance" rel="noopener ugc nofollow" target="_blank"> Web性能API </a>的<a class="ae ky" href="https://medium.com/@chamerling/list/web-performance-aea332cb8386" rel="noopener">系列文章的一部分。</a></p><p id="86f6" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这第一篇文章中，我将介绍这个强大的API，所有的Web开发人员都可以使用，不需要安装任何东西。</p><p id="c01c" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在接下来的文章中，我们将更详细地讨论，试图用更具体的例子来说明为什么不更深入地创建可重用的和准备好投入生产的代码和组件。</p></blockquote><div class="lz ma gp gr mb"><div role="button" tabindex="0" class="ab bv gv cb fp mc md bn me ks ex"><div class="mf l"><div class="ab q"><div class="l di"><img alt="Christophe Hamerling" class="l de bw mg mh fe" src="../Images/5408ee0c3d8b2f0dfcc319ef62d19018.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*_vPV0y0L5JyzedAeZXrsLA.jpeg"/><div class="fb bw l mg mh fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">克里斯托夫·哈默林</p></div></div><div class="mk ml gw l"><h2 class="bd iu tq og fp tr fr fs ts fu fw is bi translated">网络表演系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tt au tu tv tw pv tx an eh ei ty tz ua el em eo de bk ep" href="https://medium.com/@chamerling/list/web-performance-series-aea332cb8386?source=post_page-----9eb9946ac30d--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ub l fo"><span class="bd b dl z dk">3 stories</span></div></div></div><div class="mx dh my fp ab mz fo di"><div class="di mp bv mq mr"><div class="dh l"><img alt="" class="dh" src="../Images/58b1dff44b5a02533f3ef7fd30a37e60.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*Q9RbzpCThrtVOfji"/></div></div><div class="di mp bv ms mt mu"><div class="dh l"><img alt="" class="dh" src="../Images/8f1d9dab5b21022743e4fb26caf25170.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*sgKimQhExo0YaAsN"/></div></div><div class="di bv mv mw mu"><div class="dh l"><img alt="" class="dh" src="../Images/2d364a36f3a258d148d856cb6bd2afb9.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*9VAFsw5aY2tZUnm_siUdng.png"/></div></div></div></div></div></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="d0a9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">作为一名前端开发人员，您可能已经这样做了，以获得在代码的某些部分花费的时间:</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="a6ec" class="nt nu it np b be nv nw l nx ny">const start = Date.now()<br/>// do something...<br/>const diff = Date.now() - start</span></pre><p id="8d85" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">嗯，这是可行的…但这是相当有限的。如果您真的想度量“事物”，您可能需要开始使用<code class="fe nz oa ob np b">performance</code> API，它可以重构前面的代码:</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="e93f" class="nt nu it np b be nv nw l nx ny"><br/>const start = performance.now()<br/>// do something<br/>const diff = performance.now() - start</span></pre><p id="1168" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这样写，不会改变很多东西。这仍然是非常基本的，不会给你的代码增加价值。</p><p id="9477" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这两种方法的不同之处在于，<code class="fe nz oa ob np b">Date.now()</code>返回自1970年1月1日00:00:00 UTC以来经过的毫秒数，而<code class="fe nz oa ob np b">performance.now()</code>返回自时间起点以来的毫秒数，以微秒为单位(<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#the_time_origin" rel="noopener ugc nofollow" target="_blank">时间起点是一个标准时间，被认为是当前文档生命周期的开始</a>)。</p><p id="e5fa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">在上面的例子中使用其中一个没有什么大不了的，但是在调试时，获得页面时间原点的毫秒数比获得自1970年1月1日以来的毫秒数更容易阅读。(告诉我你是否可以轻松处理最新的一个，而无需将其转换为更具可读性的内容。)</p><p id="96fa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">Web Performance API有趣的部分不是关于<code class="fe nz oa ob np b">now()</code>，而是您可以使用其他特性做和构建的所有事情。我们再深入一步，玩玩<code class="fe nz oa ob np b">measure()</code>函数。它允许我们做同样的事情，即处理时差，但采用了更灵活的方法，如下所示:</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="c188" class="nt nu it np b be nv nw l nx ny">performance.mark('foo')<br/>// do something<br/>const diff = performance.measure('my_measure', 'foo')</span></pre><p id="838a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">当然，你猜对了！您可以创建一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceMeasure" rel="noopener ugc nofollow" target="_blank"> PerformanceMeasure </a>，方法是给出您之前使用<code class="fe nz oa ob np b">performance.mark(markName)</code>创建的标记名称，因此您可以在代码中的任何地方使用性能度量，而不必向下传递<code class="fe nz oa ob np b">start</code>变量。<code class="fe nz oa ob np b">diff</code>变量现在包含了一个<code class="fe nz oa ob np b">PerformanceMeasure</code>对象，它包含了比两个时间戳之间的差异更多的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b91baefd82c9b58834130f5dd486208e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PG9BYBz0o0VT9yaeR8Lr5Q.png"/></div></div></figure><p id="9a34" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">您也可以通过给定开始和结束标记名称来创建两个标记之间的度量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/154f677e998ae38b34ac47426fb35e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4tpH7g-uzjDWUzf9TomjQ.png"/></div></div></figure><p id="e212" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这看起来很容易使用，然后你可以在代码的几个地方使用它，在某个地方创建第一个标记，在另一个地方创建第二个标记，然后通过知道它们的名称来测量你选择的标记之间的距离。进入web性能的巨大世界是非常容易的。</p><p id="13c8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">更好的是，您现在可以切换您的浏览器开发工具，并检查您的应用程序中正在发生什么。您对<code class="fe nz oa ob np b">mark()</code>和<code class="fe nz oa ob np b">measure()</code>的每次调用都可以在性能记录中找到，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fc4e02f69662b4047aaf246a8846bf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odnqG-wBmnVFiez-0i6xvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">performance.measure('foobar '，' foo '，' bar ')</p></figure><p id="c4dc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这是奖金。您可以将性能日志下载为一个文件，并在以后打开它们进行进一步的分析。您创建的所有标记和度量也可以在这里找到！</p><p id="b844" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">让我们用精彩的性能API更进一步，和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver" rel="noopener ugc nofollow" target="_blank">性能观察者</a>一起玩吧！</p><p id="51db" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">如前所述，能够从标记中创建度量是很好的，但是它有点静态。使用performance observers允许您进行更复杂的性能分析，比如实时收集您标记或测量的所有内容，对其进行处理，并将其发送到另一个地方(例如，收集一些监控数据的服务，应用程序的另一部分，等等。)</p><p id="9e27" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这个API使用起来很简单:创建一个带有回调的观察器，一旦您选择的新性能数据可用，就会调用这个回调。通过告诉观察器观察什么来启动它。代码如下:</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="c7fd" class="nt nu it np b be nv nw l nx ny">try {<br/>  const po = new PerformanceObserver((list) =&gt; {<br/>    for (const entry of list.getEntries()) {<br/>      // Do anything you want with the performance entry you observe<br/>      // Here we deal with marks as it is what we tell to observe below.<br/>      console.log(entry.toJSON());<br/>    }<br/>  });<br/>  po.observe({ type: 'mark', buffered: false });<br/>} catch (e) {<br/>  // Do nothing if the browser doesn't support this API.<br/>}</span></pre><p id="5cf6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">如果“实时”对您来说不是什么有用的东西，您还可以查询Performance API并通过使用<code class="fe nz oa ob np b">getEntries</code>或<code class="fe nz oa ob np b">getEntriesByType</code>来检索数据。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="1c25" class="nt nu it np b be nv nw l nx ny">const marks = performance<br/>  .getEntriesByType("mark")<br/>  .forEach((entry) =&gt; console.log(entry))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/51451f66934bc7638cfb8cad2d13b29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9bumDNc_5YkIWaJPwl2fA.png"/></div></div></figure><p id="b15e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">这里有几个注意事项:</p><ol class=""><li id="8a27" class="og oh it lf b lg lh lj lk nl oi nm oj nn ok ly ol om on oo bi translated">正如您所看到的，性能标记名称不必是唯一的，但是如果您使用与您的应用程序相关联的命名约定，那就更好了。这有助于避免与您使用的任何库或框架发生冲突(想象每个人都使用‘start’和‘end’用上面的代码获取条目并从列表中进行一些计算可能会产生不一致的东西)。</li><li id="5000" class="og oh it lf b lg op lj oq nl or nm os nn ot ly ol om on oo bi translated">请记住，您创建的标记和度量将保留在这里，直到您重新加载页面、条目缓冲区已满，或者您使用<code class="fe nz oa ob np b">clearMarks</code>或<code class="fe nz oa ob np b">clearMeasures</code>请求一些清理。</li></ol></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="75de" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll nl ln lo lp nm lr ls lt nn lv lw lx ly im bi translated">在本文中，我们开始深入研究性能标记、度量、观察者和记录，展示了它的易用性以及它是如何打开web性能分析之门的。在下一篇文章中，我们将实现现实世界和生产就绪的代码和组件来收集您的应用程序中的指标。</p></div></div>    
</body>
</html>