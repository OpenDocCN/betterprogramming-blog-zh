<html>
<head>
<title>Exploring API Gateways: Kong Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索API网关:Kong设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-api-gateways-kong-setup-abfde6ed79fb?source=collection_archive---------9-----------------------#2022-01-06">https://betterprogramming.pub/exploring-api-gateways-kong-setup-abfde6ed79fb?source=collection_archive---------9-----------------------#2022-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="85b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件架构的美妙之处在于无数的策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1f28384594a9e499ec749a0242c3f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IO6Assez2avsyqG4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@keithhardy2001?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基思·哈迪</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我觉得有一项技术可以帮助我创建更好的架构，那就是API网关。</p><p id="0b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经避开了微服务架构，但是我看了<a class="ae kv" href="https://www.youtube.com/watch?v=zzMLg3Ys5vI" rel="noopener ugc nofollow" target="_blank">连续交付的视频</a>，可独立部署的服务让我眼前一亮。</p><p id="81da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">软件架构的美妙之处在于无数的策略。想象一个设计，你可以在开发层次上解耦你的组织。我要去争取。</p><p id="c030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信有一项技术可以帮助我设计更好的架构(不仅仅是微服务),那就是API网关。它将帮助我绑定底层容器并识别共享功能。我将在以后的文章中介绍它。现在，<a class="ae kv" href="https://github.com/vargasmesh/Kong-in-Kubernetes" rel="noopener ugc nofollow" target="_blank">我将提出我的出发点</a>。</p><p id="5d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一番研究，我决定用<a class="ae kv" href="https://konghq.com/kong/" rel="noopener ugc nofollow" target="_blank">孔</a>作为我的学习工具，多半是因为自定义Golang插件，可以在本地运行。</p><h1 id="cf37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概观</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/32d67f88cf140018e953d7490f55da1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJzpBV3IQWVMmOF7H2HtVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集装箱图</p></figure><p id="00f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kong API网关将部署在Kubernetes集群中，并使用声明性方法进行配置。我将把本地配置文件与包含decK容器的Pod同步，该容器将与Kong Admin API通信。</p><h1 id="dab2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">库伯内特斯</h1><p id="aade" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我选择Kubernetes只是为了个人挑战。使用Docker Compose可能更容易、更快。</p><p id="49ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择<a class="ae kv" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">类</a>来创建集群，因为它速度更快，而且我可以将所有东西保存在单个Docker网络中，甚至是Postgres数据库。</p><p id="c6b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">端口8000和8443将被暴露以与Kong代理交互并测试我们的微服务架构。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cf45" class="mv lt iq mr b gy mw mx l my mz">kind: Cluster<br/>apiVersion: kind.x-k8s.io/v1alpha4<br/>name: kong-in-kubernetes<br/>nodes:<br/>  - role: control-plane<br/>    extraPortMappings:<br/>      - containerPort: 32080<br/>        <strong class="mr ir">hostPort: 8000</strong><br/>      - containerPort: 32443<br/>        <strong class="mr ir">hostPort: 8443</strong></span></pre><p id="223c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后:<code class="fe na nb nc mr b">kind create cluster --config kind.yaml</code></p><h1 id="d0f2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">孔的Postgres数据库</h1><p id="d0f4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Postgres中使用Kong似乎是公平的，但我不想在Kubernetes中部署数据库(<em class="nd">后悔我的选择)</em>，太多的工作和复杂性<em class="nd">。</em></p><p id="9db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更简单的方法是在kind的网络中部署一个Postgres数据库，并使用一个<code class="fe na nb nc mr b">ExternalName</code>服务引用它。</p><p id="5c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker撰写:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ec23" class="mv lt iq mr b gy mw mx l my mz">services:<br/>  <strong class="mr ir">database:</strong><br/>    image: postgres<br/>    ports:<br/>      - 5432:5432<br/><strong class="mr ir">    networks:<br/>      - kind</strong><br/>    environment:<br/>      POSTGRES_DB: kong<br/>      POSTGRES_USER: kong<br/>      POSTGRES_PASSWORD: kong</span><span id="f047" class="mv lt iq mr b gy ne mx l my mz"><strong class="mr ir">networks:<br/>  kind:<br/>    external: true<br/>    name: kind</strong></span></pre><p id="fcc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Postgres ExternalName服务</strong>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c14f" class="mv lt iq mr b gy mw mx l my mz">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: postgres<br/>spec:<br/>  type: ExternalName<br/>  <strong class="mr ir">externalName: database</strong></span></pre><p id="bbcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行一切:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="671b" class="mv lt iq mr b gy mw mx l my mz">docker-compose up -d</span><span id="0201" class="mv lt iq mr b gy ne mx l my mz">kubectl apply -f postgres/svc.yaml</span></pre><h1 id="0559" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">孔（姓）</h1><p id="42f9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">完成所有设置后，我们可以将重点放在API网关上。在Kubernetes中部署Kong最简单的方法是使用Helm图表，我将在图表中分解一些<a class="ae kv" href="https://github.com/vargasmesh/Kong-in-Kubernetes/blob/main/kong/values.yaml" rel="noopener ugc nofollow" target="_blank">基本值</a>。</p><h2 id="5a20" class="mv lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">环境变量</h2><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ad04" class="mv lt iq mr b gy mw mx l my mz">env:<br/>  database: postgres<br/>  <strong class="mr ir">pg_host: database</strong><br/>  pg_user: kong<br/>  pg_password: kong<br/>  pg_database: kong<br/>  declarative_config: /opt/kong/kong.yaml</span></pre><p id="c294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mr b">env</code>部分中的每个变量都将被转换为大写并以<code class="fe na nb nc mr b">KONG_</code>为前缀。我们的目的是指导孔使用Postgres数据库，之所以将<code class="fe na nb nc mr b">env.pg_host</code>设置为<code class="fe na nb nc mr b">database</code>，是Postgres在kind网络中的服务名称。</p><h2 id="f3df" class="mv lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">Kong管理API</h2><p id="3c95" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将使用需要与Kong管理API通信的decK来配置Kong。但是我们不想在Kubernetes之外公开这个API。这就是我们将使用ClusterIP服务的原因:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ccda" class="mv lt iq mr b gy mw mx l my mz">admin:<br/>  enabled: true<br/><strong class="mr ir">  type: ClusterIP<br/></strong>  <br/>  http:    <br/>    enabled: true</span></pre><h2 id="4765" class="mv lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">揭露孔代理人</h2><p id="5df9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到今天结束时，我们需要测试我们的API网关，并且它需要暴露在Docker网络之外。在<code class="fe na nb nc mr b">Kind</code>的配置中，这种容器将容器的端口<code class="fe na nb nc mr b">32080</code>和<code class="fe na nb nc mr b">32443</code>分别绑定到8000和8443。这些将是<code class="fe na nb nc mr b">NodePorts</code>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="436f" class="mv lt iq mr b gy mw mx l my mz">proxy:  <br/>  enabled: true  <br/><strong class="mr ir">  type: NodePort  </strong></span><span id="beea" class="mv lt iq mr b gy ne mx l my mz">  http:    <br/><strong class="mr ir">    nodePort: 32080<br/></strong>  <br/>  tls:<br/><strong class="mr ir">    nodePort: 32443</strong></span></pre><h2 id="5bea" class="mv lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">部署孔</h2><p id="e188" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一切就绪后，我们可以运行:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d1ec" class="mv lt iq mr b gy mw mx l my mz">helm repo add kong https://charts.konghq.com<br/><br/>helm repo update<br/><br/>helm install -n kong --create-namespace api-gateway kong/kong --set ingressController.installCRDs=false --values kong/values.yaml</span></pre><h2 id="dd52" class="mv lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">声明性配置</h2><p id="b731" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在迭代Kong的特性之前，我们的最后一步是配置API网关。我更喜欢声明式方法，但这需要同步本地文件。<strong class="ky ir">可悲的是，我把我和Kubernetes的生活复杂化了，但我想到了一个解决办法。</strong></p><p id="ddb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<strong class="ky ir">ku bectl</strong>T15】CP和<strong class="ky ir"> decK </strong>，我创建了一个脚本:</p><ol class=""><li id="0113" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">产生一个有甲板的豆荚</li><li id="23f1" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">将本地kong.yaml文件复制到decK的容器中</li><li id="cc1f" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">在decK中运行同步命令</li><li id="3457" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">删除窗格</li></ol><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="21d3" class="mv lt iq mr b gy mw mx l my mz">#!/bin/bash</span><span id="eb71" class="mv lt iq mr b gy ne mx l my mz">kubectl run -n kong --wait --restart=Never deck --image=kong/deck --command -- sleep 3600<br/>kubectl wait -n kong --for=condition=ready pods/deck<br/>kubectl cp ./kong/kong.yaml kong/deck:/tmp/kong.yaml<br/>kubectl exec -n kong deck -- deck sync --kong-addr=<a class="ae kv" href="http://api-gateway-kong-admin:8001" rel="noopener ugc nofollow" target="_blank">http://api-gateway-kong-admin:8001</a> -s /tmp/kong.yaml<br/>kubectl delete -n kong pods/deck</span></pre><p id="9b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">decK使用由图表值文件中的<code class="fe na nb nc mr b">admin</code>部分创建的服务与Kong API通信。</p><p id="becd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备好出发了。</p><h1 id="8a3a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后续步骤</h1><p id="b26a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是一篇入门文章，但却是一个起点:Kubernetes集群与Kong API Gateway <strong class="ky ir">准备迭代微服务设计</strong>。</p><p id="af95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在我的GitHub资源库中查看完整的环境:</p><p id="76c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://github.com/vargasmesh/Kong-in-Kubernetes<a class="ae kv" href="https://github.com/vargasmesh/Kong-in-Kubernetes" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="03ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我将为这个微观世界起航，看看我们能从中学到什么。</p></div></div>    
</body>
</html>