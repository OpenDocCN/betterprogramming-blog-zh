<html>
<head>
<title>The Interface Segregation Principle (ISP) Explained in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中解释的接口分离原则(ISP)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-interface-segregation-principle-isp-explained-in-python-46e173241642?source=collection_archive---------7-----------------------#2022-03-21">https://betterprogramming.pub/the-interface-segregation-principle-isp-explained-in-python-46e173241642?source=collection_archive---------7-----------------------#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4aa2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看接口以及如何用坚实的原则4/5编写干净和可维护的代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa7c22a9cdd7312131f80c383dc9f5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hrv1g8WFyIhtdcfq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊恩·帕克 / <a class="ae ky" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>摄影</p></figure><p id="f3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则系列文章的第4部分。<br/>你可以在这里找到3号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-lsp-explained-in-python-6ab92b29d0b8">，在这里</a>找到2号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-explained-in-python-f5517488f990">，在这里</a>找到1号岗位<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-explained-in-python-622e2d996d86">。</a></p><p id="0517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们来看看<strong class="lb iu"> SOLID </strong>缩写中的<strong class="lb iu"> I- </strong>，它代表接口分离原则。我们从一个定义开始:</p><blockquote class="lv lw lx"><p id="d56c" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">不应该强迫客户依赖他们不使用的方法。<br/>来源:<a class="ae ky" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwizz73Eu8v2AhWGr4sKHWc7D7kQFnoECAQQAQ&amp;url=http%3A%2F%2Fstg-tud.github.io%2Fsedc%2FLecture%2Fws16-17%2F3.2-ISP.pdf&amp;usg=AOvVaw3NunCPzJ05HTwWHeRekwRB" rel="noopener ugc nofollow" target="_blank">敏捷软件开发；罗伯特·马丁；</a></p></blockquote><p id="17b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这个原则类似于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-explained-in-python-622e2d996d86">单一责任原则</a>，在这个意义上，类应该只实现它们实际使用的方法。</p><p id="dbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个实现基类中所有方法的子类。但是对于一个特定的方法，函数体会引发一个异常，因为我们根本不想让这个方法被调用。那个特定的方法会违背类的<em class="ly">行为</em>定义，技术上不应该实现。这将违反ISP原则，需要重构。</p><p id="dc3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会想为什么子类要实现一个它不需要的方法？你看，这个原理处理的是接口。当一个接口被继承时，所有存在的方法都必须被实现。</p><p id="dbe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续下一步之前，让我们快速看一下接口和duck typing。</p><h2 id="41f3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">Python中的接口、抽象类和鸭子类型</h2><p id="0213" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接口是一种软件构造，它定义并强制一个类的对象应该拥有什么方法。在Python中，我们利用<a class="ae ky" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank"> duck typing </a>来创建一个接口。我们简单地用一个抽象类来表示一个接口。Duck typing声明:</p><blockquote class="lv lw lx"><p id="d40a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果它走路像鸭子，叫声像鸭子，那么它一定是鸭子<br/>来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Duck_typing#Example" rel="noopener ugc nofollow" target="_blank">鸭子打字—维基百科</a></p></blockquote><p id="f585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，如果我们定义的类<em class="ly">的行为</em>像一个接口，我们可以像使用一个接口一样使用它。如果你没有完全掌握这一点，也不要担心。这里的关键点是，我们将抽象类视为一个接口(通过空方法体和声明方法抽象，我们将在后面看到这一点)。<br/>这是给你的鸭子🦆</p><p id="6954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别再说鸭子了。是时候写点代码了👩🏾‍💻</p><h2 id="1588" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">密码</h2><p id="036e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接口可以被认为是一个完全抽象的类。因此，我们用<code class="fe na nb nc nd b">@abstractmethod</code>注释抽象类中的所有方法。</p><p id="fcb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次重用前一篇文章的场景，考虑一辆汽车🙂</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义一个抽象基类<code class="fe na nb nc nd b">Car</code>。这也可以被认为是一个接口，因为这三个方法都被定义为抽象的。</p><p id="5f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建两个子类，即<code class="fe na nb nc nd b">RegularCar</code>和<code class="fe na nb nc nd b">SportsCar</code>。这两个类继承了<code class="fe na nb nc nd b">Car</code>中定义的方法。但是请注意，<code class="fe na nb nc nd b">RegularCar</code>没有turbo，所以如果在<code class="fe na nb nc nd b">RegularCar</code>对象上调用<code class="fe na nb nc nd b">turboAccelerate</code>，我们会引发一个异常。</p><p id="0651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以测试<code class="fe na nb nc nd b">__main__</code>函数中的代码，并看到对<code class="fe na nb nc nd b">turboAccelerate</code>的调用确实引发了异常。其他一切都像预期的那样工作。</p><p id="4467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能会想，如果不打算使用<code class="fe na nb nc nd b">RegularCar</code>函数，为什么要为它定义<code class="fe na nb nc nd b">turboAccelerate</code>函数。没错。这就是ISP的原理。如果不支持的话，我们不应该强迫一个<code class="fe na nb nc nd b">RegularCar</code>去实现<code class="fe na nb nc nd b">turboAccelerate</code>。从本质上说，这是我们车型的设计缺陷。</p><p id="6037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，第二个问题是代码维护。假设我们需要在<code class="fe na nb nc nd b">turboAccelerate</code>函数中改变一些东西。假设我们需要在函数定义中包含一个额外的参数。如果我们对接口做了这样的修改，我们也必须对<code class="fe na nb nc nd b">RegularCar</code>做修改，即使函数只是抛出了一个异常！换句话说，我们被迫做出无用的改变<em class="ly">只是为了让</em>代码编译。</p><p id="a7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复非常简单。我相信你已经看到了😎</p><h2 id="4347" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">解决办法</h2><p id="83e2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以下是代码的重构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以。我们的目标是将<code class="fe na nb nc nd b">turboAccelerate</code>从<code class="fe na nb nc nd b">RegularCar</code>中移除。但是我们不能这样做，因为接口包含方法，并且接口中的所有方法都必须由子类实现。所以，解决的办法就是做两个接口。一个叫<code class="fe na nb nc nd b">NoTurbo</code>，另一个叫<code class="fe na nb nc nd b">WithTurbo</code>。<br/>我们只是让<code class="fe na nb nc nd b">turboAccelerate</code>成为<code class="fe na nb nc nd b">WithTurbo</code>中的函数，而不是<code class="fe na nb nc nd b">NoTurbo</code>中的函数。普通车实现<code class="fe na nb nc nd b">NoTurbo</code>而涡轮车实现<code class="fe na nb nc nd b">WithTurbo</code>。</p><p id="bbeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题解决了！</p><p id="3b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，我们并没有创建两个独立的接口。相反，我们用<code class="fe na nb nc nd b">WithTurbo</code>(继承)扩展了<code class="fe na nb nc nd b">NoTurbo</code>。<br/>这样做只是为了减少代码冗余，因为<code class="fe na nb nc nd b">WithTurbo</code>中只有一个额外的函数。</p><p id="b6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！正如你现在看到的，<code class="fe na nb nc nd b">RegularCar</code>和<code class="fe na nb nc nd b">SportsCar</code>没有实现任何他们不需要的无用功能。</p><h2 id="b36d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">包裹</h2><p id="1899" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这篇文章中，你学习了接口分离原则。基本上，这个原则声明一个类不应该被强制实现它不使用的函数。</p><p id="4688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如同所有坚实的原则一样，ISP有助于使代码更易于管理和健壮。尤其是在必须对接口进行更改，并向下传播到实现它的所有子类的情况下。如果没有ISP，被更新的功能也必须在子类中更新，即使它们没有实现任何业务逻辑。</p><p id="e19a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子到此为止。希望你学到了一些有价值的东西！</p><p id="b85d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下周，我们将到达终点，看看最后的坚实的原则。<br/>敬请期待！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="6173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">原载于</em><a class="ae ky" href="https://haseebkamal.com/p/5bb14e35-827c-46fb-9e6a-a8a3631c7a12/" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://haseebkamal.com</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>