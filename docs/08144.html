<html>
<head>
<title>10 Fundamentals You Need To Know About Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript中的函数，你需要知道的10个基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-fundamentals-you-need-to-know-about-functions-in-javascript-8e74579b7a9a?source=collection_archive---------3-----------------------#2021-03-31">https://betterprogramming.pub/10-fundamentals-you-need-to-know-about-functions-in-javascript-8e74579b7a9a?source=collection_archive---------3-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b58f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义后自动执行，函数可以是闭包，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbc56a757f58a7822f2d64adc6f63112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mXcD-b40l4srBzqO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@girlwithredhat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴着红色帽子</a>的女孩在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是JavaScript中最重要的概念之一。在这篇文章中，我们将看看你可能需要了解的一些基本知识。</p><h1 id="b82b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.可以使用函数声明来声明函数</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a205" class="ms lw it mo b gy mt mu l mv mw">function compute(){}</span></pre><p id="0184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用函数声明时，<code class="fe mx my mz mo b">function</code>关键字是第一行。函数必须有名称，并且可以在定义前使用。</p><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数声明被移动或“提升”到其作用域的顶部。这意味着我们可以在函数被声明之前使用它。以下示例是使用函数声明创建的函数的有效用法:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="84ba" class="ms lw it mo b gy mt mu l mv mw">compute();</span><span id="2fbd" class="ms lw it mo b gy na mu l mv mw">function compute(){}</span></pre><h1 id="3c38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.可以使用函数表达式创建函数</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6536" class="ms lw it mo b gy mt mu l mv mw">const compute = function() {};</span></pre><p id="2e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当关键字<code class="fe mx my mz mo b">function</code>不是一行中的第一个时，我们创建函数表达式。在这种情况下，名称是可选的。可以有匿名函数表达式，也可以有命名函数表达式。</p><p id="fb0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先需要定义函数表达式，然后才能调用它们。以下示例不是函数表达式的有效用法。函数表达式不被提升。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="02b7" class="ms lw it mo b gy mt mu l mv mw">compute();<br/>//Uncaught ReferenceError: Cannot access 'compute' before initialization</span><span id="a74a" class="ms lw it mo b gy na mu l mv mw">const compute = function() {};</span></pre><h1 id="6908" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.可以使用箭头语法创建函数</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2c6d" class="ms lw it mo b gy mt mu l mv mw">const compute = () =&gt; {};</span></pre><p id="541f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">arrow函数是一个用于创建匿名函数表达式的sugar语法。与其他函数表达式一样，我们不能在创建之前使用函数。以下示例不是用arrow语法创建的函数表达式的有效用法。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="12bb" class="ms lw it mo b gy mt mu l mv mw">compute();<br/>//Uncaught ReferenceError: Cannot access 'compute' before initialization</span><span id="af8d" class="ms lw it mo b gy na mu l mv mw">const compute = () =&gt; {};</span></pre><h1 id="7a94" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.函数表达式可以在定义后自动执行</h1><p id="5d8f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">的确，函数表达式可以在定义时被调用。这类函数被称为立即调用函数表达式(IIFE)。</p><p id="f355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个生活的例子。请注意，<code class="fe mx my mz mo b">function</code>不是该行的第一个关键字。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d6b7" class="ms lw it mo b gy mt mu l mv mw">(function doSomething(){<br/>  console.log('run');<br/>})();<br/>//'run'</span></pre><p id="b1ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能见过在<code class="fe mx my mz mo b">function</code>关键字之前使用的<code class="fe mx my mz mo b">!</code>操作符，并想知道为什么。这就是为什么。它用于将函数转换为函数表达式，以便可以自动执行。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="478e" class="ms lw it mo b gy mt mu l mv mw">!function doSomething(){<br/>  console.log('run')<br/>}();</span></pre><h1 id="bbe6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.函数可以是方法</h1><p id="f07c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">函数可以用作对象的方法。看下一个例子:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7af4" class="ms lw it mo b gy mt mu l mv mw">const obj = {<br/>  compute: function(){}<br/>}</span><span id="4355" class="ms lw it mo b gy na mu l mv mw">obj.compute();</span></pre><p id="75ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mo b">compute</code>属性保留一个函数。它是一个方法属性。它还有一个简写语法，如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6ce7" class="ms lw it mo b gy mt mu l mv mw">const obj = {<br/>  compute(){}<br/>}</span></pre><p id="93a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个函数作为一个对象的方法使用时，它需要访问那个对象。<a class="ae ky" href="https://medium.com/programming-essentials/removing-javascripts-this-keyword-makes-it-a-better-language-here-s-why-db28060cc086" rel="noopener">这个</a>关键字提供了对对象的访问，其中函数被用作方法。</p><p id="f9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下一个用两个道具创建一个<code class="fe mx my mz mo b">ratingObj</code>的例子。<code class="fe mx my mz mo b">ratings</code>道具存储一个数组，<code class="fe mx my mz mo b">rateIt</code>道具保存一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mo b">rateIt</code>方法允许向<code class="fe mx my mz mo b">ratings</code>数组添加几个等级，并返回平均等级。</p><p id="f611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意如何使用<code class="fe mx my mz mo b">this</code>关键字在<code class="fe mx my mz mo b">rateIt()</code>函数中访问<code class="fe mx my mz mo b">ratings</code>属性。</p><h1 id="2fcd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.箭头函数没有自己的这个</h1><p id="8e49" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当函数作为方法使用时，它们需要访问它们所附加的对象的属性。<code class="fe mx my mz mo b">this</code>关键字指的是那个对象。</p><p id="175e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用arrow语法创建的函数没有自己的<code class="fe mx my mz mo b">this</code>，它们不应该作为方法使用。它们的主要目的是创建内联函数。</p><p id="ff56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个创建内嵌匿名函数作为内置实用程序<code class="fe mx my mz mo b">setTimeout</code>回调的例子。用arrow语法创建的内部函数是在方法内部定义的。arrow函数中的<code class="fe mx my mz mo b">this</code>关键字引用了与<code class="fe mx my mz mo b">delayMessage</code>方法相同的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="5014" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.函数是对象</h1><p id="37f0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">函数是JavaScript中的对象，这意味着它们是属性的动态集合。</p><p id="b6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们从<code class="fe mx my mz mo b">Function.prototype</code>对象继承属性，后者又从<code class="fe mx my mz mo b">Object.prototype</code>对象继承。检查<code class="fe mx my mz mo b">sum</code>功能。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0b0d" class="ms lw it mo b gy mt mu l mv mw">function sum(x, y){<br/>   return x + y;<br/>}</span><span id="969d" class="ms lw it mo b gy na mu l mv mw">Object.getPrototypeOf(sum) === Function.prototype;<br/>//true</span></pre><p id="816e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数继承类似<code class="fe mx my mz mo b">call</code>或<code class="fe mx my mz mo b">apply</code>的方法属性。</p><p id="bd7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mo b">call</code>使用给定的关联对象(<code class="fe mx my mz mo b">this</code>值)和单独提供的参数调用函数。</p><p id="be23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用<code class="fe mx my mz mo b">call</code>方法调用<code class="fe mx my mz mo b">sum</code>函数的例子。这个调用没有关联的对象，所以我们可以将第一个参数作为<code class="fe mx my mz mo b">null</code>发送。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c16d" class="ms lw it mo b gy mt mu l mv mw">const total = sum.call(null, 1, 2);<br/>//3</span></pre><p id="7a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用给定的关联对象和以数组形式提供的所有参数调用函数。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="850a" class="ms lw it mo b gy mt mu l mv mw">const total = sum.apply(null, [1, 2]);<br/>//3</span></pre><h1 id="1cd7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.函数可以作为参数发送给其他函数</h1><p id="ebd4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">函数是对象，所以像其他对象一样，它们可以被发送给函数。</p><p id="9f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个例子中，函数<code class="fe mx my mz mo b">isEven</code>作为参数被发送给<code class="fe mx my mz mo b">filter()</code>数组方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="b003" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">9.函数可以从函数中返回</h1><p id="6c0e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/programming-essentials/7-things-you-should-know-about-objects-in-javascript-c0b2f251e160" rel="noopener">对象</a>可以从函数中返回。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4aa4" class="ms lw it mo b gy mt mu l mv mw">function getEmptyObject() {<br/>  return {};<br/>}</span></pre><p id="9fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他对象一样，函数也可以从函数中返回。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9200" class="ms lw it mo b gy mt mu l mv mw">function createFunction(x){<br/>  return function(){};<br/>}</span></pre><p id="bd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mx my mz mo b">function</code>不是该行的第一个关键字，所以我们返回一个函数表达式。</p><h1 id="4be7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">10.函数可以是闭包</h1><p id="4c26" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">函数可以在其他函数内部声明，并且可以从外部函数访问变量。</p><p id="7116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要知道，即使在外部函数执行之后，内部函数也可以访问这些变量。考虑下一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mo b">createRateIt</code>函数返回另一个函数。</p><p id="6ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为这个例子中的<code class="fe mx my mz mo b">ratings</code>变量可以在<code class="fe mx my mz mo b">createRateIt</code>函数执行后被垃圾收集，但事实并非如此。<code class="fe mx my mz mo b">ratings</code>变量也被<code class="fe mx my mz mo b">rateIt</code>函数引用，该函数在<code class="fe mx my mz mo b">createRateIt</code>函数执行后仍然有效。</p><p id="42c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mx my mz mo b">rateIt()</code>功能是一个<a class="ae ky" href="https://medium.com/programming-essentials/you-will-finally-understand-what-closure-is-13ba11825319" rel="noopener">闭合</a>。即使在执行之后，它也可以从其父函数<code class="fe mx my mz mo b">createRateIt</code>访问该变量。</p><p id="baa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/programming-essentials/you-will-finally-understand-what-closure-is-13ba11825319" rel="noopener">闭包</a>封装数据。<code class="fe mx my mz mo b">ratings</code>数组封装在<code class="fe mx my mz mo b">rateIt</code>闭包函数内部，不能从外部直接访问。它只能通过使用closure函数来更改。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="abc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于JavaScript基础的更多内容，你可以看看<a class="ae ky" href="https://medium.com/programming-essentials/learn-these-javascript-fundamentals-and-become-a-better-developer-2a031a0dc9cf" rel="noopener">学习这些JavaScript基础，成为更好的开发者</a>。</p><p id="05f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>