<html>
<head>
<title>When to Use the Comparable Protocol in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时在Swift中使用类似协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-use-the-comparable-protocol-in-swift-b9f137b07413?source=collection_archive---------13-----------------------#2020-03-09">https://betterprogramming.pub/when-to-use-the-comparable-protocol-in-swift-b9f137b07413?source=collection_archive---------13-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个协议对于定制数组的排序非常方便</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b5ee02bc5151c129918324d372d790f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lUJ5BhmMD1LMyoD9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jankolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kolar.io </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="472b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个简短的教程中，我们将快速探索和掌握Swift中的可比协议。</p><p id="a50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Comparable协议是有用的，因为一旦我们的定制<code class="fe lv lw lx ly b">Array</code>符合它，它就允许我们获得免费的排序功能。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4944" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们开始吧</h1><p id="8fc7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们有一个工资跟踪应用程序，因此我们创建了<code class="fe lv lw lx ly b">Wage</code>模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们用类型为<code class="fe lv lw lx ly b">Int</code>的<code class="fe lv lw lx ly b">rawValue</code>定义了一个<code class="fe lv lw lx ly b">Month</code>枚举，这意味着我们将每个相应的月份对应于一个整数(例如，一月等于1，二月等于2，等等)。</p><p id="bca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建一个包含<code class="fe lv lw lx ly b">year</code>和<code class="fe lv lw lx ly b">month</code>属性的<code class="fe lv lw lx ly b">Wage</code>结构。</p><p id="f030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于调试目的，我们遵循<code class="fe lv lw lx ly b">CustomStringConvertible</code>协议。如果你不熟悉它，我建议你看一下我的<a class="ae ky" href="https://medium.com/better-programming/what-is-the-customstringconvertible-protocol-in-swift-4b7ddbc5785b" rel="noopener">文章，在那里我用两分钟</a>解释了它。</p><p id="5314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个由<code class="fe lv lw lx ly b">Wage</code>组成的样本数组，并对其进行洗牌，这样我们就有了一个随机集合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们实现<code class="fe lv lw lx ly b">Comparable</code>协议，为我们的<code class="fe lv lw lx ly b">wages</code>数组提供排序功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="714e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们提供了一个<code class="fe lv lw lx ly b">&lt;</code>方法来按照自定义的升序对集合进行排序。</p><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，因为我们已经实现了<code class="fe lv lw lx ly b">&lt;</code>方法，所以我们不需要定义下降的<code class="fe lv lw lx ly b">&gt;</code>方法。太好了！</p><p id="b729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排序完成后，让我们编写代码来调试我们的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="72e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经按照升序打印了数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/efa79ff1ccad329e7092d2e01a3aa942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ5My4QE8O6KWlMhL5BCeg.png"/></div></div></figure><p id="d9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照降序排列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/04625d89e587549926a62a32a650dc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yAhS0l3gBV_kOKTMTIiyQ.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4893" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><p id="cb95" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有关更多信息，请访问Apple官方文档:</p><div class="nh ni gp gr nj nk"><a href="https://developer.apple.com/documentation/swift/comparable" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">可比较的</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Comparable协议用于具有固有顺序的类型，如数字和字符串。许多类型在…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">developer.apple.com</p></div></div></div></a></div><p id="3d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>