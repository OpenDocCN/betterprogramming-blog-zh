<html>
<head>
<title>3 Things You Should Always Unit Test When Using React With Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React With Redux时，您应该始终进行单元测试的3件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-things-you-should-always-unit-test-when-using-react-with-redux-ee663c88e82d?source=collection_archive---------2-----------------------#2021-12-14">https://betterprogramming.pub/3-things-you-should-always-unit-test-when-using-react-with-redux-ee663c88e82d?source=collection_archive---------2-----------------------#2021-12-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d252" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">直面你对单元测试的负罪感，以及你可以安全跳过的内容</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/376ef597a214d8c7f07ae403261d7931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkpVeZ91G5d4lS2xEQ_H1g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">矢量艺术插图作者<a class="ae kz" href="https://medium.com/@jasonleehodges" rel="noopener">作者</a></p></figure><p id="302f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">周五下午晚些时候，你正准备结束一周的工作，然后事情发生了。一位客户报告了前一天推出的产品代码的问题。你肾上腺素激增，所有其他与工作相关的任务和周末计划都从你的脑海中消失了。你靠咖啡因补充能量，然后深入研究bug票，找到问题所在。您的手指在键盘上疯狂地移动，以实现修复，确保停机时间最小化。</p><p id="0c68" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您将补丁发布到远程存储库进行持续集成时，您会想一个bug最初是如何进入生产环境的。毕竟，有一个测试套件可以保持你的代码稳定，对吗？然后，持续集成构建与实现您的修复<em class="lw">失败</em>。你疯狂地搜索日志，试图找出原因。突然的领悟像一堵砖墙一样打击着你。<em class="lw">你的修复破坏了一个单元测试</em>。压力在于尽快修复构建并修复您的bug。您的经理不断通过即时消息向您发送ping命令，询问您的最新情况。其他开发人员开始抱怨构建失败，因为它阻碍了他们的工作。当你努力想弄清楚这个测试是如何工作的时候，你的手指开始颤抖，你的脸开始发红。</p><p id="8408" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，您举手表决，注释掉测试，并推动它。持续集成构建通过了，您的bug修复进入了生产阶段，每个人都很高兴。也许除了你的良心——它因为删除了一个旨在保持你的代码库稳定的测试而充满了罪恶感。</p><p id="a03b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你遇到过这种情况吗？</p><p id="251f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为一名工程经理，我观察到从事大型项目的工程师有一种共同的情绪。他们有时害怕创建<em class="lw">任何</em>单元测试，万一他们最终破坏了构建，人们会因此对他们感到愤怒。这种恐惧也可以表现为担心编写测试会给他们的同行带来大量的长期维护负担，因为测试本身是脆弱的。这看起来至少是一个文化问题，但甚至可能是一个过程问题。但是怎么修呢？这里存在一个动机的问题——我们为什么要编写单元测试？</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8013" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">单元测试的原因</h1><p id="60dd" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我的团队肯定不会为了确保我们的持续集成管道将一直构建而编写单元测试。如果这是真的，那么上面场景中提供的经验可能会激励我们根本不写单元测试。所以另一方面，我会假设我们编写单元测试只是为了确保我们的代码做我们期望它做的事情。但是除此之外，你可以争辩说它也可以增加我们作为开发人员的生产力，并且鼓励更好的设计模式。</p><p id="7497" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我经常发现开发人员努力识别他们的错误的来源。在他们的追求中，他们用“钉钉子的锤子”来武装自己。他们会向我寻求帮助，以确定为什么他们的单一功能，臃肿的50-100行代码，不工作。我会简单地看一下，如果60秒后还不清楚这个函数试图完成什么，我会让他们写一个单元测试，然后回来找我。像这样的大型函数通常会有意想不到的副作用，或者它们非常复杂，很难推理。通过要求开发人员编写单元测试，我实际上是要求他们准确地分解他们期望函数接受和返回的内容(也称为参照透明性)。毕竟，最终，单元测试确实是为了帮助我们确保代码做我们期望的事情，但是这也迫使我们定义我们期望的事情。</p><p id="391e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">几乎每次我让某人这样做，他们都会回来说他们的功能没有做他们认为应该做的事情。他们经常将他们的功能分解成几个更模块化、更易维护的功能。此外，仅仅通过重构他们的代码使其更具可测试性，他们就解决了问题，而不需要实际运行单元测试。这是因为可测试的代码更容易预测，也更容易推理。</p><p id="7459" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">编写测试实现的另一个主要好处是，他们不必等待代码在浏览器中重新加载，并返回到触发<code class="fe nb nc nd ne b">console.log</code>语句所需的状态。我将看到开发人员添加日志调用，重新加载浏览器，点击鼠标，并意识到他们实际上需要在其他地方<code class="fe nb nc nd ne b">console.log</code>。所以他们又一次地重复这些动作……<em class="lw">慢慢地</em>。通过编写单元测试，他们可以做出快速的改变，点击键盘上的向上箭头调出他们刚刚编写的最后一个<code class="fe nb nc nd ne b">yarn test</code>命令，然后再次启动单元测试。或者更好的是，他们在TDD/watch模式下运行他们的代码，当他们保存他们的更改时，自动运行测试。这导致了一段代码的快速迭代，极大地提高了生产率。</p><p id="72a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得一提的是，在我的调试工作流程中，我几乎从不使用<code class="fe nb nc nd ne b">console.log</code>。相反，我使用Redux DevTools和单元测试。</p><p id="ea10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么，现在我们已经确定有一个好的理由来编写单元测试，这是否意味着我们应该确保我们有100%的代码覆盖率，并且我们绝对测试我们代码库中的所有东西？我以前试过，结果证明是矫枉过正。让我们来看看什么对单元测试有意义，什么是浪费时间和资源。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="102a" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">React + Redux测试什么？</h1><p id="eb07" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">如果您现在没有在react应用程序中使用Redux，我强烈推荐您使用它。Redux Toolkit 改变了游戏，让Redux变得更容易使用。Redux本身提供了一种设计模式，允许开发人员从组件中提取尽可能多的业务逻辑，这是表示层和逻辑层的有效分离。通过从表示层抽象出业务逻辑，您的应用程序本质上变得更具可测试性。如果您正在努力将业务逻辑从应用程序中分离出来，您可能会停下来问自己，“这个逻辑是为了改变还是访问状态？”如果这个问题的答案是肯定的(通常是这样——我发现大多数业务逻辑都涉及到操纵状态)，那么将这个逻辑放在Redux reducer或selector中可能是一个很好的例子。</p><p id="d662" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，如果在应用程序中使用Redux使代码更易测试，那么实际上应该测试什么呢？我认为在使用Redux进行状态管理的React应用程序中，应该始终测试3个主要函数。</p><h2 id="2494" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">1.还原剂</h2><p id="96db" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">如果你很了解Redux flux设计模式，你会知道要更新应用程序的状态，你必须分派动作，并让一个reducer处理这些动作。减速器本身是纯函数。它们将现有状态和一个操作对象作为输入参数，并返回一个新状态。可以理解，当处理这些动作时，减压器不应产生副作用。因此，如果它接受参数，返回一个更新的状态，并且没有副作用，那么它就保持了引用透明性的所有规则，从而使它成为可测试代码的典型例子。</p><p id="ddaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在清单1中，您会发现一个稍微修改过的缩减器示例，它是由官方的<a class="ae kz" href="https://www.npmjs.com/package/cra-template-redux-typescript" rel="noopener ugc nofollow" target="_blank">create-react-app template for redux with typescript</a>提供的样板示例提供的。我在这里修改它只是为了证明当reducer处理动作时，实际上没有副作用发生(模板提供的例子使用了<code class="fe nb nc nd ne b">immer</code>,它允许您提供可变的语法，实际上在幕后为您转换成不可变的操作)。这个reducer有一个简单的计数器<code class="fe nb nc nd ne b">value</code>,可以增加1，减少1，或者增加动作有效负载提供的数量。还有一个异步动作，在经过一定时间后递增1。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nr ns l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单1 — Redux工具包缩减器</p></figure><p id="0f8f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">记住上面的reducer，我们现在有几个案例，其中一个动作正在操纵应用程序的现有状态(T2值)。这被认为是业务逻辑，应该进行测试，以确保它确实在做我们期望它做的事情。清单2显示了create-react-app redux-typescript模板提供的默认测试。如您所见，这些测试非常容易编写。您只需导入缩减器本身，为该缩减器提供一个初始状态，并为其提供一个动作。调用该reducer的结果是更新后的状态，我们可以对照我们期望的状态进行检查。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nr ns l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单Redux Toolkit Reducer的单元测试</p></figure><h2 id="6f47" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">2.选择器</h2><p id="da07" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在通过reducer操纵状态之后，大多数开发人员需要做的下一件事就是在他们的组件中访问状态。我经常发现刚接触Redux的开发人员不为他们的应用程序编写专用的选择器，这意味着他们在组件中内嵌编写选择器，如清单3所示。内联定义这些选择器的问题是它们不能在其他组件中重用，也不能被测试。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nr ns l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单3——在组件中内联定义选择器的反模式</p></figure><p id="fec2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我观察到的另一件事是，即使开发人员有一个专用的选择器文件，他们在其中编写了所有要重用的选择器，他们也经常编写尽可能最少的选择器(即<code class="fe nb nc nd ne b">export const selectCount = (state: RootState) =&gt; state.counter.value;</code>)。然后，他们将这些选择器导入到他们的组件中，并对组件中所选的状态执行所有必要的业务逻辑。这使得测试业务逻辑更加困难，因为您必须在单元测试中安装组件本身，并模拟用户交互来查看逻辑是否工作。</p><p id="69f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为一个最佳实践，如果执行业务逻辑是为了从Redux存储的当前状态中获取一个值，那么应该在选择器中完成。选择器和减速器一样，都是纯函数。它们接受应用程序的当前状态，并返回一个派生值(基于业务逻辑)，没有副作用。这使得它们非常适合测试。</p><p id="0a48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我见过一些开发人员努力通过选择器从状态中获取值，因为他们需要提供额外的值来执行业务逻辑。但是一些简单的奉承，如清单4中的<code class="fe nb nc nd ne b">selectCountFormatted</code>选择器所示，可以帮助完成这个任务。清单4中还提供了一个示例，说明如何在同一个选择器中从state返回多个值，在本例中为<code class="fe nb nc nd ne b">selectCountAndStatus</code>。如果需要，这也可以通过减速器来实现，因为提供给选择器的状态是<code class="fe nb nc nd ne b">RootState</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nr ns l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单4 —计数器选择器文件</p></figure><p id="7e38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些选择器现在可以在您的应用程序中重复使用，并且很容易测试，以确保我们总是得到预期的结果。清单5展示了如何在组件内部的<code class="fe nb nc nd ne b">useSelector</code>钩子中使用curried选择器的例子，以及如何测试这些选择器的例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nr ns l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单5——带有定制选择器和选择器单元测试的useSelector示例</p></figure><h2 id="45a5" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">3.公用事业</h2><p id="fd8a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">通常，如果业务逻辑不能被封装在改变状态或选择状态中，它通常仍然可以被抽象成可以在组件之外存储和测试的纯功能。通过将它们存储在组件之外，它们不需要在每次组件重新渲染时重新定义，而且它们…你猜对了，<em class="lw">更容易测试</em>。</p><p id="a902" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我称这些函数为实用程序，但其他人可能称它们为助手函数。创建效用函数时要考虑的最重要的事情是它们应该是纯的。如果您的组件中有一部分本地状态是您的业务逻辑所依赖的，并且您觉得不能因此将该逻辑抽象成一个实用函数，那么只需将该本地状态作为参数传递，并保持该函数的纯洁性。一个效用函数不应该依赖于任何存在于它自身范围之外的变量。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/81c566e467b277efc37cb7608c1c0feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXO58FMsHyjMIQUUqdxPWA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">矢量艺术插图作者<a class="ae kz" href="https://medium.com/@jasonleehodges" rel="noopener">作者</a></p></figure><h1 id="78d4" class="me mf iu bd mg mh nu mj mk ml nv mn mo ka nw kb mq kd nx ke ms kg ny kh mu mv bi translated">什么不是单元测试</h1><p id="c8d0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我坚信，当操作的逻辑具有合理的计算性时，应该在React应用程序中测试上述3个元素。然而，这并不意味着您应该测试代码库中的所有内容。</p><h2 id="b5eb" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">基本冗余元素</h2><p id="43e0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">对于Redux，如果您的选择器尽可能小(如清单4的第1行所示)，您可能不需要为此进行单元测试。这里没有实际的业务逻辑，只是访问一个值。同样，如果一个reducer通过简单地将一个状态改变为有效负载提供的确切值来处理一个动作，那么您可能也不需要测试它。但是如果有任何逻辑发生(比如在现有值上增加一个值)，您可能应该测试一下，以确保reducer按照预期处理逻辑。</p><h2 id="f9d5" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">类型</h2><p id="6be2" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">如果您没有使用Typescript，我强烈推荐您使用它。通过将静态类型系统引入我们的代码库，我的团队已经能够将我们编写的单元测试数量减少至少50%。任何简单检查对象形状或函数返回的对象类型的测试都可以被静态类型化系统删除和替换。</p><h2 id="4f34" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">API调用</h2><p id="7632" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我注意到一些开发人员花费大量时间维护测试，对API调用进行大量模拟。最终，应用程序的前端和后端之间应该有一个契约。API应该被版本化，并且不应该中断。在我的组织中，我们不是关注模拟API调用，而是确保在后端执行适当的快照测试。我们还在代码的服务层放置了类型保护和错误处理，以防止意外的结果。但是通常避免为API编写带有模拟的单元测试(除非我们正在编写一些跨多个项目共享的外部客户端)。</p><h2 id="3441" class="nf mf iu bd mg ng nh dn mk ni nj dp mo lj nk nl mq ln nm nn ms lr no np mu nq bi translated">模拟用户交互</h2><p id="7802" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">很多人真的喜欢确保应用程序中的测试尽可能地模拟用户交互。论点是，通过测试用户交互，您将知道整个应用程序将按照用户期望的方式工作。这被称为端到端测试，有时也称为集成测试，这取决于你如何看待它。<a class="nz oa ep" href="https://medium.com/u/db72389e89d8?source=post_page-----ee663c88e82d--------------------------------" rel="noopener" target="_blank"><code class="fe nb nc nd ne b">react-testing-libary</code>的作者肯特·c·多兹</a>，已经写了很多关于这个话题的文章，如果你有兴趣了解更多的话。</p><p id="d7c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，在react应用程序中安装组件，通过<code class="fe nb nc nd ne b">react-testing-library</code>或<code class="fe nb nc nd ne b">enzyme</code>来模拟用户交互进行测试，本质上是非常脆弱的。每当您更新组件的任何部分时，这些集成测试往往会失败。它们需要大量的维护，因此非常昂贵。还有，他们<em class="lw">真的</em>慢(尤其是<code class="fe nb nc nd ne b">react-testing-library</code>)。这对于持续的集成管道工作来说很好，但是如果我想确保我的代码在推到我的远程分支之前没有破坏任何测试，我不想在它运行所有集成测试时等待5-10分钟。单元测试本来就应该很快。</p><p id="62a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我的组织倾向于依赖手工QA测试来完成端到端的测试。我们的逻辑是，如果你必须在这些类型的测试上花费大量的维护时间，你还不如有一个专门的人工QA人员。对此持保留态度，里程可能会有所不同，取决于您的项目。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="3153" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="af77" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">Redux是一种可预测和可维护的设计模式，使测试变得容易。使用Redux时，将尽可能多的业务逻辑转移到reducers、选择器和实用函数中，并对它们进行测试。</p><p id="f926" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最终，您的组件应该是一个非常薄的表示层。也许一些钩子做一些不同的事情，但是你的大部分逻辑发生在组件之外。</p><p id="33a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要担心测试超薄选择器、简单地将状态设置为所提供的任何有效负载、API、类型或模拟用户交互的reducer案例。</p></div></div>    
</body>
</html>