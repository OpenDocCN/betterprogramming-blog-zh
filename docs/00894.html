<html>
<head>
<title>How I Dropped Redux for the Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何为上下文API放弃Redux</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-dropped-redux-for-the-context-api-7338d481e179?source=collection_archive---------6-----------------------#2019-07-25">https://betterprogramming.pub/how-i-dropped-redux-for-the-context-api-7338d481e179?source=collection_archive---------6-----------------------#2019-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a811" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我如何用上下文API替换Redux的个人故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/088e609b3b73280c71369ffdbcba39a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyHpepOw2vFFKVFdeRvzWg.png"/></div></div></figure><p id="a67c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React 16引入了一个新的上下文API来取代被弃用的那个。好了，距离16.3版本发布已经一年多了，但在React生态系统中似乎还很新鲜。</p><p id="4973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个新的API有望解决以前使用上下文的实验性方法的许多问题。对我来说，它做得更多；它改变了我制作React应用程序的方式。这是我如何管理它的故事。</p><p id="18f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会给出Redux如何工作的课程。如果你想复习，你可以看看丹·阿布拉莫夫在Egghead 上的精彩课程。另外，你最终会把Redux从你的应用中移除，所以我们需要一个完整的课程吗？</p><p id="35b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解代码有几个要求:我会用<a class="ae lq" href="https://en.reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>和<a class="ae lq" href="https://en.reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"> React片段</a>的简称<code class="fe lr ls lt lu b">&lt;&gt;</code>。</p><p id="b5cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，假设我们有一个应用程序可以告诉我是否有空去喝杯啤酒。它包括以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">如何在React with Redux中拥有啤酒身份？</p></figure><p id="132f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的示例代码中，我创建了四个文件来处理Redux应用程序的各个部分:</p><ul class=""><li id="572b" class="mb mc it kw b kx ky la lb ld md lh me ll mf lp mg mh mi mj bi translated"><code class="fe lr ls lt lu b">actions/beer.js</code>:包含我的应用程序中每个动作的常量的文件。这可以直接内联到其他文件中，但是我喜欢保持事情清晰，关注点分开。</li><li id="501e" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated"><code class="fe lr ls lt lu b">dispatchers/beer.js</code>:我的Redux模型的每个动作的家。在这种情况下，我只有一个<code class="fe lr ls lt lu b">toogleBeerAvailability</code>方法，它从上一个文件调度动作。</li><li id="8ffd" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated"><code class="fe lr ls lt lu b">reducers/beer.js</code>:我的Redux模型的存储引擎，如果调用<code class="fe lr ls lt lu b">TOGGLE_AVAILABILITY_FOR_BEER</code>调度程序，它会改变我的可用性值。</li><li id="72e7" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated"><code class="fe lr ls lt lu b">components/beer.jsx</code>:显示和切换我的可用性的组件。我们使用<code class="fe lr ls lt lu b">react-redux</code>将redux属性映射到我的组件props。</li></ul><p id="ecb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这有很多代码，但是对于一个具有Redux的健壮系统来说是必要的。现在，我们将删除Redux，结果相同。但首先，我们为什么要放弃Redux？</p><p id="9e3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我这样做只是为了通过删除两个依赖项来减轻应用程序的重量:<code class="fe lr ls lt lu b">redux</code>和<code class="fe lr ls lt lu b">react-redux</code>。我也不喜欢我的应用程序中有多个依赖项，所以我很乐意删除其中的两个。</p><p id="bd8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是它的工作原理。请记住，它可能不是一个完美的解决方案，甚至不是一个推荐的解决方案，但它是我在项目和工作中使用的解决方案。但是让我们停止聊天，开始研究代码。</p><p id="9ddc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我正在处理一个我称为<em class="mp"> Provider </em>的状态文件。它包含了处理状态的一切。在第一个示例中，它只是我从一个状态钩子接收的一个getter和一个setter。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">如何通过上下文API获得啤酒状态</p></figure><p id="d559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来更简单、更有效，但仍有一些问题需要改进:</p><ul class=""><li id="798c" class="mb mc it kw b kx ky la lb ld md lh me ll mf lp mg mh mi mj bi translated">getters和setters在同一个对象中，有点乱。</li><li id="259b" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated"><code class="fe lr ls lt lu b">toggleAvailability</code>方法在children组件中被管理，这是不起作用的。</li><li id="69e3" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated">由于状态改变，我们可能会遇到性能问题。</li></ul><p id="f53a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于第一个，我喜欢将对象分成两个子对象，<code class="fe lr ls lt lu b">actions</code>和<code class="fe lr ls lt lu b">values</code>，就像Redux中的dispatchers和states。最终看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">如何通过上下文API和一点结构获得啤酒状态</p></figure><p id="dca8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于第二个，我们只需要将调用移动到父组件中，并将操作添加到新的actions部分中。这将使我们的<code class="fe lr ls lt lu b">Beer</code>组件简单很多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">如何使beer状态与上下文API、结构和一致性保持一致</p></figure><p id="296f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于性能，我们的组件仍然有两个问题:</p><ul class=""><li id="1440" class="mb mc it kw b kx ky la lb ld md lh me ll mf lp mg mh mi mj bi translated">每次更新<code class="fe lr ls lt lu b">Provider</code>组件时，都会重新评估<code class="fe lr ls lt lu b">toggleAvailability</code>方法</li><li id="3f75" class="mb mc it kw b kx mk la ml ld mm lh mn ll mo lp mg mh mi mj bi translated">每次<code class="fe lr ls lt lu b">Provider</code>组件发生变化时，包含状态的值对象也会更新。</li></ul><p id="0b5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，React提供了两个钩子来处理我们的数据缓存。</p><p id="0ed7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将首先在<code class="fe lr ls lt lu b">useCallback</code>钩子中封装<code class="fe lr ls lt lu b">toggleAvailability</code>方法。它将确保当第二个参数中的数据没有改变时，返回的方法总是相同的。这将是可能的，因为React的<code class="fe lr ls lt lu b">useState</code>钩子保证它的set方法将是相同的，尽管渲染。</p><p id="b61d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将使用<code class="fe lr ls lt lu b">useMemo</code>钩子来封装<code class="fe lr ls lt lu b">value</code>对象。这个钩子几乎和<code class="fe lr ls lt lu b">useCallback</code>一样，只是针对物体。它还将获得第二个参数来显示它所依赖的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="cab4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这些了，伙计们！我们的应用程序中不再有Redux，并有一个干净的上下文用法。希望你试试上下文API！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/15cdedd0d912d3d48f9c7f91d410e268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucBcf14roFs8-c4Nc9Dp9Q.jpeg"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">我React项目的新方法。照片归功于我。</p></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3f56" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated"><strong class="ak">参考文献</strong></h1><div class="nq nr gp gr ns nt"><a href="https://en.reactjs.org/docs/hooks-reference.html" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">钩子API参考-反应</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">en.reactjs.org</p></div></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://kentcdodds.com/blog/how-to-use-react-context-effectively" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">如何有效使用React上下文</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">在使用React的应用程序状态管理中，我谈到了如何混合使用本地状态和React上下文来帮助您…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">kentcdodds.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div></div></div>    
</body>
</html>