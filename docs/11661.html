<html>
<head>
<title>What is the Microtask Queue and How Does It Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是微任务队列，它是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-the-microtask-queue-and-how-does-it-work-3b858ff2a270?source=collection_archive---------9-----------------------#2022-04-06">https://betterprogramming.pub/what-is-the-microtask-queue-and-how-does-it-work-3b858ff2a270?source=collection_archive---------9-----------------------#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c45d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个JavaScript用例例子解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65276d2dd7122d05a33d31a044c73591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuwDCsC9afrOoo1ObUvuCw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Adobe Stock照片</p></figure><p id="d20b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几周前，我的一个同事向我寻求帮助。他们试图给异步函数增加一个人工等待时间。</p><p id="a1f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1a41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预期的行为是:<code class="fe lw lx ly lz b">task1</code>运行，然后5秒后<code class="fe lw lx ly lz b">task2</code>，最后<code class="fe lw lx ly lz b">task3</code>。</p><p id="8503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们看到的实际行为是<code class="fe lw lx ly lz b">task1</code>跑，然后是<code class="fe lw lx ly lz b">task3</code>，最后是<code class="fe lw lx ly lz b">task2</code>。我的同事想知道为什么函数没有等待<code class="fe lw lx ly lz b">setTimeout</code>结束就继续。</p><p id="76ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lw lx ly lz b">task2</code>在<code class="fe lw lx ly lz b">task3</code>之后运行的原因是微任务队列。</p><p id="53d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript引擎有一个等待任务的事件循环。当任务进来时，它们按照到达的顺序执行。在事件循环内部，有一个称为微任务队列的子队列。</p><p id="05bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">微任务队列阻止事件循环的其余部分运行，直到所有微任务都已完成。承诺进入微任务队列。这就是为什么应用程序在进入下一个任务之前“等待”承诺的解决。</p><p id="8e24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我同事的例子中，当函数运行时，有三个任务被添加到事件循环中。<code class="fe lw lx ly lz b">Task1</code>、<code class="fe lw lx ly lz b">setTimeout</code>和<code class="fe lw lx ly lz b">task3</code>。<code class="fe lw lx ly lz b">setTimout</code>不返回承诺，因此它被添加到常规任务队列中。</p><p id="185a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事件循环示例:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="d8d1" class="me mf it lz b gy mg mh l mi mj">Tasks     | setTimeout<br/>Microtasks| task1, task3</span></pre><p id="7be7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Task1将首先运行，然后task3将作为微任务队列中的下一个运行。一旦微任务队列为空，常规任务将运行。</p><p id="2971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此<code class="fe lw lx ly lz b">setTimeout</code>功能将在5秒内完成。一旦<code class="fe lw lx ly lz b">setTimeout</code>完成，<code class="fe lw lx ly lz b">task2</code>将被添加到事件循环中。<code class="fe lw lx ly lz b">Task2</code>被添加到Micortasks队列中，因为它返回一个<code class="fe lw lx ly lz b">Promise</code>。这就解释了为什么我的同事经历了<code class="fe lw lx ly lz b">task1</code>然后<code class="fe lw lx ly lz b">task3</code>然后<code class="fe lw lx ly lz b">task2</code>。</p><p id="033a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现预期的等待行为，<code class="fe lw lx ly lz b">setTimeout</code>函数需要包装在<code class="fe lw lx ly lz b">Promise</code>中。一旦它在一个承诺中，它将加入微任务队列中的<code class="fe lw lx ly lz b">task1</code>和<code class="fe lw lx ly lz b">task3</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ec20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，<code class="fe lw lx ly lz b">task3</code>将在新的<code class="fe lw lx ly lz b">Promise</code>解决后运行。</p><p id="cd74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的<code class="fe lw lx ly lz b">Promise</code>将在<code class="fe lw lx ly lz b">task2</code>完成且解析功能运行后解析。</p></div></div>    
</body>
</html>