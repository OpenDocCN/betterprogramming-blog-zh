# 在 Swift 中学习嘲笑

> 原文：<https://betterprogramming.pub/learning-to-mock-in-swift-bc233f01da72>

## 在单元测试中剔除嵌套函数

![](img/f0a805f2e038f0b9c798271857fd7ff0.png)

根据您在单元测试中的立场，您可能会发现这篇文章比其他文章更有用或更不有用。我选择测试，因为当我为自己开发时，我没有人可以提供代码审查，所以它给了我额外的保证，我没有破坏任何东西。我还发现看到一切都变得绿色起来令人奇怪地满足。

# 为什么需要嘲笑？

> “单元测试是软件测试的一个层次，其中测试软件的单个单元/组件。目的是验证软件的每个单元都按照设计执行。单元是任何软件中最小的可测试部分。”
> 
> —国际软件测试资格委员会(ISTQB)

为了很好地对一个函数进行单元测试，你需要覆盖你的函数可以采用的所有不同的路径。随着应用程序的增长，您的函数最终会调用您在代码库中编写的嵌套函数或其他库函数。

当你对一个函数进行单元测试时，你可能会考虑那些嵌套函数的输出，并且想要测试某个路径。

这就是嘲讽的由来。它使您能够单独测试有问题的函数，而不必考虑嵌套函数中的逻辑。例如，如果您的函数要进行 API 调用，您可以模拟网络层，这样您的测试实际上不会进行调用，但仍然会考虑所有可能的场景。

正如您所想象的，这极大地加快了您的测试速度，并且意味着您不再依赖网络来决定您的测试是通过还是失败。

# 迅速嘲笑

通过观察一个典型的网络层，我们可以看到问题是什么，以及如何利用 Swift 的协议来模拟功能。

正如你所看到的，如果我们要测试`executeRequest`函数，没有办法不调用真正的`URLSession`并对参数中提供的 URL 发出请求。相反，我们可以重构类来利用协议，这将允许我们在测试中注入一个 mock。

我们用函数的签名创建一个协议。然后，我们通过使`URLSession`符合`NetworkClientProtocol`来实现该功能。一旦我们看到如何调用它**，这就更容易理解了。**

通过重构`NetworkClient`、**、*、*、**，我们可以传入任何符合我们在初始化阶段创建的协议的东西，并默认为正常的`URLSession.shared`，就像我们之前做的那样。

然后当我们调用`executeRequest`时，它使用我们传入的值来调用它自己的函数实现。因此，我们只在使用真正的`URLSession`时调用网络请求。现在让我们看看如何在测试中模拟它。

我们通过在测试中动态创建一个符合`NetworkClientProtocol`的类来模拟这个函数。在这里，我们可以告诉它做我们想做的任何事情。在本例中，我告诉它返回`nil`数据来模拟函数中的`noData`错误。

然后，我们初始化刚刚创建的模拟类，将它传递到`NetworkClient`，并发出请求和我们想要发出的任何断言。

使用这种方法，我们避免了真实的网络请求，这意味着我们的测试更加稳定，并且我们可以测试网络可能带来的所有可能的场景。

我们免费得到的其他东西是不需要在我们的测试中使用`XCTestExpectation`。这在处理`@escaping`闭包时很常见，但是由于我们的模拟函数直接返回，我们可以避免这种情况。

# 结论

我希望你能看到，这种方法很容易与你在 Swift 中编写的任何函数复制。感谢阅读！

我还有一份完全免费的时事通讯，我可以在上面撰写与 swift 相关的主题。请随意使用下面的链接注册！👇

[](https://swiftlythinking.substack.com) [## SwiftlyThinking 的简讯

### 来自一位对 SwiftUI 和更多东西充满热情的 iOS 开发人员的博客帖子。

swiftlythinking.substack.com](https://swiftlythinking.substack.com)