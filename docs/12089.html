<html>
<head>
<title>File Uploads With Angular and RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular和RxJS上传文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/file-uploads-with-angular-and-rxjs-34262b3450ae?source=collection_archive---------1-----------------------#2022-05-11">https://betterprogramming.pub/file-uploads-with-angular-and-rxjs-34262b3450ae?source=collection_archive---------1-----------------------#2022-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="64e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的Angular应用程序添加一个强大、优雅的文件上传控件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4e1a0035af86796a56b87518c2ebeb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNpLMCsTmKoeamcA4ukkNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">神奇的互联网人将文件传送到云端(<a class="ae kv" href="https://www.shutterstock.com/image-photo/conceptual-image-successful-businessman-suit-flying-1052295092" rel="noopener ugc nofollow" target="_blank"> Khakimullin Aleksandr </a></p></figure><h1 id="5264" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">文件上传🧑‍💻</h1><p id="4f31" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据传输是软件应用程序中普遍存在的一部分。从Apple到Zoom，文件上传控件渗透到整个技术生态系统中，是许多人每天都要交互的组件。本教程演示了如何用RxJS、Angular和Bootstrap构建一个文件上传客户端。</p><p id="b78b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">大多数Angular文件上传教程订阅observables并显式管理订阅。在这篇文章中，我们将探索如何使用bindCallback、scan、mergeMap、takeWhile和AsyncPipe来创建一个完全反应式的上传控件，包括进度条和订阅。</p><p id="9a2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本文的配套回购可以在这里<a class="ae kv" href="https://github.com/bobbyg603/file-uploads-with-angular-and-rxjs" rel="noopener ugc nofollow" target="_blank">找到。</a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="49ba" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">服务器☁️</h1><p id="0b2f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了开发我们的Angular文件上传组件，我们需要一个能够处理文件上传、下载和返回已上传文件列表的后端。</p><p id="ff3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要开始，请克隆服务器存储库:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f7db" class="ng kx iq nc b gy nh ni l nj nk">git clone <a class="ae kv" href="https://github.com/bobbyg603/upload-server.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bobbyg603/upload-server.git</a></span></pre><p id="dd9b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">安装包的依赖项并启动服务器，这样我们就有了可以用来开发文件上传组件的东西:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="be12" class="ng kx iq nc b gy nh ni l nj nk">npm i &amp;&amp; npm start</span></pre><p id="70ea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一个真正的服务器，不使用时不应该让它运行！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="5a44" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">客户💻</h1><p id="e123" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，让我们使用<a class="ae kv" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>创建一个新的Angular应用程序，确保选择scss作为样式表格式:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="6501" class="ng kx iq nc b gy nh ni l nj nk">ng new uploads-client &amp;&amp; cd uploads-client</span></pre><p id="492f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以利用一些第三方库来大大简化真实世界文件上传组件的创建。让我们安装<a class="ae kv" href="https://www.npmjs.com/package/bootstrap" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>、<a class="ae kv" href="https://www.npmjs.com/package/@ng-bootstrap/ng-bootstrap" rel="noopener ugc nofollow" target="_blank"> ng-bootstrap </a>和<a class="ae kv" href="https://www.npmjs.com/package/@bugsplat/ngx-file-drop" rel="noopener ugc nofollow" target="_blank"> ngx-file-drop </a>。我们还将安装Bootstrap的依赖关系<a class="ae kv" href="https://www.npmjs.com/package/@popperjs/core" rel="noopener ugc nofollow" target="_blank"> @popperjs/core </a>:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d934" class="ng kx iq nc b gy nh ni l nj nk">npm i bootstrap <!-- -->@popperjs/core<!-- --> @ng-bootstrap/ng-bootstrap @bugsplat/ngx-file-drop --legacy-peer-deps</span></pre><p id="e50f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过运行以下终端命令，为引导添加<a class="ae kv" href="https://www.npmjs.com/package/@angular/localize" rel="noopener ugc nofollow" target="_blank">@ angular/localize</a>poly fill:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="503a" class="ng kx iq nc b gy nh ni l nj nk">ng add <a class="ae kv" href="http://twitter.com/angular/localize" rel="noopener ugc nofollow" target="_blank">@angular/localize</a></span></pre><p id="4a6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，将引导程序的scss导入到您的<code class="fe nl nm nn nc b">styles.scss</code>文件中:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0cdd" class="ng kx iq nc b gy nh ni l nj nk">@import "~bootstrap/scss/bootstrap";</span></pre><h2 id="6c0d" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">文件表</h2><p id="1c78" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最容易的起点是从服务器获取文件列表，并在表格中显示它们。创建一个新的文件组件来显示我们的文件列表:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d7f3" class="ng kx iq nc b gy nh ni l nj nk">ng g c files</span></pre><p id="0a40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">向您的<code class="fe nl nm nn nc b">app.component.html</code>模板添加一个新的<code class="fe nl nm nn nc b">FilesComponent</code>实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件组件</p></figure><p id="bf8c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们添加一个表示我们想要显示的数据的接口。创建新文件<code class="fe nl nm nn nc b">files/files-table-entry.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件表输入界面</p></figure><p id="0fcb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nl nm nn nc b">files.component.html</code>中，添加一个显示文件集合的表格:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件组件表</p></figure><p id="c705" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了让UI更有趣，让我们在<code class="fe nl nm nn nc b">files.component.ts</code>中提供一些占位符数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件组件占位符数据</p></figure><h2 id="051d" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">列出上传的文件</h2><p id="9c8b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，我们已经构建了一个用于显示文件的表，并用一些虚拟数据填充了它。让我们通过向服务器上的<code class="fe nl nm nn nc b">/files</code>端点发出GET请求来显示真正的文件列表。</p><p id="79f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将<code class="fe nl nm nn nc b">HttpClientModule</code>添加到<code class="fe nl nm nn nc b">app.module.ts</code>中的导入数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将HttpClient模块添加到App模块</p></figure><p id="2253" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将<code class="fe nl nm nn nc b">HttpClient</code>注入到<code class="fe nl nm nn nc b">app.component.ts</code>的构造函数中。在构造函数中，将<code class="fe nl nm nn nc b">files$</code>设置为对<code class="fe nl nm nn nc b">/files</code>的GET请求的结果——如果Express server还没有运行，请确保启动它！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取应用程序组件中的文件</p></figure><p id="693f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用Angular的<a class="ae kv" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">异步管道</a>将<code class="fe nl nm nn nc b">files$</code>作为输入传递给<code class="fe nl nm nn nc b">FilesComponent</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用异步管道订阅</p></figure><p id="87fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用AsyncPipe，因为它将自动管理对<code class="fe nl nm nn nc b">files$</code>可观察对象的订阅和取消订阅。如果你发现自己在Angular中调用了一个可观察的<code class="fe nl nm nn nc b">subscribe</code>,要小心了——忘记调用<code class="fe nl nm nn nc b">unsubscribe</code>会导致<a class="ae kv" href="https://en.wikipedia.org/wiki/Memory_leak" rel="noopener ugc nofollow" target="_blank">内存泄漏</a>和应用程序性能下降！</p><p id="fb58" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你做的一切都正确，你的应用现在应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a50d9bee479a991cad2af2597c9cbd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ynl1ux4uYlTFmDDISRj8_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件表检查点</p></figure><h2 id="f5de" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">文件选择</h2><p id="1af7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们上传文件之前，我们需要一种方法来允许用户指定他们想要上传的文件。首先，创建一个新的用于选择文件的<code class="fe nl nm nn nc b">file-drop.component.ts</code>组件:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ddd3" class="ng kx iq nc b gy nh ni l nj nk">ng g c file-drop</span></pre><p id="244b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的第三方<code class="fe nl nm nn nc b">NgxFileDropComponent</code>允许我们的用户将文件拖放到我们的web应用程序中，或者通过系统文件选择器指定要上传的文件。要使用<code class="fe nl nm nn nc b">NgxFileDropComponent</code>，我们首先需要将<code class="fe nl nm nn nc b">NgxFileDropModule</code>添加到我们应用程序的<code class="fe nl nm nn nc b">app.module.ts</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将NgxFileDrop模块添加到应用程序模块</p></figure><p id="b320" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将<code class="fe nl nm nn nc b">ngx-file-drop</code>和一个基本的ng模板添加到<code class="fe nl nm nn nc b">file-drop.component.html</code>，这样我们就可以将文件拖放到我们的应用程序中，或者通过系统文件选择器选择文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件放置模板</p></figure><p id="41ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nl nm nn nc b">file-drop.component.ts</code>中，创建一个<code class="fe nl nm nn nc b">onFilesDropped</code>函数，作为<code class="fe nl nm nn nc b">onFileDrop</code>事件的处理程序。让我们也创建一个<code class="fe nl nm nn nc b">filesDropped</code>输出，我们将使用它将事件转发给我们的<code class="fe nl nm nn nc b">AppComponent</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件删除组件</p></figure><p id="29ad" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们在这里使用一个<code class="fe nl nm nn nc b">Output</code>，这样我们可以从<code class="fe nl nm nn nc b">FileDropComponent</code>到<code class="fe nl nm nn nc b">AppComponent</code>进行通信。关注点分离是基本的软件设计原则，鼓励干净、可读和可重用的代码。</p><p id="20b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经在<code class="fe nl nm nn nc b">FileDropComponent</code>中创建了<code class="fe nl nm nn nc b">Output</code>，将<code class="fe nl nm nn nc b">filesDropped</code>事件的处理程序添加到您的<code class="fe nl nm nn nc b">app.component.html</code>模板中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将FileDrop组件添加到App组件</p></figure><p id="0378" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">向您的<code class="fe nl nm nn nc b">AppComponent</code>添加一个<code class="fe nl nm nn nc b">onFilesDropped</code>处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序组件中的OnFilesDropped处理程序</p></figure><p id="2a63" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此时，您应该已经构建了一个类似如下的应用程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/009cae57d33ee9cf0ee1b2987099a4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*t2k_ZRPQ5rzgn7-VTZfQIw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件丢弃检查点</p></figure><h2 id="baa7" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">获取文件对象</h2><p id="d57b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在开始文件上传之前，我们需要创建一个可观察的流，从<code class="fe nl nm nn nc b">NgxFileDropEntry</code>数组中发出每个文件。从<code class="fe nl nm nn nc b">NgxFileDropEntry</code>获取<code class="fe nl nm nn nc b">File</code>对象有点棘手，因为它是作为参数传递给回调函数的。</p><p id="d1ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">幸运的是，RxJS有<code class="fe nl nm nn nc b">bindCallback</code>,我们可以用它将接受回调的函数转换成可观察的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用BindCallback将文件回调转换为可观察的</p></figure><p id="0b36" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的<code class="fe nl nm nn nc b">bindCallback</code>片段中发生了很多事情。</p><p id="e6c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，<code class="fe nl nm nn nc b">from</code>操作符用于获取一组<code class="fe nl nm nn nc b">NgxFileDropEntry</code>项，并逐个发出它们，允许我们单独操作每一项。</p><p id="35b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，项目通过管道传输到<code class="fe nl nm nn nc b">mergeMap</code>，这允许我们将每个<code class="fe nl nm nn nc b">NgxFileDropEntry</code>映射到一个新的可观察对象，而无需取消任何先前的内部订阅。每个<code class="fe nl nm nn nc b">NgxFileDropEntry</code>最终将映射到一个上传操作，该操作会随着时间的推移发出多个进度事件。</p><p id="b4e8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您想将一个可观察对象映射到另一个可观察对象时，<code class="fe nl nm nn nc b">switchMap</code>是大多数情况下的首选操作符，因为它会自动取消内部订阅。然而，在这种情况下，我们希望维护内部订阅，以便它们继续对正在上传的每个文件进行流式处理。我们一会儿将回到这一点。</p><p id="3c51" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们使用<code class="fe nl nm nn nc b">bindCallback</code>从一个将异步操作的结果传递给回调的函数中创建一个可观察对象。不幸的是，在TypeScript的es5 lib中有一个我不能完全理解的打字问题。为了解决这个问题，<code class="fe nl nm nn nc b">bindCallback</code>的结果被转换为<code class="fe nl nm nn nc b">any</code>。这很有效，但是感觉有点脏——如果有人知道更好的解决方案，我很乐意在评论中听到！</p><h2 id="0cf7" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">文件上传</h2><p id="ddb0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">既然我们已经将<code class="fe nl nm nn nc b">File</code>对象从<code class="fe nl nm nn nc b">NgxFileDropEntry</code>转换为可观察对象，那么让我们使用Angular的<code class="fe nl nm nn nc b">HttpClient</code>来上传文件并返回进度事件。</p><p id="5eec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是我们的应用程序组件的<code class="fe nl nm nn nc b">onFilesDropped</code>功能应该是什么样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件上传片段</p></figure><p id="9af3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，我们现在将<code class="fe nl nm nn nc b">file$</code>映射到<code class="fe nl nm nn nc b">httpClient.post</code>的结果，这一次，用<code class="fe nl nm nn nc b">switchMap</code>拉平可观察的流并取消内部订阅。我们使用<code class="fe nl nm nn nc b">reportProgress: true</code>和<code class="fe nl nm nn nc b">observe: 'events'</code>来指示<code class="fe nl nm nn nc b">HttpClient</code>我们希望它在文件上传时发出进度值。</p><p id="dffe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果一切正常，您应该会看到开发人员控制台记录了几个进度事件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/e2dbccdc184da7ff62132b29ac6e371b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJOg1vwPABkLip5Qg5Vv4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上传进度事件</p></figure><p id="b868" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们最感兴趣的事件具有类型<code class="fe nl nm nn nc b">HttpEventType.UploadProgress</code>或<code class="fe nl nm nn nc b">type: 1</code>。</p><h2 id="2085" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">过滤事件</h2><p id="0c4d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，让我们创建一个类型保护。<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型保护</a>将允许我们过滤掉不是进度事件的事件，并向类型脚本指示下一个操作符的输入类型将是<code class="fe nl nm nn nc b">HttpUploadProgressEvent</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HttpUploadProgressEvents的类型Guard</p></figure><p id="5b30" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对<code class="fe nl nm nn nc b">filter</code>操作符使用类型保护，以便从可观察的流中过滤掉其他事件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">仅接受HttpProgress事件</p></figure><p id="8da0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，当您将文件拖动到您的应用程序中或通过系统文件选择器选择它们时，您应该只看到显示在开发人员控制台中的<code class="fe nl nm nn nc b">type: 1</code>事件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6ff1c7d4a5360efd84eea84f4c4e5242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*p3nczriNZdZI6K0HVN4xIg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">过滤的上传进度事件</p></figure><p id="fc40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，上传事件不多，因为你上传到的是本地机器上的服务器。当服务器通过互联网托管时，您将会看到更多的上传事件。</p><h2 id="665e" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">完成上传可观察流</h2><p id="e55d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们走得太远之前，我们需要对我们的可观察流做一个小的改变，以确保它在正确的时间完成。还记得<code class="fe nl nm nn nc b">mergeMap</code>如何要求我们管理我们的内部订阅吗？<a class="ae kv" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap#why-use-mergemap" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>推荐使用一个<code class="fe nl nm nn nc b">take</code>操作符来管理内部订阅的完成。</p><p id="206d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当上传操作完成时，HttpClient发出一个类型为<code class="fe nl nm nn nc b">HttpEventType.Response</code>或<code class="fe nl nm nn nc b">{ type: 4 }</code>的事件。让我们使用<code class="fe nl nm nn nc b">takeWhile</code>操作符在上传操作发出响应时完成订阅:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">持续到上传完成</p></figure><p id="35dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，您应该能够将文件上传到您的服务器了——太好了！在最后一部分，我们将在文件上传中添加进度条。</p><h2 id="99cf" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">上传进度累加器</h2><p id="9623" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们正在上传文件并获得一系列上传事件，我们需要将这些事件整合到一个集合中，以便在UI中使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件上传进度界面</p></figure><p id="37e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nl nm nn nc b">scan</code>操作符与<code class="fe nl nm nn nc b">reduce</code>相似，但它不是操纵数组，而是减少从可观察流发送到数组或对象中的值。</p><p id="12be" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们希望保持一个运行的集合，将每个文件映射到它最近的进度值。对于大型集合，使用字符串值对集合进行索引要比在集合中搜索正确的索引快得多。</p><p id="e038" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们想给每个文件一个唯一的字符串作为<code class="fe nl nm nn nc b">id</code>属性，我们可以用它来快速索引我们的文件集合并更新它们相关的进度。为此，我们将依靠<a class="ae kv" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>包:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3881" class="ng kx iq nc b gy nh ni l nj nk">npm i uuid &amp;&amp; npm i --save-dev @types/uuid</span></pre><p id="af09" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将使用别名将uuid导入到<code class="fe nl nm nn nc b">app.component.ts</code>中，这样读起来更好一些:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将V4作为UUID导入</p></figure><p id="c563" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以使用<code class="fe nl nm nn nc b">loaded</code>和<code class="fe nl nm nn nc b">total</code>值来生成我们的进度值。首先，我们将每个进度事件<code class="fe nl nm nn nc b">map</code>到<code class="fe nl nm nn nc b">FileUploadProgress</code>接口。接下来，我们将使用<code class="fe nl nm nn nc b">scan</code>操作符和我们在祖先函数作用域中定义的<code class="fe nl nm nn nc b">id</code>来将我们的进度值保存到一个累加器中。最后，我们将把累加器转换成一个值数组，以便在UI中显示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上传进度累加器</p></figure><p id="12c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唷！太多了，但我们快完成了。</p><h2 id="7b36" class="ng kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">上传进度条</h2><p id="26ea" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用进度条向用户显示每次上传的进度。要开始，将<code class="fe nl nm nn nc b">NgbProgressbarModule</code>添加到<code class="fe nl nm nn nc b">app.module.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将NgbProgressBar模块添加到应用程序模块</p></figure><p id="095e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">添加一个<code class="fe nl nm nn nc b">UploadsComponent</code>以便我们可以显示上传进度条:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8864" class="ng kx iq nc b gy nh ni l nj nk">ng g c uploads</span></pre><p id="e4b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将以下内容复制到<code class="fe nl nm nn nc b">uploads.component.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上传组件</p></figure><p id="9a90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将以下代码片段添加到<code class="fe nl nm nn nc b">uploads.component.html</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上传进度条模板</p></figure><p id="63e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nl nm nn nc b">UploadComponent</code>使用<a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank"> *ngFor </a>为uploads集合中的每个上传创建一个包含模板的div。当上传失败时，我们将<code class="fe nl nm nn nc b">text-danger</code>类添加到包含上传名称的span中，将文本涂成红色。上传完成后，根据上传是否失败，我们会在文件名旁边添加一个复选标记或x。最后，我们创建一个红色(危险)或绿色(成功)的进度条，并将<code class="fe nl nm nn nc b">[value]</code>输入绑定到<code class="fe nl nm nn nc b">upload.progress</code>，这样进度条的宽度会随着文件的上传而更新。</p><p id="0012" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经完成了<code class="fe nl nm nn nc b">UploadsComponent</code>，让我们将其添加到<code class="fe nl nm nn nc b">app.component.html</code>模板中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将上传进度添加到应用程序组件</p></figure><p id="74ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">太棒了。如果一切都连接正确，您应该会看到如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c7a5a82ac8914da414c82538f73d6cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/1*9g048wXCwZbk2K_oPrqN-w.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上传进度条</p></figure><p id="a833" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">刷新列表</strong></p><p id="dc1c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一个难题是在上传完成后获取一个新的上传文件列表。这可以使用<code class="fe nl nm nn nc b">BehaviorSubject</code>和<code class="fe nl nm nn nc b">finalize</code>操作符来完成。</p><p id="8c6f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nl nm nn nc b">app.component.ts</code>中可以使用一个<code class="fe nl nm nn nc b">BehaviorSubject</code>来指示<code class="fe nl nm nn nc b">files$</code>可观察对象何时被刷新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">刷新文件表</p></figure><p id="6d24" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当一个可观察的流完成时，调用<code class="fe nl nm nn nc b">finalize</code>操作符。让<code class="fe nl nm nn nc b">getFilesSubject</code>在由<code class="fe nl nm nn nc b">finalize</code>调用的函数中发出一个事件，以便在上传完成时刷新文件列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完整的应用组件</p></figure><h1 id="c116" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">恭喜你！🎉</h1><p id="4cc4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感谢您的关注！如果您做的一切都正确，您的应用程序应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0066e6fd27e3c5ad14bcac7ec337ce2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/1*u9uwHhYV7v9kNpYpWMzxJQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件上传进度和刷新</p></figure><p id="56a3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在未来，我希望发布本教程的第2部分，解释如何添加模态对话框，将上传逻辑移入“智能”组件，将文件添加到正在进行的上传中，并使应用程序看起来更专业。</p><p id="b2f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面先睹为快，看看未来的教程会是什么样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1ce05aee2fa433052745c01816e4d50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*sQZz5rOMlzljs_fco6wLeQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">未来文件上传</p></figure><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ece9" class="ng kx iq nc b gy nh ni l nj nk"><strong class="nc ir">Want to Connect?</strong></span><span id="1ad6" class="ng kx iq nc b gy og ni l nj nk">If you found the information in this tutorial useful please follow me on <a class="ae kv" href="https://github.com/bobbyg603" rel="noopener ugc nofollow" target="_blank">GitHub</a>, and subscribe to my <a class="ae kv" href="https://www.youtube.com/c/bobbyg603" rel="noopener ugc nofollow" target="_blank">YouTube</a> channel.</span></pre></div></div>    
</body>
</html>