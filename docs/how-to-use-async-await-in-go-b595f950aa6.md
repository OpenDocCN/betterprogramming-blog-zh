# 如何在 Go 中使用异步/等待

> 原文：<https://betterprogramming.pub/how-to-use-async-await-in-go-b595f950aa6>

## 有了渠道，就简单了！

![](img/24a2c5537aaa6fa68307ed471c5afdcd.png)

昆汀·德格拉夫在 [Unsplash](https://images.unsplash.com/photo-1507823690283-48b0929e727b?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80) 上拍摄的照片

如果你使用多种语言，其中一种是 Go，你可能会想是否有一种 Go 等同于其他语言中一直流行的`async` / `await`。

例如，如果你最近用 JavaScript、Python 或另一种现代语言编程，你可能已经见过用于编写非阻塞函数的`async`和`await`。

这里有一个 JavaScript 的例子:

在 Python 中，模式非常相似:

这太棒了。它使程序员能够编写并发的代码*，而*不必使用回调函数、特殊框架或并行性。这是对比**并发性**(可以同时在多个地方运行的代码)和**并行性**(一次运行多个自身副本的代码)的最佳方式。并行是实现并发的一种方式。不是不好，只是复杂。我们可以通过多线程或多处理来实现。

旁注:并发性与并行性一直出现在面试问题中。知道这两个概念之间的区别，并且能够举出一个具体的例子来展示你的知识，这是一个很好的想法。

举例来说，想象一个脚本调用`my_asynchronous_function` (来自上面的例子)一次，然后退出。如果您需要这样做 100 次，但是想要节省时间，您可以并行运行这个脚本 100 次。想想看，这就是平行。但是，由于这是一个异步函数，您可以从同一个脚本中调用该函数 100 次，这些函数调用可以在等待网络上的 API 响应的同时进行计算。相比之下，这就是并发性。

但是如果`async` / `await`对于并发编程如此有用，那么为什么它没有出现在 Go 的语言规范中呢？毕竟，Go 是一种非常并发友好的语言。

答案在于 Go 语言的一个更加实用的特性:通道。

通道就像在并发代码中进行通信的共享信息管道。可以跨多个 goroutines 以最小的开销读取或写入通道。等待一个值出现在通道上类似于 JavaScript 中的承诺或 Python 中的协程。如果你还没看的话，看看[官方的解释吧。通过通道，Go 可以模仿`async` / `await`模式，同样简单，如下所示:](https://tour.golang.org/concurrency/2)

请注意，本例中的大部分复杂性都存在，因为 Go 是一种系统编程语言，所以我们必须手工关闭和读取请求。然而，并发性是用`go` / `<-`简洁地实现的。这是相当于`async` / `await`的围棋。

如果你曾希望在 Go 中使用`async` / `await`模式，只需遵循以下步骤，就能获得清晰、等效的结果:

1.  创建一个通道来接收来自“异步”函数的响应
2.  使用`go`关键字作为 goroutine 运行您的“async”函数
3.  使用`<-`从您的渠道“等待”结果

来自 Python 和 JavaScript 背景，我发现这个翻译非常有帮助，因为我经常用`async`和`await`来思考。有趣的是，它有时也反过来起作用。当我阅读 Go 代码时，有时我会想到`go`就像我会想到`async`一样，想到`<-`就像我会想到`await`一样。

这并不完美，因为`go`和`<-`并不像`async` / `await`那样紧密合作。在 Go 中可以有一个而没有另一个，goroutines 和 channels 有很多其他的用途，不像上面简单的一个。不过，我希望这是一个有用的技巧，可以帮助您思考 Go 中的并发模式，或者至少更好地理解其他人可能是如何做的。

毕竟，现代程序员必须利用多种语言的专业知识，将一种语言的惯用模式翻译成另一种语言的常见结构。希望我已经帮助说明了`async` / `await`不仅仅是一种语言结构，而是一种精神工具，即使在没有这些关键字的语言中也可以利用。

一如既往，**勇往直前，勇往直前！**