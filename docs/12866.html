<html>
<head>
<title>A Perception of Exception in Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林协程中的异常感知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-perception-of-exception-in-kotlin-coroutines-d0b87131510f?source=collection_archive---------5-----------------------#2022-07-07">https://betterprogramming.pub/a-perception-of-exception-in-kotlin-coroutines-d0b87131510f?source=collection_archive---------5-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a2b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">别让他们控制你，你来控制他们！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a9e118c976d2bb890c18a2fe56fb27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7_5y_Y7o0ZI_LeXG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@vonshnauzer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">叶戈尔·迈兹尼克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异常处理是任何代码执行的一个非常重要的部分，当涉及到协同程序时，它变得非常关键，因为要理解协同程序的异常处理，您需要理解它们的基本操作方式和它们支持的并发模式。在不知道的情况下，编写任何数量的try-catch块都没有任何帮助。</p><p id="94e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果你想知道协程是什么，为什么，以及怎样的，读读</em> <a class="ae kv" href="https://blog.devgenius.io/kotlin-coroutines-what-why-how-99529c951a2e" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这个</em> </a> <em class="ls">和</em> <a class="ae kv" href="https://blog.devgenius.io/kotlin-coroutines-job-and-timeout-d7b8c5416d69" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这个</em> </a> <em class="ls">。你不会失望的。</em></p><p id="cd82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们对协程有了基本的了解，在本文中，我们将试图简化和理解异常处理是如何为协程工作的。我们将通过按指定顺序理解以下内容来涵盖这个主题。</p><ul class=""><li id="5fc2" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">协程上下文中的异常和取消是什么？</li><li id="dcf6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">异常如何在协程层次结构中传播？</li><li id="0b79" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">如何处理协程中的异常？</li><li id="7008" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">什么是异常聚合？</li></ul><h1 id="6f97" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">协程上下文中的异常和取消是什么？</h1><p id="2614" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这可能有点棘手和混乱，但在我们处理任何其他事情之前，我们需要非常清楚这一点。简单来说:</p><p id="ca72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异常是意外发生的事情，对于子协程及其父协程来说是不可捕获或不可处理的。任何子协程中未捕获的异常都会取消其父作业。</p><p id="6373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">取消是指用<code class="fe ne nf ng nh b">CancellationException</code>取消一个协程，但不取消其父进程的作业。父处理程序忽略用<code class="fe ne nf ng nh b">CancellationException</code>取消协同程序，因为这是被取消的协同程序的预期行为。</p><p id="8f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是两种不同的行为，但也是相互关联的，因为取消在内部使用<code class="fe ne nf ng nh b">CancellationException</code>来更新父代。</p><p id="e2f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，就是这么简单。随着我们的前进，我们会对这些有更多的了解。</p><h1 id="b9e4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">异常如何在协程层次结构中传播？</h1><p id="cbaa" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们知道了什么是异常和取消，让我们看看异常是如何在协程中引发并在层次结构中传播的。</p><p id="9e18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景1:协程提供协作取消，即如果子进程未能完成其任务或被取消，它会将其异常传递给其父进程协程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/996b83554ddf95e7b9ad97818b65be52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FACo4mVMp_Hf_BcWPpX1Sw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片1</p></figure><p id="6ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图显示了<code class="fe ne nf ng nh b">runBlocking</code>协程有三个子协程。因此，如果第一个被取消，那么它将把<code class="fe ne nf ng nh b">CancellationException</code>传递给它的父进程，即<code class="fe ne nf ng nh b">runBlocking</code>，父进程将简单地忽略这个异常，因为它是一个被取消的作业的异常行为。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该代码是图像1的实现。我们可以看到，launch 1没有打印在日志中，因为它被取消了，但其余的作业都已执行。</p><p id="ef04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景2:如果协程的子进程未能完成其任务，并抛出一个未被捕获的异常。异常再次被传递给父进程，但是在这种情况下，父进程将取消它的所有子进程和它自己的任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f0b52aa927b47066a45ca0c1de79786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*DWLk7icmtf5hrvrbo7PD0Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片2</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f5b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，一旦launch 1抛出异常，第三次启动就无法完成，因为父进程取消了其子进程的所有作业。</p><p id="b442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯！以上两个场景描述了协作取消，并展示了异常是如何传递到层次结构的根的。现在我们已经知道了异常传播，让我们继续。</p><h1 id="a8a6" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">如何处理协程中的异常？</h1><p id="a3b0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">使用<code class="fe ne nf ng nh b">CoroutineExceptionHandler</code>可以修改未捕获的异常行为。这是一个异常处理程序，可以与根父级一起使用，并充当通用catch块。一旦我们进入异常处理程序块，我们就不能对异常做太多的事情，因为当处理程序被调用时，协程已经完成了它的执行。</p><blockquote class="nm nn no"><p id="8791" class="kw kx ls ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">CoroutineExceptionHandler仅在未捕获的异常上调用，这些异常不会以其他方式处理。</p></blockquote><p id="c1b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景1:让我们首先看看如果我们将这个处理程序传递给我们的子协程会怎么样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ecf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，我们创建了一个<code class="fe ne nf ng nh b">CoroutineExceptionHandler</code>对象，并将其传递给我们的launch 1。如果我们运行这段代码，我们会看到在输出中没有调用launch 3，也没有打印异常日志。为什么？</p><p id="3d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">嗯，那是因为launch 1是</em> <code class="fe ne nf ng nh b"><em class="ls">runBlocking</em></code> <em class="ls">的子节点，它会把它的异常传递给它的父节点，所以这种情况下的异常处理程序是无效的。</em></p><p id="a6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景2:现在让我们看看如果我们将这个处理程序传递给一个根协程会怎么样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，launch 1是一个根协程，这意味着它不是<code class="fe ne nf ng nh b">runBlocking</code>的子进程。如果有孩子的话，它就是孩子的父母。现在，当根协程抛出一个异常时，我们打印出异常日志，显示传递异常处理程序只对根协程有效，而不对子协程有效。</p><p id="607c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">场景3:让我们也看看使用异步构建器的场景2。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行代码，我们会看到，即使在传递了根异步构建器中的处理程序之后，异常也在catch块中被捕获。这是为什么呢？</p><p id="dc9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">这样做的原因是异步构建器返回的结果被封装在延迟对象中，这意味着即使有未捕获的异常，它也会被封装在延迟对象中。</em></p><p id="b7de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此在deferred上调用<code class="fe ne nf ng nh b">await()</code>意味着我们正在通过await调用等待结果，因此这个await调用接收到异常并抛出它。因为它在catch块中，所以我们在catch块中捕获异常，而不是在处理程序中。</p><p id="e52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能会有一个疑问，为什么我们不把处理程序传递给runBlocking？答案如下:</p><blockquote class="nm nn no"><p id="eab2" class="kw kx ls ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">" CoroutineExceptionHandler总是安装到在GlobalScope中创建的协程中。为在主运行阻塞范围内启动的协同例程安装异常处理程序是没有意义的，因为尽管安装了处理程序，当其子例程异常完成时，主协同例程总是会被取消。”</p></blockquote><h1 id="b37d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">什么是异常聚合？</h1><p id="6e0a" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当多个子节点因异常而失败时，第一个子节点赢得传播竞赛，其余的子节点作为被抑制的子节点被附加。这称为异常聚合。</p><p id="af21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此功能仅受JDK 7+支持，输出如下所示</p><pre class="kg kh ki kj gt ns nh nt nu aw nv bi"><span id="4b71" class="nw mi iq nh b gy nx ny l nz oa">CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]</span></pre><p id="e584" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中IOException由一个孩子抛出，算术由另一个孩子抛出。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="ea5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。最后，我们清楚地了解了如何处理协程中的异常。一定要试着自己运行代码片段，尝试不同的场景来理解功能。</p><p id="c472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果你想阅读协程基础知识，可以在这里阅读</em><a class="ae kv" href="https://blog.devgenius.io/kotlin-coroutines-what-why-how-99529c951a2e" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">和</em> <a class="ae kv" href="https://blog.devgenius.io/kotlin-coroutines-job-and-timeout-d7b8c5416d69" rel="noopener ugc nofollow" target="_blank"> <em class="ls">在这里</em> </a> <em class="ls">。</em></p><p id="604f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这能对你有所帮助。会尽量以简化的方式带来更多的内容。如果你有任何建议的话题，请告诉我。</p><p id="127b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您喜欢内容，我们可以在<a class="ae kv" href="https://saurabhpant.medium.com/" rel="noopener"> Medium </a>或<a class="ae kv" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上连接。订阅电子邮件以获得新主题的即时更新。</p><p id="4d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前就这些。敬请期待！</p><p id="c304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见。</p><p id="6802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！</p></div></div>    
</body>
</html>