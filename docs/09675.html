<html>
<head>
<title>4 Cool Facts About Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Jetpack Compose的4个酷事实</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-cool-facts-about-jetpack-compose-d9e6c795f9a1?source=collection_archive---------3-----------------------#2021-09-24">https://betterprogramming.pub/4-cool-facts-about-jetpack-compose-d9e6c795f9a1?source=collection_archive---------3-----------------------#2021-09-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9817" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在Android中构建用户界面变得越来越容易和快速</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2ed3a26782ed9c8585f5779d25df6c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zPfFOg6lXqUWH97F"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@andymant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Andrew M </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="f19b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Jetpack Compose 是谷歌最新的UI框架，用于构建Android(和<a class="ae kz" href="https://www.jetbrains.com/lp/compose/" rel="noopener ugc nofollow" target="_blank">桌面</a>)应用。它极大地改变了构建UI组件的方法。它是完全声明性的，意味着您通过调用一系列将数据转换成UI层次结构的函数来描述您的UI。它是不捆绑的，这意味着它向后兼容旧版本的Android，可以独立于Android操作系统进行更新。</p><p id="ce64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但最重要的是，它使得编写UI代码变得非常容易。你会问，有多容易？就像下面的代码一样简单:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><p id="7c15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个简短的函数在UI中创建一个列表，就像您使用RecyclerView构建的一样。</p><p id="cff2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并且你可以在这个<code class="fe ly lz ma mb b">LazyColumn</code>中构建任何UI，想象一下自己通过在布局中添加一个适配器、<code class="fe ly lz ma mb b">ViewHolder</code>、<code class="fe ly lz ma mb b">DiffUtil</code>类和一个<code class="fe ly lz ma mb b">RecyclerView</code>来开发它。</p><p id="edce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我想分享我在学习作曲时遇到的最有趣的事实。</p><h1 id="7146" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">1.Compose可与Android视图互操作</h1><p id="d93e" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj mw ll lm ln mx lp lq lr my lt lu lv in bi translated">可以在Android视图中使用Compose，在Compose中使用Android视图。</p><p id="c752" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这很好，因为Compose将与您现有的UI实现一起工作。如果你想把它添加到你的项目中，你不必一步到位，一气呵成。你可以慢慢开始，介绍一些基础的东西，比如主题、样式，然后逐渐将Compose集成到你的代码库中。欲了解更多详情，请查看此<a class="ae kz" href="https://developer.android.com/jetpack/compose/interop" rel="noopener ugc nofollow" target="_blank">页面</a>。</p><h1 id="aeeb" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">2.可组合的函数可能在后台线程池中执行</h1><p id="632a" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj mw ll lm ln mx lp lq lr my lt lu lv in bi translated">与Android视图不同，Compose可以在后台线程中运行您的可组合函数(您可以在其中声明您的UI )!</p><p id="ed33" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它可以通过并行运行可组合函数来优化重组(更新UI中发生变化的部分)。这使得Compose可以利用多个内核，并以较低的优先级运行不在屏幕上的可组合函数。</p><h1 id="4fe3" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">3.所有可组合的函数和lambdas必须没有副作用</h1><p id="de2c" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj mw ll lm ln mx lp lq lr my lt lu lv in bi translated">可组合函数必须具有以下属性:</p><ul class=""><li id="7f70" class="mz na iu lc b ld le lg lh lj nb ln nc lr nd lv ne nf ng nh bi translated">当用同一个参数多次调用该函数时，它的行为是一样的，并且它不使用其他值，比如全局变量或对<code class="fe ly lz ma mb b">random()</code>的调用。</li><li id="276a" class="mz na iu lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">函数描述了没有任何副作用的UI，例如修改属性或全局变量。</li></ul><p id="49ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Compose使用的声明式编程范式中，当您想要更新UI时，需要用新数据再次调用composable函数。这样做会导致UI被重新组合——如果需要的话，由函数发出的小部件会用新数据重新绘制。</p><p id="e878" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">重新构建整个UI树的计算开销会很大。Compose用这种智能重组解决了这个问题。重组是当输入改变时再次调用可组合函数的过程。当Compose基于新的输入重新组合时，它只调用可能已经改变的函数或lambdas，而跳过其余的。通过跳过所有没有改变参数的函数，Compose可以高效地重新组合。</p><p id="0ce4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当需要执行副作用时，从回调(如<code class="fe ly lz ma mb b">onClick</code>)中触发它，而不是从可组合函数中访问局部或全局变量。这些回调总是在UI线程上执行。[ <a class="ae kz" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="52d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你必须在一个组合函数中保持一个状态，你应该使用<code class="fe ly lz ma mb b">mutableStateOf</code>和<code class="fe ly lz ma mb b">remember</code>来避免每次重组都有不同的状态。这就把我们带到了下一个话题。</p><h1 id="cb62" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">4.撰写没有内部状态</h1><p id="c5cc" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj mw ll lm ln mx lp lq lr my lt lu lv in bi translated">在Compose中，状态管理掌握在开发人员手中。默认情况下，Compose中没有内部状态。这将消除应用程序和合成组件之间的同步问题。</p><p id="194a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，与Android视图不同，当你点击复选框或切换按钮(在Compose中称为切换)时，它不会在Compose中默认自动切换。您需要编写“点击开关改变开关状态”逻辑的代码。</p><p id="48f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，考虑以下可组合函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/788f651ce56c7b2b38de81a84734cc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*5p6o27XOAMv_uF1O92bA6w.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="8cd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这不会使复选框自动可勾选。因为我们还需要实现<code class="fe ly lz ma mb b">onCheckedChange </code>回调，实现“点击复选框使其被选中”的逻辑。</p><p id="096f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能认为我们可以像这样在可组合函数中添加一个Kotlin变量:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><p id="a8dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，这不是好的做法，也不会起作用。因为Compose不知道这个状态，所以这个值将在下一次重新组合时被丢弃。我们需要在Compose中注册这个状态，以便它可以在进行重组时考虑它。</p><p id="d620" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该使用<code class="fe ly lz ma mb b">remember</code>函数，而不是科特林变量:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/c4025f3d7673c7371accec236a5272b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*uHXNW0fYASC1rLYFxmAaZA.gif"/></div></figure><p id="4643" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在用<code class="fe ly lz ma mb b">remember</code> Compose了解我们的状态。这样，我们可以创建一个典型的行为，您可以检查并看到它处于选中状态。</p><p id="6ae9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有其他存储状态的方法。因为您可能并不总是希望将它存储在您的可组合函数中。还可以将必要的信息和回调函数作为可组合函数的参数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lw lx l"/></div></figure><p id="ccfb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这允许父节点控制子节点的状态，称为状态提升<em class="no">。</em>在构建这些函数时，您应该考虑父节点是否可能对状态感兴趣，如果是，则考虑使用这种方法。[ <a class="ae kz" href="https://developer.android.com/jetpack/compose/state" rel="noopener ugc nofollow" target="_blank">来源</a></p><h1 id="babd" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">Compose现在可以投入生产了</h1><p id="0f6b" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj mw ll lm ln mx lp lq lr my lt lu lv in bi translated">作曲最近达到稳定。这是一个开始学习并为你的项目考虑它的好时机。<a class="ae kz" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">立即开始使用Jetpack Compose！</a></p><p id="bd1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您今天的参与，下次再见。</p></div></div>    
</body>
</html>