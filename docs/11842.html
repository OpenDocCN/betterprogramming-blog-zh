<html>
<head>
<title>Python’s Match-Case Is Too Slow (If You Don’t Understand It)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的匹配速度太慢(如果你不理解的话)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pythons-match-case-is-too-slow-if-you-don-t-understand-it-8e8d0cf927d?source=collection_archive---------2-----------------------#2022-04-21">https://betterprogramming.pub/pythons-match-case-is-too-slow-if-you-don-t-understand-it-8e8d0cf927d?source=collection_archive---------2-----------------------#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3275" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解结构模式匹配是如何工作的，在哪里使用它，以及应该用什么来代替</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1afc9c7906463b7156c218f839b13cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*daDEFs8XzYbJVGGt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米歇尔·玛特隆在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="be34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的3.10版本带来了一个新的语法特性:结构模式匹配。这个特性允许简单的声明性条件处理，它应该用更简洁的语法替换if-else语句序列。</p><p id="9d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你来自像C这样的编译语言，你可能会看到Python的match-case语句像switch-case，只是名字不同而已。然而，尽管C编译器通常会生成一个类似智能<a class="ae ky" href="https://en.wikipedia.org/wiki/Lookup_table" rel="noopener ugc nofollow" target="_blank">的查找表</a>的结构来有效地处理各种情况，Python的结构模式匹配却是相当低效的，尤其是在你使用不当的情况下。我们来看看为什么。</p><h2 id="e7c9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Python匹配案例语句示例</h2><p id="8261" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我相信大家都熟悉使用一系列if-else语句来检查条件并相应地改变程序行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python 3.10的结构模式匹配，您可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="eb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个代码片段实现了完全相同的事情:它们根据你传入的名字来做事情。那么，它们有什么不同呢？</p><h2 id="1774" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">匹配用例与if-else性能指标评测</h2><p id="5451" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我现在将比较两个Python函数的性能，一个是使用结构化模式匹配实现的，另一个是作为if-else语句序列实现的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">If-else语句序列</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结构模式匹配</p></figure><p id="ea4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是负责基准测试的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准的代码</p></figure><p id="5b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看结果:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="376c" class="lv lw it mw b gy na nb l nc nd">Average time for match_case:  0.004244441888295114 seconds<br/>Average time for if_else:     0.004139213310554624 seconds</span></pre><p id="d576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以清楚地看到，两个函数用了相同的时间来执行。如果我告诉你它们在引擎盖下工作是一样的呢？</p><h2 id="e0f7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">大小写匹配是如何工作的？</h2><p id="10a7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们来看看Python的结构模式匹配到底是什么，以及它与if-else语句相比如何。对于这个分析，我们将使用<a class="ae ky" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器资源管理器</a>，这是一个功能强大的网站，允许您轻松查看通过编译给定代码生成的汇编指令。</p><p id="d293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先这里是一个简化的if-else序列和相对反汇编的Python字节码。如果您不熟悉汇编语言，请不要担心，因为我会根据需要解释说明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的if-else序列</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为if-else序列注释生成的汇编代码</p></figure><p id="af74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能已经猜到的，一系列if-else语句编译成一系列比较。现在，让我们来看看匹配案例版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的大小写匹配语句</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">match-case语句的注释汇编代码</p></figure><p id="6914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Python的match-case语句只是一系列比较，就像if-else方法一样。这就是为什么当我们对这两种方法进行基准测试时，它们表现相同。</p><p id="8f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您应该注意到Python的结构模式匹配不执行简单的对象比较，而是模式比较。由于这个原因，在处理match-case语句的情况时，不会调用<code class="fe ne nf ng mw b">__eq__()</code>方法(负责处理<code class="fe ne nf ng mw b">==</code>操作)。为了证明这一点，让我们用一个自定义对象运行这个简单的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配情况副作用</p></figure><p id="f74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果有效地调用了<code class="fe ne nf ng mw b">__eq__()</code>方法，我们应该为每个被测试的案例在控制台上打印一些东西，但是我们没有，正如您从控制台输出中看到的:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e08a" class="lv lw it mw b gy na nb l nc nd">$ python3 match_side_effects.py</span><span id="833e" class="lv lw it mw b gy nh nb l nc nd">five</span></pre><p id="2c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们用if-else序列执行相同类型的比较，我们将得到下面的输出，这意味着每次比较都会调用<code class="fe ne nf ng mw b">__eq__()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">If-else副作用</p></figure><p id="5225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及相应的控制台输出:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a33c" class="lv lw it mw b gy na nb l nc nd">$ python3 match_side_effects.py <br/><br/>5 == 1<br/>5 == 2<br/>5 == 3<br/>5 == 4<br/>5 == 5<br/>five</span></pre><p id="0ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们目前所看到的来看，Python的结构化模式匹配实际上是一系列不同名称和更好语法下的if-else语句。虽然match-case在您的工具箱中肯定有它的位置(我们将在后面讨论)，但是如果您正在寻找运行时性能，您可能想要一些不同的东西:这里有一种更快的方法。</p><h2 id="b445" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">查找表和哈希表</h2><p id="ef6d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">简单地说，查找表和哈希表是用于存储预先计算的值的数据结构，以便在运行时不必计算它们。假设你有一个允许进入某个房间的名字唯一的人的名单。您可以通过if-else序列检查是否允许某人进入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法只在少数情况下适用，但随着允许人员列表的增长，检查每个可能的姓名会变得非常低效。</p><p id="10d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用哈希表(也称为字典)的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="76c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解发生了什么，让我们来看看编译器资源管理器生成的汇编指令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，与我们之前看到的if-else序列和match-case语句相比，条件检查部分要简单得多。现在让我们看看与顺序检查相比，哈希表有多快。</p><p id="accf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基准测试，我们将使用前面的代码片段(<code class="fe ne nf ng mw b">if_names()</code>和<code class="fe ne nf ng mw b">match_names()</code>)与通过散列表实现的相同逻辑进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试代码与之前相同，只是我们添加了对<code class="fe ne nf ng mw b">dict_names()</code>的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="df1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看结果:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c5cd" class="lv lw it mw b gy na nb l nc nd">Average time for match_case:  0.004383811901789159 seconds<br/>Average time for if_else:     0.00433244610321708 seconds<br/>Average time for dict_lookup: 0.0008352182921953499 seconds</span></pre><p id="e52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个明显的赢家:哈希表比一系列的比较要快得多，大约5.3倍的性能。</p><h2 id="45db" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">何时使用结构模式匹配</h2><p id="d8b9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">到目前为止，我只对结构模式匹配持否定态度，说它很慢，只不过是一系列if-else语句。然而，它仍然应该在您的工具箱中占有它的位置，因为它实际上是一个模式匹配语句。</p><p id="9e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要检查一个有点复杂的模式，那么您不会有很多机会使用散列表或查找表，因为它们固有的不灵活性使得它们非常快。If-else语句可以完成这项工作，但是代码很快就会变得一团糟。这就是你应该使用结构模式匹配的地方。这里有一个来自<a class="ae ky" href="https://peps.python.org/pep-0636/" rel="noopener ugc nofollow" target="_blank"> PEP-636 </a>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你面对几个简单的条件时，你应该使用一个简单的if-else语句序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果您有大量可能被视为简单条件的情况，或者您需要运行时性能，那么您最好使用哈希表或查找表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，查找表和哈希表不仅限于存储简单的值，它们还可以包含完整的函数或复杂的对象。</p><p id="bf6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你用Python编程，你的主要目标可能不是运行时性能，为此你应该选择编译语言。然而，显著的速度提升——记住基准测试中5.3倍的性能提升——不会有坏处。此外，了解您的工具、它们的优点和缺点总是好的，并且，一般来说，要知道您正在做什么。</p><h2 id="deb1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="4469" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">总而言之，结构化模式匹配是一个强大的语法特性，它允许简单的声明性条件分支。虽然它对于模式匹配(其最初目的)来说很方便，但一些开发人员将其误认为是一种高性能的类似查找表的工具，类似于C编译器优化switch-case语句的方式。</p><p id="6d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键的一点是，你应该知道你的工具，以决定在每一个特定的情况下哪一个是最合适的。</p><blockquote class="ni"><p id="6998" class="nj nk it bd nl nm nn no np nq nr lu dk translated">生活中没有放之四海而皆准的方法。归根结底，就是使用正确的工具完成正确的工作。</p></blockquote><p id="9e3e" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有什么要补充的，请在评论中分享你的想法。感谢阅读！</p><p id="220f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多关于查找表和哈希表的知识，我建议你看看下面这个故事:</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">用查找表和哈希表去掉过多的If-Else语句</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">在所有专业代码库中使用的代码性能实践。通过这些简单的例子学习使用它们。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">better编程. pub</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>