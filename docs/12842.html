<html>
<head>
<title>How to Write Syntax Tree-Based Domain-Specific Languages in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中编写基于语法树的特定领域语言</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-syntax-tree-based-domain-specific-languages-in-go-b15537f0d2f3?source=collection_archive---------5-----------------------#2022-07-06">https://betterprogramming.pub/how-to-write-syntax-tree-based-domain-specific-languages-in-go-b15537f0d2f3?source=collection_archive---------5-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ebb4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于AST的DSL在表示递归结构方面的能力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/068ef9e8e8951567e6a8fab46ade971f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G_skVWh7IgAWIGl_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰里米·毕晓普在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7e8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大约一年来，我一直在写Go，同样长的时间里，我一直在实现语法树。现在进行的还可以，但是当我开始的时候，由于我没有找到任何初学者友好的内容，所以这是一场真正的斗争。所以，这是我在做年轻时的自己，也希望是你们中的一些人，帮个忙。</p><p id="bd13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于语法树的特定领域语言的一个有用特性是它们的递归性质，这使得它们在表示数学领域(如逻辑和代数)方面非常出色。作为一个工作示例，我们将编写一个程序，它可以象征性地表示基本的代数表达式，并对它们进行操作和求值。如果你不是像我一样的数学呆子；放心吧！我将主要关注我们计划的实施细节，而不是数学。</p><h1 id="53dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><h2 id="b5af" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">特定领域语言(DSL)</h2><p id="c642" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">你不必成为<a class="ae kv" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank">领域特定语言</a>(DSL)的专家。事实上，除了知道它是一种比通用语言<a class="ae kv" href="https://en.wikipedia.org/wiki/General-purpose_language" rel="noopener ugc nofollow" target="_blank"/>(GPR)范围更小的语言之外，你真的不需要了解它的任何东西，比如Go。这意味着DSL被优化以非常有效地解决一个特定领域的问题(在计算和实现方面)，它甚至可能不支持该领域之外的任何事情。</p><p id="29de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为DSL的功能非常有限，所以通常用其他语言来实现。因此，用于构建SQL查询的包可以被认为是DSL，其中域是SQL查询。在我们的工作示例中，域将是代数表达式，并作为Go包实现。</p><h2 id="c7b1" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">抽象语法树</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9c8f2f81f2b7faf3e213ae1a0a3f1417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*5wq2bufZk-dMmCAB-nYlFA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nc">图1: </strong>表达式4+6x的树形表示。</p></figure><p id="f969" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a> (AST)是一种数据结构，用于表示某些数据的<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax" rel="noopener ugc nofollow" target="_blank">抽象语法</a>结构。这对我们来说意味着，顾名思义，AST将一些数据的结构和含义表示为一棵树。易于通过ASTs建模的数据类型通常是递归的，例如代数表达式或源代码。ast通常在编译器中使用，因为它们可以表示含义。</p><p id="3c24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的意图和目的来说，认识到一个代数表达式，例如图1中呈现的<code class="fe nd ne nf ng b">4 + 6x</code>,非常适合树结构就足够了。更准确地说，每个操作符(<code class="fe nd ne nf ng b">+</code>、<code class="fe nd ne nf ng b">-</code>、<code class="fe nd ne nf ng b">*</code>、<code class="fe nd ne nf ng b">/</code>、<code class="fe nd ne nf ng b">Const</code>、<code class="fe nd ne nf ng b">x</code>)都由一个节点来表示，而它的参数(如果有的话)则由子节点来表示。</p><h2 id="21d6" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">结合DSL和AST</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/491ed581adec5c1d5b3a34b504d2dffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrsDIbSqOVptoOYGchhNRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nc">图2: </strong>评估过程的可视化；从AST到数字。</p></figure><p id="4d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了DSL和AST是什么的概念，我们可以将它们拼凑在一起，以形成我们的工作示例背后的思想，即用于简单代数表达式的基于语法树的领域特定语言。</p><p id="f1c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望能够表示包含任何或所有基本算术运算符(<code class="fe nd ne nf ng b">+</code>、<code class="fe nd ne nf ng b">-</code>、<code class="fe nd ne nf ng b">*</code>、<code class="fe nd ne nf ng b">/</code>)的一个变量的任何代数表达式，并且我们希望以某种方式在某个指定值对给定表达式求值。所有这些都在图2中举例说明，其中表达式<code class="fe nd ne nf ng b">4 + 6x</code>被表示为AST，并且在<code class="fe nd ne nf ng b">x = 10</code>对其求值的过程被可视化，从而产生<code class="fe nd ne nf ng b">4 + 6*10 = 64</code>。</p><h1 id="2788" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">履行</h1><h2 id="68b9" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">使用结构的树建模</h2><p id="8315" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">创建这种基于语法的DSL时，最重要的工具是Go的类型系统。然而，在开始构建我们的AST的树结构之前，我们将查看图1中的每个节点，并意识到似乎有两大类不同的节点；有孩子的和没有孩子的。前者包括基本的算术运算(<code class="fe nd ne nf ng b">+</code>、<code class="fe nd ne nf ng b">-</code>、<code class="fe nd ne nf ng b">*</code>、<code class="fe nd ne nf ng b">/</code>)。它们都有两个参数，在我们的树结构中，这两个参数对应于它的子节点。没有子节点的节点是我们的树结构的叶子，可以被看作由常量和变量组成。</p><p id="fe84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们认识到，每一种不同的节点类型都可以，单独地或连接起来形成一棵树，被认为是代数表达式。因此，我们将接口定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地打印代数表达式，我们让这个接口实现了<code class="fe nd ne nf ng b">String</code>方法。</p><p id="48c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了不同类型的节点和捕获它们相似性的接口，我们可以在<a class="ae kv" href="https://go101.org/article/type-embedding.html" rel="noopener ugc nofollow" target="_blank">类型嵌入</a>的帮助下将所有不同类型的节点定义为结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3d45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，类型嵌入指的是每个结构顶部的类型为<code class="fe nd ne nf ng b">Expr</code>的未命名结构字段。这基本上是Go对继承的模拟，并且说每个节点类型也是一个<code class="fe nd ne nf ng b">Expr</code>。这使得将节点的子节点或参数定义为嵌入接口<code class="fe nd ne nf ng b">Expr</code>的任何类型成为可能。</p><p id="6a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe nd ne nf ng b">String</code>方法实现的细节:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现了所有这些之后，我们可以构建如图1所示的表达式，并用下面的程序打印出来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="103d" class="mk lt iq ng b gy no np l nq nr">&gt; go run main.go<br/>( 4 ) + ( ( 6 ) * ( X ))</span></pre><h1 id="ff7c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">评估函数</h1><p id="07c1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">能够使用结构和类型嵌入在Go中表示一个代数表达式是很酷的，但是我们也想对给定的值<code class="fe nd ne nf ng b">x</code>进行评估。为此，我们扩展了接口<code class="fe nd ne nf ng b">Expr</code>以包含一个名为<code class="fe nd ne nf ng b">Eval</code>的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数的行为如图2所示；它接受一个语法树和一个值<code class="fe nd ne nf ng b">x</code>,并返回以该值计算的表达式。为了实现这一点，我们利用递归，给每个节点类型它自己的<code class="fe nd ne nf ng b">Eval</code>实现，两种类型的叶节点(<code class="fe nd ne nf ng b">Const</code>和<code class="fe nd ne nf ng b">x</code>)作为递归的基本情况，因为它们没有子节点。在非叶节点的情况下，<code class="fe nd ne nf ng b">Eval</code>函数用Go中实际使用的语法操作替换语法操作，例如<code class="fe nd ne nf ng b">Add</code>变成了<code class="fe nd ne nf ng b">+</code>，然后递归地对节点的子节点执行同样的操作。在实践中，这看起来如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ec47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了表示一个代数表达式并把它打印到终端，我们现在还可以计算它的一个特定值。下面的程序显示了如何执行此操作的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="4024" class="mk lt iq ng b gy no np l nq nr">&gt; go run main.go<br/>( 4 ) + ( ( 6 ) * ( X )) = 64</span></pre><h2 id="00d3" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">转换语法树</h2><p id="2865" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">好的，我们可以在程序中把一个代数表达式表示成一个树形数据结构，对给定值求值，那又怎么样？为什么我们不直接把表达式写成lambda函数，去掉树和递归的麻烦？我希望你会问，因为我们还没有看到语法表示最令人惊奇的地方。</p><p id="c68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比方说，出于某种原因，你需要计算我们的示例表达式<code class="fe nd ne nf ng b">4 + 6x</code>的导数。如果我们将该表达式表示为lambda函数，我们只能近似计算给定值<code class="fe nd ne nf ng b">x</code>的导数，但是使用我们基于AST的DSL，我们实际上可以根据我们在数学课上学到的所有规则进行微分，从而获得精确的导数，然后我们可以在任何点对其进行求值。</p><p id="7bac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这成为可能，我们需要用微分函数<code class="fe nd ne nf ng b">D</code>扩展我们的<code class="fe nd ne nf ng b">Expr</code>接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a76f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，就像对<code class="fe nd ne nf ng b">Eval</code>-函数一样，我们可以递归地实现每个不同操作符的微分规则:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以通过运行下面的简单程序来区分我们的表达式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="0800" class="mk lt iq ng b gy no np l nq nr">&gt; go run main.go<br/>D(( 4 ) + ( ( 6 ) * ( X ) )) = ( 0 ) + ( ( ( 0 ) * ( X ) ) + ( ( 6 ) * ( 1 ) ) )</span></pre><p id="eba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出有很多冗余项，这是由于我们从来不简化表达，而是变成了我们所期望的；<code class="fe nd ne nf ng b">D(4 + 6x) = 0 + 0*x + 6*1 = 6</code>。</p><h1 id="23a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="eaea" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们现在已经看到了基于AST的DSL在表示递归结构，特别是代数表达式时是多么有用，以及如何在Go中实现它们。我们还看到了在进行符号转换(如微分)时，语法表示是多么有用。</p><p id="20f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你觉得这很有趣，那么你很幸运，因为你可以用ASTs和DSL做更多的事情。我第一次遇到这个话题是在查默斯科技大学的数学领域特定语言课程中，这是一门开源课程，其内容可以在G <a class="ae kv" href="https://github.com/DSLsofMath/DSLsofMath" rel="noopener ugc nofollow" target="_blank"> ithub repo </a>中找到。然而，该课程的内容相当数学化，但回购的自述文件中的参考资料包含一些涵盖该主题的文献，但没有太多数学内容。</p></div></div>    
</body>
</html>