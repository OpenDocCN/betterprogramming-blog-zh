<html>
<head>
<title>Exploring AWS CDK Pipeline and DR Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索AWS CDK管道和灾难恢复设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/aws-cdk-pipeline-and-dr-setup-d85920ee635c?source=collection_archive---------11-----------------------#2022-03-17">https://betterprogramming.pub/aws-cdk-pipeline-and-dr-setup-d85920ee635c?source=collection_archive---------11-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f412" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">想了解有关CDK跨区域部署的更多信息吗？请便！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b9505423c04a4a35723f53bd81f31d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qj3woCMzdLnA3pA5rYrdTw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">《云中雷雨》，来自<a class="ae kv" href="https://www.flickr.com/photos/jeffreysullivan/" rel="noopener ugc nofollow" target="_blank">杰夫·沙利文</a>在<a class="ae kv" href="https://www.flickr.com/photos/jeffreysullivan/11466953306" rel="noopener ugc nofollow" target="_blank"> Flickr </a>上。</p></figure><h1 id="0585" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="3c90" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">AWS CDK是将AWS基础设施作为代码进行管理的一个很好的工具，尤其是在复杂的环境中，构建在多个堆栈上。</p><p id="1120" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种部署的复杂性可以通过CDK管道轻松管理，在AWS服务(如CodePipeline和CodeBuild)之上实现。</p><p id="1d37" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，当涉及到跨多个地区、可能跨多个账户的弹性基础设施时，使用CDK(以及云形成，就此而言)会面临一些挑战，这些挑战可能不是那么容易克服的。</p><h1 id="542b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">方案</h1><p id="0e88" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了展示使用CDK实现这种弹性基础设施的可能方式，我将介绍一个我最近参与的真实用例场景。</p><p id="ced6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们考虑部署的主要单元包括:</p><ul class=""><li id="980a" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">一个S3桶</li><li id="c9d1" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">Redis集群的弹性缓存</li><li id="ab51" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">极光RDS星团</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/18590842d82d033042507294eb6e8f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*OnEQQAzFUKma3VfLkhoqVA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">场景资源</p></figure><p id="70e7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些资源作为CDK堆栈的一部分一起部署。</p><h1 id="78fd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">环境</h1><p id="dbbb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们还考虑一下，部署由跨越两个区域的几个客户(即开发、测试和生产)的CDK管道管理，这两个区域旨在作为主区域和灾难恢复区域。</p><p id="28db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为每一对客户和区域都被称为CDK的环境，所以我们的场景总共包括:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c050" class="nj kx iq nf b gy nk nl l nm nn">3 (accounts) x 2 (regions) = 6 (environments)</span></pre><h1 id="6069" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">预期目标状态</h1><p id="f217" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑到我们打算跨区域部署的主要资源，整体部署的目标状态应该是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7a7b845e14ae78df5c402d76f57a5a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbTkYgA_xMTsHuVUzBobKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">目标部署状态</p></figure><p id="93b5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面考虑的资源类型(S3存储桶、Redis集群的Elasticache和Aurora RDS实例)在跨区域设置中部署时，会在主服务器和从服务器之间引入一组依赖关系，不一定总是按照这个顺序。</p><p id="61fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，S3跨区域复制配置要求在创建配置本身之前存在复制副本存储桶，通常作为主存储桶创建的一部分。</p><p id="29c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相反，在为Redis创建elastic cache全局集群之前，必须为Redis创建一个辅助elastic cache集群基础设施。</p><p id="32ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">同样，Aurora RDS从配置只能添加到现有的Aurora RDS主集群中。</p><h1 id="261f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可能的排序</h1><p id="0c96" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑到上面介绍的依赖性，最初有三种可能的部署顺序:</p><ul class=""><li id="549f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">并行部署</li><li id="cdbc" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">主要优先</li><li id="9c97" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">次要优先</li></ul><p id="33c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看一下每个单独的序列，以了解哪一个可以成功实现。</p><h1 id="3a49" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">并行部署</h1><p id="8294" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这种部署方式可以表示如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/7a7b845e14ae78df5c402d76f57a5a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbTkYgA_xMTsHuVUzBobKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">并行部署</p></figure><p id="ae4c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在并行部署中，两个区域中的资源可以以任何速度部署，从而导致不可预测的结果，因为一些排序可能碰巧是正确的，而其他排序可能是错误的。</p><p id="7673" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，可能会出现这样的情况:辅助存储桶实际上是在主存储桶之前创建的，而辅助Redis紧随其后，而主Redis全局集群尚未创建。</p><p id="b570" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">更糟糕的是，不同的运行会导致不同的结果，增加了解决方案的不可预测性。</p><p id="91ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总而言之，尽管并行部署看起来是执行跨区域部署的最直接、最自然的方式，但是它的不可预测性使它完全不适合。</p><h1 id="a696" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">主要优先</h1><p id="01cc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于并行运行通常会失败，因为当辅助区域中的资源引用主区域中的资源时，主区域中的资源不可用，所以可能会尝试首先在主区域中部署资源。</p><p id="96e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将导致如下所示的部署序列:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/509f554681702428baf247a7525f7da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubPIf-oajFviOytX1ZR3kw.png"/></div></div></figure><p id="3557" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尽管这种部署顺序背后有逻辑推理，但它失败有多种原因:</p><ol class=""><li id="da1f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nq mv mw mx bi translated">主复制存储桶创建失败，因为它引用了辅助区域中尚不存在的存储桶</li><li id="fa5a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nq mv mw mx bi translated">主Redis集群被创建。但是，全局集群定义依赖于必须已经存在的辅助区域配置。</li><li id="904a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nq mv mw mx bi translated">从属Aurora基础结构必须添加到主要主节点的CDK对象中。在创建主节点时，还不存在辅助节点，因此无法添加辅助节点。</li></ol><p id="94f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的一些限制是由于CDK码看起来像明码，但是间接涉及跨越多个区域的资源的事实。</p><p id="aae2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另外，请记住，在不同的环境中，不允许跨栈传递对象引用。</p><p id="9d98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，让我们考虑创建极光跨区域集群的片段(感谢CDK极光全球数据库插件<a class="ae kv" href="https://github.com/neilkuan/cdk-aurora-globaldatabase" rel="noopener ugc nofollow" target="_blank">这里</a>，来自Neil Kuan)。</p><p id="7787" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">原则上，您应该在辅助区域上创建从属基础结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a14e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后将其链接到主全局数据库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7236" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">变量<code class="fe nt nu nv nf b">subnetname</code>在次要区域中创建，在主要区域中使用，因此它不能在您的CDK代码中通过引用传递，因为每个堆栈都是一个独立的部署，变量不能跨区域。</p><h1 id="baa1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">SSM参数</h1><p id="dd90" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了克服这一限制，您可以在跨区域设置中使用SSM参数，我在另一篇文章中详细介绍了这种方法:</p><div class="nw nx gp gr ny nz"><a href="https://cmorgia.medium.com/cdk-and-the-sharing-of-cross-region-data-955925685e57" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">CDK与跨区域数据共享</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">如何使用CDK跨地区共享数据</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">cmorgia.medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><p id="87ad" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看一下前面的例子，您可以将子网名称存储到SSM参数中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="11c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">并在主区域中创建全局主节点时读取该值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="4501" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">次要优先</h1><p id="2ebc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如我们在主服务器优先部署的案例中所看到的，大多数资源都需要预先定义辅助区域中的对应资源，因此让我们来评估在主服务器之前部署辅助服务器的场景:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/b3d08ebbf70864de87a721c78c47beef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ya-hVBAMWBXCL547oJ93Uw.png"/></div></div></figure><p id="8e00" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个部署场景中，除了Redis部署之外，一切都正常，Redis部署首先需要全局主服务器。</p><h1 id="6f62" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">无解？</h1><p id="9e99" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于这种部署顺序，似乎没有适用的解决方案。</p><p id="0fc2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是，通过查看Redis集群创建代码，可以清楚地看到，辅助集群的创建可以分为两个部分:</p><ul class=""><li id="49ac" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">创建辅助支持基础架构，主集群需要它来定义全局基础架构</li><li id="8cca" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">创建第二个集群作为现有全局集群的一部分</li></ul><h1 id="788a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">解决方案</h1><p id="f5d6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">诀窍是将此阶段分成两个子阶段，一个在主阶段之前运行，另一个在主阶段之后运行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/88241f503b7f164fea972afad33206fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5akGZjp_pQbLmrxi5An8rg.png"/></div></div></figure><p id="eb01" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用这种方法，所有的内部依赖关系都得到满足，跨区域部署也可以进行。</p><p id="8376" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从代码的角度来看，在主服务器之前部署Redis的初始阶段如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="94d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">而在主服务器创建Redis全局集群之后，辅助服务器阶段看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2206" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里的关键属性是<code class="fe nt nu nv nf b">globalReplicationGroupId</code>，用于引用在主区域中创建的Redis全局集群，类似于它的次区域。</p><h1 id="0e03" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">经验教训</h1><p id="01e7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这场漫长的讨论中，需要记住的要点是:</p><ul class=""><li id="8b84" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">跨区域部署可能需要拆分部署单元，以满足订单依赖性</li><li id="987a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">假设实现了以跨区域方式读取SSM参数值的机制，则跨区域场景中的信息片段共享可以通过SSM参数来实现。</li></ul><p id="e9a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个解决方案的完整代码可以在<a class="ae kv" href="https://github.com/cmorgia/xregionCDK" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p></div></div>    
</body>
</html>