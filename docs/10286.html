<html>
<head>
<title>What to Do When the Index is Larger Than the SQL Table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当索引大于SQL表时该怎么办</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-to-do-when-the-index-is-larger-than-the-table-2fae2ae8ee75?source=collection_archive---------7-----------------------#2021-12-21">https://betterprogramming.pub/what-to-do-when-the-index-is-larger-than-the-table-2fae2ae8ee75?source=collection_archive---------7-----------------------#2021-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5896" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我解释一下如何处理大型索引表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7482f06450cbbf3a70bd93533d5abdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4pjQJP8acY6MGgxt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chrisliverani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="891d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用表格是开发人员的日常工作。但是SQL开发并不经常。在某些情况下，我看到了我的过去。许多开发人员创建只有一个索引的表。</p><h1 id="7a33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="ba9b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当产品用于生产时，当数据量增加时，它会变慢。每个开发人员都说“哟！创建一个索引”。</p><p id="e963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能导致索引大于表本身。</p><h1 id="64b6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">是什么导致了索引大小？</h1><p id="23f1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">增加索引大小有几个原因。</p><p id="0728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同一列中有太多索引。</p><p id="28eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，分析你的指数。删除未使用的索引。此外，减少现有列的数量。</p><blockquote class="ms mt mu"><p id="5cb5" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">请记住，聚集索引列是所有非聚集索引中的“隐藏”包含列</p></blockquote><p id="aa03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要确定索引的用法，可以使用以下查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/db22b1500c0ed9eabef9eaf9dc6ba637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycvgF2UvpYFUwz7wU6Ny4A.png"/></div></div></figure><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将显示何时以及谁将使用该索引。</p><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重叠索引</strong></p><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在<code class="fe nc nd ne nf b">a,b,c,d</code>上有一个索引，在<code class="fe nc nd ne nf b">a,b,c</code>上有一个索引，你可以考虑删除第二个索引，因为第一个索引覆盖了第二个索引。因此，请尝试将重叠的列聚合到一个索引中。</p><p id="906d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">索引碎片</strong></p><p id="1ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引可能会产生碎片，您可以使用下面的查询来了解实际索引的碎片情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您可以使用以下命令重建索引</p><p id="3290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">ALTER INDEX INDEX_NAM;E ON TABLE_NAME REBUILD</code></p><p id="8802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，将重建索引，减少碎片</p><p id="6b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">识别存储在索引文件中的内容？</strong></p><p id="d3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你必须知道，索引会存储你告诉存储的任何东西。该查询将帮助您了解哪些索引使用了最多的空间，以及使用的原因(在行数据、lob数据中)</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="b654" class="nk lw it nf b gy nl nm l nn no">SELECT  convert(char(8),object_name(i.object_id)) AS table_name, i.name AS index_name, <br/>    i.index_id, i.type_desc as index_type,<br/>    partition_id, partition_number AS pnum,  rows, <br/>    allocation_unit_id AS au_id, a.type_desc as page_type_desc, total_pages AS pages<br/>FROM sys.indexes i JOIN sys.partitions p  <br/>      ON i.object_id = p.object_id AND i.index_id = p.index_id<br/>    JOIN sys.allocation_units a<br/>      ON p.partition_id = a.container_id<br/>      order by pages desc</span></pre><h1 id="27cf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">找到最适合你的解决方案</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/f4168ae8f6f4f497a2b53ef1bb6b7278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UDJIZdaBMxWkNw7O.png"/></div></div></figure><p id="a580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在图中看到的，当您创建更多的索引时，您会消耗更多的索引空间，并且很难维护这些空间。但是索引越少，查询性能越差。很难告诉任何人哪种实践适合。所以可以说“这取决于你的数据”。当你需要一个经验法则时:</p><p id="1323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用“<strong class="lb iu"> 5和5规则</strong>”。这意味着您最多可以创建5个索引。每个表5列。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="05fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！希望您喜欢它，它可以帮助您在数据查询中获得更高的性能。</p></div></div>    
</body>
</html>