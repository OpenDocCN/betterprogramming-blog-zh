<html>
<head>
<title>How to Write Optimized Dockerfiles for Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Next.js编写优化的Dockerfiles</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-optimised-dockerfiles-for-next-js-d644b628c570?source=collection_archive---------0-----------------------#2022-11-09">https://betterprogramming.pub/write-optimised-dockerfiles-for-next-js-d644b628c570?source=collection_archive---------0-----------------------#2022-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cfd7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将下一个应用程序的Docker图像减少15倍以上。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6384ab220fcf390eabc62ff225b3bf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BrMXMskAtiLA5Cg7VtmaA.png"/></div></div></figure><p id="7d35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编写docker文件有时会很棘手。我们需要小心我们推送的文件和我们给予的权利。</p><p id="851a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建图像最具挑战性的事情之一是保持图像尺寸较小。一个写得好的docker图像占用的空间越少越好。这可以通过多种方式来确保:</p><ol class=""><li id="4164" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">我们可以决定限制推送到图像的文件。这包括过滤掉不需要的文件。</li><li id="95d8" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">生成图像时使用<a class="ae mb" href="https://docs.docker.com/build/building/multi-stage/" rel="noopener ugc nofollow" target="_blank">多级构建</a>。</li><li id="5838" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在不需要的文件用尽后删除它们。</li></ol><h1 id="0f81" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">多阶段构建简介</h1><p id="3275" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">多阶段构建是一种非常流行的缩小图像大小的方法。要编写一个真正高效的Dockerfile，您需要使用shell技巧和其他逻辑来保持层尽可能小，并确保每一层都有它需要的来自前一层的工件，而没有其他东西。</p><p id="2a68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多阶段构建使用多个可用于不同基础的<code class="fe mz na nb nc b">FROM</code>语句，每个语句都开始构建的一个新阶段。您可以有选择地将工件从一个阶段复制到另一个阶段，在最终图像中留下所有不想要的东西。从而确保最终的图像尽可能精确。</p><h1 id="cf75" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">下一个JS中的独立应用程序</h1><p id="fa70" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在我们继续编写Dockerfile文件之前，我们需要理解Next框架的一个非常强大的特性。</p><p id="cdf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理想情况下，当我们在Next中构建应用程序时，我们继续依赖node _ moudules，并依次依赖package.json。这意味着即使在最终映像中，我们也需要导入所有依赖项，以便应用程序成功运行。</p><p id="f783" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是NextJS中的<a class="ae mb" href="https://nextjs.org/docs/advanced-features/output-file-tracing" rel="noopener ugc nofollow" target="_blank">输出文件跟踪/独立</a>发挥作用的地方。Next.js可以自动创建一个<em class="nd">独立的</em>文件夹，该文件夹只复制生产部署所需的文件，包括<em class="nd"> node_modules </em>中的选择文件。</p><p id="c9ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了利用这种自动复制，您可以在next.config.js中启用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/384a8e7d0de6fe43871f730c43981c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNHLYH6rQRojd4SULrZkuQ.png"/></div></div></figure><p id="d497" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将在<code class="fe mz na nb nc b">.next/standalone</code>创建一个文件夹，然后可以在不安装<code class="fe mz na nb nc b">node_modules</code>的情况下自行部署。</p><p id="ea7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，还提供了一个最小的<code class="fe mz na nb nc b">server.js</code>文件，可以用来代替<code class="fe mz na nb nc b">next start</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/804db48c74dbcb0ae71c43c612703264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*JErntalifCNkUlGXlXakLA.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">独立文件夹结构</p></figure><p id="a3a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，这个最小服务器不会复制<code class="fe mz na nb nc b">public</code>或<code class="fe mz na nb nc b">.next/static</code>文件夹。这些文件夹可以手动复制到<em class="nd"> </em> <code class="fe mz na nb nc b">standalone/public</code>和<code class="fe mz na nb nc b">standalone/.next/static</code>文件夹，之后<code class="fe mz na nb nc b">server.js</code>文件会自动为这些服务。</p><h1 id="0dc8" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Dockerfile文件</h1><p id="932f" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">让我们一步一步地构建docker文件:</p><ol class=""><li id="f902" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">让我们创建我们的第一层— <code class="fe mz na nb nc b">dependencies</code>，在这里我们将解决所有的依赖关系并定义一个基础。您可以从可用的<a class="ae mb" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">列表</a>中选择您自己的底座。</li></ol><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="cb65" class="no md iq nc b gy np nq l nr ns">FROM node:16-alpine AS dependencies</span></pre><p id="3ece" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.让我们添加一个原生包，设置工作目录，复制<code class="fe mz na nb nc b">package.json</code>和<code class="fe mz na nb nc b">package-lock.json</code>来定义依赖关系。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="797b" class="no md iq nc b gy np nq l nr ns">RUN <em class="nd">apk</em> <em class="nd">add --no-cache</em> <em class="nd">libc6-compat<br/></em>WORKDIR <em class="nd">/home/app<br/></em>COPY <em class="nd">package.json</em> <em class="nd">./<br/></em>COPY <em class="nd">package-lock.json</em> <em class="nd">./</em></span></pre><p id="5bf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.一旦我们设置好自己，我们就可以开始安装依赖项了。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="0f6b" class="no md iq nc b gy np nq l nr ns">RUN <em class="nd">npm</em> <em class="nd">i</em></span></pre><p id="d28e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经添加完了所有的依赖项。我们的第一层准备好了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/d59a3b66adc46c2b21bd2814b3057083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLvAJZNrx-MXWMHrvuwV1w.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">属国</p></figure><p id="51df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.让我们创建我们的第二层— <code class="fe mz na nb nc b">builder</code>。这一层的目标是生成静态文件，我们将最终推动到最终的图像。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="34a0" class="no md iq nc b gy np nq l nr ns">FROM node:16-alpine AS builder</span></pre><p id="093e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.然后，我们需要将前一层的相关工件复制到<code class="fe mz na nb nc b">builder</code> <em class="nd"> </em>中，并设置当前的工作目录<em class="nd">。</em></p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="7991" class="no md iq nc b gy np nq l nr ns">WORKDIR <em class="nd">/home/app<br/></em>COPY --<em class="nd">from</em>=dependencies <em class="nd">/home/app/node_modules</em> <em class="nd">./node_modules<br/></em>COPY <em class="nd">.</em> <em class="nd">.</em></span></pre><p id="d872" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6.我们现在想要构建应用程序。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="29d6" class="no md iq nc b gy np nq l nr ns">RUN <em class="nd">npm</em> <em class="nd">run</em> <em class="nd">build</em></span></pre><p id="0a71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这标志着第二层的结束。在这一阶段，我们有静态文件，我们将推动到我们的最终形象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/96f1b405421657cc78dca98b89962775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxemAId68k5_iAJz8TSfwA.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">建设者</p></figure><p id="dd7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">7.让我们创建我们的第三个也是最后一个图层— <code class="fe mz na nb nc b">runner</code> <strong class="kt ir">。在这里，我们将推送静态文件，并尽量保持图像较小。</strong></p><p id="bac9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还设置了工作目录，并将<code class="fe mz na nb nc b">NEXT_TELEMETRY_DISABLED</code>设置为<code class="fe mz na nb nc b">true</code>。这将确保我们在Next之前选择退出匿名数据收集。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="de27" class="no md iq nc b gy np nq l nr ns">FROM mhart/alpine-node:slim-14 AS runner<br/>WORKDIR <em class="nd">/home/app<br/></em>ENV NEXT_TELEMETRY_DISABLED <em class="nd">1</em></span></pre><p id="256e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">8.然后我们把相关的人工制品放到图像中。这包括来自<code class="fe mz na nb nc b">.next/standalone</code> <em class="nd">的独立文件、</em>公共文件和<em class="nd">静态文件。</em></p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="4c7a" class="no md iq nc b gy np nq l nr ns">COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/.next/standalone</em> <em class="nd">./standalone<br/></em>COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/public</em> <em class="nd">/home/app/standalone/public<br/></em>COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/.next/static /home/app/standalone/.next/static</em></span></pre><p id="b120" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">9.最后，我们公开所需的端口，并写下启动应用程序的最终命令。</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="0293" class="no md iq nc b gy np nq l nr ns">EXPOSE <em class="nd">3000<br/></em>ENV PORT <em class="nd">3000<br/></em>CMD <em class="nd">[</em>“node”<em class="nd">,</em> “./standalone/server.js”<em class="nd">]</em></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/c383a572c0d3e8f1724490b8768529de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWqQTwd87xJ9gwNoKpC7gQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">跑步者</p></figure><p id="6f69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的docker文件看起来像这样:</p><pre class="kg kh ki kj gt nk nc nl nm aw nn bi"><span id="2920" class="no md iq nc b gy np nq l nr ns">FROM node:16-alpine AS dependencies<br/>RUN <em class="nd">apk</em> <em class="nd">add --no-cache</em> <em class="nd">libc6-compat<br/></em>WORKDIR <em class="nd">/home/app<br/></em>COPY <em class="nd">package.json</em> <em class="nd">./<br/></em>COPY <em class="nd">package-lock.json</em> <em class="nd">./<br/></em>RUN <em class="nd">npm</em> <em class="nd">i</em></span><span id="33a5" class="no md iq nc b gy nw nq l nr ns">FROM node:16-alpine AS builder<br/>WORKDIR <em class="nd">/home/app<br/></em>COPY --<em class="nd">from</em>=dependencies <em class="nd">/home/app/node_modules</em> <em class="nd">./node_modules<br/></em>COPY <em class="nd">.</em> <em class="nd">.<br/></em>ENV NEXT_TELEMETRY_DISABLED <em class="nd">1<br/></em>ARG NODE_ENV<br/>ENV NODE_ENV=”${NODE_ENV}”<br/>RUN <em class="nd">npm</em> <em class="nd">run</em> <em class="nd">build</em></span><span id="c4c7" class="no md iq nc b gy nw nq l nr ns">FROM mhart/alpine-node:slim-14 AS runner<br/>WORKDIR <em class="nd">/home/app<br/></em>ENV NEXT_TELEMETRY_DISABLED <em class="nd">1<br/></em>COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/.next/standalone</em> <em class="nd">./standalone<br/></em>COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/public</em> <em class="nd">/home/app/standalone/public<br/></em>COPY --<em class="nd">from</em>=builder <em class="nd">/home/app/.next/static</em> <em class="nd">/home/app/standalone/.next/static<br/></em>EXPOSE <em class="nd">3000<br/></em>ENV PORT <em class="nd">3000</em></span><span id="b339" class="no md iq nc b gy nw nq l nr ns">CMD <em class="nd">[</em>“node”<em class="nd">,</em> “./standalone/server.js”<em class="nd">]</em></span></pre><h1 id="7a91" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="d984" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">为Next这样的框架编写docker文件时，人们最常犯的错误是:</p><ol class=""><li id="5ab9" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">将整个构建文件推送到容器中</li><li id="4f0f" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">安装所有依赖项或将所有依赖项/ <code class="fe mz na nb nc b">node_modules</code>复制到最终映像。</li><li id="8046" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">将所有工件复制到最终层，包括源文件。</li></ol><p id="1841" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们决定把它推送到映像之前，我们需要理解每个构建文件(无论是任何框架)的相关性。</p><p id="1816" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了<code class="fe mz na nb nc b">next.config.js</code>和<code class="fe mz na nb nc b">Dockerfile</code>中的这些变化，我能够将Docker映像的大小从1.45 GB降低到仅仅81.6 MB。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/9ad9cab73042c1a3e6ef3105b2a718f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YpI8J5IUWRSyNwxf5Kkjg.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">容器的大小。然后</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/9ddc78a625db6d51b0615f89b0f78d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNFMUtJNMZMj-c4s9wUPug.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">独立集装箱的尺寸</p></figure><p id="a023" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望我能够向你展示，我们如何为像Next这样的框架编写一个优化的<code class="fe mz na nb nc b">Dockerfile</code>。</p></div></div>    
</body>
</html>