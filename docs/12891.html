<html>
<head>
<title>When Load Testing Gives a False Sense of Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当负载测试给出错误的安全感时</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-load-testing-gives-a-false-sense-of-security-76527a644e29?source=collection_archive---------9-----------------------#2022-07-08">https://betterprogramming.pub/when-load-testing-gives-a-false-sense-of-security-76527a644e29?source=collection_archive---------9-----------------------#2022-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2435" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们认为我们的应用程序可以处理大量的负载。直到我们了解了开放和封闭系统模型。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3670981f8f0c61fbac74da03c6991b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lb3_jDY9b8jv3aoR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">梅丽娜·基弗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3358" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，负载测试似乎很简单。您启动一个K6实例(或者JMeter，或者Gatling)，逐渐增加负载，然后等待应用程序崩溃。然而不幸的是，大多数性能测试并不像实际用户那样运行。</p><p id="65d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解负载发生器如何产生负载(以及<a class="ae kv" href="https://www.youtube.com/watch?v=sCr2mzBlvfI" rel="noopener ugc nofollow" target="_blank">鳄鱼</a>)，了解封闭和开放系统模型的概念是很重要的。</p><h2 id="d9bb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">封闭系统模型</h2><p id="c453" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">根据Schroeder等人的观点，在一个封闭的系统模型中，“假设有一些固定数量的用户，他们永远使用这个系统。”这可能适用于由固定数量的员工使用的非常具体的业务应用程序。然而，大多数应用程序都有一组不太确定的用户。</p><p id="3f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由已关闭的工作负载生成器启动的虚拟用户只会在第一个请求完成后发出第二个请求。如果所有虚拟用户都在等待请求完成，就不会产生额外的负载。测试变慢是因为系统跟不上。</p><p id="5267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的负载测试应该是坚持不懈的。当系统变慢时，我不能后退。就像当应用程序运行缓慢时，实际用户不会停止点击时事通讯的链接一样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/9aa1ba462e8e0606cde3a015856b9339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-gkGataeFcfMOxDc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个封闭系统模型的类比:当交通过于拥挤时，固定数量的十字转门会降低交通速度。保罗·席尔瓦在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><h2 id="1cfc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">开放系统模型</h2><p id="e1e6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在开放系统模型中，新用户将以给定的速率到达。每个用户向系统发出一个请求，等待响应，然后离开。对于大多数应用程序来说，开放系统模型和封闭系统模型一样不现实。</p><p id="b9d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，它有一个优点:如果一个工作负载生成器每秒发出100个请求，而系统设法在不到一秒的时间内响应其中的99个请求，那么接下来的100个请求将被启动，而队列中还有一个请求。一秒钟后，系统落后两个请求。然后3。然后4。</p><blockquote class="mr ms mt"><p id="f48e" class="kw kx mu ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">"对于给定的负载，封闭系统中的平均响应时间明显低于开放系统."—施罗德等人。</p></blockquote><p id="fa94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们设法创建了一个向下的螺旋，这个螺旋的负载对于被测试的系统来说稍微有点高。</p><h2 id="1f95" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">部分开放系统模型</h2><p id="b462" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了获得两个世界的最佳效果，Schroeder等人引入了一个部分开放的模型。在开放模型中，用户以固定的速率到达，但是每个用户执行的请求数量由给定的概率决定。</p><p id="e20e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当每个虚拟用户只发出几个请求时(根据经验法则≤ 5)，部分开放系统的行为类似于开放系统。当每个用户的请求数量很大时(经验法则是≥ 10)，它的行为类似于一个封闭系统。</p><blockquote class="mr ms mt"><p id="eac1" class="kw kx mu ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">“随着(虚拟用户数量)的增长，封闭的系统变得开放。”—施罗德等人。</p></blockquote><p id="4b61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数时候，你希望使用部分开放的模型，因为它最能模拟真实用户(在大多数网站上)。不过，选择用户发出另一个请求的概率有点像猜谜游戏。</p><h2 id="c5af" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">行程安排</h2><p id="5660" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">调度对负载的大小有很大的影响；尤其是当被测系统必须处理大的和小的请求时。因为我们的应用程序只需要处理小的请求，所以我们采用了先进先出(FIFO)的调度。如果你想下兔子洞，一定要看施罗德等人的<a class="ae kv" href="https://www.usenix.org/legacy/event/nsdi06/tech/full_papers/schroeder/schroeder.pdf" rel="noopener ugc nofollow" target="_blank">论文。</a></p><h2 id="9f49" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><ul class=""><li id="5545" class="my mz iq ky b kz ml lc mm lf na lj nb ln nc lr nd ne nf ng bi translated">封闭的系统模型对你撒谎:它们创建的负载并不代表你的用户。您的系统可能无法处理由开放模型创建的相同负载。</li><li id="2ec1" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">在大多数情况下，部分开放的系统模型最能代表实际用户。</li></ul><h2 id="7ae4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">履行</h2><p id="11e4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当一位客户预约了与<a class="ae kv" href="https://www.stormforge.io/" rel="noopener ugc nofollow" target="_blank"> StormForge </a>的会议时，我被介绍了开放和封闭系统模型。他们的产品默认支持半开放模式，并提供了强大的支持。如果你想使用开源软件，可以看看<a class="ae kv" href="https://k6.io/docs/using-k6/scenarios/arrival-rate/" rel="noopener ugc nofollow" target="_blank"> K6关于到达率</a>的博客文章。似乎还有一种用JMeter实现开放模型的方法，但是我不推荐它(因为我在这个主题上找到的资源很少)。</p><h2 id="d68c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">参考</h2><ul class=""><li id="0d8b" class="my mz iq ky b kz ml lc mm lf na lj nb ln nc lr nd ne nf ng bi translated">Sebastian Cohnen: <a class="ae kv" href="https://www.stormforge.io/blog/open-closed-workloads/" rel="noopener ugc nofollow" target="_blank">为性能测试选择开放或封闭的工作负载模型</a>——感谢Sebastian和StormForge团队教会我开放和封闭模型。</li><li id="c8c2" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">施罗德等人:<a class="ae kv" href="https://www.usenix.org/legacy/event/nsdi06/tech/full_papers/schroeder/schroeder.pdf" rel="noopener ugc nofollow" target="_blank">开放与封闭:一个警示故事</a>——一个关于开放和封闭模型的学术观点。👩‍🏫</li><li id="a1d6" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated"><a class="ae kv" href="https://k6.io/docs/using-k6/scenarios/arrival-rate/" rel="noopener ugc nofollow" target="_blank">在K6中实现开放模式</a>🏔</li></ul></div></div>    
</body>
</html>