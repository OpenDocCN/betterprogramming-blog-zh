<html>
<head>
<title>Dealing With Data and Communication in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中处理数据和通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dealing-with-data-and-communication-in-kubernetes-4b1c940719af?source=collection_archive---------7-----------------------#2021-02-11">https://betterprogramming.pub/dealing-with-data-and-communication-in-kubernetes-4b1c940719af?source=collection_archive---------7-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cde7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从使用minikube进行本地开发环境设置到启动自己的博客应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4893061b90db842d59190a82defbcfc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtGsW3VDL9f3DgQh6nDlKg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="76ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不久前，我在Udemy上做了一个名为“<a class="ae lr" href="https://www.udemy.com/course/microservices-software-architecture-patterns-and-techniques/" rel="noopener ugc nofollow" target="_blank">微服务软件架构:模式和技术</a>”的在线课程。在本课程中，讲师详细描述了微服务架构带来的主要挑战以及可能的解决方案。在学习有关服务注册、服务发现、故障转移机制和健康API的课程时，我想，“感谢上帝，我们有Kubernetes，它为我们提供了大部分现成的解决方案，这样我们就可以专注于实现我们的业务逻辑了。”</p><p id="a222" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管您从Kubernetes获得了很多，但微服务架构的某些方面需要您亲自解决。其中最重要的是数据和通信，它解决了以下问题:</p><p id="aaaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你如何存储你的数据？</p><p id="f3a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务如何交换这些数据？</p><p id="eab8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将向您展示如何使用minikube建立本地Kubernetes集群。通过实现一个非常基本的例子，我将描述如何在微服务架构中处理数据和通信。</p><p id="df87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例应用程序本身非常简单:一个博客应用程序，允许您创建和查看文章，并查看文章页面上显示的印象计数器。博客逻辑将被实现为一个Ruby on Rails应用程序，它将文章存储在MySQL数据库中——而impressions逻辑将由一个用Elixir编写的独立应用程序处理，该应用程序使用Redis作为Impressions计数器的键值存储。我们将使用Kafka来更新印象计数器。</p><p id="8e00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将带您一步一步地完成设置:从第一次在您的本地机器上启动minikube到从您的浏览器访问blog应用程序并看到计数器增加。</p><h2 id="e6f5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">我们将详细做些什么</h2><ol class=""><li id="1bfd" class="ml mm iq kx b ky mn lb mo le mp li mq lm mr lq ms mt mu mv bi translated">设置迷你库</li><li id="f4bf" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">部署MySQL</li><li id="9ef0" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">部署Redis</li><li id="9ce0" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">部署卡夫卡</li><li id="5dff" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">部署Impressions API</li><li id="6579" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">部署博客应用程序</li></ol><p id="e6f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每一步之后，我将提供一个小测试，您可以运行它来确保一切都为您工作。</p><p id="d25f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MySQL、Redis和Kafka将使用Helm部署，Helm是Kubernetes应用程序的包管理器。基本上，它将允许我们用一个简单的命令来安装这些服务器。</p><p id="58d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于Impressions API和Blog应用程序，我将提供所需的所有Kubernetes配置文件。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="2d34" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">我们需要卡夫卡做什么？</h1><p id="bbcf" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们的架构由几部分组成:一个MySQL服务器存储博客的文章，一个Redis数据库管理印象计数器。但是为什么我们也需要卡夫卡呢？</p><h2 id="ff93" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">每个服务规则一个数据库</h2><p id="af15" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">要理解我们为什么需要Kafka，我们先说一下微服务中的数据。</p><p id="aae9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，在monolith应用程序中，您有一个可以从代码的每个部分访问的数据库。这非常简单快捷。</p><p id="65cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，当您有多个应用程序时，如何存储您的数据呢？</p><p id="69e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您有一个电子商务平台，其中一个服务负责用户资料，另一个服务负责发送电子邮件推荐。用户资料服务负责所有用户数据(包括姓名和电子邮件)，而推荐服务只是将产品与用户id相关联，并使用它们向用户发送推荐电子邮件。推荐服务需要访问用户数据，比如姓名和电子邮件。</p><p id="9e17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于推荐需要读取用户简档数据，最简单的解决方案可能是共享相同的数据库凭证，并让推荐服务直接从数据库中查询用户简档。这个解决方案看起来简单快捷，但是问题会很快出现。</p><p id="8294" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应用程序会根据新的需求不断变化，而这些变化通常也要求数据库模式发生变化。如果许多应用程序直接访问同一个数据库，那么很难在确保没有其他应用程序中断的情况下进行这些更改。在我们的示例中，想想如果我们需要将“name”字段更改为“firstname”和“lastname”会发生什么。更改模式后，推荐应用程序会崩溃，因为它试图访问数据库中不再存在的“name”字段。</p><p id="16b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么在微服务架构中使用“共享数据库”是一种已知的反模式。</p><p id="a809" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">规则是每个服务一个数据库</strong>。</p><p id="789c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，每个应用程序都有自己的数据库，只能由自己直接访问。如果其他服务需要属于该应用程序的一些信息，它们需要请求。在我们之前的例子中，推荐服务会询问用户简档服务——“你能给我用户123的名字和电子邮件吗？”—用户服务将返回请求的数据。</p><p id="3b78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将数据库和数据之间的应用程序公开给外部，使我们能够实现适当的弃用过程。例如，当用户简档服务将单个字段“姓名”更改为“名字”和“姓氏”时，它可以继续将“姓名”字段作为“名字”和“姓氏”的串联返回给推荐服务同时，它可以通知所有其他应用程序切换到新的字段。一旦它从接收到的请求中知道不再使用不赞成使用的字段，旧的“name”字段映射可以被移除。</p><h2 id="82c6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">服务之间的通信</h2><p id="8774" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们现在知道，每个服务都有自己的数据库，访问这些数据的唯一方式是通过拥有它的服务。因此，服务之间需要进行大量的通信，以获取和提供在monolith应用程序中可以直接访问的数据。由于每个服务只能直接访问它所负责的应用程序数据的一部分，因此它需要不断地将这些数据与来自其他服务的数据集成在一起。</p><p id="4464" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，有两种类型的通信:同步和异步。</p><p id="2b59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">同步通信</strong>，或者说请求-响应，发生在一个服务正在执行一个动作，并且需要立即从另一个服务获得信息的时候。例如，您有一个库存服务，允许您了解产品的当前可用性，还有一个服务充当电子商务前端。当前端服务接收到呈现特定产品页面的请求时，对库存服务进行同步调用，例如REST调用。这个调用返回特定产品的当前状态，然后呈现给最终用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/50c203cdfa4fe1f4fee20e0fbc33e349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Trn7f_HyVIcRAj7cxFRKFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用REST API的同步通信</p></figure><p id="ed97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在其他情况下，这种类型的交流不是很有用。假设您有一个搜索服务，它负责索引您的所有产品，以便用户可以随时找到可用的产品。该服务希望隐藏缺货的产品，这样用户就不会迷失在他们买不到的产品中。使用同步通信来检查产品可用性意味着搜索服务需要频繁地向库存服务发出请求——这样它就可以删除缺货的产品。当然，这并不理想。</p><p id="9dc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们不想不断地询问是否发生了变化。我们希望数据的所有者(服务)在发生变化时通知其他应用程序，以便任何感兴趣的人都可以对变化做出反应。在这种情况下，我们谈到异步通信，或发布-订阅，其中当他们的应用程序上的某些内容发生变化时，数据所有者发布一条消息，这可能会引起其他应用程序的兴趣。</p><p id="bf18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，正在购买的产品(→库存更新→可能状态更新)。然后，其他应用程序可以使用这些消息并执行它们的任务。再举一个例子，搜索服务可以读取关于正在购买的产品的消息，并决定通过从所有必要的服务获取更新的信息来重新索引该产品。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/553d055300d5bae91baf1efea5cfab66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHpWcPUbRcQRGjJ4J5zZXQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kafka的异步通信</p></figure><p id="31ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">异步通信可以使用不同的技术实现，但最常用的是AMQP和卡夫卡。在这个例子中，我们将使用卡夫卡。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="fcf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总而言之，我们说过每个应用程序都有自己的数据库，这些数据只能通过应用程序来访问。由于这些数据的一部分是其他服务需要的，甚至是更新的，我们需要实现服务之间的通信，特别是两种类型的通信:用于同步通信的REST API端点和用于异步通信的Kafka Publisher和Consumers。</p><p id="1e8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在将一步一步地看如何添加所需的块，直到我们有一个工作的微服务架构来运行我们的博客应用程序。我们将能够从浏览器访问这个应用程序，这样我们就可以看到文章的印象计数器随着每次刷新而增加。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="3721" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">示例应用程序</h1><p id="07ce" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">现在，让我们来看看示例应用程序。如前所述，这个示例应用程序将是一个简单的博客应用程序，允许您创建和查看文章，并看到每篇文章的浏览量增加。博客逻辑和印象计数逻辑将在两个不同的服务上实现，这允许您处理两种通信类型:同步和异步。</p><p id="9719" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同步通信将需要在博客应用程序上显示一篇文章的页面浏览量。这将通过REST API调用调用impressions服务来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e1de768812c85c6262944984815bc0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pEXHr2eGG0gwz4so72qPA.png"/></div></div></figure><p id="bd61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要异步通信来通知impressions服务页面已被查看。换句话说，当博客应用程序收到一个呈现文章的请求时，它会发布一个关于Kafka主题的新消息<code class="fe ny nz oa ob b">blog.articles.viewed</code>。这将指定文章的<code class="fe ny nz oa ob b">id</code>的有效负载，更准确地说，是urn(统一资源名——我们的应用程序中的一个全局唯一标识符)。订阅该队列的impressions服务将使用该消息，读取有效负载中的urn，并递增相关的计数器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/57983ce149b92950ecb1ae97825478f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YoMPRnq_b-3-xWVICOZDQ.png"/></div></div></figure><p id="f6d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我将一步一步地向您介绍这个示例。我不会详细介绍实际应用的实现，因为这会让这篇文章更长，但是我会在这个GitHub <a class="ae lr" href="https://github.com/domangi/blog-impressions-k8" rel="noopener ugc nofollow" target="_blank"> repo </a>中提供所有使用的代码。这个repo还将拥有用于启动这两个应用程序的Kubernetes配置文件。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="07b0" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">第一步。设置Minikube</h1><p id="6750" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">minikube是当地的Kubernetess它致力于使Kubernetes易于学习和开发。</p><p id="d613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要做的第一件事是按照<a class="ae lr" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">官方指南</a>在我们的本地机器上安装minikube。</p><p id="0bbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您运行的是macOS(否则请查看指南)，安装minikube应该像通过brew安装一样简单。使用以下命令:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="86fc" class="ls lt iq ob b gy oh oi l oj ok">$ brew install minikube</span></pre><p id="3465" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装minikube后，我们可以启动我们的第一个本地Kubernetes集群，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="1d75" class="ls lt iq ob b gy oh oi l oj ok">$ minikube start</span></pre><h2 id="f2a4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试Minikube设置</h2><p id="145b" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">正如开始时所承诺的，对于每一步，我们都将进行测试，以确保一切都按预期运行。为了测试minikube的工作情况，让我们创建一个临时测试容器，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="e8c0" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl run -it --rm --restart=Never test-pod --image=alpine sh</span></pre><p id="a946" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一切正常，我们应该能看到新的外壳。命令中的<code class="fe ny nz oa ob b">--rm</code>选项确保当我们离开pod时，pod被删除，这可以通过在shell中键入<code class="fe ny nz oa ob b">exit</code>来实现。</p><h2 id="ca44" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">Minikube仪表板</h2><p id="e8ad" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">测试一切正常的另一种方法是启动Kubernetes仪表板，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="54b1" class="ls lt iq ob b gy oh oi l oj ok">$ minikube dashboard</span></pre><p id="1283" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该命令将在您的默认浏览器中打开仪表板，从中您可以查看和管理您的Kubernetes集群。这是仪表板的图像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/62a4ff7783f2bd7042bb7ff3616b5008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAFQIqae1NGXYZJWCkY-TQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kubernetes仪表板</p></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="1c14" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">第二步。部署MySQL</h1><p id="5c84" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">可以想象，我不是第一个尝试在Kubernetes上部署MySQL服务器的人。就像你会在RubyGems上寻找一个Ruby库来解决你的RubyOnRails应用程序中的一个常见问题一样，你也可以在<a class="ae lr" href="https://artifacthub.io/" rel="noopener ugc nofollow" target="_blank">https://artifacthub.io/</a>上寻找提供你正在寻找的Kubernetes应用程序的导航图。事实上，<a class="ae lr" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>是Kubernetes的包经理。</p><p id="11b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，在我们可以使用头盔之前，我们需要安装它。在macOS上，您可以使用brew:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="e3bb" class="ls lt iq ob b gy oh oi l oj ok">$ brew install helm</span></pre><p id="2de2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果这不是你的选择，请查看<a class="ae lr" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">官方指南</a>了解更多详情。</p><p id="5246" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经安装了Helm，让我们使用它来安装MySQL，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="8a75" class="ls lt iq ob b gy oh oi l oj ok">$ helm repo add t3n https://storage.googleapis.com/t3n-helm-charts<!-- --> </span><span id="f8bf" class="ls lt iq ob b gy om oi l oj ok">$ helm install mysql t3n/mysql --version 1.0.0</span></pre><p id="8e89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在<a class="ae lr" href="https://artifacthub.io/packages/helm/t3n/mysql" rel="noopener ugc nofollow" target="_blank">图表页面</a>上找到关于配置选项的更多详细信息。</p><p id="fffd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成这一步后，将部署一个MySQL服务器，可以使用主机名<code class="fe ny nz oa ob b">mysql</code>从集群访问该服务器。如果你想把它叫做<code class="fe ny nz oa ob b">mysql-service</code>，你必须运行<code class="fe ny nz oa ob b">helm install mysql-service t3n/mysql --version 1.0.0</code>，然后你可以访问你在主机<code class="fe ny nz oa ob b">mysql-service</code>的MySQL服务器。</p><h2 id="1b3d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试MySQL服务器</h2><p id="779d" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">为了测试它是否工作，我们首先需要获得数据库根密码，然后我们将创建一个运行Ubuntu的虚拟pod，安装一个MySQL客户端，并访问MySQL数据库。</p><p id="3c4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用minikube仪表板获得<code class="fe ny nz oa ob b">mysql_root_password</code>(在“secrets”下，找到MySQL条目，然后单击mysql-root-password旁边的眼睛。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9ccc62d3b2195220ec3c20662a34bc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*858yiNFjL02CjzasudIQWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自Minikube Dashboard的MySQL密码</p></figure><p id="0cba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，我们可以使用以下命令从命令行获取密码:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="ae16" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl get secret --namespace default mysql -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo</span><span id="dc53" class="ls lt iq ob b gy om oi l oj ok"># YOURPASSWORDHERE</span></pre><p id="8158" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了密码，让我们启动一个新的运行Ubuntu的临时pod，安装mysql-client，并使用主机名<code class="fe ny nz oa ob b">mysql</code>访问我们的mysql服务——这个名称是我们之前给MySQL安装起的。以下是命令:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="18fb" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl run -it --rm --restart=Never test-pod --image=ubuntu:16.04 sh<br/># apt-get update &amp;&amp; apt-get install mysql-client -y<br/>...<br/>...<br/>... INSTALLING STUFF<br/>...<br/>...</span><span id="8e7a" class="ls lt iq ob b gy om oi l oj ok"># mysql -h mysql -p<br/>Enter password:</span><span id="90bd" class="ls lt iq ob b gy om oi l oj ok">Welcome to the MySQL monitor.  Commands end with ; or \g.<br/>Your MySQL connection id is 22059<br/>Server version: 5.7.32 MySQL Community Server (GPL)</span><span id="93ab" class="ls lt iq ob b gy om oi l oj ok">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><span id="48b0" class="ls lt iq ob b gy om oi l oj ok">Oracle is a registered trademark of Oracle Corporation and/or its<br/>affiliates. Other names may be trademarks of their respective<br/>owners.</span><span id="ff60" class="ls lt iq ob b gy om oi l oj ok">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><span id="6749" class="ls lt iq ob b gy om oi l oj ok">mysql&gt;</span></pre><p id="141e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了。我们测试了MySQL服务器正在运行，并且我们可以使用<code class="fe ny nz oa ob b">mysql</code>作为主机名从不同的pod访问它。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="e39c" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">第三步。部署Redis</h1><p id="3a3c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">与MySQL一样，Redis也可以使用Helm部署。这一次，我们向安装程序传递一个设置，这样就可以不用密码访问Redis。使用以下命令:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="d750" class="ls lt iq ob b gy oh oi l oj ok">$ helm repo add bitnami <a class="ae lr" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank">https://charts.bitnami.com/bitnami</a></span><span id="d435" class="ls lt iq ob b gy om oi l oj ok">$ helm install redis bitnami/redis --set usePassword=false</span></pre><p id="e14d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查看<a class="ae lr" href="https://artifacthub.io/packages/helm/bitnami/redis" rel="noopener ugc nofollow" target="_blank">图表安装页面</a>了解更多详情。</p><h2 id="bda0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试Redis服务器</h2><p id="5426" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">和以前一样，我们希望确保Redis服务器正在运行，并且可以使用主机名<code class="fe ny nz oa ob b">redis-mater</code>从另一个pod访问它。</p><p id="4149" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以再次使用运行Ubuntu的临时pod，安装<code class="fe ny nz oa ob b">redis-tools</code>，并尝试使用以下命令访问我们的Redis服务器:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="95a1" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl run -it --rm --restart=Never test-pod --image=ubuntu:16.04 sh<br/>root@ubuntu:/# apt-get update &amp;&amp; apt-get install <!-- -->redis-tools<!-- --> -y<br/>root@ubuntu:/# redis-cli -h redis-master<br/>redis-master:6379&gt; PING<br/>PONG</span></pre><p id="ddce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成了。我们确保我们的Redis服务器正在运行，并且可以从主机名<code class="fe ny nz oa ob b">redis-master</code>的其他pod访问它。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="42ae" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">第四步。添加Kafka服务</h1><p id="4093" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们想要部署的最后一个基础架构模块是Kafka。幸运的是，我们可以使用Helm(手动部署Kafka可能是一个令人头疼的问题，:D)。以下是命令:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="b2b4" class="ls lt iq ob b gy oh oi l oj ok">$ <!-- -->helm repo add bitnami <a class="ae lr" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank">https://charts.bitnami.com/bitnami</a></span><span id="21ae" class="ls lt iq ob b gy om oi l oj ok">$ helm install kafka --set replicaCount=1 bitnami/kafka</span></pre><p id="0564" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我手动将<code class="fe ny nz oa ob b">replicationCount</code>设置为<code class="fe ny nz oa ob b">1</code>，因为我的本地机器有点问题，而且由于我在本教程中并不关心Kafka复制，所以我只是将其设置为<code class="fe ny nz oa ob b">1</code>。</p><p id="460a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae lr" href="https://artifacthub.io/packages/helm/bitnami/kafka" rel="noopener ugc nofollow" target="_blank">舵图表页面</a>上找到所有可能安装选项的更多细节。</p><h2 id="f29a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试Kafka部署</h2><p id="4e04" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">为了测试我们的Kafka部署是否按预期工作，我们将使用Kafka (bootstrap)服务器和主机<code class="fe ny nz oa ob b">kafka</code>来验证发布到主题的消息是否被正确使用。</p><p id="0ffb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们创建一个pod，我们可以在其上运行Kafka-consumer或Kafka-producer。为此，我们将使用以下命令:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="b097" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl run kafka-client --restart='Never' --image docker.io/bitnami/kafka:2.7.0-debian-10-r35 --namespace default --command -- sleep infinity</span></pre><p id="059b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以在这个pod上打开一个shell，并使用以下命令启动一个主题为<code class="fe ny nz oa ob b">test-topic</code>的消费者:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="f21b" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl exec -it kafka-client bash<br/># kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic test-topic --from-beginning</span></pre><p id="e1c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们打开pod上的另一个shell，并使用它通过以下命令生成新的<code class="fe ny nz oa ob b">test-topic</code>:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="fd80" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl exec -it kafka-client bash<br/># kafka-console-producer.sh --bootstrap-server kafka:9092 --topic test-topic<br/>&gt; This is my first message</span></pre><p id="67d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您按下enter键时，您应该会看到消费者shell上出现以下消息:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="aa28" class="ls lt iq ob b gy oh oi l oj ok"># kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic test-topic --from-beginning<br/>This is my first message</span></pre><p id="a3e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了。我们已经完成了基础设施的设置。我们有一个可以在主机<code class="fe ny nz oa ob b">mysql</code>访问的MySQL服务器，一个可以在主机<code class="fe ny nz oa ob b">redis-master</code>访问的Redis服务器，以及一个可以在<code class="fe ny nz oa ob b">kafka:9092</code>访问的Kaka Broker。</p><p id="cd54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是时候添加我们自己的应用程序了。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="bdef" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">第五步。添加印象服务</h1><p id="0111" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">impressions服务是一个Elixir应用程序，它做两件简单的事情:</p><ol class=""><li id="d220" class="ml mm iq kx b ky kz lb lc le oo li op lm oq lq ms mt mu mv bi translated">它使用Kafka主题<code class="fe ny nz oa ob b">blog.article.viewed</code>,并使用Kafka消息有效负载中指定的密钥递增Redis计数器</li><li id="e78f" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">它公开了一个REST端点来获取特定键的当前计数</li></ol><p id="f777" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要太深入应用程序的实现细节(你可以在<a class="ae lr" href="https://github.com/domangi/blog-impressions-k8/tree/main/impressions" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看)，这里唯一要注意的是应用程序需要与Kafka和Redis交互。应用程序假设完整的Kafka URL在名为<code class="fe ny nz oa ob b">KAFKA_URL</code>的环境变量中定义，Redis主机和端口在<code class="fe ny nz oa ob b">REDIS_HOST</code>和<code class="fe ny nz oa ob b">REDIS_PORT</code>中定义。该应用程序的docker映像在Docker Hub上以<code class="fe ny nz oa ob b">domangi/impressions:v11</code>的名称公开发布。</p><p id="8edc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们定义运行服务所需的所有Kubernetes配置，它们是:</p><ul class=""><li id="eed7" class="ml mm iq kx b ky kz lb lc le oo li op lm oq lq or mt mu mv bi translated">定义环境变量的配置图</li><li id="6212" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated">描述我们期望状态的部署，包括运行哪个docker映像和使用多少副本</li><li id="af33" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated">使用特定主机名从集群访问应用程序的服务</li></ul><h2 id="52d4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">印象配置图</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="a831" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个configmap被命名为<code class="fe ny nz oa ob b">impressions-configmap</code>，并将在impressions部署中用于访问三个所需的环境变量。</p><h2 id="ce19" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">印象部署</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="5b4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将运行我们的印象服务器。<code class="fe ny nz oa ob b">domangi/impressions</code>是服务器的docker镜像。使用<code class="fe ny nz oa ob b">envFrom -&gt; configMapRef</code>,我们告诉部署在它创建的所有pod中使用<code class="fe ny nz oa ob b">impressions-configmap</code>中定义的环境变量。</p><h2 id="829c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">印象服务</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="a196" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一步是定义一个服务，允许集群中的其他pod“作为服务”访问应用程序。使用Kubernetes，您不需要修改应用程序来使用不熟悉的服务发现机制。Kubernetes为一组pod提供它们自己的IP地址和一个DNS名称，并可以在它们之间进行负载平衡。在这种情况下，端口80处的<code class="fe ny nz oa ob b">impressions-service</code>将允许您访问端口4000处的<code class="fe ny nz oa ob b">impressions pods</code>之一。</p><p id="b349" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以应用这些配置文件并测试我们的impressions部署，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="ca96" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl apply -f impressions-configmap.yml<br/>$ kubectl apply -f impressions-deployment.yml<br/>$ kubectl apply -f impressions-service.yml</span></pre><p id="bc56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在继续测试之前，从Kubernetes仪表板或使用命令行<code class="fe ny nz oa ob b">kubectl get deployment impressions-deployment</code>检查所有副本是否正在运行。</p><h2 id="38c1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试印象服务</h2><p id="f7ff" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">为了测试impressions服务，我们将启动一个pod并使用<code class="fe ny nz oa ob b">curl</code>与impressions REST API进行交互。然后，我们将使用Kafka客户端在<code class="fe ny nz oa ob b">blog.article.viewed</code>上发布一条新消息，并验证从REST API返回的计数器是否更新如下:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="edcf" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl run -it --rm --restart=Never test-pod --image=ubuntu:16.04 sh</span><span id="4b9b" class="ls lt iq ob b gy om oi l oj ok"># apt-get update &amp;&amp; apt-get install curl -y<br/>...<br/>... installing stuff<br/>...</span><span id="41a7" class="ls lt iq ob b gy om oi l oj ok"># curl impressions-service/impressions/blog:article:123<br/>{"urn":"blog:article:123","count":0}</span></pre><p id="ece9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来REST API可以在<code class="fe ny nz oa ob b">impressions-service</code>访问。现在让我们打开我们的<code class="fe ny nz oa ob b">kafka-client pod</code>，用一个<code class="fe ny nz oa ob b">kafka-console-producer</code>来模拟一个带有urn <code class="fe ny nz oa ob b">blog:article:123</code>的页面视图。</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="8940" class="ls lt iq ob b gy oh oi l oj ok">### see kafka deployment step if you don't have a kafka-client pod<br/>$ kubectl exec -it kafka-client bash<br/># kafka-console-producer.sh --bootstrap-server kafka:9092 --topic blog.article.viewed<br/>&gt; blog:article:123</span></pre><p id="0e0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们再次调用urn <code class="fe ny nz oa ob b">blog:article:123</code>的REST端点，我们应该看到计数器已经增加了:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="a69c" class="ls lt iq ob b gy oh oi l oj ok">#  curl impressions-service/impressions/blog:article:123<br/>{"urn":"blog:article:123","count":1}</span></pre><p id="e1dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没错。我们已经确保我们的impressions应用程序使用主题为<code class="fe ny nz oa ob b">blog.article.viewed</code>的消息，并且它递增与发布的Kafka消息中包含的urn相关联的计数器——该消息由rest端点返回。</p><h1 id="7013" class="ni lt iq bd lu nj ou nl lx nm ov no ma jw ow jx md jz ox ka mg kc oy kd mj ns bi translated">第六步。添加博客Webapp</h1><p id="cc1e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">部署实现以下博客逻辑的web应用程序的最后一步:创建和查看文章，并通过impressions服务跟踪不断增长的文章浏览量。这次我们将使用MySQL作为数据库，因此除了<code class="fe ny nz oa ob b">KAFKA_URL</code>之外，我们还需要所有的数据库环境变量，如<code class="fe ny nz oa ob b">DATABASE_NAME</code>、<code class="fe ny nz oa ob b">DATABASE_HOST</code>、<code class="fe ny nz oa ob b">DATABASE_PORT</code>、<code class="fe ny nz oa ob b">DATABASE_USERNAME</code>和<code class="fe ny nz oa ob b">DATABASE_PASSWORD</code>。由于我们将使用impressions-service REST API来获取文章印象数以呈现在页面上，我们还需要定义<code class="fe ny nz oa ob b">IMPRESSIONS_SERVICE_URL</code>。</p><p id="0f45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ny nz oa ob b">DATABASE_PASSWORD</code>将从我们通过Helm添加MySQL服务器时创建的MySQL secret定义中直接访问。所有其他环境变量都将在配置图中定义。</p><p id="6f16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应用程序的docker映像在Docker Hub上以<code class="fe ny nz oa ob b">domangi/blog:v5</code>的名称公开发布。</p><p id="9960" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像以前一样，我们将创建一个configMap，它将被用作部署和服务。</p><h2 id="b9d1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">博客配置图</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b15a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个configmap被命名为<code class="fe ny nz oa ob b">blog-configmap</code>，将在blog部署中用于访问数据库环境变量，以及访问Kafka和Impressions Rest API所需的变量。</p><h2 id="cf7d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">博客部署</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="1084" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们定义了我们想要的运行实例的数量，两个副本，它们将使用在<code class="fe ny nz oa ob b">blog-configmap</code>中定义的所有环境变量来运行映像<code class="fe ny nz oa ob b">domangi/blog</code>。然后我们将添加一个新的<code class="fe ny nz oa ob b">DATABASE_PASSWORD</code> env变量，它的值必须取自名为<code class="fe ny nz oa ob b">mysql</code>的<code class="fe ny nz oa ob b">secret</code>配置文件，特别是，将使用与键<code class="fe ny nz oa ob b">mysql-root-password</code>相关联的值。</p><h2 id="ce1d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">博客服务</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="f972" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和以前一样，我们为我们的部署定义了一个类似DNS的服务。在本例中，我们指定了<code class="fe ny nz oa ob b">type: LoadBalancer</code>，因为我们想要分配一个<code class="fe ny nz oa ob b">external-ip</code>地址，这样我们就可以从Kubernetes集群外部访问它。</p><p id="0757" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以应用这些配置文件并测试我们的博客部署，如下所示:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="f798" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl apply -f blog-configmap.yml<br/>$ kubectl apply -f blog-deployment.yml<br/>$ kubectl apply -f blog-service.yml</span></pre><p id="7798" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您检查<code class="fe ny nz oa ob b">blog-service</code>的状态，您会发现<code class="fe ny nz oa ob b">external-ip</code>访问从未被分配:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="a50d" class="ls lt iq ob b gy oh oi l oj ok">NAME           TYPE           CLUSTER-IP      EXTERNAL-IP<br/>blog-service   LoadBalancer   10.96.53.11     &lt;pending&gt;</span></pre><p id="9513" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了分配<code class="fe ny nz oa ob b">external-ip</code>,我们需要在一个新的终端中运行<code class="fe ny nz oa ob b">minikube tunnel</code>。更多细节参见<a class="ae lr" href="https://minikube.sigs.k8s.io/docs/commands/tunnel/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="afd8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">测试博客服务器</h2><p id="8e3e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">在这种情况下，测试将包括使用浏览器中的应用程序并检查计数器是否增加。您可以从Kubernetes dashboard(在services部分)或使用如下命令行来获取公共ip地址:</p><pre class="kg kh ki kj gt od ob oe of aw og bi"><span id="79de" class="ls lt iq ob b gy oh oi l oj ok">$ kubectl get service blog-service<br/>NAME           TYPE           CLUSTER-IP    EXTERNAL-IP<br/>blog-service   LoadBalancer   10.96.53.11   10.96.53.11</span><span id="625e" class="ls lt iq ob b gy om oi l oj ok">$ open http://10.96.53.11</span></pre><p id="0607" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将打开您的浏览器，并向您显示博客应用程序，您可以在其中创建新文章并查看它们。如果一切正常，您应该会看到一个不断增加的印象计数器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/729182947354cae7b712660ecfd947a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1z3fk4tJNNF5NFVMhb6NA.png"/></div></div></figure><p id="9fcf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有效:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/0d19165ec1b8d443febb67e3bef086b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mufa34iGP8R6KcH9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基思·卢克在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="777a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回顾一下我们所做的。在本文中，我们做了以下工作:</p><ol class=""><li id="110e" class="ml mm iq kx b ky kz lb lc le oo li op lm oq lq ms mt mu mv bi translated">如何为当地的Kubernetes开发建立minikube</li><li id="cf09" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">如何使用Helm在Kubernetes上安装常见的应用程序，如MySQL、Redis和Kafka</li><li id="a6ba" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">如何在Kubernetes上运行自己的docker映像，定义配置映射、部署和服务</li><li id="389e" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">如何通过使用类型为<code class="fe ny nz oa ob b">LoadBalancer</code>的服务从浏览器访问您的应用程序，以及如何运行<code class="fe ny nz oa ob b">minikube tunnel</code>来获得分配的外部ip</li></ol></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="c18b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！我希望你喜欢这篇文章。请在下面留下评论，让我知道你对它的看法！</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="badb" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">参考</h1><ul class=""><li id="2464" class="ml mm iq kx b ky mn lb mo le mp li mq lm mr lq or mt mu mv bi translated">https://minikube.sigs.k8s.io/docs/start/<a class="ae lr" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"/></li><li id="cc37" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated"><a class="ae lr" href="https://codingbee.net/tutorials/kubernetes/using-docker-with-minikube" rel="noopener ugc nofollow" target="_blank">https://coding bee . net/tutorials/kubernetes/using-docker-with-minikube</a></li><li id="7801" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated"><a class="ae lr" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">https://helm.sh/</a></li><li id="e070" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated"><a class="ae lr" href="https://github.com/domangi/blog-impressions-k8" rel="noopener ugc nofollow" target="_blank">https://github.com/domangi/blog-impressions-k8</a></li><li id="0aa2" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq or mt mu mv bi translated"><a class="ae lr" href="https://www.udemy.com/course/microservices-software-architecture-patterns-and-techniques/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/micro services-software-architecture-patterns-and-techniques/</a></li></ul></div></div>    
</body>
</html>