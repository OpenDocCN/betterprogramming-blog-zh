<html>
<head>
<title>5 Git Commands that will Help You to Work on a Team</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个Git命令将帮助你在团队中工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/collaborate-more-productively-with-these-5-git-commands-80dd0ccf8443?source=collection_archive---------20-----------------------#2022-09-12">https://betterprogramming.pub/collaborate-more-productively-with-these-5-git-commands-80dd0ccf8443?source=collection_archive---------20-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1392" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习5个git命令，这些命令在与其他开发人员一起开发Git项目时会非常有用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be348ed520b4d053aaa9e0c6d1e8b9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjuZnAsQiGFIuE_-X-wGPQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@marvelous?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae kv" href="https://unsplash.com/s/photos/software-team?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，只有一个人的Git存储库中的开发工作流是简单的。首先，编写一些新功能，然后我们使用常见的添加、提交和推送命令:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b85d" class="lx ly iq lt b gy lz ma l mb mc">## Usual Workflow<br/>git add changed_file<br/>⁠git commit -m "Commit Message"<br/>⁠git push</span></pre><p id="66f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，我们可能会做一些事情，比如创建一个新的分支，然后在以后合并它。但是基本上，这就是我们用一个开发人员管理git库所需要的全部内容。</p><p id="6e46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，由多人开发项目的过程可能需要使用其他工具。为了更有效地协作，了解和理解一些关键命令是很重要的，这些命令将帮助我们在团队工作时避免问题。在这篇文章中，我分离了其中的五个，它们是:</p><ol class=""><li id="5472" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">git提交修改</li><li id="b696" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Git贮藏</li><li id="c413" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Git rebase</li><li id="b30c" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Git参考日志</li><li id="ebf3" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Git精选</li></ol><p id="001d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们直入主题:</p><h1 id="ad64" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">1.提交修改</h1><p id="e3c6" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">通常，我们可能会意识到我们的最后一次提交包含一个打字错误或任何其他愚蠢的错误。</p><p id="3981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而不是在新提交中添加此修复，并显示如下消息:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2259" class="lx ly iq lt b gy lz ma l mb mc">git commit -m "Fix 1"<br/>git commit -m "Fix typo"</span></pre><p id="fa5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用修改选项:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2800" class="lx ly iq lt b gy lz ma l mb mc">git commit --amend</span></pre><p id="912e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的这个命令将用一个新的commit替换以前的commit(hash也将被替换),它包含我们可能想要添加的任何更改，而不需要创建另一个commit。</p><p id="30cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它将打开编辑器，以便我们可以在必要时更改提交消息。</p><p id="a896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np lt b">— amend</code>选项允许我们更改提交消息和/或内容。它可以帮助我们保持一个分支机构的干净的历史。没有任何意外。</p><p id="e327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果我们打算只更改提交内容并保留其原始消息，我们可以添加标志<code class="fe nn no np lt b">— no-edit</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3887" class="lx ly iq lt b gy lz ma l mb mc">git commit --amend --no-edit</span></pre><p id="bba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的重要一点是，如果您已经提交了最后一次提交，那么将强制使用<code class="fe nn no np lt b"> — force</code> <strong class="ky ir"> </strong>标志来将更改发送到远程存储库，因为本地分支与它有分歧。</p><h1 id="477f" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">2.Git贮藏</h1><p id="161d" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">有时候，在一个分支上工作时，我们可能想要在另一个分支中检查一些东西。如果我们的工作没有完成，或者没有准备好提交，在这种情况下，stash命令可以节省我们一些时间。</p><p id="9ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令将获取工作分支的当前状态并保存。因此，完成一半的修改将被存储在stash stack中，工作目录将被恢复。</p><p id="512d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们在<code class="fe nn no np lt b">change-robots</code>分支的修改了<code class="fe nn no np lt b">robots.txt</code>文件<em class="nq">。</em></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e222" class="lx ly iq lt b gy lz ma l mb mc">git status<br/>⁠<br/>On branch change-robots<br/>Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git restore &lt;file&gt;..." to discard changes in working directory)<br/>        modified:   robots.txt<br/><br/>no changes added to commit (use "git add" and/or "git commit -a")</span></pre><p id="75d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们需要在<code class="fe nn no np lt b">master</code>分支检查一些东西，我们还不能切换分支，因为我们有一个未分级的文件。stash命令将保存我们已经完成一半的更改:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="685f" class="lx ly iq lt b gy lz ma l mb mc">git stash<br/>⁠<br/>Saved working directory and index state WIP on change-robots: 1c37707 About page</span></pre><p id="a0d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在来回切换到<code class="fe nn no np lt b">master</code>分支后，我们可以继续我们的工作:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="28fc" class="lx ly iq lt b gy lz ma l mb mc">git stash pop<br/>⁠<br/>On branch change-robots<br/>Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git restore &lt;file&gt;..." to discard changes in working directory)<br/>        modified:   robots.txt<br/><br/>no changes added to commit (use "git add" and/or "git commit -a")</span></pre><p id="9635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，stash命令并不局限于我们进行修改的分支。我们可以在任何其他分支应用隐藏的更改。</p><h1 id="57e1" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">3.重定…的基准</h1><p id="b66b" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">与merge命令一起，rebase合并了不同分支中完成的工作。它采用了不同的方法。rebase命令将在正在使用的分支中重新创建整个修改历史，而不是创建包含来自两个分支的更改的新提交:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f32a114909778dd99173dd0c59fc2325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/0*xla6gRQCKqJAAQvM"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git rebase示例。作者图片</p></figure><p id="cb12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nn no np lt b">master </code>分支中考虑C1、C2、C3和C4的承诺，在单独的分支中考虑C5和C6的承诺。</p><p id="49ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">rebase命令背后的思想可以被认为是:改变历史分支的基础。</p><p id="4bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初，历史基地在C1委员会，后来我们把它改成了C4。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6564" class="lx ly iq lt b gy lz ma l mb mc">git rebase master other-branch</span></pre><p id="362e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在一个单独的分支中处理一个特性时，我们可能希望用一个参考分支来保持它的最新状态，比如<code class="fe nn no np lt b">master </code>或者<code class="fe nn no np lt b">dev</code> <em class="nq">。rebase命令允许我们包含新的修改，而不会因合并提交而污染特征分支记录。</em></p><h2 id="b88a" class="lx ly iq bd ms ns nt dn mw nu nv dp na lf nw nx nc lj ny nz ne ln oa ob ng oc bi translated">交互式Rebase</h2><p id="4af7" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">除了正常的rebase命令，我们还可以添加<strong class="ky ir"> -i </strong>选项，它代表交互式。它给了我们完全的控制权来重写我们想要的分支历史。我们可以从工作分支中删除、编辑、压缩或更改任何提交的顺序。在我们的rebase示例中，假设我们想在rebase之后删除C5提交，我们可以运行:⁠</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="46c8" class="lx ly iq lt b gy lz ma l mb mc">git rebase master other-branch -i</span></pre><p id="1593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将打开一个编辑器，我们可以在其中修改我们的分支历史:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f7cc" class="lx ly iq lt b gy lz ma l mb mc">pick f9914a6 C5 (Changed README.md)<br/>pick 4faa953 C6 (Removed HTML About Page)</span><span id="e2ce" class="lx ly iq lt b gy od ma l mb mc">Commands:<br/># p, pick &lt;commit&gt; = use commit<br/># r, reword &lt;commit&gt; = use commit, but edit the commit message<br/># e, edit &lt;commit&gt; = use commit, but stop for amending<br/># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br/>...</span></pre><p id="3c17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们能够擦除C5提交，只需将它前面的<code class="fe nn no np lt b">pick</code>字<strong class="ky ir"> </strong>替换为<strong class="ky ir"> </strong> <code class="fe nn no np lt b">drop</code> <strong class="ky ir">。</strong></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="be31" class="lx ly iq lt b gy lz ma l mb mc">drop f9914a6 C5 (Changed README.md)<br/>pick 4faa953 C6 (Removed HTML About Page)</span><span id="492b" class="lx ly iq lt b gy od ma l mb mc">Commands:<br/># p, pick &lt;commit&gt; = use commit<br/># r, reword &lt;commit&gt; = use commit, but edit the commit message<br/>...</span></pre><p id="cbab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在我们返工的分支中，C5提交已被删除。我们只保留了rebase命令后的C6。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f159b5e190848416413cc1a2febcdedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*EZm2PYsw7Mm0u46l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git rebase交互示例。作者图片</p></figure><p id="9706" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将我们的rebased分支推到remote，我们必须在push命令中包含<code class="fe nn no np lt b"> — force</code>标志。你们中的一些人可能想知道:强制将提交推送到远程难道不是一种不好的做法吗？</p><p id="7780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，对于工程领域的几乎所有问题，答案都是:视情况而定！</p><p id="f141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing" rel="noopener ugc nofollow" target="_blank"> git书</a>中，有一整章都在讨论这个问题。</p><p id="e877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，如果您决定对一个包含没有被其他人使用过的提交的分支进行重定基准，这不是问题。换句话说，如果没有人把它的工作建立在要重定基础的分支的提交上，它将会很好。然而，如果是这种情况，并且你的提交已经被其他人用来在它们的基础上构建一些东西，那么这将是一个坏主意！</p><p id="123a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，在一些团队中，使用rebase而不是merge来保持他们的分支与<code class="fe nn no np lt b">master</code>或任何其他引用保持同步可能是一个偏好问题。它们都是为了通过不同的手段达到相似的结果。请记住<code class="fe nn no np lt b">git rebase</code>的这个特别之处。</p><h1 id="f7cd" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">4.参考日志</h1><p id="4d74" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">关于重定基的一个重要细节，我在上一节中没有提到，那就是它肯定会涉及到管理分支之间的冲突。如果目标分支包含许多新的提交，就很容易出错。在某些情况下，reflog命令可以帮助我们回滚到之前一切正常的状态。这可能是有用的，尤其是在我们推动了变革之后。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f20d" class="lx ly iq lt b gy lz ma l mb mc">git reflog</span><span id="4dfb" class="lx ly iq lt b gy od ma l mb mc">81da6f0 HEAD@{0}: rebase -i (finish): returning to refs/heads/dev<br/>859e694 HEAD@{1}: rebase -i (start): checkout HEAD~3<br/>9a37wee HEAD@{2}: commit: Add Feature3<br/>121e0f8 HEAD@{3}: commit: Add Feature2<br/>859e694 HEAD@{4}: commit: Add Feature1<br/>e3fxf10 HEAD@{5}: checkout: moving from master to dev</span></pre><p id="5f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以运行一个<code class="fe nn no np lt b">git checkout</code> <em class="nq"> </em>或<em class="nq"> </em> <code class="fe nn no np lt b">git reset</code> <em class="nq"> </em>使用提交散列存储。reflog存储本地项目中更新的所有引用，来自我们可能访问过的任何分支。这是git提供的另一个资源，这样我们可以在出现问题时恢复我们的工作。</p><h1 id="065f" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">5.樱桃采摘</h1><p id="4506" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">正如rebase和merge一样，Cherry-picking是一种将代码中不同分支的工作结合起来的方法。精选背后的思想是包含从一个分支到另一个分支的单个提交</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/a0b7970a2270572f1a30a604ad1c3875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UP0kEpXdPH4aZlzY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git精选示例。作者图片</p></figure><p id="7b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上图中，我们在主分支中创建了一个与特征分支中的C4提交相同的提交C4。当我们需要从一个分支到另一个分支包含一个修补程序或一个小的修改时，以及从一个废弃的分支中检索一些工作时，它可以派上用场。</p><p id="0128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，不应该使用cherry-pick命令代替merge或rebase命令，因为它会将提交复制到另一个分支中。根据我的经验，这应该只用于包含来自您的存储库中其他地方的小的修复或更改。</p><h1 id="8c4a" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">结论</h1><p id="a8a8" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">在这篇文章中，我展示了一些帮助我在使用git的团队中更有效地协作的工具。如果使用得当，所有这些方法都会有很大的帮助。但是即使我们发现自己已经把事情搞砸了。幸运的是，git提供了许多允许我们回滚的工具。</p><p id="c7b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>