<html>
<head>
<title>Data Migrations Using Azure Functions (ikcomponeer blog part 11)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure函数进行数据迁移(ikcomponeer博客第11部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-migration-using-azure-functions-40de2acafa98?source=collection_archive---------5-----------------------#2019-06-07">https://betterprogramming.pub/data-migration-using-azure-functions-40de2acafa98?source=collection_archive---------5-----------------------#2019-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="489d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为复杂流程创建简单函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec5379faccea8621341d4a72911ef64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZRRTo0W82eugGjEjnvukQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gabriel Barletta 在<a class="ae kv" href="https://unsplash.com/search/photos/compose?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6f15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的文章将向您展示如何创建简单函数来生成复杂流的过程。在这篇详尽的文章中，你将会看到这是如何发生的。</p><p id="3cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在之前的一篇文章中，我设计了一个转换器，将一些关系数据转换成事件数据。我现在将使用翻译器将一个音乐作曲从儿童作曲工具<a class="ae kv" href="http://ikcomponeer.nl" rel="noopener ugc nofollow" target="_blank"> ikcomponeer.nl </a> (Flash和mySQL/PHP)迁移到新的作曲工具环境(HTML、JavaScript和<a class="ae kv" href="http://azure.microsoft.com/en-au/" rel="noopener ugc nofollow" target="_blank"> Azure </a>)。</p><p id="da67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看需要采取哪些步骤。我们如何控制从源环境到目标环境的迁移顺序？如果一个组合在源环境中被修改了呢？我们必须确保它被再次迁移，从而在目标环境中覆盖之前的迁移。</p><p id="ff1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从我们正在迁移的遗留数据库的表上的“migrated”标志开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e585acef5d3d4d0b2a4ae90647f3708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHrB9Hj3o2bTKQiAATJHCA.png"/></div></div></figure><p id="3c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我从一个手动触发的功能开始。稍后，我们可以让它被计时器触发。这将使我们能够控制组合迁移的速度。在开发过程中，我们手动触发该功能，然后，当一切正常时，使用计时器。</p><p id="2540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是函数本身。您可以看到一个名为<code class="fe lt lu lv lw b">compositionToMigrate</code>的out参数和一个字符串输入。输入不重要；它只是一些通过点击手动<code class="fe lt lu lv lw b">run</code>按钮生成的字符串。</p><p id="216f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，该函数执行以下操作:</p><ol class=""><li id="41fd" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">从旧的mySQL/PHP环境中检索最近未迁移的组合<code class="fe lt lu lv lw b">id</code>。</li><li id="6fef" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">将<code class="fe lt lu lv lw b">id</code>分配给输出队列。</li><li id="c03a" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">再次调用旧环境以确认<code class="fe lt lu lv lw b">id</code>可以被标记为已迁移</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/55dad050582a70cc041876e5baeb2ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr4oZYXtdNy1ZHgr-uYOSA.png"/></div></div></figure><p id="8773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过检查队列来查看结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/86ab79ecf347f08e5710d2c6d3a8a80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1g0ChGNmg7uBekAyh0skAA.png"/></div></div></figure><p id="3c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，当然也应该导致作文在数据库中被标为<code class="fe lt lu lv lw b">migrated</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/3b67d8c6e8cac2989c19665ae18f212a.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*ndwB23D6S1SoC8gm9fz6iw.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="71ab" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">将数据从源系统中取出并存储在Azure数据中心</h1><p id="bbc4" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我们将创建一个由队列中出现的新组合id触发的函数。它将加载作曲的所有数据<strong class="ky ir"/>——包括它所依赖的所有数据——如设置、使用的音乐集合等。然后，该函数将这些数据存储在blob存储中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/cdee8076bf3e494b3ea97e573a3442de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSvrTqsa927zLzk4sqPN2Q.png"/></div></div></figure><p id="8487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，函数来了，很简单！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/5ad21acc2c892ea531ace9381ab019b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsiYkIuHDrpoPrJJ0nYeaA.png"/></div></div></figure><p id="f9e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以通过手动获取第一个触发函数的ID来尝试一下…它在容器中显示有一些数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/b1d34f3c2527cc24f4f2673013c51daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQYlNtJUwvmJ1hvZW-vuvw.png"/></div></div></figure><p id="ac00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！看起来所有的数据都被捕获了！我可以从存储容器中下载一个blob来看看:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/34722db1119c97c1dfdb19196610e5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR3r_JxlcPIigbWaqQlitA.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="76cd" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">译者及其事件分组</h1><p id="f748" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在我们已经将数据安全地保存在blob存储中，我们可以将它作为转换成事件驱动形式的出发点。</p><p id="31a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件存储在四个不同的Azure存储表中，旨在提供我们需要的分布和可用性。这四个表基于数据的四种实际应用或用法。因此，它们以一种特殊的方式相关联。</p><p id="9163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该设计是由数据视图驱动的，它被用在不同的级别和角色上。构图本身永远是主要的切入点。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="4077" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">四张Azure储物桌</h1><ol class=""><li id="066b" class="lx ly iq ky b kz nn lc no lf nw lj nx ln ny lr mc md me mf bi translated">音乐创作数据。</li><li id="1cf2" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">项目配置数据(当涉及到应用程序和周围web/网络环境的配置时，许多组合共享相同类型的配置)。</li><li id="4c1a" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">音乐环境数据(许多作品共享同一组源MP3文件和其他音乐参数，如速度)。</li><li id="6326" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">滚动数据(处理该作品时可用的其他作品的列表，以便用户可以输入多种音乐和体验)。</li></ol><p id="e03c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下章节将详细解释不同种类的数据。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="2b5c" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">音乐环境数据</h1><p id="4e55" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">这些数据是由音乐制作人提供的，音乐制作人制作了一组音频剪辑，供孩子们用来作曲。可以进行不同的乐器乐句(声部)组合，如木乐、打击乐、铜管乐，也可以是非传统的或创造性的组合。</p><p id="7ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下事件，同一组剪辑可以用作源素材来创建这些剪辑的多个组织。这种类型的事件用<code class="fe lt lu lv lw b">IMusicEnvironmentEvent</code>接口标记。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b237c5ea44052f7e428447b2585795d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*B4cI-zXDiTRGAIfiIofv1Q.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="8142" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">项目配置数据</h1><p id="6f95" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">项目配置不处理音乐数据本身。它处理用户可以使用音乐数据的应用程序的配置。</p><p id="5c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">比如:</strong></p><ul class=""><li id="a612" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr oa md me mf bi translated">你可以用多种方式展示它们。</li><li id="0f87" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oa md me mf bi translated">您可以允许与数据进行一些不同的交互，例如以某种方式保存结果。</li><li id="4041" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oa md me mf bi translated">你可以添加一些按钮来做这个或那个。例如，收听帮助、提示或技巧的录音。</li><li id="5688" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oa md me mf bi translated">添加一个按钮，一次清除整个构图。</li><li id="1bac" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr oa md me mf bi translated">添加一个按钮来随机创建一个组合。</li></ul><p id="3c1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">诸如此类。应用程序可以做的和可以配置的任何事情都属于这个组。</p><p id="cbd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前一章所述，环境数据通常由作曲家或音乐制作人创建。</p><p id="3cf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目配置数据通常由项目制作者和应用顾问创建，他们可以帮助实现特定的安装、配置或使用形式。它们还可以通过技术接口帮助组合工具以不同的方式与嵌入站点进行交互。</p><p id="ac4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样的<code class="fe lt lu lv lw b">Config</code>事件有很多种(多到无法在图片上放得下)，但这里有一个印象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2b90cd536fea6f3e46da9de51461f48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*FCa1avjju2owLwd3ad2Y8A.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="e053" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">滚动事件</h1><p id="2638" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">虽然配置意味着配置音乐集的不同用途，但是滚动是具体的开始项目的列表——包含音乐环境、配置数据和作曲数据的作曲。</p><p id="a6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该列表被命名为<em class="oc">滚动</em>，因为当你在一个网站上时(例如一所学校的作曲空间，或者一个管弦乐队的教育网站)，你可以滚动该列表以点击一个开始作曲。</p><p id="84ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">滚动事件是最简单的。它们只是作品的名字和id。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/34b633fd3ad46307aa9aab8c4e730fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*H4HokoN0nNJY6NJGtzDpIQ.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="d49d" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">合成事件</h1><p id="749c" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">作曲事件是由终端用户创作的实际作曲音乐。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/441d998b3e67d16fcf8065470d5abcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*v3AC4Hi7CzOygzjYo--iPg.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="3ced" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">其他可预见的事件</h1><p id="5987" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">以上列表并不完整。创建它只是为了迁移数据和构建您可以开始使用应用程序的环境。</p><p id="4af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还想存储其他可预见的事件。例如，当用户在轨道上移动事件，或按下按钮来听音乐，或触发其他UI行为(如听声音帮助线索)时。</p><p id="9a02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这样的事件是值得存储的——为了改进和分析，或者为了允许多个用户同时从不同的计算机上对同一合成进行同步协作。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="8c82" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">翻译功能</h1><p id="2a01" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">translator函数会将上述事件列表存储在一个blob中。通过将这些数据存储在blob中，我们可以创建另一个函数来实现其他功能(在另一个函数中)，这将处理Azure表存储的细节。</p><p id="5ce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后者可以在非迁移情况下重用，例如在迁移后存储事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/73691ddd93dff6447a141bb0974f1be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pVJmkzN9Y73gvd-SpPh6Q.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="b074" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">包括翻译</h1><p id="c0b0" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">翻译器本身就是一个项目，有单元测试什么的。它由一个构建环境和测试组成，这些测试自动将一个库推送到<a class="ae kv" href="https://www.nuget.org/" rel="noopener ugc nofollow" target="_blank"> NuGet </a>包管理平台。</p><p id="c81c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的源代码:</p><div class="og oh gp gr oi oj"><a href="https://github.com/bvd/ikc-deserialize2009composition" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">bvd/ikc-反序列化2009合成</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这个项目有助于反序列化2009 LAMP堆栈中的ikcomponeer组合。…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div><p id="05cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及由此产生的NuGet包:</p><div class="og oh gp gr oi oj"><a href="https://www.nuget.org/packages/JsonCompositionFromIkc2009" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">jsonpositionfromikc 2009 1 . 0 . 0-CI-2019 06 12-131247</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">描述</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.nuget.org</p></div></div><div class="os l"><div class="oy l ou ov ow os ox kp oj"/></div></div></a></div><p id="8221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在函数中使用翻译器，我们必须包含这个NuGet包。首先，我们基于现成的模板“blob trigger”创建一个空函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/0746c1371f763707609f01fcc1a17cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEInrgJoXxygh-2XtejXpg.png"/></div></div></figure><p id="0dd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们转到特殊工具并选择Kudu环境</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/6bc04661d3c0e7813c98c2a74597c499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-EYQoFYxhi8IlkO56n14AA.png"/></div></div></figure><p id="ad0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们编辑<code class="fe lt lu lv lw b">project.json</code>文件，以便引用我们需要导入的包；我们自己的NuGet包中的包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/377fff9a841f64fa945d3b250c81d1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlZmQheWjxCr00T7Q5zFGQ.png"/></div></div></figure><p id="20e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在保存和编辑一些函数代码后，函数环境将导入包，我们可以成功地编译从包中调用功能的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/01f57ff9a19b6ebc6d8984f0bf59207c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-rcW9MQyOhs4uEge7eS7g.png"/></div></div></figure><p id="caf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们从测试NuGet包的测试项目中取出一些代码。这些代码可以反序列化和翻译源数据，这样我们就有了一个翻译器，其中包含对事件的翻译，然后我们需要存储这些翻译。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/90f5070c16b51b9c45b5424741b452e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwrcoSaOrfiJnpeir90g7Q.png"/></div></div></figure><p id="2945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们配置/绑定另一个blob存储容器来存储事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/4eaea6065db233a18154650886a72757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koVNvF52gi7iIFfn1Fjxbg.png"/></div></div></figure><p id="c53a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在翻译器的库中，您可以看到它有一个如下所示的<code class="fe lt lu lv lw b">ToString()</code>实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/66e3a29f8f1a0abde03e4230c9ea8427.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*7Ih_ydqS2n2BT6zc-yn5Tw.png"/></div></figure><p id="dcfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当序列化时，所有对象都有一个类名作为标准字段，这样反序列化也成为可能。例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/c315c3e55d535c421b5099ccf49960c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*_bkTGvwP_7yEQn-dQw2PYA.png"/></div></figure><p id="e9c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储到blob现在变得很容易；我们只需将绑定作为函数参数(out参数)添加，并为其分配一个字符串。框架将确保它存储在blob中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/987ab6efd0d8274d538b920d5c024736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHUXrduGqdSU6grTrzfBgg.png"/></div></div></figure><p id="ed57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看当我们手动运行链中的第一个函数时会发生什么。我们可以在Monitor部分看到，结果我们的新函数也运行了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/fce06cdc8e9034eea8ddd95bada6f079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zuR45K5MpjnWt-WghQvtg.png"/></div></div></figure><p id="8182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的存储位置有一个新的blob条目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/95ff5bfe0dbe9044bb7b8c96f75bff63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whL47YVg9I2xSYbb8xI-qA.png"/></div></div></figure><p id="7a2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它应该以事件的形式包含我们的数据。让我们看看它是什么样子，并思考如何将它们存储在表存储中。</p><p id="ad5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常好！类名被正确地存储在<code class="fe lt lu lv lw b">Type</code>字段中，所以从blob存储中反序列化事件应该不会太难。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/f8b49413c3c4dd13d3151bed6a3aec9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N62u7rxzmYJbzyA0pRzgnA.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="33d5" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">领域驱动的对象关系映射</h1><p id="13f5" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">数据由本文前面提到的四组数据组成。这清楚地反映在事件数据的序列化中。</p><ol class=""><li id="80a5" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">首先是滚动项(由内容版主创建和更改)。</li><li id="ed8a" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">其次，您有配置项(由技术人员创建和更改，如合成工具开发人员)。</li><li id="af9f" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">第三，有音乐环境参数，例如由顾问与源音乐素材的制作者一起创建的用于作曲的音乐剪辑的可用性。</li><li id="bda1" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">最后但并非最不重要的是，有最终用户的合成事件，您可以在上图中看到一个例子。</li></ol><p id="0042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使存储更加高效、可伸缩和可维护，我们现在将了解如何将数据存储在非结构化的表格存储中。为此，我们必须设计表存储容器名称、分区键和行键。</p><p id="5085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的翻译器中，我们已经实现了一个字段，它将为滚动数据、配置数据、环境数据和组合数据提供一个唯一的标识符。这些标识符存储在合成创建的事件中。</p><p id="d344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在迁移中，我们可以假设，当我们之前已经存储了一个具有该标识符的项目时，我们将不必再做一次，因为它已经在那里了。</p><p id="fd0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是标识符在合成创建的事件中的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/fe0b816b0de189d0c296fc1481c3db6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAahqwi7ltdSIjF2Rh-M3w.png"/></div></div></figure><p id="7a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的新函数需要来自blob的带有序列化事件数据的输入绑定。对于输出绑定，我们需要滚动、环境和配置数据，但是我们必须检查这些项目是否存在。</p><p id="788f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅对于合成本身，我们将总是存储我们的合成事件行—可能覆盖较早的版本—这没有问题，因为较早创建的顺序将确保新的环境由上游实体的较新版本更新到下游。</p><p id="237f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，在存储事件时，通常不会更新整个实体，因为导致新版本的编辑事件只需添加到早期版本的尾部，从而保留整个历史。只有在迁移期间并行情况的上下文中，我们才会清除整个早期版本，并用人工翻译的较新版本来替换它。</p><p id="6559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是必要的，因为旧版本的前端也不保存事件数据。然而，在未来新的(JavaScript而非Flash)版本的前端中，所有的编辑操作只会导致新的事件被附加到同一个流中。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="72f5" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">存储帐户的差异</h1><p id="8cfc" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">在我的Azure订阅中，我创建了多个存储帐户，因为我通常期望不同的发行版。卷轴将用于一个国家或地区，在嵌入网站的背景下。</p><p id="b546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，滚动通常会有一个很短的缓存期，因为滚动的业务是向用户提供一些条目，用户可以用这些条目开始创作。</p><p id="ca25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">环境数据(可用剪辑)通常在多个合成的上下文中重用，并且可以在区域之间重用。配置数据支持环境在滚动上下文中的典型使用，因此它们也是本地的，但是可以比滚动数据更多地被缓存，因为它们通常一旦发布就不再改变。</p><p id="3d1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后是组合数据，这些数据通常在本地使用，但会发生变化，应该能够实现实时协作。由于所有这些不同的特征，我真的不知道缩放将如何发展。</p><p id="9b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至少我创建了四个不同的存储帐户:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/d52231f2c7491b8973043c91df0e42f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*1oZocrZ9Ks5KJ33tQ9Ok6g.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="4b8d" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">函数StoreEventsInTables的设计</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/7ee5e9a51a1111cac1546bacdd23c787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TnCYTDEL-vwnZtoJogecA.png"/></div></div></figure><p id="0345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数本身的创建——c#中的blob触发函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/665d1c177db6a207b88b917959f7f196.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*q4hmJhEgsS8oKsC9PHSWig.png"/></div></figure><p id="e8bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个函数将有四个不同的输出绑定，所以在函数JSON文件中定义它们变得更容易，而不是在用户界面中手动单击。为此，使用右边的文件资源管理器，然后在JSON函数中编辑绑定。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/a04087345972c56fd1a1eb0b40e39009.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*RPXI5esxtf0_bAr12GIyMg.png"/></div></figure><p id="6b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这之后，当我们返回C#文件<code class="fe lt lu lv lw b">run.csx</code>时，编译器开始抱怨没有以我们的绑定命名的参数。只有当我们定义了那些论点，它才会快乐。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/0eafc0ed2fa31cf3eb1ede9c7ad9dcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8fAXwoGLUr4sW-N1YgS3A.png"/></div></div></figure><p id="542d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我选择了<a class="ae kv" href="https://docs.microsoft.com/en-us/java/api/com.microsoft.azure.storage.table._cloud_table" rel="noopener ugc nofollow" target="_blank"> CloudTable </a>类型，这使我能够对存储表做任何我想做的事情。绑定可以是导致相同类型存储的不同类型。在<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-table#packages---functions-1x" rel="noopener ugc nofollow" target="_blank">这个微软页面</a>上有很棒的文档。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="a36d" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">使用泛型代码反序列化为类型</h1><p id="969d" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">这部分出乎意料的难。当您知道反序列化对象中的这些类的名称，并且不想为每个单独的类编写几行代码时，如何从JSON反序列化成某种包含不同类的列表呢？</p><p id="d54f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一番绞尽脑汁和谷歌搜索，我找到了一种反序列化为特定类型的方法，但不是以一种非常通用的方式。我必须明确地告诉编译器它将会是什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/3b3cc23e14c20ef2a628d382eeb8b46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2q4NRzn6_HyT38TaxEPE0w.png"/></div></div></figure><p id="42a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我花了更多的时间将对象实例化为合适的类型，但最终我成功了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/12e511c6b39b0bb1c70b13fc3bb095f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Elr_srbw8rnMy3ze8_Ir-Q.png"/></div></div></figure><p id="141d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用标记接口来决定哪个事件应该存储在哪个表中。所以我应该能够区分它们——这很有效！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/8f20c40ecaa9413f4a790c5145b54506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGgZXrktz1yaCB9EyJ9MbQ.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="848d" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">事件的行键和分区键的组合</h1><p id="cbff" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">如前所述，我使用组合创建的事件来存储不同“业务会话”的事件流的标识符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/d803b9d775b7cc163a764873dc1d50f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcA-utUFCD3rXwer6umEtw.png"/></div></div></figure><p id="9e9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些可以用作分区键。然后可以使用一个递增的数字作为行键。</p><p id="2968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用一个递增的数字，我们可以加载一系列的事件。例如，为了同步一个会话，我们可以将最新的已知事件传递给我们的API，然后API可以选择所有最近的事件。</p><p id="41b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们创建所有事件时，我们继承了<code class="fe lt lu lv lw b">TableEntity</code>，这样一个行和分区键将自动可用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/138258b8e597e44c09b71c2ea2ef5052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*v0uLvmLutLuxRpQsHLcNjQ.png"/></div></figure><p id="d9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种代码会给我们一些存储密钥:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/8efcdf963d1921dca9b64bd11bc18b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmRSBiGMItMQzteLVyqp6w.png"/></div></div></figure><p id="5d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们将分区和行键分配给表实体之后，我们总是将所有的合成事件存储在数据库中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/0eb220ed2d7b48afce26332e2bdf4f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdAOkNOUBcsTCRnBzmMCCg.png"/></div></div></figure><p id="4a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行测试，我们将把同一文件的另一个副本从文件资源管理器放入存储资源管理器，以触发该函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/f94be68489131f52bba9c4f381b1a001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H85Bqgx67QTbRCWAsDr06w.png"/></div></div></figure><p id="4e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，因为我在火车上，日志流服务没有向我显示任何内容！幸运的是，我们有监控页面，可以看到运行是成功的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/b129eba4312fa2217f7b912b2d6923ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YmnKOySyT0L9zT4gUHSOw.png"/></div></div></figure><p id="1178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我单击那一行时，我仍然可以看到调用细节。看起来很不错！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/282bea256924f98736c659db42e4a88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVHcqQkf5j-Nl_YQf25VwQ.png"/></div></div></figure><p id="50a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是最好的还在后面…我们的数据在表中存储！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/af03058087ee79a1c74c199c284fab75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsAsqWTwLzd0rLvxQ4rvKw.png"/></div></div></figure><p id="debe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你研究上图的时候，你会发现有很多空字段。然而，这些只是Azure Storage Explorer的结果，它使用表格视图来显示行。</p><p id="7f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，表中的“空字段”没有空间损失——每一行都有自己的结构，并且每一行都是唯一的。在存储资源管理器中可能会变得难以阅读，但这并不重要。</p><p id="d391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们习惯了展示的方式，我们会发现桌子上有三种类型。数字0是<code class="fe lt lu lv lw b">ClearComposition</code>事件。它没有字段。它是一种标记，告诉应用程序卸载现有的内存或存储。</p><p id="8717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个(你可以看到它有下一个<code class="fe lt lu lv lw b">RowKey</code>)显然是一个<code class="fe lt lu lv lw b">CompositionCreated</code>事件。它有组合的名称和它所依赖的其他实体的所有标识符。第三个，以及所有其他的，是音乐剪辑被添加到作品中的事件。</p><p id="a400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一个问题，类型没有被存储！</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="2f4f" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">删除以前的记录</h1><p id="e08f" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">因为我在类型上犯了一个编程错误(我需要纠正这个错误)，所以我必须删除具有特定分区键的所有复合数据行。此外，当用户保存一个新版本的组合，并在这个新版本中迁移，它将不得不覆盖旧版本。所以，现在有必要删除所有带有分区键的行。</p><p id="772a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了下面的代码，它将删除特定组合中的所有行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qb"><img src="../Images/fd49b4cf9ec256d30d3e4927be6bf28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMc9zlwZERxzkMsEPcSeYw.png"/></div></div></figure><p id="0c93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是否从表存储中删除了我的实际行？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/615803ae9a736f4a5f8222325f326312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*31KKsmvEa5hUp0FXX1LUqA.png"/></div></figure><p id="513c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是啊！</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="f203" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">更正类型字段</h1><p id="f802" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我做过的实现，但只是序列化。为了使它也作为一个表实体工作，旧版本不能工作。这是旧版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/21a144553c795e62c242115946381248.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*RRPlfHMX2VZ6BD3x7x8ykQ.png"/></div></figure><p id="a645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，该字段需要有一个普通的getter和setter。为了自动填充字段，我使用了构造函数。感觉有点怪怪的，希望以后不会给我出问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/549829361df6ca896e2ac791c5b8a44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*RKWkhALfudYkQQaw0dSWEw.png"/></div></figure><p id="456c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个版本，当我运行我的函数时，它在表存储中给我类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qf"><img src="../Images/a0c2f68fb4a2ada777a881c28408b5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUXcjqUyC2hGo0wDMLT7SA.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="aff3" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">不存在时插入，否则不执行任何操作</h1><p id="e259" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">对于合成，我们使用的策略是:<em class="oc">存在时总是覆盖</em>。相比之下，为了节省Azure点数，我们将对配置、环境和滚动数据使用另一种策略:<em class="oc">当存在时，不做任何事情</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qg"><img src="../Images/cf7c7968814c09aff52075c017164dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MJsn2mytXEr1FyzhURi9g.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="0c4d" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">简化存储</h1><p id="39cd" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">当我再次删除数据时，导致我的四个存储表被填满。我可以看到所有的东西都在储物桌上。但是，没有我期望枚举类型的字段。</p><p id="8ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我看了flatten API和<code class="fe lt lu lv lw b">DynamicTableEntity</code>类。但是，我已经对JSON序列化相当满意了，我不想通过使用更多的方法来增加更多的漏洞。我不打算在表存储的上下文中实际使用这些字段，所以我还不如将它们序列化，让一切变得简单得多。</p><p id="8ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储域和应用程序域之间的分离变得更加清晰。然而，这意味着我必须从我所有的类中移除<code class="fe lt lu lv lw b">TableEntity</code>类型的继承。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qh"><img src="../Images/facce4a5fa8c6eb0c21cbbd64a9533e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFX75kY1PKcwBpKAFYPZ6g.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/4f50d5e5e6e1f99aac9963d03aa9ca5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*0rNyU1GHPWoJGkH5X1MIZw.png"/></div></figure><p id="cca7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">SerializedEntity</code>是我将用于<em class="oc">所有</em>我存储的数据的那个。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="1d08" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">最终结果的预演</h1><p id="1d8d" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">代码的最终结果变得更加简单。我只是创建了四个相同类型的列表。唯一的区别是它们的分区键，并且，由于前面解释的原因，它们的存储帐户因分布/可伸缩性/优化原因而不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qj"><img src="../Images/e7ecbaa07b53e5767a85922eba99886a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQlM06O9u5QJQ9NFCVPAUA.png"/></div></div></figure><p id="cd4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从日志来看，这部分功能似乎运行得很好:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/ddc2cefa4aec35c1646903a8248088c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*td4ARWS1WGxH8oGBi4glQw.png"/></div></figure><p id="a8b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码的下一部分处理确定类型，并查看事件应该存储在哪里:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ql"><img src="../Images/11e123f45da2e1c33287c8edb479c128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JlXEUMsAu9Kv2-6QoJnRg.png"/></div></div></figure><p id="7920" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在日志中看到的，这似乎也是可行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/97342886ab0f8450143d1722212a56a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*jwJwYteFYlMhdxlxshSm-A.png"/></div></figure><p id="b7a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一段代码将确保当同一组合的旧版本已经被迁移时，组合首先被删除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qn"><img src="../Images/1cfabf3954b70cc06c390b1c17a32a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBqbWeDQwhdkZgKgcZ0Zlg.png"/></div></div></figure><p id="379d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在存储表的时间戳中看到，合成确实被覆盖了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qo"><img src="../Images/db0073ee2683763ff9257932b9e27322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnoQ78TQHxweJACyY4O0XA.png"/></div></div></figure><p id="1370" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他三个聚合在迁移过程中永远不会改变。因此，我们只需要存储它们一次。因为读取一条记录比覆盖全部记录要便宜得多。通过编写这样的代码，我们将节省数以亿计的写操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ql"><img src="../Images/9bc3d608cee74c4e219cb9f24677fe20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9P-SW5QWgucW57grvTl8w.png"/></div></div></figure><p id="3fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在日志中看到这是可行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/a358297259ed1465e03bf746ac2e69b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*seki2_GMOxaQyDPQzldlFA.png"/></div></figure><p id="b956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们可以在时间戳上看到，它比成分更老。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qq"><img src="../Images/925cae14063eb0d67aaa62943d5de58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlX2ruIF7hasdstJSxCv-A.png"/></div></div></figure><p id="0660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一切似乎都工作了，我们可以再次检查整个流程。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="e3c3" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">回归测试整个流程</h1><p id="4ea5" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">当我们在几个下游函数中对NuGet库做了一些更改时，我们可以问，“我们是否也需要在上游函数中实现这些更改？”</p><p id="8684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们查看这些变化的性质时，它是有帮助的，并且可以预测我们是否必须将上游功能更新到包的更新版本。</p><p id="f654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们再次重温第一个函数。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="3412" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">重新访问标记组合形成迁移</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e585acef5d3d4d0b2a4ae90647f3708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHrB9Hj3o2bTKQiAATJHCA.png"/></div></div></figure><p id="f518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数似乎没有对库做任何事情——它只是从PHP API获取一个数字id，将其放入一个队列，并使用<code class="fe lt lu lv lw b">setMigratedFlag</code>函数确认，同样只使用id。</p><p id="fcd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以查看函数的<code class="fe lt lu lv lw b">project.json</code>文件来完全确定。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qr"><img src="../Images/7ea2ea073f8ad45b608f5ef3d2ac3041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abVCHCUrRtmdpbyf7yw28g.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="8b20" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">重新访问LoadDataFromSourceSystemToBlob</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/cdee8076bf3e494b3ea97e573a3442de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSvrTqsa927zLzk4sqPN2Q.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qs"><img src="../Images/70e69277cd283aa04dd3b60d61ccd24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1Hrg-GkY0gmT3rbTPfZ8Q.png"/></div></div></figure><p id="43b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数简单地从PHP后端加载大量JSON序列化数据，并通过Blob输出绑定(<code class="fe lt lu lv lw b">hierarchicalCompositionData</code>)将它们安全地存储在Azure数据中心。所以，再次，没有使用我们的NuGet包。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="5921" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">重温TranslateToEvents</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/73691ddd93dff6447a141bb0974f1be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pVJmkzN9Y73gvd-SpPh6Q.png"/></div></div></figure><p id="c93b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数使用实际的翻译器来加载来自PHP后端的复合数据，并将这些数据翻译成在。NET NuGet包。</p><p id="0a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的软件包使用的是旧版本。当前版本是安装包1 . 0 . 0-CI-2019 05 29–063832</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qt"><img src="../Images/c316c7dd8247d50447af6553ea32ad4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpmBDZsfKr6TVFvteJC1bQ.png"/></div></div></figure><p id="6cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是软件包的使用方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qu"><img src="../Images/fadad12710fabfd3f6e63651037a7cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksgThbrVaC7meJf_jc4ImQ.png"/></div></div></figure><p id="3c39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一下自从这个NuGet包版本以来所做的代码更改。</p><p id="8d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，在这个日期，我们可以找到一个构建，推动NuGet与这个版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qv"><img src="../Images/c787aa4d96b864ea206902dd191914b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o68UKXzASG1zbhK7dw4MOw.png"/></div></div></figure><p id="bd4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建的标题立即显示了我应该在GitHub上寻找哪个提交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qw"><img src="../Images/f4383d5af732c951c123126c3f1c7408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gakS1sMQ9BHlLz-zoSYzRw.png"/></div></div></figure><p id="8cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在可以检查所有的更改，以预测是否更改版本更好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/6e093d86c34e2fbd272a146a80f854c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*l8dYfK5DvaOUbA2t_m7b_A.png"/></div></figure><p id="ff9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我决定更新函数，这是您通常想要做的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qy"><img src="../Images/2c2a762f1bf274dbec4197f3af9ee306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMPnMlSOm8TPTfwrpLTgWg.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="ca98" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">重新测试整个流程</h1><p id="bca7" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">由于我们已经更新了我们的包，现在让我们重新测试整个流程。它从第一个功能的手动触发开始，之后应该会导致连续触发四个功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/ac0dfaf17a3e95932718ac3aa6ba5e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*8xThdMZLiH3qss_LowtIJA.png"/></div></figure><p id="6bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导致日志中出现成功消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/d4635c06e001058905421a892d723c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*IfN6FpI-oXM8FfFYdPtMVw.png"/></div></figure><p id="d67c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这一次，其他函数是否也成功运行了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rb"><img src="../Images/a4f253751c7a861501c409aa5c40d3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*ggLZ22qHTGLdnbTpgjT8oA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rc"><img src="../Images/7d367b289b5f254bd396ade88e362d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*PYJeOt6EUMqtuoYKIaCooA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f2c266cdedf39fc26fc5739efe5aa3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*N1vI3OzfoZH8Jbtu7Wz0DA.png"/></div></figure><p id="7274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以…看起来不错！结果呢？</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="fd81" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">在源系统数据库中测试结果</h1><p id="c1fd" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">当我运行查询“everything migrated please”时，我看到最近迁移的组合是<code class="fe lt lu lv lw b">avonturrrrrrrrren1ctest</code>，所以这应该是在我刚刚测试功能时提取、加载和转换并存储到Azure Table存储中的组合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rd"><img src="../Images/83f263dc8ab4fb2b5ba767188d0f63da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2BT9OxpU83H0-NHnw5s2g.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="6151" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">检查Blob存储</h1><p id="5cb3" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我可以看到在存储容器中有一个blob，用于存储层次化/未转换的源数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi re"><img src="../Images/e235c1e0e4ce637d090cc339753b57f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*6XoINUKN9uyp0u_3PDj1iA.png"/></div></figure><p id="1862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当下载blob时，我看到它确实是预期的组成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rf"><img src="../Images/37e55fb59a8900f9f538e222f2deb80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOG19aqMHYdAlX-_x4iBWQ.png"/></div></div></figure><p id="2420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在转换后的序列化数据的位置有一个新的blob。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rg"><img src="../Images/9740e3fce185970fcc2d377de12c7f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*nE39NGQdbt7RPpAxZuW7jQ.png"/></div></figure><p id="0ade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当下载这个blob时，我对里面的数据有了很好的印象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/b40618e9dd881f9e65db94292309ade9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*mcDHBK46fJT_qWLctYGZlQ.png"/></div></figure><p id="def7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的对象是“composition created”事件，在这里我们将找到其他聚合的分区键。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ri"><img src="../Images/b3266a1d1afdeb2dbdf4bde35f968a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*8PAMET-CeSCNujFhKdKjaQ.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="99e3" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">检查存储表</h1><p id="a7ae" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">环境、项目/配置和滚动表没有更新，因为这些实体已经存储。然而，组合本身被更新了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rj"><img src="../Images/f762b7a8337ab36fcb0be8caf5c498e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUBNnUDq6acgrBGbbsVxXw.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="9948" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">用定时器触发器代替手动触发器</h1><p id="e3c8" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">为了迁移所有的组合，我们将使用一个计时器。我们应该让计时器走多快？我们希望旧的PHP数据库不会因为我们的请求而过载，但另一方面，我们希望在两个月内迁移所有的组件。两个月有多少秒？五百一十八万四千秒。数据库里有多少作文？104,000.</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rk"><img src="../Images/14da031812d8a6458bf6fa7c9427735d.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*73_U8yepXqVVR8FLW_Q43A.png"/></div></figure><p id="ff6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们这个问题的答案是5184000/104559。</p><p id="ec5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个组合必须每49秒迁移一次，这样我们才能在两个月内准备好。让我们把它四舍五入到一分钟，这将需要两个月零十天。</p><p id="d6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们如何才能将手动触发改为定时触发呢？</p><p id="29e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们删除手动触发器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rl"><img src="../Images/390accd9df026676d84adb306d2a860f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQKvoOy2ntk5ZNkbe_BUUA.png"/></div></div></figure><p id="18ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在删除手动触发器后，用户界面为我们提供了添加新触发器的选项。默认计划将每分钟触发一次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rm"><img src="../Images/a11eb408796ba030545f45c8a3efc895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFWXwmee2wrCUPtDqwZyOA.png"/></div></div></figure><p id="4872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以在日志中看到有一个错误，告诉我应该将<code class="fe lt lu lv lw b">myTimer</code>参数添加到函数配置文件中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rn"><img src="../Images/b1a656596cf1072638251f8f6e950026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpQHitCnVoN6dRI6itqlIw.png"/></div></div></figure><p id="a71b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我可以看到函数每分钟都在运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ro"><img src="../Images/ba3d92cd50c010839995c2edaf66e1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlklS_XBhnthhgFFgGxW8Q.png"/></div></div></figure><p id="1d9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它应该会导致每分钟都添加一些斑点！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rp"><img src="../Images/ea3cf3d57d1758d21308a41af42dfd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*2QWAinpZHiWUJec0DeSCKA.png"/></div></figure><p id="e4d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们会在储物桌上看到一些东西吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rq"><img src="../Images/02de8b4ece81ceb13d0fba8df5ce3b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*dSNDNLvgwQnYrkGfU9qjUw.png"/></div></figure><p id="63ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的…成功了！</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="ecb0" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">监视</h1><p id="fc66" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">TK我每天都想看看这是怎么回事。我希望我提供的东西是现成的…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rr"><img src="../Images/9b58a69bdbb7c57373ca8baa7b983204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZX7lvhvljXqiOcLvqzhgjw.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="1edd" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">应用洞察</h1><p id="b7e3" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我在Application Insights的分析页面中看到一些查询。我不必对此进行配置；显然它是从盒子里出来的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rs"><img src="../Images/412f53013efe7961a31c608661a501fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riBy4jdFrbKdOoWEgLlD3A.png"/></div></div></figure><p id="9096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道这到底是什么语言，但我设法轻松地包含了所有的函数，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/8d16c59c971d2f210ffcfb57e0fd0ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSE9RXB_bL82Vuxec4wAqg.png"/></div></div></figure><p id="f462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我设法只得到<strong class="ky ir">联合国</strong>成功的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ru"><img src="../Images/24155ad1b002189ed29752e1968781f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQYWFlIB38vE5Tz2aMOgAQ.png"/></div></div></figure><p id="9ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等了几天后，我再次查看我的查询，发现了一些错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rv"><img src="../Images/2ea4d610c1e6042b803b7fc39c91b52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plH5q4NA6DCzJKt0D5F63g.png"/></div></div></figure><p id="71b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，很不错，但是我看不到太多的伐木。幸运的是，在应用洞察中还有其他好东西。</p><p id="6958" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图中，我选择了一个时间范围，在该时间范围内，我预计“请求失败”下钻会出现一些错误。右下角有一个蓝色按钮，可以让我进一步深入查看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qq"><img src="../Images/6b7764dd8728568e32b04c1938317a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YyjF8Zj9ryCJcPqgH3__Q.png"/></div></div></figure><p id="e9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个接口，我找到了这个调用的数据。我用<code class="fe lt lu lv lw b">view all telemetry around this time</code>按钮查看更多，我稍微调整了遥测的时间窗口。</p><p id="e8b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我发现，很明显，关于导致错误的blobs的数据被移到了一个有害队列中！</p><p id="f7b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以很容易地在存储资源管理器中找到这个队列。这些消息中包含了我需要的所有数据，以便查看blob存储中无法处理的数据，并使用它来解决问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rw"><img src="../Images/16245be2a98bcb09d872a30bdd14147d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHywLgRqDkhFpwgHXqsmjA.png"/></div></div></figure><p id="9214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是没那么容易。我必须手动打开所有排队的消息，并手动搜索和下载所有blob文件。因此，我将编写另一个函数，以便将失败的数据复制到一个特殊的blob容器中。这个容器将被命名为<code class="fe lt lu lv lw b">failing-data</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/180227418b729b16b64f2e3cb80b87ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*jYKlCMpvq-tuoSeNb6H-mQ.png"/></div></figure><p id="8543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了一个函数来处理这些数据，并给它一个存储队列触发器，但是我故意在绑定中出错，因为我不希望在我的处理函数按预期工作之前我的消息出队。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rx"><img src="../Images/72641fffa2b45617cd1509e58e9d7e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*2EztK_6jHpEasiNnYHKTzw.png"/></div></figure><p id="dc23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要从消息中反序列化所需的属性，您必须创建一个类，并将绑定分类为这个自定义类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ry"><img src="../Images/d66e25e7b4dfeefbd984de6570098621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*T8jfgV8AExyUQMnr0sVsCw.png"/></div></figure><p id="473b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我想根据病毒blob的容器名称，写入不同的blob位置。我不能为此使用标准绑定，但我必须使用命令式绑定，这样它才能动态工作。</p><p id="ef1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我在函数中注入一个粘合剂。然后，我可以使用这种绑定风格向带有动态路径的blob中写入内容。路径的第一段是blob的容器。其他部分是路径中的其他目录，最后是文件名。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rz"><img src="../Images/60419276af79fa3fc0ebc7d9b546d1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTzDtKeVd7Q5WgYVnSqn4A.png"/></div></div></figure><p id="e760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们如何使用<code class="fe lt lu lv lw b">PoisonMessage</code> <code class="fe lt lu lv lw b">ContainerName</code>和<code class="fe lt lu lv lw b">BlobName</code>从适当的容器中动态读取<strong class="ky ir"> </strong>？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sa"><img src="../Images/8e0015ef00c49150428bedb1041fa35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-YfiEpKyGTrv9W6rE1yjw.png"/></div></div></figure><p id="3d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们纠正故意输入错误，从队列中读取消息，看看是否会导致数据被复制到失败数据blob中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sb"><img src="../Images/4e98baeffab054a91d638e6244dda2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxPUGYxYTX8ImSA5MJDbmg.png"/></div></div></figure><p id="6c1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">队列现在应该是空的，它是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sc"><img src="../Images/36c261d5633578f265d6b26d8013fa2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDXRGoWnXWuw514o-PAc7Q.png"/></div></div></figure><p id="62af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，我们应该在新创建的容器中找到失败的斑点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sd"><img src="../Images/43e99d9adf8271343b7fef750e7240a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Y0U4f_nZjPQ8B2j2XBg2w.png"/></div></div></figure><p id="ee3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候一次轻松下载所有这些blobs，看看哪里出错了。然而，乍一看，我真的看不出这些数据有什么问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi se"><img src="../Images/023498649b149931e9d2a6657d5f306d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIK6Xv0P361FVE-YnzntVg.png"/></div></div></figure><p id="2c26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再次查看应用洞察，搜索异常本身。</p><p id="9f62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查故障时，我们首先看到的是数字增加了。有10个blob有失败的数据，总共有50个异常，因为每个blob重试四次，每个失败的blob总共执行五次。</p><p id="47a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还看到两种类型的异常——无效强制转换和空引用异常。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sf"><img src="../Images/a0d87b0e7607fbb7c5bfb5d8cdfab2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCi4Esl0EJ-XBnGtm0Vong.png"/></div></div></figure><p id="8336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们点击无效的强制转换异常，看看它告诉我们什么。</p><p id="12d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一些点击，我得到了实际的错误，这是非常详细的！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sg"><img src="../Images/a59cde6fcff18d3adf333879002a64d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pi8G3F9GKDMwcIuzXrUAAg.png"/></div></div></figure><p id="1ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，是真的。在我的记事本++ JSON数据中，我现在可以发现情况就是这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi sh"><img src="../Images/afe546f114af2d683b971ab967249ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uenbI8fAmovTMJ-kwjvcBw.png"/></div></div></figure><p id="ae6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许这些作品没有被很好地配置，因为它们从来没有真正投入生产，但它们是一个学生项目，一个实验。</p><p id="19b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个实验产生了九个毒文件，还有九个无效的强制转换异常，这不是巧合。我不打算修改任何东西，并把这些数据视为不会被迁移的垃圾数据。</p><p id="256a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，出现了一个空引用异常。让我们看看还没有分析的数据文件。为什么会出现空引用异常似乎很清楚，因为它是一个空文件。因为它只发生过一次，它可能只是一些奇怪的事件，所以我不打算进一步调查它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi si"><img src="../Images/d87940b7b9b551fd789d8b2ffd1a88ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vp7ChyeHkKLtriVD3OkAzg.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="bd68" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated"><strong class="ak">结论</strong></h1><p id="4f8b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我希望你玩得开心，并且在实践中学习了如何使用Azure函数。我将重新启动迁移，并解决一些类似的问题，直到所有数据都迁移完毕。</p><p id="9387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请在下面留下您的反馈。</p></div></div>    
</body>
</html>