# 保持代码干燥

> 原文：<https://betterprogramming.pub/keeping-your-code-dry-1105377c9c80>

## 重构要点

![](img/4d0544928e8cc2e1c231a9381cf0317a.png)

[弗兰克诉](https://unsplash.com/@franckinjapan?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/repeat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

# 背景

在过去的一周里，我的大部分时间都花在了一个编码挑战上。从理解用户故事到构建应用程序，再到实现代码，再到调试，这绝对是一项艰巨的任务。

我的组件之间有很多来回。我慢慢开始意识到，当我更改了代码的一部分时，我需要更改依赖于它的代码的所有其他部分。

通过改变我的代码的一部分而产生手动改变的下游效应，这违反了 DRY(不要重复自己)原则。

当您最初写出代码时，这种情况可能比您想象的要多得多。保持代码干燥是重构过程的一部分，所以如果你没有马上发现它，那不是问题。

# 在组件中保持代码干燥

我第一次意识到我没有保持代码干燥是在我必须制作一个登录表单的时候。下面的要点显示了我的登录表单的代码。

非干燥的登录表单

这是一个通用的表格，你需要输入你的电子邮件和密码。`handleChange`是使表单成为受控组件的回调函数。

如果您不熟悉一个受控组件，那么它本质上是 React 组件的值与 DOM 上显示的值相同，这符合单一来源的原则。

能不能找到代码可能没干的地方？

提示:看一下`input`属性。

如果你看一下`input`属性和 switch/case 语句，字符串“email”和“password”是重复的。

如果您不小心从这些字符串中删除了一个字母，代码仍然可以编译，但现在当您需要将电子邮件和密码值发送到后端时，这将使调试成为一场噩梦。

另外，如果我决定更改我的登录表单，不再使用电子邮件作为凭证，而是使用用户名，该怎么办？

现在，我需要找到所有出现“email”的地方，把它改成“username”。您可能会想:“等等，我的文本编辑器可以找到“name”的所有实例，我可以将其全部替换为“username ”,然后就到此为止。”

我会说你是正确的，但它没有解决前一段中提到的任何意外错误的问题。

那么，这种登录表单怎么干呢？您可以将重复的字符串保存到常量中。

```
const EMAIL = "email"
const PASSWORD = "password"
```

这将这些字符串的所有实例汇集成一个*单一的真实来源*，一个常量。请注意，根据惯例，常量是大写的。

所以现在，如果您用它们各自的常量替换所有的“email”和“password”字符串，代码看起来会像下面的要点。

登录表单干燥

这如何裁定偶然错误的问题？如果常量名称出错(例如，`EMAIL`到`EMAL`)，JavaScript 将出现编译错误，因为没有定义不正确的常量名称。

如果你在字符串或者常量的值上犯了一个错误，你可以准确的指出错误在哪里，因为只有一行声明了这个值。这样可以节省时间和精力，彻底检查您的代码，寻找潜在的小错误。

# 跨组件保持代码干燥

到目前为止，我们讨论了在组件中保持干燥。但是如果在多个组件中使用相同的值会怎么样呢？

出于演示目的，让我们引入另一个组件。我们也将重复使用登录表单，因为我们在这一点上已经很熟悉了。

带有获取请求的登录表单

带有获取请求的朋友组件

在登录表单中，我添加的唯一内容是包含 URL 的获取请求的前半部分。获取请求的其余部分不适用于本主题。

在`Friends`组件中，当组件被挂载时，它向后端发出一个获取请求，以检索与 ID 为 1 的用户相关联的所有朋友。

请注意，我一引入`Friends`组件，我们的代码就不枯燥了。但是怎么做呢？

如果查看两个组件中的获取请求，URL 使用相同的域:`http://localhost:3001`。通常情况下，域名永远不会改变，这是一个完美的应用程序，提取 URL 的域部分，并将其保存为一个常数，就像我们以前所做的一样！

但是等等，这是跨组件的，不是同一个组件内的。将 URL 的域部分分配给一个变量并在同一个组件中使用一次是多余的。

那么，我们如何保存域 URL 并在多个组件中使用它呢？就像我们处理库一样，我们可以`import`它们！但是，我们可以创建一个包含所有常量的文件，并根据需要导入它们，而不是拥有一个变量库。

因此，首先，让我们创建常量文件并将域 URL 放入其中。

接下来，我们在需要的文件中导入`DOMAIN`常量，然后用`DOMAIN`替换所有使用`http://localhost:3001`的实例。

实现了导入的域常量的登录表单

实现了导入的域常量的 Friends 组件

跨多个组件保持代码干燥就是这么简单！

# 利用 Constants.js

在代码的这一点上，我们创建了一个单独的文件`Constants.js`，用来存储跨多个组件使用的常量。

下一个问题是这样的:“我们是否希望使用`Constants.js`来存储在这个时间点上只属于组件(例如，登录表单组件)的常量？”

答案是…我不知道。我可以很容易地为这两种情况进行论证。

## **1。将所有常量存储在 Constants.js 中**

通过将所有常量存储在`Constants.js`中，文件只有一个责任。这也使得调试更加容易，因为所有常量值的唯一来源都在该文件中。

可伸缩性也是一个重要因素，因为如果您要创建使用相同常量的新组件，我们可以直接导入它们，而不必担心在本地组件级别第一次使用常量时重构组件。

## 2.**仅在 Constants.js 中存储跨多个组件使用的常数**

这意味着在本地组件级别使用的常量将*仅*用于该组件。这缩小了常数的使用范围。

如果您在不同的组件中看到相同的常数，这可能表明该常数的使用不正确，或者该组件可能一开始就不需要该常数。

在这两种情况下，我认为在实现代码之前需要做出设计决策。

如果您在实现过程中改变了主意，您将需要解析所有组件，并确定常量是应该在本地级别还是在常量文件中。

# 结论

保持代码干燥可以避免代码味道。当进行调试时，它用最少的努力维护干净简洁的代码，并最小化重复。

请记住，你不必像我一样应用干燥原则。我确信有其他方法可以保持代码干燥，只要你不重复自己，你就在正确的轨道上！