<html>
<head>
<title>6 Things To Know When Dockerizing Python Apps in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中整理Python应用程序时需要知道的6件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-things-to-know-when-dockerizing-python-apps-in-production-f4701b50ca46?source=collection_archive---------1-----------------------#2021-02-11">https://betterprogramming.pub/6-things-to-know-when-dockerizing-python-apps-in-production-f4701b50ca46?source=collection_archive---------1-----------------------#2021-02-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f126" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在生产环境中使用Python运行Docker容器的清单</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/dc2eecf5f7fccc91ca6c03bbb1cc1865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cltXwC-YEA_jjkIP"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上J. Kelly Brito 拍摄的照片。</p></figure><p id="d2ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<a class="ae kz" href="https://medium.com/better-programming/docker-for-node-js-in-production-b9dc0e9e48e0" rel="noopener">的上一篇文章</a>中，我写了一份在生产环境中使用Docker运行Node.js应用程序的清单。</p><p id="eab5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最近忙着开发Python应用。如果你将Node.js和Docker与Python和Docker进行比较，你会发现很多东西是相同的。但是也有值得注意的差异。</p><p id="cdff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我重写了我的清单。这个是为了在生产环境中用Python运行Docker容器。</p><p id="9aa5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在这个GitHub库中找到所有的例子<a class="ae kz" href="https://github.com/PatrickKalkman/python-docker" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7cb1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">1.选择正确的基础图像</h1><p id="49b7" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为您的Python应用程序选择正确的基本Docker映像至关重要。这取决于应用程序，但请始终尝试使用<a class="ae kz" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">官方Docker图像</a>，因为它们拥有出色的文档，使用最佳实践，并且是为最常见的用例而设计的。</p><p id="10a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看官方<a class="ae kz" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank"> Python Docker图片</a>的话还是有很多图片可以选择的。大多数时候，我选择最小尺寸的图像来运行我的Python应用程序。如果您想在64位Linux上运行Python 3.8应用程序，以下是一些选项:</p><ul class=""><li id="202d" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">python:3.8-buster→<strong class="lc iv"/>883 MB</li><li id="3c59" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">python:3.8-瘦克星→ 114 MB</li><li id="c74a" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">python:3.8-alpine → 43 MB</li></ul><p id="c6bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker团队将Alpine映像基于Alpine Linux发行版，这是一个带有强化内核的最小Linux发行版。如果你的应用程序在Alpine上工作，你应该用它作为你的基本图像，这样可以得到最小的图像尺寸。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8940" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">2.使用非根容器用户</h1><p id="38a4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">默认情况下，您的应用程序以root用户身份在容器内运行。但是，容器中的根与主机上的根不同。Docker限制容器中的用户。但是为了减少安全攻击面，您可能希望尽可能以无特权用户的身份运行容器。</p><p id="ff62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些官方映像已经在它们的Docker映像中创建了一个非root用户，但是大多数情况下，您必须自己在Docker文件中添加用户。有关添加和使用Python用户的示例，请参见下面的docker文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">以非root用户身份添加和运行Python应用程序</p></figure><p id="57ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第一行，我使用python:3.7.8-alpine图像作为基础图像。第6行的语句添加了Python用户。第9行的指令为我的应用程序创建了目录。我显式地将新的目录所有者设置为Python用户，因为我仍然作为root用户运行。</p><p id="3f9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nq nr ns nt b">WORKDIR</code>指令设置工作目录并创建文件夹。但是，没有办法设置目录所有者。</p><p id="d65f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在第12行将用户设置为Python用户。<code class="fe nq nr ns nt b">USER</code>指令在运行映像时设置用户名(或UID)。Dockerfile选择用户后，我执行<code class="fe nq nr ns nt b">pip install</code>来安装我的应用程序的依赖项。该命令将以Python用户的身份运行。在第22行，我将应用程序的源代码复制到工作文件夹中。</p><p id="f5dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在最后一行，应用程序使用了<code class="fe nq nr ns nt b">CMD</code>指令。这提供了执行容器的缺省值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7f21" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">3.启动和停止Python应用程序</h1><p id="5fda" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在Docker容器中以正确的方式启动和停止Python应用程序至关重要。在之前显示的Dockerfile文件中，我使用<code class="fe nq nr ns nt b">CMD</code>指令启动应用程序。</p><p id="96aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您使用exec形式的<code class="fe nq nr ns nt b">CMD</code>指令启动Python应用程序时，您需要确保能够从应用程序内部的操作系统(例如<code class="fe nq nr ns nt b">SIGINT</code>和<code class="fe nq nr ns nt b">SIGTERM</code>)接收信号，并处理它们以正常关闭应用程序。</p><p id="f341" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你忽略这些信号并停止你的容器，Docker将等待十秒钟(默认超时)让你的应用程序响应。如果你的应用没有响应，它会终止你的Python进程并停止容器。因此，您要做的第一件事就是对<code class="fe nq nr ns nt b">SIGINT</code>和<code class="fe nq nr ns nt b">SIGTERM</code>命令做出反应，然后优雅地关闭您的应用程序:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过对SIGINT和SIGTERM做出反应，优雅地停止您的Python应用程序</p></figure><p id="82a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码示例显示了如何实现对<code class="fe nq nr ns nt b">SIGINT</code>和<code class="fe nq nr ns nt b">SIGTERM</code>信号的响应。在这个例子中，我通过调用<code class="fe nq nr ns nt b">stop()</code>退出进程，但是这也是清理资源的地方。</p><p id="ddb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您无法访问源代码或不想更改应用程序的源代码，有两种不同的方法可以关闭您的应用程序。</p><p id="c79a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先是使用<code class="fe nq nr ns nt b">--init</code>。这个标志向Docker表明它应该使用一个init进程作为容器中的<code class="fe nq nr ns nt b">PID 1</code>。启动容器时，可以这样使用它:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="1503" class="ny me iu nt b gz nz oa l ob oc">docker run --init -d yourpythonappimage</span></pre><p id="cc3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后你的容器将直接对<code class="fe nq nr ns nt b">Ctrl-C</code>或<code class="fe nq nr ns nt b">Docker stop</code>命令做出反应。</p><p id="01d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一个更持久的选择是将<a class="ae kz" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> tini </a>添加到您的docker文件中，并将其包含在您的图像中。这也是当你使用<code class="fe nq nr ns nt b">--init</code>标志时Docker在后台做的事情。在您的映像中安装tini，并使用<code class="fe nq nr ns nt b">ENTRYPOINT</code>启动和包装<code class="fe nq nr ns nt b">CMD</code>。请参见下面的示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">带蒂尼的Dockerfile</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d7bc" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">4.健康检查</h1><p id="8abe" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Docker文件中的<code class="fe nq nr ns nt b">HEALTHCHECK</code>指令告诉Docker如何验证容器是否仍在工作。这可以检测到这样的情况，例如web服务器陷入无限循环，即使服务器进程仍在运行，也无法处理新的连接。</p><p id="24df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须实现执行健康检查的功能，因为Docker不知道您的应用程序何时正常运行。我通常为我的服务器添加一个不同的路由，专门用于处理健康请求。</p><p id="2f84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有几个包可以帮助用Python实现健康检查。我在下面列出了两个:</p><ul class=""><li id="db65" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><a class="ae kz" href="https://pypi.org/project/health-check/" rel="noopener ugc nofollow" target="_blank">健康检查</a></li><li id="77dd" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://pypi.org/project/py-healthcheck/" rel="noopener ugc nofollow" target="_blank">py-健康检查</a></li></ul><p id="3b35" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些包中的大多数实现了健康检查的接收端。您仍然需要将实际的请求添加到Dockerfile文件中。如果您的Python应用程序中有一个HTTP端点，那么您可以使用<code class="fe nq nr ns nt b">curl</code>来执行健康检查。例如，通过使用下面的<code class="fe nq nr ns nt b">HEALTHCHECK</code>命令:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="f23a" class="ny me iu nt b gz nz oa l ob oc">HEALTHCHECK <!-- -->--interval=21s --timeout=3s --start-period=10s <!-- -->CMD curl --fail http://localhost:3000/ || exit 1</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="c0b8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">5.从Python应用程序记录日志</h1><p id="4e77" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在Docker容器中运行时，从Python应用程序进行日志记录很简单:根据具体情况，记录到<code class="fe nq nr ns nt b">stdout</code>或<code class="fe nq nr ns nt b">stderr</code>。</p><p id="702f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这背后的基本原理是让其他东西来处理日志记录。让其他东西记录日志是有意义的，因为我们通常在微服务架构中使用Docker容器，在微服务架构中，您可以在多个服务之间分配职责。</p><p id="8e00" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我不推荐使用<code class="fe nq nr ns nt b">print</code>从你的Python应用程序中写入<code class="fe nq nr ns nt b">stdout</code>或<code class="fe nq nr ns nt b">stderr</code>。相反，我会利用标准库中可用的优秀日志功能。</p><p id="e2ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您仍然使用<code class="fe nq nr ns nt b">print</code>函数来记录日志，请使用<code class="fe nq nr ns nt b">-u</code>参数启动Python。这确保Python不会缓冲消息。因此，在Docker中启动Python应用程序的命令如下所示:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="56ae" class="ny me iu nt b gz nz oa l ob oc">CMD ["python", "-u", "main.py"]</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4706" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">6.使用环境变量的配置</h1><p id="8d13" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当你的应用在Docker容器中运行时，Docker希望你使用环境变量来完成所有的配置。有一个名为<a class="ae kz" href="https://pypi.org/project/python-dotenv/" rel="noopener ugc nofollow" target="_blank"> python-dotenv </a>的优秀库可以提供帮助。</p><p id="eec3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个库从名为<code class="fe nq nr ns nt b">.env</code>的文件中读取所有的键值对，并将它们添加到环境变量中。在您的Python应用程序中，您可以像读取标准环境变量一样读取它们。</p><p id="a182" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个<code class="fe nq nr ns nt b">.env</code>文件包含许多键值对，每一个都在单独的一行上:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="7d9d" class="ny me iu nt b gz nz oa l ob oc"># development settings<br/>DB_ADDRESS=localhost:2323<br/>DB_TIMEOUT=4000<br/>LOG_LEVEL=DEBUG</span></pre><p id="1905" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">阅读和使用<code class="fe nq nr ns nt b">dotenv</code>很简单。请参见下面的示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用dotenv进行阅读环境设置</p></figure><p id="8e61" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第10行，<code class="fe nq nr ns nt b">.env</code>被加载。在<code class="fe nq nr ns nt b">.env</code>文件中定义的环境变量<code class="fe nq nr ns nt b">LOOP</code>被加载并存储在<code class="fe nq nr ns nt b">self.loops</code>中。当我们使用<code class="fe nq nr ns nt b">os.getenv</code>读取变量时，我们也指定了一个默认值。您可以使用这些默认变量来设置开发值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d261" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="e1d1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这些是我在Docker容器中运行Python应用程序的技巧。你可以在GitHub库中找到所有的例子。</p><p id="3715" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。如果你有更多的建议，请告诉我。我喜欢学习。</p></div></div>    
</body>
</html>