<html>
<head>
<title>The Art of the MVVM-C Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM-C模式的艺术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-art-of-mvvm-c-pattern-6fb9def2bb66?source=collection_archive---------8-----------------------#2019-11-28">https://betterprogramming.pub/the-art-of-mvvm-c-pattern-6fb9def2bb66?source=collection_archive---------8-----------------------#2019-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c61d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">如何优化TabBar项目中的导航</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/4b0a63084770332813aee8ed4407f72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKj5o1GfDY2ugQmkTbd3yg.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@ddmdsdd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">达维·门德斯</a>在<a class="ae kw" href="https://unsplash.com/s/photos/tabs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3d0b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为一名开发人员，或者只是一名智能手机用户，你可能已经体验过了，现在大多数应用程序都是用TabBars构建的。过去，应用程序通常是用segues构建的，这有时会导致巨大的堆栈，并且同一个ViewController可能需要构建两次。</p><p id="a9eb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">希望，Soroush Khanlou给我们带来了这些巨大故事板的答案:<a class="ae kw" href="http://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank">协调者模式</a>。</p><p id="014e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">值得注意的是，我的教程首先是基于MVVM模式的，我不打算在本文中解释。通过实例化独立的视图控制器，协调器模式本身将只负责应用程序中的导航，现在可以一个接一个地使用多次。</p><p id="f6c7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些模式的结合带来了惊人的结果:MVVM-C模式。</p><p id="a7f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们开始吧！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="66a2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">场景代表</h1><p id="96c0" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">场景委托已经包含在每个Xcode项目中。它在这种情况下的作用是抓住AppCoordinator不放。</p><p id="b0e0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后您将调用<code class="fe mx my mz na b">start()</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5a63" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">应用协调员</h1><p id="27f6" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">这是指挥整个app的协调者的切入点。这很简单:你只需要把它和场景委托连接起来，实例化TabCoordinator，把它和场景委托连接起来，然后调用它的启动函数。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5bea" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">选项卡协调员</h1><p id="7ac8" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">这里是航海的地球。选项卡协调器可以分为几个部分:</p><p id="49d9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">来源:</strong><code class="fe mx my mz na b">TabBarSource</code>的一个实例，它是负责带标签栏相关参数的类。因为我们在讨论接口编程，所以你需要继承一个协议，该协议在其扩展中将为每个标签添加一个名为<code class="fe mx my mz na b">relatively</code>的原始值。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nd"><img src="../Images/d08fc175fc65d235e0aa471cb4481d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvSjl8-KOyq75bPOOcZCNw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">下面是文件中的源代码</p></figure><p id="e457" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，在选项卡协调器上进行扩展(在底部),以获得所选选项卡的原始值:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ne"><img src="../Images/071bab1ba52caea1815956526f3b0005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erSpEiaoY0qHc-TdRu0Umw.png"/></div></div></figure><p id="ae25" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，调用relative <code class="fe mx my mz na b">show()</code> func来实例化堆栈的协调器:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/33bc7d09c14453f1cc07a9ef9f1a80f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*8UiWKCCcxMbjm2YJt6ZILQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">这是TabBar类的样子</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fa43" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">协调者</h1><p id="0d9a" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">每个堆栈都有一个协调器。然后，它将在屏幕的帮助下，通过实例化不同的MVVM块来协调整个堆栈的流程。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/56ebb57a3578f275d443cd59c33d8c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*x2JReYdvxkIyAvOnzAcreQ.png"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="cef8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">屏幕</h1><p id="ba69" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">这个类<code class="fe mx my mz na b">Screens</code>只包括故事板。</p><p id="73ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，创建扩展。每一个都应该包含一个函数，负责实例化viewController及其相关的视图模型和最终的存储库、委托等。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nh"><img src="../Images/906afbe378112f51a546ce1a2f615254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6wcqJyPUaLqkLyJzvX4Gg.png"/></div></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1f66" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">MVVM</h1><p id="b9ef" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">此外，您将找到与每个视图相关的MVVM块。在本教程中，它仅指ViewController和ViewModel。</p><p id="84d9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我不愿意在这个话题上更进一步。然而，我只能建议发展您对此模式的理解和技能。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ec6f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="6af8" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">我希望我已经很好地介绍了MVVM-C模式。当然，这个教程对那些已经有这方面的高级知识的人来说不会很有用。但是，要成为专家，总要从某个地方开始，化繁为简往往就是把事情说清楚。</p><p id="2a65" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可能还想在这个<a class="ae kw" href="https://github.com/Cublax/MVVM-C-Tutorial" rel="noopener ugc nofollow" target="_blank">地址</a>上检查这个项目的存储库。</p><p id="57e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢阅读，祝你好运！</p></div></div>    
</body>
</html>