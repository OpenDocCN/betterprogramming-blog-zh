<html>
<head>
<title>Concurrent vs. Serial Dispatch Queue: Concurrency in Swift Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发与串行调度队列:Swift中的并发性解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/concurrent-vs-serial-dispatch-queue-concurrency-in-swift-explained-14c4fa6f2478?source=collection_archive---------15-----------------------#2019-11-12">https://betterprogramming.pub/concurrent-vs-serial-dispatch-queue-concurrency-in-swift-explained-14c4fa6f2478?source=collection_archive---------15-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Swift中线程和并发的更多信息</h2></div><p id="0eed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并发和串行队列有助于我们管理执行任务的方式，并有助于使我们的应用程序运行得更快、更有效，并提高响应能力。我们可以使用<code class="fe le lf lg lh b">DispatchQueue</code>类轻松地创建队列，该类构建在Grand Central Dispatch (GCD)队列之上。</p><p id="9045" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分派队列的好处是，与较低级别的GCD线程代码相比，它们更容易理解，并且在不同线程上执行任务时更高效。尽管如此，还有很多东西需要学习，所以让我们深入了解并发队列和串行队列之间的区别。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="3107" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">什么是调度队列？</h1><p id="ac90" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated"><code class="fe le lf lg lh b">DispatchQueue</code>是GCD队列之上的一个抽象层，它允许您在应用程序中异步和并发地执行任务。任务总是按照它们被添加到队列的顺序执行。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8feb" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">什么是串行队列？</h1><p id="d71e" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">串行调度队列一次只执行一项任务。串行队列通常用于同步对特定值或资源的访问，以防止发生数据竞争。</p><h2 id="a360" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">创建串行调度队列</h2><p id="18a5" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">一个<code class="fe le lf lg lh b">DispatchQueue</code>默认为一个串行队列，可以初始化如下:</p><pre class="my mz na nb gt nc lh nd ne aw nf bi"><span id="1c73" class="mm lq it lh b gy ng nh l ni nj">let serialQueue = DispatchQueue(label: "swiftlee.serial.queue")<br/><br/>serialQueue.async {<br/>    print("Task 1 started")<br/>    // Do some work..<br/>    print("Task 1 finished")<br/>}<br/>serialQueue.async {<br/>    print("Task 2 started")<br/>    // Do some work..<br/>    print("Task 2 finished")<br/>}<br/><br/>/*<br/>Serial Queue prints:<br/>Task 1 started<br/>Task 1 finished<br/>Task 2 started<br/>Task 2 finished<br/>*/</span></pre><p id="1d03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，第二个任务仅在第一个任务完成后开始。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="0df8" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">什么是并发队列？</h1><p id="a582" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">并发队列允许我们同时执行多个任务。任务总是按照它们被添加的顺序开始，但是它们可以按照不同的顺序完成，因为它们可以并行执行。任务将在由调度队列管理的不同线程上运行。同时运行的任务数量是可变的，取决于系统条件。</p><h2 id="7af0" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">创建并发调度队列</h2><p id="ac9d" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">并发调度队列可以通过将一个属性作为参数传递给<code class="fe le lf lg lh b">DispatchQueue</code>初始化器来创建:</p><pre class="my mz na nb gt nc lh nd ne aw nf bi"><span id="d57e" class="mm lq it lh b gy ng nh l ni nj">let concurrentQueue = DispatchQueue(label: "swiftlee.concurrent.queue", attributes: .concurrent)<br/><br/>concurrentQueue.async {<br/>    print("Task 1 started")<br/>    // Do some work..<br/>    print("Task 1 finished")<br/>}<br/>concurrentQueue.async {<br/>    print("Task 2 started")<br/>    // Do some work..<br/>    print("Task 2 finished")<br/>}<br/><br/>/*<br/>Concurrent Queue prints:<br/>Task 1 started<br/>Task 2 started<br/>Task 1 finished<br/>Task 2 finished<br/>*/</span></pre><p id="3b2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，在第一个任务完成之前，第二个任务已经开始了。这意味着两个任务并行运行。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="b493" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">两全其美</h1><p id="ed08" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在某些情况下，利用并发队列来同时执行多个任务，同时防止数据竞争是很有价值的。这可以通过利用所谓的屏障来实现。在我们开始之前，最好了解一下数据竞争到底是什么。</p><h2 id="d1ed" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">什么是数据竞赛？</h2><p id="9e71" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">当多个线程不同步地访问同一个内存，并且至少有一次访问是写操作时，就会发生数据争用。您可能正在从主线程读取数组中的值，而后台线程正在向同一个数组中添加新值。</p><p id="d9ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据竞争可能是古怪的测试和奇怪的崩溃背后的根本原因。因此，定期花时间使用<a class="ae nk" href="https://twitter.com/twannl/status/1192781427978493952?s=20" rel="noopener ugc nofollow" target="_blank">螺纹消毒剂</a>是个好习惯。</p><h2 id="1d13" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">在并发队列上使用屏障来同步写入</h2><p id="c0c4" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">屏障标志可用于使对某个资源或值的访问是线程安全的。我们同步写入访问，同时保持并发读取的优势。</p><p id="7ee9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码演示了一个可以同时从多个线程访问的messenger类。向阵列添加新消息是使用屏障标志和块以及新读取来完成的，直到写入完成。</p><pre class="my mz na nb gt nc lh nd ne aw nf bi"><span id="42be" class="mm lq it lh b gy ng nh l ni nj">final class Messenger {<br/><br/>    private var messages: [String] = []<br/><br/>    private var queue = DispatchQueue(label: "messages.queue", attributes: .concurrent)<br/><br/>    var lastMessage: String? {<br/>        return queue.sync {<br/>            messages.last<br/>        }<br/>    }<br/><br/>    func postMessage(_ newMessage: String) {<br/>        queue.sync(flags: .barrier) {<br/>            messages.append(newMessage)<br/>        }<br/>    }<br/>}<br/><br/>let messenger = Messenger()<br/>// Executed on Thread #1<br/>messenger.postMessage("Hello SwiftLee!")<br/>// Executed on Thread #2<br/>print(messenger.lastMessage) // Prints: Hello SwiftLee!</span></pre><p id="c1c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将一个障碍看作是一个妨碍并行任务的任务，并且在一瞬间，使一个并发队列成为一个串行队列。带有障碍的任务被延迟执行，直到所有先前提交的任务执行完毕。最后一个任务完成后，队列执行屏障块，然后恢复正常的执行行为。</p><h2 id="9bc3" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">异步与同步任务</h2><p id="a832" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">一个<code class="fe le lf lg lh b">DispatchQueue</code>任务可以同步或异步运行。主要区别发生在创建任务时。</p><ul class=""><li id="692f" class="nl nm it kk b kl km ko kp kr nn kv no kz np ld nq nr ns nt bi translated">同步启动任务将阻塞调用线程，直到任务完成</li><li id="d9a1" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">异步启动任务将直接在调用线程上返回，而不会阻塞</li></ul><p id="9cbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您将从主线程向队列添加一个任务。您希望防止自己对长时间运行的任务使用同步方法。这将阻塞主线程，使你的用户界面没有反应。</p><h2 id="ab3d" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">主线怎么样？</h2><p id="1a00" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">主调度队列是一个全局可用的串行队列，在应用程序的主线程上执行任务。因为主线程用于UI更新，所以在这个队列上执行任务时要注意。因此，使用前面描述的dispatch APIs在不同的线程上执行任务是有价值的。</p><p id="2847" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以开始在后台队列上执行繁重的工作，并在完成后将其分派回主队列。</p><pre class="my mz na nb gt nc lh nd ne aw nf bi"><span id="072e" class="mm lq it lh b gy ng nh l ni nj">let concurrentQueue = DispatchQueue(label: "swiftlee.concurrent.queue", attributes: .concurrent)<br/><br/>concurrentQueue.async {<br/>    // Perform the data request and JSON decoding on the background queue.<br/>    fetchData()<br/><br/>    DispatchQueue.main.async {<br/>        /// Access and reload the UI back on the main queue.<br/>        tableView.reloadData()<br/>    }<br/>}</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="ed16" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">避免过多的线程创建</h1><p id="92bb" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">读完这篇文章后，你可能会想创建许多队列来提高应用程序的性能。不幸的是，创建线程是有代价的，因此您应该避免创建过多的线程。</p><p id="3a72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在两种常见的情况下，会创建过多的线程:</p><ul class=""><li id="4d47" class="nl nm it kk b kl km ko kp kr nn kv no kz np ld nq nr ns nt bi translated">并发队列中添加了太多的阻塞任务，迫使系统创建额外的线程，直到系统用完应用程序的线程。</li><li id="4d6f" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">存在太多私有并发调度队列，它们都消耗线程资源。</li></ul><h2 id="d666" class="mm lq it bd lr mn mo dn lv mp mq dp lz kr mr ms mb kv mt mu md kz mv mw mf mx bi translated">如何防止过多的线程创建？</h2><p id="d1c2" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">最佳实践是利用全局并发调度队列。这可以防止您创建太多的私有并发队列。除此之外，您还应该注意执行长阻塞任务。</p><p id="fe50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用全局并发队列，如下所示:</p><pre class="my mz na nb gt nc lh nd ne aw nf bi"><span id="93e9" class="mm lq it lh b gy ng nh l ni nj">DispatchQueue.global().async {<br/>    /// Concurrently execute a task using the global concurrent queue. Also known as the background queue.<br/>}</span></pre><p id="cda5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个全局并发队列也被称为后台队列，用在<code class="fe le lf lg lh b">DispatchQueue.main</code>的旁边。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="58d6" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">结论</h1><p id="0bf1" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">就是这样，深入了解Swift中的调度队列。还有更多的内容需要介绍，但这里只介绍了基本的内容。请务必查看Thread Sanitizer，看看您的应用程序在哪些地方可以针对数据竞争进行改进。</p><p id="b395" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢！</p></div></div>    
</body>
</html>