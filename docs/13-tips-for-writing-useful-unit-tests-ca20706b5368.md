# 编写有用的单元测试的 13 个技巧

> 原文：<https://betterprogramming.pub/13-tips-for-writing-useful-unit-tests-ca20706b5368>

## 如何编写测试和编写测试一样重要

![](img/ccdd04d717eb9d35dbc92d3731eb332e.png)

本·穆林斯在 [Unsplash](https://unsplash.com/s/photos/test?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

在[我之前的文章](https://medium.com/better-programming/unit-testing-and-why-you-should-be-doing-it-ab61407c53ce)中，我提出了你应该对你的代码进行单元测试的案例。我觉得我的理由很充分。

在本文中，我将介绍一些关于如何对代码进行单元测试的技巧和提示。开始了。

# 1.孤立地一次测试一件事

这可能是单元测试要遵循的基本规则。所有的类都应该单独测试。他们不应该依赖于除了模仿和存根以外的任何东西。

他们不应该依赖其他测试的结果。它们应该可以在任何机器上运行。你应该能够在你母亲的计算机上运行你的单元测试可执行文件，即使它还没有连接到互联网。

# 2.遵循 AAA 规则:安排、行动、断言

说到单元测试，AAA 代表*安排、行动、断言*。这是编写单个测试的通用模式，以使它们更具可读性和有用性。

首先，你安排。在这一步中，您设置要测试的东西。您可以设置变量、字段和属性来运行测试，并定义预期的结果。

然后您采取行动——也就是说，您调用您正在测试的方法。

最后，您断言——调用测试框架来验证您的“行为”的结果是预期的。遵循 AAA 原则，你的测试就会清晰易读。

# 3.首先编写简单的“中间快速投球”测试

你写的第一个测试应该是最简单的——快乐之路。它们应该是那些能够简单快速地说明你要写的功能的东西。

如果您正在编写加法算法，您编写的早期测试应该确保您的代码可以执行 2 + 2 = 4。然后，一旦这些测试通过，您应该开始编写更复杂的测试(如下所述),测试代码的边缘和边界。

# 4.跨边界测试

单元测试应该测试给定边界的两边。如果您正在为日期和时间实用程序构建一些测试，请尝试在午夜前一秒和午夜后一秒进行测试。检查日期值是否为 0.0。

如果您正在处理一个包含矩形的结构，那么测试矩形内外的点会发生什么。上面或者下面呢？向左还是向右？右上方？在左下方？

跨越边界是代码可能失败或以不可预知的方式执行的地方。

# 5.如果可以的话，测试整个光谱

如果可行，测试你的功能的所有可能性。如果它涉及枚举类型，请用枚举中的每一项测试功能。

检查每一个可能的字符串或每一个整数可能不切实际，但是如果你能测试每一种可能性，那就去做吧。

# 6.如果可能的话，覆盖每一条代码路径

这也是一个挑战，但是如果你的代码是为测试而设计的，并且你使用了代码覆盖工具，你可以确保你的每一行代码至少被单元测试覆盖一次。

如果你选择的语言有一个代码覆盖工具，在你的单元测试中使用它。覆盖每一条代码路径并不能保证没有任何错误，但是它肯定会给你关于每一行代码状态的有价值的信息。

# 7.编写测试来揭示错误，然后修复它

这是一种强大而有用的技术。如果你发现了一个 bug，写一个测试来揭示它。然后，您可以通过调试测试来快速修复 bug。

然后，您有一个优秀的回归测试来确保如果该 bug 因为任何原因再次出现，您将立即知道。当您在调试器中运行一个简单、直接的测试时，修复一个 bug 是很容易的。

这里的一个附带好处是你已经“测试了你的测试”。因为您已经看到测试失败，然后又看到它通过，所以您知道测试是有效的，因为它已经被证明正确地工作。这使得它成为一个更好的回归测试。

# 8.使每个测试独立

测试不应该互相依赖。如果您的测试必须以特定的顺序运行，那么您需要改变您的测试。

相反，您应该正确使用单元测试框架的`Setup` 和`TearDown` 特性，以确保每个测试都准备好单独运行。

单元测试框架不保证测试会以任何特定的顺序运行。如果您的测试依赖于以特定顺序运行的测试，那么您可能会发现自己在测试中有一些微妙的、难以追踪的错误。

确保每个测试都是独立的，你就不会有这个问题。

# 9.清楚地命名你的测试，不要害怕长名字

因为您在每个测试中做一个断言，所以每个测试可能会非常具体。因此，不要犹豫使用一个长的、完整的测试名。有`TestDivisionWhenNumPositiveDenomNegative`比有`DivisionTest3`好。

一个长的、完整的名字可以让你立即知道哪个测试失败了，以及这个测试到底想做什么。名称清晰的长测试也可以记录你的测试。

例如，一个名为`DivisionByZeroShouldThrowException`的测试精确记录了当你试图除以零时代码做了什么。

# 10.测试是否引发了每个引发的异常

如果您的代码引发异常，那么编写测试来确保您引发的每个异常都在应该引发的时候被引发。

大多数 xUnit 测试框架可以测试正在引发的异常，所以您应该使用该特性来确保您的代码引发的每个异常确实是在适当的情况下引发的。

# 11.避免使用 Assert。伊斯特鲁

避免检查布尔条件。

例如，不要用`Assert.IsTrue`来检查两个东西是否相等，而是用`Assert.AreEqual`来代替。为什么？因为这个:

```
Assert.IsTrue(Expected = Actual);
```

会举报类似`Some test failed: Expected True, but the actual result was False`的事情。这说明不了什么。相反，使用`Assert.AreEqual`:

```
Assert.AreEqual(Expected, Actual)
```

它会告诉你所涉及的实际值，比如`Some test failed: Expected 7, but the actual result was 3` *，*哪个作为错误信息更有价值。

# 12.不断运行您的测试

在编写代码的同时运行测试。您的测试应该运行得很快，使您能够在即使很小的更改后运行它们。

如果您不能将测试作为正常开发过程的一部分来运行，那么一定是出了问题——单元测试应该几乎立即运行。如果不是，那可能是因为你没有孤立地运行它们。

# 13.作为每个自动化构建的一部分运行您的测试

正如您应该在开发时运行测试一样，它们也应该是您持续集成过程中不可或缺的一部分。失败的测试应该意味着你的构建被破坏了。

不要让失败的测试徘徊不前——将它视为构建失败，并立即修复它。

# 结论

有 13 种方法可以写出有用的单元测试。请记住，除非您正在编写单元测试，否则您的代码将难以维护和修复。写得好的、全面的单元测试是一个巨大的胜利。