# 单元测试最佳实践

> 原文：<https://betterprogramming.pub/unit-testing-best-practices-9bceeafe6edf>

## 可以帮助您编写更好的测试的实用建议列表

![](img/4b5c0392f51e8f89cc7a40fe4d8457c3.png)

[来源](https://unsplash.com/photos/IiEFmIXZWSw)

**免责声明**:这是一组我认为在编写单元测试时非常有用的东西。我称它们为*最佳实践*，因为它们允许我编写好的、高质量的测试，更容易阅读、更易维护，并且更好地描述业务需求。

这些点可能是主观的，你可能有其他的意见或有更多的项目。那很好。不要犹豫，把你的观点写在评论里。

# 开发过程中的测试

测试在开发过程中非常重要。他们给你很多好处:

*   测试验证需求。这表明您的实现正确地解决了问题。
*   他们在早期阶段识别缺陷。越早发现问题越好，因为修复起来更快更便宜。通过编写测试在开发过程中发现缺陷是最好的时机。
*   提高可维护性。要编写测试，源代码应该是可测试的，这意味着它更易于维护。可测试代码通常是良好解耦的，这增加了可读性。这也迫使更好的架构。
*   让重构更安全。测试允许大的变化，并验证没有引入回归。
*   有助于代码审查。因为测试清楚地表明了作者的意图，所以首先验证测试做了解决方案应该做的事情更容易。这将让我们更深入地了解实际做了些什么，使回顾变得更简单。

# 不错的测试

我们将从定义什么可以被认为是“好的测试”开始。

通常，一个好的测试是:

*   值得信赖。这意味着它只有在被破坏的情况下才会失败。如果测试有时会失败，那么它就是不可靠的，不能称之为好的测试。
*   可读/可维护。从阅读一个测试，应该清楚它测试什么，如何做。它不应该有样板或棘手的调整状态或控制。
*   应该验证一个用例。这与单一责任原则有关。如果一个测试验证了多个案例，那么如果它失败了，我们不能确切地说出原因。一个好的测试验证一个用例，当它失败时，我们立即知道哪里出错了。
*   孤立无援。该测试不应影响其他测试。这特别意味着测试不应该共享一个全局状态。如果测试没有被隔离，那么它们的执行顺序会导致意想不到的结果。

# 良好测试过程的最佳实践

第二组最佳实践是关于一个好的测试过程。

如果满足以下条件，测试流程就是好的:

## 它是自动化的(在配置项上)

测试只有在及时执行的情况下才有用。最好的选择是使用持续集成，例如，在每次提交时，持续运行您的测试。否则，很容易忘记运行测试，这使得它们没有用。

## 测试是在开发期间编写的，而不是在开发之后

TDD(在编写代码之前编写测试)很好，但是从一开始，可能就不太容易预见模块应该是什么样子，类的结构是什么，等等。

所以，如果一个人不能先写测试，那也没关系。重要的是在开发的早期建立测试，不要拖到最后。

原因是测试帮助你写出干净的代码。分离关注点，使用接口来隐藏实现细节或一些特定于平台的细节。如果您延迟编写测试，您会发现自己处于这样一个位置，有些代码是不可测试的，并且很容易修改它。

## **为发现的每个缺陷/案例增加测试**

在编写测试时，你不需要考虑所有理论上可能发生的情况(我们将在下面详细讨论)。

最重要的事情是反映业务用例，并为发现的任何其他需求或缺陷不断添加测试。尤其是对于缺陷。因为这样，您可以在修复之前验证是否有案例失败，并在修复之后检查测试是否真正通过。

# 测试最佳实践

这些是编写单元测试的一般理论实践。他们有助于对测试过程有一个大致的了解。

但是在这篇文章中，我想更深入地探讨一些可能使您的测试更好的实用要点。

## 写一个好的测试名

它应该描述测试的内容、测试发生的条件以及测试结果的预期。

如果给定的测试有一个测试用例，在测试 Javadoc 中提供一个到它的链接。
如果测试名称变大，使用缩写。描述测试 Javadoc 中缩写的含义。

一个不好的测试名会降低它的可维护性。

## 测试公共接口

不公开的东西都不应该测试。

不要破坏封装(通过提供`[@VisibleForTesting](http://twitter.com/VisibleForTesting)`或类似的东西)来测试功能。

如果有一个方法你想彻底地单独测试，这意味着它很可能是某个其他类的公共接口的一部分(或者实用方法，或者扩展)。

每个被测试的类都应该有一个公共接口(以明确应该测试什么)。

测试非公共的东西会降低测试的可维护性。打破封装破坏建筑。

## 每次测试验证一个用例

测试应该检查一件事。特别是，这意味着每个测试应该只有一个断言。

但是这里也有例外:如果你想检查一个测试的设置是否正确，那么你可以使用假设检查。

如果您想验证在测试过程中调用了(或没有调用)模拟中的哪些方法，那么进行多次验证是很好的。
尽管对于断言来说，每次测试只断言一次是很重要的。

在一个测试中测试多个东西并不允许你，当这样的测试失败时，清楚地说出失败的确切原因。

## 将测试主体分组为逻辑部分

对于在返回值时断言的简单单元测试，应该有一个设置部分和一个断言部分。

在复杂测试的情况下(更接近于集成测试)，应该有一个设置部分(给定)、一个触发部分(当)和一个结果部分(然后)。

没有逻辑分组的测试更难阅读，因此更难维护。

## 使用依赖倒置

在构造函数中或通过公共接口向测试中的类提供依赖关系。不要在类内部创建一些第三方依赖项。不要从类内部获取单例实例。

用自己的接口包装一些系统/平台类，提供这些接口而不是真正的平台类作为依赖。这包括提供使用日历/时间的界面。

不使用 DI 会降低代码的可测试性。

## 模拟与存根

尽可能使用真实的类。如果这是不可能的，那么提供一个存根。如果不可能提供存根，就提供一个 mock。

这通常意味着实体和值对象应该是真实的，一些第一方服务应该是真实的或存根，第三方服务应该是存根或模拟。

在测试中过度使用模拟可能会导致您测试模拟实现，而不是实际的实现。

## 实体/值对象默认生成器

当使用实体或值对象的真实类时，用带有默认值的构建器来构建它们是很方便的。

基本上，它是 entity/value 对象的默认实现，在这个实现中，用户可以更改对于给定测试很重要的属性。

没有这样的构建器会导致代码重复，降低测试的可维护性。

## 组合成子类的组测试

使用通用设置创建一个抽象的基本测试类，并使用测试特定部分功能的子类来扩展它。

这将把紧密耦合的测试用例集中在一个地方。这样，就有可能将部分测试名(重复部分)提取到一个封闭的类名中。

将所有测试放在一个类中会降低可读性。

## 测试的初始状态应该只通过被测试类的公共 API 及其依赖项来生成

不应该对类进行内部修改来进行测试设置。没有`@VisibleForTesting`与打破封装。

通过非公共 API 改变内部状态可能会产生一种不可能的情况。此外，它打破了封装。

## 尽早设置测试

编写几个涵盖基本功能的测试。随着时间的推移，当体系结构建立起来，了解到更多的信息时，添加更多的测试。

在早期编写大量测试需要技巧(如果使用 TDD 的话)。TDD 很棒，但是如果没有足够的经验，当结构发生重大变化时，可能需要多次重写测试。

将编写测试推迟到开发结束可能会导致不可测试的代码。

# 结论

编写测试不是一件容易的事情。这需要纪律。

此外，测试也是代码，应该像编写一般产品代码一样小心编写。但是，当你在测试上投入时间，随着时间的推移，你会从中获得越来越多的价值。

不要害怕写测试。不要等待。从今天开始。继续做测试。

编码快乐！