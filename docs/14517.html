<html>
<head>
<title>Accelerate JavaScript Applications With Concurrent Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过并发管道加速JavaScript应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-concurrent-pipelines-to-accelerate-javascript-applications-246cbdd167a?source=collection_archive---------3-----------------------#2022-12-31">https://betterprogramming.pub/using-concurrent-pipelines-to-accelerate-javascript-applications-246cbdd167a?source=collection_archive---------3-----------------------#2022-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac5f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们如何在应用程序上实现35%的加速</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/445b668753277fbd84beccb642f083d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t-PxEG6mMUNiErAC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nishimiyaphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">洋子科雷亚西宫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="11c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据管道，比如著名的ETL管道，对于大多数后端开发人员来说并不陌生。</p><p id="511c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近发现自己在团队的Node.js后端使用这样的管道。我在一个端点上工作，接收许多对象，验证它们，并将它们插入数据库:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="6c03" class="lx ly iq lt b be lz ma l mb mc">for (var obj of objects) {<br/>    await validate(obj);<br/>    await insert(obj);<br/>}</span></pre><p id="6576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式在代码库中已经存在很长时间了。它过去可以完成工作，但效率不是特别高，因为每个对象都需要往返后端:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6d691c1142074339ff050fcd92991341.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*7fEooAAKbR7EAgl9atfNJA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">幼稚管道的时间表</p></figure><p id="4298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在注意到大量的人力时间被浪费在等待操作上之后，我优化了端点，使其使用<a class="ae kv" href="https://www.mongodb.com/docs/manual/core/bulk-write-operations/" rel="noopener ugc nofollow" target="_blank">批量数据库插入</a>。这将往返数据库的次数减少到1:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="3e54" class="lx ly iq lt b be lz ma l mb mc">const bulk = new Bulk();<br/>for (var obj of objects) {<br/>    await validate(obj);<br/>    bulk.insert(obj);<br/>}<br/>await bulk.execute();</span></pre><p id="23bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是更改后的时间线:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/4f87837c87809d0dc3748fa621ba7fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Wqb01dUM670mX895mVskYw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有批量数据库插入的时间线</p></figure><p id="00a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果非常好:端点的性能提高到了令人满意的水平。</p><p id="1973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是还有另一个优化的机会:注意一个被验证的对象是如何完全独立于另一个被插入的对象的，然而所有的数据库插入都发生在所有的对象验证之后。如果我们将对象验证和数据库插入重叠在一起会怎么样，就像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f4e711ff00dfe3a8d0dbc70cefb4f6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*HfWhoO8xy02ncrdBfCrqTQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有并发批量数据库写入和对象验证的时间线</p></figure><p id="c68b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如何在JavaScript中实现这样的行为呢？一种方法可能是完全删除最后一个<code class="fe mf mg mh lt b">await</code>:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="b540" class="lx ly iq lt b be lz ma l mb mc">for (var batchStart=0; batchStart&lt;objects.length; batchStart+=BATCH_SIZE) {<br/>    const bulk = new Bulk();<br/>    for (var i=batchStart; i&lt;batchStart+BATCH_SIZE &amp;&amp; i&lt;objects.length; i++) {<br/>        await validate(objects[i]);<br/>        bulk.insert(objects[i]);<br/>    }<br/>    bulk.execute();<br/>}</span></pre><p id="5028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当然，并发的运行中的数据库请求的数量是没有限制的，特别是如果与数据库插入相比，验证花费的时间很少，并且我们正在处理大量的对象，更不用说异步异常处理了。</p><p id="596d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们可以使用由我创作的NPM软件包<code class="fe mf mg mh lt b"><a class="ae kv" href="https://www.npmjs.com/package/concurrent-pipeline" rel="noopener ugc nofollow" target="_blank">concurrent-pipeline</a></code>。我们首先导入包并创建一个新的<code class="fe mf mg mh lt b">Pipeline</code>:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="3b7a" class="lx ly iq lt b be lz ma l mb mc">const Pipeline = require('concurrent-pipeline');<br/>const ppl = new Pipeline(10);</span></pre><p id="47c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">10代表“最多10个并发运行的流”。</p><p id="f0d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们用<code class="fe mf mg mh lt b">pipelined</code>包装内部for循环，允许外部for循环继续进行，而不必等待每个批处理:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="7520" class="lx ly iq lt b be lz ma l mb mc">for (var batchStart=0; batchStart&lt;objects.length; batchStart+=BATCH_SIZE) {<br/>    await ppl.pipelined(async (stage, batchStart) =&gt; {<br/>        const bulk = new Bulk();<br/>        for (var i=batchStart; i&lt;batchStarts+BATCH_SIZE &amp;&amp; i&lt;objects.length; i++) {<br/>            await validate(objects[i]);<br/>            bulk.insert(objects[i]);<br/>        }<br/>        await bulk.execute();<br/>    })(batchStart);<br/>}</span></pre><p id="e78c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在代码的不同阶段实施不同的并发限制。让我们假设我们希望最多进行5个并发验证，但是将数据库插入阶段限制为3个并发操作:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="8337" class="lx ly iq lt b be lz ma l mb mc">for (var batchStart=0; batchStart&lt;objects.length; batchStart+=BATCH_SIZE) {<br/>    await ppl.pipelined(async (stage, batchStart) =&gt; {<br/>        const bulk = new Bulk();<br/>        await stage('validation', 5);<br/>        for (var i=batchStart; i&lt;batchStarts+BATCH_SIZE &amp;&amp; i&lt;objects.length; i++) {<br/>            await validate(objects[i]);<br/>            bulk.insert(objects[i]);<br/>        }<br/>        await stage('database', 3);<br/>        await bulk.execute();<br/>    })(batchStart);<br/>}</span></pre><p id="ca0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mf mg mh lt b">await stage</code>语句阻止流进入已经达到并发限制的阶段，直到出现一个点。</p><p id="c84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们等待所有流结束:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="8cbd" class="lx ly iq lt b be lz ma l mb mc">await ppl.finish();</span></pre><p id="7a2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个调用还会抛出流没有处理的任何异常。</p><p id="76be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe mf mg mh lt b">concurrent-pipeline</code>将验证与数据库操作重叠，并保持多个数据库操作运行，我的应用程序获得了35%的加速。</p><p id="c8d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<code class="fe mf mg mh lt b">concurrent-pipeline</code>的<a class="ae kv" href="https://github.com/mstniy/concurrent-pipeline-js" rel="noopener ugc nofollow" target="_blank">回购</a>上找到关于【】的更多细节。</p></div></div>    
</body>
</html>