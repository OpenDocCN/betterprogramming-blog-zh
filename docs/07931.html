<html>
<head>
<title>Learn How To Build APIs With Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何使用Next.js构建API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-how-to-build-apis-with-next-js-109d381f8b30?source=collection_archive---------0-----------------------#2021-03-08">https://betterprogramming.pub/learn-how-to-build-apis-with-next-js-109d381f8b30?source=collection_archive---------0-----------------------#2021-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4b50" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Next.js中的API routes特性来构建可扩展的无服务器lambda函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/70d6280fea77c2803216cc61fa7d6a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TsvMzies8CnR77qhK287w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8b4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.js 是React的一个框架，它使得开发者开发SEO友好的网站变得简单而有效。因为它装载了很棒的特性和<a class="ae lr" href="https://nextjs.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank">惊人的文档</a>(以及<a class="ae lr" href="https://nextjs.org/learn" rel="noopener ugc nofollow" target="_blank">入门课程</a>)，Next.js对于任何经验水平的开发者都是一个很好的选择。</p><p id="5f9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于大多数听说过Next.js的开发人员来说，当提到它时，脑海中浮现的是“前端web开发”然而，许多人可能不知道它的API routes特性，该特性使您能够在同一个代码库中编写前端和<em class="ls"> </em>后端代码。当与像Vercel(专门为Next.js开发的)或Netlify这样的无服务器平台结合时，Next.js的API routes特性使开发人员能够轻松地为他们的项目API编写lambda函数。</p><p id="5736" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们将利用这一创新特性来创建一个真实世界API的基本示例。我们将介绍生产性API设计和开发的基本步骤，包括诸如<a class="ae lr" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank">逻辑抽象</a>、<a class="ae lr" href="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design" rel="noopener ugc nofollow" target="_blank">自顶向下设计</a>和<a class="ae lr" href="https://en.wikipedia.org/wiki/Skeleton_(computer_programming)" rel="noopener ugc nofollow" target="_blank">框架代码</a>等主题。一旦我们完成了API，如果您有兴趣继续深入，请阅读额外的“集成测试”部分和/或可选的“创建登录页面”和“部署到Vercel”部分。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3a1c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">成品代码</h1><p id="9eef" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">和往常一样，这个项目的代码可以在GitHub上找到:<a class="ae lr" href="https://github.com/chroline/words-aas" rel="noopener ugc nofollow" target="_blank">https://github.com/chroline/words-aas</a>。如果你有兴趣看最终产品，请参观https://words-aas.vercel.app/。您可以在此URL上测试API路由。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f10b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">目标</h1><p id="6feb" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">对于这个项目，我们将创建一个基本的API，让它的最终用户基于给定的查询随机生成短语；你可以把它想象成一台电脑在填补一个MadLibs游戏的空白。让我们看一些查询和可能的响应的例子:</p><ul class=""><li id="b529" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq nc nd ne nf bi translated"><code class="fe ng nh ni nj b">the $animal jumped over the $noun</code>可能会用<code class="fe ng nh ni nj b">the cow jumped over the moon</code>或<code class="fe ng nh ni nj b">the cat jumped over the river</code>来回应。</li><li id="6bbf" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated"><code class="fe ng nh ni nj b">I like $gerund $pluralNoun</code>可能会用<code class="fe ng nh ni nj b">I like dancing cars</code>或<code class="fe ng nh ni nj b">I like bubbling buildings</code>来回应。</li><li id="87c5" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated"><code class="fe ng nh ni nj b">my $bodyPart is $adjective</code>可能会用<code class="fe ng nh ni nj b">my tonsil is arrogant</code>或<code class="fe ng nh ni nj b">my forearm is dumb</code>来回应。</li></ul><p id="3b26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这些例子中可以看出，前面有<code class="fe ng nh ni nj b">$</code>字符的单词类型通知API用一个单词替换它。它将替换的单词是从API将访问的单词列表中随机生成的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8c2c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">API设计</h1><p id="9090" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在我们开始为项目编码之前，让我们计划API将如何工作，然后我们计划如何组织我们的代码。</p><h2 id="54d6" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">路线</h2><p id="d868" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">Next.js API路由遵循REST(表述性状态转移)协议，这是大多数internet APIs使用的标准化协议。因此，我们在设计API的路由时有很大的灵活性。</p><p id="e792" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个API将接受两个路由:一个路由将接受一个slug，而另一个路由将接受一个带有<code class="fe ng nh ni nj b">query</code>属性的JSON对象。</p><ul class=""><li id="2b7e" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq nc nd ne nf bi translated"><strong class="kx ir"> Slug route: </strong>在web开发中，<em class="ls"> slug </em>是URL的唯一标识符，通常位于URL的末尾。例如，在URL <code class="fe ng nh ni nj b">https://example.com/blog/this-is-the-post</code>中，slug可能是<code class="fe ng nh ni nj b">this-is-the-post</code>。对于这个API，URL看起来类似于:<code class="fe ng nh ni nj b">http://localhost:3000/api/[slug]</code>，其中<code class="fe ng nh ni nj b">[slug]</code>被替换为所需的查询。因为这个路由的URL会根据请求而改变，所以它被称为一个<em class="ls">动态路由</em>。这个API路由将通过向服务器发送一个带有所需查询URL的<code class="fe ng nh ni nj b">GET</code>请求来执行。</li><li id="9532" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated"><strong class="kx ir">请求主体API路由:</strong>该API路由将接受以下格式的JSON对象:<code class="fe ng nh ni nj b">{ "query": QUERY }</code>，其中<code class="fe ng nh ni nj b">QUERY</code>是所需的格式。此API路由不会简单地通过更改URL来执行；它必须通过对服务器的<code class="fe ng nh ni nj b">POST</code>请求来执行，请求的主体是具有所述格式的对象。</li></ul><p id="22e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些路由都将被写成lambda函数，函数接受一个<code class="fe ng nh ni nj b">req</code>请求参数(用于与用户请求交互)和一个<code class="fe ng nh ni nj b">res</code>响应参数(用于与发送回用户的响应数据交互)。</p><h2 id="65ae" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">什么是lambda函数？</h2><p id="b0b2" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在计算机科学理论术语中，<em class="ls"> lambda函数</em>是任何不绑定到标识符的函数，也称为<em class="ls">匿名函数</em>。lambda函数背后的理论来自lambda微积分领域。本质上，它们允许函数作为参数传递给其他函数。</p><p id="f9ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在无服务器计算方面，短语<em class="ls"> lambda function </em>因AWS Lambda服务而流行，该服务允许您编写充当API端点的函数(类似于我们将对Next.js API routes所做的)。就像计算机科学理论中的定义一样，这些无服务器lambda函数不绑定到任何服务器，而是在到达API端点时提供给无服务器服务调用(因此与计算机科学理论lambda函数的“函数作为参数传递”质量相匹配)。</p><h2 id="2e9d" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">代码基础结构</h2><p id="1554" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">Next.js项目的最基本结构如下:</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="7645" class="np mb iq nj b gy of og l oh oi">- pages<br/>  - index.js<br/>- package.json</span></pre><p id="cea9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">pages/index.js</code>文件代表你网站路由器的索引位置。如果你有一个<code class="fe ng nh ni nj b">/about</code>页面，这将对应于<code class="fe ng nh ni nj b">pages/about.js</code>文件，等等。</p><p id="ec71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个项目，我们将使用<a class="ae lr" href="https://www.typescriptlang.org/docs/" rel="noopener ugc nofollow" target="_blank">打字稿</a>，所以我们将使用<code class="fe ng nh ni nj b">.tsx</code>而不是<code class="fe ng nh ni nj b">.js</code>。此外，因为我们正在编写API路由，所以它们必须位于<code class="fe ng nh ni nj b">pages/api</code>目录中。</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="1e8d" class="np mb iq nj b gy of og l oh oi">- pages<br/>  - api<br/>    - index.tsx<br/>    - [slug].tsx<br/>- package.json</span></pre><p id="edf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">api</code>目录中的两个文件将是之前描述的两个API路由:<code class="fe ng nh ni nj b">index.tsx</code>将用于请求体路由，<code class="fe ng nh ni nj b">[slug].tsx</code>将用于slug路由。<code class="fe ng nh ni nj b">[slug].tsx</code>必须用括号<code class="fe ng nh ni nj b">[]</code>括起来，告诉Next.js这是动态路由。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a23e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">建立代码库</h1><h2 id="7e71" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">引导Next.js项目</h2><p id="fde7" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">首先，我们可以创建一个基本的Next.js项目。为此，请运行:</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="8a8d" class="np mb iq nj b gy of og l oh oi">npx create-next-app<br/># or<br/>yarn create next-app</span></pre><p id="3a42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将运行<code class="fe ng nh ni nj b">create-next-app</code> CLI，并提示您输入项目名称。为了这个教程，我称它为<code class="fe ng nh ni nj b">words-aas</code>。</p><h2 id="0275" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">安装依赖项</h2><p id="3355" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">因为这个项目将使用TypeScript，我们将需要安装<code class="fe ng nh ni nj b">typescript</code>依赖项，以及<code class="fe ng nh ni nj b">react</code>、<code class="fe ng nh ni nj b">react-dom</code>和<code class="fe ng nh ni nj b">node</code>的类型依赖项。这些依赖项仅用于开发，所以我们将用<code class="fe ng nh ni nj b">-D</code>标志将它们添加到<code class="fe ng nh ni nj b">devDependencies</code>中。</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="df2b" class="np mb iq nj b gy of og l oh oi">yarn add -D typescript @types/react @types/react-dom @types/node</span></pre><h2 id="5153" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">创建util/api.ts文件</h2><p id="339c" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">这个文件将包含API的所有逻辑。由于我们将拥有多个共享相同逻辑的API路径，因此我们应该坚持DRY(不要重复)原则，将逻辑抽象到一个单独的文件中，以便以后导入。这样，我们可以将所有复杂的API逻辑从实际的API路径中分离出来，这将使开发更加高效。</p><p id="9ae9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据您项目的结构，您可以创建/使用一个与<code class="fe ng nh ni nj b">util</code>目录相对的<code class="fe ng nh ni nj b">lib</code>目录。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="35c9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">创建框架API路由</h1><p id="e43d" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在我们编写API逻辑之前，我们可以创建两个框架API路由。Next.js在<code class="fe ng nh ni nj b">pages/api</code>文件夹中存放API路由，因此我们将创建以下两个文件:</p><ul class=""><li id="b6ec" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq nc nd ne nf bi translated"><code class="fe ng nh ni nj b">pages/api/[slug].ts</code>—slug API路线。用括号将<code class="fe ng nh ni nj b">slug</code>括起来会告诉Next.js这是一个动态路由，slug会被传递给lambda函数。</li><li id="6732" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated"><code class="fe ng nh ni nj b">pages/api/index.ts</code> —请求体API路由。这个路由接受一个JSON对象，所以没有必要使它成为一个动态路由。</li></ul><p id="d8d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这两个文件中，我们将创建一个基本的API路径:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0a52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了测试这些API路径，在您的项目中运行<code class="fe ng nh ni nj b">yarn dev</code>或者简单地运行<code class="fe ng nh ni nj b">next</code>。然后，在浏览器中访问<code class="fe ng nh ni nj b">http://localhost:3000/api</code>和/或<code class="fe ng nh ni nj b">http://localhost:3000/api/[slug]</code> ( <code class="fe ng nh ni nj b">[slug]</code>可以是任意字符串)。你应该会得到<code class="fe ng nh ni nj b">Hello, world!</code>的回应。</p><h2 id="9f13" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">段塞API路线</h2><p id="891f" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">slug API路由将获取一个slug字符串，并将其转换为一个短语。如前所述，slug将由逗号<code class="fe ng nh ni nj b">,</code>连接的单词类型列表组成。</p><p id="d4f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为slug API路由是一个动态路由，slug会在<code class="fe ng nh ni nj b">req.query</code>对象中传递给我们。我们需要明确告诉TypeScript,<code class="fe ng nh ni nj b">req.query</code>对象包含一个<code class="fe ng nh ni nj b">slug</code>属性，因此我们可以使用类型注释(<code class="fe ng nh ni nj b">as { slug: string }</code>)来解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a49f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要测试这条路线，在浏览器中访问<code class="fe ng nh ni nj b">http://localhost:3000/api/the $pluralNoun is $gerund</code>，你输入的slug应该就是给你的响应。</p><h2 id="2375" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">请求正文API路由</h2><p id="aab5" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">与slug API路由相比，请求体API路由为所需短语提供了更多的可定制性。因此，我们将需要操作所提供的查询字符串，将其转换为单词类型的数组，就像我们对slug API路由所做的那样。</p><p id="da0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为这个API路由接受一个JSON对象，我们将使用<code class="fe ng nh ni nj b">req.body</code>对象，而不是<code class="fe ng nh ni nj b">req.query</code>对象。我们还将明确告诉TypeScript】对象包含一个<code class="fe ng nh ni nj b">query</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="94e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要测试这条路线，可以打开一个类似失眠或邮差的REST客户端，测试向<code class="fe ng nh ni nj b">http://localhost:3000/api</code>发送一个带有<code class="fe ng nh ni nj b">query</code>属性的JSON对象。</p><p id="44ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要了解有关测试这些路线的更多信息，请向下滚动到奖金整合测试部分。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="aefd" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">编写API逻辑</h1><p id="a34e" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">有趣的部分来了！既然我们已经在主干API路由中将短语分成了单独的单词/单词类型，我们可以打开<code class="fe ng nh ni nj b">util/api.ts</code>文件来编码API逻辑。</p><p id="131b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建API逻辑，我们将遵循<em class="ls">自顶向下的设计</em>实践，其中我们将总的API逻辑(系统)分解成单独的功能(称为子系统)。使用这种实践，我们可以在完成系统时将所有单独的子系统放在一起，这使得我们比从底层开始更有效率。</p><p id="0108" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下功能将存在于<code class="fe ng nh ni nj b">util/api.ts</code>文件中。</p><h2 id="9499" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">getWordFile</h2><p id="215c" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><code class="fe ng nh ni nj b">getWordFile</code>函数接受一个<code class="fe ng nh ni nj b">wordType: string</code>参数，并返回与给定单词类型匹配的单词列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="c43d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此函数<code class="fe ng nh ni nj b">fetch</code>为给定的单词类型创建文件。如果你是一个精明的全栈开发者，你可能会注意到我们其实是在服务器端使用<code class="fe ng nh ni nj b">fetch</code>，你可能会疑惑“fetch不是只在浏览器端支持吗？<em class="ls"> " </em>是的，<code class="fe ng nh ni nj b">fetch</code> API只在浏览器中被本机支持，但是Next.js为<code class="fe ng nh ni nj b">fetch</code> API提供了一个polyfill，所以我们可以在后端使用它！</p><p id="6891" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">word文件将位于<code class="fe ng nh ni nj b">public/db</code>文件夹中。要下载它们在你自己的项目中使用，你可以<a class="ae lr" href="https://github.com/chroline/words-aas/releases/tag/word-files" rel="noopener ugc nofollow" target="_blank">下载word文件夹</a>。</p><h2 id="772c" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">getRandomWord</h2><p id="de56" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><code class="fe ng nh ni nj b">getRandomWord</code>函数接受一个<code class="fe ng nh ni nj b">contents: string</code>参数，并从给定的内容中返回一个随机单词。</p><p id="3251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">contents</code>字符串是来自<code class="fe ng nh ni nj b">getWordFile</code>函数的返回值，是一个word文件的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="26d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数用一个空白字符串替换所有回车符。然后，我们可以将<code class="fe ng nh ni nj b">contents</code>字符串拆分成一个单词列表。从这个单词列表中，我们可以找到一个随机元素并返回它。</p><h2 id="9d9f" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">短语生成器</h2><p id="7020" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><code class="fe ng nh ni nj b">phraseGenerator</code>函数接受一个<code class="fe ng nh ni nj b">words: string[]</code>参数，并从给定的单词中返回转换后的短语。</p><p id="0060" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ng nh ni nj b">words</code>参数是我们之前在slug和request主体路由中获得的单词类型列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="be71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数遍历<code class="fe ng nh ni nj b">words</code>参数中的所有单词类型，并基于以下条件构建短语:</p><ul class=""><li id="f5a3" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq nc nd ne nf bi translated">如果单词是空的，或者第一个单词是<em class="ls"> a </em>(记住，以<em class="ls"> a </em>开头的短语是我们后面会处理的边缘情况)，我们会忽略它和<code class="fe ng nh ni nj b">continue</code>。</li><li id="1941" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated">如果单词以<code class="fe ng nh ni nj b">$</code>字符开头，那么它就是我们需要处理的单词类型:如果该单词类型不包含在数据库中，则抛出一个错误。否则，从该单词类型中随机选择一个单词，并将其添加到短语中。</li><li id="1b00" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated">否则，只需将单词添加到短语中。</li></ul><p id="03c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了一个(几乎)完全生成的短语！因为结尾会有一个额外的空格，所以我们可以把它去掉。</p><h2 id="c69f" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">vowelTester</h2><p id="dec2" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><code class="fe ng nh ni nj b">vowelTester</code>函数接受一个<code class="fe ng nh ni nj b">phrase: string</code>参数并返回一个布尔值。</p><p id="73f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数用于确定所提供的<code class="fe ng nh ni nj b">phrase</code>中的第一个字母是否是元音字母，然后用于确定第一个单词<em class="ls"> a </em>是否应该转换为<em class="ls">a</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="240f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数使用一个RegExp表达式，该表达式全局(<code class="fe ng nh ni nj b">g</code>)测试元音字母(<code class="fe ng nh ni nj b">[aeiou]</code>)是小写还是大写(<code class="fe ng nh ni nj b">i</code>)。</p><h2 id="9119" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">短语解析器</h2><p id="09f9" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><code class="fe ng nh ni nj b">phraseResolver</code>函数接受一个<code class="fe ng nh ni nj b">query: string</code>参数并返回一个<code class="fe ng nh ni nj b">phrase</code>字符串。</p><p id="b2f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该功能将之前的所有子系统集合在一起。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8acc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每出现一个空格字符，就会将<code class="fe ng nh ni nj b">query</code>分开。从那些<code class="fe ng nh ni nj b">words</code>中生成一个短语。如果第一个<code class="fe ng nh ni nj b">word</code>是<em class="ls"> a </em>，该函数测试元音以确定该单词是否应该保持为<em class="ls"> a </em>或<em class="ls">a</em>。最后，返回<code class="fe ng nh ni nj b">phrase</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="d8d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唷，那是许多编码和许多(希望)简单的逻辑。可以在GitHub 上查看<a class="ae lr" href="https://github.com/chroline/words-aas/blob/main/util/api.ts" rel="noopener ugc nofollow" target="_blank">完整文件进行回顾。</a></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b01d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">把它们放在一起</h1><p id="af5e" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">现在我们已经编写了API逻辑，我们可以将它连接到我们之前创建的框架API路由。</p><h2 id="7fda" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">段塞API路线</h2><p id="0ad4" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">下面是slug API路径的最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b7f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们尝试从给定的slug中解析一个短语。如果成功，我们将它作为JSON对象发送给用户。然而，如果不成功，我们告诉用户我们遇到了一个错误。例如，如果用户请求数据库中不存在的单词类型，这可能会发生。</p><h2 id="27ea" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">请求正文API路由</h2><p id="0a48" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">请求体API路由的代码与slug API路由几乎相同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="807a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们抽象了API逻辑，所以我们可以简单地从两个API路径的lambda函数中的<code class="fe ng nh ni nj b">util/api.ts</code>文件导入<code class="fe ng nh ni nj b">phraseResolver</code>函数。</p><p id="0cce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能会注意到，两个lambda函数中的逻辑也几乎完全相同。我们能不能也把这个逻辑抽象出来，以便完全遵守干燥原则？是的，我们可以，但是将<code class="fe ng nh ni nj b">req</code>和<code class="fe ng nh ni nj b">res</code>对象封装在lambda函数本身中通常被认为是最佳实践。这使得lambda函数更容易理解，因为程序员可以立即看到从<code class="fe ng nh ni nj b">req</code>对象中读取了什么，以及用<code class="fe ng nh ni nj b">res</code>对象将什么发送回最终用户。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ced7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">额外收获:集成测试</h1><p id="a702" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在软件开发的世界里，有两种主要类型的代码测试:单元测试和集成测试。</p><ul class=""><li id="4a99" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq nc nd ne nf bi translated"><strong class="kx ir">单元测试</strong>包括将你的代码分解成可以测试的最小单元。如果你的代码库使用适当的自顶向下设计，你的代码已经被分解成小的代码单元:每个单独的功能都是可以测试的单元。</li><li id="caf5" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq nc nd ne nf bi translated">集成测试包括测试你的项目/服务作为一个整体的行为。单元测试会测试每个单独的子系统，而集成测试会测试整个系统本身。</li></ul><p id="dddb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个项目，集成测试更有意义，因为使用的逻辑数量很少。(对于较大的项目，考虑使用单元测试和集成测试的组合来获得最彻底的结果。)</p><p id="2767" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您使用的是WebStorm或IntelliJ之类的JetBrains IDE，请遵循方法一。否则，遵循方法二。</p><h2 id="7511" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">方法一:使用JetBrains IDEs</h2><p id="2cf0" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">适合web开发的JetBrains IDEs有一个内置的方法来测试RESTful API——也就是遵守REST协议的API。</p><p id="b00e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">打开您的项目并创建一个名为<code class="fe ng nh ni nj b">test</code>的新HTTP文件。然后输入以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="038f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码对API运行两个请求:第一个测试slug路由，第二个测试请求体路由。</p><p id="1bc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦您通过在您的项目中运行<code class="fe ng nh ni nj b">yarn dev</code>或<code class="fe ng nh ni nj b">next</code>启动了您的开发服务器，点击“运行文件中的所有请求”按钮并选择“无环境运行”窗口底部应该会打开一个新面板。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/32cf2632abd5198d50c3a85829454cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iodtpobcAyr7gaA2aWGatg.png"/></div></div></figure><p id="9ca7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一切顺利，您应该会在“All in test”旁边看到一个绿色的复选标记，这意味着您的所有请求都已成功完成。要验证请求的结果，您可以单击输出中的文件名，这将显示来自服务器的响应文本。</p><h2 id="a224" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">方法二:使用REST客户端</h2><p id="6297" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">有很多很棒的REST客户端可以用来测试你的RESTful API。最受欢迎的两个是<a class="ae lr" href="https://www.postman.com/product/rest-client/" rel="noopener ugc nofollow" target="_blank">邮差</a>和<a class="ae lr" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>。我将使用Postman，但大多数步骤应该与Postman或其他REST客户端类似。</p><p id="1d81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，创建一个新文件夹，并将其命名为API test。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/be8f46e19be5a69ef7c4a199b4e4bc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2kVA4TjiQWhmG6Rk7dMWg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/a8da90e83aa25485e27bdc17cc384b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8U7JqQECICO8vTGT4Nruyw.png"/></div></div></figure><p id="306c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后添加两个请求:</p><ol class=""><li id="1bf1" class="mx my iq kx b ky kz lb lc le mz li na lm nb lq on nd ne nf bi translated"><strong class="kx ir">蛞蝓路线</strong> : <code class="fe ng nh ni nj b">GET &lt;http://localhost:3000/api/[slug]</code> &gt;(用短语替换<code class="fe ng nh ni nj b">[slug]</code>进行测试。)</li><li id="27c0" class="mx my iq kx b ky nk lb nl le nm li nn lm no lq on nd ne nf bi translated"><strong class="kx ir">请求车身路线</strong> : <code class="fe ng nh ni nj b">POST &lt;http://localhost:3000/api</code> &gt;。将body类型切换到JSON，并输入一个类似<code class="fe ng nh ni nj b">{ "query": "$gerund $pluralNoun" }</code>的演示请求对象</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/393b7202ba90846a19f939fb7518c809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOKBshlx77gQGKMCPh_Pjg.png"/></div></div></figure><p id="a998" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以发送这两个请求，如果它们成功，您应该会在窗口的右侧面板上看到响应。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b610" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">包扎</h1><p id="4184" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">恭喜，我们已经使用Next.js完成了我们的简单API项目！</p><p id="fc35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们刚刚做的是基础的，但是希望它给你一个很好的概述，在Next.js中为API路由编写lambda函数是什么样的。如果您觉得本教程有帮助，请继续关注关于使用Next.js编写API的更高级实践的教程</p><p id="2c4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你对这个项目感兴趣，请阅读下面的可选和额外部分，给你的项目一个额外的完成感。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7efc" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">可选:创建登录页面</h1><p id="9571" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">为了吸引更多的用户，考虑为您的服务添加一个有吸引力的登录页面。Next.js不仅非常适合创建无服务器API路由，它还是React的框架。这意味着您可以在同一个项目中创建您的前端站点和后端逻辑。</p><p id="252e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.js路由器将URL的路径名对应到<code class="fe ng nh ni nj b">pages</code>目录中的同名文件。例如，<code class="fe ng nh ni nj b">/about</code>会对应<code class="fe ng nh ni nj b">about.tsx</code>或<code class="fe ng nh ni nj b">about.js</code>档，<code class="fe ng nh ni nj b">/</code>会对应<code class="fe ng nh ni nj b">index.tsx</code>或<code class="fe ng nh ni nj b">index.js</code>档。要制作主页，在<code class="fe ng nh ni nj b">pages</code>目录下创建一个<code class="fe ng nh ni nj b">index.tsx</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="478d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe ng nh ni nj b">pages</code>目录下的每个文件中，应该有一个默认的导出函数。当Next.js检索您的文件时，将呈现这个函数。因此，当您的路径为<code class="fe ng nh ni nj b">/</code>时，将渲染<code class="fe ng nh ni nj b">Home</code>函数中的JSX。</p><p id="be9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">利用你的React技能为你的Next.js服务创建一个登陆页面。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="94d1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">可选:部署到Vercel</h1><p id="bdd8" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated"><a class="ae lr" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>是一个专门为Next.js开发的平台，它为用Next.js创建的API路由提供一流的支持，使用它们的CLI，您可以轻松地将您的Next.js项目部署到Vercel，并与世界共享。</p><h2 id="d4d3" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">下载Vercel CLI</h2><p id="bee9" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">要下载Vercel CLI，请运行:</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="3b2c" class="np mb iq nj b gy of og l oh oi">yarn global add vercel</span></pre><p id="58a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能必须在sudo模式下运行这个命令(只有在绝对必要的情况下)。</p><h2 id="7e5b" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">登录到Vercel</h2><p id="3841" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在部署您的项目之前，您必须首先登录到Vercel。运行:</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="b04f" class="np mb iq nj b gy of og l oh oi">vercel login</span></pre><p id="9402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将提示您在浏览器窗口中登录到Vercel。</p><h2 id="b115" class="np mb iq bd mc nq nr dn mg ns nt dp mk le nu nv mm li nw nx mo lm ny nz mq oa bi translated">部署</h2><p id="2ef0" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">登录到Vercel后，只需运行以下命令即可进行部署:</p><pre class="kg kh ki kj gt ob nj oc od aw oe bi"><span id="464d" class="np mb iq nj b gy of og l oh oi">vercel</span></pre><p id="9d70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">按照步骤部署您的项目。</p><p id="dd54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">部署成功后，它应该会为您提供一个指向您托管的项目的链接。现在你可以和你的朋友分享，并向他们展示你的成果！</p></div></div>    
</body>
</html>