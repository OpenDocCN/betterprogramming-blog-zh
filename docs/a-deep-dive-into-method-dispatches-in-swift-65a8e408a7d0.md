# 深入了解 Swift 中的方法调度

> 原文：<https://betterprogramming.pub/a-deep-dive-into-method-dispatches-in-swift-65a8e408a7d0>

## 静态、垂直表和消息调度

![](img/7af0c1ff7494b073288404505f43b80a.png)

由 [Philippe Oursel](https://unsplash.com/@ourselp?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

想知道 Swift 中的方法调用是如何工作的吗？看起来很简单，你定义了方法，在运行时，方法调用神奇地工作了，即使有很多事情要处理，比如继承导致的重写方法，方法调用优化等等。

在这篇短文中，我们将了解 Swift 中可用的不同类型的方法分派。在讨论分派时，我们还将讨论编译器和运行时为了实际处理方法调用而进行的一些优化。

所以让我们开始吧。

# 什么是方法调度？

方法分派是在编程语言中管理函数调用的过程。

让我们试着解释一下当你调用一个方法时会发生什么。编译器如何知道方法在哪里？当你有多个子类时，编译器如何知道调用哪个方法？毫不奇怪，所有这些都在编译时和运行时得到了解决。

对类类型或值类型中定义的每个方法的调用可以通过三种方式解决:

1.  静态调度
2.  虚拟表调度
3.  信息发送

# 1.静态调度

如果一个方法不能被重写，则该方法是静态调度的。

这种类型的方法调度是所有调度中最简单和最快的。其速度之所以如此之快，是因为给定函数不能被覆盖，这意味着该方法只有一个实现会在运行时存储在内存中的某个位置。运行时可以直接跳转到那个内存地址并执行它(不像您将看到的其他调度)。

您始终可以使用以下关键字指定使用静态分派的方法:

*   `static`
*   `final`

另一方面，这也是在值类型中声明的函数的默认调度方法，因为根据定义，值类型不能被重写。

# 2.虚拟表调度

这是 Swift 中用于参考类型的默认分派方法。

在这种方法中，在编译时创建一个查找表，指定需要在运行时调用的方法的实际实现。在运行时，这个查找表作为一个地址数组保存在内存中实现所在的实际位置。

这种分派成为引用类型的默认分派方法的原因是，类需要支持继承。V 表通过生成对重写方法和非重写方法的正确调用来帮助继承类。

因此，如果您有一个类似下面的设置，运行时会计算出何时需要调用`ChildClass`类而不是`SuperClass`类中的实现:

下一个问题显然是运行时如何确定调用哪个方法？

事情是这样的，类的方法实现存储在一个名为*调度表*的数组中(也称为`vtable`或`witness`表，稍后会详细介绍)。

每个类，即`ChildClass`和`SuperClass`，都有自己的表，这些表包含指向实际方法实现的指针。

V 表是在编译时在 [SIL](https://github.com/apple/swift/blob/main/docs/SIL.rst#vtables) (Swift 中间语言)生成期间计算的，需要调用的实际方法实现是在运行时计算出来的。基本上，您可以将 V-Table 视为一个表查找，它为实际的函数实现分配一个惟一的标识符。在为子类生成的表中也提供了每个超类实现，因此本质上只有一个额外的操作需要在运行时执行，即在运行时从 V 表中计算出当调用该方法时需要调用该方法的哪个实现。

下面先睹为快，看看 SIL 生成的 V-Table 看起来像上面的代码片段。

从上面生成的代码中可以看到，`ChildClass`和`SuperClass`在它们的 V 表中都声明了所有可用的方法。

还要注意，对于两个类的`nonOverriddenMethod`,方法标识符(类似于出现在每行末尾的`@$SilGen10SuperClass…`的字符串)是相同的(因为`ChildClass`没有覆盖它),但是对于`overrideMethod`声明是不同的(因为它们有不同的实现)。

如果您想进一步了解实际调用是如何发生的，您可以使用以下命令生成 SIL:

```
swiftc -emit-silgen -O <swift-file-name>.swift
```

您将发现更多关于 SIL 生成的代码在调用站点实际使用的信息。

# 3.信息发送

这是一个有趣的方法，尽管它可能会导致一些性能下降，所以了解何时使用它很重要！在前面的部分中，我们看到了如何使用 V-Table 分派来推迟决定需要在运行时调用方法的哪个实现，但是我们还有另一个问题。为了理解这个问题，我们需要追溯历史。

## 很久很久以前…

Objective-C 是一种非常依赖于运行时的语言。我这样说是什么意思？

这意味着 Objective-C 为我们提供了在运行时执行大量代码检查和更改代码实现的能力。

这种语言通常将其许多任务推迟到运行时，这样可以加快编译速度。

这在运行时支持许多功能，例如:

*   使用一个名为`isMemberOfClass`的函数检查一个实例是否属于一个特定类型的类。或者如果您想检查它是否属于继承层次中的某个特定类，您可以使用`isKindOfClass`。
*   使用一个叫做`respondsToSelector`的函数检查一个类是否能响应一个特定的方法
*   使用所谓的*方法重组*在运行时动态改变方法实现
*   使用`class_addMethod`在运行时添加方法实现

还有很多。所有这些都要归功于一个名为 Objective-C 运行时库的库，它嵌入在`NSObject`使用的 Objective-C 中。鉴于 Objective-C 中的几乎每个类都必须从这个类继承，这些功能几乎在任何地方都可用。

现在我们知道了 Objective-C 是一种非常灵活的运行时语言，你可以改变方法实现，添加方法实现等等。，都是在运行时。这可能会对 V 表分派的方式造成问题，因为 V 表是在编译时生成的。编译时生成的 V-Table 可能不代表需要调用的方法的正确实现，因为它可能已经被重新整理过，或者可能已经在运行时添加了新方法。

消息分派是对上述问题的解决方案，其中在运行时维护不同的表。在实际调用过程中，运行时在这个表上进行查找，以找出进行调用的实际方法地址。

使用动态分派的方法不包括在编译时生成的 V 表中，因为由于 Objective-C 的运行时功能，这些方法在运行时可能会被替换。

对于所有需要动态调度的成员，这是 Objective-C 中的默认调度方法。

## `dynamic`和`@objc`

这一节从更深的意义上探讨 SIL 生成的代码。这里提供的唯一理论如下:`dynamic`关键字在 Swift 中用于为需要它的方法启用动态分派(例如，在方法切换或 KVO 相关代码中),而`@objc`用于将该方法公开给 Objective-C

在 Swift 3 之前，所有动态成员都自动暴露给 Objective-C，但从 Swift 4 开始，您必须在需要暴露给动态调度的方法前面明确提到`dynamic`和`@objc`。

在 Swift 中，需要用作`selector`对象的方法必须用`@objc`来声明，因为这些方法仍然需要向 Objective-C 公开。这里使用的目标动作机制仍然是用 Objective-C 编写的

例如，当您向代码中创建的`UIBarButton`添加通知观察器或方法时(使用[目标动作](https://www.notion.so/Target-Action-Selector-239ebc1b81004f1c8a11d60478f77718)机制，等等)。)这些方法使用 Obj-C 的运行时功能来调用这些方法。

从现在开始，这将是对 SIL 生成的代码的一个小小的探索，而且不会很好看。让我们以一个简单的类为例:

为此类生成的垂直表如下所示:

V 表不包含对`dynamicMethod`的声明，因为它附加了`dynamic`关键字。

SIL 还为每种方法生成两个版本。一个是 Objective-C(第 10 行和第 33 行)，一个是 Swift 中的实际实现(第 2 行和第 24 行)。Objective-C 公开的方法反过来调用 Swift 实现本身，这是当您向 Objective-C 公开一个方法时发生的运行时开销。

以下是 SIL 生成的函数实现代码:

在呼叫站点，SIL 看起来如下:

如果您看过去第 23 行，在那里生成了对`dynamicMethod`的调用，您可以看到一个名为`foreign`的新关键字，它在调用`objcMethod`的第 18 行没有出现。该关键字表示现在方法实现调用不再由 Swift V-Table 处理，而是由其他系统处理。

# 结论

总而言之，我希望您从这篇文章中学到的是三种类型的派遣以及与它们相关的权衡。

如果阅读本文的目的只是为面试做准备或只是为了理解理论，那么进入 SIL 可能是没有必要的，尽管 SIL 生成的代码可以进行完全不同的技术内省，最好通过在您的系统上实际生成该代码来完成。

# 有用的链接

这里是我在学习方法分派时浏览的一些链接。

*   [Method Dispatches in Swift—right point](https://www.rightpoint.com/rplabs/switch-method-dispatch-table)(这可能有点过时，但这里的理论仍然有效。)
*   [@objc 和动态 SIL 演练— Swift 拆箱](https://swiftunboxed.com/interop/objc-dynamic/)
*   [减少动态调度——苹果 Swift 博客](https://developer.apple.com/swift/blog/?id=27)