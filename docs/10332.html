<html>
<head>
<title>Hiding Ransomware in a TensorFlow Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在张量流模型中隐藏勒索软件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hiding-ransomware-in-tensorflow-model-fdefbaabe86a?source=collection_archive---------9-----------------------#2021-12-28">https://betterprogramming.pub/hiding-ransomware-in-tensorflow-model-fdefbaabe86a?source=collection_archive---------9-----------------------#2021-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">保护您的模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57272edd3145bd5e2a787b5b46f8f944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_E9C0DFDjyuU2H38.jpg"/></div></div></figure><p id="13c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">预训练模型在机器学习过程中起着重要的作用。对象检测模型依赖于预先训练的图像网络。与从头开始训练模型相比，对预训练模型进行微调通常是更好的选择。</p><p id="982c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，如果有人可以隐藏勒索软件或一些间谍软件-窃取您的宝贵数据到这些模型之一呢？如果可以直接用TensorFlow写勒索软件会怎么样？这篇文章将详细介绍什么是可能的。</p><blockquote class="lq lr ls"><p id="5252" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it">免责声明:</em> </strong>这篇文章旨在对使用预训练模型的潜在危险进行教育概述，而不是作为创建模型的指南。</p></blockquote><p id="f003" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今年，我帮助准备了2021年欧洲网络安全挑战的挑战。我创建的挑战是关于逆转用TensorFlow编写并存储为TensorFlow模型的勒索软件，该模型在用于推理时会加密数据(在我的程序中只有图像)。</p><p id="34a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文不会解释如何解决这个挑战，而是给出一些关于它是如何创建的细节。在本文的其余部分，我将假设使用TensorFlow 2.4.1。</p><h1 id="ce00" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">张量流模型格式</h1><p id="4c9d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果我们使用流行的<code class="fe mv mw mx my b">tf.keras.Model</code>类来构建模型，它提供了一个简单的<code class="fe mv mw mx my b">save(...)</code>函数。该功能允许以两种格式保存模型:</p><ul class=""><li id="3d76" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><a class="ae lx" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank"> TensorFlow SavedModel </a></li><li id="e336" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format" rel="noopener ugc nofollow" target="_blank"> HDF5 </a></li></ul><p id="be92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HDF5的好处是将一个模型保存到单个文件中，但似乎对文件内容要求更严格。在这篇文章中，我们将使用<code class="fe mv mw mx my b">Tensorflow SavedModel</code>,因为它允许我们保存更复杂的函数。</p><h1 id="8631" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">读取和写入文件</h1><p id="b660" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">读写是创建勒索软件的关键IO功能。将这些函数存储在保存的模型中是最重要的一步。</p><p id="5124" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有读取文件的功能并不奇怪。毕竟数据管道是每个机器学习项目的重要组成部分。因此TensorFlow提供了许多功能来优化这一过程。我们将使用的两个主要软件包是<code class="fe mv mw mx my b">tf.io</code>和<code class="fe mv mw mx my b">tf.data</code>。</p><p id="3134" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lx" href="https://www.tensorflow.org/api_docs/python/tf/io" rel="noopener ugc nofollow" target="_blank"> tf.io </a>提供低级输入输出操作。我们将使用函数<code class="fe mv mw mx my b">tf.io.read_file(...)</code>和<code class="fe mv mw mx my b">tf.io.write_file(...)</code>。这些函数的伟大之处在于它们可以将文件直接读入<code class="fe mv mw mx my b">tf.Tensor</code>或将<code class="fe mv mw mx my b">tf.Tensor</code>写出到文件中。而且，这些函数可以保存为SavedModel格式。</p><p id="ef78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，棘手的部分是列出文件。勒索软件不能依赖静态文件路径。另外，它必须能够列出模型目录之外的文件。</p><p id="6cc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不得不尝试多种不同的函数，因为有些函数一旦保存后总是返回相同的结果。最终，我到达了基于文件模式列出文件的<code class="fe mv mw mx my b">tf.data.Dataset.list_files(...)</code>。此外，该文件模式可以是<code class="fe mv mw mx my b">tf.Tensor</code>的形式。</p><h1 id="9c82" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">勒索软件</h1><p id="8156" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有了这些关键组件，我们就可以开始编写实际的代码了。如下所示，我们通过子类化<code class="fe mv mw mx my b">tf.keras.Model</code>来创建模型。</p><p id="280f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们只需要覆盖预测过程中执行的<code class="fe mv mw mx my b">call(...)</code>函数。在那里，我们执行实际的预测和文件加密。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="085d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我跳过了实际的加密功能。对任意长度的数组使用TensorFlow有一些限制，但是如果有足够的创造力，这应该不是问题。尤其是因为文件可以作为字节数组加载。</p><p id="3bd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最大的问题是遍历目录。截至目前，该代码只加密图像。这显然可以通过检查不同的文件类型和添加用于访问父目录的<code class="fe mv mw mx my b">../</code>来扩展。然而，我没有找到任何简单的方法来检测列出的文件是目录还是实际文件。</p><p id="4fbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个问题是代码实际上非常慢。至少我用于ECSC 2021挑战赛的加密算法是这样的。我想这主要是因为我一个字节接一个字节地运行加密程序，这对于大文件来说会花费很长时间。不过，如果有人设法用优化的矩阵运算来执行加密，我也不会感到惊讶。</p><h1 id="105a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="be2e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我猜，为了创建成功的勒索软件，你需要解决的问题不仅仅是读取文件。另一方面，它仍然关注的是，模型可以读取文件没有任何通知。尤其是因为预先训练的模型是机器学习世界的重要组成部分。</p><p id="6900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我正在开发一个应用程序<a class="ae lx" href="https://feltoken.ai/" rel="noopener ugc nofollow" target="_blank"> feltoken.ai </a>，它专注于使用智能合约创建一个联合学习解决方案。保护数据隐私是联合学习的一个关键部分，在联合学习中，各方只共享最终训练的模型。本文中演示的内容使得使用这种模型格式来共享模型变得不可能，因为这可能会导致数据泄漏。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="b386" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lt">原载于</em>【https://bretahajek.com】<em class="lt"/></p></div></div>    
</body>
</html>