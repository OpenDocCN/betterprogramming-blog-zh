<html>
<head>
<title>2 Years of GraphQL in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两年的GraphQL生产经验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-years-of-graphql-in-production-a1a6dbaddbda?source=collection_archive---------4-----------------------#2020-06-25">https://betterprogramming.pub/2-years-of-graphql-in-production-a1a6dbaddbda?source=collection_archive---------4-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c9a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该避免的常见陷阱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9d529d2d91c0459e06ffebac6ac978f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBKGMklvjbsB1KI0xpCjtw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用GraphQL Voyager生成的关系概述(作者提供照片)。</p></figure><p id="90dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL 因为一些非常好的原因变得越来越流行。我们遇到的一些问题很有挑战性，但都是值得的。我将在本文中使用一个示例设置来演示我们遇到的问题以及如何解决这些问题。</p><p id="2824" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从头开始。我们为什么选择GraphQL？</p><ul class=""><li id="c28e" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">无需担心更新文档。所有的查询和突变都会被自动记录。</li><li id="3b8e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">我们可以编写只返回请求数据的查询，而不是获取整个数据集。</li><li id="053d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">我们前端的一个接入点。从20个不同的API获取所有需要的数据并不有趣。使用GraphQL，我们可以选择将所有这些API缝合成一个。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b754" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">缝</h1><p id="9aea" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">能够从一个端点获取所有数据听起来不错，但是拼接也会导致一些非常糟糕的问题。让我们看看下面的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/05696db520e2a568b73a9ca7b5975c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*yjdIc7krYMcDrZhjAG6OuA.png"/></div></figure><p id="127d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有一个与公共API通信的前端。公共API缝合订单API，订单API缝合产品API。公共API是唯一可以被前端访问的API。这种连接看起来不是一个很大的问题，但是如果你有20个多层的API，发布会变成一场噩梦。</p><p id="76f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么？因为当您更新产品API的模式时，您将需要重新启动订单API和公共API(按照那个顺序)，因为模式需要重新加载。每次更新GraphQL模式时都必须重启十几个API，这肯定不是一件有趣的事情。</p><p id="ffae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可能遇到的另一个问题是当我们想要向上而不是向下查询时——从一个产品到它的父订单。这是行不通的，因为Order API只有在Product API运行时才会启动，因为它需要加载它的模式。</p><p id="d941" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着我们可以获取属于某个订单的产品:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b5af" class="nq mo iq nm b gy nr ns l nt nu">order {<br/>    identifier<br/>    products {<br/>        identifier<br/>    }<br/>}</span></pre><p id="542c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们无法获取属于某个产品的订单:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="28d0" class="nq mo iq nm b gy nr ns l nt nu">products {<br/>    identifier<br/>    order {<br/>        identifier<br/>    }<br/>}</span></pre><p id="617f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这些问题，我们可以重新安排我们缝合API的方式。通过让公共API负责加载所有模式，我们只需要在模式更新时重启一个API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/d9c47ee1212dea8b4c593b5af6957cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYYRWAq20opGjRjyq6x8bw.png"/></div></div></figure><p id="5ea6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为公共API现在获取所有模式，我们可以添加一些代码，用<code class="fe nw nx ny nm b">order</code>属性扩展产品<strong class="kx ir"> </strong>模式。这将使通过产品查询获取订单成为可能。查看Apollo <a class="ae lr" href="https://www.apollographql.com/docs/apollo-server/federation/entities/#extending" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多关于扩展模式的信息。</p><p id="a835" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，并不是所有的查询和变化都可以通过我们的公共API访问。例如，我们不想给我们的客户触发改变支付状态的突变的可能性。解决这个问题的一个方法是过滤掉某些查询和变异。我们可以循环模式中的所有查询和变化，并将它们与列表进行比较。如果查询在列表中，它们将是可见的。否则，它们将从模式中删除。另一种选择是添加一个中间件，检查当前用户是否有权触发某些查询和变异。</p><p id="b7b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们选择了这两个选项的组合。但是现在我们有了另一个问题。因为不是所有的变化都可以通过公共API访问，所以我们需要在更新支付状态时直接调用支付API。这将适用于突变，但不适用于我们所有的查询，因为子对象和父对象只在公共API中缝合。为了解决这个问题，我们必须再次重新安排我们的设置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/cb909d73d748e5e9796f7c3ee9ad9d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu6yiQwZRPT9jKhOEN5tEw.png"/></div></div></figure><p id="be22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将创建一个网关API，并让它负责缝合所有的模式。公共API将缝合网关API，并删除所有不应该通过前端访问的查询和变异。当我们需要在后端进行查询或变更时，我们现在可以使用网关API，因为我们的后端服务位于同一个网络中。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="0440" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">分页查询</h1><p id="4ffa" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">为某些查询实现<a class="ae lr" href="https://graphql.org/learn/pagination/#pagination-and-edges" rel="noopener ugc nofollow" target="_blank">分页</a>绝对是个好主意。我们选择了基于光标的方法，它运行得非常好。当我们想要获取产品时，我们现在可以使用以下查询:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="460c" class="nq mo iq nm b gy nr ns l nt nu">products(first: 5, after: "cursor") {<br/>    edges {<br/>        node {<br/>            identifier<br/>        }<br/>    }<br/>}</span></pre><p id="c66a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，因为我们更改了模式，所以在获取订单及其产品时，我们现在有了一个分页结构:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="5639" class="nq mo iq nm b gy nr ns l nt nu">order {<br/>    products(first: 5, after: "cursor") {<br/>        edges {<br/>            node {<br/>                identifier<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="fdd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们不希望有一个分页的结构，因为对于一个特定的订单只有几个产品。为了解决这个问题，我们可以选择编写两个查询——一个带分页，一个不带分页。或者，当我们将产品<strong class="kx ir"> </strong>组合成一个订单时，我们可以使用模式包装来剥离分页。包装模式是一个非常强大的选项，尤其是当您将所有远程模式整合到一个API中时。更多信息，请参见关于模式包装的<a class="ae lr" href="https://www.graphql-tools.com/docs/schema-wrapping/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f938" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">技巧</h1><p id="f61e" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">这些是我们遇到的最大的问题，但不是唯一的问题。这里有一些技巧可以帮助你构建一个可维护的GraphQL API。</p><ul class=""><li id="6a39" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">类型和枚举应该总是有一个唯一的名称。例如，如果你想给一个产品添加一个状态，把它命名为<code class="fe nw nx ny nm b">ProductStatus</code>而不是<code class="fe nw nx ny nm b">Status</code>，以避免类型冲突的问题。</li><li id="364b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">向查询添加筛选器，而不是编写单独的查询。<a class="ae lr" href="https://swapi.graph.cool/" rel="noopener ugc nofollow" target="_blank">这个API </a>是如何实现过滤器的一个很好的例子(查看docs选项卡并搜索<code class="fe nw nx ny nm b">assetFilter</code>)。</li><li id="0235" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">为您的查询和变异定义一个命名约定。这将更容易找到您正在寻找的查询或变异。</li><li id="6700" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用分页查询时，设置默认值和最大限制。当有人运行查询时，您不希望您的API崩溃。</li><li id="3bfc" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">您可以使用<a class="ae lr" href="https://github.com/APIs-guru/graphql-voyager" rel="noopener ugc nofollow" target="_blank"> GraphQL Voyager </a>来生成您的模式的所有查询、变化和关系的概述。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="422e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">资源</h1><ul class=""><li id="2a0c" class="ls lt iq kx b ky nf lb ng le nz li oa lm ob lq lx ly lz ma bi translated"><a class="ae lr" href="https://www.apollographql.com/docs/apollo-server/features/schema-stitching/#:~:text=Combining%20multiple%20GraphQL%20APIs%20into,we%20need%20in%20one%20request." rel="noopener ugc nofollow" target="_blank">用Apollo服务器拼接GraphQL模式</a></li><li id="564f" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://www.apollographql.com/docs/apollo-server/federation/entities/#extending" rel="noopener ugc nofollow" target="_blank">扩展GraphQL模式中的类型</a></li><li id="0b0a" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://graphql.org/learn/pagination/#pagination-and-edges" rel="noopener ugc nofollow" target="_blank"> GraphQL基于光标的分页</a></li><li id="d040" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><a class="ae lr" href="https://www.graphql-tools.com/docs/schema-wrapping/" rel="noopener ugc nofollow" target="_blank">模式包装</a></li></ul></div></div>    
</body>
</html>