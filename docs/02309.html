<html>
<head>
<title>The Builder Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的生成器模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-builder-pattern-in-javascript-6f3d85c3ae4a?source=collection_archive---------1-----------------------#2019-11-21">https://betterprogramming.pub/the-builder-pattern-in-javascript-6f3d85c3ae4a?source=collection_archive---------1-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6978" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用构建器模式构建代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/393bb499c5610da13fd2e43195c14892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-nSYrQ_GwHTim7I_QZv-A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@iurte?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Iker Urteaga </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="24df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用JavaScript开发应用程序时，你有时会发现构造复杂的对象很困难。一旦它在你的代码中达到这一点，它就变得更加重要，因为随着你的应用程序变大，它会变得更加复杂。</p><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是，有办法将这种复杂性分解成简单和更小的步骤，这就是我们今天要讨论的内容。</p><p id="bfb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍一种在这些情况下会对您有所帮助的设计模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bf4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成器设计模式</h1><p id="82b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将要学习的设计模式通常被称为生成器设计模式，这是一种用于帮助构造复杂对象的模式。它有助于将对象构造从其表示中分离出来，这将有助于我们重用它来创建不同的表示。</p><p id="678f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它规划了以下步骤:</p><h2 id="765f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><em class="nl">基类</em>包含业务逻辑</h2><p id="6d82" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它还接收已创建的对象，并继续设置值。</p><h2 id="a8e5" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">将负责创建对象的代码分成<em class="nl">构建器、</em>构建器，它们最终也只是对象/类</h2><p id="9dcd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有这些构建者将负责定义构建复杂对象的步骤。</p><h2 id="eedc" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">可以使用一个可选的类，叫做<em class="nl"> Director </em></h2><p id="7742" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">指导者参与定义方法，确保步骤以特定的顺序执行，以构建通常构造的对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2648" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建器模式还解决了其他什么问题？</h1><p id="b523" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，当我们需要一种方法来帮助简化复杂对象的构造时，通常最需要构建器模式，所以在您的代码中引入这种模式的最佳时机是当您达到这一点时(或者当它们变大时)。</p><p id="a84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下下面的示例代码，看看为什么它在将来会难以管理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ef6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个<code class="fe no np nq nr b">Frog</code>类。看上面的例子，你能想到什么问题？</p><p id="9d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会也可能不会想到的一个问题是参数。我特别指的是这一行:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="0c17" class="mz md it nr b gy nw nx l ny nz">constructor(name, weight, height, gender) {</span></pre><p id="7f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe no np nq nr b">Frog</code>类定义看起来很容易理解，因为我们只消耗了很少的行。然而，当我们试图实例化<code class="fe no np nq nr b">Frog</code>实例时，情况就不同了:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2f67" class="mz md it nr b gy nw nx l ny nz">const bob = new Frog('Bob', 9, 2.2, 'male')</span></pre><p id="d7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你决定去加勒比海度假六个月，你认为你会记得中间那两个参数指的是什么吗？你将被迫回去检查源代码，以便能够清楚地理解它们的真正含义。</p><p id="0789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这两个参数是同一类型时，这尤其是一个问题。任何开发人员在实例化真实场景中的<code class="fe no np nq nr b">Frog.</code>时，都可能很容易混淆<code class="fe no np nq nr b">weight</code>或<code class="fe no np nq nr b">height</code>参数的位置，这些情况在医疗行业等行业中尤其重要，因为一个数据不匹配可能会让公司损失惨重。</p><p id="6b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这是如何简化的呢？你猜对了，使用构建器模式。</p><p id="b3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是按照模式简化后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以清楚地看到创建<code class="fe no np nq nr b">Frog</code>实例时发生了什么。</p><p id="e2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看构造函数，看看我们从返工中获得了什么:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="dce7" class="mz md it nr b gy nw nx l ny nz">constructor(name, gender) {<br/>    this.name = name<br/>    this.gender = gender<br/>  }</span></pre><p id="7942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当从<code class="fe no np nq nr b">4</code>实例化到<code class="fe no np nq nr b">2</code>时，<code class="fe no np nq nr b">FrogBuilder</code>减少了参数的数量，因为它将它们移到了它的实现细节中。这不仅更容易理解，而且在实例化时看起来更自然:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4b3c" class="mz md it nr b gy nw nx l ny nz">const sally = new FrogBuilder('Sally', 'female')</span></pre><p id="7270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，我们很容易忘记在哪里、何时或者如何在一个<code class="fe no np nq nr b">Frog</code>上设置<code class="fe no np nq nr b">weight</code>和<code class="fe no np nq nr b">height</code>属性:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="dc79" class="mz md it nr b gy nw nx l ny nz">const bob = new Frog('Bob', 9, 2.2, 'male')</span></pre><p id="dbd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了新的方法，构建者(<code class="fe no np nq nr b">FrogBuilder</code>)通过鼓励更多的开放机会来解决这个问题，从而简化了这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们得到了同样的结果，只是现在它对我们人类来说更容易管理和阅读。</p><p id="427e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:让我们想象一下，有一个复杂的对象，需要对大量的字段和嵌套的对象进行大规模、系统化的逐步初始化。这可能隐藏在具有许多参数的巨大构造函数中，甚至分散在代码中。</p><p id="ab24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们继续考虑如何创建一个汽车对象。为了制造一辆简单的汽车，你需要制造四个轮子，一个方向盘，刹车和油门踏板。但是，如果你想要一辆有附加功能的卡车，比如天窗和空调呢？</p><p id="bc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个任务看起来最简单的解决方案是扩展基本的car类，并创建一组子类，每个子类包含一些参数。但是如果你仔细想想，你最终会面临这样的问题，每次你遇到新的参数，比如有有色的窗户，你都必须创建新的子类。而每一次这种情况发生，你的等级就会增长更多。</p><p id="34ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是在基本的<code class="fe no np nq nr b">Car</code>类中创建一个巨大的构造函数，处理控制汽车对象的所有可能的参数变化。虽然这消除了对子类的任何需求，但它仍然引入了一个新问题。</p><p id="2499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你有一个试图处理每个参数的巨大构造函数时，在大多数情况下，这是一个坏主意，因为大多数参数实际上不会被使用。这使得构造函数块不必要的难以理解和维护。</p><p id="0e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，大多数汽车甚至不需要天窗，因此与天窗相关的参数在99%的时间里都会变得相当无用。</p><p id="3884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章到此结束。我希望你发现这是有价值的。</p></div></div>    
</body>
</html>