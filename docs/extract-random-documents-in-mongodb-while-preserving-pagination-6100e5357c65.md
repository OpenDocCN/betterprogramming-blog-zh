# 在 MongoDB 中提取随机文档，同时保留分页

> 原文：<https://betterprogramming.pub/extract-random-documents-in-mongodb-while-preserving-pagination-6100e5357c65>

## 因为有时你需要从数据库中随机获取一个文档

![](img/3be278fac7a127d08b3b0f26572847c8.png)

由 [Patrick Fore](https://unsplash.com/@patrickian4?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

这听起来可能很奇怪。这听起来可能有些极端。这听起来可能不合常规。但是从 MongoDB 集合中提取随机文档实际上是一种常见的行为，每个程序员迟早都必须能够实现和复制这种行为。

# 首先:用例与真实需求

毕竟，您真的需要能够随机抽取文档。

想象一下，在一个用例或应用中，你必须随机显示信息，即使有一个基本的算法，也不一定完全是随意的。应用程序显示随机或伪随机数据的频率比你想象的要高，以循环播放内容，让它们看起来总是新鲜的。

Instagram 本身使用的方法与此没有太大不同，它选择图片显示在探索版块中。

这些图片是基于你通常喜欢欣赏的内容，这是毫无疑问的，但你能看到的图像必须以某种方式旋转、洗牌和混合。

因此，即使不考虑您可以在这项技术中采用的算法或逻辑，您的目标通常也是从您的集合中选取随机的(当然也是真实的)文档，并将它们发送到您的客户端应用程序，在本例中是移动应用程序。

以下是一些可能出现的情况:

*   显示热门帖子
*   从特定类别中提取随机新闻
*   输出样本数据
*   应用随机性来匹配和满足特定目标，例如，让您的内容具有相同的印象率和分布
*   生成随机内容来随机化行为——可能是为了测试目的，比如单元测试的输入数据

## 分页的问题

简单但非常令人沮丧:当您取出前 50 个文档时，您希望能够对数据进行分页并正确使用`$skip`和`$limit`，在每个后续查询中显示一致的数据并避免重复的内容。

因此，如果它是完全随机的，显然您可以在每个单独的查询中提取相同的文档，因为每个跳过的查询都不会关心之前发生了什么以及我们之前在输出中发送了什么。

第一种方法是*记住*(或*缓存*)在每个先前输出中发出的内容。但那太糟糕了。没有技术可以扩展这种方法，我们也不想将任何无用的数据存储到我们的 *x* 十亿文档集合中——我们想做得更好。所以我们怎么能呢？

## 播种查询

如果输出可以是随机的，但与一个种子或客户机在分页过程中保持的值相关，我们就会得到它。因此，如果我们可以随机提取数据——也许按特定的输入排序——我们只需要告诉客户端对第一个请求之上的每个请求使用相同的输入。但是怎么做呢？

这种方法实际上存在于 SQL 中。流行的`Order by Random()`可以通过调用括号内有值的随机函数来简单地应用一个特定的值。所以像这样的查询…

```
SELECT * FROM theCollection ORDER BY RANDOM(123)
```

…在大多数 RDBMS 中都可以实现。那么 MongoDB 呢？
除了`$sample`操作符之外，MongoDB 没有提供任何特定的操作符或函数来随机化对集合的访问。

## ' $sample '运算符:不是解决方案

`[$sample](https://docs.mongodb.com/manual/reference/opera…)` [操作符](https://docs.mongodb.com/manual/reference/opera…)可以用在任何聚合管道中，因为它是作为管道阶段存在的。

这是一个非常简单的操作符:一个非常通用且易于使用的将随机性应用到聚合管道的方法。但这也是非常有限和基本的。它是这样工作的:

```
db.theCollection.aggregate(
   [ { $sample: { field: *fieldValue* } } ]
)
```

`$sample`使用伪随机光标来选择文档，因此它基本上只是将光标定位在随机位置来提取伪随机数据——非常容易，复杂度非常低。

这就是为什么它不是我们问题的解决方案，因为它不能考虑以前的数据查询，并且不提供任何在第一次提取后重复查询的功能，同时提供避免重复文档的能力。

## 正确的方法

为了维护合并到查询匹配标准中的逻辑，满足我们目标的唯一方法是定制它的特性，并让它用定制的算法提取数据。

因此，除了使用`$sample`操作符，我们必须回到播种方法，这种方法的工作原理是将一个参数作为输入传递给我们的查询，并让它作为种子，我们从种子中确定查询提取的随机性。

*   客户给了我们一粒种子
*   该查询使用种子来混洗、随机化，然后投影一个新字段
*   然后，查询根据这个新值对结果进行排序

真正的问题是如何使种子与我们的文档字段值相关联。考虑这些提示和建议:

*   如果种子是一个数字，它可以被用来制定一个数学演算，这给了我们良好的分布和基数
*   如果种子是一个字符串，您可以操作它的值，或者以某种方式将它的值与我们的一个字段相关联
*   如果种子是一个日期，您可以用时间戳或类似的东西来计算时差，以随机化新值

它完全是关于你的，并且它非常依赖于你的数据库的集合结构和数据建模。

根据我的经验，使用种子作为数字比操作字符串格式(字符出现次数、字符串长度等)要容易得多。

通过使用一个数字作为种子，很容易找到一个公式来`$project`一个具有随机值的新字段。我个人使用了模数(`%`)或除法器(`/`)操作符，效果非常好，保持了非常低的复杂度，避免了 CPU 的开销。

# 结论

从一个集合中抽取随机的文档可能很棘手——至少和构建最糟糕的集合一样棘手。

但毕竟:保持事情简单，获得一个种子，然后`$project`创建一个新字段——您将订购的字段——可能是一个好主意，如果您找到一种简单的方法从种子值开始计算这个字段值的话。

显然，每次你想随机化你的数据时，种子必须被刷新:这就是为什么每次你请求第一页结果时，创建一个新的种子值是一个好主意；此后，每个后续页面将使用相同的种子值。