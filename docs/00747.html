<html>
<head>
<title>Front End JS Development Without Transpiling Your Source Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端JS开发，无需编译源代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bye-bye-transpile-3e4413f7f590?source=collection_archive---------5-----------------------#2019-07-09">https://betterprogramming.pub/bye-bye-transpile-3e4413f7f590?source=collection_archive---------5-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0174" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用谷歌浏览器、ES模块和导入地图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b6b1fc81c7e354bcace5579a6c258cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEnEE7B_IYvKobT0vmaG7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/search/photos/source-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@euwars?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法扎德·纳齐菲</a>拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="feac" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是运输？</h1><p id="96f9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them" rel="noopener ugc nofollow" target="_blank">trans pilling</a>是指从一种编程语言翻译一些源代码，并在另一种编程语言(或同一种语言的两种不同方言/版本)中生成等效代码的过程。</p><p id="602f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在前端浏览器开发中，transpiling主要用于使用JS之外的语言开发应用程序，并将原始代码翻译成JavaScript(例如<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>、<a class="ae ky" href="https://coffeescript.org/" rel="noopener ugc nofollow" target="_blank"> CoffeeScript </a>、<a class="ae ky" href="https://developers.google.com/closure/compiler/" rel="noopener ugc nofollow" target="_blank"> Closure </a>、Java、<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/" rel="noopener ugc nofollow" target="_blank"> C# </a>等)。).</p><p id="58df" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一个用例是将您的本地JavaScript代码从一个版本转换到另一个版本(<a class="ae ky" href="https://en.wikipedia.org/wiki/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ECMAScript版本</a>)，这样您就可以使用浏览器还不支持的特性(或其中的一些)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5c22" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">运输的费用</h1><p id="99e7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在开发过程中使用transpiling确实很诱人；所有这些功能-全语言和语法糖可供选择！</p><p id="c775" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所有这些都承诺让你在更短的时间内开发出更好的程序，更少的错误。但是这些承诺是真的吗？成本是多少？</p><p id="8376" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">JavaScript是一种臭名昭著的语言，尤其是在构建复杂而庞大的应用程序时。但是JavaScript在最近几年有了很大的发展，并且随着每一个新的语言规范的发布而变得越来越好。</p><p id="1886" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">浏览器采用新功能的速度比过去更快，你不必等很久就能看到谷歌Chrome和其他浏览器支持的重要新功能。</p><p id="5f60" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最终，今天的JavaScript是一种强大而坚实的语言。</p><p id="dfaa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">JavaScript是一种解释型动态语言。相比编译语言，比如TypeScript、Java、Closure、C#等。，您不必等待编译就能看到您的应用程序正在运行并对其进行调试。</p><p id="7541" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当你开始开发你的新应用程序时，这可以被看作是一个可以忽略的时间，但随着你的应用程序变得越来越大和越来越复杂，这一时间会越来越长。如果你选择transpile，你就失去了这个优势，而且不仅仅是这个优势。</p><p id="d47f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">transpiling的另一个问题是浏览器运行的代码不是你写的代码。因此，调试和优化性能会变得非常棘手。是的，你有源图，但这不是一回事。</p><p id="9b4c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">源映射映射代码中的位置，但是它们不映射两个变量名如何相互关联。优化可能会使编译后的源代码与您所编写代码的预期行为不符。</p><p id="e86f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/chrome-devtools/" rel="noopener ugc nofollow" target="_blank">谷歌Chrome Inspector </a>是目前可用的最强大、最高效的软件调试器之一，用源代码地图给它增加不必要的复杂性，而不直接在你写的代码上释放它的力量，这真的是一种耻辱。</p><p id="3a59" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在开发过程中使用了许多基于transpiling的项目之后，我可以向您保证，在Inspector中直接处理原始代码(没有源地图中介或其他翻译)是一种更好的体验。</p><p id="1a4e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">今天，可以直接在Google Chrome中编写、运行和调试你的前端JavaScript代码，并且只在生产和交付时进行转换。</p><p id="369e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">所以，你说不通过传输来开发我的前端会更好，但是我该怎么做呢？我如何使用非ES就绪依赖项？如果我想进行静态类型检查呢？</p><p id="a90c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看一个使用<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">React</a>/<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">JSX</a>——残局应用的例子。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9050" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">谷歌浏览器中的ES模块</h1><p id="a6a8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">今天，Chrome在理解JavaScript代码中的导入/导出方面没有问题。你可以把你的应用拆分成ES模块文件，直接在浏览器上运行，没有任何问题。</p><p id="846c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当您想要使用第三方库时，问题就出现了。</p><p id="7fef" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">JavaScript依赖管理事实上的标准来自于<a class="ae ky" href="https://nodejs.org/api/modules.html" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中的包管理。</p><p id="6524" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">可以使用<a class="ae ky" href="https://yarnpkg.com/lang/en/" rel="noopener ugc nofollow" target="_blank">纱</a>、<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>等打包实用程序。，要求您的库，并在本地文件夹中提供主题(通常是<code class="fe mz na nb nc b">node_modules</code>)。</p><p id="954a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不幸的是，并非所有可用的软件包都是ES-ready。大多数包使用<a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>模块语法(它们使用“require”而不是“import”)。即使是es就绪模块也可能依赖于非ES模块。</p><p id="6fb9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了避免这种不便并能够直接使用所有现有的包，我们可以在等价的es模块(我们称之为<em class="nd"> web模块</em>)中传输我们的依赖关系。</p><p id="bbe9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个transpiling只对依赖项(不是我们的源代码)有影响，并且只在我们添加新库时执行一次。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3952" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">ES覆盖</h1><p id="9ade" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">并非所有的依赖关系都可以自动翻译成es模块。在某些情况下，我们必须编程如何将lib移植到ES模块(手动命名导出)。</p><p id="cd2d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为此，我们创建中间件包，导入所需的库(任何有效的Node.js库)并将其作为es导出。</p><p id="689c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，我们使用<a class="ae ky" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> rollup </a>将ES中间件依赖项转换成web模块，准备在Chrome中使用。</p><p id="237b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了使这一步变得容易，我们开发了几个实用程序脚本:覆盖和web模块(请随意修改它们以满足您的需求)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/70e46c3b8f8ad28e56119e27398deff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3raMvIEXk5yuqDBo431ww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由于HTML中声明的导入映射，Chrome从web_modules文件夹中加载名为“react”的ES模块。创建一个es覆盖模块，用于为未准备好ES的包建立web模式。</p></figure><p id="5569" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请注意，对于已经与es兼容的包，ES覆盖是不必要的。关于已经兼容的软件包列表，请参考<a class="ae ky" href="https://www.pika.dev/" rel="noopener ugc nofollow" target="_blank"> pika列表</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="887b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">覆盖脚本</h1><p id="a0a2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">第一个脚本覆盖(<a class="ae ky" href="https://github.com/FbN/endgame/blob/master/scripts/overlay.js" rel="noopener ugc nofollow" target="_blank">脚本源代码</a>)用于初始化我们的中间件ES模块。</p><p id="a597" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如，在我们的项目中，我们想要使用React，所以我们开始使用Yarn将它添加到我们的依赖项中:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3778" class="nj lh it nc b gy nk nl l nm nn">$ yarn add react<br/>$ yarn add react-dom</span></pre><p id="ca6a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这一点上，这两个依赖关系在<code class="fe mz na nb nc b">package.json</code>中有说明，并且在<code class="fe mz na nb nc b">node_modules</code>中本地可用，但是我们还不能在我们的es模块中使用它们。</p><p id="c696" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">像这样的代码不会工作，因为React不是一个ES模块，我们没有告诉浏览器在哪里搜索它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8e5a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，我们要为这两个lib做一个叠加。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e23c" class="nj lh it nc b gy nk nl l nm nn">$ yarn run overlay — pkg react<br/>$ yarn run overlay — pkg react-dom</span></pre><p id="fdab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">该实用程序做两件事:</p><ul class=""><li id="db6b" class="nq nr it ma b mb mu me mv mh ns ml nt mp nu mt nv nw nx ny bi translated">在<code class="fe mz na nb nc b">@es</code>文件夹中创建中间件包文件。每个包由一个<code class="fe mz na nb nc b">package.json</code>和一个<code class="fe mz na nb nc b">index.js</code>组成。这些文件很好(默认情况下，它们从原始dep中导出所有内容)，但是在某些情况下，您必须编辑<code class="fe mz na nb nc b">index.js</code>并手动指定一个命名的导入/导出。</li><li id="33bf" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">将覆盖的包添加到<code class="fe mz na nb nc b">“webmodules”</code>属性下的<code class="fe mz na nb nc b">package.json</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e99b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">每个中间件ES模块都由一个<code class="fe mz na nb nc b">package.json</code>文件组成，该文件在一个<code class="fe mz na nb nc b">index.js</code>文件中声明原始依赖关系，该文件导入/导出所有原始依赖关系名称。</p><p id="3652" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">此表格对大多数包都有效。对于某些包，您可能被迫手动声明要导入/导出的名称。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="879d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Web模块脚本</h1><p id="e71b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">既然我们已经声明了ES模块，我们希望将它们转换成可用的模块。为此，我们运行一个web模块脚本(<a class="ae ky" href="https://github.com/FbN/endgame/blob/master/scripts/web-modules.js" rel="noopener ugc nofollow" target="_blank">脚本源代码</a>)。</p><p id="3e6e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个脚本的源代码是pika/web项目的一部分。</p><p id="9db5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">与pika的不同之处在于，我们可以管理每一种依赖，而不仅仅是ES-ready。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7fa9" class="nj lh it nc b gy nk nl l nm nn">$ yarn run web-modules</span></pre><p id="736c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">该脚本读取关于需要从<code class="fe mz na nb nc b">package.json</code>传输的web模块的信息。</p><p id="292e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然后，使用<a class="ae ky" href="https://yarnpkg.com/lang/en/docs/cli/link/" rel="noopener ugc nofollow" target="_blank"> Yarn link functionality </a>(如果您愿意，可以很容易地将其更改为使用npm)使ES中间件模块(由覆盖脚本生成)对节点脚本可用，在<code class="fe mz na nb nc b">node_modules</code>内部链接它们。</p><p id="3c3b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，脚本运行rollup来传输模块，并将它们输出到<code class="fe mz na nb nc b">web_modules</code>文件夹中。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ef92" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">告诉Chrome在哪里可以找到模块</h1><p id="2098" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">此时，我们已经准备好在<code class="fe mz na nb nc b">web_modules</code>中以正确的es模块格式使用我们的依赖项。</p><p id="a109" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是当我们使用<a class="ae ky" href="https://github.com/WICG/import-maps#bare-specifiers" rel="noopener ugc nofollow" target="_blank">裸说明符</a>导入时(例如从‘React’导入React)，Chrome如何知道从哪里搜索呢？</p><p id="06cc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将使用一个新的(仍在试验中的)谷歌Chrome功能，名为<em class="nd">导入地图</em> ⁴.</p><p id="1cbc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要启用它，打开谷歌浏览器的标志配置页面(通过输入这个网址:<code class="fe mz na nb nc b">chrome://flags</code>)并启用“内置模块基础设施和导入地图”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/40eb01a1448ba2515001033dfc2af0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4E87H78OGopPvMf6Gb6Ig.png"/></div></div></figure><p id="0545" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用导入映射，您可以告诉浏览器在哪里可以找到裸导入，在HTML中的特殊脚本标记中声明它们。</p><p id="9617" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了方便起见，我们的<code class="fe mz na nb nc b">web-modules</code>脚本自动更新所有HTML文件中的import maps选项卡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">index.html进口地图申报样本</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9973" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">发球脚本</h1><p id="138c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们需要一个网络服务器来使所有的文件对Chrome可用，并运行我们的应用程序。</p><p id="25dd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们创建一个<code class="fe mz na nb nc b">serve</code>脚本，它使用<a class="ae ky" href="https://www.browsersync.io/" rel="noopener ugc nofollow" target="_blank"> Browsersync </a>启动一个本地web服务器，并将我们的项目发布到<code class="fe mz na nb nc b">localhost:3000</code>。</p><p id="d0f7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你看看下面的<code class="fe mz na nb nc b">serve.js</code>，我们已经将<code class="fe mz na nb nc b">‘/web_modules’</code>URL映射到了我们的<code class="fe mz na nb nc b">web_modules</code>文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="351d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用JSX怎么样</h1><p id="5ed9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">JSX是一个语法糖，在JS文件中编写类似HTML的语句，而不是直接调用React <code class="fe mz na nb nc b">createElement</code>函数。使用JSX的文件需要传输。</p><p id="4634" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为了使用JSX但保持我们项目的主文件不被传输，我们将我们的JSX用法隔离到我们称之为<code class="fe mz na nb nc b">views</code>的文件。</p><p id="548d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们创建一个<code class="fe mz na nb nc b">views</code>文件夹，把我们的JSX文件放在里面。然后，我们添加一个脚本来传输所有的JSX文件，并将输出(有效的es模块)放在一个<code class="fe mz na nb nc b">./tmp</code>文件夹中。</p><p id="0c17" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在Browsersync中声明了<code class="fe mz na nb nc b">.tmp</code>文件夹，因为它是次根文件夹，所以在主根(app文件夹)中找不到的路径会在<code class="fe mz na nb nc b">.tmp</code>文件夹中搜索。</p><p id="e2e8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过这样做，我们现在可以将经过编译的JSX文件导入到主非经过编译的源代码中。</p><p id="2b62" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">重要的是要明白，只有当我们在JSX改变某些东西时，传输才会发生，而且只适用于JSX文件。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6be4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">最终项目结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/34e971d9e9650a725d211a02a4f66fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*7Mz70xqkst3FWETgtvXfkw.png"/></div></figure><ul class=""><li id="bbf6" class="nq nr it ma b mb mu me mv mh ns ml nt mp nu mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">.tmp</code>:临时文件夹，未修改。包含传输的JSX文件。由Browsersync服务器作为辅助根进行搜索。</li><li id="971f" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">@es</code>:包含我们的中间件es模块，用于将非ES节点模块转换为ES ready for web。修订的文件夹。由覆盖脚本生成，需要时可以有自定义代码。文件夹内容通过纱线链接(或npm链接)链接到<code class="fe mz na nb nc b">node_modules</code>文件夹内。</li><li id="915f" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">app</code>:包含应用源文件和资产。所有文件都被修改。该文件夹是Browsersync服务器发布的主根目录。这里的所有源文件都不是透明的。</li><li id="4348" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">scripts</code> : Node.js脚本文件，作为管理项目的实用工具。目录已被修订。</li><li id="3745" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">views</code> : JSX修改文件。JSX在这里被传送到<code class="fe mz na nb nc b">.tmp</code>文件夹</li><li id="2c40" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated"><code class="fe mz na nb nc b">.babelrc</code> : <a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">通天塔</a>配置文件。包含JSX运输的配置。注意，巴别塔仅用于JSX。</li></ul><p id="c064" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">剩下的内容应该是显而易见的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="db21" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">运行示例应用程序:Endgame</h1><p id="2656" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">很简单:</p><ul class=""><li id="2ba2" class="nq nr it ma b mb mu me mv mh ns ml nt mp nu mt nv nw nx ny bi translated">克隆它(Git克隆:<a class="ae ky" href="https://github.com/FbN/endgame.git" rel="noopener ugc nofollow" target="_blank">https://github.com/FbN/endgame.git</a>。/endgame)</li><li id="9c8b" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">进入克隆的项目(cd结束游戏)</li><li id="3fe7" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">纱线安装</li><li id="d61f" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">纱线运行<code class="fe mz na nb nc b">web-modules</code></li><li id="238b" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">纱线JSX</li><li id="ed63" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">纱线服务</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7b53" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">把它投入生产</h1><p id="69d4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本文针对应用程序的开发阶段。但是出版制作呢？</p><p id="f102" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">导入地图当前不可用于生产；您必须将项目转换成更受支持的JavaScript形式。但是这并不是一件困难的事情。</p><p id="a424" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">你可以使用Babel，和rollup或<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>一起，让你的源代码像往常一样传输到目标浏览器功能级别。生产运输不是问题；在开发过程中不断传输文件是个问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3f52" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">如果我想要静态类型检查呢</h1><p id="443f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">信不信由你，让TypeScript检查您的原生JavaScript源代码并在您的IDE中拥有所有TypeScript的优势而不放弃原始JavaScript是可能的。</p><p id="19d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我目前正在做这件事，并且我正在计划一个快速的操作方法，很快会涉及到<a class="ae ky" href="https://devdocs.io/jsdoc/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>和<a class="ae ky" href="https://atom.io/" rel="noopener ugc nofollow" target="_blank"> Atom </a>集成中的TypeScript。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2604" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="d51c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">开发并直接看到你的原始代码在Chrome上运行是一种享受。</p><p id="9d3d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">Chrome Inspector是一个令人难以置信的调试器，绕过源代码地图使其无与伦比。</p><p id="b348" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">优化您的代码，毫无畏惧地放置断点。保存修改后的代码以在浏览器中查看结果，而不需要等待任何额外的构建时间，这是非常好的。</p><p id="d417" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过正确的设置，您甚至可以用TypeScript验证您的代码，并让您的IDE完成您的代码，而无需放弃纯JavaScript。</p><p id="2500" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">弊端？您必须为非本地es就绪的包创建和维护ES覆盖模块，但这实际上只是一件小事。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="43f5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">源代码</h1><p id="4ae1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">GitHub上提供了endgame示例项目:</p><p id="6d6f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><a class="ae ky" href="https://github.com/FbN/endgame" rel="noopener ugc nofollow" target="_blank">https://github.com/FbN/endgame</a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="df00" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">引用和链接</h1><p id="67a9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">[1] Matt Zeunert:源地图是如何工作的？<br/><a class="ae ky" href="https://www.mattzeunert.com/2016/02/14/how-do-source-maps-work.html" rel="noopener ugc nofollow" target="_blank">https://www . mattzeunert . com/2016/02/14/how-do-source-maps-work . html</a></p><p id="caa2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">[2] Pika Web项目<br/><a class="ae ky" href="https://github.com/pikapkg/web" rel="noopener ugc nofollow" target="_blank">https://github.com/pikapkg/web</a></p><p id="1e65" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">[3]谷歌Chrome导入地图状态<br/><a class="ae ky" href="https://chromestatus.com/feature/5315286962012160" rel="noopener ugc nofollow" target="_blank">https://chromestatus.com/feature/5315286962012160</a></p><p id="3a48" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">[4]谷歌Chrome导入地图设计规范<br/><a class="ae ky" href="https://docs.google.com/document/d/1vFQzbmxg9ilpg8CT_P8roEYcpTfZ06Q5N4J9-ZQqqZo/edit" rel="noopener ugc nofollow" target="_blank">https://chromestatus.com/feature/5315286962012160</a></p></div></div>    
</body>
</html>