# 理解线程和 Java 中的线程

> 原文：<https://betterprogramming.pub/understand-threads-and-threading-in-java-8f706fc44d13>

## 用 Java 和 JVM 进行并发编程

![](img/485709b728e1799032e1f829462d0643.png)

[drmakete lab](https://unsplash.com/@drmakete?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

在编写复杂的应用程序时，我们经常会发现自己需要同时执行多个动作。幸运的是，Java 和 JVM 被设计成支持并发编程，因为所有的执行都发生在线程的上下文中。

# JVM 对多线程的支持

由于 Java 是在 90 年代创建的，那时计算机已经有多个处理单元，它们的创造者决定包括对多线程的本地支持。

Java 运行在 Java 虚拟机中。当程序启动时，JVM 创建执行`main()` 方法的主线程。从这一点开始，程序可以按照层次结构创建任意多的线程。在 Java 中，线程可以处于以下任何状态:

*   New: 当一个新线程被实例化时，就处于这种状态。处于这种状态时，线程还没有开始执行。
*   Runnable: 处于这种状态的线程可以是正在运行的，也可以是随时准备运行的。
*   阻塞/等待:在这种状态下，线程是不活动的，等待一个资源。
*   Suspended: 线程在调用带有`timeout`参数的方法时处于这种状态，会暂时挂起。之后，它可以从停止的地方继续执行。
*   终止:当一个线程执行完它的`run()` 方法时，它就处于终止状态。垃圾收集器将释放该线程使用的资源。

此外，JVM 为每个线程分配自己的方法调用堆栈，这允许这些线程跟踪局部变量、JVM 传递给方法的参数以及方法的返回值。

# 线程类

在 Java 中创建线程的第一种方法是创建一个扩展`Thread`类的类，用线程必须运行的代码覆盖`run`方法，然后实例化这个类:

一旦我们创建了这个类，我们就可以实例化它并启动线程:

```
**MyThread** thread = new **MyThread**();thread.**start**();
```

首先，我们分配一个新的`MyThread`对象，然后我们调用`start`方法，以便 JVM 调用该线程的`run`方法。注意，严格禁止多次启动一个线程(线程一旦完成执行，就不能重新启动)。如果我们想再次运行那个线程，我们应该创建一个线程对象的新实例。

# **可运行接口**

runnable 接口应该由任何类来实现，这些类的实例应该由线程来执行。该类必须定义一个名为`run`的无参数方法。此外，runnable 接口提供了激活一个类而不子类化`Thread`的方法。

一般来说，当我们只想覆盖线程的`run`方法而不使用任何其他的`Thread`方法时，就应该使用这个接口。

# 如何多次运行一个线程

如果我们想多次运行一个线程，在 Java 中我们该如何做呢？人们可能倾向于尝试以下方法:

但是我之前说过，这是不可能的。如果我们试图运行这段代码，将会抛出一个`IllegalThreadStateException`。

为了多次运行它，应该实例化一个新线程。一种可能的方法是使用线程数组。在本例中，我将运行十个线程:

# 临界断面

在 Java 中，`Object`类提供了一个锁，允许程序员管理对临界区的独占访问。锁允许两种操作:`open`和`close`。当一个锁被关闭时，任何其他关闭它的尝试都将被挂起，直到它被关闭它的线程打开。管理这些操作的 Java 方法是使用`synchronized`结构。使用该结构的第一种方法如下:

使用`synchronized`构造的另一种方式是定义一个`synchronized`方法:

```
public class **MyClass**{     public **synchronized** int **methodOne**(args){         ……     }
}
```

# 同步线程

`Thread`类实现了几个方法，允许我们控制线程何时以及如何等待其他线程。

第一种方法是`join()`。当一个线程希望等待另一个线程终止时，它会使用该线程的引用来调用此方法。当这个方法正在等待的线程被`interrupted()`方法中断时，这个方法抛出一个`InterruptedException`。

在下面的例子中，主线程将等待`thread1`线程终止:

另一个重要的方法是`wait()`。这个方法应该在一个`synchronized`方法中被调用。如果执行`wait`方法的线程被中断，它会抛出一个`InterruptedException`。JVM 将执行`wait`方法的线程添加到与进行调用的对象相关联的等待列表中。然后，与该对象相关联的锁被打开，当从调用返回时，它将被关闭。

我们将介绍的最后一个方法是`notify()`。当被调用时，它将激活一个正在等待列表中等待的线程。将要启动的线程还没有确定，但是必须等到可以再次关闭锁的时候。类似的方法是`notifyAll()`，激活等待列表中的所有线程。