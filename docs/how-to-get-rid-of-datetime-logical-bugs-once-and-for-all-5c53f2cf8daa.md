# 如何一劳永逸地摆脱 Datetime 逻辑 bug

> 原文：<https://betterprogramming.pub/how-to-get-rid-of-datetime-logical-bugs-once-and-for-all-5c53f2cf8daa>

## 何时使用 UTC，何时不使用

![](img/61f43a50a525c70932fe2bef432e79bf.png)

索尼娅·兰福德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我注意到优秀的开发人员可能会对日期时间逻辑感到困惑。他们的代码依赖于日期时间库来完成繁重的认知提升，作为回报，代码变得错误百出。

这也是可以理解的，因为时间非常复杂。我们站在巨人的肩膀上，他们简化了我们日常生活的时间。我们现在的日历和 24 小时制就是例子。我们认为它们是理所当然的。

当应用程序依赖日期时间时，开发人员应该对世界如何建模时间有一个基本的了解。建模时间的方法不止一种，每种模型都有优缺点。

我想你会发现它可以被简化，因为事实上它从来没有被解释过。

# UTC 与本地时间和 ISO

我们大多数人以前都听过这些日期时间逻辑术语，但是您真的了解它们是什么以及它们是如何关联的吗？

[UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time) 是世界标准日期时间模式。这是绝对时间，因为无论你在世界的哪个地方，UTC 日期时间都是一样的。这意味着它不考虑夏令时。

当地日期时间主要是我们在日常生活中想到的。这是相对时间，因为你在世界的哪个地方与时间有关。时区决定当地时间，可以考虑夏令时。夏令时取决于时区。

[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) 是格式化日期时间的主要标准。UTC 和本地日期时间都可以是 ISO 格式。

```
UTC:   "2021-01-01T00:00:00.000Z"
Local: "2021-01-01T00:00:00.000"
```

## 在后端使用 UTC

在大多数情况下，最好在后端使用 UTC。

绝对时间比相对时间更容易处理，因为代码不需要处理时区或夏令时。

这也意味着前端将处理 UTC 日期时间，作为与后端交互的一种方式。因此，前端将从后端接收 UTC 日期时间，它还会将任何本地日期时间转换为 UTC 发送回后端。

## 在前端使用本地日期时间

尽管我们是以 UTC 日期时间与后端交互，但我们希望在前端为我们的用户提供本地日期时间。

因为我们在日常生活中使用本地日期时间，所以向用户显示 UTC 日期时间是一种可怕的体验。因此，您几乎总是希望显示本地日期时间。

发生在前端的日期时间逻辑呢？例如，根据日期过滤一组对象。

它将简化您的代码，只在前端使用本地日期时间。同样，转换为 UTC 的唯一原因是将日期时间发送到后端。

## 仅在后端添加时间戳

前端代码永远不应该为持久数据创建时间戳。

这不是关于用户时钟的可靠性，而是关于控制。开发人员无法控制用户的时钟，因此时间戳只能在后端或数据库上完成。

# 为什么我的代码里还是有 bug？

我们现在理解了不同的时间模型，并且有一个简化代码的高级计划。但是我们仍然看到与日期时间逻辑相关的错误。为什么？

## 始终使用日期时间库

正如我以前说过的，时间是复杂的，独自处理这种复杂性是愚蠢的。如果你不相信我，回到这部关于时区的史诗 [Computfile 剧集](https://www.youtube.com/watch?v=-5wpm-gesOY)。

> …你非常感谢[OG datetime programmers]使[datetime libraries]开源，你给他们荣誉，你拿走他们的成果，把它放在你的程序中，你永远不会再看它。

*总是*使用日期时间库。

有很多这样的网站，所以你要尽职调查，找到一个适合你需要的。

最流行的前端日期时间库是 [Moment.js](https://momentjs.com) ，但是这个库已经正式完成了。所以如果你想找个替代品，我推荐读[最佳时刻。JS 备选方案](https://medium.com/swlh/best-moment-js-alternatives-5dfa6861a1eb)并从那里继续你的研究。本机 javascript 日期功能也可以工作。

## 单元测试日期时间函数

既然我们已经理解了 datetime 的复杂性，并且正在将这种复杂性转移到我们的 datetime 库中，那么我们如何才能确定这个库正在做我们认为它应该做的事情呢？

因为太复杂了，这些库可能会做出与我们期望不同的假设。检查这一点的最好方法是根据应用程序的用例编写单元测试。

因此，我们想测试代码如何处理 UTC、本地日期时间和格式。为此，我们必须将一个时区强制转换为本地日期时间。如果我们不这样做，并且我们的服务器在 UTC 下运行，那么我们的本地 datetime 测试不会中断，这是一个坏测试的标志。我们希望我们的测试能够打破。

我在这个例子中使用 Moment.js 纯粹是因为它很受欢迎。为了强制时区，我还需要添加 [moment-timezones](https://momentjs.com/timezone) ，尽管这在导入中没有出现。

*我建议将第三方应用程序库包装在助手函数中。这个例子是假装我们有一个函数把* `*format*` *一个日期时间转换成一些预定义的日期格式:*

这是在代码库中测试日期时间逻辑的一个例子。它测试 UTC 和本地日期时间以及它们是如何被格式化的。

编写这些测试需要库的知识。Moment.js 有本地模式和 UTC 模式，每种模式的格式都不同。如果没有测试，我可能不会发现。

## 前端开发人员必须比后端开发人员更好地理解日期时间逻辑

前端开发人员是用户体验的把关者。我们将设计粘合到应用程序本身。

为了让前端开发人员与后端开发人员进行有意义的对话，他们必须理解日期时间逻辑。前端开发人员是他们的反馈环，所以我们必须向他们提供有价值的反馈。

例如，如果本地日期时间是错误的，后端可能会认为这是显示问题。由前端来理解为什么它的格式不正确。

日期时间库可能正在做一些意外的事情。在这种情况下，添加额外的单元测试和修复。但也有可能后端没有发送 UTC 日期时间，甚至没有正确格式化日期时间。

无论如何，如果你能向后端开发人员解释问题所在，他们会倾听的。与后端同事合作，为用户提供最佳体验。

# 结论

日期时间是复杂的，在处理日期时间逻辑之前，需要相当多的理解。

这本操作指南通过几个要点简化了复杂性。

*   在后端使用 UTC
*   在前端使用本地日期时间
*   向日期时间库偏移复杂性
*   单元测试日期时间逻辑
*   仅在后端(或数据库)创建时间戳

这并不能解决所有的日期时间问题，但是这是一个很好的起点。

一如既往地运用你的直觉，尽职尽责。