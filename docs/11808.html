<html>
<head>
<title>Solidity Tutorial: All About Types Conversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体教程:关于类型转换的所有内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-tutorial-all-about-conversion-661130eb8bec?source=collection_archive---------4-----------------------#2022-04-19">https://betterprogramming.pub/solidity-tutorial-all-about-conversion-661130eb8bec?source=collection_archive---------4-----------------------#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实性的隐式与显式转换，以及理解类型间转换的例子。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/555789e91165acd95ec1b80ed6aa4adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Na5BrhCHlxUeicRj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jamietempleton" rel="noopener ugc nofollow" target="_blank">杰米·坦普尔顿</a>在Unsplash上拍摄的照片</p></figure><p id="a1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的文章相当有深度，技术性和细节性！我们探索不同类型之间的转换。</p><p id="3eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这篇文章的主要目的是让你理解<em class="lv">“在可靠性方面，隐式转换和显式转换的区别是什么”</em>。</p><p id="c286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将讨论类型之间的每种可能的转换，仍然使用一些代码示例。所以，拿起咖啡或茶(或一杯威士忌)，让我们开始吧！</p><h1 id="d418" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目录</h1><ul class=""><li id="6d66" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">隐式与显式—定义</li><li id="881a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">坚实度的隐式与显式转换</li><li id="7f83" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">无符号整数之间的转换<code class="fe ne nf ng nh b">uintN</code></li><li id="a8f4" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">bytesN</code>(<em class="lv">eg:</em><code class="fe ne nf ng nh b"><em class="lv">bytes4</em></code><em class="lv">&lt;-&gt;</em><code class="fe ne nf ng nh b"><em class="lv">bytes16</em></code><em class="lv">)</em>之间的转换</li><li id="8da1" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">从<code class="fe ne nf ng nh b">uintM</code>到<code class="fe ne nf ng nh b">bytesN</code>的转换</li><li id="34af" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">从<code class="fe ne nf ng nh b">bytesN</code>到<code class="fe ne nf ng nh b">uintM</code>的转换</li><li id="035f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">从<code class="fe ne nf ng nh b">bytes</code>到<code class="fe ne nf ng nh b">string</code>的转换</li><li id="9540" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">表格摘要— <code class="fe ne nf ng nh b">uintM</code> ← → <code class="fe ne nf ng nh b">bytesN</code></li><li id="36d2" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">bytesN</code>的文字赋值</li><li id="9667" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">小数和十六进制文字赋值<code class="fe ne nf ng nh b">uintN</code></li><li id="0e01" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">从<code class="fe ne nf ng nh b">bytes</code>到<code class="fe ne nf ng nh b">bytesN</code>的转换</li><li id="01ec" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">转换为<code class="fe ne nf ng nh b">address</code>类型</li><li id="d6a2" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">address</code>和<code class="fe ne nf ng nh b">address payable</code>之间的转换</li><li id="1dca" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">Contract</code>和<code class="fe ne nf ng nh b">address</code>类型之间的转换</li><li id="9507" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">参考</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c48f" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">隐式与显式—定义</h1><p id="5c05" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在深入探讨<em class="lv">Solidity中的隐式vs显式转换</em>之前，我们先来了解一下人类语言中的区别。</p><p id="9154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.lexico.com/" rel="noopener ugc nofollow" target="_blank">Lexico.com</a>给出了隐性和显性的如下定义。</p><blockquote class="nx"><p id="9e89" class="ny nz it bd oa ob oc od oe of og lu dk translated"><a class="ae ky" href="https://www.lexico.com/definition/implicit" rel="noopener ugc nofollow" target="_blank">含蓄</a> =暗示某事，但不直接表达。</p><p id="bbae" class="ny nz it bd oa ob oc od oe of og lu dk translated">明确的；清楚的；清楚的；清楚的。</p></blockquote><p id="ac83" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">当一件事很明确的时候，它是非常清楚的。没有模糊的理解或歧义</p><p id="1e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当某事是隐含的，它是隐含的。有些东西是从措辞上理解的，它不是直接陈述或清楚描述的。</p><p id="a220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个例子来说明。爱丽丝是鲍勃的雇员。如果她得不到加薪，她打算表达她离开公司的决定。她可以这样表达:</p><blockquote class="nx"><p id="df62" class="ny nz it bd oa ob oc od oe of og lu dk translated">含蓄地:<em class="om">“如果我没有得到更多的赏识，我会检讨我的选择。”</em></p><p id="6ce9" class="ny nz it bd oa ob oc od oe of og lu dk translated">明确地说:“如果我得不到加薪，我会离开。”</p></blockquote></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="5ab8" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">坚实度的隐式与显式转换</h1><p id="10a8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">所有编程语言都支持某种类型的转换。</p><p id="733d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坚固性也允许类型转换。Solidity中的类型转换可以在三种主要情况下发生:</p><ul class=""><li id="a95c" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated">通过变量赋值。</li><li id="3cc0" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">向函数传递参数时。</li><li id="aeb7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">应用运算符时。</li></ul><p id="ac82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型转换可以隐式完成(=编译器自动派生类型)，也可以通过对编译器显式完成(=告诉编译器要转换到哪种类型)。</p><p id="3bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细看看Solidity编译器的隐式和显式转换的基本规则。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="3cda" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.13/types.html?highlight=Implicit%20conversion#implicit-conversions" rel="noopener ugc nofollow" target="_blank">隐式转换</a></h2><p id="ddfe" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在以下情况下，Solidity允许两种数据类型之间的隐式转换:</p><ul class=""><li id="c502" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated">语义上有意义<em class="lv">(什么意思？)</em></li><li id="a606" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">在此过程中不会丢失任何信息。</li></ul><p id="70d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">示例:</em></p><ul class=""><li id="ff61" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">uint8</code>到<code class="fe ne nf ng nh b">uint16</code> = ✅</li><li id="4cca" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">int120</code>到<code class="fe ne nf ng nh b">int256</code> = ✅</li><li id="77b7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">int8</code>到<code class="fe ne nf ng nh b">uint256</code> = ❌ ( <em class="lv">因为</em> <code class="fe ne nf ng nh b"><em class="lv">uint256</em></code> <em class="lv">不能保存可能来自</em> <code class="fe ne nf ng nh b"><em class="lv">int8</em></code> <em class="lv">的负值)。</em></li></ul><p id="dff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的最后一个例子可以看出，当一些信息可能丢失时，Solidity编译器不允许隐式转换。</p><p id="32d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用最后一个例子来说明，如果<code class="fe ne nf ng nh b">int8</code>的值是<code class="fe ne nf ng nh b">-5</code>，编译器将不得不放弃求反，以便将其转换为允许的<code class="fe ne nf ng nh b">uint256</code>数。这种转换会导致数据中的信息丢失，Solidity编译器足够聪明，能够知道这一点并向您发出警告。</p><p id="6ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果你<em class="lv">“不同意编译器”</em>，或者你想<em class="lv">“强制一些转换”，</em>你总是可以通过显式告诉编译器该怎么做。</p><h2 id="4e75" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">显式转换</h2><blockquote class="pc pd pe"><p id="c94a" class="kz la lv lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated">如果编译器不允许隐式转换，但您知道自己在做什么，显式类型转换有时是可能的。</p></blockquote><p id="c828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显式转换可以通过<em class="lv">强制转换</em>或类似构造函数的语法来完成。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="9444" class="oq lx it nh b gy pm pn l po pp">uint256 a = 12345;<br/>bytes32 b = bytes32(a);</span></pre><p id="3c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，显式转换可能有风险，如Solidity文档中所述。</p><blockquote class="pc pd pe"><p id="b4f6" class="kz la lv lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated">这可能会导致意想不到的行为，并允许您绕过编译器的一些安全功能，所以一定要测试结果是否是您想要的和期望的！</p></blockquote><h2 id="799e" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">定义摘要</h2><p id="4df2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">这里用两句话总结一下<em class="lv">隐式</em> <em class="lv"> vs显式</em>在坚固性上的转换。</p><p id="92ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Solidity中从类型<code class="fe ne nf ng nh b">A</code>转换到类型<code class="fe ne nf ng nh b">B</code>时，数据中的一些信息可能会在转换过程中丢失。</p><ul class=""><li id="c982" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated">使用隐式转换:您可能没有意识到(潜在的)信息正在丢失。</li></ul><p id="d58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果某些信息确实丢失了，编译器将拒绝编译并抛出一个错误❌</p><ul class=""><li id="a8e2" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated">使用显式转换:您完全知道一些信息可能会丢失。</li></ul><p id="c8cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<em class="lv">你对编译器</em>是显式的，它将允许你编译，并允许(潜在的)信息✅损失</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="80e6" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">无符号整数之间的转换<code class="fe ne nf ng nh b">uintN</code></h1><p id="b19b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Solidity中的无符号整数以不同的比特大小存在于8比特序列中。例如:<code class="fe ne nf ng nh b">uint8</code>、<code class="fe ne nf ng nh b">uint16</code>、<code class="fe ne nf ng nh b">uint24</code>、<code class="fe ne nf ng nh b">uint32</code>、…直到<code class="fe ne nf ng nh b">uint256</code>。</p><p id="c80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于理解，让我们定义一个<strong class="lb iu">高型</strong>和<strong class="lb iu">低型</strong>的编号:</p><ul class=""><li id="7dca" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated"><strong class="lb iu">更大的类型号:</strong>更接近最低位范围<code class="fe ne nf ng nh b">uint8</code>的数字。</li><li id="f184" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><strong class="lb iu">更小的类型号:</strong>更接近最高位范围<code class="fe ne nf ng nh b">uint256</code>的数字。</li></ul><p id="10fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无符号整数的转换可以双向进行。</p><h2 id="7e5f" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">转换成更大的类型</h2><p id="e97f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在这个场景中，您正在将一个数字转换成一个比初始类型更大的新类型。</p><p id="f14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">例如:</em> <code class="fe ne nf ng nh b">uint64</code>到<code class="fe ne nf ng nh b">uint128</code></p><p id="ca2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将无符号整数转换为更大的类型时，<strong class="lb iu">出现左填充</strong>，意味着零(= 0位)被添加到左边。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="413b" class="oq lx it nh b gy pm pn l po pp">uint16 a = 0x1234;<br/>uint32 b = uint32(a); // b = 0x00001234</span></pre><h2 id="cfb5" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">转换成较小的类型</h2><p id="64c8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在这种情况下，您要将一个数字转换为比初始类型更小的新类型。</p><p id="cbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">例如:</em> <code class="fe ne nf ng nh b">uint256</code>到<code class="fe ne nf ng nh b">uint128</code></p><p id="a976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将无符号整数转换为较小的类型时，<strong class="lb iu">高阶位(最左边的位)最终被丢弃。</strong></p><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">示例:</em></p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="c9ee" class="oq lx it nh b gy pm pn l po pp">uint32 a = 0x12345678;<br/>uint16 b = uint16(a); // b = 0x5678</span></pre><p id="2635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于对我们要转换的数字取模，转换新位范围的较高数字。</p><p id="0ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举以下例子:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="979b" class="oq lx it nh b gy pm pn l po pp">uint32 a = 100000;<br/>uint16 public b = uint16(a); //b = a % 65536<br/>uint8 public c = uint8(a); //c = a % 256</span></pre><p id="3f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中:</p><ul class=""><li id="8658" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">uint16 b</code>可以通过做<code class="fe ne nf ng nh b">a % 65536 = 34,464</code>来计算</li><li id="6f73" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">uint8 c</code>可以通过做<code class="fe ne nf ng nh b">a % 256 = 160</code>来计算</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b7dd" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">bytesN ( <em class="om">例如:bytes4 &lt; - &gt; bytes16) </em>之间的转换</h1><p id="a30f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Solidity允许在不同固定大小的字节之间转换。存在几种情况。这些将在下面介绍。</p><h2 id="b617" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">转换到较小的字节范围</h2><p id="78ae" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">当显式转换为更小的字节范围时，最右边的字节被丢弃(=第<em class="lv">“高位字节”)。</em></p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="ea5a" class="oq lx it nh b gy pm pn l po pp">bytes2 a = 0x1234;<br/>bytes1 b = bytes1(a); // b = 0x12</span></pre><p id="d15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上意味着Solidity从右边截断，直到字节长度等于类型转换中指定的新字节长度。</p><h2 id="cbad" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">转换到更高的字节范围</h2><p id="dfa5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">当转换为更大的字节时，会在右侧添加零填充。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="abb9" class="oq lx it nh b gy pm pn l po pp">bytes2 a = 0x1234;<br/>bytes4 b = bytes4(a); // b = 0x12340000</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b11d" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">从uintM到bytesN的转换</h1><p id="6c2f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">下面是转换两个值<code class="fe ne nf ng nh b">a</code>和<code class="fe ne nf ng nh b">b</code>的规则。让我们使用下面的模板来更好地理解未来可能的转换。</p><blockquote class="pc pd pe"><p id="c32e" class="kz la lv lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">uintM a</code>，其中<code class="fe ne nf ng nh b">M</code> =介于<code class="fe ne nf ng nh b">uint8 ... uint256</code>之间的8位范围</p><p id="ec23" class="kz la lv lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">bytesN b,</code>其中<code class="fe ne nf ng nh b">N</code> =介于<code class="fe ne nf ng nh b">bytes1 ... bytes32</code>之间的1字节范围</p></blockquote><h2 id="4b36" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">隐式转换</h2><p id="2fe8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated"><code class="fe ne nf ng nh b">uintM</code>和<code class="fe ne nf ng nh b">bytesN</code>相互之间不能隐式转换❌</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="e3ba" class="oq lx it nh b gy pm pn l po pp">uint32 a = 0xcafecafe;<br/>bytes4 b = a; // TypeError</span><span id="f511" class="oq lx it nh b gy pq pn l po pp">// TypeError: Type uint32 is not implicitly convertible to expected type bytes4.<br/></span><span id="c43c" class="oq lx it nh b gy pq pn l po pp">bytes4 c = 0xbeefbeef;<br/>uint32 d = c; // TypeError</span><span id="e7ed" class="oq lx it nh b gy pq pn l po pp">// TypeError: Type bytes4 is not implicitly convertible to expected type uint32.</span></pre><h2 id="b4e4" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">显式转换</h2><p id="1ada" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">只要<code class="fe ne nf ng nh b">uintM</code>和<code class="fe ne nf ng nh b">bytesN</code>具有相同的大小(位数<code class="fe ne nf ng nh b">M</code>等于字节数<code class="fe ne nf ng nh b">N</code> ) ✅，就允许显式转换</p><p id="0037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:M位= N字节</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="11fe" class="oq lx it nh b gy pm pn l po pp">uint32 a = 0xcafecafe;<br/>bytes4 b = bytes4(a); // OK</span><span id="b855" class="oq lx it nh b gy pq pn l po pp">bytes4 c = 0xbeefbeef;<br/>uint32 d = uint32(c); // OK</span></pre><p id="b9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:M位&gt; N字节</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="8c95" class="oq lx it nh b gy pm pn l po pp">uint32 a = 0xcafecafe;<br/>bytes3 b = bytes3(a); // TypeError</span><span id="15f0" class="oq lx it nh b gy pq pn l po pp">// TypeError: Explicit type conversion not allowed from "uint32" to "bytes3".</span></pre><p id="97c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:M位&lt; N-bytes</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="f645" class="oq lx it nh b gy pm pn l po pp">uint32 a = 0xcafecafe;<br/>bytes5 b = bytes5(a); // TypeError</span><span id="94bb" class="oq lx it nh b gy pq pn l po pp">// TypeError: Explicit type conversion not allowed from "uint32" to "bytes5".</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="2da2" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">Conversion from bytesN to uintM</h1><p id="fca9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Same rules as before but in the other order.</p><p id="43c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Explicit conversion is allowed as long as the  【T18】  and  【T19】  are of the same size (number of bits  【T20】  is equivalent to the number of bytes  【T21】 )✅</p><p id="19bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">e.g: N-bytes = M-bits</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="6207" class="oq lx it nh b gy pm pn l po pp">bytes4 a = 0xbeefbeef;<br/>uint32 b = uint32(a);</span></pre><p id="d131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">e.g: N-bytes &gt; M位</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="6beb" class="oq lx it nh b gy pm pn l po pp">bytes4 a = 0xbeefbeef;<br/>uint24 b = uint24(a); // TypeError</span><span id="774f" class="oq lx it nh b gy pq pn l po pp">// TypeError: Explicit type conversion not allowed from "bytes4" to "uint24".</span></pre><p id="824b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:N字节&lt; M比特</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="6e88" class="oq lx it nh b gy pm pn l po pp">bytes4 a = 0xbeefbeef;<br/>uint40 b = uint40(a); // TypeError</span><span id="5bc9" class="oq lx it nh b gy pq pn l po pp">// TypeError: Explicit type conversion not allowed from "bytes4" to "uint40".</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="7a57" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">表格摘要— uintM ← →字节数n:</h1><p id="c015" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">下表总结了<code class="fe ne nf ng nh b">uintN</code>和<code class="fe ne nf ng nh b">bytesN</code>之间的等效性。只要记住<code class="fe ne nf ng nh b">uintM</code>的数字是位数，<code class="fe ne nf ng nh b">bytesN</code>的数字是字节数，一个字节<code class="fe ne nf ng nh b">N</code> = 8位<code class="fe ne nf ng nh b">M</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pr ps l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字节← →坚固性的单位表等效</p></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="4bb9" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">字节的十六进制文字赋值</h1><h2 id="7943" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">隐式赋值</h2><p id="6904" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">任何十六进制文字都可以隐式地赋给一个<code class="fe ne nf ng nh b">bytesN</code>,只要该文字的字节数与类型中提到的相同。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="b40c" class="oq lx it nh b gy pm pn l po pp">bytes4 a = 0xcafecafe;</span><span id="1a21" class="oq lx it nh b gy pq pn l po pp">bytes4 b = 0xcafe; // TypeError: Type [...] not implicitly convertible to expected type bytes4.</span><span id="989f" class="oq lx it nh b gy pq pn l po pp">bytes4 c = 0xcafecafecafe; // TypeError: Type [...] is not implicitly convertible to expected type bytes4.</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="ead3" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">小数和十六进制文字赋值uintN</h1><h2 id="8e57" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">隐式转换</h2><p id="a582" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">小数或十六进制数字文字可以隐式转换为任何<code class="fe ne nf ng nh b">uintN</code>，但必须遵循以下两条规则之一:</p><ul class=""><li id="f81a" class="mo mp it lb b lc ld lf lg li on lm oo lq op lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">uintN</code>和✅的字面数字一样大</li><li id="cddc" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><code class="fe ne nf ng nh b">uintN</code>比✅的字面数字还要大</li></ul><p id="4d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，规则是整数类型(=位的范围)必须足够大，以表示+ hold值而不截断。</p><p id="3e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Solidity文档中的示例:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="29f0" class="oq lx it nh b gy pm pn l po pp">uint8 a = 12; // no error<br/>uint32 b = 1234; // no error<br/>uint16 c = 0x123456; // error, as truncation required to 0x3456</span></pre><h2 id="9fff" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">显式转换</h2><p id="c35a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">坚实度0.8.0之前。可以显式地将任何十进制或十六进制文字转换为任何整数类型(无论位数范围如何)。请参见下面的示例。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="0bc9" class="oq lx it nh b gy pm pn l po pp">// this would compile up to solc 0.7.6<br/>uint8 a = uint8(300); // a = 44</span></pre><p id="70cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种显式转换的结果相当于计算300的模，如<code class="fe ne nf ng nh b">300 % 256 = 44</code>。</p><p id="2b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Solidity 0.8.0，上面的代码将导致错误:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="bd7b" class="oq lx it nh b gy pm pn l po pp">TypeError: Explicit type conversion not allowed from "int_const 300" to "uint8".</span></pre><p id="1039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从0.8.0开始，这种文字的显式转换与隐式转换一样严格。这意味着只有当文字符合结果范围时才允许它们。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="3b05" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">从字节到字节的转换</h1><ul class=""><li id="ac3d" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">❌不允许隐式转换</li><li id="5afe" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">从Solidity 0.8.5开始，允许显式转换🙌 🙂</li></ul><p id="6499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="b22e" class="oq lx it nh b gy pm pn l po pp">bytes memory data = new bytes(5);<br/>bytes2 firstTwoBytes = bytes2(data);</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="79df" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">字节和字符串之间的转换</h1><ul class=""><li id="738e" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">隐式转换不允许❌在任一侧(<code class="fe ne nf ng nh b">bytes</code>到<code class="fe ne nf ng nh b">string</code>，或<code class="fe ne nf ng nh b">string</code>到<code class="fe ne nf ng nh b">bytes</code>)</li><li id="4a36" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">✅允许显式转换</li></ul><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="8985" class="oq lx it nh b gy pm pn l po pp">string memory a = "All About Solidity";<br/>bytes memory b = bytes(a);</span><span id="b001" class="oq lx it nh b gy pq pn l po pp">bytes memory c = new bytes(5);<br/>string memory d = string(c);</span></pre><p id="6c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用这种显式转换类型将原始的<code class="fe ne nf ng nh b">bytes</code>转换为<code class="fe ne nf ng nh b">string</code>的契约的实际例子:来自<code class="fe ne nf ng nh b"><a class="ae ky" href="https://www.npmjs.com/package/@lukso/lsp-smart-contracts" rel="noopener ugc nofollow" target="_blank">@lukso/lsp-smart-contracts</a></code>的<code class="fe ne nf ng nh b"><a class="ae ky" href="https://github.com/lukso-network/lsp-smart-contracts/blob/b9f2315954a0ebc9b0ba2255ee6de33b93997f7c/contracts/LSP4DigitalAssetMetadata/LSP4Compatibility.sol" rel="noopener ugc nofollow" target="_blank">LSP4Compatibility.sol</a></code>契约。</p><p id="0383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.lukso.tech/standards/nft-2.0/LSP4-Digital-Asset-Metadata" rel="noopener ugc nofollow" target="_blank"> LSP4是元数据标准</a>，用于描述<a class="pt pu ep" href="https://medium.com/u/2376b006b57f?source=post_page-----661130eb8bec--------------------------------" rel="noopener" target="_blank"> LUKSO </a>上的令牌或NFT(参见<em class="lv"/><a class="ae ky" href="https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-7-DigitalAsset.md" rel="noopener ugc nofollow" target="_blank"><em class="lv">LSP 7</em></a><em class="lv">或</em><a class="ae ky" href="https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-8-IdentifiableDigitalAsset.md" rel="noopener ugc nofollow" target="_blank"><em class="lv">ls P8</em></a><em class="lv">了解关于基于EVM链的新一代令牌和NFT的更多细节</em>)。</p><p id="1961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在LSP4中，令牌或NFT的基本信息(如其名称或符号)存储在令牌/NFT的<a class="ae ky" href="https://docs.lukso.tech/standards/universal-profile/lsp0-erc725account#erc725y---generic-key-value-store" rel="noopener ugc nofollow" target="_blank"> ERC725Y键值</a>存储中的特定“数据键”下。</p><p id="3cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些键在下面的代码片段中被称为<code class="fe ne nf ng nh b">_LSP4_TOKEN_NAME_KEY</code>和<code class="fe ne nf ng nh b">_LSP4_TOKEN_SYMBOL_KEY</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/d48db20966c20b06c336d82bc71f1c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYT0pqe5wOPILSx_dM8zTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/lukso-network/lsp-smart-contracts/blob/b9f2315954a0ebc9b0ba2255ee6de33b93997f7c/contracts/LSP4DigitalAssetMetadata/LSP4Compatibility.sol" rel="noopener ugc nofollow" target="_blank">Github-lukso-network/LSP-smart-contracts，LSP4Compatibility.sol，第21–37行</a></p></figure><p id="8b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码来自<code class="fe ne nf ng nh b">LSP4Compatibility.sol </code>合同。该合同支持创建向后兼容的LSP7令牌和LSP8 NFTs，这意味着任何ERC20和ERC721令牌都可以像使用常规ERC20 / ERC721令牌一样与之交互。(唯一不同的是<a class="ae ky" href="https://docs.lukso.tech/standards/nft-2.0/introduction#how-tokens--nft-20-are-different" rel="noopener ugc nofollow" target="_blank"> LSP7和LSP8有更好的内置安全性+更可扩展的元数据！</a>😉)</p><p id="2b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到<code class="fe ne nf ng nh b">bytes</code>到<code class="fe ne nf ng nh b">string</code>的转换。在上面的代码片段中，函数<code class="fe ne nf ng nh b">name()</code>和<code class="fe ne nf ng nh b">symbol()</code>从底层的ERC725Y键值存储中检索数据，所有数据都存储为原始数据<code class="fe ne nf ng nh b">bytes</code>。</p><p id="820e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了支持向后兼容，这些字节被显式转换为<code class="fe ne nf ng nh b">string</code>(就像<em class="lv">转换一样)。</em>这种显式转换导致这两个函数类似于ERC20 / 721标准中的函数，而名称和符号实际上并不存储在变量下，而是存储在通过<a class="ae ky" href="https://github.com/ERC725Alliance/ERC725/blob/main/docs/ERC-725.md#erc725y" rel="noopener ugc nofollow" target="_blank"> ERC725Y </a> 🗄获得的键值存储抽象下</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="8ae2" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">转换为地址类型</h1><h2 id="c06d" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">从十六进制文字到地址的转换</h2><p id="9fc6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">下面是将十六进制文字转换为地址的规则，要么通过赋值隐式地<em class="lv">转换为地址，要么通过类型转换<em class="lv">显式地</em>转换为地址，如<code class="fe ne nf ng nh b">address(0x…)</code>。</em></p><p id="7076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隐式转换</p><p id="c02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果满足以下两个要求，任何十六进制文字都可以隐式转换为<code class="fe ne nf ng nh b">address</code>类型:</p><p id="5189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则1:必须有正确的大小:20字节长。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="e6b3" class="oq lx it nh b gy pm pn l po pp">// not long enough<br/>address vanityAddress = 0xfccfdadf3acefddcdebdefad8d0e7cbb96eeee;</span><span id="c886" class="oq lx it nh b gy pq pn l po pp">// TypeError: Type int_const 5637...(38 digits omitted)...7022 is not implicitly convertible to expected type address.</span></pre><p id="0253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则2:必须有有效的校验和</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="597a" class="oq lx it nh b gy pm pn l po pp">// invalid checksum<br/>address vanityAddress = 0xfccfdadf3acefddcdebdefad8d0e7cbb96eeeebf;</span><span id="8123" class="oq lx it nh b gy pq pn l po pp">// SyntaxError: This looks like an address but has an invalid checksum. Correct checksummed address: "0xFCCfDadf3acEFDdcdeBdefaD8d0e7Cbb96eeEeBf". If this is not used as an address, please prepend '00'. For more information please see https://docs.soliditylang.org/en/develop/types.html#address-literals</span></pre><p id="dda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你从上面看到的，Solidity编译器会返回一个错误，但也会返回一个带有有效校验和的地址文字。</p><p id="3809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的代码片段将成功编译，因为它遵循2条规则:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="9905" class="oq lx it nh b gy pm pn l po pp">address vanityAddress = 0xFCCfDadf3acEFDdcdeBdefaD8d0e7Cbb96eeEeBf;</span></pre><p id="a3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显式转换</p><p id="0579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将任何十六进制文字显式转换为地址，如下所示。只要文字小于或等于20个字节，这是允许的。</p><p id="c962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果十六进制文字小于20个字节，它将左零填充地址+校验和它。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="75f1" class="oq lx it nh b gy pm pn l po pp">address example1 = address(0xcafecafe)<br/>// 0x00000000000000000000000000000000CaFECAfE</span><span id="bac2" class="oq lx it nh b gy pq pn l po pp">address example2 = address(0xca11ab1e00beef010101)<br/>// 0x00000000000000000000ca11AB1e00BEEF010101</span></pre><p id="fafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果十六进制文本正好是20字节长，则该文本必须具有有效的校验和。否则，Solidity编译器将返回一个错误，并返回有效的校验和文本。</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="cc0a" class="oq lx it nh b gy pm pn l po pp">address example = address(0xcafecafecafecafecafecafecafecafecafecafe);</span><span id="9d8a" class="oq lx it nh b gy pq pn l po pp">// SyntaxError: This looks like an address but has an invalid checksum. Correct checksummed address: "0xCAfEcAfeCAfECaFeCaFecaFecaFECafECafeCaFe". If this is not used as an address, please prepend '00'. For more information please see <a class="ae ky" href="https://docs.soliditylang.org/en/develop/types.html#address-literals" rel="noopener ugc nofollow" target="_blank">https://docs.soliditylang.org/en/develop/types.html#address-literals</a></span></pre><h2 id="706d" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">从uint160到地址的转换</h2><ul class=""><li id="be99" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">不允许从<code class="fe ne nf ng nh b">uint160</code>到<code class="fe ne nf ng nh b">address</code> ❌的隐式转换</li><li id="6091" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">允许从<code class="fe ne nf ng nh b">uint160</code>到<code class="fe ne nf ng nh b">address</code> ✅的显式转换</li></ul><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="63f8" class="oq lx it nh b gy pm pn l po pp">uint160 someNumber = 5_689_454_112;</span><span id="bd03" class="oq lx it nh b gy pq pn l po pp">address convertedAddress = address(someNumber);</span></pre><blockquote class="pc pd pe"><p id="cd6d" class="kz la lv lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated">注意:在Solidity 0.8.0之前(直到Solidity 0.7.6)，可以显式地将任何整数类型<code class="fe ne nf ng nh b">uintN</code>转换为<code class="fe ne nf ng nh b">address</code>(通过转换)。从Solidity 0.8.0开始，只允许用<code class="fe ne nf ng nh b">uint160</code>进行显式转换。</p></blockquote><h2 id="7d7a" class="oq lx it bd ly or os dn mc ot ou dp mg li ov ow mi lm ox oy mk lq oz pa mm pb bi translated">从地址到uint160的转换</h2><ul class=""><li id="be31" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">不允许从<code class="fe ne nf ng nh b">address</code>到<code class="fe ne nf ng nh b">uint160</code> ❌的隐式转换</li><li id="ae16" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">允许从<code class="fe ne nf ng nh b">address</code>到<code class="fe ne nf ng nh b">uint160</code> ✅的显式转换</li></ul><p id="5d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是一个奇怪的例子，并不常见(<em class="lv">据我所知，我从未见过这样的实现)。下面的代码给出了一个说明性的例子</em></p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="acb3" class="oq lx it nh b gy pm pn l po pp">function addressToUint160() public view returns (uint160) {<br/>    <br/>    address from = msg.sender;<br/>    uint160 result = uint160(from);<br/>    return result;</span><span id="eabf" class="oq lx it nh b gy pq pn l po pp">}</span><span id="2807" class="oq lx it nh b gy pq pn l po pp">// example with msg.sender = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br/>// result = 520786028573371803640530888255888666801131675076</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="9b05" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">地址和应付地址之间的转换</h1><p id="9979" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">一个<code class="fe ne nf ng nh b">address from</code>可以通过<code class="fe ne nf ng nh b">payable(from)</code>显式地转换成<code class="fe ne nf ng nh b">address payable</code></p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="6218" class="oq lx it nh b gy pm pn l po pp">address payable from = msg.sender;</span><span id="fa64" class="oq lx it nh b gy pq pn l po pp">// TypeError: Type address is not implicitly convertible to expected type address payable.<br/></span><span id="10e2" class="oq lx it nh b gy pq pn l po pp">address payable from = payable(msg.sender);</span></pre><p id="5137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们前面的例子特别相关，因为任何到<code class="fe ne nf ng nh b">address</code>类型的显式转换(使用<code class="fe ne nf ng nh b">address(…)</code>)总是返回一个不可支付的<code class="fe ne nf ng nh b">address</code>类型。</p><p id="ee63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，任何地址文字、<code class="fe ne nf ng nh b">bytes20</code>或<code class="fe ne nf ng nh b">uint160</code>值都可以显式转换为<code class="fe ne nf ng nh b">address payable</code>，如下所示:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="1b69" class="oq lx it nh b gy pm pn l po pp">// conversion from Address Literal to address payable</span><span id="846a" class="oq lx it nh b gy pq pn l po pp">address to = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;<br/>address payable payableTo = payable(to);</span><span id="91a8" class="oq lx it nh b gy pq pn l po pp">// conversion from bytes20 to address payable</span><span id="b960" class="oq lx it nh b gy pq pn l po pp">bytes20 from = bytes20(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);<br/>address payable payableFrom = payable(address(from));<br/></span><span id="cd09" class="oq lx it nh b gy pq pn l po pp">// conversion from uint160 to address payable</span><span id="ce4c" class="oq lx it nh b gy pq pn l po pp">uint160 u = 12345;<br/>address payable converted = payable(address(u));</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="cc12" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">合同和地址类型之间的转换</h1><p id="31a9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">从<code class="fe ne nf ng nh b">address</code>到<code class="fe ne nf ng nh b">Contract</code>类型的显式转换可以完成。</p><p id="cc81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以Solidity文档中的以下示例为例:</p><pre class="kj kk kl km gt pi nh pj pk aw pl bi"><span id="c009" class="oq lx it nh b gy pm pn l po pp">address creator = TokenCreator(msg.sender);</span></pre><p id="cd76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种显式转换，我们在这里假设msg发送方(=调用契约)的类型是<code class="fe ne nf ng nh b">TokenCreator</code>。但是，除了使用ERC165标准接口检测(假设这里的<code class="fe ne nf ng nh b">msg.sender</code>实现了这个标准)之外，没有真正的方法来验证这一点。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="8fe5" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">参考</h1><ul class=""><li id="e0f9" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#new-restrictions" rel="noopener ugc nofollow" target="_blank"> Solidity v0.8.0重大变更— Solidity 0.8.13文档</a></li><li id="6317" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.13/types.html?highlight=Implicit%20conversion#conversions-between-elementary-types" rel="noopener ugc nofollow" target="_blank">类型—坚固性0.8.13文件</a></li><li id="dd9c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/solidity/solidity_conversions.htm#:~:text=Solidity%20compiler%20allows%20implicit%20conversion,value%20not%20allowed%20in%20uint256" rel="noopener ugc nofollow" target="_blank">坚固性——转换</a></li><li id="7817" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://learning-dcs-bbn.netlify.app/part%2005-module%2001-lesson%2002_new%20introduction%20to%20solidity%20and%20creating%20a%20token/06.%20type%20conversion%20in%20solidity" rel="noopener ugc nofollow" target="_blank">实型转换</a></li><li id="85c4" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/coinmonks/solidity-variables-storage-type-conversions-and-accessing-private-variables-c59b4484c183" rel="noopener">可靠性变量——存储、类型转换和访问私有变量</a></li><li id="86be" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="http://www.ifindbug.com/doc/id-16974/name-Solidity%20-%20Conversions.html" rel="noopener ugc nofollow" target="_blank">稳固性—转换—稳固性，稳固性教程—我发现Bug </a></li><li id="f00c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/coinmonks/solidity-variables-storage-type-conversions-and-accessing-private-variables-c59b4484c183" rel="noopener">可靠性变量——存储、类型转换和访问私有变量</a></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pw ps l"/></div></figure></div></div>    
</body>
</html>