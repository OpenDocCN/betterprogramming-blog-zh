<html>
<head>
<title>How to Use React Hooks With the GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在GraphQL API中使用React钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-react-hooks-with-the-graphql-api-448169ec19c?source=collection_archive---------5-----------------------#2020-02-05">https://betterprogramming.pub/using-react-hooks-with-the-graphql-api-448169ec19c?source=collection_archive---------5-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">集成前端开发中最热门的两个东西:Hooks和GraphQL</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d6e0de9d1502f6e7d75d14e64d75ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV1CD6aD8SlH9Gipb86fSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com/s/photos/integration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c7df" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">什么是挂钩？</strong></h1><p id="c0dc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">钩子是让你在不使用类组件的情况下进入“状态”的函数。</p><p id="e6ac" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不用考虑使用哪种生命周期方法，您现在可以编写考虑如何以及何时使用数据的组件。</p><p id="17e1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">React Hooks于2018年10月推出，2019年2月发布。React 16.8及更高版本现已提供。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5544" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">挂钩为什么受欢迎？</strong></h1><ol class=""><li id="2bae" class="mz na it ma b mb mc me mf mh nb ml nc mp nd mt ne nf ng nh bi translated">没有样板。您不需要导入新的库或编写任何样板代码，您可以在React 16.8及更高版本中直接开始使用钩子。</li><li id="d116" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">不需要使用类组件来使用状态。即使我们想在React组件中使用状态，也不再需要编写类组件。以前，如果我们写了一个函数组件，我们想在其中使用状态，我们必须把它改成类组件。通过钩子，我们可以在功能组件中使用状态。</li><li id="db79" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">安装和清理功能。<strong class="ma iu"> </strong>你不再需要考虑React什么时候挂载一个组件，你应该在<code class="fe nn no np nq b">componentDidMount</code>做什么，记得在<code class="fe nn no np nq b">componentWillUnmount</code>清理。钩子会把这些东西从盒子里拿出来。</li></ol><p id="9133" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">钩子说够了吗？让我们转向商业…</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2d4d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">入门</strong></h1><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ed88" class="nv lh it nq b gy nw nx l ny nz">npm install @apollo/react-hooks</span></pre><p id="9b64" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个包导出了<code class="fe nn no np nq b">ApolloProvider</code>组件，将客户端连接到React应用程序，就像旧的API一样。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1ce2" class="nv lh it nq b gy nw nx l ny nz">npm install graphql-tag</span></pre><p id="67c8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">将GraphQL查询字符串解析成标准GraphQL AST的JavaScript模板文字标签。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e163" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">一些常见的钩子</strong></h1><h2 id="f0a3" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated">1.使用状态</h2><p id="5c8c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nn no np nq b">useState</code>用于设置和更新状态，如类组件中的<code class="fe nn no np nq b">this.state</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="fca8" class="nv lh it nq b gy nw nx l ny nz">const [ state, setState] = useState(initialState);</span></pre><h2 id="604a" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated">2.使用效果</h2><p id="7ac5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">效果挂钩允许您在功能组件中执行副作用。副作用可能包括DOM操作、订阅和API调用。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="7838" class="nv lh it nq b gy nw nx l ny nz">useEffect(() =&gt; {<br/>  document.title = 'Hello World' <br/>});</span></pre><h2 id="be75" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated">3.用户教育</h2><p id="7c34" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nn no np nq b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code>的替代方案。接受类型为<code class="fe nn no np nq b">(state, action) =&gt; newState</code>的缩减器，并返回与<code class="fe nn no np nq b">dispatch</code>方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。)</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8316" class="nv lh it nq b gy nw nx l ny nz">const [ state, dispatch ] = useReducer(reducer, initialArg, init);</span></pre><h2 id="2b18" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated">4.使用上下文</h2><p id="8261" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">接受一个上下文对象(从<code class="fe nn no np nq b">React.createContext</code>返回的值)并返回该上下文的当前上下文值。当前上下文值由树中调用组件上方最近的<code class="fe nn no np nq b">&lt;MyContext.Provider&gt;</code>的<code class="fe nn no np nq b">value</code>属性决定。</p><p id="6060" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当组件上方最近的<code class="fe nn no np nq b">&lt;MyContext.Provider&gt;</code>更新时，这个钩子将触发一次重新渲染，将最新的上下文<code class="fe nn no np nq b">value</code>传递给那个<code class="fe nn no np nq b">MyContext</code>提供者。</p><p id="a963" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不要忘记<code class="fe nn no np nq b">useContext</code>的参数必须是<em class="ol">上下文对象本身</em>:</p><ul class=""><li id="847f" class="mz na it ma b mb mu me mv mh om ml on mp oo mt op nf ng nh bi translated">正确:<code class="fe nn no np nq b">useContext(MyContext)</code></li><li id="58fc" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt op nf ng nh bi translated">不正确:<code class="fe nn no np nq b">useContext(MyContext.Consumer)</code></li><li id="83c7" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt op nf ng nh bi translated">不正确:<code class="fe nn no np nq b">useContext(MyContext.Provider)</code></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="68b1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">graph QL是什么？</strong></h1><p id="356a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">根据<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="oq or os"><p id="9e9a" class="ly lz ol ma b mb mu ju md me mv jx mg ot mw mj mk ou mx mn mo ov my mr ms mt im bi translated">" G <!-- --> raphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时。</p><p id="ca78" class="ly lz ol ma b mb mu ju md me mv jx mg ot mw mj mk ou mx mn mo ov my mr ms mt im bi translated">GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。"</p></blockquote><p id="f5a5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">有两种主要类型的操作，查询和突变。</p><p id="f681" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="ol">查询</em>用于检索数据，而<em class="ol">变异</em>用于创建/更新/删除数据。</p><p id="5dd8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">GraphQL的另一个重要特性是可以使用单个端点和单个网络请求执行多个操作。这减少了往返和整体数据传输的次数，这在移动设备和糟糕的网络情况下非常重要。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="39ff" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">例题</strong></h1><p id="0ebc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">添加新用户(并选择在哪个字段上获得结果)的GraphQL变体:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="74db" class="nv lh it nq b gy nw nx l ny nz">mutation CreateUser($name: String!){<br/>  createUser(name: $name) {<br/>    name<br/>  }<br/>}</span></pre><p id="c862" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">获取用户列表的GraphQL查询:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c7cf" class="nv lh it nq b gy nw nx l ny nz">{<br/>  users {<br/>    name<br/>  }<br/>}</span></pre><h2 id="7582" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated"><strong class="ak">真实世界查询示例</strong></h2><p id="e03f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，我们将创建一个名为<code class="fe nn no np nq b">GET_DOGS</code>的GraphQL查询。记住将查询字符串包装在<code class="fe nn no np nq b">gql</code>函数中，以便将它们解析成查询文档:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="670c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">接下来，我们将创建一个名为<code class="fe nn no np nq b">Dogs</code>的组件。在其中，我们将把我们的<code class="fe nn no np nq b">GET_DOGS</code>查询传递给<code class="fe nn no np nq b">useQuery</code>钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="9139" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当我们的查询执行并且<code class="fe nn no np nq b">loading</code>、<code class="fe nn no np nq b">error</code>和<code class="fe nn no np nq b">data</code>的值改变时，<code class="fe nn no np nq b">Dogs</code>组件可以根据查询的状态智能地呈现不同的UI元素:</p><ul class=""><li id="6b0f" class="mz na it ma b mb mu me mv mh om ml on mp oo mt op nf ng nh bi translated">只要<code class="fe nn no np nq b">loading</code>为<code class="fe nn no np nq b">true</code>(表示查询仍在进行中)，组件就会显示一个<code class="fe nn no np nq b">Loading...</code>通知。</li><li id="f7fe" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt op nf ng nh bi translated">当加载为<code class="fe nn no np nq b">false</code>且没有<code class="fe nn no np nq b">error</code>时，查询完成。该组件呈现一个下拉菜单，其中填充了服务器返回的狗品种列表。</li></ul><h2 id="fcbc" class="nv lh it bd li oa ob dn lm oc od dp lq mh oe of ls ml og oh lu mp oi oj lw ok bi translated"><strong class="ak">真实世界突变示例</strong></h2><p id="61f0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们知道了如何查询数据，让我们看看如何创建突变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="5b30" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在我们将看到如何调用我们上面创建的突变来保存记录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="cf5c" class="lg lh it bd li lj oy ll lm ln oz lp lq jz pa ka ls kc pb kd lu kf pc kg lw lx bi translated"><strong class="ak">结论</strong></h1><p id="2720" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">钩子是反应的一个强大的附加物。此外，React Hooks是一个强大的库，可以在React应用程序中使用带有GraphQL的钩子。我建议你现在就用钩子弄脏你的手，因为你已经有基础了。</p><p id="ebb3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">你今天学到新东西了吗？评论和反馈总是让作者开心！</p></div></div>    
</body>
</html>