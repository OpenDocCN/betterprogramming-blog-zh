<html>
<head>
<title>Deep Links, Universal Links, and the SwiftUI App Life Cycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度链接、通用链接和SwiftUI应用生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deep-links-universal-links-and-the-swiftui-app-life-cycle-e98e38bcef6e?source=collection_archive---------2-----------------------#2020-07-29">https://betterprogramming.pub/deep-links-universal-links-and-the-swiftui-app-life-cycle-e98e38bcef6e?source=collection_archive---------2-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c077" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在新的SwiftUI应用生命周期中处理深度链接，并发现一种管理它们的优雅方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8789d7992973acfa6ec106214b705ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3DUbtop5jaU_Ok_PRgwahA.png"/></div></div></figure><h1 id="e7e5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><p id="5289" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在WWDC20上，苹果推出了SwiftUI 2.0和iOS 14的许多新功能。继去年的主题演讲之后，这些新功能将仅由SwiftUI提供支持。</p><p id="fc48" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了让它更有吸引力，苹果发布了新的SwiftUI应用生命周期:100%用SwiftUI编写的应用。只要使用<code class="fe mn mo mp mq b">@main</code>并符合新协议，<code class="fe mn mo mp mq b">App</code>我们就可以告诉Xcode我们应用程序的起点在哪里。但是UIKit的<code class="fe mn mo mp mq b">AppDelegate</code>会怎么样呢？该文件便于:</p><ul class=""><li id="8b8c" class="mr ms it lo b lp mi ls mj lv mt lz mu md mv mh mw mx my mz bi translated">启动时配置第三方库</li><li id="0cd7" class="mr ms it lo b lp na ls nb lv nc lz nd md ne mh mw mx my mz bi translated">处理通知</li><li id="ed3c" class="mr ms it lo b lp na ls nb lv nc lz nd md ne mh mw mx my mz bi translated">处理深层和通用链接</li></ul><p id="dd5c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本教程中，我们将重点关注深层链接，并学习如何使用SwiftUI的新修饰符来监听这些事件，以及提供一种整洁干净的方法来处理它们。注意，我们所说的深度链接同样适用于通用链接。唯一增加的是你需要<a class="ae nf" href="https://developer.apple.com/documentation/safariservices/supporting_associated_domains" rel="noopener ugc nofollow" target="_blank">支持相关域名</a>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a0f6" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">简介:旅行日历</h1><p id="a49f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我们将使用这个名为Trips Calendar的示例应用程序。该应用程序显示您的旅行列表，并让您导航到详细视图。您也可以添加或删除行程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/dee380d5f195485557decca6ddd750d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*bSY2Yi_vtABMHwg9IG0-Xg.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">主屏幕</p></figure><p id="a7f7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们如何实现深度链接，以便用户只需使用SwiftUI代码就可以导航到详细视图？我们将在接下来的几节中看到如何处理深度链接。<em class="nx"> </em>你可以在我的资源库<a class="ae nf" href="https://github.com/fermoya/TripsCalendar" rel="noopener ugc nofollow" target="_blank">这里</a>找到本教程的全部实现:</p><div class="ny nz gp gr oa ob"><a href="https://github.com/fermoya/TripsCalendar" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">费尔莫亚/特里斯卡伦达</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d11b" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">设置应用深层链接</h1><p id="b5e2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您熟悉在应用程序中设置URL类型，可以跳过这一部分。否则，继续读。</p><p id="4aa1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">深层链接只是带有明确指向你的应用的方案的URL。例如，对于旅行日历，我们可以想出一个类似<code class="fe mn mo mp mq b">tcal</code> <em class="nx">的方案。</em>这样，任何带有此方案的URL都将启动我们的应用程序。</p><p id="608e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为此，请转到Xcode中的项目文件。选择你的目标，进入“信息”，向下滚动直到你找到“网址类型”点击+按钮，在“URL方案”下添加您的方案</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/030c054e92537ab1ee43d5880b2f7d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5DGZwjFyEVQEbj3jwjUjQ.png"/></div></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0f08" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">处理深层链接</h1><p id="61f7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">SwiftUI 2.0附带了一个新的修改器，<code class="fe mn mo mp mq b">onOpenURL</code>。这个修改器在任何<code class="fe mn mo mp mq b">View</code>中都有。尽管您可以简单地在任何可能需要的<code class="fe mn mo mp mq b">View</code>上实现<code class="fe mn mo mp mq b">onOpenURL</code>，但这并不是一个好主意——您很可能会重复代码来处理深层链接，也就是说，确定要对特定链接执行的操作。</p><p id="5546" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我提议的解决方案是使用<code class="fe mn mo mp mq b">App</code>来完成这一处理，并使用<code class="fe mn mo mp mq b">environment</code>来传播链接，并相应地对更改做出反应。</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="a728" class="ov kv it mq b gy ow ox l oy oz">@main<br/>struct TripsCalendarApp: App {<br/>    var body: some Scene {<br/>        WindowGroup {<br/>            ContentView()<br/>                .onOpenURL {<br/>                    // code here<br/>                }<br/>        }<br/>    }<br/>}</span></pre><h2 id="e9ff" class="ov kv it bd kw pa pb dn la pc pd dp le lv pe pf lg lz pg ph li md pi pj lk pk bi translated">解析深层链接</h2><p id="00a1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mn mo mp mq b">DeepLinker</code>的唯一目的是处理深层链接。现在，Trips Calendar感兴趣的深层链接有两种:</p><ul class=""><li id="6132" class="mr ms it lo b lp mi ls mj lv mt lz mu md mv mh mw mx my mz bi translated"><code class="fe mn mo mp mq b">home</code>:在主屏幕上打开应用程序</li><li id="f6b9" class="mr ms it lo b lp na ls nb lv nc lz nd md ne mh mw mx my mz bi translated"><code class="fe mn mo mp mq b">details</code>:导航至详细视图</li></ul><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="9586" class="ov kv it mq b gy ow ox l oy oz">class Deeplinker {<br/>    enum Deeplink: Equatable {<br/>        case home<br/>        case details(reference: String)<br/>    }</span><span id="8bb4" class="ov kv it mq b gy pl ox l oy oz">    ...<br/>}</span></pre><p id="e3f6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们为什么要处理主屏幕的URL呢？嗯，这是通常在应用程序启动时首先呈现给任何用户的屏幕，但如果用户在你的应用程序中的任何屏幕中，转到后台，并点击深层链接，会发生什么？在这种情况下，没有向前导航，只有向后导航。这也是我们希望能够处理的事情:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="2283" class="ov kv it mq b gy ow ox l oy oz">func manage(url: URL) -&gt; Deeplink? {<br/>    guard url.scheme == URL.appScheme else { return nil }<br/>    guard url.pathComponents.contains(URL.appDetailsPath) else { return .home }<br/>    guard let query = url.query else { return nil }</span><span id="147f" class="ov kv it mq b gy pl ox l oy oz">    let components = query.split(separator: ",").flatMap { $0.split(separator: "=") }<br/>    guard let idIndex = components.firstIndex(of: Substring(URL.appReferenceQueryName)) else { return nil }<br/>    guard idIndex + 1 &lt; components.count else { return nil }<br/>    <br/>    return .details(reference: String(components[idIndex.advanced(by: 1)]))<br/>}</span></pre><p id="13e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以基本上，Trips Calendar Deep Linker会检查URL方案，以确保它与app方案匹配。如果没有找到URL路径，则默认为主屏幕。否则，它会在URL查询中查找一个参数来创建<code class="fe mn mo mp mq b">details</code>深层链接。</p><p id="3136" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以现在从<code class="fe mn mo mp mq b">App</code>文件中，我们可以处理深层链接并在URL被识别时执行操作:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="f2fa" class="ov kv it mq b gy ow ox l oy oz">.onOpenURL { url in<br/>    let deeplinker = Deeplinker()<br/>    guard let deeplink = deeplinker.manage(url: url) else { return }</span><span id="a7a5" class="ov kv it mq b gy pl ox l oy oz">    // do something<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="dcdd" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">使用环境值</h1><p id="465a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">SwiftUI中新增的是修饰符<code class="fe mn mo mp mq b">onchange(of:perform:)</code>。这对于观察环境值的变化非常有用，例如，<code class="fe mn mo mp mq b">scenePhase</code>取代了<code class="fe mn mo mp mq b">SceneDelegate</code>应用生命周期通知(后台、活动、非活动等)。).我们可以利用同样的方法，为深度链接创建我们自己的<code class="fe mn mo mp mq b">EnvironmentKey</code>:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="2c7d" class="ov kv it mq b gy ow ox l oy oz">struct DeeplinkKey: EnvironmentKey {<br/>    static var defaultValue: Deeplinker.Deeplink? {<br/>        return nil<br/>    }<br/>}</span><span id="e0a9" class="ov kv it mq b gy pl ox l oy oz">extension EnvironmentValues {<br/>    var deeplink: Deeplinker.Deeplink? {<br/>        get {<br/>            self[DeeplinkKey]<br/>        }<br/>        set {<br/>            self[DeeplinkKey] = newValue<br/>        }<br/>    }<br/>}</span></pre><p id="6e65" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这样，<code class="fe mn mo mp mq b">App</code>将接收一个深度链接，并将其作为一个环境值注入:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="8603" class="ov kv it mq b gy ow ox l oy oz">@main<br/>struct TripsCalendarApp: App {</span><span id="6799" class="ov kv it mq b gy pl ox l oy oz">    @State var deeplink: Deeplinker.Deeplink?<br/>    ...</span><span id="edf7" class="ov kv it mq b gy pl ox l oy oz">    var body: some Scene {<br/>        WindowGroup {<br/>            ContentView()<br/>                ...<br/>                .environment(\.deeplink, deeplink)<br/>                .onOpenURL { url in<br/>                    let deeplinker = Deeplinker()<br/>                    guard let deeplink = deeplinker.manage(url: url) else { return }<br/>                    self.deeplink = deeplink<br/>                }<br/>        }<br/>    }<br/>}</span></pre><p id="e0d0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意<code class="fe mn mo mp mq b">App</code>是如何定义一个<code class="fe mn mo mp mq b">State</code>变量并将其作为一个<code class="fe mn mo mp mq b">environment</code>变量注入到其<code class="fe mn mo mp mq b">ContentView</code>中的。这将使它不仅在<code class="fe mn mo mp mq b">ContentView</code>中可用，而且对它的所有子代都可用:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="d42b" class="ov kv it mq b gy ow ox l oy oz">+ ContentView<br/>  + CalendarView<br/>    + List<br/>      + CalendarView</span></pre><p id="524a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">比如《T21》里面:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="2790" class="ov kv it mq b gy ow ox l oy oz">@State var cellSelected: Int?<br/>@Environment(\.deeplink) var deeplink</span><span id="73e1" class="ov kv it mq b gy pl ox l oy oz">var body: some View {<br/>    List {<br/>        ForEach((0..&lt;trips.count)) { index in<br/>            NavigationLink(destination: TripDetailView(trip: trips[index]), tag: index, selection: $cellSelected) {<br/>                CalendarEntryView(trip: trips[index])<br/>                    .onTapGesture {<br/>                        cellSelected = index<br/>                    }<br/>         }<br/>     }<br/>     .onChange(of: deeplink, perform: { deeplink in<br/>         // process deeplink<br/>         cellSelected = indexInsideDeeplink<br/>     }<br/>}</span></pre><p id="e22c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注意:</strong>环境变量以及环境对象只能从视图层次结构中访问。这意味着如果推送或呈现另一个视图，您将需要再次传递环境值。</p><p id="c35f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如在<code class="fe mn mo mp mq b">ContetnView</code>中:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="8fe4" class="ov kv it mq b gy ow ox l oy oz">.sheet(isPresented: $isNewTripPresented) {<br/>    NavigationView {<br/>        NewTripView()<br/>            .environment(\.deeplink, deeplink)<br/>        }<br/>    }<br/>}</span></pre><p id="51b5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后在<code class="fe mn mo mp mq b">NextTripView</code>里面:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="6663" class="ov kv it mq b gy ow ox l oy oz">@Environment(\.presentationMode) var presentationMode<br/>@Environment(\.deeplink) var deeplink</span><span id="ff0f" class="ov kv it mq b gy pl ox l oy oz">var body: some View {<br/>    ...<br/>    .onChange(of: deeplink, perform: { deeplink in<br/>        guard let _ = deeplink else { return }<br/>        presentationMode.wrappedValue.dismiss()<br/>    })<br/>}</span></pre><h2 id="e835" class="ov kv it bd kw pa pb dn la pc pd dp le lv pe pf lg lz pg ph li md pi pj lk pk bi translated">重置环境值</h2><p id="f425" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一旦被消耗，环境值不会像现在这样被重置。这意味着如果用户再次点击同一个链接，什么也不会发生——因为环境<code class="fe mn mo mp mq b">deepLink</code>没有改变。</p><p id="f38e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在<code class="fe mn mo mp mq b">App</code>文件中，几毫秒后重置深层链接:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="fbc8" class="ov kv it mq b gy ow ox l oy oz">.onOpenURL { url in<br/>    // proccess deeplink<br/>    DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(200)) {<br/>        self.deeplink = nil<br/>    }<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ac2a" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">测试深层链接</h1><p id="2f7d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你使用的是真实的设备，只需点击一个包含你的应用程序方案的自动生成的URL(用它给自己发一封电子邮件，或者在笔记中记下URL)。对于模拟器，您可以使用命令行发送到您的应用程序的深层链接。在我们的例子中，我们可以使用这个:</p><pre class="kj kk kl km gt or mq os ot aw ou bi"><span id="a15d" class="ov kv it mq b gy ow ox l oy oz">xcrun simctl openurl booted "tcal://www.trips.calendar.com/details?reference=55091-231959"</span></pre><p id="2ada" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">观看它的实际应用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/24dd48bec0bc25ed633170205df4345c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*HK-c21MN8IKW0WX_gudebA.gif"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">弹出视图并推出新视图的深层链接</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/8c6b8c81fa1c3880f7025a4423ecce66.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*JAbHR-uDUnDtDJj8YhGuBQ.gif"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">深层链接消除一种模式，推出一种新的观点</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c41b" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">结论</h1><p id="4bc2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">SwiftUI的新版本提供了比其前身更多的工具，这显然是苹果试图提升SwiftUI并鼓励开发者使用它。在SwiftUI中不再需要<code class="fe mn mo mp mq b">AppDelegate</code>。</p><p id="4242" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们已经看到了一个干净的实现，它遵循SRP并避免了代码的重复，使得扩展和修改变得容易。我们还研究了WWDC20中引入的一些新修饰符，并在示例应用程序中实现了它们。</p></div></div>    
</body>
</html>