<html>
<head>
<title>The Power and Limitations of JavaScript Promise.all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Promise.all的力量和局限性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-and-limitations-of-javascript-promise-all-6e1b53520e50?source=collection_archive---------4-----------------------#2021-06-03">https://betterprogramming.pub/the-power-and-limitations-of-javascript-promise-all-6e1b53520e50?source=collection_archive---------4-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写异步JavaScript时并行的力量——以及要注意的陷阱！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f67d2199ef081c1f65159d408aad9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGOI9yzi6bZmI4pAGkDnUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Alberto Barrera 在<a class="ae ky" href="https://unsplash.com/s/photos/promises?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="1b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多web开发项目中，重要的功能依赖于异步代码——无论是向API发出HTTPS请求、查询和更新数据库，还是管理像读取大文件这样的时间敏感任务。</p><p id="ca29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你能确保你的异步代码尽可能高效地运行吗？</p><p id="d1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我刚接触异步JavaScript时，我经常<code class="fe lv lw lx ly b">await</code>每个承诺，却没有意识到我在代码中制造了不必要的瓶颈。一旦明白了<code class="fe lv lw lx ly b">Promise.all</code>的一些好处，我就经历了一个过度使用的阶段。在特定的场景中，我的代码变得不一致，因为我试图并行地做一些相互影响的事情，并且最先发生的任务是最快的！</p><p id="a5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探究并行的威力，同时也要注意过度使用<code class="fe lv lw lx ly b">Promise.all</code>的危险。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="caed" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何承诺。所有作品</h1><p id="3751" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们从一个基本的例子开始。首先，我们将创建一个从<code class="fe lv lw lx ly b">1</code>到<code class="fe lv lw lx ly b">100</code>的数字数组:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f01d" class="nh mh it ly b gy ni nj l nk nl">const nums = new Array(100).fill(1).map((num, i) =&gt; i + 1);</span></pre><p id="6db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创建一个需要50毫秒完成的异步函数。为了简化示例，我们将依靠<code class="fe lv lw lx ly b">useTimeout</code>来模拟API调用，而不是实际发出HTTP请求:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e92d" class="nh mh it ly b gy ni nj l nk nl">const asyncDouble<strong class="ly iu"> </strong>= num =&gt; {<br/>  return new Promise((resolve, reject) =&gt; setTimeout(() =&gt; {<br/>    return resolve(num * 2);<br/>  }, 50));<br/>}</span></pre><p id="611f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的异步函数接受一个数，并将其加倍。现在让我们假设我们想为数组中的每一项调用这个函数。</p><p id="0e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是同步代码，我们可能会选择<code class="fe lv lw lx ly b">map</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b357" class="nh mh it ly b gy ni nj l nk nl">const doubledNums = nums.map(num =&gt; num * 2);</span></pre><p id="f075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们使用我们的<code class="fe lv lw lx ly b">asyncDouble</code>函数来尝试，会发生什么呢？</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="531f" class="nh mh it ly b gy ni nj l nk nl">const doubledNums = nums.map(async (num) =&gt; await asyncDouble(num));</span></pre><p id="e56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们已经添加了<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>关键字，但还是有一个问题。我们登录到控制台的<code class="fe lv lw lx ly b">doubledNums</code>充满了未兑现的承诺！那是因为<code class="fe lv lw lx ly b">map</code>不是用来处理承诺的。</p><p id="8fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是使用<code class="fe lv lw lx ly b">for</code>循环，就像这样:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7d27" class="nh mh it ly b gy ni nj l nk nl">const doubledNums = [];</span><span id="bb56" class="nh mh it ly b gy nm nj l nk nl">for (const num of nums) {<br/>  doubledNums.push(await asyncDouble(num));<br/>}</span></pre><p id="56f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们得到了我们想要的结果，但是对<code class="fe lv lw lx ly b">promiseFunc</code>的每个调用只有在前一个调用解决之后才发生。需要五秒钟才能得到最终结果。如果我们需要查询100万个值，那将需要将近14个小时！</p><p id="0f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lv lw lx ly b">Promise.all</code>的用武之地。它以并行方式触发每个承诺，并且仅在所有其他承诺都已解决时才解决:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="77ea" class="nh mh it ly b gy ni nj l nk nl">const doubledNums = await Promise.all(nums.map(num =&gt; asyncDouble(num)));</span></pre><p id="8d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，并行运行，这需要大约50毫秒——与单个<code class="fe lv lw lx ly b">promiseFunc</code>实例的时间长度相同。与依次履行每个承诺相比，你节省了很多时间。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0192" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们一次能解决多少承诺？</h1><p id="ee63" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们能把<code class="fe lv lw lx ly b">Promise.all</code>推多远，一次能触发多少承诺？当然，这取决于一系列因素，如处理能力和承诺的复杂性。</p><p id="733f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有处理能力，并且我们的承诺可以并行运行，那么有一个超过200万个承诺的硬限制。</p><p id="00e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们深入研究Chrome和Node.js底层的JavaScript引擎V8的代码，我们可以看到长度为<code class="fe lv lw lx ly b">2**21</code>或更长的数组会触发<code class="fe lv lw lx ly b">TooManyElementsInPromiseAll</code>错误。因此，长度2，097，150是可以接受的，而2，097，151会引发错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们中很少有人会在这个极限附近工作。然而，这并不意味着我们总是可以并行运行承诺。一个更常见的问题是尝试并行运行相互依赖的承诺，而不是担心规模。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0431" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">承诺的局限性是什么？</h1><p id="425a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，警告一句。当我还是一个经验不足的开发人员时，我因为过于自由地使用<code class="fe lv lw lx ly b">Promise.all</code>而在尝试优化数据库CRUD操作时遇到了困难。即使一个函数不直接依赖于另一个函数的结果，它们仍然可能以执行顺序很重要的方式影响相同的字段。</p><p id="ba73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想象一个简单的MongoDB数据库，其中包含比萨饼类型、它们的价格(以美分计)以及它们在菜单上的顺序:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8f9f" class="nh mh it ly b gy ni nj l nk nl">[<br/>  {<br/>    type: "<a class="ae ky" href="https://en.wikipedia.org/wiki/Pizza_quattro_formaggi" rel="noopener ugc nofollow" target="_blank">Quattro formaggi</a>",<br/>    price: 1200,<br/>    order: 0,<br/>  },<br/>  {<br/>    type: "<a class="ae ky" href="https://en.wikipedia.org/wiki/Pizza_quattro_formaggi" rel="noopener ugc nofollow" target="_blank">H</a>awaiian",<br/>    price: 1000,<br/>    order: 1,<br/> },<br/>  {<br/>    type: "<a class="ae ky" href="https://en.wikipedia.org/wiki/Pizza_quattro_formaggi" rel="noopener ugc nofollow" target="_blank">M</a>argherita",<br/>    price: 800,<br/>    order: 2,<br/>  },<br/>]</span></pre><p id="91dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望使用三个异步函数来更新我们的定价:</p><ul class=""><li id="fa68" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">全面提价50%的方案。</li><li id="babd" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">另一个将5美元的折扣应用于夏威夷披萨。</li><li id="4b47" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">第三个更新菜单顺序，从最便宜的披萨到最贵的披萨。</li></ul><p id="30c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试异步运行它们会发生什么？</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a9ad" class="nh mh it ly b gy ni nj l nk nl">await Promise.all([<br/>  inflatePrices(),<br/>  discountHawaiian(),<br/>  sortByPrice(),<br/>]);</span></pre><p id="77b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能保证这些函数中的一个总是最快的，而另一个总是最慢的，这意味着承诺可以以任何顺序执行。因为这些函数相互依赖，这就给我们的最终结果带来了一致性。</p><p id="db35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">inflatePrices</code>在<code class="fe lv lw lx ly b">discountHawaiian</code>执行之前执行，我们的夏威夷披萨将花费10.00美元。但是如果函数以相反的顺序执行，它将花费7.50美元。根据<code class="fe lv lw lx ly b">sortByPrice</code>的说法，考虑到最终价格，这款披萨的订购可能正确，也可能不正确。</p><p id="b6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，更好的做法是容忍代码的性能有一个可忽略的降低，并有一个一致的、可重复的结果，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="09b3" class="nh mh it ly b gy ni nj l nk nl">await inflatePrices();<br/>await discountHawaiian();<br/>await sortByPrice();</span></pre><p id="4557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找出相互依赖的函数并不总是那么容易。出于这个原因，对使用<code class="fe lv lw lx ly b">Promise.all </code>过度优化保持警惕是很重要的——尤其是如果您没有完全理解您的异步函数可能正在做的所有事情。</p><p id="dbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当你知道你可以安全地并行解决承诺的时候，<code class="fe lv lw lx ly b">Promise.all</code>是一个非常有用的工具来帮助你加速你的代码！</p></div></div>    
</body>
</html>