<html>
<head>
<title>Swift 101: Develop a To-Do List App With CloudKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 101:用CloudKit开发待办事项应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-it-yourself-develop-a-to-do-app-with-cloudkit-e029e820df43?source=collection_archive---------4-----------------------#2020-03-19">https://betterprogramming.pub/swift-it-yourself-develop-a-to-do-app-with-cloudkit-e029e820df43?source=collection_archive---------4-----------------------#2020-03-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ff32" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过在Apple的CloudKit上构建经典的待办事项应用程序来学习Swift</h2></div><p id="bcb4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">要开发一个允许数据和文件在不同设备之间共享和同步的应用程序，我们需要一个后端服务来执行这些任务。对于装有iOS或macOS的设备，我们可以使用CloudKit。在本文中，我们将了解如何使用CloudKit开发任务应用程序。</p><h1 id="0fc0" class="lf lg iu bd lh li lj lk ll lm ln lo lp ka lq kb lr kd ls ke lt kg lu kh lv lw bi translated">什么是CloudKit？</h1><p id="c4be" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated"><code class="fe mc md me mf b"><a class="ae mg" href="https://developer.apple.com/icloud/cloudkit/" rel="noopener ugc nofollow" target="_blank">CloudKit</a></code>是Apple的存储服务，允许您的应用程序远程保存数据和文件。苹果在2014年<a class="ae mg" href="https://developer.apple.com/videos/wwdc2014/" rel="noopener ugc nofollow" target="_blank"> WWDC大会</a>上推出了<code class="fe mc md me mf b">CloudKit</code>，作为一个允许与iCloud服务器通信的新库。</p><p id="c38f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有了<code class="fe mc md me mf b">CloudKit</code>和Swift，我们可以免费存储任何类型的数据和文件——高达10gb的文件存储、100 MB的数据库存储、2 GB的数据传输和每秒40个请求。但我们可以免费获得更大的容量，具体取决于添加的用户数量(1 PB的文件存储、10 TB的数据库、200 TB的数据传输和每秒400个请求)。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/b40545c6f2be5ce089c0290d1fa39647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wg7Ycg9FyvIAxD5J.png"/></div></div></figure><p id="decc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们可以将<code class="fe mc md me mf b">CloudKit</code>与其他BaaS(后端即服务)解决方案进行比较，比如<a class="ae mg" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>。</p><p id="0701" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">通过<code class="fe mc md me mf b">CloudKit</code>，苹果还提供:</p><ul class=""><li id="81e3" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated">用于在设备和iCloud之间通信和传输数据的API。</li><li id="1b45" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">管理苹果服务器上存储的数据、测量用户活动或带宽消耗的桌面。</li></ul></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="23d4" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">使用云工具包</h1><p id="d96d" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">要使用CloudKit，我们必须牢记:</p><ul class=""><li id="6afe" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated">您必须在iOS开发者计划中注册才能使用<code class="fe mc md me mf b">CloudKit</code>。</li><li id="2cb6" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">由于数据不是保存在本地，而是在苹果服务器上，如果没有互联网连接，使用<code class="fe mc md me mf b">CloudKit</code>的应用程序是没有用的。</li><li id="2864" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">用户数据受到保护，因为开发人员只能访问他们自己的数据库，而不能访问私人用户数据。</li><li id="a914" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">Apple建议在出现错误时通知用户(例如在保存过程中发现错误)，以便他们知道数据可能已经丢失或尚未保存。</li></ul></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="5302" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">CloudKit数据库</h1><p id="fd33" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">使用<code class="fe mc md me mf b">CloudKit</code>时，我们必须记住，就像每个应用程序都有自己的<code class="fe mc md me mf b">sandbox</code>一样，<code class="fe mc md me mf b">icloud</code>中的每个应用程序都有一个容器(如果我们已经为它注册了应用程序，我们将在后面看到)。<code class="fe mc md me mf b">CloudKit</code>定义了三种类型的数据库:</p><ul class=""><li id="4014" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated">私人的</li><li id="919c" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">公共</li><li id="e082" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">共享的</li></ul><h2 id="ba19" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">私有数据库</h2><p id="5702" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">应用程序的每个用户(如果已经注册使用<code class="fe mc md me mf b">iCloud</code>)在iCloud容器中都有一个私有数据库，只要用户登录到他们的<code class="fe mc md me mf b">iCloud</code>帐户。由于是私有的，开发者不能访问存储在这个数据库中的数据。</p><h2 id="af09" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">公共数据库</h2><p id="7a89" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">一个<code class="fe mc md me mf b">iCloud</code>容器也包含一个公共数据库，但是在这种情况下，它的数据可以被应用程序的所有用户读取，即使他们没有使用他们的<code class="fe mc md me mf b">iCloud</code>帐户登录。请注意，由于<code class="fe mc md me mf b">CloudKit</code>日志总是有一个所有者，所以只有登录到<code class="fe mc md me mf b">iCloud</code>的用户能够将数据写入公共数据库。</p><h2 id="0d57" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">共享数据库</h2><p id="1463" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">与私人数据库一样，共享数据库只有在您登录iCloud后才能访问。它用于与应用程序的其他用户共享用户私有数据库中的记录。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="90c6" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">要考虑的概念</h1><p id="9c51" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">使用<code class="fe mc md me mf b">CloudKit</code>时，我们必须考虑一些概念:</p><ul class=""><li id="b2bf" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><strong class="kl iv">集装箱。如我们所见，这些是存储用户数据的<code class="fe mc md me mf b">CKContainer</code>类的实例。我们可以访问应用程序的默认容器(<code class="fe mc md me mf b">default</code>)或我们已经创建的容器:</strong></li></ul><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="844b" class="oj lg iu mf b be ok ol l om on">let defaultContainer = CKContainer.default()<br/>let customContainer = CKContainer(identifier: "{YOUR_CONTAINER_IDENTIFIER}")</span></pre><ul class=""><li id="325b" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><strong class="kl iv">数据库。如我们所见，在<code class="fe mc md me mf b">CloudKit</code>中有三个数据库:公共的、私有的和共享的。它们由类型<code class="fe mc md me mf b">CKDatabase</code>的对象表示。</strong></li><li id="2b76" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">注册表。</strong>这些是类型<code class="fe mc md me mf b">CKRecord</code>的对象。我们可以把它们看作字典，其中的关键字是数据库中表的字段。</li><li id="426d" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">地带。</strong>这些由<code class="fe mc md me mf b">CKZone</code>类型的对象表示。这是保存数据的地方。在<code class="fe mc md me mf b">CloudKit</code>中，所有数据库都有一个默认区域，但是我们也可以创建自定义区域，尽管只是在私有数据库中。</li></ul></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="cadf" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">TodoList项目</h1><p id="a752" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">我们要创建一个待办事项app，<code class="fe mc md me mf b">TodoList</code>，保存在<code class="fe mc md me mf b">iCloud</code>。你可以从<a class="ae mg" href="https://github.com/raulferrerdev/TodoList" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载这个项目。</p><p id="ee24" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">首先，我们使用<em class="oo">单视图应用</em>模板在Xcode中创建新项目:</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/593dae1930d95769e31652c7700f3c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vhTxUQiPpL-nRINU.png"/></div></div></figure><p id="aa8f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，我们输入项目数据并选择<em class="oo">使用核心数据</em>和<em class="oo">使用CloudKit </em>选项。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/f32b34a1155dbf40ece99dc12865fb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h1XVKYPZmj_L1Afr.png"/></div></div></figure><p id="7ba7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们必须在项目中添加使用<em class="oo"> iCloud </em>的功能。为此，我们在<em class="oo">目标</em>中选择应用程序，然后选择<em class="oo">签名&amp;功能</em>选项卡，最后选择<em class="oo">+功能</em>选项。将出现一个菜单，从中我们可以选择<em class="oo"> iCloud </em>选项。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/89f6d5420eec142005686cf5c1bfe5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ReUH_ozwsQR2Hs13.png"/></div></div></figure><h2 id="a7aa" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">CloudKit仪表板</h2><p id="77ef" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">现在我们已经创建了项目和容器，我们必须为我们将在应用程序中使用的数据创建记录。我们可以从<em class="oo"> CloudKit </em>桌面上完成这项工作。为此，我们单击<em class="oo"> CloudKit仪表盘</em>按钮。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/0c48771ed93062a92fec578615d085d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZzeqApBEolicrZWm.png"/></div></div></figure><p id="ada6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如上图所示，<em class="oo"> CloudKit </em>桌面有六个部分:</p><ul class=""><li id="6dd1" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><strong class="kl iv"> API访问。</strong>管理允许调用web服务的API令牌和服务器到服务器密钥。</li><li id="6414" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">数据。</strong>管理公共、私有和共享数据库中的记录及其类型、索引、订阅和安全性。</li><li id="daaf" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">图式。</strong>在这里我们可以找到<em class="oo">注册类型、</em>索引、<em class="oo">安全角色</em>和<em class="oo">订阅类型</em>的选项。</li><li id="4f1d" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">日志。</strong>显示服务器活动或通知的历史和实时数据。</li><li id="5a51" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">遥测。</strong>显示使用数据库时服务器端使用情况和性能的图表，以及通知事件。</li><li id="4f4b" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">用法。</strong>显示有关活动用户、每秒请求数或数据存储的信息。</li></ul><h2 id="a28c" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">从CloudKit仪表板创建数据库</h2><p id="dec5" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">正如我们之前所评论的，我们将创建一个简单的应用程序，允许我们管理一系列任务，我们将在<em class="oo"> iCloud </em>中同步这些任务。由于这是一个简单的例子，我们将创建一个数据库，其中包含一个保存任务的表，该表具有以下属性:标题、创建日期、修改日期以及是否完成。</p><p id="821a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">从CloudKit桌面选择<em class="oo"> Schema &gt;记录类型&gt;新类型</em>，并将其命名为<em class="oo">任务</em>。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/e9134fbe9abc1eaf2dde3b95047bd5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*46T0mPPyMAqPNuPF.png"/></div></div></figure><p id="5982" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦创建了这种类型的记录，我们选择它并开始添加字段(添加完之后，点击<em class="oo">保存</em>):</p><ul class=""><li id="cdda" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><strong class="kl iv">标题</strong>(类型<em class="oo">串</em>)</li><li id="2f8e" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">创建日期</strong>(类型<em class="oo">日期</em>)</li><li id="39d6" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">修改日期</strong>(类型<em class="oo">日期</em>)</li><li id="7ed3" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">已检查</strong>(类型<em class="oo"> Int64 </em>，因为没有布尔值)</li></ul><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/8c7fae888868d8d06c3c77052a978add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oHdCZ-IJqw2wiux7.png"/></div></div></figure><p id="9b19" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">数据可以有以下任何一种基本类型(你也可以把这些数据做成数组，<em class="oo"> List </em>):</p><ul class=""><li id="fb7d" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><strong class="kl iv">资产。</strong>它是一个与记录相关联的文件，尽管它是独立存储的(它有1 MB的限制)。</li><li id="a9d6" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">日期/时间。一个日期和时间数据。</li><li id="d733" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv"> Int(64)。</strong>64位整数。</li><li id="2ef0" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">替身。</strong>一个<strong class="kl iv">一个</strong>双数。</li><li id="c310" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">字节。</strong>存储在注册表本身的字节缓冲区。</li><li id="1292" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">弦。</strong>一个文本字符串。</li><li id="38e3" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">地点。</strong>为地理位置数据。</li><li id="25ef" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><strong class="kl iv">参考。</strong>对另一个表的引用，以便在它们之间创建关系。</li></ul><p id="5e7c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最后，我们选择<em class="oo">编辑索引</em>并添加三个:</p><ul class=""><li id="d83d" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><em class="oo">可排序类型的createdAt </em>(这将允许我们按创建日期对结果进行排序)。</li><li id="b676" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated"><em class="oo">选中类型为可查询的</em>(以确定任务是否标记为完成)。</li><li id="3129" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">可查询类型的记录名(检索记录)。</li></ul><p id="5e5b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这样，我们得到了下面的图像:</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/771cbaf626569da9d9e7542ee83efcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CrrxuQTj-r2NzHLs.png"/></div></div></figure><h2 id="b3a5" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">添加样本数据</h2><p id="e570" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">一旦创建了<em class="oo">任务</em>表，我们就可以从CloudKit桌面添加一些示例数据。为此，我们从下拉菜单中选择<em class="oo">数据</em>选项。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/281d3b81c5731a4a92cce3c72336e5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PyLJY-RXHDIIGe8-.png"/></div></div></figure><p id="988d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，在左侧面板中，我们从<em class="oo">数据库</em>菜单中选择<em class="oo">公共数据库</em>，在<em class="oo">区域</em>菜单中，我们选择<em class="oo"> _defaultZone </em>(这是包含应用程序公共记录的区域)。然后，在<em class="oo">类型</em>菜单中我们选择<em class="oo">任务</em>(表名)，然后点击<em class="oo">新记录</em>按钮添加数据。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/dad7e1909ca17122ead0fe9224d320df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kyww3V23sI1upTk4.png"/></div></div></figure><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/26fee1fd2e4be6c0794c7227216c1056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bas2WFTY8n_V7ZSC.png"/></div></div></figure></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="f83e" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">有点快</h1><p id="4f0c" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">一旦我们输入了几个样本记录，我们就开始开发一个简单的应用程序。这个项目可以在<a class="ae mg" href="https://github.com/raulferrerdev/TodoList" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到全文。</p><h2 id="169f" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">UI设计</h2><p id="3486" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">这个项目由一个<code class="fe mc md me mf b">UITableView</code>组件组成，它将显示任务。这个表格的每个单元格都是一个任务，带有标题、创建日期和一个图标来指示任务是否已经完成。</p><p id="25cd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">该表将位于工具栏中的一个<code class="fe mc md me mf b">UINavigationController</code>组件内，我们将在该组件中放置标题和一个添加任务的按钮。在这个项目中，所有这些都将通过代码来完成，不使用故事板或。xib文件。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div class="gi gj op"><img src="../Images/c4f6066317e2618b525134dd9ccf8385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*DtS4w3fBpKVCON07.png"/></div></figure><h2 id="be4e" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">项目创建</h2><p id="52e9" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">在Xcode 11中建立项目时，要在没有故事板的情况下工作，我们必须在创建项目后采取一些步骤:</p><ul class=""><li id="3811" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated">我们删除文件Main.storyboard</li><li id="e3f5" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">在<em class="oo">常规</em>选项卡(<em class="oo">目标</em>)中，我们转到<em class="oo">主</em> <em class="oo">界面</em>选择器并删除<em class="oo">主</em>，将该字段留空。</li></ul><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/eb0dd49b82aad0c7fb13cb947f93e092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*Z46AOdQ2rog46e1S.png"/></div></figure><p id="08ff" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最后，在信息选项卡(<em class="oo">目标</em>)中，我们转到<em class="oo">应用</em> <em class="oo">场景清单&gt;场景配置&gt;应用会话角色&gt;项目0(默认配置)</em>并删除<em class="oo">故事板名称</em>字段。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj mh"><img src="../Images/701d4db887034ec1c2d106de9c26cdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GhlMFZ2AYdpxiUvN.png"/></div></div></figure><p id="385b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">由于我们将不再调用<em class="oo"> Main.storyboard </em>来启动项目，我们转到<em class="oo"> SceneDelegate.swift </em>文件，并在<code class="fe mc md me mf b">function scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</code>中将其内容替换为以下代码:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="8b88" class="oj lg iu mf b be ok ol l om on">guard let windowScene = (scene as? UIWindowScene) else { return }<br/>window = UIWindow(frame: UIScreen.main.bounds)<br/>let viewController = ViewController()<br/>let navigationController = UINavigationController()<br/>navigationController.viewControllers = [viewController]<br/>window?.rootViewController = navigationController<br/>window?.makeKeyAndVisible()<br/>window?.windowScene = windowScene</span></pre><p id="9884" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这段代码创建了一个UINavigationController，并向其中添加了<code class="fe mc md me mf b">ViewController</code>控制器。然后将其指定为<code class="fe mc md me mf b">rootViewController</code>。</p><h2 id="0167" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">创建记录管理器</h2><p id="bcba" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">接下来，我们创建一个管理器，它将执行与<code class="fe mc md me mf b">CloudKit</code>相关的任务(检索记录，保存它们……)。我们打算称它为<code class="fe mc md me mf b">CloudKitManager.swift</code>。首先，我们将添加检索<code class="fe mc md me mf b">iCloud</code>日志的功能:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="ff04" class="oj lg iu mf b be ok ol l om on">import Foundation<br/>import CloudKit<br/><br/>enum FetchError {<br/>    case fetchingError, noRecords, none<br/>}<br/><br/>struct CloudKitManager {<br/>    <br/>    private let RecordType = "Task"<br/>    <br/>    func fetchTasks(completion: @escaping ([CKRecord]?, FetchError) -&gt; Void) {<br/>        let publicDatabase = CKContainer(identifier: "{YOUR_CONTAINER_IDENTIFIER}").publicCloudDatabase<br/>        let query = CKQuery(recordType: RecordType, predicate: NSPredicate(value: true))<br/>        query.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: false)]<br/>        <br/>        publicDatabase.perform(query, inZoneWith: CKRecordZone.default().zoneID, completionHandler: { (records, error) -&gt; Void in<br/>            self.processQueryResponseWith(records: records, error: error as NSError?, completion: { fetchedRecords, fetchError in<br/>                completion(fetchedRecords, fetchError)<br/>            })<br/>        })<br/>    }<br/>    <br/>    <br/>    private func processQueryResponseWith(records: [CKRecord]?, error: NSError?, completion: @escaping ([CKRecord]?, FetchError) -&gt; Void) {<br/>        guard error == nil else {<br/>            completion(nil, .fetchingError)<br/>            return<br/>        }<br/>        <br/>        guard let records = records, records.count &gt; 0 else {<br/>            completion(nil, .noRecords)<br/>            return<br/>        }<br/>        <br/>        completion(records, .none)<br/>    }<br/>}</span></pre><p id="4034" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<code class="fe mc md me mf b">fetchTasks(completion: @escaping ([CKRecord] ?, FetchError) -&gt; Void)</code>中，我们做的第一件事是从我们给它的标识符(<em class="oo"> iCloud.com… </em>)中检索我们应用程序的容器(类型<code class="fe mc md me mf b">CKContainer</code>),然后我们得到公共数据库，这是我们先前创建演示记录的地方。</p><p id="ac76" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后，我们创建一个搜索(<em class="oo">查询</em>，类型为<em class="oo"> CKQuery </em>)，其中我们指出了我们在<em class="oo"> iCloud </em> ( <em class="oo">任务</em>)中创建的表的名称，并为获得的记录添加了一个排序标准——在这种情况下，它将根据创建日期(<code class="fe mc md me mf b">createdAt</code>)从最新到最早(<code class="fe mc md me mf b">ascending: false</code>)对记录进行排序。</p><p id="af2a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，我们根据<code class="fe mc md me mf b">publicDatabase.perform(&lt;query: CKQuery, inZoneWith: CKRecordZone.ID?, completionHandler: ([CKRecord]?, Error?) -&gt; Void&gt;)</code>方法在公共数据库中执行查询，因为我们引入了我们创建的查询、区域标识符(这是默认区域，<em class="oo">默认</em>，以及我们在<em class="oo"> iCloud </em>中创建表时选择的区域)。</p><p id="e89e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当执行查询时，我们得到两个参数作为响应:一个记录列表(<code class="fe mc md me mf b">CKRecord</code>)和一个错误(这两种情况都是有条件的，因为它们可以有值<code class="fe mc md me mf b">nil</code>)。</p><p id="c3b2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个响应在<code class="fe mc md me mf b">processQueryResponseWith</code>方法中被处理，在这个方法中，我们检查在执行查询时是否有错误，是否有任何记录被返回，以及这些记录是什么。为了便于错误的处理，创建了<code class="fe mc md me mf b">enum FetchError</code> <em class="oo"> </em>，收集了可能出现的错误。</p><h2 id="cef7" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">创建UITableView组件</h2><p id="bc9a" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">UITableView组件很简单，我们唯一要定制的是单元格可以有可变的高度，以显示最多三行(<code class="fe mc md me mf b">TasksTableViewController.swift</code>)的任务标题:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="1488" class="oj lg iu mf b be ok ol l om on">import UIKit<br/>import CloudKit<br/><br/>class TasksTableViewController: UITableViewController {<br/>    <br/>    private var tasks = [CKRecord]()<br/>        <br/>    init() {<br/>        super.init(style: .plain)<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/><br/>        configureTableView()<br/>    }<br/>    <br/>    <br/>    private func configureTableView() {<br/>        tableView.backgroundColor = .white<br/>        tableView.separatorStyle = .singleLine<br/>        tableView.register(TaskCell.self, forCellReuseIdentifier: TaskCell.reuseID)<br/>        tableView.delegate = self<br/>        tableView.dataSource = self<br/>        tableView.bounces = false<br/>        tableView.showsVerticalScrollIndicator = false<br/>        tableView.rowHeight = 72<br/>        tableView.estimatedRowHeight = UITableView.automaticDimension<br/>        tableView.translatesAutoresizingMaskIntoConstraints = false<br/>        tableView.contentInsetAdjustmentBehavior = .never<br/>    }<br/>    <br/>    func set(tasks: [CKRecord]) {<br/>        self.tasks = tasks<br/>        tableView.reloadData()<br/>    }<br/>}<br/><br/><br/>// MARK: - Table view data source<br/>extension TasksTableViewController {<br/><br/>    override func numberOfSections(in tableView: UITableView) -&gt; Int {<br/>        return 1<br/>    }<br/><br/>    <br/>    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {<br/>        return tasks.count<br/>    }<br/>    <br/>    <br/>    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>        let cell = tableView.dequeueReusableCell(withIdentifier: TaskCell.reuseID, for: indexPath) as! TaskCell<br/>        cell.set(record: tasks[indexPath.row])<br/>        <br/>        return cell<br/>    }<br/><br/>    <br/>    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {<br/>        return UITableView.automaticDimension<br/>    }<br/>    <br/>    <br/>    override func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat {<br/>        return UITableView.automaticDimension<br/>    }<br/>    <br/>    <br/>    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool {<br/>        return true<br/>    }<br/>}</span></pre><p id="a818" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还创建了一个自定义单元格(<code class="fe mc md me mf b">TaskCell.swift</code>):</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="38a0" class="oj lg iu mf b be ok ol l om on">import UIKit<br/>import CloudKit<br/> <br/>class TaskCell: UITableViewCell {<br/> <br/>    static let reuseID = "TaskCell"<br/>    <br/>    private var record: CKRecord?<br/>    private var taskTitleLabel = UILabel(frame: .zero)<br/>    private var createdAtLabel = UILabel(frame: .zero)<br/>    private var checkedButton = UIButton(frame: .zero)<br/>    private var isChecked: Bool = false<br/>    <br/>    private let uncheckedIcon = UIImage(systemName: "circle")!<br/>    <br/>    private let checkedIcon = UIImage(systemName: "checkmark.circle")!<br/>    weak var delegate: TaskCheckDelegate?<br/> <br/>    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {<br/>        super.init(style: style, reuseIdentifier: reuseIdentifier)<br/>        configure()<br/>    }<br/>    <br/> <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    <br/>    override func prepareForReuse() {<br/>        self.record = nil<br/>        self.isChecked = false<br/>    }<br/> <br/>    <br/>    private func configure() {<br/>        selectionStyle = .none<br/>        <br/>        configureTitleLabel()<br/>        configureCreatedAtLabel()<br/>        configureCheckedButton()<br/>        layoutUI()<br/>    }<br/>    <br/>    <br/>    func set(record: CKRecord) {<br/>        self.record = record<br/>        <br/>        taskTitleLabel.text = record.object(forKey: "title") as? String ?? ""<br/>        if let createdDate = record.object(forKey: "createdAt") as? Date {<br/>            createdAtLabel.text = createdDate.convertToMonthYearDayFormat()<br/>        } else {<br/>            createdAtLabel.text = ""<br/>        }<br/>        <br/>        if let checked = record.object(forKey: "checked") as? Int64 {<br/>            self.isChecked = checked == 0 ? false : true<br/>            checkedButton.setBackgroundImage(self.isChecked ? checkedIcon : uncheckedIcon, for: .normal)<br/>        } else {<br/>            self.isChecked = false<br/>            checkedButton.setBackgroundImage(uncheckedIcon, for: .normal)<br/>        }<br/>    }<br/>    <br/>    <br/>    private func configureTitleLabel() {<br/>        taskTitleLabel.translatesAutoresizingMaskIntoConstraints = false<br/>        taskTitleLabel.font = .systemFont(ofSize: 16)<br/>        taskTitleLabel.textColor = .systemGray2<br/>        taskTitleLabel.textAlignment = .left<br/>        taskTitleLabel.numberOfLines = 3<br/>        taskTitleLabel.lineBreakMode = .byTruncatingTail<br/>    }<br/>    <br/>    <br/>    private func configureCreatedAtLabel() {<br/>        createdAtLabel.translatesAutoresizingMaskIntoConstraints = false<br/>        createdAtLabel.font = .systemFont(ofSize: 12)<br/>        createdAtLabel.textColor = .systemGray3<br/>        createdAtLabel.textAlignment = .left<br/>        createdAtLabel.numberOfLines = 1<br/>    }<br/>    <br/>    <br/>    private func configureCheckedButton() {<br/>        checkedButton.translatesAutoresizingMaskIntoConstraints = false<br/>        checkedButton.setBackgroundImage(uncheckedIcon, for: .normal)<br/>        checkedButton.tintColor = .systemGray<br/>        checkedButton.addTarget(self, action: #selector(toggleChecked), for: .touchUpInside)<br/>    }<br/>    <br/>    <br/>    private func layoutUI() {<br/>        contentView.addSubview(taskTitleLabel)<br/>        contentView.addSubview(createdAtLabel)<br/>        contentView.addSubview(checkedButton)<br/>        <br/>        NSLayoutConstraint.activate([<br/>            checkedButton.centerYAnchor.constraint(equalTo: contentView.centerYAnchor),<br/>            checkedButton.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -10),<br/>            checkedButton.heightAnchor.constraint(equalToConstant: 20),<br/>            checkedButton.widthAnchor.constraint(equalToConstant: 20),<br/>            <br/>            taskTitleLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 5),<br/>            taskTitleLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 10),<br/>            taskTitleLabel.trailingAnchor.constraint(equalTo: checkedButton.leadingAnchor, constant: -10),<br/>            taskTitleLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -30),<br/> <br/>            createdAtLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 10),<br/>            createdAtLabel.trailingAnchor.constraint(equalTo: checkedButton.leadingAnchor, constant: 10),<br/>            createdAtLabel.topAnchor.constraint(equalTo: taskTitleLabel.bottomAnchor, constant: 5)<br/>        ])<br/>        <br/>        taskTitleLabel.setContentHuggingPriority(.required, for: .vertical)<br/>    }<br/>    <br/>    <br/>    @objc private func toggleChecked() {<br/>        guard let record = record else { return }<br/>        isChecked.toggle()<br/>        checkedButton.setBackgroundImage(isChecked ? checkedIcon : uncheckedIcon, for: .normal)<br/>        checkedButton.tintColor = isChecked ? .systemGreen : .systemGray<br/>    }<br/>}</span></pre><p id="7a24" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">其中<em class="oo"> </em> <code class="fe mc md me mf b">toggleChecked()</code>方法允许你改变目前已完成任务图标的状态。</p><p id="833c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在在<code class="fe mc md me mf b">ViewController.swift</code>类中，我们已经可以显示表格并执行<code class="fe mc md me mf b">iCloud</code>调用。</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="765e" class="oj lg iu mf b be ok ol l om on">import UIKit<br/> <br/>class ViewController: UIViewController {<br/>    <br/>    private let tableView = TasksTableViewController()<br/>    private let manager = CloudKitManager()<br/> <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/>        self.title = "Tasks"<br/> <br/>        layoutUI()<br/>        fetchRecords()<br/>    }<br/>    <br/>    <br/>    private func layoutUI() {<br/>        view.addSubview(tableView.view)<br/>        <br/>        NSLayoutConstraint.activate([<br/>            tableView.view.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),<br/>            tableView.view.bottomAnchor.constraint(equalTo: view.bottomAnchor),<br/>            tableView.view.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>            tableView.view.widthAnchor.constraint(equalTo: view.widthAnchor)<br/>        ])<br/>    }<br/>    <br/>    <br/>    private func fetchRecords() {<br/>        manager.fetchTasks(completion: { (records, error) in<br/>            guard error == .none, let records = records else {<br/>                // Deal with error<br/>                return<br/>            }<br/>            <br/>            DispatchQueue.main.async {<br/>                self.tableView.set(tasks: records)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj or"><img src="../Images/4f681fe13e5cf1cf9faa26524cf42785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z4D0op--F0sDJSXQyFH5pg.gif"/></div></div></figure><h2 id="64d6" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">记录删除</h2><p id="24dc" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">为了删除记录，我们启用了单元格拖动，以便删除选项出现。我们通过向<code class="fe mc md me mf b">TasksTableViewController</code> <em class="oo"> </em>类添加以下方法来实现这一点:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="ec4e" class="oj lg iu mf b be ok ol l om on">override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {<br/>    if (editingStyle == .delete) {<br/>            <br/>    }<br/>}</span></pre><p id="06b7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还修改了这个类，注入了一个<code class="fe mc md me mf b">CloudKitManager</code> <em class="oo">的实例。</em></p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="f5c3" class="oj lg iu mf b be ok ol l om on">private var manager: CloudKitManager!<br/> <br/>init(manager: CloudKitManager) {<br/>    super.init(style: .plain)<br/>        <br/>    self.manager = manager<br/>}<br/>view raw</span></pre><p id="cb0a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<code class="fe mc md me mf b">ViewController</code>类中，我们更改了<code class="fe mc md me mf b">TasksTableViewController</code>类的实例，因为现在我们将注入<code class="fe mc md me mf b">CloudKitManager</code>实例:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="6ca3" class="oj lg iu mf b be ok ol l om on">private var tableView: TasksTableViewController!<br/>private let manager = CloudKitManager()<br/> <br/>override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>        <br/>    self.title = "Tasks"<br/> <br/>    configureTableView()<br/>    layoutUI()<br/>    fetchRecords()<br/>}<br/>    <br/>    <br/>private func configureTableView() {<br/>    tableView = TasksTableViewController(manager: manager)<br/>}</span></pre><p id="1d46" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<code class="fe mc md me mf b">CloudKitManager</code>中，我们添加这些方法来删除记录，并将<code class="fe mc md me mf b">deletingError</code>案例添加到<code class="fe mc md me mf b">FetchError enum</code>:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="98e3" class="oj lg iu mf b be ok ol l om on">func deleteRecord(record: CKRecord) {<br/>    let publicDatabase = CKContainer(identifier: "{YOUR_CONTAINER_IDENTIFIER}").publicCloudDatabase<br/>     <br/>    publicDatabase.delete(withRecordID: record.recordID) { (recordID, error) -&gt; Void in<br/>        guard let _ = error else {<br/>          completionHandler(.none)<br/>          return<br/>        }<br/> <br/>        completionHandler(.deletingError)<br/>    }<br/>}</span></pre><p id="80bc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在TasksTableViewController类中，我们修改了最后一个方法:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="0a7b" class="oj lg iu mf b be ok ol l om on">override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {<br/>    if (editingStyle == .delete) {<br/>        manager.deleteRecord(record: tasks[indexPath.row], completionHandler: { error in<br/>            guard error == .none else {<br/>                // Deal with error<br/>                return<br/>            }<br/>                <br/>            self.tasks.remove(at: indexPath.row)<br/>                <br/>            DispatchQueue.main.async {<br/>                self.tableView.deleteRows(at: [indexPath], with: .right)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="f900" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们可以测试任务的删除。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj or"><img src="../Images/3247aa3bf66990945888a5549a6d7407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gy6uqnxHxGMr2VBLRab6iw.gif"/></div></div><p class="os ot gk gi gj ou ov bd b be z dk translated">删除记录。</p></figure><h2 id="e389" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">添加任务</h2><p id="581f" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">为了创建一个任务，我们将创建一个<code class="fe mc md me mf b">UIViewController</code>，我们将通过单击导航栏中的“+”按钮导航到该任务。这个新的<code class="fe mc md me mf b">UIViewController</code>，我们称之为<code class="fe mc md me mf b">AddTaskController</code>，将简单地由一个<code class="fe mc md me mf b">UITextField</code>组件和一个<code class="fe mc md me mf b">UIButton</code>组件组成，我们将在其中引入任务文本，并添加它。</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="a4dd" class="oj lg iu mf b be ok ol l om on">import UIKit<br/>import CloudKit<br/> <br/>protocol TasksDelegate: class {<br/>    func addedTask(_ task: CKRecord?, error: FetchError)<br/>}<br/> <br/>class AddTaskController: UIViewController {<br/>    <br/>    private let textField = UITextField(frame: .zero)<br/>    private let addButton = UIButton(frame: .zero)<br/>    <br/>    private var manager: CloudKitManager!<br/>    <br/>    weak var delegate: TasksDelegate?<br/>    <br/>    init(manager: CloudKitManager) {<br/>        super.init(nibName: nil, bundle: nil)<br/>        <br/>        self.manager = manager<br/>    }<br/>    <br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/> <br/>        view.backgroundColor = .white<br/>        <br/>        configureTextField()<br/>        configureAddButton()<br/>        layoutUI()<br/>    }<br/>    <br/>    <br/>    private func configureTextField() {<br/>        textField.translatesAutoresizingMaskIntoConstraints = false<br/>        textField.placeholder = "Add a task"<br/>        textField.borderStyle = UITextField.BorderStyle.line<br/>        textField.textColor = .systemGray2<br/>        textField.font = .systemFont(ofSize: 16)<br/>        textField.contentVerticalAlignment = .top<br/>    }<br/>    <br/>    <br/>    private func configureAddButton() {<br/>        addButton.translatesAutoresizingMaskIntoConstraints = false<br/>        addButton.setTitle("Add task", for: .normal)<br/>        addButton.setTitleColor(.systemTeal, for: .normal)<br/>        addButton.titleLabel?.font = .boldSystemFont(ofSize: 16)<br/>        addButton.addTarget(self, action: #selector(addTask), for: .touchUpInside)<br/>    }<br/>    <br/>    <br/>    private func layoutUI() {<br/>        view.addSubview(textField)<br/>        view.addSubview(addButton)<br/>        <br/>        NSLayoutConstraint.activate([<br/>            textField.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),<br/>            textField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10),<br/>            textField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -10),<br/>            textField.heightAnchor.constraint(equalToConstant: 300),<br/>            <br/>            addButton.topAnchor.constraint(equalTo: textField.bottomAnchor, constant: 40),<br/>            addButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>            addButton.widthAnchor.constraint(equalToConstant: 200),<br/>            addButton.heightAnchor.constraint(equalToConstant: 50)<br/>        ])<br/>    }<br/>    <br/>    <br/>    @objc private func addTask() {<br/>        guard let task = textField.text, !task.isEmpty else {<br/>            delegate?.addedTask(nil, error: .addingError)<br/>            self.navigationController?.popViewController(animated: false)<br/>            return<br/>        }<br/>        <br/>        manager.addTask(task, completionHandler: { (record, error) in<br/>            self.delegate?.addedTask(record, error: .none)<br/>            DispatchQueue.main.async {<br/>                self.navigationController?.popViewController(animated: false)<br/>            }<br/>            return<br/>        })<br/>    }<br/>}</span></pre><p id="fcae" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这段代码中有几个要点:</p><ul class=""><li id="15bb" class="mt mu iu kl b km kn kp kq ks mv kw mw la mx le my mz na nb bi translated"><code class="fe mc md me mf b">init</code>方法注入一个<code class="fe mc md me mf b">CloudKitManager</code>实例，以便管理记录的添加。</li><li id="3a57" class="mt mu iu kl b km nc kp nd ks ne kw nf la ng le my mz na nb bi translated">与“<em class="oo">添加任务”</em>按钮关联的方法被称为<code class="fe mc md me mf b">CloudKitManager</code>的<code class="fe mc md me mf b">addTask</code>方法，它将管理新记录的添加。在<code class="fe mc md me mf b">CloudKitManager</code>中为该案例添加的代码为(新案例<code class="fe mc md me mf b">addingError</code>，也已在<code class="fe mc md me mf b">FetchError enum</code>中添加):</li></ul><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="2a76" class="oj lg iu mf b be ok ol l om on">func addTask(_ task: String, completionHandler: @escaping (CKRecord?, FetchError) -&gt; Void) {<br/>    let publicDatabase = CKContainer(identifier: "{YOUR_CONTAINER_IDENTIFIER}").publicCloudDatabase<br/>    let record = CKRecord(recordType: RecordType)<br/>        <br/>    record.setObject(task as __CKRecordObjCValue, forKey: "title")<br/>    record.setObject(Date() as __CKRecordObjCValue, forKey: "createdAt")<br/>    record.setObject(0 as __CKRecordObjCValue, forKey: "checked")<br/>        <br/>    publicDatabase.save(record, completionHandler: { (record, error) in<br/>        guard let _ = error else {<br/>            completionHandler(record, .none)<br/>            return<br/>        }<br/>            <br/>        completionHandler(nil, .addingError)<br/>    })<br/>}</span></pre><p id="1c46" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">已经创建了一个协议来将创建的记录传递给<code class="fe mc md me mf b">ViewController</code>。最后，启动控制器(<code class="fe mc md me mf b"><em class="oo">ViewController</em></code>)被导航。</p><p id="c301" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了调用<code class="fe mc md me mf b">AddTaskController</code>类，我们在导航栏上添加了一个按钮。我们使用<code class="fe mc md me mf b">UIBarButtonItem</code>组件来实现这一点，并将其与<code class="fe mc md me mf b">addTask</code>方法关联起来。在这个方法中，我们实例化控制器，定义委托并推送新的控制器。</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="50a0" class="oj lg iu mf b be ok ol l om on">private func configureAddButton() {<br/>    let addButton = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(addTask))<br/>    navigationItem.rightBarButtonItems = [addButton]<br/>}<br/>    <br/>@objc private func addTask() {<br/>    let controller = AddTaskController(manager: manager)<br/>    controller.delegate = self<br/>    navigationController?.pushViewController(controller, animated: false)<br/>}</span></pre><p id="1567" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">既然我们已经为<code class="fe mc md me mf b">ViewController</code>定义了代表，我们必须让<code class="fe mc md me mf b">ViewController</code>采用这个协议的方法。我们使用一个<code class="fe mc md me mf b">ViewController</code>扩展(来组织代码)来做到这一点:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="8dfe" class="oj lg iu mf b be ok ol l om on">extension ViewController: TasksDelegate {<br/>    func addedTask(_ task: CKRecord?, error: FetchError) {<br/>        guard error == .none, let task = task else {<br/>            // Deal with error<br/>            return<br/>        }<br/>        DispatchQueue.main.async {<br/>            self.tableView.add(task: task)<br/>        }<br/>    }<br/>}</span></pre><p id="f987" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在addedTask方法的这个实现中，任何可能的错误都会被处理，如果一切都是正确的，那么创建的记录将被发送到我们将在<code class="fe mc md me mf b">TasksTableViewController</code>类中创建的新的<code class="fe mc md me mf b">add(task: CKRecord)</code>方法:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="02e5" class="oj lg iu mf b be ok ol l om on">func add(task: CKRecord) {<br/>    self.tasks.insert(task, at: 0)<br/>    tableView.reloadData()<br/>}</span></pre><p id="759f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个方法的作用是将新记录添加到记录列表的开头(它是最新的)，然后从表中重新加载数据。</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj or"><img src="../Images/e91ddf9f75b27acef020712d831e1a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iKVu5-VLH_7ayyEOwkY5bg.gif"/></div></div><p class="os ot gk gi gj ou ov bd b be z dk translated">添加新记录。</p></figure><h2 id="aac6" class="nt lg iu bd lh nu nv dn ll nw nx dp lp ks ny nz lr kw oa ob lt la oc od lv oe bi translated">更新任务</h2><p id="a917" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">我们已经看到了如何用<code class="fe mc md me mf b">CloudKit</code>恢复、删除或创建记录。现在我们将看看如何在<code class="fe mc md me mf b">CloudKit</code>中更新注册表。为此，我们将使用一个简单的案例，它对应于完成一个任务并将其标记为已完成。</p><p id="f277" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">首先我们在<code class="fe mc md me mf b">CloudKitManager</code>中添加一个新方法:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="2c52" class="oj lg iu mf b be ok ol l om on">func updateTask(_ task: CKRecord, completionHandler: @escaping (CKRecord?, FetchError) -&gt; Void) {<br/>    let publicDatabase = CKContainer(identifier: "{YOUR_CONTAINER_IDENTIFIER}").publicCloudDatabase<br/>        <br/>    publicDatabase.save(task, completionHandler: { (record, error) in<br/>        guard let _ = error else {<br/>            completionHandler(record, .none)<br/>            return<br/>        }<br/>            <br/>        completionHandler(nil, .addingError)<br/>    })<br/>}</span></pre><p id="5b23" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当传递一个已经存在的对象并将其保存在<code class="fe mc md me mf b">CloudKit</code>中时，其值被更新。为了在我们将任务标记为完成时调用这个方法，我们创建了一个协议，允许将修改后的记录从单元格传递给<code class="fe mc md me mf b">TasksTableViewController</code>类:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="32f5" class="oj lg iu mf b be ok ol l om on">protocol TaskCheckDelegate: class {<br/>    func updateTask(_ record: CKRecord)<br/>}</span></pre><p id="1827" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在，在<code class="fe mc md me mf b">TasksTableViewController</code>类中，我们将委托添加到单元格中:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="ff79" class="oj lg iu mf b be ok ol l om on">override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>    let cell = tableView.dequeueReusableCell(withIdentifier: TaskCell.reuseID, for: indexPath) as! TaskCell<br/>    cell.set(record: tasks[indexPath.row])<br/>    cell.delegate = self<br/>        <br/>    return cell<br/>}</span></pre><p id="a63b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后我们让<code class="fe mc md me mf b">TasksTableViewController</code>类采用协议:</p><pre class="mi mj mk ml gu of mf og bn oh oi bi"><span id="4d01" class="oj lg iu mf b be ok ol l om on">extension TasksTableViewController: TaskCheckDelegate {<br/>    func updateTask(_ record: CKRecord) {<br/>        manager.updateTask(record, completionHandler: { (record, error) in<br/>          // Deal with error if there is one<br/>        })<br/>    }<br/>}</span></pre><p id="8a6d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果我们将一个记录标记为完成，然后关闭应用程序并重新加载，我们会看到该记录在<em class="oo"> iCloud: </em>中被修改</p><figure class="mi mj mk ml gu mm gi gj paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gi gj or"><img src="../Images/c1f48b2356b0713a6ab4ed21a11d910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IfEm_N6aFYcL7JOyFmS74A.gif"/></div></div><p class="os ot gk gi gj ou ov bd b be z dk translated">更新记录。</p></figure></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><h1 id="1d27" class="lf lg iu bd lh li no lk ll lm np lo lp ka nq kb lr kd nr ke lt kg ns kh lv lw bi translated">结论</h1><p id="23d9" class="pw-post-body-paragraph kj kk iu kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le in bi translated">我们已经看到了如何创建一个使用<em class="oo"> CloudKit </em>与<em class="oo"> iCloud </em>同步数据的应用程序。在这个应用程序中，我们集成了数据库的基本CRUD方法(<em class="oo">创建</em>、<em class="oo">读取</em>、<em class="oo">更新</em>、<em class="oo">删除</em>)。你可以从<a class="ae mg" href="https://github.com/raulferrerdev/TodoList" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载完整的项目。</p></div></div>    
</body>
</html>