<html>
<head>
<title>Let’s Build a Movie API With Separated Layered Architecture Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们使用Go构建一个具有分离的分层架构的电影API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-build-a-movie-api-with-clean-architecture-ef1f555b563d?source=collection_archive---------0-----------------------#2022-04-17">https://betterprogramming.pub/lets-build-a-movie-api-with-clean-architecture-ef1f555b563d?source=collection_archive---------0-----------------------#2022-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee8b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件架构的目标是最小化构建和维护所需系统所需的人力资源。[1]</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/759088270d6191b0a833631f3736d3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WYN6QI_2wodtdglo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@felixmooneeram?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利克斯·穆纳拉姆</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的第一篇文章中，我们谈到了用Go进行测试。现在，我们将继续前进，看看如何借助三层架构更轻松地测试<a class="ae kv" href="https://github.com/dilaragorum/movie-go" rel="noopener ugc nofollow" target="_blank">我们的电影API </a>。</p><p id="adaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">分层架构的理念建立在接口编程的理念之上。当一个模块通过一个接口与另一个模块交互时，你可以用一个服务提供者代替另一个[2] </em>。</p><p id="a9ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">放心吧！我尽量简单解释一下。</p><p id="ea03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面的这个图表。看起来很简单，对吧？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/95bcae19ed395fee49ef8f6d1ccd5d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aVKkR38tU0APeL3Rp7Kiw.png"/></div></div></figure><p id="737e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构背后的逻辑每一层都有自己的职责，它们将相互独立。这样，我们可以用一种更隔离的方式测试它们。是的，再次测试！</p><p id="0e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些层(处理程序、服务和repository)❓)的角色是什么</p><p id="6c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Handler </strong>:获取http请求并返回http响应给客户端的层。</p><p id="28df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">服务</strong>:这是我们业务逻辑所在的一层。</p><p id="0487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">存储库</strong>:它是一个层，提供来自外部(DBs)或内部(内存中)数据源的所有必要数据。为了简单起见，我们使用内存中。</p><p id="81fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在学习图中接口的角色之前，我们需要讨论一下依赖注入。依赖注入只基于抽象(接口)而不是具体类型(结构)。以这种方式，我们通过使用接口来注入我们所有的依赖。</p><p id="f44b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如我们在项目中会有两个服务:<code class="fe lu lv lw lx b">MockService</code>和<code class="fe lu lv lw lx b">DefaultService.</code>在服务接口的帮助下，我们可以在Handler层使用这两个不同structs的方法。在测试阶段，Handler与<code class="fe lu lv lw lx b">MockService</code>交互，另一方面，它与生产中的<code class="fe lu lv lw lx b">DefaultService</code>交互。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/c2d3e01eac4a489450d56cedef790986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bc1ohUKxW2mzYoCDmAkT2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">依赖性倒置示例</p></figure><p id="dcb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心，当我们看到行动时，你会更好地理解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，当我们调用处理程序中的服务方法和服务中的存储库方法时，可以合理地将这种关系看作“调用栈”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mb"><img src="../Images/efc69b5433b751f7d1cec14461f13794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7y5y2_sxiEMoIZrE43_wQ.png"/></div></div></figure><p id="039b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们用调用堆栈做的简单图表。我们的计算机为我们的函数调用分配内存。</p><p id="393d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把这个记忆想象成一个盒子。</p><p id="aa69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一个呼叫(在<code class="fe lu lv lw lx b">Handler</code>中)需要保存在内存中。</p><p id="ed09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们的第二个调用(在<code class="fe lu lv lw lx b">Service</code>中)被保存在处理器盒的内存中。</p><p id="4352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们的第三个电话(在<code class="fe lu lv lw lx b">Repository</code>)被保存在服务箱的内存中。棘手的是，我们的服务需要等待存储库功能完成。完成后，我们的处理程序需要等待服务功能完成。完成后，<code class="fe lu lv lw lx b">Handler</code>函数就可以工作了。</p><p id="6124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们的栈也将是空的。这就是调用堆栈的工作方式。你可以阅读'<a class="ae kv" href="https://www.amazon.com.tr/Grokking-Algorithms-Aditya-Y-Bhargava/dp/1617292230" rel="noopener ugc nofollow" target="_blank">搜索算法书</a>的调用栈部分来了解更多。</p><p id="f527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的设计是如何创造的广阔视角。我们可以深入我们的项目。在本文中，我们将只处理一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" rel="noopener ugc nofollow" target="_blank">补丁请求</a>的例子。</p><h1 id="d8a5" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">1.main.go</h1><p id="27b3" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">当客户端用PATCH方法发送请求时，使用<code class="fe lu lv lw lx b"><a class="ae kv" href="https://github.com/julienschmidt/httprouter" rel="noopener ugc nofollow" target="_blank">httprouter</a></code>调用movieHandler的UpdateMovie方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="09f2" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">2a。处理者</h1><p id="ae0a" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">这是我们的API获取HTTP请求的第一层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="bf39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理程序是将来自服务的响应转换成http响应的层。如您所知，HTTP响应由状态代码、报头和主体组成。</p><h2 id="ad3b" class="mz md iq bd me na nb dn mi nc nd dp mm lf ne nf mo lj ng nh mq ln ni nj ms nk bi translated">2b。处理器测试</h2><p id="60f5" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">在继续测试处理程序之前，我想介绍一下<a class="ae kv" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank"> mockgen包</a>。这个包帮助我们的代码更容易测试。</p><p id="b289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给它您想要模仿的接口源路径，向它显示自动生成的模仿文件将被创建的位置，并让它代表您生成模仿结构实现。如果我们想测试处理程序层，我们需要模拟服务层。我们可以这样安装它:</p><pre class="kg kh ki kj gt nl lx nm nn aw no bi"><span id="c832" class="mz md iq lx b gy np nq l nr ns">mockgen -source service/movie_service_interface.go -destination service/mock_movie_service.go -package service</span></pre><p id="667e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在测试文件中，我们应该测试可能的错误和成功案例，以增加处理程序的测试覆盖率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="73ff" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">3a。服务</h1><p id="7fc1" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">这一层包括我们的app业务逻辑。通过将业务逻辑分离到特定的层，我们可以轻松地编写单元测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="6877" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">3b。服务测试</h1><p id="8ef9" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">像在处理程序测试部分一样，我们需要模拟我们的存储库来测试我们的服务层:</p><pre class="kg kh ki kj gt nl lx nm nn aw no bi"><span id="7582" class="mz md iq lx b gy np nq l nr ns">mockgen -source repository/movie_repository_interface.go -destination repository/mock_movie_repository.go -package repository</span></pre><p id="75d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会给你一个窍门。每当我们改变给<code class="fe lu lv lw lx b">mockgen</code>的接口时，我们必须再次运行<code class="fe lu lv lw lx b">mockgen</code>命令。</p><p id="b92c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们有两个模拟文件，当我们向接口添加新方法时，我们需要反复编写这些长代码。这么繁琐的方式！解决方法是<code class="fe lu lv lw lx b"><strong class="ky ir">Makefile</strong></code>。使用<code class="fe lu lv lw lx b"><strong class="ky ir">Makefile</strong></code>，我们仅使用<code class="fe lu lv lw lx b">generate-mocks</code>命令来重新创建我们的模拟文件。(<code class="fe lu lv lw lx b">make generate-mocks</code>)</p><p id="70ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在通过模仿存储库来测试可能的错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="94d7" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">4.贮藏室ˌ仓库</h1><p id="61ec" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">这是我们实施数据集成的地方:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="528d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">奖励:HTTP客户端插件</h1><p id="7e03" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">我们正在尝试开发RESTful API，在开发过程中，我们希望确保它能像预期的那样工作。当然，我们需要向我们的API发送HTTP请求。</p><p id="74a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以使用<a class="ae kv" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>、<a class="ae kv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>、<a class="ae kv" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠症</a>和<a class="ae kv" href="https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html" rel="noopener ugc nofollow" target="_blank"> Jetbrains H <em class="ls"> TTP客户端</em>插件</a>等来实现这两种方式。我非常喜欢使用Jetbrains HTTP客户端插件。</p><p id="3856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<em class="ls"> HTTP客户端</em>插件，您可以直接在IntelliJ IDEA代码编辑器中创建、编辑和执行HTTP请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/9924bb669e4b854d1d98d88f0046e14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cbJStNHNbWVxidFN-slmYQ.gif"/></div></div></figure><h1 id="036e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">源代码</h1><div class="nu nv gp gr nw nx"><a href="https://github.com/dilaragorum/movie-go" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">GitHub-dilaragorum/电影-go</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><h1 id="6292" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">参考</h1><p id="7029" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">[1，2]干净的架构软件结构和设计的工匠指南(Robert C. Martin)</p><p id="0476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]每个程序员都应该知道的97件事专家的集体智慧</p></div></div>    
</body>
</html>