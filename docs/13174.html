<html>
<head>
<title>How Not to Go Crazy Writing iOS Asynchronous Code Using Various Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不疯狂地使用各种框架编写iOS异步代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-not-to-go-crazy-writing-ios-asynchronous-code-1afe6aa8fecf?source=collection_archive---------17-----------------------#2022-08-03">https://betterprogramming.pub/how-not-to-go-crazy-writing-ios-asynchronous-code-1afe6aa8fecf?source=collection_archive---------17-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">组合、异步/等待等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a4bd5ae4b7f909751a981a0c1199570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RFenwRYc245xrI4fwtQwg.png"/></div></div></figure><p id="9752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在使用现代移动应用程序时，我们经常使用异步代码，这非常棘手。</p><p id="f71b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Swift团队成员尽最大努力让我们的生活更轻松；因此，自2021年起，我们可以使用新的基于<code class="fe ln lo lp lq b"><a class="ae lr" href="https://developer.apple.com/news/?id=2o3euotz" rel="noopener ugc nofollow" target="_blank">async/await</a></code> <a class="ae lr" href="https://developer.apple.com/news/?id=2o3euotz" rel="noopener ugc nofollow" target="_blank">的并发</a>。如果我们没有另一个不太老的工具，这就不是iOS编程了。</p><p id="ec6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们将<a class="ae lr" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">联合收割机</a>框架打包到我们的武器库中。异步操作和数据流的简单组合对程序员来说是必不可少的，所以在我们听说Combine和Swift Concurrency正在计划中之前，社区就推出了<a class="ae lr" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="5748" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，有许多框架可以用于组合并发方法。我们经常最终在一个项目中使用所有这些工具。我的情况也是如此。曾经，我从联合收割机的<code class="fe ln lo lp lq b">Publisher</code>中接收数据，并在Swift的<code class="fe ln lo lp lq b">Task</code>中执行异步操作。</p><p id="4682" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Combine时，我们需要持有一个强引用来持续接收<code class="fe ln lo lp lq b">Publisher</code>的发射。任务完全不同。不管你是否持有参考，它们都会运行。所以，我们需要保留一个，在需要的时候取消一个任务，然后释放它。听起来很熟悉？我打赌是的。</p><p id="3873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你用过RxSwift，你肯定记得<code class="fe ln lo lp lq b">DisposeBag</code>。联合收割机使用与<code class="fe ln lo lp lq b">Set&lt;AnyCancallable&gt;</code>类似的方法。那么，为什么不创造一个袋子来帮助存储任务和可取消的任务呢？</p><p id="b252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从创建API开始，它将允许我们向这样的sack添加我们的异步魔术:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6730" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们知道了API的样子，让我们创建我们可以使用的<code class="fe ln lo lp lq b">SubscriptionContainer</code>。</p><p id="d671" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很容易，多亏了<code class="fe ln lo lp lq b">AnyCancellable</code>行为。根据文档:<em class="mb">一个</em> <code class="fe ln lo lp lq b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/anycancellable" rel="noopener ugc nofollow" target="_blank"><em class="mb">AnyCancellable</em></a></code> <em class="mb">实例在反初始化时自动调用</em> <code class="fe ln lo lp lq b"><a class="ae lr" href="https://developer.apple.com/documentation/combine/cancellable/cancel()" rel="noopener ugc nofollow" target="_blank"><em class="mb">cancel()</em></a></code> <em class="mb">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f854" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用法如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ec1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，观察发布者将采取相同的行动，容器释放将取消任务。请注意，编译器使捕获对<code class="fe ln lo lp lq b">self</code>的强引用变得容易，因为它是隐式添加的。</p><p id="59fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在使用上述<code class="fe ln lo lp lq b">SubscriptionContainer</code>的同时，考虑弱攻<code class="fe ln lo lp lq b">self</code>。</p><p id="8b2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自然，扩展它以存储RxSwift订阅可以很容易地添加。</p></div></div>    
</body>
</html>