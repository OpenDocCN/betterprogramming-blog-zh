<html>
<head>
<title>3 Fallback Techniques To Support CSS Grid in Any Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在任何浏览器中支持CSS网格的3种回退技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-fallback-techniques-to-support-css-grid-in-any-browser-1740454d7cdb?source=collection_archive---------11-----------------------#2021-03-08">https://betterprogramming.pub/3-fallback-techniques-to-support-css-grid-in-any-browser-1740454d7cdb?source=collection_archive---------11-----------------------#2021-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="838d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解CSS网格在生产中的使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44bd12220eaa3cdf969b5571dcd302cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z99PsHMNipBY051X"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·施诺布里奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CSS Grid现在在浏览器中有很大的支持——大约95%的支持它的基本功能。然而，有时你不能忽略这5%,因为你可能希望你的web应用程序的布局在所有浏览器上看起来都很棒。您甚至可能希望使用支持较少的较新的网格特性。</p><p id="5b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做什么呢我们应该避免在生产中使用网格吗？我们应该忽略使用旧浏览器的用户吗？我们应该等待该功能有更好的覆盖范围吗？肯定不是。有很多后备技术可以克服这些问题。</p><p id="2ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将探索三个最重要的技术，它们将帮助我们从网格布局中优雅地后退。我们将根据可用的浏览器功能调整我们的网页设计。它将逐渐适应。</p><p id="7a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入技术方面之前，我们需要定义一个策略。拥有合适的策略是成功的关键。它会给我们方向感和一致性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa17" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义战略</h1><p id="fc08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Grid最常见的用法是构建适应用户屏幕分辨率的多维布局。当网格不可用时，您应该做什么？除了网格之外，你怎样才能做出一个灵活的、有反应的布局呢？</p><p id="7d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试通过使用Flexbox来复制相同的布局，但是这会添加太多的代码。此外，Flexbox并不是为同样的目的而构建的，您可能会感到吃力。</p><p id="e845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你该怎么办？解决方案非常简单:作为退路，只需向用户呈现移动布局。只有使用过时浏览器的桌面用户才会注意到一些问题。这在你的总用户群中所占的比例非常低。该网站应该是可用的和一致的。这是一个公平的交易。</p><p id="d793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用最新的网格特性怎么样？同样的策略也适用:尝试退回到一个体面的类似布局。</p><p id="c2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:我们的布局将逐步加强。使用老版本浏览器的用户将会看到一个更简单、更实用的布局版本。使用最新浏览器的用户将获得完整的UX体验。</p><p id="32b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们可以使用的三大工具。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eede" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用CSS功能查询</h1><p id="5684" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从描述这些是什么开始:</p><blockquote class="mz na nb"><p id="55e5" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“特性查询是使用CSS at-rule <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@supports" rel="noopener ugc nofollow" target="_blank"> @supports </a>创建的，非常有用，因为它们为web开发人员提供了一种测试浏览器是否支持特定特性的方法，然后提供仅基于该测试结果运行的CSS。在本指南中，您将了解如何使用功能查询实现渐进式增强。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Conditional_Rules/Using_Feature_Queries" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="3680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经使用过媒体查询，您将会非常熟悉它的语法。是一样的。不是根据浏览器的视窗大小来调整布局，而是根据CSS属性的有效性来调整布局。</p><p id="be13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的战略:</p><ol class=""><li id="8cc6" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们将使用Flexbox构建一个移动布局版本，并将其用作默认版本。</li><li id="1769" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">通过使用<code class="fe nu nv nw nx b">@supports</code>，我们将检查浏览器是否支持网格。如果是这样，我们将通过使用网格来增强我们的布局。</li></ol><p id="a7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，由于我们只对标准的网格行为感兴趣，我们将向<code class="fe nu nv nw nx b">@supports</code>查询基本的<code class="fe nu nv nw nx b">display: grid</code>特性:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="43e7" class="oc md it nx b gy od oe l of og">@supports (display: grid) {<br/>  //... code here<br/>}</span></pre><p id="f8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个完整的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="947a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们并没有断言这个网格特性:<code class="fe nu nv nw nx b">grid-template-columns</code>。如果浏览器不支持会怎么样？在这种情况下，Grid将退回到默认的定位算法。它会堆叠<code class="fe nu nv nw nx b">divs</code>。对于我们的例子，这是可行的，所以我们不需要任何额外的工作。</p><p id="fd27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看结果。</p><p id="7e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是桌面分辨率下支持网格的浏览器的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8e27844414219649587c13e532d85662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuwFq17QtSj96yMWa7KGwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">支持网格时的布局</p></figure><p id="fb80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是支持网格的浏览器在移动分辨率下的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bdafc1fcf45d37613f99b1b7977ec49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*nm0t3NbuJboHpmEACBUsIw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">支持网格时的布局</p></figure><p id="30c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是不支持网格的浏览器在任何分辨率下的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/4849e0f73082003fd5050da8f1ae19d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YfV-AKl5U5bRzX9BVYtMGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后备布局</p></figure><p id="4695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布局没有被破坏，仍然可以被所有浏览器引擎使用和访问。只有从桌面访问它的用户才会看到不同之处。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f8e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.以编程方式使用CSS功能查询</h1><p id="eb92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，仅仅通过CSS样式上的CSS特性查询是不可能实现您想要的。尽管它们很强大，但也有局限性。您可能希望基于浏览器功能以编程方式添加或移除元素。这是如何实现的？</p><p id="d075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，CSS特性可以在JavaScript端以编程方式调用。可以通过CSS对象模型接口<code class="fe nu nv nw nx b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSSupportsRule" rel="noopener ugc nofollow" target="_blank">CSSSupportsRule</a></code>访问<code class="fe nu nv nw nx b">@supports</code>。</p><blockquote class="om"><p id="5b09" class="on oo it bd op oq or os ot ou ov lu dk translated">"<code class="fe nu nv nw nx b"><strong class="ak">CSSSupportsRule</strong></code>接口代表单个CSS <code class="fe nu nv nw nx b">@supports</code> <code class="fe nu nv nw nx b">at-rule</code>"— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSSupportsRule" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="2c95" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">让我们看看接口定义:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="418f" class="oc md it nx b gy od oe l of og">function supports(property: string, value: string): boolean;</span></pre><p id="aadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在一个虚拟的例子中使用它。让我们警告用户，如果他们使用的浏览器不支持网格布局特性。千万不要在生产中这样做。这只是一个好玩的虚拟例子。</p><p id="19ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们如何有条件地检查网格是否不受支持:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="8187" class="oc md it nx b gy od oe l of og">if (!CSS || !CSS.supports('display', 'grid')) {<br/>  ...<br/>}</span></pre><p id="a819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe nu nv nw nx b">CSS.supports</code>可能在某些浏览器上不被支持，因此会进行空值检查。</p><p id="2a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个工作代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="724e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">CSS.supports</code>是一个以编程方式创建后备布局的伟大工具。如果您必须处理非常复杂的布局，您可能希望选择这种技术，而不是CSS特性查询。您可以使用它来创建web组件及其编程回退。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.覆盖属性</h1><p id="0c98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候你不需要像CSS特性查询这样的花哨东西。您可以利用CSS属性的工作方式:当在CSS类中重新定义属性时，最后一个有效的属性将被使用。</p><p id="7542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是什么意思？这有多酷？您可以通过覆盖CSS属性来定义回退:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="5db2" class="oc md it nx b gy od oe l of og">#container {<br/>  display: flex;<br/>  display: grid;</span><span id="b9c4" class="oc md it nx b gy pb oe l of og">  // if grid is not available this will be invalid and it will apply the previous property value: flex<br/>}</span></pre><p id="6334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一种更简单的方式重做我们之前的CSS特性查询示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ac2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种退路简单而强大。它在许多情况下都很有用。您不可能对所有想要使用的网格特性使用支持查询。</p><p id="266a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用它来回顾一下最新的网格特性之一:<code class="fe nu nv nw nx b">subgrid</code>。应该怎么用？</p><p id="2e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一个场景，在这个场景中，我们希望将<code class="fe nu nv nw nx b">subgrid</code>用于嵌套的网格模板列。这是它的要点:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="9790" class="oc md it nx b gy od oe l of og">#content {<br/>  grid-template-columns: inherit;<br/>  grid-template-columns: subgrid;<br/>}</span></pre><p id="95fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，当不支持子网格时，它将只继承父网格定义。这将创建一个大致相似的布局。</p><p id="ca34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的例子。您可以将<code class="fe nu nv nw nx b">grid-template-columns</code>微调到一些固定的大小，或者在您的特定场景中最有效的大小。</p><p id="85b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="fb4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/dd4c482193a6c2c413b1cfb3d8079cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vk89GdczF9r3hEZI6841gw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子网格可用。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/56ff8a0c5b6b4ae1008cc9aeb3d38f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8rPVYjENApqFPg--2Be_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子网格不可用。</p></figure><p id="1ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，结果100%相等，但非常相似。这就是我们的目标。随着越来越多的浏览器采用<code class="fe nu nv nw nx b">subgrid</code>，越来越多的用户将会看到你的布局的像素完美版本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d2d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="31bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Grid和Flexbox旨在解决不同的场景。我们不能一直用Flexbox构建所有东西，因为仍然有少数浏览器不支持它。</p><p id="5f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Flexbox升级到Grid并不意味着旧设备上的布局会突然中断。在本文中，我们探索了构建渐进式布局是多么容易和有趣。正如我们在开始时看到的，有一个如何进行的策略是非常重要的。</p><p id="32ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些策略不仅仅意味着添加基本的网格功能。只要你提供一个合理的退路，你就可以利用像<code class="fe nu nv nw nx b">subgrid</code>这样的最新特性。</p><p id="1797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这能激励您在需要的时候逐步开始在生产中使用网格。你再也不用躲在Flexbox后面了。</p><h2 id="816a" class="oc md it bd me pe pf dn mi pg ph dp mm li pi pj mo lm pk pl mq lq pm pn ms po bi translated">相关文章</h2><div class="pp pq gp gr pr ps"><a rel="noopener  ugc nofollow" target="_blank" href="/grid-vs-flexbox-which-one-should-you-be-using-471cb955d3b5"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">Grid和Flexbox——你应该使用哪一个？</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">为正确的工作寻找正确的工具的旅程</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">better编程. pub</p></div></div><div class="qb l"><div class="qc l qd qe qf qb qg ks ps"/></div></div></a></div><div class="pp pq gp gr pr ps"><a rel="noopener  ugc nofollow" target="_blank" href="/top-3-css-grid-features-to-start-using-in-production-b0fe59b2e0f7"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">开始在生产中使用的3大CSS网格特性</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">深入探究一些广泛支持的CSS网格特性</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">better编程. pub</p></div></div><div class="qb l"><div class="qh l qd qe qf qb qg ks ps"/></div></div></a></div></div></div>    
</body>
</html>