<html>
<head>
<title>Advanced Form Validation With Only HTML and CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅使用HTML和CSS的高级表单验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-form-validation-with-only-html-and-css-e92fa3dc9b54?source=collection_archive---------1-----------------------#2022-07-04">https://betterprogramming.pub/advanced-form-validation-with-only-html-and-css-e92fa3dc9b54?source=collection_archive---------1-----------------------#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们构建一个简单的表单，看看我们可以使用的所有HTML和CSS验证技术，然后提交表单！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/590366e9ffc6d9ec7e5f91a26bc0ed5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xDM_hNew7qa6PyIY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://matemarschalko.medium.com/advanced-css-only-input-fields-interactive-animated-validated-d7ecff3cde8c" rel="noopener">上周</a>我们构建了一个交互式的、动画的高级输入框，甚至包括一些自我验证，我们根本没有使用JavaScript！</p><p id="98cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">焦点主要集中在鼠标和键盘的交互以及依赖于验证状态的样式上。但是我们能做的远不止这些！</p><p id="8dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们添加了验证功能，并提交了一个只有CSS和HTML的表单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="7dab" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">浏览器提供的输入字段</h1><p id="50ea" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">带<code class="fe mu mv mw mx b">type="text"</code>的普通输入域，顾名思义，允许你输入一些文本。通过要求在输入有效和提交表单之前输入一定数量的字符，我们可以进一步澄清我们期望的文本类型。这可以用<code class="fe mu mv mw mx b">minlength</code>和<code class="fe mu mv mw mx b">maxlength</code>属性来定义。我们还可以使用<code class="fe mu mv mw mx b">required</code> required属性来指示输入必须有某个值才能有效。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b1f9" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="text" minlength="3" maxlength="20" required /&gt;</span></pre><p id="b4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地限制字符长度可能不足以验证许多其他的表单域类型，但是最重要的是最常见的表单域类型都有自己的专用类型。验证电子邮件绝对不仅仅是检查字符长度，所以我们可以依靠浏览器来完成这项工作，这很好:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7d73" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="email" /&gt;</span></pre><p id="0073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将验证状态从无效更改为有效之前，此输入字段现在只接受电子邮件地址。</p><p id="b879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们也可以让浏览器检查输入是否是有效的URL:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d358" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="url" /&gt;</span></pre><p id="17c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密码输入类型不会验证输入的密码，但它会通过用符号(通常是*或)替换每个字符来模糊文本。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bff0" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="password" /&gt;</span></pre><p id="4c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也有搜索类型，但它的功能与大多数浏览器上的简单文本字段相同，但定义不同可能有助于可访问性或样式:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7673" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="search" /&gt;</span></pre><p id="104b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的内置类型列表，然而，它显然是不完整的，我们不能希望有一个所有可能类型的完整列表。为了解决这个问题并给我们更多的灵活性，发明了<code class="fe mu mv mw mx b">pattern</code>属性。</p><h1 id="8ba5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">10分钟正则表达式简介</h1><p id="4a33" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe mu mv mw mx b">pattern</code>属性接受一个正则表达式，该表达式定义了一个标准，然后用来测试输入值，以决定该值是有效还是无效。</p><p id="1def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式很复杂！</p><p id="eaf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多关于这个主题的书，这也意味着你可以用它们做很多事情。让我们看几个简单的例子来了解这个想法。我能想到的最简单的正则表达式允许输入一个字符，在本例中是“a ”:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bd1d" class="nc ly it mx b gy nd ne l nf ng">a</span></pre><p id="b2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果希望将这个正则表达式模式分配给输入字段，只需将其添加到模式属性中:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2242" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="text" pattern="a" /&gt;</span></pre><p id="581d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们非常简单的输入字段现在只接受“a”作为输入值，其他都是无效的。</p><p id="04c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多次输入“a”也无效。为了允许字符多次出现，我们可以使用+号:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8e0a" class="nc ly it mx b gy nd ne l nf ng">a+</span></pre><p id="aaed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以通过在花括号之间定义一个数字来允许固定数量的“a”字符:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="18af" class="nc ly it mx b gy nd ne l nf ng">a{5}</span></pre><p id="a1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如果我们想允许输入从“a”到“z”的所有字母呢？为此，我们需要做的就是使用破折号来定义范围:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0e32" class="nc ly it mx b gy nd ne l nf ng">[a-z]+</span></pre><p id="9843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住正则表达式是非常严格的，所有的规则都必须是显式的。例如，按照我们的定义，它只允许小写字母，因此必须明确定义允许大写字母:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d4bc" class="nc ly it mx b gy nd ne l nf ng">[a-zA-Z]+</span></pre><p id="8386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照这个逻辑，向规则集添加数字很简单:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a9c4" class="nc ly it mx b gy nd ne l nf ng">[a-zA-Z0-9]+</span></pre><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用更多的字符来扩展一下:_。+ —并说结尾必须是“@gmail.com”。据此，我们创建了一个非常原始的电子邮件验证器，仅允许gmail电子邮件进入:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2a2b" class="nc ly it mx b gy nd ne l nf ng">[a-zA-Z0-9_.+-]+@gmail.com</span></pre><p id="3084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们的正则表达式搜索整个输入值。这意味着我们新的Gmail模式将报告一封有效的电子邮件，即使它在一句话的中间。但这不是我们想要的。我们想确保除了邮件之外没有其他东西。为此，我们需要添加一条规则，要求输入文本以定义的电子邮件开始和结束。^符号表示表达式的开始，$符号表示表达式的结束。添加这些解决了我们的问题:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="26ae" class="nc ly it mx b gy nd ne l nf ng">^[a-zA-Z0-9_.+-]+@gmail.com$</span></pre><p id="3124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的例子，展示了正则表达式的可能性，但是由于它的简单性，对于生产代码来说可能不够好，因为它没有考虑所有的边缘情况。</p><p id="3235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再看几个例子，这次用数字。假设我们想要创建一个输入字段来验证一个月中的某个日期，从而允许输入从1到31的数字。让我们假设<code class="fe mu mv mw mx b">number</code>类型的输入字段不存在，我们不能简单地用<code class="fe mu mv mw mx b">min</code>和<code class="fe mu mv mw mx b">max</code>属性定义允许的范围。相反，让我们用正则表达式重新创建这个逻辑。</p><p id="a008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经了解了如何定义一系列字符。假设我们允许从1到9的字符，而不允许使用开始和结束符号:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7f2b" class="nc ly it mx b gy nd ne l nf ng">^[1-9]$</span></pre><p id="5cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试将允许的范围定义在10到29之间。如果我们开始考虑字符链而不是数字，那么我们会看到10到29范围内的第一个字符只能是1和2。另一方面，第二个字符可以是0到9。将它转换成正则表达式意味着我们添加两个方括号，每个方括号代表一个允许的字符:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0efe" class="nc ly it mx b gy nd ne l nf ng">^[12][0-9]$</span></pre><p id="b026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住12不是12，这意味着我们允许1和2作为第一个字符。定义30和31的方法非常相似:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3ef9" class="nc ly it mx b gy nd ne l nf ng">^[3][01]$</span></pre><p id="5405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们设法分别定义了这些条件，但是现在我们需要找到一种方法将它们组合在一个正则表达式中。我们需要结合的三条规则是:</p><ul class=""><li id="f344" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">使用<code class="fe mu mv mw mx b">^[1-9]$</code>允许数字从1到9</li><li id="2b7b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">使用<code class="fe mu mv mw mx b">^[12][0-9]$</code>允许10到29的数字</li><li id="7732" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">允许数字30和31带有<code class="fe mu mv mw mx b">^[3][01]$</code></li></ul><p id="75a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">圆括号和管道符号(<code class="fe mu mv mw mx b">|</code>)让我们可以组合这些规则。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ab71" class="nc ly it mx b gy nd ne l nf ng">^([1-0]|[12][0-9]|[3][01])$</span></pre><p id="11ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把pipe看作一个“或”组合子，如果任何子规则的结果为真，那么正则表达式的结果为真。现在，我们可以输入从1到31的数字。</p><p id="209a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加一点额外的逻辑，我们可以定义DD/MM/YYYY日期格式:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7746" class="nc ly it mx b gy nd ne l nf ng">^((0?[1–9]|[12][0–9]|3[01])[- /.](0?[1–9]|1[012])[- /.] (19|20)?[0–9]{2})*$</span></pre><p id="dca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我承认这比前面的例子稍微复杂一些，但是它应该是可读和可理解的。在一天结束的时候，我们不一定要自己写这些。网上有很多资源可以帮助你。</p><p id="f3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你编写和测试新的正则表达式时，我推荐使用Regexr网站。在这个网站上还有一个方便的备忘单和一个提供大量帮助的实时编辑器。</p><p id="cc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经了解了最常用的输入类型和一些正则表达式，但是我们不要忘记我们可以使用的所有其他输入类型！</p><h1 id="4b0f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">更高级的内置输入类型</h1><p id="a1e3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">例如，您可以编写和验证数字:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="edeb" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="number" min="0" max="1000" step="10" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7ebd16be34538bdfd2dec8907a444e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*mgMg-hrIkfCHZyp0NayvVQ.png"/></div></figure><p id="4d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数字输入字段有一个<code class="fe mu mv mw mx b">min</code>和一个<code class="fe mu mv mw mx b">max</code>属性来定义有效的数字范围。我们还有<code class="fe mu mv mw mx b">step</code>，它是点击上下箭头调整数值时使用的步进间隔。<code class="fe mu mv mw mx b">step</code>也用于验证。在本例中，我们将<code class="fe mu mv mw mx b">step</code>值设置为<code class="fe mu mv mw mx b">10</code>，这意味着单击向上或向下箭头将从0到1000以10为单位递增和递减数字。</p><p id="6183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于电话号码，我们可以使用<code class="fe mu mv mw mx b">tel</code>输入类型。这将在移动设备上显示专用的电话号码键盘:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ff9b" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="tel" /&gt;</span></pre><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们还有复选框:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f906" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="checkbox" /&gt;<br/>&lt;input type="checkbox" checked /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4267e3ddb648bcf7a7fd7e0f20ef49cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/1*ZR5id5-kyQyfmezYFIqdZw.png"/></div></figure><p id="eee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和单选按钮:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d250" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="radio" /&gt;<br/>&lt;input type="radio" checked /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7f979e1e1a9582a77534f2731829092c.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/1*azWJjadwjvyDu7qltXItBA.png"/></div></figure><p id="50ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们之间的区别在于，当我们有多个选项可供选择时，单选按钮只允许从所有选项中选择一个，而复选框允许同时选择多个值。</p><p id="73aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复选框和单选按钮是如此的多才多艺，以至于我有一些专门的帖子来讨论我们可以用它们做的所有技巧。</p><p id="bedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且这还不是全部！我们可以把一个输入框变成一个按钮:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="6ff8" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="button" value="Click me! /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9cf9656e9aed3456fe179d1a55220f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*7nQXG9v5tmRFzd2jsEDo5w.png"/></div></figure><p id="45c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，如果没有分配给它一些JavaScript功能，它自己不会做太多事情，所以它对我们来说没有多大用处！</p><p id="a206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们必须提交和重置按钮，以便将表单中经过验证的字段发送到web服务器进行处理，或者清除所有字段并重新启动。这些根本不需要任何JavaScript！</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2a4f" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="submit" /&gt;<br/>&lt;input type="reset" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2645904292ea21334b32253b999b5e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*W6Y-bhfTV1QlBoFweZG_Dw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b019e8042d619a8f39ba174ffdb76673.png" data-original-src="https://miro.medium.com/v2/resize:fit:228/format:webp/1*cRhAPz5saK6N2qe1qp6RmA.png"/></div></figure><p id="a9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用简单的HTML表单而不是JavaScript将表单提交到web服务器进行处理听起来很令人兴奋，但是在我们研究这个之前，让我们快速浏览一下我们所拥有的一些可用的但稍具实验性的输入类型:</p><p id="ec61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">挑选颜色:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="72bc" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="color" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5bd17c0d94de7d2961f9cf95cd65ddd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*sCMifLZjcjfBZilp3oCSdA.png"/></div></figure><p id="cf42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们的计算机中选择图像或其他文件，与表单一起提交:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="cf67" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="file" /&gt;<br/>&lt;input type="image" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8b28d38758207843dda0f8489f2194ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*9e16OBC4L3OV48_EUvF6tw.png"/></div></figure><p id="87e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及提交日期和时间的各种输入:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1c75" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="date" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/4301224c02997b132aea897f1b4bc884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*q-gAPqYfxMlP9jqWvJ_yZg.png"/></div></figure><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0afc" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="datetime" /&gt;</span><span id="468e" class="nc ly it mx b gy oe ne l nf ng">&lt;input type="week" /&gt;</span><span id="d441" class="nc ly it mx b gy oe ne l nf ng">&lt;input type="month" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b46256c80c24934fd9b23b35fa1392ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*xKXbSWGvPOFoUxZe2uIzXw.png"/></div></figure><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1657" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="time" /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5017e7018ac28ac2dedb846572346f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*xKSvIZtDXGZHUktk89FAlQ.png"/></div></figure><p id="5a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很棒的是，我们可以使用所有这些输入字段，而不必围绕它们编写JavaScript功能和验证。您甚至可以使用带有日期和时间字段的<code class="fe mu mv mw mx b">min</code>和<code class="fe mu mv mw mx b">max</code>属性来定义允许的日期和时间范围:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ea8b" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="date" min="2018-01-01" max="2018-12-31" value="2018-07-22" /&gt;</span><span id="3baf" class="nc ly it mx b gy oe ne l nf ng">&lt;input type="time" min="9:00" max="18:00" value="13:22" /&gt;</span></pre><p id="7aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不要忘记，我们可以用<code class="fe mu mv mw mx b">:valid</code>和<code class="fe mu mv mw mx b">:invalid</code>选择器来选择所有这些输入字段的验证状态。</p><p id="01d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您就可以显示和隐藏它们的错误和成功验证消息。我们在我之前的<a class="ae ky" href="https://matemarschalko.medium.com/advanced-css-only-input-fields-interactive-animated-validated-d7ecff3cde8c" rel="noopener">帖子</a>中讨论过这些。</p><h1 id="6351" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">构建我们的高级形式</h1><p id="af03" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">要查看所有这些，让我们创建一个非常简单的表单来提交一些测试结果。您的分数需要超过65%才能提交表格，该表格将使用已经讨论过的功能进行验证。该表单将类似于以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/aca812759e0a118a17d55b1f5bb0fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AVqSPgbXBlUPXIbrw560g.png"/></div></div></figure><p id="a2f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以复制并使用此示例的项目模板。您可以从<a class="ae ky" href="https://github.com/webondevices/html-css-wizardry" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载模板和完成示例的源代码。</p><p id="18c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们复制我们的项目模板并准备文档的框架。表单将位于一个<code class="fe mu mv mw mx b">&lt;form&gt;</code>和<code class="fe mu mv mw mx b">&lt;fieldset&gt;</code>中:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5330" class="nc ly it mx b gy nd ne l nf ng">&lt;form&gt;<br/>  &lt;fieldset&gt;<br/>    &lt;legend&gt;Submit your score&lt;/legend&gt;<br/>    &lt;!-- Form fields will come here --&gt;<br/>     &lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>  &lt;/fieldset&gt;<br/>&lt;/form&gt;</span></pre><p id="0f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元素可以用来将几个控件和一个标题组合在一起。在<code class="fe mu mv mw mx b">&lt;fieldset&gt;</code>中，我们从一个<code class="fe mu mv mw mx b">&lt;legend&gt;</code>开始，它将作为表单的标题。之后，我们将添加表单字段(即将到来)，然后我们在最后有提交按钮，当单击时会自动触发表单提交。</p><h1 id="62ab" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">实现单个字段</h1><p id="d796" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">表单中的第一个输入字段是电子邮件地址:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="6962" class="nc ly it mx b gy nd ne l nf ng">&lt;label for="email"&gt;Enter your Gmail&lt;/label&gt;<br/>&lt;input<br/>  id="email"<br/>  placeholder="Enter your email ending with @gmail.com"<br/>  pattern="^[a-zA-Z0-9_.+-]+@gmail.com$"<br/>  name="email"<br/>  type="email"<br/>  required /&gt;<br/>&lt;span class="error-message"&gt;<br/>  Enter a valid email ending with @gmail.com<br/>&lt;/span&gt;<br/>&lt;span class="success-message"&gt;<br/>  Email correct<br/>&lt;/span&gt;</span></pre><p id="9b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我们需要输入一个Gmail地址，这样我们就可以使用我们之前创建的正则表达式。另外，请注意添加了错误和成功消息。我们将根据字段的验证状态来切换它们的可见性。但是我们希望默认情况下这些是隐藏的:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="fa98" class="nc ly it mx b gy nd ne l nf ng">.error-message,<br/>.success-message {<br/>  display: none;<br/>}</span></pre><p id="733c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加输入字段来输入分数，我们说过分数至少需要达到65分才能被接受:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="c43c" class="nc ly it mx b gy nd ne l nf ng">&lt;label for="score"&gt;Enter your test result&lt;/label&gt;<br/>&lt;input id="score" type="number" name="score" min="65" max="100" value="0" required /&gt;</span><span id="c1bd" class="nc ly it mx b gy oe ne l nf ng">&lt;span class="error-message"&gt;<br/>  You haven't reached the minimum score<br/>&lt;/span&gt;<br/>&lt;span class="success-message"&gt;<br/>  Congratulations for your excellent score<br/>&lt;/span&gt;</span></pre><p id="d573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果没有营销垃圾邮件的同意复选框并使其成为强制性的，任何表格都是不完整的。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="439f" class="nc ly it mx b gy nd ne l nf ng">&lt;label&gt;Tick if you want to receive marketing spam from us<br/>  &lt;input id="accept" name="marketing" type="checkbox" required /&gt;<br/>&lt;/label&gt;</span></pre><p id="82b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，表单的HTML标记就完成了，验证也按预期进行，因为已经添加了正确的属性:</p><ul class=""><li id="6401" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">email字段中的email <code class="fe mu mv mw mx b">pattern</code>和<code class="fe mu mv mw mx b">reguired</code>属性，以确保表单中提交了有效的email</li><li id="a6b5" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">分数字段中的最小值(<code class="fe mu mv mw mx b">min</code>)、最大值(<code class="fe mu mv mw mx b">max</code>)和<code class="fe mu mv mw mx b">required</code>属性，以确保用户只提交分数超过65的表单</li><li id="d4dd" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">营销复选框的<code class="fe mu mv mw mx b">required</code>必需属性，确保每个人都同意接受营销电子邮件</li></ul><p id="a438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一些基本的东西开始设计表单:我们需要移除字段集周围的边框，增加图例的字体大小，将输入字段堆叠在一起，并在它们周围留有一定的间距:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="914e" class="nc ly it mx b gy nd ne l nf ng">main {<br/>  padding: 50px;<br/>}</span><span id="0614" class="nc ly it mx b gy oe ne l nf ng">fieldset {<br/>  border: none;<br/>}</span><span id="4989" class="nc ly it mx b gy oe ne l nf ng">legend {<br/>  font-size: 24px;<br/>  font-weight: bold;<br/>}</span><span id="1a46" class="nc ly it mx b gy oe ne l nf ng">input, button, label {<br/> display: block;<br/>}</span><span id="75ab" class="nc ly it mx b gy oe ne l nf ng">input {<br/>  width: 400px;<br/>  height: 30px;<br/>  padding: 15px;<br/>  font-size: 16px;<br/>  outline: none;<br/>  border: 2px solid var(--grey);<br/>  margin-bottom: 30px;<br/>}</span></pre><p id="8ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，表单域将以灰色边框开始。但是我们还想在编辑输入字段时将这些边框颜色更改为黑色，在有效时更改为绿色，在无效时更改为红色:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ba2f" class="nc ly it mx b gy nd ne l nf ng">input:focus {<br/>  border: 2px solid black;<br/>}</span><span id="c383" class="nc ly it mx b gy oe ne l nf ng">input:valid {<br/>  border: 2px solid var(--green);<br/>}</span><span id="4a47" class="nc ly it mx b gy oe ne l nf ng">input:invalid {<br/>  border: 2px solid var(--red);<br/>}</span></pre><p id="0740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的表单中，所有输入文本字段都是强制性的，因为它们具有必需的属性。如果您有一个带有可选字段的表单，那么您可以使用<code class="fe mu mv mw mx b">:optional</code>伪选择器来设置它们的样式:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4cff" class="nc ly it mx b gy nd ne l nf ng">input:optional {}</span></pre><p id="08e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还想对所有必需的输入字段元素进行样式化，这也有一个伪类:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="514e" class="nc ly it mx b gy nd ne l nf ng">input:required {}</span></pre><p id="5cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于带有<code class="fe mu mv mw mx b">min</code>和<code class="fe mu mv mw mx b">max</code>属性的输入字段，还有一个特殊的选择器。有了这些，您可以使用<code class="fe mu mv mw mx b">:in-range</code>伪类来选择字段，其中输入的数字介于<code class="fe mu mv mw mx b">min</code>和<code class="fe mu mv mw mx b">max</code>属性中的值和<code class="fe mu mv mw mx b">:out-of-range</code>属性中的值之间，当它超出这个范围时:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5e79" class="nc ly it mx b gy nd ne l nf ng">input:in-range {<br/>  border: 2px solid var(--green);<br/>}</span><span id="9921" class="nc ly it mx b gy oe ne l nf ng">input:out-of-range {<br/>  border: 2px solid var(--red);<br/>}</span></pre><p id="ff24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些伪类有助于向用户提供一个可视化的指示，表明字段的当前值在允许的范围内。如果您想要更好地控制您的错误验证，这是很好的，但是在我们的例子中这是不必要的，因为字段仍然会响应<code class="fe mu mv mw mx b">:valid</code>和<code class="fe mu mv mw mx b">:invalid</code>伪类。</p><p id="2aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一需要做一些额外工作的是错误和成功消息。我们需要根据字段的验证状态来显示和隐藏这些消息。将错误消息设为红色，成功消息设为绿色也不错。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="663a" class="nc ly it mx b gy nd ne l nf ng">.error-message,<br/>.success-message {<br/>  display: none;<br/>}</span><span id="bde9" class="nc ly it mx b gy oe ne l nf ng">.error-message {<br/>  color: var(--red);<br/>}</span><span id="d4be" class="nc ly it mx b gy oe ne l nf ng">.success-message {<br/>  color: var(--green);<br/>}</span><span id="e236" class="nc ly it mx b gy oe ne l nf ng">input:invalid + .error-message,<br/>input:valid + .error-message + .success-message {<br/>  display: block;<br/>}</span></pre><p id="cba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了<code class="fe mu mv mw mx b">display: none</code>来使消息容器默认隐藏。我们用来显示无效字段的错误消息的选择器是这样的:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d3fe" class="nc ly it mx b gy nd ne l nf ng">input:invalid + .error-message {}</span></pre><p id="539d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还记得的话，+是相邻的兄弟选择器。如果我们有A + B，那么选择器选择紧跟在HTML文档中A元素之后的B元素。我们的新选择器选择文档中任何无效输入元素之后的带有<code class="fe mu mv mw mx b">error-message</code>类的元素。</p><p id="1c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于错误消息非常有效，但是相同的选择器不能用于成功消息:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f053" class="nc ly it mx b gy nd ne l nf ng">/* this will not work */<br/>input:valid + .success-message</span></pre><p id="2893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将不起作用，因为成功消息元素没有紧跟在输入字段之后。错误消息夹在两者之间，阻止相邻的兄弟选择器工作。</p><p id="38d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一般的同胞选择器(~)怎么样？</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ef09" class="nc ly it mx b gy nd ne l nf ng">/* this will not work */<br/>input:valid ~ .success-message {}</span></pre><p id="51bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅会选择即将出现的元素，还会选择出现在表单更下方的所有成功消息兄弟元素。</p><p id="a4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过将所有输入字段及其标签和消息容器包装在一个额外的元素中来解决，以确保在同一级别上只有一个成功消息，但是在HTML中引入额外的元素来支持某种样式并不是一个好的做法。我们可以做得更好，方法是在有效输入字段后的错误消息后选择成功消息:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2aa3" class="nc ly it mx b gy nd ne l nf ng">input:valid + .error-message + .success-message {}</span></pre><p id="f9d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们将选择器的范围限制在相关的成功消息容器。在其他情况下，您可能不知道想要跳过的元素的确切类别，所以您可能只想说您想要它后面的第二、第三或第四个元素。对于这些情况，您可以使用通用选择器，它会忽略中间的元素类型:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="c4e6" class="nc ly it mx b gy nd ne l nf ng">/* second element after the input field */<br/>input:valid + * + .success-message {}</span><span id="0c2d" class="nc ly it mx b gy oe ne l nf ng">/* third element after the input field */<br/>input:valid + * + * + .success-message {}</span><span id="3b6c" class="nc ly it mx b gy oe ne l nf ng">/* fourth element after the input field */<br/>input:valid + * + * + * + .success-message {}</span></pre><p id="3168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个新提出的选择器，当你打开页面时，错误信息会立即显示出来，并且，正如所料，当你开始填写表单时，它们会一个接一个地变绿。但是这对用户来说可能有点烦人，因为我们告诉他们，他们甚至在开始之前就把整个表单弄乱了。</p><p id="598a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以使用前面的示例项目中的想法<a class="ae ky" href="https://matemarschalko.medium.com/advanced-css-only-input-fields-interactive-animated-validated-d7ecff3cde8c" rel="noopener">，仅在用户与表单交互并输入一些值(占位符不再显示)以及用户完成编辑(输入字段不再处于焦点)后显示这些消息:</a></p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a440" class="nc ly it mx b gy nd ne l nf ng">input:not(:placeholder-shown):not(:focus):valid {<br/>  border: 2px solid var(--green);<br/>}</span><span id="bf7e" class="nc ly it mx b gy oe ne l nf ng">input:not(:placeholder-shown):not(:focus):invalid {<br/>  border: 2px solid var(--red);<br/>}</span><span id="ea86" class="nc ly it mx b gy oe ne l nf ng">input:not(:placeholder-shown):not(:focus):invalid + .error-message,<br/>input:not(:placeholder-shown):not(:focus):valid + .error-message + .success-message {<br/>  display: block;<br/>}</span></pre><p id="738f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在表单的末尾，我们在HTML中添加了submit按钮:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5565" class="nc ly it mx b gy nd ne l nf ng">&lt;button type="submit"&gt;Submit&lt;/button&gt;</span></pre><p id="a337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要一些基本的样式来使它看起来更好:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="670f" class="nc ly it mx b gy nd ne l nf ng">[type="submit"] {<br/>  width: 150px;<br/>  height: 30px;<br/>  margin-top: 20px;<br/>  border: none;<br/>  background-color: var(--blue);<br/>  cursor: pointer;<br/>}</span></pre><h1 id="ac74" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">验证整个表单</h1><p id="a68f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">到目前为止，我们已经看到了如何验证单个字段并使用一些属性定义验证规则，然后根据输入字段的焦点、有效和无效状态以及一些伪类的帮助来设计输入字段的样式。输入字段正在验证，相关的成功和错误消息正在出现，因此我们取得了良好的进展！</p><p id="dc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们花了很多时间处理各个输入字段。现在让我们看看可以对表单本身做些什么！</p><p id="3e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您构建整个表单时，通常会有多个输入字段，最后有一个提交按钮，您可以用一个字段集和图例将所有内容包装在一个表单元素中:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b953" class="nc ly it mx b gy nd ne l nf ng">&lt;form&gt;<br/>  &lt;fieldset&gt;<br/>    &lt;legend&gt;Submit your score&lt;/legend&gt;<br/>    &lt;!-- Form fields will come here --&gt;<br/>    &lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>  &lt;/fieldset&gt;<br/>&lt;/form&gt;</span></pre><p id="2635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚构建的表单具有相同的结构，在最后我们有一个提交按钮，将您的输入值发送到服务器。在这个例子中，我们使用了一个带有属性的元素来告诉浏览器我们希望使用这个按钮来提交表单的内容。但是我们也可以只使用带有<code class="fe mu mv mw mx b">type="submit"</code>属性的<code class="fe mu mv mw mx b">&lt;input&gt;</code>元素。我们还可以添加带有<code class="fe mu mv mw mx b">type="reset"</code>属性的按钮和输入:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3520" class="nc ly it mx b gy nd ne l nf ng">&lt;button type="reset"&gt;Reset&lt;/button&gt;<br/>&lt;input type="reset" value="Reset" /&gt;</span></pre><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按下这些按钮将清除表单中的所有字段和值。</p><p id="6a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">&lt;button&gt;</code>和<code class="fe mu mv mw mx b">&lt;input&gt;</code>元素处理提交和重置表单的方式是相同的。它们之间唯一的区别是，输入提交按钮只通过它的value属性将文本作为内容，然而，按钮元素内部可以有额外的HTML内容，如一个图像或一段文本，这样在需要时会提供更多的灵活性。</p><p id="4798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试点击提交按钮而不填写表单，浏览器将验证您的整个表单，并且不允许您向服务器发送任何内容并中止提交。浏览器甚至会给你一个有意义的错误信息，告诉你可能出了什么问题。所有这些都是通过我们在中添加的验证属性自动发生的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4412b572b8479aec59cb65a3d22e19ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzhXKWVoovSHsZeE8WUmXg.png"/></div></div></figure><p id="123e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，不仅仅是您的输入字段是无效的，而且表单本身也是无效的。这意味着您可以根据表单的验证状态来设计整个表单的样式。让我们在表单周围添加一个红色边框来表示有问题:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="22ac" class="nc ly it mx b gy nd ne l nf ng">form:invalid {<br/>  border: 1px solid var(--red);<br/>}</span></pre><p id="189a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户现在可以立即知道他们没有完成。但是提交按钮本身仍然是活动的，仍然可以被按下。如果表单还没有完成，禁用并变灰按钮怎么样？</p><p id="3fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这可以很容易地通过向按钮添加<code class="fe mu mv mw mx b">disabled</code>属性来实现:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ea8e" class="nc ly it mx b gy nd ne l nf ng">&lt;input type="submit" value="Submit" disabled /&gt;</span></pre><p id="5854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将禁用按钮并添加适当的样式，但是不能从CSS中切换该属性，只能从JavaScript中切换。这意味着该按钮被禁用，并且即使在表单有效并准备好提交后也将保持禁用状态。</p><p id="5408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入字段还有一个<code class="fe mu mv mw mx b">readonly</code>属性，顾名思义，它不允许用户修改内容，内容只能被读取。与禁用状态类似，只读状态也可以通过相关的伪类在CSS中获得:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8a68" class="nc ly it mx b gy nd ne l nf ng">/* not needed for our example */<br/>input:disabled,<br/>input:read-only {<br/>  border: 2px solid grey;<br/>}</span></pre><p id="a7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们还有一个伪类来选择所有启用的输入字段:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e2e0" class="nc ly it mx b gy nd ne l nf ng">input:enabled {}</span></pre><p id="ee9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们知道不能用CSS切换disabled属性，但是，我们可以通过选择无效表单中的submit子按钮来模拟一些CSS的禁用状态，因为我们知道表单也会获得无效状态:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="751b" class="nc ly it mx b gy nd ne l nf ng">form:invalid [type="submit"] {<br/>  background-color: var(--grey);<br/>  cursor: not-allowed;<br/>}</span></pre><p id="9de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个挺好看的！当表格未完成时，按钮为灰色，将光标移至其上会将鼠标指针设置为“不允许”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/481c65c462c0cf3c6560f9265226ab6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*pMmSEFJd0aj7l1UzShohwQ.png"/></div></figure><p id="319d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦表单全部有效，该规则将不再适用，按钮将变回蓝色，光标指针指向其默认值。</p><p id="6301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们设法添加了一些视觉指示，按钮被禁用，但尽管我们所有的努力，按钮仍然是可点击的。用CSS完全禁用按钮实际上可能吗？</p><p id="ac39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还记得的话，我们已经做过类似的事情，当我们创建我们的<a class="ae ky" href="https://matemarschalko.medium.com/advanced-css-only-input-fields-interactive-animated-validated-d7ecff3cde8c" rel="noopener">高度交互和动画输入字段</a>并想要禁止点击覆盖字段的表单标签时。</p><p id="8b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诀窍是用<code class="fe mu mv mw mx b">pointer-events</code> CSS属性禁用元素上注册的指针事件。让我们将它添加到提交按钮的禁用状态:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bf74" class="nc ly it mx b gy nd ne l nf ng">form:invalid [type="submit"] {<br/>  background-color: var(--grey);<br/>  cursor: cursor: not-allowed;<br/><strong class="mx iu">  pointer-events: none;</strong><br/>}</span></pre><p id="1322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种添加，除非表单有效并准备好提交，否则不能再单击按钮，在这种情况下，按钮将变成蓝色:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f9b373aaa3f34452e90bd8b8c45fbf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQXQFcH4fH0if-Z2Jnoyow.png"/></div></div></figure><p id="e9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是我们引入了一个小的回归。因为指针事件不再被按钮拾取，包括当鼠标指针在它上面时，我们不再看到“不允许”的光标。</p><p id="78f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以将<br/><code class="fe mu mv mw mx b">pointer-events</code>声明移动到<code class="fe mu mv mw mx b">:active</code>伪类，这样鼠标交互只会在我们实际点击按钮时被阻止，而不会在我们悬停鼠标时被阻止。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="dc60" class="nc ly it mx b gy nd ne l nf ng">form:invalid [type="submit"] {<br/>  background-color: var(--grey);<br/>  cursor: cursor: not-allowed;<br/>}</span><span id="ee1b" class="nc ly it mx b gy oe ne l nf ng">form:invalid [type="submit"]:active {<br/>  pointer-events: none;<br/>}</span></pre><p id="79de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做到这一切很好，但请记住，预期的用户体验可能不是这样。您可能仍然希望允许用户单击提交按钮来查看由浏览器或其他各种原因生成的验证错误。</p><h1 id="1406" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">提交表单</h1><p id="f40d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">那么当我们按下提交按钮时会发生什么呢？我们的价值观从何而来？</p><p id="f645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一切正常时，表单有效，提交按钮被按下，然后浏览器将初始化一个GET HTTP请求，并将您在表单中输入的值作为查询字符串附加到URL的末尾。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4566" class="nc ly it mx b gy nd ne l nf ng"><a class="ae ky" href="https://www.yourwebsite.com/?email=mate%40gmail." rel="noopener ugc nofollow" target="_blank">https://www.yourwebsite.com/?email=mate%40gmail.</a> com&amp;score=78&amp;marketing=on</span></pre><p id="a973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的命名约定不是随机的:查询字符串中的email、score和marketing来自输入字段的name属性，等号后面的值是用户输入的值。</p><p id="094c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不更改任何设置，所有这些都将默认发生。但是该表单允许您更改提交表单的URL，以及提交时浏览器应该使用的HTTP方法:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="721a" class="nc ly it mx b gy nd ne l nf ng">&lt;form action="login-api/" method="get"&gt;<br/>  &lt;!-- your form --&gt;<br/>&lt;/form&gt;</span></pre><p id="c59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mu mv mw mx b">login-api/</code>添加到action属性将会更新表单提交到的URL:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a711" class="nc ly it mx b gy nd ne l nf ng"><a class="ae ky" href="https://www.yourwebsite.com/login-api/?email=mate%40gmail." rel="noopener ugc nofollow" target="_blank">https://www.yourwebsite.com/login-api/?email=mate%40gmail.</a> com&amp;score=78&amp;marketing=on</span></pre><p id="d174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您的web应用程序的前端就完成了！现在由后端和您的服务器应用程序来处理发送到<code class="fe mu mv mw mx b">/login-api</code>端点的输入查询字符串数据。</p><p id="06c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">action属性也可以指向另一个HTML文件。然后，这个文档可以让JavaScript应用程序读取并处理提交的查询字符串数据。</p><p id="3df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP方法默认设置为“get ”,所以我们没有通过显式声明它来改变行为。但是，您可以将此设置更改为“post”方法，这将稍微改变行为。</p><p id="9300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">post方法发送用户在请求正文中输入的表单数据，表单数据不会附加到URL。这也意味着不可能直接从JavaScript中检索数据，因此数据处理必须在服务器上进行，这使得这种方法成为敏感数据的推荐方法。</p><p id="2c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论这些的原因是为了理解这样一个事实，即验证表单值并提交给服务器进行处理根本不需要JavaScript。我们可以用简单的HTML处理所有这些基本任务！</p></div></div>    
</body>
</html>