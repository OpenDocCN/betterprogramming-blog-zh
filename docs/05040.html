<html>
<head>
<title>What Is DangerouslySetInnerHTML?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是DangerouslySetInnerHTML？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-dangerouslysetinnerhtml-6d6a98cbc187?source=collection_archive---------0-----------------------#2020-06-03">https://betterprogramming.pub/what-is-dangerouslysetinnerhtml-6d6a98cbc187?source=collection_archive---------0-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5eea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">真的有那么危险吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d16765dce272634d1e1c8fb23ceecbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOXGcnp7tijvykETkkBxhw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.flickr.com/photos/wocintechchat/" rel="noopener ugc nofollow" target="_blank"> WOCinTech Chat </a>在<a class="ae ky" href="https://www.flickr.com/photos/wocintechchat/25926572291/in/photostream/" rel="noopener ugc nofollow" target="_blank"> Flickr </a>上拍摄</p></figure><p id="819e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论什么是<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>，它是如何使用的，<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>和<code class="fe lv lw lx ly b">innerHTML</code>之间的区别，以及一个它被证明有用的真实项目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6324" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么？</h1><p id="dc9d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>是React中DOM元素下的一个属性。</p><p id="b776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据官方文档，<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>是React对浏览器DOM中使用<code class="fe lv lw lx ly b">innerHTML</code>的替代。</p><p id="f8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果在React中，您必须以编程方式或从外部源设置HTML，您将必须使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>而不是Javascript中的传统<code class="fe lv lw lx ly b">innerHTML</code>。</p><p id="3183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>，可以直接从React设置HTML。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4f55" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">怎么会？</h1><p id="2acd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们来看看<code class="fe lv lw lx ly b">innerHTML </code>是如何工作的。(<a class="ae ky" href="https://codepen.io/lelouchb/pen/MWaMYde" rel="noopener ugc nofollow" target="_blank">https://codepen.io/lelouchb/pen/MWaMYde</a>)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">innerHTML</p></figure><p id="e53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Javascript代码:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="16ed" class="nj mh it ly b gy nk nl l nm nn">let root = document.querySelector('#root')<br/>root.innerHTML = `&lt;h1&gt;This text is set using innerHTML&lt;/h1&gt;`</span></pre><p id="69e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">innerHTML</code>很简单。您只需在DOM元素中使用点符号，并使用引号或模板文字传递HTML字符串。</p><p id="440b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>实现同样的效果。(<a class="ae ky" href="https://codepen.io/lelouchb/pen/PoPrqEw" rel="noopener ugc nofollow" target="_blank">https://codepen.io/lelouchb/pen/PoPrqEw</a>)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code></p></figure><p id="12db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="a72a" class="nj mh it ly b gy nk nl l nm nn">function App(){<br/>return(<br/>&lt;div dangerouslySetInnerHTML={{ __html: `This text is set using dangerouslySetInnerHTML` }}&gt;<br/>  <br/>  &lt;/div&gt;)<br/>  }</span><span id="2b9f" class="nj mh it ly b gy no nl l nm nn">ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</span></pre><p id="5d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>时，您必须用<code class="fe lv lw lx ly b">__html</code>键传递一个对象。(注意，该键由两个下划线组成)。对象<code class="fe lv lw lx ly b">dangerouslySetInnerHTML </code>可以通过不同的方法传递。</p><p id="823c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个变量:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="fdab" class="nj mh it ly b gy nk nl l nm nn">function App(){<br/>  const markup={ __html: 'This text is set using dangerouslySetInnerHTML'}<br/>return(<br/>&lt;div dangerouslySetInnerHTML={markup}&gt;<br/>  <br/>  &lt;/div&gt;)<br/>  }<br/>ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</span></pre><p id="44e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一项功能:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="ffe6" class="nj mh it ly b gy nk nl l nm nn">function App(){<br/>  const markup=()=&gt;{return{ __html: 'This text is set using dangerouslySetInnerHTML'}}<br/>return(<br/>&lt;div dangerouslySetInnerHTML={markup()}&gt;<br/>  <br/>  &lt;/div&gt;)<br/>  }<br/>ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="60ad" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">差异</h1><p id="143b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">innerHTML</code>和<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>的直接效果是一样的:DOM节点将使用注入的HTML进行更新。然而，在幕后，当您使用它时，它让React知道组件内部的HTML不是它所关心的。</p><p id="18e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为React使用虚拟DOM，所以当它比较实际DOM的差异时，它可以直接绕过检查该节点的子节点，因为它知道HTML来自另一个源。因此性能会有所提高。</p><p id="e25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，如果简单地使用<code class="fe lv lw lx ly b">innerHTML</code>，React没有办法知道DOM节点已经被修改。下次调用<code class="fe lv lw lx ly b">render</code>函数时，React将用它认为DOM节点的正确状态来覆盖手动注入的内容。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8f3b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么危险？</h1><p id="8dec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对<code class="fe lv lw lx ly b">innerHTML</code>的不当使用会让您面临<a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS) </a>攻击。prop名称<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>被有意选择为吓人的，prop值(一个对象而不是一个字符串)可以用来表示清理过的数据。在将HTML插入页面之前，您需要确保它的结构正确，并且经过净化。您可以使用像<a class="ae ky" href="https://www.npmjs.com/package/dompurify" rel="noopener ugc nofollow" target="_blank"> dompurify </a>这样的库来实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="77ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么时候？</h1><p id="cd5a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">适当的名字被有意地选择是令人害怕的，所以它应该在什么时候被使用？让我们讨论一个现实生活中的React项目<strong class="lb iu"> <em class="np"> </em> </strong>，其中开发者将不得不使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>。</p><h2 id="6b08" class="nj mh it bd mi nq nr dn mm ns nt dp mq li nu nv ms lm nw nx mu lq ny nz mw oa bi translated"><a class="ae ky" href="https://github.com/HackerNews/API" rel="noopener ugc nofollow" target="_blank">黑客新闻API </a></h2><p id="b9ba" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用HackerNews API制作的项目非常常见，制作简单，也很有趣，但其中的大多数API请求都是针对<code class="fe lv lw lx ly b">topstories</code>、<code class="fe lv lw lx ly b">beststories</code>等项目的id。下面是<code class="fe lv lw lx ly b">topstories</code>其中一项的响应JSON数据:</p><p id="d76f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://hacker-news.firebaseio.com/v0/item/23331287.json?print=pretty" rel="noopener ugc nofollow" target="_blank">https://hacker-news.firebaseio.com/v0/item/23331287.json?打印=漂亮</a></p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="7b3b" class="nj mh it ly b gy nk nl l nm nn">{<br/>  "by" : "lostmsu",<br/>  "descendants" : 251,<br/>  "id" : 23331287,<br/>  "kids" : [ 23332582, 23333565, 23332777, 23334075, 23331976, 23332122, 23332664, 23332047, 23333745, 23332119, 23332909, 23332118, 23332674, 23333572, 23334374, 23331882, 23334410, 23331780, 23332176, 23331823, 23332297, 23333192, 23333690, 23334269, 23332755, 23333735, 23333025, 23331297, 23333672, 23332123, 23332298, 23332913, 23333112, 23334176, 23333814, 23333849, 23334245, 23333261, 23332823, 23332079, 23331890, 23332360, 23332197, 23332840 ],<br/>  "score" : 844,<br/>  "time" : 1590620950,<br/>  "title" : "The Day AppGet Died",<br/>  "type" : "story",<br/>  "url" : "https://keivan.io/the-day-appget-died/"<br/>}</span></pre><p id="da68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对<code class="fe lv lw lx ly b">askstories</code>中条目的请求返回了一些有趣的东西。让我们来看看吧。</p><p id="1a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://hacker-news.firebaseio.com/v0/item/23325385.json?print=pretty" rel="noopener ugc nofollow" target="_blank">https://hacker-news.firebaseio.com/v0/item/23325385.json?print=pretty </a></p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="c527" class="nj mh it ly b gy nk nl l nm nn">{<br/>  "by" : "behnamoh",<br/>  "descendants" : 3,<br/>  "id" : 23325385,<br/>  "kids" : [ 23326663, 23326382, 23325618 ],<br/>  "score" : 1,<br/>  "<strong class="ly iu">text</strong>" : "As a heavy user, I basically <strong class="ly iu">&lt;i&gt;live&lt;/i&gt; </strong>in my browser. However, extensions do slow down the browser, which makes me think there&amp;#x27;s gotta be a better way. I believe it&amp;#x27;s high time we had an operating system which is fully optimized as a browser. Extensions then, would be apps on the OS, and probably won&amp;#x27;t slow it down. Have you seen any OS that is browser-first?",<br/>  "time" : 1590595712,<br/>  "title" : "Ask HN: Can operating systems be browsers?",<br/>  "type" : "story"<br/>}</span></pre><p id="dd3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe lv lw lx ly b">text</code>字段包含HTML标签&lt; i &gt; live &lt; /i &gt;，与包含字符串、数字等的其他字段相比，您不能简单地在HTML中显示它们。这只是一个例子。有包含许多HTML标签的响应数据。</p><p id="3874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>的实际用例，上面讨论的响应使用<code class="fe lv lw lx ly b">dangerouslySetInnerHTML</code>呈现在HTML中。</p><p id="c4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>