<html>
<head>
<title>Dissecting Rust Traits to Learn Their Secrets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解剖铁锈特征以了解它们的秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dissecting-rust-traits-to-learn-their-secrets-839845d3d71e?source=collection_archive---------1-----------------------#2022-07-29">https://betterprogramming.pub/dissecting-rust-traits-to-learn-their-secrets-839845d3d71e?source=collection_archive---------1-----------------------#2022-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="63cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们将分解Add trait，以了解它如何实现所有的trait工具来提供所有的灵活性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3e936c8cce6eca95659462366b20d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPMxnv_7RA9T_iIB1-5PTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">剖析特征</p></figure><p id="dd2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特征是Rust中最有趣的特征之一。对于任何编程语言来说，这都是一个令人难以置信的基本操作，但它有一点我们可以在<strong class="la iu"> traits </strong>中找到的一切，甚至是运算符重载，所以这是一个令人难以置信的例子，可以学习如何将traits的工具拼凑在一起，以提供一个完美绑定的功能，从而提供惊人的灵活性。<strong class="la iu">我们来看看</strong>。</p><h1 id="74a7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">通用的</h1><p id="8706" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">首先，我们有<code class="fe lu lv lw lx b">pub trait Add</code>，这个特征的头，它指定这个特征被命名为<code class="fe lu lv lw lx b">Add</code>，并且它是公开的，没有任何限制，所以这个特征可以在Rust项目的任何地方实现和使用。</p><p id="998a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们有<code class="fe lu lv lw lx b">Rhs</code>，这是一个通用标识符，就像常用的<code class="fe lu lv lw lx b">T</code>。在这种情况下，之所以这样命名，是因为首字母缩略词的意思是<strong class="la iu">右手边</strong>，这是一种描述性的方式，表明这种特征的一般部分是什么，这种类型我们将添加到实现<code class="fe lu lv lw lx b">Add</code>的项目中。例如，在加法运算<code class="fe lu lv lw lx b">Counter(0) + 1</code>中，RHS是右边的那个，它的类型是一个整数(i32，u8，无论什么)。</p><p id="ccb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个泛型的一个重要注意事项是，它不只是<code class="fe lu lv lw lx b">Rhs</code>而是<code class="fe lu lv lw lx b">Rhs = Self</code>。这意味着默认情况下，RHS类型将与实现特征的项目相同。因此，我们可以像这样在两个计数器之间实现加法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">看，我们是不是在impl Add中省略了泛型</p></figure><h1 id="3210" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">该功能</h1><p id="68ad" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们的下一步是trait定义的函数，我们必须实现它来允许我们的项目增加。我们看到它有两个参数:<code class="fe lu lv lw lx b">Rhs</code>类型的<code class="fe lu lv lw lx b">self</code>和<code class="fe lu lv lw lx b">rhs</code>。</p><p id="18e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这其中很重要的一点就是<strong class="la iu">我们有</strong> <code class="fe lu lv lw lx b">self</code> <strong class="la iu">而没有</strong> <code class="fe lu lv lw lx b">&amp;self</code>。这意味着如果我们实现了这个特征，我们将在执行加法时消耗这个项目。这样做是为了提供灵活性，因为如果我们希望它被消费，我们可以为<code class="fe lu lv lw lx b">Counter</code>实现<code class="fe lu lv lw lx b">Add</code>;如果我们希望它在添加后继续存在，我们可以为<code class="fe lu lv lw lx b">&amp;Counter</code>实现<code class="fe lu lv lw lx b">Add</code>;如果我们希望允许这两种行为，我们可以为两者都实现<code class="fe lu lv lw lx b">Add</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为&amp;Counter实现Add <self>，这不会消耗计数器</self></p></figure><p id="24f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，函数的最后一部分是它的返回类型，我们可以看到它是<code class="fe lu lv lw lx b">Self::Output</code>。让我们看看那是什么。</p><h1 id="2bbd" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">关联的类型</h1><p id="6e01" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">最后，<code class="fe lu lv lw lx b">Output</code>是trait的一部分，它给了我们最后的额外灵活性，它就像是trait的第二个泛型，定义了从加法中返回的类型。</p><p id="4c91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这种方式，你可以从一个加法中输出一个不同于运算中所用的两个东西中的任何一个。在上面的两个例子中，我们返回计数器，但是也可以返回我们想要的任何值，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数器+ i16返回一个i32</p></figure><p id="70fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你一定想知道为什么要这样实现。我们用一个通称来定义输出图像，例如:<code class="fe lu lv lw lx b">trait Add&lt;Rhs, Output&gt;</code>。有了这个签名，我们可以制作<code class="fe lu lv lw lx b">impl Add&lt;i32, Counter&gt; for Counter</code>和<code class="fe lu lv lw lx b">impl Add&lt;i32, i32&gt; for Counter</code>。这将导致冲突，因为同一个<code class="fe lu lv lw lx b">Counter(2) + 4</code>可能返回两个不同的东西。</p><h1 id="bd48" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">包扎</h1><p id="acea" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们已经看到了标准库中最常用的特征之一，以及它如何使用组件来实现我们希望从加法这样的操作中获得的灵活性。一个很好的工具实现，让我们定义或实现具有很多通用性的trait。有了这些:</p><ul class=""><li id="10f5" class="mx my it la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">我们可以在所有权或借贷上实现特征。</li><li id="114b" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">我们可以使用泛型来处理不同类型的项目。</li><li id="2cdb" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">我们可以为这些泛型指定默认值，以节省代码和时间。</li><li id="fe30" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">我们可以指定我们选择返回或使用的额外类型。</li><li id="d619" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">我们可以做这样疯狂的事情:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相加&amp;Counter和i32会使as so失败，返回结果<i32 string=""/></p></figure><p id="aeb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一点，像往常一样，这里是带有工作示例的存储库:</p><div class="nl nm gp gr nn no"><a href="https://github.com/kriogenia/medium/tree/main/add_trait" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">中等/主要克里金属的附加性状/中等</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">存放我的Medium帖子中使用的示例的存储库- medium/add_trait位于main kriogenia/medium</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.co</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div></div></div>    
</body>
</html>