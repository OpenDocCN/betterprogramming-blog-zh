<html>
<head>
<title>Use the Little-Known Classmethod Decorator to Add Constructors to Your Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用鲜为人知的Classmethod Decorator向类中添加构造函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-the-little-known-classmethod-decorator-to-add-constructors-to-your-classes-464e96d8fe86?source=collection_archive---------6-----------------------#2019-09-05">https://betterprogramming.pub/use-the-little-known-classmethod-decorator-to-add-constructors-to-your-classes-464e96d8fe86?source=collection_archive---------6-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3eab" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">改进您的Python</h2><div class=""/><div class=""><h2 id="2b49" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习一些关于类方法装饰器、类和继承的有用知识</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/478e8757787329b8468b2687b535613f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIVVrJJ8IVpoIRlAAzxrGA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@dnevozhai?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae lh" href="https://unsplash.com/search/photos/giving-down?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2aa9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">装饰器、类和继承是相当高级的概念。大多数时候，有另一种方法来解决一个给定的问题，并且很可能你还没有给decorators或类太多的考虑，更不用说继承了。理应如此。你没必要这么做。</p><p id="0a6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，当你在成为更好的程序员的旅程中前进时，你开始在这里和那里遇到类。</p><p id="e88a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着您越来越关注代码的可读性和可维护性，而不是“我只是想让它工作”这一部分，类就成了您的武器库中不可或缺的工具。</p><p id="2e74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个故事中，我想展示一个典型的类用例，尤其是<code class="fe me mf mg mh b">@classmethod</code>装饰器。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="65ba" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">Python中的类简介</h1><h2 id="5993" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">类别定义</h2><p id="6c80" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">虽然Python当然可以，而且经常被用作脚本语言，但它是作为面向对象的编程语言而设计的。</p><p id="9ea7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">面向对象编程(OOP)意味着程序具有围绕数据或对象而不是功能和逻辑来组织的强烈倾向。</p><p id="360e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这通常意味着一个类代表了一些更有形的东西背后的思想或概念，比如一个合理地特定于您的业务的实际对象。</p><p id="a6aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，当使用谷歌广告时，一个课程可以是一个活动。当使用市场时，一个类可以是一个参与者。使用教育应用程序时，班级可以是学生、教师或教室。</p><h2 id="9dd1" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">对象实例化</h2><p id="70ad" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">类通常定义一个<code class="fe me mf mg mh b">__init__</code>函数，当调用它时，实例化一个对象。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="1458" class="nh mq it mh b gy ob oc l od oe"><strong class="mh jd">IN:</strong><br/>class Car():<br/>    def __init__(self,make,year):<br/>        self.make = make<br/>        self.year = year</span><span id="3391" class="nh mq it mh b gy of oc l od oe">my_car = Car('Honda',1984)</span><span id="ef54" class="nh mq it mh b gy of oc l od oe">print(my_car.make)</span><span id="551e" class="nh mq it mh b gy of oc l od oe"><strong class="mh jd">OUT:</strong> <br/>'Honda'</span></pre><p id="5d93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个对象(<code class="fe me mf mg mh b">my_car</code>)是一个实例化的类(<code class="fe me mf mg mh b">Car</code>)，实际上对于一个给定类可以实例化多少个对象没有限制。例如，你可以实例化更多的汽车，比如<code class="fe me mf mg mh b">your_car = Car('BMW', 2017)</code>。一个类就像一个蓝图或者一个模式，一个对象就是一个真实的东西。</p><h2 id="8148" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">实例方法</h2><p id="2687" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在您有了一个对象，在这一点上它只不过是一个数据容器。现在，您可以在类上定义每个实例化的对象都可以访问的函数(方法)，如下所示:</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="26c6" class="nh mq it mh b gy ob oc l od oe"><strong class="mh jd">IN:</strong><br/>class Car():<br/>    def __init__(self,make,year):<br/>        self.make = make<br/>        self.year = year<br/>        self.status = 'dirty'</span><span id="b898" class="nh mq it mh b gy of oc l od oe">def clean_car(self):<br/>        print('cleaning the car!')<br/>        self.status = 'clean'</span><span id="87b0" class="nh mq it mh b gy of oc l od oe">my_car = Car('Honda',1984)</span><span id="5174" class="nh mq it mh b gy of oc l od oe">print(f'The car is : {my_car.status}')<br/>my_car.clean_car()<br/>print(f'The car is : {my_car.status}')</span><span id="3514" class="nh mq it mh b gy of oc l od oe"><strong class="mh jd">OUT:</strong> <br/>The car is : dirty<br/>cleaning the car!<br/>The car is : clean</span></pre><p id="9e15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如<code class="fe me mf mg mh b">__init__</code>中设定的那样，每辆车一开始都很脏。但是这不是问题，因为我们已经定义了一个<code class="fe me mf mg mh b">clean_car()</code>方法，它清洗汽车。</p><h2 id="2e5d" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">遗产</h2><p id="c2d9" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在下面的例子中，我们将利用一个叫做继承的概念。像几乎所有面向对象语言一样，Python中的类可以被子类化。</p><p id="5ec9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">能够子类化意味着你可以将原始类的通用逻辑和一些特定的逻辑添加到子类中。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="00ff" class="nh mq it mh b gy ob oc l od oe"><strong class="mh jd">IN:</strong><br/>class Person(object):<br/>    def __init__(self,first_name,last_name):<br/>        self.first_name = first_name<br/>        self.last_name = last_name</span><span id="0d27" class="nh mq it mh b gy of oc l od oe">class Teacher(Person):<br/>    def __init__(self,first_name,last_name,grade):<br/>        self.grade = grade<br/>        super(Teacher, self).__init__(first_name,last_name)</span><span id="364a" class="nh mq it mh b gy of oc l od oe">mr_smith = Teacher('Joe','Smith',4)<br/>print(mr_smith.first_name)<br/>print(mr_smith.grade)</span><span id="daca" class="nh mq it mh b gy of oc l od oe"><strong class="mh jd">OUT:<br/></strong>Joe<br/>4</span></pre><p id="feb5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的逻辑中，<code class="fe me mf mg mh b">Teacher</code>类用老师教的年级扩展了<code class="fe me mf mg mh b">Person</code>类。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6940" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">更高级的例子</h1><h2 id="b8b5" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">设置</h2><p id="9f5b" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在下面的代码片段中，我们设置了一个伪数据库和一个读写方法。</p><p id="54f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，您可能在自己选择的数据库之上有一些抽象层。但是逻辑，即通过ID的存储、读取和写入逻辑，可能是相似的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="627f" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">示例:基类</h2><p id="8021" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先，我们创建一个基类。当看到<code class="fe me mf mg mh b">__init__</code>方法时，我们的基类不应该被实例化的事实变得很明显。</p><p id="8f07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个类的实例化只会产生一个带有<code class="fe me mf mg mh b"> _id</code>的对象，其他什么都没有。虽然你可以做，但这没有用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5883" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们一步一步地了解它的功能:</p><ul class=""><li id="eda3" class="oi oj it lk b ll lm lo lp lr ok lv ol lz om md on oo op oq bi translated"><code class="fe me mf mg mh b">__init__</code>为<code class="fe me mf mg mh b">self._id</code>分配一个传递的<code class="fe me mf mg mh b">_id</code>值或随机生成的值。</li><li id="a7d6" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">@classmethod</code> <code class="fe me mf mg mh b">_instanciate_from_db</code>需要两个自变量，1。<code class="fe me mf mg mh b">cls</code>(类的简称)和2。安<code class="fe me mf mg mh b">_id</code>。然后，它根据给定的ID从<code class="fe me mf mg mh b">cls._table</code>获取一条记录，解包并将其传递回类。在基类上定义<code class="fe me mf mg mh b">_table</code>是没有意义的，因为这将告诉我们在哪个表中寻找<code class="fe me mf mg mh b">_id</code>。因为对应于我们的派生类的实例的数据库对象将驻留在不同的表中，所以有必要在派生类而不是基类上实现<code class="fe me mf mg mh b">_table</code>。</li><li id="559c" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">to_dict</code>以字典形式返回不以<code class="fe me mf mg mh b">_</code>开头的类的属性。</li><li id="f12a" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">__repr__</code>调用<code class="fe me mf mg mh b">to_dict</code>并通过<code class="fe me mf mg mh b">json.dumps</code>将其序列化。</li></ul><h2 id="f589" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">示例:子类</h2><p id="6962" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我们有两个，来自<code class="fe me mf mg mh b">Base</code>，派生类，<code class="fe me mf mg mh b">Student</code>和<code class="fe me mf mg mh b">ClassRoom</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="40d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个派生类都定义了<code class="fe me mf mg mh b">_table</code>和一个<code class="fe me mf mg mh b">__init__</code>方法。两者都调用super(即，在它们的init方法中基类上的<code class="fe me mf mg mh b">__init__</code>方法)。</p><h2 id="bf2a" class="nh mq it bd mr ni nj dn mv nk nl dp mz lr nm nn nb lv no np nd lz nq nr nf iz bi translated">示例:将所有内容放在一起</h2><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="71ac" class="nh mq it mh b gy ob oc l od oe"><strong class="mh jd">IN:</strong><br/>print(Student(name='Charly',age=16))<br/>print(Student._instanciate_from_db(_id='1234'))</span><span id="65e0" class="nh mq it mh b gy of oc l od oe">print(ClassRoom(floor=13,seats=30))<br/>print(ClassRoom._instanciate_from_db(_id='abcd'))</span><span id="591b" class="nh mq it mh b gy of oc l od oe"><strong class="mh jd">OUT:<br/></strong>{"age": 16, "name": "Charly"}<br/>{"age": 15, "name": "John Doe"}<br/>{"floor": 13, "seats": 30}<br/>{"floor": 10, "seats": 15}</span></pre><p id="2e0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以在<code class="fe me mf mg mh b">Student</code>和<code class="fe me mf mg mh b">ClassRoom</code>对象上使用<code class="fe me mf mg mh b">_instanciate_from_db</code>方法。两者都从基类继承方法。</p><p id="dae8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于我们使用了<code class="fe me mf mg mh b">@classmethod</code> decorator，该方法可以访问类对象，因此可以使用我们在派生类中定义的<code class="fe me mf mg mh b">_table</code>来指定我们想要在哪个表中查找ID。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1094" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">值得注意的观察</h1><ul class=""><li id="bdac" class="oi oj it lk b ll ns lo nt lr ow lv ox lz oy md on oo op oq bi translated">虽然方法<code class="fe me mf mg mh b">_instanciate_from_db</code>是在基类中定义的，并且引用了一个<code class="fe me mf mg mh b">cls</code>，但是当在派生类中调用时，它引用的是被调用方法的派生类，而不是基类。</li><li id="a0ad" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">@classmethod</code>装饰器导致类(相对于实际的对象)被传递给函数。</li><li id="12c4" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">@classmethod</code>装饰器是实现额外构造函数的完美方式。</li></ul></div></div>    
</body>
</html>