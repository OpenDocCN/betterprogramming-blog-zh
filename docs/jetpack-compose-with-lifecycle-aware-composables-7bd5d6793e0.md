# Jetpack 由生命周期感知组件组成

> 原文：<https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0>

## 可组合和视图生命周期之间的桥梁

![](img/e1572b2c3e3dad30b258bfc1f890e498.png)

由 [Zakaria Ahada](https://unsplash.com/@zakariahada?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

如果你有 Android 背景，你应该熟悉生命周期的概念。Jetpack Compose 引入了一种新的范式来使用组件构建声明性 UI。它们具有简化的生命周期，包括三个阶段:

*   进入阶段。
*   重组阶段。
*   退出阶段。

官方文档详细描述了一个可组合组件在其整个生命周期中的行为。

现在，您可能会认为可组合组件的生命周期取代了视图的生命周期。尽管命名是一致的，但我们谈论的是两个不同的概念。

例如，即使您构建了一个纯粹的组合应用程序，您的组合可能需要与视图的生命周期进行交互。如果当应用程序出现在前台时，您有一个刷新一些数据的可组合组件，就会出现这种情况。

然而，可组合组件对视图的生命周期一无所知。你需要在这两个世界之间架起一座桥梁，将这种意识带给你的组件。

# 恢复的可组合用例

让我们假设我们正在构建一个纯 Compose 应用程序。包括一个可组合的屏幕。这个屏幕注入一个视图模型——例如通过 Hilt 来获取产品。我们会有下面的代码:

ViewModel 在创建时启动一个协程，并将获取操作委托给存储库。

现在，我们想在用户每次显示此屏幕时刷新我们的产品。当用户进入后台并重新进入前台时会发生这种情况——前提是系统没有关闭应用程序。或者，如果您想导航到不同的屏幕，则导航回`ProductsScreen`。

您很快就会意识到我们的示例代码不能满足我们的需求。提取仅在可组合文件第一次出现时有效。这是因为当可组合组件退出组合树时，ViewModel 取消了协程，但是当重新进入组合阶段时，ViewModel 不会重新启动它。

一种解决方案是依靠可组合组件的进入阶段来获取您的产品。您可以从 ViewModel 中公开 fetch 方法，并从 Composable 中调用它。记住使用副作用调用这个方法。否则，您将不仅在可组合对象变得可见时获取您的产品，而且在它的状态将改变的每次重组时获取您的产品！

如果您想在可组合组件进入其组合阶段时调用它一次，您可以使用一个`LaunchEffect`和`Unit`作为键——或`true`,只要它在组合期间不改变。

不过，我们还没有检查所有的方框。使用进入阶段将帮助我们在导航回此屏幕时更新我们的产品。当用户将应用程序放在后台时，情况就不一样了。

区分 Composable 和 View 的生命周期是如何工作的很重要。但是理解你可以把它们结合起来也是很有价值的。

# 将视图的生命周期带入一个组合世界

在纯 Compose 应用程序中，您必须创建一个活动作为入口点。我们可以依靠它来获取视图的生命周期，并将其传递给我们的可组合组件。

但是将一些事件从持有活动传递到可组合活动变得很乏味。尤其是当你有几个父母的时候。幸运的是，我们可以直接让任何组件感知生命周期。

如果你不熟悉 Android 中的生命周期感知组件，我已经在本文的[中介绍了一个类似的用例。](/empowered-lifecycle-aware-viewmodel-for-android-f495de9a8170)

类似的配置适用于 Jetpack Compose。但是有一种更聪明、更“像作曲”的方式来实现它。每个可组合组件公开了当前的生命周期所有者，您可以在其中检索视图的生命周期。使用一个`DisposableEffect`副作用，您可以存储视图生命周期的最新事件并对其做出反应，同时在可组合组件退出组合树时安全地分离其观察者。

如果更多的组件能够感知生命周期，那么所有这些都会很快变成样板文件。我们可以编写一个可组合的扩展方法:

有了这种配置，您可以用几行额外的代码对视图的生命周期做出反应。

# Jetpack 合成的生命周期感知视图模型

在之前链接的文章中，我提到了 ViewModel 在应用程序可伸缩性中的重要作用。尤其是当一些业务逻辑与视图的生命周期紧密相关时。

使用 Compose 并不能免除您这样做——即使它使关注点的分离更容易。

使用上面的解决方案，视图仍然负责对生命周期事件做出反应，并请求获取视图模型。理想情况下，ViewModel 应该负责这个问题。

使用相同的技术，我们创建另一个可组合的扩展方法，让任何`LifecycleOwner`观察视图的生命周期。然后，我们让 ViewModel 实现`DefaultLifecycleObserver`接口。我们可以将所有的逻辑移到视图模型中！

# 包扎

我们已经看到，对于一个简单的用例，仅仅依靠可组合组件的生命周期是不够的。使用生命周期感知组件库和一个`DisposableEffect`，您可以将生命周期事件转移到视图模型。

此外，与我之前的文章相比，测试过程保持不变。这意味着我们可以保持生命周期感知的视图模型逻辑，不管它是由视图还是可组合的组件注入的。只有生命周期绑定有所不同——用扩展方法组合更简单！

我希望这将有助于您在迁移到 Jetpack Compose 的过程中减轻对代码的影响。编码快乐！