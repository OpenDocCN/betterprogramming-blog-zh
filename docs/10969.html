<html>
<head>
<title>When to and When Not to Use Enums in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中什么时候使用枚举，什么时候不使用枚举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-to-and-when-not-to-use-enums-in-java-8d6fb17ba978?source=collection_archive---------3-----------------------#2022-02-08">https://betterprogramming.pub/when-to-and-when-not-to-use-enums-in-java-8d6fb17ba978?source=collection_archive---------3-----------------------#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e17" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">枚举是一种代码气味吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/19d2a61d963a0ef0b82298d85cc9d54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpyIfQ1l_-sxXScDgXynbg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@blakeconnally" rel="noopener ugc nofollow" target="_blank">布莱克</a>在<a class="ae kv" href="https://unsplash.com/photos/B3l0g6HLxr8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="6b49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多人认为枚举是代码味道，是OOPs中的反模式。某些书也引用枚举作为代码气味，如下所示。</p><p id="01c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">警告根据经验，枚举是代码的味道，应该被重构为多态类依赖注入。马克·西曼</p><p id="0860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，枚举闻起来是因为它经常被滥用，但这并不意味着你必须避免它们。如果使用得当，枚举可以成为你武器库中的强大工具。在这篇文章中，我想简单回顾一下什么时候应该使用枚举，什么时候不应该使用枚举。</p><h1 id="fcb0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">枚举的快速复习</h1><p id="cd89" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">枚举通常用于表示一组常数。它们是使用enum关键字创建的，常量之间用逗号分隔。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="83e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">枚举通常在switch语句中用于检查相应的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="6e6a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">枚举就是字符串列表，对吗？</h1><p id="e068" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">枚举通常被认为是字符串常量:命名的值，可以在以后赋值和识别。但这并不是故事的全部，如果你就此打住，你只是浏览了表面。</p><p id="b1c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">枚举实际上是作为类实现的，枚举值是它们的实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">枚举“房屋”的类表示</p></figure><p id="6c4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着枚举可以像任何其他类一样拥有属性和方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例摘自<a class="ae kv" href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/Java/javaOO/enum . html</a></p></figure><p id="49f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的enum类都继承了Java标准类<em class="ls"> java.lang.Enum </em>，它们从这个类继承了一些潜在有用的方法。</p><p id="d9af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该知道的继承方法有<code class="fe ms mt mu mv b">name()</code>、<code class="fe ms mt mu mv b">ordinal()</code>和静态方法<code class="fe ms mt mu mv b">values()</code>。</p><p id="c953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">name()</code>方法返回与枚举值中定义的名称完全相同的名称。<code class="fe ms mt mu mv b">ordinal()</code>方法返回一个数值，它反映了枚举的声明顺序，从零开始。举个例子，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">values()方法通常更有用。它返回一个包含所有枚举值的数组，并可用于遍历这些值。这里有一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="03be" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">何时以及为何使用枚举:</h1><p id="28ce" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">虽然枚举不仅仅是一个字符串列表，但枚举最常见的用例是表示一个常量列表。但是我们为什么需要枚举呢？为什么不能用简单的字符串数组？</p><p id="7ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们举个例子。假设你正在用下面的一组输入命令构建一个游戏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c131" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的程序中会有代码对这些命令做出反应，然后调用正确的方法来执行它们。在下面的代码片段中，我假设字符串变量<code class="fe ms mt mu mv b">commandWord</code>保存键入的单词:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b4b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案有什么问题？确实有两个基本问题立即凸显出来:类型安全和全球化。</p><h2 id="727c" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated"><strong class="ak">类型安全</strong></h2><p id="0216" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在开关盒中，字母P是“Pass”中的大写字母，编译器无法检测到这一点。</p><p id="cb03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们使用枚举重写相同的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="563e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在此处错误地键入了case标签或赋值，编译器会检测到并通知您。</p><h2 id="c294" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated"><strong class="ak">全球化</strong></h2><p id="a2bb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你决定将程序翻译成不同的语言(假设移动命令现在是移动)，这将导致错误。如果你只是改变数组中的命令字，程序会编译，但是功能会中断。</p><h1 id="4cc3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">enum什么时候是代码味？</h1><h2 id="bf86" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated">枚举迫使你使用多个开关的情况</h2><p id="1013" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">枚举被认为是代码味道的一个主要原因是它们诱使你在代码中散布switch语句。这有什么问题呢？</p><p id="e78c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这个场景</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">干净代码的例子:敏捷软件工艺手册(罗伯特·c·马丁)</p></figure><p id="7b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些明显的问题。它违反了多个OOP最佳实践:</p><ul class=""><li id="a187" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">当添加新的雇员类型时，函数会增长，可读性会降低。</li><li id="1474" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">它违反了<a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener ugc nofollow" target="_blank">单一责任原则</a> (SRP)，因为它改变的原因不止一个。</li><li id="a28d" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">它违反了<a class="ae kv" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle#:~:text=In%20object%2Doriented%20programming%2C%20the,without%20modifying%20its%20source%20code." rel="noopener ugc nofollow" target="_blank">开闭原则</a> (OCP)，因为每当添加新类型时，它都必须改变。</li><li id="d4a6" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">类似于这个函数，将会有无限数量的其他函数具有相同的结构。isPayday(员工e，日期日期)或deliverPay(员工e，金钱支付)或许多其他的。向枚举添加额外的值意味着在代码中找到该类型的每一次使用，并且可能需要为新值添加新的分支。</li></ul><p id="52c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我们不能总是避免switch语句，但是我们<em class="ls">可以</em>确保每个switch语句都被隐藏在一个低级类中。</p><p id="af08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Robert C. Martin在Clean code: <em class="ls">中提出的“ONE SWITCH”规则，对于给定的选择类型，可能只有一个SWITCH语句。该switch语句中的案例必须创建多态对象，以取代系统其余部分中的其他此类switch语句。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">干净代码的例子:敏捷软件工艺手册(罗伯特·c·马丁)</p></figure><p id="82c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，添加一个新类型仅仅意味着创建一个实现接口的新类——更改集中在一个地方，更容易进行。</p><blockquote class="nw nx ny"><p id="500b" class="kw kx ls ky b kz la jr lb lc ld ju le nz lg lh li oa lk ll lm ob lo lp lq lr ij bi translated">注意:如果你已经有了一个类层次结构，这个技术就不能应用了。在面向对象编程中，不能通过继承来创建双重层次。但是你可以使用这里提到的另一种技术:<a class="ae kv" href="https://refactoring.guru/replace-type-code-with-state-strategy" rel="noopener ugc nofollow" target="_blank">https://refactoring . guru/replace-type-code-with-state-strategy</a></p></blockquote><h2 id="4ebc" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated"><strong class="ak">枚举导致次优建模</strong></h2><p id="dd9a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">与前一个问题类似，这也不是枚举的单独问题。不幸的是，枚举有时会导致糟糕的数据模型设计决策。</p><p id="9b2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑前面的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8ea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想要存储关于薪水的信息。“销售人员”的工资是基于佣金的，所以我们希望存储财产佣金百分比。最简单的方法是向类中添加一个新属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="63e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，该属性与“工程师”无关，因为他们没有基于佣金的工资。所以现在你有了一个与“工程师”无关的属性，这不是一个非常干净的表示数据的方式。</p><p id="341e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的设计方法是使用子类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="28bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能是显而易见的，但正如大多数显而易见的事情一样——它不是，所以我认为它值得一提。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="478d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！基本上，如果你认为你在编译时知道“某物”所有可能的值，并且可以用一个简单的值来表示，你可以把它表示为一个枚举类型。但是，当您在多个开关案例中使用这些枚举时，您应该注意了。</p><p id="b609" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，这些要点中的一些对你来说可能非常明显，或者可能碰巧有帮助。</p></div></div>    
</body>
</html>