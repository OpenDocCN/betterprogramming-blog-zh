# 代码委托:K8s 部署的声明性与命令性方法

> 原文：<https://betterprogramming.pub/delegating-with-code-declarative-vs-imperative-approach-for-k8s-deployments-dfdd3e23d5c7>

## 声明式和命令式编程方法之间的最大区别是对这个问题的回答:“它为谁服务？”

![](img/6201c71a611e0d55c685a4d0777f1889.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

声明式和命令式编程方法之间的最大区别是对这个问题的回答:“它为谁服务？”

命令式方法概述了机器需要如何做某事，为机器服务。它使自己与机器的操作模型保持一致，并告诉它需要如何做某事。

例如，假设你正在编写一个程序，从这个句子中挑选出所有的元音字母，计算一个数组中元素的和，你应该这样写:

```
int sum=Integer.MIN_VALUE;for(int i=0;i<arr.length;i++) {
    sum += arr[i];
}
```

声明式方法，声明您想要的东西，为您，开发人员服务。你告诉机器你需要什么，剩下的事情就完成了。

在这种情况下，您告诉计算机计算的逻辑，而不详细说明控制流或低级结构，如循环、if 语句、赋值等等。像这样:

```
int sum = IntStream.of(arr).sum();
```

本质上，这是一个“如何”与“什么”范式的问题。但这并不意味着一个比另一个更好。

声明式编程更容易理解，因为您可以阅读代码并理解它。它简洁、可重用，并支持引用透明性。

但是声明性的会慢一些，需要更长的时间来完成这个过程。在任务关键的实时应用中，如石油钻塔的监控或雷达处理，这可能为时已晚而无用。

另一方面，命令式方法给你更多的控制。但是，它不太可重用，因为它与编写它的上下文紧密相关。

因此，很难用命令式代码进行伸缩。根据程序员的专注和暗示程度，这种方法也容易出错。

基于需求、编程语言和开发人员的舒适程度，他们可能会选择一个或另一个来完成他们的工作。只有一种方法可以编写您的应用程序——您的方法。

但是部署是一个完全不同的游戏。部署到库伯内特，更是如此。

# 部署自动化的声明式方法

在容器化的世界里，一个开发者需要不仅仅是一个开发者。除了编程之外，他们还需要了解代码将要运行的基础设施，并使其高效运行。

部署到 Kubernetes 迫使开发人员爬上陡峭的学习曲线，爬上复杂的环境。这不是开发人员寻求的学习方式。

一个潜在的解决方案是使用以应用程序为中心的模型的部署自动化工具，它让您用自己的行话来声明您的需求，同时它为您生成必要的清单。

这个工具不是强迫你为 K8s 的操作模型编写代码，而是必须适应开发人员的心智模型并与之一起工作。

# Kubernetes 的服务部署示例

这里是您部署一个简单的服务到 K8s 所需要的一切，使用声明性的方法，使用自动化工具。

## 为您的服务命名

它将作为服务发现和与其他服务通信的 DNS 名称。

## 将它指向服务图像

*   从图像注册表中提取。
*   从源/二进制文件中生成和添加图像。
*   使用现有的 Docker 图像，如果有的话。

## 设置其他顶级指令

端口、卷、环境属性、机密等。

## 部署到 Kubernetes

部署您的规范—为您的应用程序名称指定路径、K8s 名称空间和标识符。

然后，该工具将自动创建 Kubernetes 清单、存储类、守护进程集、副本集、状态集、PVC、配置映射、活性探测、网络策略等。

这样，您只需告诉工具您需要什么，它就会负责部署，为您节省大量的时间和精力。

这就是我们的开源项目 HyScale 的目标。我们看到开发团队需要以应用为中心的 Kubernetes 抽象和自动化，以实现开发和运营之间的无缝交接。

我们特别关注用户体验，构建了一个只需要开发人员最少努力的工具，同时完成了所有的繁重工作。我们已经为开发团队提供了它——你可以[在这里](https://github.com/hyscale/hyscale)试用它。