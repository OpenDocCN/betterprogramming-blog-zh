<html>
<head>
<title>Exploring the Serverless Event-Driven Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索无服务器事件驱动架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-the-serverless-event-driven-architecture-8d6bda93e823?source=collection_archive---------13-----------------------#2022-04-01">https://betterprogramming.pub/exploring-the-serverless-event-driven-architecture-8d6bda93e823?source=collection_archive---------13-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">认识一下你的老朋友Terraform、Lambda、SQS和Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d28e728e25a4a86a4047573cd0d2fca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qaym2Q-QMNCA-tV4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂西安</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，您不希望您的最终用户在后处理事件上等待后端确认。<br/>作为一名运营人员，您不希望让超级强大的基础设施加快后端处理时间。</p><p id="082d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们深入探讨一种事件驱动的架构，它将满足您的所有需求:</p><ol class=""><li id="23c4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对最终用户的快速响应时间—例如，在一秒钟内确认提交</li><li id="5151" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">易于管理的后端，只需维护少量代码(在后台拆分您的后处理任务)</li><li id="307d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">低成本基础架构—您只需为消费的内容付费</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/248b13941398e5954bd7afb302f2f1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*yhLeAfxyZP7jucRWCsy0wA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将通过本文发现的基本事件驱动架构</p></figure><p id="a1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的模式中看到的，我们将在这里部署一个包含三个组件的超级简单的架构(我在这里不会提到Cloudwatch，我假设它是嵌入式的)。</p><p id="dd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了部署这个架构，我将使用一个平台，我不会详细解释，但仍然可以通过这个链接获得:<a class="ae ky" href="https://github.com/gmariette/medium-eda" rel="noopener ugc nofollow" target="_blank">https://github.com/gmariette/medium-eda</a>。</p><p id="be26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，除了上面提到的资源之外，该项目还创建了lambda函数使用的IAM角色(请查看IAM模块以清楚地了解将要部署的内容)—请注意，我们使用单独的角色来推送队列和读取，这是最佳实践，但是这些角色需要更加严格。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="6e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要考虑的是从最终用户接收流量的lambda。在这个例子中，我将直接从控制台调用lambda端点，但是你也可以想象配置一个API网关作为前端端点来基于URL、参数…分派你的请求，这将在下一篇文章中讨论。</p><blockquote class="mr ms mt"><p id="6628" class="kz la mu lb b lc ld ju le lf lg jx lh mv lj lk ll mw ln lo lp mx lr ls lt lu im bi translated">这里的代码非常简单，获取一个事件消息，并将其发送到SQS队列。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="306a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码可以通过直接在Lambda控制台上的test选项卡中创建一个非常基本的JSON来测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7ac0aedee6e6323c65d8c583a10aff05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVvmQLRnCIqBLcDC-I83bA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建一个基本事件来测试函数</p></figure><blockquote class="mr ms mt"><p id="3f7e" class="kz la mu lb b lc ld ju le lf lg jx lh mv lj lk ll mw ln lo lp mx lr ls lt lu im bi translated"><strong class="lb iu">代码会做什么？接收事件，对于json中包含的每一行，消息都将被发送到SQS。</strong></p></blockquote><p id="3549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码还生成日志，让您能够检查在执行过程中是否没有发生任何错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/00225919e4399fa535b88ba41c0794a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HegZrtBJgiXFsYg-raIQ9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Cloudwatch控制台上显示的日志输出</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="bf90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看SQS队列度量——这是查看队列已收到消息的一个好方法，尽管您的代码似乎工作正常，但您最好想确保您的消息通过它。</p><p id="89f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的测试用例中的一个关键指标是收到的消息的大约数量<strong class="lb iu"><em class="mu"/></strong>。在我的例子中，我在Lambda控制台上做了一个测试，结果有两条消息被发送到队列。<br/>保持相同的逻辑，我们希望我们的两个消息都被发送到我们的lambda目标函数。从SQS的角度来看，这可以通过检查发送的<strong class="lb iu"> <em class="mu">消息数量</em> </strong>度量来检查，该度量应该与第一个度量相匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/28c29df3e38de804ea100194886ab830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_DWCaILdHIktsD0FtnAaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这两个指标都匹配</p></figure><p id="0a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以直接从SQS控制台检查lambda是否被配置为触发器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/5977f45644b6f43da9171f05032138b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmoZ2qLjHdrpzrW924AY6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda触发器已配置</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="a537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当SQS接收到消息时，后处理lambda被自动触发。<br/>基本上，这个函数只是证明消息已经被我们的第二个lambda函数接收到了。</p><p id="dd92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对最近的调用进行快速检查将显示我们的第二个lambda已经被自动触发:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/602e2629524e9e79751647c8476ec4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_3KKrZLilwo3WNXGx3sZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我进行的最后两次调用将与下面的cloudwatch日志相匹配</p></figure><p id="50fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">云监控日志中也会发生同样的事情，会创建两个日志流:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a84d83a5af9d47ed8a0abcca390fa099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyzyhnOWglt3OM53hPDQWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个调用一个日志流</p></figure><p id="b22d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个日志细节，我们概念的最终证明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2748422e63bcc7d6456909fe4aca3365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDp-pcoG2qSfibdWJtmZOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们的lambda分析的第二条消息</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="0935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，它给了你基于你的特定用例创建你自己的架构的想法。<br/>需要记住的几件事是，这类应用程序可以节省大量资金，非常容易监控，并且在方法上也非常灵活！</p><p id="c4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一篇文章可能会专门讨论API网关，我们可以用它作为访问我们服务的大门。</p></div></div>    
</body>
</html>