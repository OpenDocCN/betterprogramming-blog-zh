<html>
<head>
<title>How to Use Redis for Caching and Pub/Sub in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用Redis进行缓存和发布/订阅</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-redis-for-caching-and-pub-sub-in-python-3851174f9fb0?source=collection_archive---------0-----------------------#2022-01-06">https://betterprogramming.pub/how-to-use-redis-for-caching-and-pub-sub-in-python-3851174f9fb0?source=collection_archive---------0-----------------------#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="642d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Python中Redis的常见用例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21010e0711b9e1ab603b1fca66757ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HjmtCYm--Cibzy9b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://unsplash.com/photos/w1K9Ug_pjXw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="f573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener"> Redis </a>是一个开源的内存数据结构存储，可以用作内存键值数据库、缓存系统和发布/订阅消息代理。Redis的特殊之处在于，它的所有数据都存储在内存中，而不是存储在磁盘上，这使得它非常快，是一种流行的缓存选项。</p><p id="6e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener">之前的文章</a>中，介绍了Redis数据类型和常用命令的要点。在本文中，我们将关注如何在Python中使用Redis进行缓存和发布者/订阅者(pub/sub)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="39de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以直接在计算机上安装Redis服务器。然而，出于学习的目的，推荐使用Docker容器来测试Redis，因为您可以随时使用最新版本的Redis进行测试。要使用Docker容器启动Redis服务器，请在shell中运行以下命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="4856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高端口16379用于避免机器上潜在的端口冲突。此外，还创建了一个Docker网络，使Redis服务器与<code class="fe me mf mg mh b">redis-cli</code>的连接更加容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="ddd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以使用<code class="fe me mf mg mh b">redis-cli</code>运行常见命令，如<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener">上一篇文章</a>中所示。但是，本文的重点是如何在Python中使用Redis，所以我们继续。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3055" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">在Python中使用Redis的基础知识</strong></h1><p id="1b58" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">要用Python访问Redis服务器，您需要一个Python Redis客户机。推荐的是<code class="fe me mf mg mh b"><a class="ae ky" href="https://redis.io/clients#python" rel="noopener ugc nofollow" target="_blank">redis-py</a></code>，比较成熟，支持也不错。它目前被视为Python的“必由之路”。</p><p id="8f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe me mf mg mh b">redis-py</code>，我们应该把它安装在我们的电脑上。建议将它安装在一个<a class="ae ky" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">虚拟环境</a>中，这样它就不会与现有的库混淆。为简单起见，我们将使用<a class="ae ky" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener"> <em class="nf"> conda </em> </a>来创建一个虚拟环境:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行上的<code class="fe me mf mg mh b">(redis)</code>表示虚拟环境已成功创建并激活。如果你想了解更多关于<em class="nf">康达</em>，<a class="ae ky" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">这篇文章</a>可以作为很好的参考。</p><p id="0bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后要安装<code class="fe me mf mg mh b">redis-py</code>，运行:</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="5509" class="nk mj it mh b gy nl nm l nn no">$ <strong class="mh iu">pip install redis</strong></span></pre><p id="d7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意要安装的库是<code class="fe me mf mg mh b">redis</code>，不是<code class="fe me mf mg mh b">redis-py</code>。为了更容易地以交互方式运行Python命令，我们还将在虚拟环境中安装iPython:</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="2168" class="nk mj it mh b gy nl nm l nn no">$ <strong class="mh iu">pip install ipython</strong></span></pre><p id="2791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以启动iPython并与Redis交互:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的Redis服务器启用了身份验证，您可以用<code class="fe me mf mg mh b">password</code>参数指定密码。如果您的Redis服务器有多个数据库，您还可以指定<code class="fe me mf mg mh b">db</code>参数。默认的数据库号是0，这是在您没有指定数据库号时使用的默认数据库号。</p><p id="ee30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您应该正确指定端口，这里是自定义的高端口16379，而不是经典的6379。还要注意Redis的键和值只能是字节、字符串、整数和浮点数。为了最佳实践，我们通常应该只使用有意义的字符串作为键。但是，对于具有非基本类型(如对象或数组)的值，必须先将其转换为字符串或字节，然后才能在Redis中设置为值。<code class="fe me mf mg mh b">json.dumps</code>函数通常用于将Python中的字典或列表转换成JSON字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="264d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，正如我们所见，在Python中，默认情况下，所有响应都以字节形式返回。如果我们想要解码来自Redis客户端的所有字符串响应，我们可以在创建客户端时指定<code class="fe me mf mg mh b">decode_responses</code> <em class="nf"> </em>和<em class="nf"> </em> <code class="fe me mf mg mh b">encoding</code>参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="cdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉字符串编码/解码和Unicode/UTF-8的概念，这篇文章可能会有所帮助。</p><p id="0c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除Redis密钥，只需使用客户端的<code class="fe me mf mg mh b">delete</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="9ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果中，<em class="nf"> 1 </em>表示密钥删除成功，<em class="nf"> 0 </em>表示密钥不存在。</p><p id="9358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有许多Redis键需要检查时，有一个方便的方法叫做<code class="fe me mf mg mh b">scan_iter</code>，它类似于<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener"> SCAN </a>命令，但使用起来要方便得多，因为我们不需要记住和指定光标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="4f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener">冒号</a> ( <code class="fe me mf mg mh b">:</code>)只是用来分隔对象类型和id，实际上没有任何特殊含义。<code class="fe me mf mg mh b">scan_iter</code>方法期望一个<a class="ae ky" href="https://redis.io/commands/keys" rel="noopener ugc nofollow" target="_blank"> Redis模式</a>作为输入。如果没有指定模式，将返回所有键。特别是，星号“<code class="fe me mf mg mh b">*</code>”匹配任意数量的任意字符。它相当于正则表达式中的“<code class="fe me mf mg mh b">.*</code>”模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们已经介绍了Redis在Python中非常基本的用法。Python中的大多数Redis方法都有其本地的<code class="fe me mf mg mh b">redis-cli</code>命令对应物。如果你有兴趣或者需要使用其他方法，可以参考<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener">上一篇文章</a>重点介绍的原生<code class="fe me mf mg mh b">redis-cli</code>命令。</p><p id="f9f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把重点放在Redis管道和pub/sub上，它们在<code class="fe me mf mg mh b">redis-cli</code>中不常用，但在驱动程序中更常用(在本文中是Python)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7416" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak"> Redis管道</strong></h1><p id="fc44" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">对于Redis，管道是同时执行多个命令的一种方式。命令将被缓冲，只有一个请求将被发送到Reids服务器。通过这种方式，Redis服务器和客户端之间的通信开销显著降低，速度/效率得以提高。当您需要顺序运行许多Redis命令时，管道非常有用。</p><p id="7c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道类似于SQL数据库中的<a class="ae ky" href="https://medium.com/codex/understand-the-basics-of-locks-and-deadlocks-in-mysql-part-i-92f229db0a" rel="noopener">事务</a>。但是，这里不是先启动一个事务，然后提交，而是先创建一个管道对象，然后执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，管道使用起来非常简单。它有更多的高级设置，这使得它可以在更复杂的情况下工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="88a7" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak"> Redis发布/订阅</strong></h1><p id="8b80" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Redis是一个常用的轻量级消息/队列或发布/订阅(pub/sub)系统。例如，<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html" rel="noopener ugc nofollow" target="_blank"> Airflow </a>使用它作为代理将消息从调度器转发到工作器。</p><p id="7127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他消息/队列系统一样，在发布和接收消息之前，我们需要创建一个通道和订阅。在一些消息/队列系统中，如Google云平台的<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-use-google-pub-sub-to-build-an-asynchronous-messaging-system-in-python-3b43094627dc" rel="noopener"> Pub/Sub </a>服务中，通道有时被称为<a class="ae ky" href="https://cloud.google.com/pubsub/docs/overview#core_concepts" rel="noopener ugc nofollow" target="_blank"> topic </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们不需要显式地创建通道。频道是在第一次订阅时自动创建的，如上所示。而且，我们可以同时订阅多个频道。我们甚至可以通过模式订阅多个频道，我们很快就会看到下面的<code class="fe me mf mg mh b">psubscribe</code>方法。</p><p id="5b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们向渠道发布一些消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="52dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该注意，Redis客户机(<code class="fe me mf mg mh b">redis_cli</code>)用于将消息发布到通道，而不是上面创建的PubSub对象。返回的数字是消息传递到的订户的数量。让我们创建一个新的订阅，看看数字是否会相应地改变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中,<code class="fe me mf mg mh b">psubscribe</code>意味着订阅将由模式创建。创建的订阅将侦听与指定模式匹配的所有频道。</p><p id="de88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，当我们发布到<code class="fe me mf mg mh b">channel-*</code>时，返回是1，这意味着消息只发布到一个订阅者，即使用模式<code class="fe me mf mg mh b">channel-*</code>创建的订阅者。但是，当消息再次发布到<code class="fe me mf mg mh b">channel-1</code>时，返回值变为2，这意味着消息发布到了两个订阅者。实际上，只创建和使用了一个PubSub对象。然而，这个PubSub对象有两个订阅/订户，一个订阅到频道<code class="fe me mf mg mh b">channel-1</code>，另一个订阅到所有匹配<code class="fe me mf mg mh b">channel-*</code>的频道。</p><p id="2724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从系统中获取发布的消息。为此，我们需要调用PubSub对象的<code class="fe me mf mg mh b">get_message</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="fb82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">get_message</code>方法获取下一条消息(如果有)，否则不获取。它返回一个包含四个键的字典:</p><ul class=""><li id="6385" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe me mf mg mh b">type</code> —数据的类型。值可以是<code class="fe me mf mg mh b">subscribe</code>、<code class="fe me mf mg mh b">psubscribe</code>、<code class="fe me mf mg mh b">message</code>等。<code class="fe me mf mg mh b">message</code>表示实际发布的数据，其他表示订阅类型，可以看作元数据。我们通常只对<code class="fe me mf mg mh b">message</code>类型的数据感兴趣。</li><li id="a6b4" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe me mf mg mh b">pattern</code> —通道的模式。对于除了<code class="fe me mf mg mh b">pmessage</code>类型以外的所有消息，它都是None，如上所示。在本例中，这意味着消息被发布到与模式<code class="fe me mf mg mh b">channel-*</code>匹配的通道。</li><li id="8073" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe me mf mg mh b">channel</code> —消息发布到的渠道。</li><li id="7e5b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe me mf mg mh b">data</code> —实际发布的消息数据。对于“元数据”订阅，它是调用<code class="fe me mf mg mh b">get_message</code>方法时PubSub对象的订阅数。对于消息类型，它是实际发送的消息。</li></ul><p id="778b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你和我一样好奇，那么当创建一个新的订阅和取消订阅时，会发布一个“元数据”消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="393a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常情况下，您不会太在意元数据，只需要处理发布的真实消息。</p><p id="5601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的简单例子中我们可以看出，创建一个通道(主题)和订阅，然后用Redis发布/接收消息是非常简单的。然后，您可以创建一些逻辑来解析接收到的数据，并在您的应用程序中使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文介绍了Python中Redis最常见的用例。结合<a class="ae ky" href="https://medium.com/codex/essentials-of-redis-all-you-need-to-know-as-a-developer-73da5d2fdc0b" rel="noopener">上一篇关于使用原生Redis命令的文章</a>，您现在应该对Redis有了相当好的理解，并可以开始在工作中使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="eac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="cb0d" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/how-to-use-google-pub-sub-to-build-an-asynchronous-messaging-system-in-python-3b43094627dc?source=your_stories_page----------------------------------------" rel="noopener">如何使用Google Pub/Sub在Python中构建异步消息传递系统</a></li></ul></div></div>    
</body>
</html>