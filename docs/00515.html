<html>
<head>
<title>Building High-Performance Infinite Lists in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建高性能无限列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-high-performance-infinite-lists-in-react-a53c0899a211?source=collection_archive---------7-----------------------#2019-06-04">https://betterprogramming.pub/build-high-performance-infinite-lists-in-react-a53c0899a211?source=collection_archive---------7-----------------------#2019-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a7f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解和解决常见问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/43e8b92e22332bf6300c4c345836d791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9xICOT_nMKR3xiSVm0sYQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/photos/Mkh2La9fEDY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@rohittandon" rel="noopener ugc nofollow" target="_blank"> Rohit Tandon </a>拍摄的照片</p></figure><p id="7336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">互联网上充斥着使用无限滚动的产品。无限卷轴让信息的消费变得非常容易，并且极易上瘾。带有时间线或订阅源的产品，如Twitter、Instagram等。最适合无限卷轴。</p><p id="f248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中实现无限滚动可能很有挑战性。当你的提要有数千个条目时，问题就变得更加复杂了。让我们来看看其中的一些问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b847" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题</h1><ul class=""><li id="fc6d" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">渲染速度慢，因为在调整大小时，浏览器必须重新绘制所有元素</li><li id="38fb" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">滞后滚动</li><li id="ac3d" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">页面上成千上万的DOM元素会导致浏览器崩溃</li></ul><p id="134b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数设备每秒刷新屏幕<strong class="ky ir"> 60次</strong>。这些帧中的每一帧的预算都刚刚超过16毫秒(1秒/60 = 16.66毫秒)。当你不能满足这个预算，帧速率下降，内容在屏幕上抖动。你可以使用Chrome中的<a class="ae kv" href="https://developer.chrome.com/devtools/docs/rendering-settings" rel="noopener ugc nofollow" target="_blank"> FPS计</a>来检查网页的刷新率。当你在有这么多DOM元素的页面上滚动时，FPS肯定会低于60。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="53c5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们能做什么</h1><p id="4ae9" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们必须减少元素并处理滚动问题。以下是解决这些问题的一些基本思路:</p><ul class=""><li id="0e31" class="mr ms iq ky b kz la lc ld lf nk lj nl ln nm lr my mz na nb bi translated"><strong class="ky ir"> DOM回收</strong>:想法是只渲染可见的元素。我们可以重用它们来呈现新的项目，而不是创建新的项目。</li><li id="09bb" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky ir">滚动锚定</strong>:由于DOM中只有10个元素，我们需要伪造滚动来给人无限滚动的错觉。</li></ul><p id="4d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些需要大量的计算和拐角条件来有效地实现它。在阅读这些问题时，我遇到了一个<a class="ae kv" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank"> react-virtualized </a>包，它为所有这些问题构建了解决方案，并由<a class="ae kv" href="https://twitter.com/dan_abramov/status/716369503291105283" rel="noopener ugc nofollow" target="_blank"> Dan Abramov </a>推荐。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1aa1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">虚拟化的工作原理</h1><p id="6abb" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">React-virtualized通过一组组件实现虚拟渲染，这些组件完成相同的任务:</p><ul class=""><li id="c1c3" class="mr ms iq ky b kz la lc ld lf nk lj nl ln nm lr my mz na nb bi translated">它们计算在列表显示区域内哪些项目是可见的。</li><li id="d891" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">他们使用一个具有相对位置和绝对位置的容器，通过改变容器的宽度、高度、顶部和左侧属性来确定内部子元素的位置。</li></ul><p id="f1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用以下组件来呈现具有动态宽度的列表以及动态宽度和高度的项目:</p><ul class=""><li id="baa4" class="mr ms iq ky b kz la lc ld lf nk lj nl ln nm lr my mz na nb bi translated"><strong class="ky ir">列表:</strong>该组件呈现一个元素列表。它负责虚拟化列表并只呈现可见的项目。</li><li id="baca" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky ir"> CellMeasurer </strong>:它通过以用户不可见的方式临时呈现单元格来自动测量单元格的内容。指定一个固定宽度来测量动态高度(反之亦然)。</li><li id="5ae9" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky ir"> CellMeasurerCache </strong>:存储<code class="fe nn no np nq b">CellMeasurer</code>个测量值，并与父节点(<code class="fe nn no np nq b">List</code>)共享。</li><li id="0597" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky ir"> AutoSizer </strong>:自动调整单个子的宽度和高度的高阶组件。</li><li id="6fbf" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><strong class="ky ir"> InfiniteLoader </strong>:当用户在列表中上下滚动时，它管理数据的即时获取。它还缓存列表数据，以避免在用户滚动时再次获取它。</li></ul><p id="a549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用它们来建立一个真正的列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过<a class="ae kv" href="https://github.com/bvaughn/react-virtualized/tree/master/docs#documentation" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">文档</strong> </a>来了解这些组件的工作原理以及不同可用道具的含义。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="20a7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">缓存问题</h1><p id="2716" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如果您基于一些状态变化重新呈现列表，您可能会因为<code class="fe nn no np nq b">CellMeasurerCache</code>和<code class="fe nn no np nq b">InfiniteLoader</code>所做的缓存而面临问题。可以使用内置方法清除缓存。</p><pre class="kg kh ki kj gt nt nq nu nv aw nw bi"><span id="18da" class="nx ma iq nq b gy ny nz l oa ob">// Reset cached measurements for all cells.<br/>this.cellMeasurerCache.clearAll();</span><span id="2138" class="nx ma iq nq b gy oc nz l oa ob">// Reset any cached data about already-loaded rows<br/>this.infiniteLoaderRef.resetLoadMoreRowsCache();</span><span id="45a6" class="nx ma iq nq b gy oc nz l oa ob">// Recompute row heights and offsets<br/>this.listRef.recomputeRowHeights();</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e56e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="08f8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我希望这有助于你理解实现大列表的问题以及如何处理它们。它提供了对react虚拟化包的基本理解。该软件包提供了许多其他组件来解决大型动态表格、网格等问题。布莱恩·沃恩也推荐<a class="ae kv" href="https://github.com/bvaughn/react-window" rel="noopener ugc nofollow" target="_blank">反应窗</a>作为一个可能的轻量级替代方案。</p><p id="2a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在评论中分享你的使用案例和你所面临的无限列表的问题。谢谢！</p></div></div>    
</body>
</html>