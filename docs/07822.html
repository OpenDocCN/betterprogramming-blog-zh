<html>
<head>
<title>What’s New in TypeScript 4.2?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.2有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-2-97f722689c43?source=collection_archive---------6-----------------------#2021-02-23">https://betterprogramming.pub/whats-new-in-typescript-4-2-97f722689c43?source=collection_archive---------6-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypeScript的又一次惊人的增量升级</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00ca83d4d9fd873f041ea1e7b09f5cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hvtum1YgCxQTMrHg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vishnurnair?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毗湿奴·R·奈尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Typescript的<code class="fe lv lw lx ly b">4.2</code>刚刚在2月23日星期二发布🎉。这个版本带来了哪些令人敬畏的功能？对你作为开发者的日常生活有什么影响？是否应该立即更新？</p><p id="5e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将介绍所有最激动人心的新功能。以下是总结:</p><ul class=""><li id="4751" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">更智能的类型别名保留</li><li id="c580" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">元组类型中的前导/中间剩余元素</li><li id="d260" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">对<code class="fe lv lw lx ly b">in</code>操作员进行更严格的检查</li><li id="376a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">--noPropertyAccessFromIndexSignature</code></li><li id="937c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">模板文字表达式具有模板文字类型</li><li id="baad" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">改进了逻辑表达式中的未调用函数检查</li><li id="08a0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">更好地理解编译过程</li><li id="e734" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">支持抽象构造函数类型</li></ul><p id="d0b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得最新Typescript版本的编辑器，请使用<a class="ae ky" href="https://code.visualstudio.com/insiders/" rel="noopener ugc nofollow" target="_blank">Visual Studio Code Insiders</a>。你也可以为VS代码使用一个插件。</p><p id="82ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只是想边看文章边玩，你可以使用这里的<code class="fe lv lw lx ly b">Typescript Playground </code><a class="ae ky" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"/>。这是一个有趣和超级容易使用的工具。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="24a8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">更智能的类型别名保留</h1><p id="e4c5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有时TypeScript不能正确地解析类型。它可能返回正确的类型，但不返回正确的别名。别名可能很重要，不应该在途中丢失。</p><p id="85a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，一个<code class="fe lv lw lx ly b">undefined</code>类型需要被添加到方法返回类型中，因为它在某些场景中返回<code class="fe lv lw lx ly b">undefined</code>。</p><p id="127a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">4.2</code>之前<code class="fe lv lw lx ly b">divisablePer0</code>类型的返回是<code class="fe lv lw lx ly b">number | bigint | undefined</code>。那个类型确实是正确的，但是我们丢失了一些信息。别名<code class="fe lv lw lx ly b">BasicPrimitive</code>在这个过程中丢失了，这是一条有用的信息。</p><p id="d7e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在TypeScript <code class="fe lv lw lx ly b">4.2</code>上做同样的事情，我们会得到正确的别名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在方法<code class="fe lv lw lx ly b">divisablePer0</code>有了正确的返回类型:<code class="fe lv lw lx ly b">BasicPrimitive | undefined</code>。仅仅通过升级就能让你的代码更具可读性。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2259" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">元组类型中的前导/中间剩余元素</h1><p id="9ff6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在关于映射类型的文章<a class="ae ky" href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener">中，我们已经看到了类型脚本元组。作为复习，让我们重温一下这个例子:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们忘记了检查元组是否可以使用可选元素。让我们看看前面的例子是什么样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">4.2</code>之前，我们甚至可以使用spread运算符来表示元素的动态数量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个新的TypeScript中，版本元组变得更加强大。以前，我们可以使用spread操作符，但是我们不能定义最后的元素类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="61c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，类似这样的内容是无效的:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="6d49" class="nx mv it ly b gy ny nz l oa ob">let arrayOptions: [string, ...boolean[], number?];</span></pre><p id="4863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选元素不能跟在rest元素后面。然而，请注意，<code class="fe lv lw lx ly b">...boolean[]</code>确实接受空数组，因此元组将接受<code class="fe lv lw lx ly b">[string, number]</code>类型。</p><p id="229d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在下面的例子中详细了解一下:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="cf9a" class="nx mv it ly b gy ny nz l oa ob">let arrayOptions: [string, ...boolean[], number];<br/>arrayOptions = ['config', 12]; // works</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="79c3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">对in运算符进行更严格的检查</h1><p id="ec02" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">in</code>操作符很容易知道一个方法或属性是否在一个对象中。然而，在JavaScript中，如果对照原语进行检查，它将在运行时失败。</p><p id="d1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当你尝试这样做的时候:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">游乐场链接<a class="ae ky" href="https://www.typescriptlang.org/play?noUncheckedIndexedAccess=true&amp;ts=4.2.0-beta&amp;ssl=2&amp;ssc=77&amp;pln=1&amp;pc=1#code/EQWwpgLgFg9gJsABASwHaIEwGYBQB6PRAUQCcSYSAuRAFSjEROQHMoIBaKAQ1TkQGdkcBjABmiHogDkaKYjAAPAA4kw-QTHQgArvwiJUMfQCMGXRCuQhkEZADcwAOhxA" rel="noopener ugc nofollow" target="_blank">此处</a></p></figure><p id="0da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将得到一个错误，明确地告诉您发生了什么。由于这个操作符已经变得更加严格，这个版本可能会引入突破性的变化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cced" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><code class="fe lv lw lx ly b">--noPropertyAccessFromIndexSignature</code></h1><p id="39c1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">另一个总是很有趣的编译器配置。在TypeScript中，可以使用带括号的元素语法或像JavaScript一样的点语法来访问属性。当键是字符串时，访问器是可能的。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="c544" class="nx mv it ly b gy ny nz l oa ob">interface Person {<br/>  name: string;<br/>}</span><span id="3d2a" class="nx mv it ly b gy oc nz l oa ob">const p: Person = { name: 'Max };</span><span id="4bd1" class="nx mv it ly b gy oc nz l oa ob">console.log(p.name) // Max</span><span id="799c" class="nx mv it ly b gy oc nz l oa ob">console.log(p['name']) // Max</span></pre><p id="d9c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种情况会导致显式属性类型错误:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="2366" class="nx mv it ly b gy ny nz l oa ob">interface Person {<br/>  name: string;<br/>  [key: string]: string;<br/>}</span><span id="2367" class="nx mv it ly b gy oc nz l oa ob">const p: Person = { name: 'Max };</span><span id="96a9" class="nx mv it ly b gy oc nz l oa ob">console.log(p.namme) // undefined</span><span id="9eb0" class="nx mv it ly b gy oc nz l oa ob">console.log(p['namme']) // undefined</span></pre><p id="e109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何访问错误的属性<code class="fe lv lw lx ly b">namme</code>的，但是因为它符合<code class="fe lv lw lx ly b">[key: string]</code>隐式属性，所以TypeScript不会失败。</p><p id="69e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用<code class="fe lv lw lx ly b">--noPropertyAccessFromIndexSignature</code>将使TypeScript在使用点语法时查找<code class="fe lv lw lx ly b">explicit</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不是<code class="fe lv lw lx ly b">strict</code>配置的一部分，因为这可能不适合所有的开发者和代码库。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f1be" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">模板文字表达式具有模板文字类型</h1><p id="2b80" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">模板文字类型是在<code class="fe lv lw lx ly b">4.1</code>中引入的，在这里它们变得更加智能。以前，您不能定义类型模板用法模板文字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心问题是字符串表达式被解析为类型<code class="fe lv lw lx ly b">string</code>，这导致了这种类型的不兼容性:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="2892" class="nx mv it ly b gy ny nz l oa ob">const x = `get${propertyName}`; // string</span></pre><p id="8d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用<code class="fe lv lw lx ly b">4.2</code>，模板字符串表达式将总是以模板文字类型开始:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="914a" class="nx mv it ly b gy ny nz l oa ob">const x = `get${propertyName}`; // getName</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0876" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">改进了逻辑表达式中的未调用函数检查</h1><p id="e6ff" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">TypeScript的未调用函数检查适用于<code class="fe lv lw lx ly b">&amp;&amp;</code>和<code class="fe lv lw lx ly b">||</code>表达式。在<code class="fe lv lw lx ly b">--strictNullChecks</code>下，您现在将检查以下错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">游乐场链接<a class="ae ky" href="https://www.typescriptlang.org/play?noUncheckedIndexedAccess=true&amp;ts=4.2.0-beta#code/GYVwdgxgLglg9mABDAzgSTANxlApgEwAowBDAW1wC5EUoAnGMAcwEpEBvAKER8Ttygg6SUhUQBCALyTEAcgBKcAEa46UWQG5OAX06dQkWAkRN+A4uSo16jVh268YwRIVQZsefGy69fiAPT+iACidHRwdIjGADaMuIgAbA5+AUEAKgAWqIgQCPg48EgA7jDR0Ygk0UUkAJ4ofAJCSPQg8SiMEPFQGfEG0IXI9ZXVdYj4uMBx+AB0yX6BiAAiMPiINXAgiBQkzXA5leU4yGC0uCT4APxzvvyCwogABgDquNG5YgAk7KK42g9avl0N0a9weAGUInQamsNhV+IgwHAoMcPAR-jogA" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></figure><p id="af35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多详情<a class="ae ky" href="https://github.com/microsoft/TypeScript/issues/40197" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c0fc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">更好地理解编译过程</h1><p id="1249" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有时，确定Typescript文件定义是从哪里提取出来的是相当具有挑战性的。有时候是一个试错的过程。</p><p id="80dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以更深入地了解正在发生的事情，使用下面的代码使编译器更加冗长:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7848" class="nx mv it ly b gy ny nz l oa ob">tsc --explainFiles</span></pre><p id="720e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/581b704ff19db064c3d07be099f36190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cnjsw5JLaRcUB9n3lgHpw.png"/></div></div></figure><p id="d1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常棒的特性，它将帮助您进一步理解Typescript的内部结构。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2622" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/3e636bd1fbb2d668b0dd9bafcb0ab5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HRJ7NEpDLZ47vJrq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@davealmine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dawid za wia</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管TypeScript <code class="fe lv lw lx ly b">4.2</code>没有像之前的版本一样引入任何主要特性，但它仍然是功能齐全的。</p><p id="b3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上一个版本我们有模板文字特性。如果你在之前的版本中错过了这个特性，请在我的文章<a class="ae ky" href="https://medium.com/better-programming/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9" rel="noopener">中查看。在这个版本中，我们看到它变得更加成熟，使用起来更加有趣。</a></p><p id="a5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像更智能的类型保留和改进的非调用函数检查这样的特性将对您的日常编码产生直接影响。它们将使你的代码更具可读性，并让你更好地了解正在发生的事情。</p><p id="f2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到更多有助于使代码更严格的特性总是很好的。希望这能帮助你在早期发现错误。</p><p id="c7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想了解更多关于<code class="fe lv lw lx ly b">4.2</code>发布的信息，请点击查看他们的官方发布博客<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-2/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="559d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多的TypeScript内容将很快出现—干杯</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b858" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated"><strong class="ak">相关文章</strong></h1><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">TypeScript 4.1的高级映射类型</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">看看递归条件类型、模板文字类型等等</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/simulating-a-typescript-interview-cdaf9d217dff" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">模拟打字面试</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">知道你的下一次面试是什么样子，从而领先一步</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/mastering-typescripts-mapped-types-5fa5700385eb" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">掌握TypeScript的映射类型</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">了解如何像专家一样处理Typescript映射类型</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>