<html>
<head>
<title>SwiftUI, a Tour Into Its Beautiful API (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI，它美丽的API之旅(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-a-tour-into-its-beautiful-api-part-1-b098b38e77?source=collection_archive---------3-----------------------#2019-06-07">https://betterprogramming.pub/swiftui-a-tour-into-its-beautiful-api-part-1-b098b38e77?source=collection_archive---------3-----------------------#2019-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b423" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个新的跨平台声明式UI框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/78a0616ce244da60c9ecf9ece6b0374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*vMuzAesLiPp2TerWlaTfYw.png"/></div></figure><p id="64d0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就在几天前，苹果在WWDC19上展示了<a class="ae lj" href="https://developer.apple.com/documentation/swiftui" rel="noopener ugc nofollow" target="_blank"><em class="lk">swift ui</em>T5。一个承诺彻底改变我们在每个苹果平台上做UI的方式的框架:iOS，watchOS，iPadOS，tvOS和macOS。</a></p><p id="5e36" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它提供了抽象概念来轻松地描述和漂亮地组合视图、控件、布局和事件处理。一切都进行得非常迅速。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="cbcf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">UIKit有什么问题？</h1><p id="94ba" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">实际上没有。</p><p id="8ed5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lj" href="https://getuikit.com/" rel="noopener ugc nofollow" target="_blank"> UIKit </a>效果很好，值得一个大大的掌声。由于它的灵活性、正确性和架构，到目前为止，AppStore中有210万个应用程序！</p><p id="14ee" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，我们每天都在努力让我们的应用变得更好。我们努力改进我们的开发工作流程，这样以前比较难的东西现在可以更容易、更快地开发出来。</p><p id="2c84" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">需要一个复杂的应用程序(甚至是一个简单的应用程序)来管理不同的状态，不仅是业务逻辑，还有UI。每当你为你的下一个照片分享应用程序加载和显示壮观的图像，或者为你的下一个平滑注册流程启用/禁用邮件文本字段时，用户界面需要管理许多不同的状态。</p><p id="4519" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">管理国家是困难的。</p><p id="affc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个小错误可能会导致用户界面不同步、按钮损坏，或者更糟，导致意外行为。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="2d28" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">SwiftUI如何帮助我们？</h1><p id="2d65" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">SwiftUI从命令式范式转变为纯粹的<strong class="kp ir">声明式</strong>范式，遵循类似项目的方法，如<a class="ae lj" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> Flutter </em> </a>、<a class="ae lj" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>或J <a class="ae lj" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> etpack Compose </a>。由于它与操作系统和Swift语言的深度集成，它非常容易使用，功能强大，速度快。</p><p id="ef94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">声明式用户界面意味着能够“描述”你的用户界面应该是什么样子，而不需要确切地告诉“如何”。因此，这个框架能够，也将会找到最好的方法来做这件事。</p><p id="c3b3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">想想必须做一个比萨饼。您可以:</p><ul class=""><li id="86f7" class="mp mq iq kp b kq kr kt ku kw mr la ms le mt li mu mv mw mx bi translated">按照我意大利祖母的食谱，一步一步地，按照明确的顺序。小心——犯错误或不遵守命令很可能会导致不好的结果。</li><li id="2b12" class="mp mq iq kp b kq my kt mz kw na la nb le nc li mu mv mw mx bi translated">在披萨店要一份你最喜欢的披萨，描述你喜欢的方式。厨师会知道怎么准备，怎么做，所以你只要好好享受就好了。</li></ul><p id="2793" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了在SwiftUI中描述我们的视图，我们将遵循<code class="fe nd ne nf ng b">View</code>协议，该协议通过<code class="fe nd ne nf ng b">body</code>属性定义了单一的真实来源。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="50fe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用<code class="fe nd ne nf ng b">body</code> computed属性来声明我们的UI。每当数据依赖项(即<code class="fe nd ne nf ng b">ViewModel</code>或状态)更新时，SwiftUI的渲染引擎将读取<code class="fe nd ne nf ng b">body</code>来相应地更新UI。基本上消除了手动同步UI的需要。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="cdec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">它是如何工作的(以及对快速进化的赞美)</h1><p id="ce3a" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">让我们定义一个<code class="fe nd ne nf ng b">CustomView</code>,它显示一个文本以及它接收到的点击次数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c0d5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您对这段代码感到困惑，它是完全合法的，因为它包含了Swift 5.1编译器的几个新功能。值得提及和欣赏的特性。</p><h2 id="62de" class="nj lt iq bd lu nk nl dn ly nm nn dp mc kw no np me la nq nr mg le ns nt mi nu bi translated">属性包装器(<a class="ae lj" href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-delegates.md" rel="noopener ugc nofollow" target="_blank"> SE-0258 </a>)</h2><p id="9ce4" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated"><code class="fe nd ne nf ng b">@State</code>叫做属性糖纸。它所做的是“包装”一个属性，这样一个常见的行为就可以由类似于<code class="fe nd ne nf ng b">State</code>的类型来实现。一个例子是<code class="fe nd ne nf ng b">@Lazy</code>属性包装器，被定义为表现为<code class="fe nd ne nf ng b">lazy</code>修饰符。或者，如本例所示，<code class="fe nd ne nf ng b">@State</code>可用于在其包装属性改变时触发渲染引擎。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="b49d" class="nj lt iq bd lu nk nl dn ly nm nn dp mc kw no np me la nq nr mg le ns nt mi nu bi translated">不透明类型(SE-0244)</h2><p id="0a0e" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated"><code class="fe nd ne nf ng b">some</code>是我们如何在Swift 5.1中定义不透明类型。不透明类型隐藏了具体类型，有点像返回协议，但本质上是不同的。例如，编译器可以保证返回的类型必须始终相同。这使得能够返回带有关联类型的<code class="fe nd ne nf ng b">some</code>协议，或者能够在两次返回<code class="fe nd ne nf ng b">var shape: some Shape</code>之间使用<code class="fe nd ne nf ng b">Equatable</code>。如果你想了解更多的细节，我强烈建议你看一下这个提议。</p><h2 id="1aed" class="nj lt iq bd lu nk nl dn ly nm nn dp mc kw no np me la nq nr mg le ns nt mi nu bi translated">省略回车(<a class="ae lj" href="https://github.com/apple/swift-evolution/blob/master/proposals/0255-omit-return.md" rel="noopener ugc nofollow" target="_blank"> SE-0255 </a>)</h2><p id="e8d1" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">对于单个表达式，我们可以省略关键字<code class="fe nd ne nf ng b">return</code>。使您能够做以下事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e5fc" class="nj lt iq bd lu nk nl dn ly nm nn dp mc kw no np me la nq nr mg le ns nt mi nu bi translated">函数生成器</h2><p id="319f" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">目前<a class="ae lj" href="https://forums.swift.org/t/pitch-function-builders/25167" rel="noopener ugc nofollow" target="_blank">正在讨论</a>，函数构建器使得创建DSL变得容易。如果没有这个提议，SwiftUI看起来会更加庞大，因为我们需要将每个组件传递给类似于构建器的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="786a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，我们不用这段代码来设置两个垂直对齐的文本，而是用如下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1f60" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">肯定更啰嗦。</p><h1 id="389c" class="ls lt iq bd lu lv nv lx ly lz nw mb mc jw nx jx me jz ny ka mg kc nz kd mi mj bi translated">结论</h1><p id="685b" class="pw-post-body-paragraph kn ko iq kp b kq mk jr ks kt ml ju kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">这些是Swift 5.1的主要特性，使SwiftUI变得难以置信的简洁和强大。在接下来的第二部分中，我们将看到更多关于SwiftUI的API——如何布局视图，如何通过修饰符改变其外观等等。感谢阅读。</p></div></div>    
</body>
</html>