<html>
<head>
<title>Use Generics to Reduce SwiftUI Preview’s Boilerplate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用泛型来减少SwiftUI Preview的样板文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-generics-to-reduce-swiftui-previews-boilerplate-7924bc763ba5?source=collection_archive---------6-----------------------#2021-12-16">https://betterprogramming.pub/use-generics-to-reduce-swiftui-previews-boilerplate-7924bc763ba5?source=collection_archive---------6-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1350" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用泛型和值类型来减少预览和其他协议实现中的样板文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79305eb390a1446795b4b486ada9b44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x4d_oUJV-qoakwKZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pmvch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> pmv chamara </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用UIKit的iOS开发中，最令人讨厌的事情之一是实现一个UI和在屏幕上看到它之间的缓慢反馈循环。</p><p id="0742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用UIKit开发时，尤其是使用代码优先的UI时，我们必须先编写所有的UI代码，然后才能看到它的外观。有时，我们不得不修复小故障，运行应用程序的开销比实际修复花费更多的时间。</p><p id="57b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 13和<code class="fe lv lw lx ly b">SwiftUI</code>中，苹果推出了SwiftUI预览:这项技术让我们在编写应用程序时，可以在Xcode中看到应用程序的外观。这大大缩短了开发周期。</p><p id="01da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果还引入了一些协议，我们可以用它们来收获UIKit中预览的好处。这些协议是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewRepresentable</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewcontrollerrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewControllerRepresentable</a></code>。</p><p id="bc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我将回顾如何实现这些协议，以便在SwiftUI预览中呈现UIKit视图。然后，我们将开发一个实用程序来删除一些不必要的样板文件。最后，我们将应用相同的机制使我们的ViewControllers也可用于预览，讨论这种方法的一般适用性。</p><h1 id="f493" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使UIKit视图对SwiftUI预览可用</h1><p id="889a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" rel="noopener ugc nofollow" target="_blank">UIViewRepresentable</a></code>的诞生是为了允许我们将UIKit视图与SwiftUI架构相结合。最初，两年前，SwiftUI不提供许多组件，开发人员使用该协议创建他们可以在SwiftUI中使用的UIKit视图。</p><p id="dafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协议有一个<code class="fe lv lw lx ly b">UIViewType: UIView</code>作为关联类型。此协议的关联类型必须是<code class="fe lv lw lx ly b">UIView</code>的子类。协议要求我们实现两种方法:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable/makeuiview(context:)" rel="noopener ugc nofollow" target="_blank">makeUIView(context:)</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable/updateuiview(_:context:)" rel="noopener ugc nofollow" target="_blank">updateUIView(_:context:)</a></code>。前者由SwiftUI生命周期用来创建视图，后者用于在发生某些事情时更新视图。</p><p id="cef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文，我们将使用UIKit实现一个配置文件屏幕，我们将在SwiftUI预览中看到它。为此，我们需要经历以下步骤:</p><ol class=""><li id="36d4" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">定义视图</li><li id="a846" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使其符合<code class="fe lv lw lx ly b">UIViewRepresentable</code>协议</li><li id="2ac6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">定义<code class="fe lv lw lx ly b">SwiftUI_preview</code></li><li id="f1b9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">实现视图。</li></ol><h2 id="6e8e" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">定义视图</h2><p id="8bf0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们先按下<code class="fe lv lw lx ly b">⌘+N</code>来创建一个新文件，我们称它为<code class="fe lv lw lx ly b">ProfileView</code>。</p><p id="87e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义该视图的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们创建了一个新的空UIKit视图。我已经定义了实现视图所需的方法框架。</p><p id="7008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还定义了对我们需要呈现的数据建模的<code class="fe lv lw lx ly b">Profile</code>结构。</p><h2 id="249c" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">使其符合<code class="fe lv lw lx ly b">UIViewRepresentable</code></h2><p id="91a6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">下一步是添加<code class="fe lv lw lx ly b">UIViewRepresentable</code>协议一致性。</p><p id="3acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要导入<code class="fe lv lw lx ly b">SwiftUI</code>并实际实现一致性。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="83d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在定义一个包装UIKit视图的结构。该结构需要一些必须呈现的数据，因此我们用一个<code class="fe lv lw lx ly b">Profile</code>来初始化它。</p><p id="b5be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">makeUIView(context:)</code>方法中，我们返回新创建的<code class="fe lv lw lx ly b">ProfileView</code>。主要目标是在SwiftUI预览中呈现视图，我们不需要在那里处理任何更新，所以<code class="fe lv lw lx ly b">updateUIView(_:context:)</code>方法有一个空体。</p><h2 id="8e1d" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">定义SwiftUI_Preview</h2><p id="82b0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">SwiftUI管道的最后一步是添加预览代码。我们需要定义另一个结构:在这种情况下，它必须符合<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/previewprovider" rel="noopener ugc nofollow" target="_blank">PreviewProvider</a></code>协议。这个协议需要一个<code class="fe lv lw lx ly b">static var previews: some View</code>属性来让Xcode呈现预览。</p><p id="13fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预览的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了新的结构，并实现了<code class="fe lv lw lx ly b">PreviewProvider</code>协议。计算出的var创建了上一步中定义的<code class="fe lv lw lx ly b">UIViewRepresentable</code>结构，传递了一个将在预览中呈现的模型。</p><p id="19d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此步骤还会自动启用Xcode预览。如果没有发生，我们可以使用<code class="fe lv lw lx ly b">⌥+⌘+↩︎</code>快捷键或<code class="fe lv lw lx ly b">Editor &gt; Canvas</code>菜单来触发画布。IDE应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/87807be1b8926ca709c8a3e91f2bfd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gl7IJSg0OuP9WKCkojXa4g.png"/></div></div></figure><h2 id="9e66" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">实现视图</h2><p id="48cc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">要开始预览，我们可以点击出现在画布右上角的<code class="fe lv lw lx ly b">Resume</code>按钮。随着预览的激活，我们可以实现我们的视图，我们可以在右边的面板中看到它。</p><p id="84aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使视图出现在预览中，我们必须:</p><ol class=""><li id="42b6" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">将其添加到超级视图中。</li><li id="ea3a" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">设计它。</li><li id="388d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">设置它们的布局约束。</li></ol><p id="a55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些步骤编码在第一步中描述的方法中。视图的代码可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我省略了一些重复的代码。按照上述步骤，我们:</p><ol class=""><li id="d795" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">定义我们想要添加的视图(第4到9行)。</li><li id="3bf9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">添加视图作为<code class="fe lv lw lx ly b">ProfileView</code>(<code class="fe lv lw lx ly b">setup</code>方法)的子视图。</li><li id="c4dc" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">样式化视图(方法<code class="fe lv lw lx ly b">style</code>)。</li><li id="9db6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">设置它们的自动布局约束(<code class="fe lv lw lx ly b">setConstraints</code>方法)。</li></ol><p id="0770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后的结局大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1285a0a38f75877592fa8b78b81ba0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXjwtNn69s4Ft_lA0tNt-g.png"/></div></div></figure><h1 id="bcad" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">样板文件的问题</h1><p id="3b0a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在想象一下，我们需要实现许多不同的视图。对于每个视图，我们必须使它符合<code class="fe lv lw lx ly b">UIViewRepresentable</code>协议。过程总是一样的:</p><ol class=""><li id="aef0" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">定义一个符合它的新结构。</li><li id="2937" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">定义一个属性来保存数据。</li><li id="3812" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">实现<code class="fe lv lw lx ly b">makeUIView</code>方法来实例化视图。</li><li id="aaa8" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">将<code class="fe lv lw lx ly b">updateUIView</code>方法留空。</li></ol><p id="c147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到所有这些重复，找到一种自动化这一步的方法看起来很自然。我们可以通过利用<a class="ae ky" href="https://www.youtube.com/watch?v=3BVkbWXcFS4" rel="noopener ugc nofollow" target="_blank">协议见证</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Value_semantics" rel="noopener ugc nofollow" target="_blank">值语义</a>来实现。</p><h2 id="f43c" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">定义一个通用的UIViewRepresentable</h2><p id="8634" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们希望为<code class="fe lv lw lx ly b">UIViewRepresentable</code>协议提供一个通用的实现，这样我们就可以将任何需要的视图传递给预览。</p><p id="150c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义此结构的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构实现了<code class="fe lv lw lx ly b">UIViewRepresentable</code>，并且是一个我们称之为<code class="fe lv lw lx ly b">ViewType</code>的泛型。该类型被约束为<code class="fe lv lw lx ly b">UIView</code>的子类型。</p><p id="0e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们试图实现<code class="fe lv lw lx ly b">makeUIView(context:)</code>方法时，我们没有足够的信息来创建一个通用的实现。</p><h2 id="671c" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">实现MakeUIView方法</h2><p id="2b44" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当我们没有足够的信息时，我们可以遵循的一个常见方法是推迟操作，直到我们有了足够的信息。用编码术语来说，这意味着将实现委托给结构的使用者。</p><p id="7542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过请求一个由结构体的消费者提供的<a class="ae ky" href="https://refactoring.guru/design-patterns/factory-method" rel="noopener ugc nofollow" target="_blank">工厂关闭</a>来实现这一点。<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code>的代码现在看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="889e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们引入了一个实例变量来存储闭包，并在<code class="fe lv lw lx ly b">makeUIView(context:)</code>方法中调用它。</p><h2 id="5ac8" class="nk ma it bd mb nl nm dn mf nn no dp mj li np nq ml lm nr ns mn lq nt nu mp nv bi translated">如何使用<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code></h2><p id="83ea" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，我们可以在预览中使用这个新对象。我们只需要:</p><ol class=""><li id="cfa2" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">定义一个<code class="fe lv lw lx ly b">SwiftUI_Preview</code>结构。这与上述实现中的步骤3相同，也是SwiftUI本身所需要的(Xcode在SwiftUI视图模板中创建该结构)。</li><li id="ba4d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在<code class="fe lv lw lx ly b">previews</code>属性中实例化<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code>。</li><li id="9c45" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">实现闭包以返回您的特定视图。</li></ol><p id="94c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这些步骤应用于<code class="fe lv lw lx ly b">ProfileView</code>。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">previews</code>属性中，我们定义了数据模型并创建了一个<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code>，传递了一个实例化我们的<code class="fe lv lw lx ly b">ProfileView</code>的闭包。</p><p id="e4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code>可以用来预览许多不同的UIKit视图。如果我们有一个包含用户名列表的表格视图，我们可以使用以下代码创建一个预览:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且<code class="fe lv lw lx ly b">UserListView</code>不一定要符合<code class="fe lv lw lx ly b">UIViewRepresentable</code>。</p><h1 id="4af4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">对UIViewControllerRepresentable应用相同的方法</h1><p id="9f20" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们对<code class="fe lv lw lx ly b">UIViewRepresentable</code>所做的可以用任何其他协议来完成。这个过程被称为去协议化，并在协议见证中转换协议，协议见证是一种符合协议的值类型，它防止我们创建各种一致性。</p><p id="fc2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将此应用于<code class="fe lv lw lx ly b">GenericUIViewControllerRepresentable</code>。SwiftUI使用这个协议使<code class="fe lv lw lx ly b">UIViewController</code>的与SwiftUI一起工作。在这种情况下，它与我们对<code class="fe lv lw lx ly b">UIViewRepresentable</code>所做的非常相似。</p><p id="642f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过程总是一样的:我们创建一个实现协议的通用结构，并要求消费者提供一个闭包来返回<code class="fe lv lw lx ly b">UIViewController</code>。</p><h1 id="3f63" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="7119" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们探讨了如何在UIKit代码库中利用SwiftUI预览。我们探索了基本过程，这需要我们使我们的观点符合<code class="fe lv lw lx ly b">UIViewRepresentable</code>。</p><p id="ea39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们意识到，如果我们想让所有视图在SwiftUI预览中可见，我们将添加许多样板代码来实现这种一致性。因此，我们将这些代码统一在一个<code class="fe lv lw lx ly b">GenericUIViewRepresentable</code>结构中，该结构实现了协议并将视图的初始化委托给消费者。</p><p id="06e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们探讨了如何将这一过程推广到其他协议。我们创建了一个<code class="fe lv lw lx ly b">GenericUIViewControllerRepresentable</code>结构，目的与<code class="fe lv lw lx ly b">UIViewRepresentable</code>协议相同。</p><p id="e2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将该过程应用于任何其他协议。在您的代码库中寻找具有许多彼此非常相似的实现的协议:它们是创建这些<code class="fe lv lw lx ly b">Generic</code>结构以减少样板文件的绝佳候选。</p></div></div>    
</body>
</html>