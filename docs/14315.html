<html>
<head>
<title>Build a GraphQL API Using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust构建一个GraphQL API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-graphql-api-using-rust-edf3554adf8f?source=collection_archive---------6-----------------------#2022-11-28">https://betterprogramming.pub/build-a-graphql-api-using-rust-edf3554adf8f?source=collection_archive---------6-----------------------#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c316" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用<a class="ae ki" href="https://github.com/tokio-rs/axum" rel="noopener ugc nofollow" target="_blank"> axum </a> web框架</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/bc873cd3cc8f58fc5c200c39a549b52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOYJZ07npQzv4HhHBzDPcA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在<a class="ae ki" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ki" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="405f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南将教你如何用Rust构建一个强大的GraphQL API。您将使用Rust和一些著名的库来创建一个HTTP服务器，添加GraphQL支持，甚至实现一个小API。之后，您将学习如何通过添加跟踪和指标来使该服务为生产做好准备，然后您将把所有东西放入Docker容器中，准备进行部署。</p><p id="e7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL现在是一项至关重要的API技术。脸书、网飞、Spotify、Shopify和许多更著名的科技公司都在构建和维护这样的API。特别是联邦GraphQL APIs(这些API带有一个API网关和许多单独的微服务，组成一个大型超图)为表带来了很大的灵活性。团队可以独立工作，同时为单个API表面做出贡献，使客户可以在单个端点上轻松使用他们可能需要的任何后端功能，同时足够灵活，只查询他们真正需要的数据。</p><p id="4363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，您很可能会遇到实现GraphQL API的任务。也许您已经构建了GraphQL APIs，并且正在寻找更令人兴奋的方法来构建它们。在任何一种情况下，这个指南都适合你。</p><p id="2c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<strong class="lb iu">快速提示:</strong>如果您在浏览本指南时遇到困难，您可以在这里找到<a class="ae ki" href="https://github.com/oliverjumpertz/axum-graphql" rel="noopener ugc nofollow" target="_blank">的完整代码</a>。)</p><h1 id="f9ac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于Rust和GraphQL</h1><h2 id="10dc" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">GraphQL</h2><p id="ae5e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><a class="ae ki" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>是一种用于API的开源数据查询和操作语言，也是一个用现有数据完成查询的运行时。它最初于2012年在脸书开发，并于2016年公开发布。</p><p id="21f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，许多公司，如网飞、Spotify、Shopify等，都构建了GraphQL APIs，因为该技术比传统的REST APIs为客户端提供了更多的灵活性。客户端可以指定它们想要获取的数据，只有客户端请求的数据才会从API端点返回。使用GraphQL，带有许多不需要的字段的大型JSON blobs已经成为过去。</p><h2 id="d634" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">锈</h2><p id="045b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Rust是一种静态类型的系统编程语言，可以编译成机器代码。它在运行时的速度通常与C和C++相当，同时提供了现代语言结构和丰富成熟的生态系统。有了固执己见的工具和快速增长的生态系统，Rust是在考虑一种新的编程语言来学习或构建您的系统时要考虑的绝佳人选。</p><h1 id="faff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">准备</h1><p id="38ac" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">本教程假设您使用Unix风格的终端。如果你在Windows上，请看<a class="ae ki" href="https://learn.microsoft.com/en-us/windows/wsl/install" rel="noopener ugc nofollow" target="_blank"> Windows子系统for Linux </a>。如果您决定继续使用Windows，本教程的大部分内容应该是有用的。你需要确保相应地调整你的路径(例如，Windows使用<code class="fe ne nf ng nh b">\</code>而不是<code class="fe ne nf ng nh b">/</code>作为路径分隔符)。</p><p id="fef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有安装Rust，你可以使用<a class="ae ki" href="https://rustup.rs/" rel="noopener ugc nofollow" target="_blank"> rustup作为安装Rust </a>的最快方法，你需要的所有工具都遵循这篇文章。</p><p id="6cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦安装了rustup，或者如果你已经有了一个完整的工具链，确保你使用的至少是Rust版本<code class="fe ne nf ng nh b">1.65.0</code>。</p><p id="64e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不确定安装了哪个版本，可以使用以下命令:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="6904" class="nm lw it nh b be nn no l np nq">❯ rustup show<br/>Default host: x86_64-apple-darwin<br/>rustup home:  /Users/oliverjumpertz/.rustup<br/>installed toolchains<br/>--------------------<br/>stable-x86_64-apple-darwin (default)<br/>1.59.0-x86_64-apple-darwin<br/>1.60.0-x86_64-apple-darwin<br/>1.61.0-x86_64-apple-darwin<br/>1.62.1-x86_64-apple-darwin<br/>1.64.0-x86_64-apple-darwin<br/>1.65.0-x86_64-apple-darwin<br/>active toolchain<br/>----------------<br/>1.65.0-x86_64-apple-darwin (overridden by '/Users/oliverjumpertz/projects/axum-graphql/rust-toolchain.toml')<br/>rustc 1.65.0 (897e37553 2022-11-02)<br/><br/># OR<br/>❯ rustc --version<br/>rustc 1.65.0 (897e37553 2022-11-02)</span></pre><p id="3a34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要的最后一件事是安装<a class="ae ki" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。确保你已经安装了Docker Desktop(Mac和Windows)或者Docker(Linux)本身。</p><h1 id="8b20" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置项目</h1><p id="1189" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">是时候开始用Rust构建你的GraphQL API了。打开您喜爱的终端应用程序，并导航到您想要项目驻留的文件夹。</p><p id="0bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为您的项目创建一个新文件夹，然后直接进入该文件夹:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="7a80" class="nm lw it nh b be nn no l np nq">❯ mkdir axum-graphql<br/>❯ cd axum-graphql</span></pre><p id="4926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您需要使用cargo创建一个新的Rust项目:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="fbb3" class="nm lw it nh b be nn no l np nq">❯ cargo init<br/>Created binary (application) package</span></pre><p id="9b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cargo自动创建一个二进制项目，并为您初始化一个git存储库。您的项目文件夹现在应该如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="5ab8" class="nm lw it nh b be nn no l np nq">| Cargo.toml<br/>| .git/<br/>| .gitignore<br/>| src/<br/>  | main.rs</span></pre><p id="0f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种设置通常足以满足业余爱好项目，但是您需要稳定性，尤其是在构建生产级服务时。</p><p id="279d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果每个开发人员都安装了不同版本的Rust，你很快就会遇到只发生在特定版本上的错误。为了避免这种情况，Cargo提供了一种支持，可以锁定您希望用来构建项目的Rust版本。</p><p id="b790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新文件，并将其命名为<code class="fe ne nf ng nh b">rust-toolchain.toml</code>。然后插入以下内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="3065" class="nm lw it nh b be nn no l np nq">[toolchain]<br/>channel = "1.65.0"</span></pre><p id="4389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行<code class="fe ne nf ng nh b">channel = "1.65.0"</code>告诉cargo，无论何时运行Cargo命令，您都希望Cargo确保您使用Rust版本1.65.0。如果未激活或安装该版本，它会自动为您激活或安装。</p><p id="0658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一件你想做的事情是确保至少某种程度的代码质量。很高兴的是，Rust在它生命的早期就决定固执己见。这意味着有一种官方支持的代码风格。这种代码风格已经在官方的Rust格式化程序<a class="ae ki" href="https://github.com/rust-lang/rustfmt" rel="noopener ugc nofollow" target="_blank"> rustfmt </a>中完全实现。</p><p id="0077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以手动安装rustfmt，但是您必须告诉您潜在的合作伙伴，他们也需要安装这个组件。这就是为什么<code class="fe ne nf ng nh b">rust-toolchain.toml</code>支持所谓的组件(可以做大量工作的工具，比如格式化你的代码)。</p><p id="ff8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面一行<code class="fe ne nf ng nh b">components = [ "rustfmt" ]</code>添加到您的<code class="fe ne nf ng nh b">rust-toolchain.toml</code>中，这会使整个文件看起来像这样:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="65e2" class="nm lw it nh b be nn no l np nq">[toolchain]<br/>channel = "1.65.0"<br/>components = ["rustfmt"]</span></pre><p id="6d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了rustfmt后，现在可以自动格式化代码了。但是，在继续之前，最好将该工具放在一个它可以使用的配置文件中。在您的项目中创建一个名为<code class="fe ne nf ng nh b">.rustfmt.toml</code>的新文件，并添加以下内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="a021" class="nm lw it nh b be nn no l np nq">edition = "2021"<br/>newline_style = "Unix"</span></pre><p id="32b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前这只告诉rustfmt两件事:</p><ul class=""><li id="1cf8" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">你用的Rust的版本是2021</li><li id="db5b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">换行符应该采用Unix风格的格式</li></ul><p id="8ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您想在Docker容器中构建，但自己却在Windows上工作，这就变得很有趣了</p><p id="1c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道你还有哪些配置选项，你可以在这里查看<a class="ae ki" href="https://rust-lang.github.io/rustfmt/?version=v1.5.1&amp;search=" rel="noopener ugc nofollow" target="_blank">设置的完整列表</a>。</p><p id="fdcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在最不需要的就是棉绒。大多数编程语言都有以一种特定的方式做事的方法(通常称为惯用法)，而且它们通常也有一些常见的陷阱。铁锈也不例外。<a class="ae ki" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank"> Clippy是Rust的短绒</a>它附带了550多条林挺规则。这足以确保您避免常见错误，并使您的代码对其他Rust开发人员可读。</p><p id="9637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将另一个条目添加到您的<code class="fe ne nf ng nh b">rust-toolchain.toml</code>中名为<code class="fe ne nf ng nh b">"clippy"</code>的组件中，这会使文件看起来像这样:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="5094" class="nm lw it nh b be nn no l np nq">[toolchain]<br/>channel = "1.65.0"<br/>components = ["rustfmt", "clippy"]</span></pre><p id="2131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与rustfmt一样，Clippy支持一个配置文件，您可以在其中更改特定lints的设置。在您的项目中创建另一个名为<code class="fe ne nf ng nh b">.clippy.toml</code>的文件，并添加以下内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="c0bb" class="nm lw it nh b be nn no l np nq">cognitive-complexity-threshold = 30</span></pre><p id="1a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面一行告诉clippy允许它所分析的任何方法的认知复杂度为30(方法越复杂，越难阅读，编译器也越难优化)。当然，还有更多的设置，你可以在这里查看<a class="ae ki" href="https://rust-lang.github.io/rust-clippy/master/index.html" rel="noopener ugc nofollow" target="_blank">完整的可用棉绒设置列表</a>。</p><p id="4c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有设置和配置后，现在有两个命令可以帮助您lint和格式化代码。</p><p id="4779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">cargo fmt — all</code>检查你的代码，并根据官方风格指南和你在<code class="fe ne nf ng nh b">.rustfmt.toml</code>中配置的规则格式化一切。</p><p id="c3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">cargo clippy — all — tests</code>负责林挺你的代码。</p><p id="5778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是作为Rust的GraphQL API的基础所需要的一切。终于到了跳入实际实现的时候了。</p><h1 id="0808" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建Web服务器</h1><p id="588c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在有很多针对Rust的web服务器实现，通常很难选择正确的一个。您将为您的GraphQL API使用<a class="ae ki" href="https://github.com/tokio-rs/axum" rel="noopener ugc nofollow" target="_blank"> axum </a>来使事情变得更简单。它目前被认为是社区内任何新项目的最佳选择(无论您是否需要HTTP、REST或GraphQL API)。</p><p id="fcd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">axum是由已经构建和维护了<a class="ae ki" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> tokio (Rust最早的异步运行时)</a>的同一批开发人员创建和维护的web框架。它速度快，易于使用，并完美地集成到tokio生态系统中，这使它成为任何规模的项目的可靠选择。</p><p id="32dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是向项目中添加两个依赖项。打开<code class="fe ne nf ng nh b">Cargo.toml</code>并添加以下依赖项:</p><ul class=""><li id="72ae" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">axum</li><li id="a47f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">时男</li></ul><p id="94a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的<code class="fe ne nf ng nh b">Cargo.toml</code>现在应该是这个样子:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="207b" class="nm lw it nh b be nn no l np nq">[package]<br/>edition = "2021"<br/>name = "axum-graphql"<br/>version = "0.1.0"<br/><br/>[dependencies]<br/>axum = "0.5.17"<br/>tokio = {version = "1.18.2", features = ["full"]}</span></pre><p id="cbaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在打开<code class="fe ne nf ng nh b">src/main.rs</code>，用下面的代码替换它的内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="e40b" class="nm lw it nh b be nn no l np nq">use axum::{Router, Server};<br/><br/>#[tokio::main] // (1)<br/>async fn main() {<br/>    let app = Router::new(); // (2)<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap()) // (3)<br/>        .serve(app.into_make_service())<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="422d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速看一下这段代码做了什么:</p><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1): <code class="fe ne nf ng nh b">#[tokio::main]</code>是一个宏，抽象出启动线程池和设置tokio的基本设置逻辑。</p><p id="1bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):路由器是axum路由请求的方式。稍后，您将在这里添加路由，以将不同的端点映射到函数。</p><p id="542a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3): Server是axum的HTTP服务器的实际实现。它接受一个路由器，并为它收到的每个传入请求调用它。</p><p id="f8e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个web服务器的基本实现没有提供任何可以远程调用的方法，但是它是添加更多端点的完美基础。说到端点，您可能应该添加一个您需要的端点(例如，只要您的服务能够在Kubernetes上的容器内运行)。</p><p id="86dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次打开<code class="fe ne nf ng nh b">Cargo.toml</code>并将<a class="ae ki" href="https://serde.rs/" rel="noopener ugc nofollow" target="_blank"> serde </a>添加到您的依赖项中，如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="7820" class="nm lw it nh b be nn no l np nq">[package]<br/>edition = "2021"<br/>name = "axum-graphql"<br/>version = "0.1.0"<br/><br/>[dependencies]<br/>axum = "0.5.17"<br/>tokio = {version = "1.18.2", features = ["full"]}<br/>serde = {version = "1.0.147", features = ["derive"]}</span></pre><p id="4dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">serde是任何想要处理序列化和反序列化的Rust应用程序的默认选择。因为您的端点将使用JSON进行响应，所以您需要这个crate，它的“派生”特性使您能够使用<code class="fe ne nf ng nh b">derive</code>宏为您的任何结构添加完整的JSON支持。</p><p id="4d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在serde是您的项目的一个依赖项，创建一个新文件夹<code class="fe ne nf ng nh b">src/routes</code>并添加一个文件<code class="fe ne nf ng nh b">mod.rs</code>到其中。打开文件并添加以下内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="b138" class="nm lw it nh b be nn no l np nq">use axum::{http::StatusCode, response::IntoResponse, Json};<br/>use serde::Serialize;<br/><br/>#[derive(Serialize)] // (1)<br/>struct Health { // (2)<br/>    healthy: bool<br/>}<br/><br/>pub(crate) async fn health() -&gt; impl IntoResponse { // (3)<br/>    let health = Health {<br/>        healthy: true<br/>    };<br/><br/>    (StatusCode::OK, Json(health)) // (4)<br/>}</span></pre><p id="56a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是上面代码中发生的另一个快速浏览:</p><p id="acd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1): <code class="fe ne nf ng nh b">derive(Serialize)</code>自动为您实现所有逻辑，以便下面的结构可以被序列化(在本例中为JSON)。</p><p id="6b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):健康只是这个特定用例的一个基本结构。它包含一个属性，仅此而已。</p><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):这是即将出现的端点方法。它不需要参数，并返回axum的<code class="fe ne nf ng nh b">IntoResponse</code>，这是一个标记结构的特征，这些结构可以序列化为axum可以理解并返回给用户的响应。</p><p id="1371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4):这个元组响应是axum中返回响应的几种方法之一。在这种情况下，它只是一个HTTP状态代码和一个序列化版本的<code class="fe ne nf ng nh b">Health</code>结构的组合。</p><p id="7c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您需要注册端点方法，以便每当有人向特定路径发出HTTP请求时，axum都可以获取并调用它。在这种情况下，该方法将在路径<code class="fe ne nf ng nh b">/health</code>下可用。</p><p id="75ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ne nf ng nh b">src/main.rs</code>并注册您的新方法，如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="0035" class="nm lw it nh b be nn no l np nq">use crate::routes::health;<br/>use axum::{routing::get, Router, Server};<br/><br/>mod routes;<br/><br/>#[tokio::main]<br/>async fn main() {<br/>    let app = Router::new().route("/health", get(health));<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap())<br/>        .serve(app.into_make_service())<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="6441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">route("/health", get(health))</code>告诉axum任何对<code class="fe ne nf ng nh b">/health</code>的HTTP GET请求都应该调用您的方法<code class="fe ne nf ng nh b">health</code>。您可以尝试通过cargo启动您的服务，并使用<code class="fe ne nf ng nh b">curl</code>或其他工具快速发送测试请求:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="da2d" class="nm lw it nh b be nn no l np nq">❯ cargo run<br/>   Compiling axum-graphql v0.1.0 (/Users/oliverjumpertz/projects/axum-graphql)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1.13s<br/>     Running `target/debug/axum-graphql`<br/><br/>❯ curl http://localhost:8000/health   <br/>{"healthy":true}</span></pre><p id="f62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你手头没有curl这样的工具，也不用担心。只需打开您的浏览器并导航到<code class="fe ne nf ng nh b">http://localhost:8000/health</code>，它应该看起来像这样:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi of"><img src="../Images/c95083b61d8e903ab4977c9f68e233a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpQPa7dqbjxY_cFiIfPyUg.png"/></div></div></figure><p id="b0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜，您已经设置了一个基本的web服务器，并实现了您的第一个端点。不过，这还不是GraphQL API。这就是为什么您将在下一步添加GraphQL并实现一个非常基本的模式。</p><h1 id="d29b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加GraphQL</h1><p id="704a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您目前已经有了一个基本的web服务器。现在是时候给它添加GraphQL功能了。</p><p id="0f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从概念上讲，GraphQL(基于HTTP)只不过是位于普通HTTP端点之上的一个附加处理器。它期望通过HTTP POST请求(或带有查询参数的GET)发送一个查询(和变量)，将该数据传递给查询处理器，然后将响应返回给用户。这就是为什么将GraphQL添加到任何Rust web服务器都相对简单的原因。</p><p id="0870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本指南中，您将使用<a class="ae ki" href="https://github.com/async-graphql/async-graphql" rel="noopener ugc nofollow" target="_blank"> async-graphql </a>。它是一个Rust crate，支持最新的GraphQL规范，另外还支持Apollo Federation(包括v2)。</p><p id="390d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次打开<code class="fe ne nf ng nh b">Cargo.toml</code>，再添加两个依赖项:</p><ul class=""><li id="6862" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">async-graphql<br/>-async-graph QL为您的Rust服务增加了graph QL支持</li><li id="cb29" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">async-graphql-axum <br/> -一个集成机箱，提供async-graphql与axum协同工作所需的一切</li></ul><p id="d696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的<code class="fe ne nf ng nh b">Cargo.toml</code>现在应该是这样的:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="b280" class="nm lw it nh b be nn no l np nq">[package]<br/>edition = "2021"<br/>name = "axum-graphql"<br/>version = "0.1.0"<br/><br/>[dependencies]<br/>async-graphql = "4.0.16"<br/>async-graphql-axum = "4.0.16"<br/>axum = "0.5.17"<br/>serde = {version = "1.0.147", features = ["derive"]}<br/>tokio = {version = "1.18.2", features = ["full"]}</span></pre><p id="c01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您的项目中已经有了async-graphql，您可以开始向您的服务添加graphql支持了。</p><p id="085d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL服务需要一些模式和模型来工作。在async-graphql的情况下，您可以使用代码优先的方法进行模式设计。这意味着您在代码中创建模式，添加宏，然后crate为您正确地映射一切。</p><p id="90d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新文件夹<code class="fe ne nf ng nh b">src/model</code>并添加一个文件<code class="fe ne nf ng nh b">mod.rs</code>到其中。然后添加以下内容(作为您的第一个模型/模式):</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="ad3b" class="nm lw it nh b be nn no l np nq">use async_graphql::{Context, Object, Schema};<br/>use async_graphql::{EmptyMutation, EmptySubscription};<br/><br/>pub(crate) type ServiceSchema = Schema&lt;QueryRoot, EmptyMutation, EmptySubscription&gt;;<br/><br/>pub(crate) struct QueryRoot; // (1)<br/><br/>#[Object] // (2)<br/>impl QueryRoot { // (3)<br/>    async fn hello(&amp;self, _ctx: &amp;Context&lt;'_&gt;) -&gt; &amp;'static str { // (4)<br/>        "Hello world"<br/>    }<br/>}</span></pre><p id="1d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速回顾一下这段代码的作用:</p><p id="40bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):这是您的模式中的<code class="fe ne nf ng nh b">Query</code>对象。它是用户可以在您的服务中使用的所有查询的根。</p><p id="100d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):<code class="fe ne nf ng nh b">Object</code>宏将Rust结构与async-graphql的底层框架逻辑连接在一起。</p><p id="b016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):<code class="fe ne nf ng nh b">QueryRoot</code>的实现包含了您的服务支持的所有查询。</p><p id="b9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4): <code class="fe ne nf ng nh b">hello</code>是你的第一个查询。它只是暂时返回一个静态字符串。</p><p id="e129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候创建处理函数来处理传入的GraphQL查询了。打开<code class="fe ne nf ng nh b">src/routes/mod.rs</code>并添加以下代码:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="369b" class="nm lw it nh b be nn no l np nq">use crate::model::ServiceSchema;<br/>use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};<br/>use async_graphql_axum::{GraphQLRequest, GraphQLResponse};<br/>use axum::{<br/>    extract::Extension,<br/>    http::StatusCode,<br/>    response::{Html, IntoResponse},<br/>    Json,<br/>};<br/>use serde::Serialize;<br/><br/>#[derive(Serialize)]<br/>struct Health {<br/>    healthy: bool,<br/>}<br/><br/>pub(crate) async fn health() -&gt; impl IntoResponse {<br/>    let health = Health { healthy: true };<br/><br/>    (StatusCode::OK, Json(health))<br/>}<br/><br/>// Your two new functions start here<br/>pub(crate) async fn graphql_playground() -&gt; impl IntoResponse {<br/>    Html(playground_source( // (1)<br/>        GraphQLPlaygroundConfig::new("/").subscription_endpoint("/ws"),<br/>    ))<br/>}<br/><br/>pub(crate) async fn graphql_handler(<br/>    req: GraphQLRequest,<br/>    Extension(schema): Extension&lt;ServiceSchema&gt;, // (2)<br/>) -&gt; GraphQLResponse {<br/>    schema.execute(req.into_inner()).await.into() // (3)<br/>}</span></pre><p id="44d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您正在慢慢接近完成Rust服务的基本GraphQL支持，但是有一些新的东西需要您首先了解:</p><p id="2e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<strong class="lb iu"> 1 </strong> ): async-graphql附带了一个GraphQL Playground的完整实现。幸运的是，您可以将它称为一个函数，并将其包装在axum的<code class="fe ne nf ng nh b">Html</code>助手中，该助手负责正确返回所有内容。</p><p id="2fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<strong class="lb iu">2</strong>):graph QL处理函数接收请求，更重要的是，接收您设计和实现的模式的实例。<code class="fe ne nf ng nh b">Extension</code>是axum的一个特殊助手，它允许您向处理程序函数添加数据和其他特定于上下文的内容。</p><p id="5ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<strong class="lb iu"> 3 </strong>):还记得我跟你说过，GraphQL over HTTP在概念上不过是一个带有特殊处理器的API端点？这正是这里发生的事情。实际的逻辑是在<code class="fe ne nf ng nh b">schema.execute(...)</code>中实现的，因此这是您在这里需要执行的唯一调用。</p><p id="68e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了这些新的处理程序，是时候集成它们了。再次打开<code class="fe ne nf ng nh b">src/main.rs</code>，像这样注册游戏场和手柄:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="73e9" class="nm lw it nh b be nn no l np nq">use crate::model::QueryRoot;<br/>use crate::routes::{graphql_handler, graphql_playground, health};<br/>use async_graphql::{EmptyMutation, EmptySubscription, Schema};<br/>use axum::{extract::Extension, routing::get, Router, Server};<br/><br/>mod model;<br/>mod routes;<br/><br/>#[tokio::main]<br/>async fn main() {<br/>    // You now need to build your schema<br/>    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription).finish();<br/><br/>    let app = Router::new()<br/>        // Both routes are registered here<br/>        .route("/", get(graphql_playground).post(graphql_handler))<br/>        .route("/health", get(health))<br/>        // You need to make the schema available to your route handlers<br/>        .layer(Extension(schema)); // (1)<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap())<br/>        .serve(app.into_make_service())<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="5700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，您只需要理解一件事:</p><p id="df6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):您需要可以在端点中访问编译的模式。通过为axum提供一个层，您可以做到这一点。您在上面几行构建的模式现在被传递到axum中，因此您可以在GraphQL处理程序中访问它。</p><p id="f918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候测试您的GraphQL API是否工作了。用<code class="fe ne nf ng nh b">cargo run</code>启动你的服务，打开浏览器，导航到<code class="fe ne nf ng nh b">http://localhost:8000</code>。您应该看到类似如下的视图:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi og"><img src="../Images/c2d06b4014561b96e2c417c42711ff9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpDy6lQd4IrwpRG-gKPeSQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">这是操场。您可以在这里输入查询并使用您的API(因此得名)。</p></figure><p id="3416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试运行您之前实现的查询，以测试您的实现是否有效。在左侧输入查询，然后单击播放按钮:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi og"><img src="../Images/fd7704183c7946b45a82c72931f080ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79Vf1TGCBSU-Lixu1dVcWw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">当您在左侧输入查询时，您可以按播放按钮并运行这些查询。然后，响应显示在右侧。</p></figure><p id="7236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的服务成功地返回了上图中看到的响应，那么您已经用Rust完成了一个基本的GraphQL API的设置。接下来，您将通过向服务添加度量来关注API的可观察性。</p><h1 id="8a8e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加指标</h1><p id="364b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">大多数微服务运行在Docker容器中，这些容器现在部署在Kubernetes上。通常，必须有人来看看这些服务在部署时的表现。度量是使您的服务可观察的一种方式。</p><p id="5b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过发布某些关键指标，您可以更好地了解GraphQL API如何执行，以及在运行和处理请求时可能会遇到什么问题。像<a class="ae ki" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>这样的服务会定期抓取暴露指标的端点，然后这些指标可以用于在像<a class="ae ki" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>这样的工具中创建图表。</p><p id="0498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次打开<code class="fe ne nf ng nh b">Cargo.toml</code>，添加两个新的依赖项:</p><ul class=""><li id="9e3e" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/metrics-rs/metrics" rel="noopener ugc nofollow" target="_blank">指标</a> —为收集指标提供一个门面。它负责收集指标并将它们存储在内部</li><li id="ad20" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/metrics-rs/metrics/tree/main/metrics-exporter-prometheus" rel="noopener ugc nofollow" target="_blank">metrics-exporter-prometheus</a>—这种板条箱为您的服务增加了与Prometheus兼容的功能</li></ul><p id="7c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，该文件现在应该如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="341b" class="nm lw it nh b be nn no l np nq">[package]<br/>edition = "2021"<br/>name = "axum-graphql"<br/>version = "0.1.0"<br/><br/>[dependencies]<br/>async-graphql = "4.0.16"<br/>async-graphql-axum = "4.0.16"<br/>axum = "0.5.17"<br/>metrics = "0.20.1"<br/>metrics-exporter-prometheus = "0.11.0"<br/>serde = {version = "1.0.147", features = ["derive"]}<br/>tokio = {version = "1.18.2", features = ["full"]}</span></pre><p id="67b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了这两个依赖项之后，您就可以开始设置您的指标了。集成相对简单。从概念上讲，度量标准需要某种形式的注册表来注册度量标准。每当您想要使用这些注册的指标时，您需要从注册表中检索它们，添加一个新值，或者增加一个计数器(或者其他任何东西)。</p><p id="9206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着至少您必须设置一次度量注册表，并将其集成到axum中。此外，您还希望记录一些指标，这就是为什么您还将添加一些最基本的指标:</p><ul class=""><li id="48e2" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">计算针对您的API的请求数量</li><li id="58bb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">记录每个请求实际花费的时间</li></ul><p id="4eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新文件夹<code class="fe ne nf ng nh b">src/observability</code>并添加一个文件<code class="fe ne nf ng nh b">metrics.rs</code>。然后添加以下代码:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="ce8a" class="nm lw it nh b be nn no l np nq">use axum::{extract::MatchedPath, http::Request, middleware::Next, response::IntoResponse};<br/>use metrics_exporter_prometheus::{Matcher, PrometheusBuilder, PrometheusHandle};<br/>use std::time::Instant;<br/><br/>const REQUEST_DURATION_METRIC_NAME: &amp;str = "http_requests_duration_seconds";<br/><br/>pub(crate) fn create_prometheus_recorder() -&gt; PrometheusHandle { // (1)<br/>    const EXPONENTIAL_SECONDS: &amp;[f64] = &amp;[<br/>        0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0,<br/>    ];<br/><br/>    PrometheusBuilder::new()<br/>        .set_buckets_for_metric( // (2)<br/>            Matcher::Full(REQUEST_DURATION_METRIC_NAME.to_string()),<br/>            EXPONENTIAL_SECONDS,<br/>        )<br/>        .unwrap_or_else(|_| {<br/>            panic!(<br/>                "Could not initialize the bucket for '{}'",<br/>                REQUEST_DURATION_METRIC_NAME<br/>            )<br/>        })<br/>        .install_recorder()<br/>        .expect("Could not install the Prometheus recorder")<br/>}<br/><br/>pub(crate) async fn track_metrics&lt;B&gt;(req: Request&lt;B&gt;, next: Next&lt;B&gt;) -&gt; impl IntoResponse { // (3)<br/>    let start = Instant::now();<br/>    let path = if let Some(matched_path) = req.extensions().get::&lt;MatchedPath&gt;() {<br/>        matched_path.as_str().to_owned()<br/>    } else {<br/>        req.uri().path().to_owned()<br/>    };<br/>    let method = req.method().clone();<br/><br/>    let response = next.run(req).await;<br/><br/>    let latency = start.elapsed().as_secs_f64();<br/>    let status = response.status().as_u16().to_string();<br/><br/>    let labels = [<br/>        ("method", method.to_string()),<br/>        ("path", path),<br/>        ("status", status),<br/>    ];<br/><br/>    metrics::increment_counter!("http_requests_total", &amp;labels); // (4)<br/>    metrics::histogram!(REQUEST_DURATION_METRIC_NAME, latency, &amp;labels);<br/><br/>    response<br/>}</span></pre><p id="66cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您更好地了解上面的代码中到底发生了什么，让我们再仔细看看:</p><p id="7ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1): <code class="fe ne nf ng nh b">create_prometheus_recorder</code>只是一个简单的函数，它返回一个<code class="fe ne nf ng nh b">PrometheusHandle</code>。后者是指标箱的一个构造。用简单的术语解释:这是一种访问实际记录器的方法，记录器是存储您记录的所有指标的注册表。</p><p id="ef6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):桶是所谓直方图所需的构造。你可以把它想象成真正的水桶并排放在一起。每当您为直方图记录一个新条目时，它会自动分类到它所适合的存储桶中。这意味着你不能得到精确的值。每个值都被分类到适合它的最小存储桶中。</p><p id="b446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):该函数的任务是记录对您的服务的请求所花费的时间。您将立即将其注册为axum的中间件。每当一个请求到达您的API时，就会运行这段代码，收集请求所用的时间，并增加一个计数器，这样您就可以跟踪您的API已经处理了多少个请求。</p><p id="bae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4):这些宏使得使用度量变得更加容易。您通常需要获得一个度量注册中心的实例，并向其中添加度量或者从中检索现有的度量。由于有了这些宏，您只需进行一次调用，而不必担心进一步的实现细节。</p><p id="a58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用这个子模块之前，您需要创建另一个新文件<code class="fe ne nf ng nh b">src/observability/mod.rs</code>并添加以下内容:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="7b98" class="nm lw it nh b be nn no l np nq">pub(crate) mod metrics;</span></pre><p id="27ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将您新创建的模块集成到您的服务中，您必须对您的<code class="fe ne nf ng nh b">main.rs</code>做一些修改。打开文件并添加以下代码，这将使整个文件如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="51f7" class="nm lw it nh b be nn no l np nq">use crate::model::QueryRoot;<br/>use crate::observability::metrics::{create_prometheus_recorder, track_metrics};<br/>use crate::routes::{graphql_handler, graphql_playground, health};<br/>use async_graphql::{EmptyMutation, EmptySubscription, Schema};<br/>use axum::{extract::Extension, middleware, routing::get, Router, Server};<br/>use std::future::ready;<br/><br/>mod model;<br/>mod observability;<br/>mod routes;<br/><br/>#[tokio::main]<br/>async fn main() {<br/>    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription).finish();<br/><br/>    let prometheus_recorder = create_prometheus_recorder();<br/><br/>    let app = Router::new()<br/>        .route("/", get(graphql_playground).post(graphql_handler))<br/>        .route("/health", get(health))<br/>        .route("/metrics", get(move || ready(prometheus_recorder.render()))) // (1)<br/>        .route_layer(middleware::from_fn(track_metrics)) // (2)<br/>        .layer(Extension(schema));<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap())<br/>        .serve(app.into_make_service())<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="c975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是更多的解释:</p><p id="fed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):这一行看起来有点笨拙，但是最后，它只不过是将您的记录器连接到一个HTTP GET请求(在<code class="fe ne nf ng nh b">/metrics</code>)。</p><p id="56cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):这就把你的追踪功能整合成了一个axum中间件。</p><p id="8412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试您是否成功地将指标集成到您的服务中，使用<code class="fe ne nf ng nh b">cargo run</code>启动您的服务，再次打开您的浏览器，导航到<code class="fe ne nf ng nh b">http://localhost:8000</code>并启动几个查询。之后，导航到<code class="fe ne nf ng nh b">http://localhost:8000/metrics</code>，您应该会看到一些返回的指标，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi og"><img src="../Images/6b1bdc60ea63f99a9f0dd69c7e349d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2-XQCTd72Xxb0G6mSehgg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由您新集成的指标端点返回的普罗米修斯式指标。</p></figure><p id="38cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在开始，您可以使用metrics crate的宏来注册新的指标或添加到现有指标中。你在哪里追踪什么完全取决于你自己。请记住，如果您意识到您不需要某个指标，添加该指标并再次删除它通常比保持盲目要好。</p><h1 id="3899" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加跟踪</h1><p id="d149" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">跟踪是提高GraphQL API可观察性的另一种方法。跟踪通常通过在代码路径周围放置一些上下文来跟踪代码路径的执行，这些上下文称为跨度。在这些时间跨度内，可能会发生某些事件。然后，所有这些事件都被附加到它们各自的范围。反过来，这些跨度连接到它们的父跨度，直到根跨度。如果您知道根span的id，您可以很容易地跟踪任何请求或代码的执行。</p><p id="6b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ki" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>是一个端到端的分布式追踪解决方案。它有自己的前端和多个支持服务，帮助微服务收集或接收跟踪。如今，它建立在分布式追踪标准OpenTelemetry的基础上。</p><p id="028d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数语言都有OpenTelemetry的实现，Rust也不例外。再次打开您的<code class="fe ne nf ng nh b">Cargo.toml</code>，添加以下依赖项:</p><ul class=""><li id="520d" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/tokio-rs/tracing" rel="noopener ugc nofollow" target="_blank">跟踪</a> —实现一个facade(类似于metrics ),并提供宏，使得发出跟踪变得容易</li><li id="d0de" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/tokio-rs/tracing/tree/master/tracing-opentelemetry" rel="noopener ugc nofollow" target="_blank">跟踪-opentelemetry </a> —增加对opentelemetry的支持</li><li id="6ae8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/tokio-rs/tracing/tree/master/tracing-subscriber" rel="noopener ugc nofollow" target="_blank">追踪订户</a>——这个箱子包含了一些实用程序，可以更容易地集成多个输出通道，如Jaeger或登录到stdout</li><li id="da85" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/open-telemetry/opentelemetry-rust" rel="noopener ugc nofollow" target="_blank"> opentelemetry </a> —这个机箱为客户实现了opentelemetry标准</li><li id="0438" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-jaeger" rel="noopener ugc nofollow" target="_blank"> opentelemetry-jaeger </a> —增加jaeger的互操作性</li><li id="7e77" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ki" href="https://github.com/dotenv-rs/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a>——这种板条箱本身与追踪没有太大关系，但总是不得不让一个耶格代理人或收藏家来经营会阻碍当地的发展。您将使用dotenv快速启用或禁用跟踪</li></ul><p id="87cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加完依赖项后，您的<code class="fe ne nf ng nh b">Cargo.toml</code>应该如下所示:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="a62c" class="nm lw it nh b be nn no l np nq">[package]<br/>edition = "2021"<br/>name = "axum-graphql"<br/>version = "0.1.0"<br/><br/>[dependencies]<br/>async-graphql = "4.0.16"<br/>async-graphql-axum = "4.0.16"<br/>axum = "0.5.17"<br/>dotenv = "0.15.0"<br/>metrics = "0.20.1"<br/>metrics-exporter-prometheus = "0.11.0"<br/>opentelemetry = {version = "0.18.0", features = ["rt-tokio"]}<br/>opentelemetry-jaeger = {version = "0.17.0", features = ["rt-tokio"]}<br/>serde = {version = "1.0.147", features = ["derive"]}<br/>tokio = {version = "1.18.2", features = ["full"]}<br/>tracing = "0.1.37"<br/>tracing-opentelemetry = "0.18.0"<br/>tracing-subscriber = {version = "0.3.16", features = ["std", "env-filter"]}</span></pre><p id="8ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您的项目中有了另一组依赖项，那么是时候回到代码上了。您需要创建一个可以用来发出跟踪事件的跟踪器实例。在这种情况下，您将创建一个jaeger代理(通常是在Kubernetes上您的服务舱旁边运行的边车)管道，将这些事件发送到代理。它以构建器的形式出现，最终返回一个跟踪程序，供您以后使用。</p><p id="62ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ne nf ng nh b">src/observability</code>中创建一个名为<code class="fe ne nf ng nh b">tracing.rs</code>的新文件，并添加以下代码:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="d1de" class="nm lw it nh b be nn no l np nq">use opentelemetry::sdk::trace::{self, Sampler};<br/>use opentelemetry::{<br/>    global, runtime::Tokio, sdk::propagation::TraceContextPropagator, sdk::trace::Tracer,<br/>};<br/>use std::env;<br/><br/>struct JaegerConfig { // (1)<br/>    jaeger_agent_host: String,<br/>    jaeger_agent_port: String,<br/>    jaeger_tracing_service_name: String,<br/>}<br/><br/>pub fn create_tracer_from_env() -&gt; Option&lt;Tracer&gt; {<br/>    let jaeger_enabled: bool = env::var("JAEGER_ENABLED")<br/>        .unwrap_or_else(|_| "false".into())<br/>        .parse()<br/>        .unwrap();<br/><br/>    if jaeger_enabled {<br/>        let config = get_jaeger_config_from_env();<br/>        Some(init_tracer(config))<br/>    } else {<br/>        None<br/>    }<br/>}<br/><br/>fn init_tracer(config: JaegerConfig) -&gt; Tracer {<br/>    global::set_text_map_propagator(TraceContextPropagator::new()); // (2)<br/>    opentelemetry_jaeger::new_agent_pipeline() // (3)<br/>        .with_endpoint(format!(<br/>            "{}:{}",<br/>            config.jaeger_agent_host, config.jaeger_agent_port<br/>        ))<br/>        .with_auto_split_batch(true)<br/>        .with_service_name(config.jaeger_tracing_service_name)<br/>        .with_trace_config(trace::config().with_sampler(Sampler::AlwaysOn))<br/>        .install_batch(Tokio)<br/>        .expect("pipeline install error")<br/>}<br/><br/>fn get_jaeger_config_from_env() -&gt; JaegerConfig {<br/>    JaegerConfig {<br/>        jaeger_agent_host: env::var("JAEGER_AGENT_HOST").unwrap_or_else(|_| "localhost".into()),<br/>        jaeger_agent_port: env::var("JAEGER_AGENT_PORT").unwrap_or_else(|_| "6831".into()),<br/>        jaeger_tracing_service_name: env::var("TRACING_SERVICE_NAME")<br/>            .unwrap_or_else(|_| "axum-graphql".into()),<br/>    }<br/>}</span></pre><p id="9433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这又是一小段代码，所以让我们快速浏览一下它最重要的部分:</p><p id="a3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):这只是一个帮助器结构，用于保存配置跟踪器所需的属性。在这种情况下，这是一种设置代理的主机和端口以及注册其跟踪的名称的方法(当您的服务在附加了Jaeger sidecar的Kubernetes中运行时，默认设置通常就足够了)。</p><p id="ff69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):跟踪可以在多个服务之间传播。这一行只是确保跟踪由traceparent头(W3C跟踪上下文传播器)传播。你可以<a class="ae ki" href="https://w3c.github.io/trace-context/" rel="noopener ugc nofollow" target="_blank">在这里</a>了解更多信息。)</p><p id="b9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):管道是创建跟踪器的实际核心逻辑。在这种情况下，一个所谓的代理管道期望向Jaeger代理发送跟踪。它配置了更多的设置，比如设置一个显式的服务名(在Jaeger的UI中找到您的服务的踪迹)和将采样器设置为始终打开，这意味着没有跨度被丢弃，所有内容都被存储。</p><p id="83c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您需要像这样将新创建的模块添加到<code class="fe ne nf ng nh b">src/observability/mod.rs</code>:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="8bfa" class="nm lw it nh b be nn no l np nq">pub(crate) mod metrics;<br/>pub(crate) mod tracing;</span></pre><p id="e7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然您的新模块是可访问的，那么是时候将一切集成到您的服务中了。再次打开<code class="fe ne nf ng nh b">src/main.rs</code>，添加以下代码:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="f452" class="nm lw it nh b be nn no l np nq">use crate::model::QueryRoot;<br/>use crate::observability::metrics::{create_prometheus_recorder, track_metrics};<br/>use crate::observability::tracing::create_tracer_from_env;<br/>use crate::routes::{graphql_handler, graphql_playground, health};<br/>use async_graphql::{EmptyMutation, EmptySubscription, Schema};<br/>use axum::{extract::Extension, middleware, routing::get, Router, Server};<br/>use dotenv::dotenv;<br/>use std::future::ready;<br/>use tracing::info;<br/>use tracing_subscriber::layer::SubscriberExt;<br/>use tracing_subscriber::util::SubscriberInitExt;<br/>use tracing_subscriber::Registry;<br/><br/>mod model;<br/>mod observability;<br/>mod routes;<br/><br/>#[tokio::main]<br/>async fn main() {<br/>    // You need to add this<br/>    dotenv().ok(); // (1)<br/><br/>    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription).finish();<br/><br/>    let prometheus_recorder = create_prometheus_recorder();<br/><br/>    // and you need to add the code below to initialize tracing correctly<br/>    let registry = Registry::default().with(tracing_subscriber::fmt::layer().pretty()); // (2)<br/><br/>    match create_tracer_from_env() { // (3)<br/>        Some(tracer) =&gt; registry<br/>            .with(tracing_opentelemetry::layer().with_tracer(tracer))<br/>            .try_init()<br/>            .expect("Failed to register tracer with registry"),<br/>        None =&gt; registry<br/>            .try_init()<br/>            .expect("Failed to register tracer with registry"),<br/>    }<br/><br/>    info!("Service starting"); // (4)<br/><br/>    let app = Router::new()<br/>        .route("/", get(graphql_playground).post(graphql_handler))<br/>        .route("/health", get(health))<br/>        .route("/metrics", get(move || ready(prometheus_recorder.render())))<br/>        .route_layer(middleware::from_fn(track_metrics))<br/>        .layer(Extension(schema));<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap())<br/>        .serve(app.into_make_service())<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="099c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又有一些新的代码需要理解，所以让我们复习一下重要的部分:</p><p id="b538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):这是设置dotenv需要做的所有事情。您将在几秒钟内创建一个小dotenv文件，以便在本地开发时快速启用或禁用Jaeger exporter。</p><p id="7caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):注册表是注册所谓跟踪层的一种方式。在这种情况下，将添加一个记录到stdout的跟踪器。这确保了您总是有一些用于调试目的的日志消息。</p><p id="776b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):可以禁用Jaeger导出。这就是为什么你需要检查是否有追踪器让你额外注册。否则，该服务将通过登录到stdout来运行。如果启用了Jaeger，标准输出记录和导出到Jaeger代理都会被注册。</p><p id="8ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4):该宏是记录或跟踪特定事件的方法之一。</p><p id="cb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经集成了跟踪，那么创建一些跟踪可能是个好主意。一个跟踪跨度绝对属于的地方是对GraphQL端点的任何调用。您可以创建一个根范围，您在处理GraphQL请求时创建的所有其他范围或事件都附加到该根范围。</p><p id="4a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跳回<code class="fe ne nf ng nh b">src/routes/mod.rs</code>，将代码更改如下:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="183e" class="nm lw it nh b be nn no l np nq">use crate::model::ServiceSchema;<br/>use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};<br/>use async_graphql_axum::{GraphQLRequest, GraphQLResponse};<br/>use axum::{<br/>    extract::Extension,<br/>    http::StatusCode,<br/>    response::{Html, IntoResponse},<br/>    Json,<br/>};<br/>use opentelemetry::trace::TraceContextExt;<br/>use serde::Serialize;<br/>use tracing::{info, span, Instrument, Level};<br/>use tracing_opentelemetry::OpenTelemetrySpanExt;<br/><br/>#[derive(Serialize)]<br/>struct Health {<br/>    healthy: bool,<br/>}<br/><br/>pub(crate) async fn health() -&gt; impl IntoResponse {<br/>    let health = Health { healthy: true };<br/><br/>    (StatusCode::OK, Json(health))<br/>}<br/><br/>pub(crate) async fn graphql_playground() -&gt; impl IntoResponse {<br/>    Html(playground_source(<br/>        GraphQLPlaygroundConfig::new("/").subscription_endpoint("/ws"),<br/>    ))<br/>}<br/><br/>pub(crate) async fn graphql_handler(<br/>    req: GraphQLRequest,<br/>    Extension(schema): Extension&lt;ServiceSchema&gt;,<br/>) -&gt; GraphQLResponse {<br/>    // Your newly refactored and improved graphql_handler starts here<br/>    let span = span!(Level::INFO, "graphql_execution"); // (1)<br/><br/>    info!("Processing GraphQL request");<br/><br/>    let response = async move { schema.execute(req.into_inner()).await } // (2)<br/>        .instrument(span.clone())<br/>        .await;<br/><br/>    info!("Processing GraphQL request finished");<br/><br/>    response<br/>        .extension( // (3)<br/>            "traceId",<br/>            async_graphql::Value::String(format!(<br/>                "{}",<br/>                span.context().span().span_context().trace_id()<br/>            )),<br/>        )<br/>        .into()<br/>}</span></pre><p id="67ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看上面代码中最重要的部分发生了什么:</p><p id="174b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):跨度可以说是一个语境。在一个范围内，所有事件和进一步的范围都附加到该范围。这有助于创建在语义和技术上属于一起的事件块。</p><p id="36c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):要理解为什么这个异步块是必要的，你需要理解异步函数是如何工作的。在任何执行点，异步函数都可以停止执行。span的生命周期与其保护者的生命周期是绑定在一起的。当你进入一个跨度，有一个后卫返回。当这个保护被丢弃时，span被退出。当一个异步函数的执行被中止时，保护不会被放弃；因此，其他代码将在此范围内发出跟踪。这就是为什么您需要使用span来检测异步块。</p><p id="a10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3):有跨度和跟踪是很好的，但是返回跟踪id也是一个好主意，这样用户就可以在遇到错误时给你一些可以搜索的东西。这就是为什么将跟踪id放入GraphQL响应的扩展中。</p><p id="8d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们可以禁用耶格追踪吗？默认值已经是false，但是如果您想要在本地启用它，您必须将环境变量设置为true来启动您的服务。一个更好的方法是使用一个<code class="fe ne nf ng nh b">.env</code>文件，你可以快速打开，调整值，然后再次启动你的服务。</p><p id="bbe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的项目根目录下快速添加一个新文件<code class="fe ne nf ng nh b">.env</code>，并添加以下内容，确保你的jaeger exporter被启用(不要忘记将<code class="fe ne nf ng nh b">.env</code>添加到你的<code class="fe ne nf ng nh b">.gitignore</code>)。您不希望秘密泄露到公共git存储库中！):</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="4099" class="nm lw it nh b be nn no l np nq">JAEGER_ENABLED=true</span></pre><p id="f29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你快完成了。您只需要做最后一件事，但让我们先来看看运行时跟踪的过程(简化):</p><ul class=""><li id="39c1" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">您的代码发出跟踪</li><li id="11af" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">这些痕迹被收集起来</li><li id="4865" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">收集更多的痕迹</li><li id="23f8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">跟踪信息会定期发送给代理</li></ul><p id="e802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着在收集跟踪和关闭服务之间有一个短暂的窗口，其中一些跟踪可能会丢失。当您的GraphQL API在Kubernetes中运行时尤其如此，在Kubernetes中可以随时重新安排pods。令人高兴的是，axum有一个关闭挂钩，OpenTelemetry有一个功能可以明确触发关闭您的跟踪器，在它们丢失之前发送任何留下的痕迹。</p><p id="4f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe ne nf ng nh b">src/main.rs</code>并添加以下代码，使您的服务和跟踪能够正常关闭:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="aa80" class="nm lw it nh b be nn no l np nq">use crate::model::QueryRoot;<br/>use crate::observability::metrics::{create_prometheus_recorder, track_metrics};<br/>use crate::observability::tracing::create_tracer_from_env;<br/>use crate::routes::{graphql_handler, graphql_playground, health};<br/>use async_graphql::{EmptyMutation, EmptySubscription, Schema};<br/>use axum::{extract::Extension, middleware, routing::get, Router, Server};<br/>use dotenv::dotenv;<br/>use std::future::ready;<br/>use tokio::signal;<br/>use tracing::info;<br/>use tracing_subscriber::layer::SubscriberExt;<br/>use tracing_subscriber::util::SubscriberInitExt;<br/>use tracing_subscriber::Registry;<br/><br/>mod model;<br/>mod observability;<br/>mod routes;<br/><br/>// A new shutdown signal handler<br/>async fn shutdown_signal() { // (1)<br/>    let ctrl_c = async {<br/>        signal::ctrl_c()<br/>            .await<br/>            .expect("failed to install Ctrl+C handler");<br/>    };<br/><br/>    #[cfg(unix)]<br/>    let terminate = async {<br/>        signal::unix::signal(signal::unix::SignalKind::terminate())<br/>            .expect("failed to install signal handler")<br/>            .recv()<br/>            .await;<br/>    };<br/><br/>    #[cfg(not(unix))]<br/>    let terminate = std::future::pending::&lt;()&gt;();<br/><br/>    tokio::select! {<br/>        _ = ctrl_c =&gt; {},<br/>        _ = terminate =&gt; {},<br/>    }<br/><br/>    opentelemetry::global::shutdown_tracer_provider();<br/>}<br/><br/>#[tokio::main]<br/>async fn main() {<br/>    dotenv().ok();<br/><br/>    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription).finish();<br/><br/>    let prometheus_recorder = create_prometheus_recorder();<br/><br/>    let registry = Registry::default().with(tracing_subscriber::fmt::layer().pretty());<br/><br/>    match create_tracer_from_env() {<br/>        Some(tracer) =&gt; registry<br/>            .with(tracing_opentelemetry::layer().with_tracer(tracer))<br/>            .try_init()<br/>            .expect("Failed to register tracer with registry"),<br/>        None =&gt; registry<br/>            .try_init()<br/>            .expect("Failed to register tracer with registry"),<br/>    }<br/><br/>    info!("Service starting");<br/><br/>    let app = Router::new()<br/>        .route("/", get(graphql_playground).post(graphql_handler))<br/>        .route("/health", get(health))<br/>        .route("/metrics", get(move || ready(prometheus_recorder.render())))<br/>        .route_layer(middleware::from_fn(track_metrics))<br/>        .layer(Extension(schema));<br/><br/>    Server::bind(&amp;"0.0.0.0:8000".parse().unwrap())<br/>        .serve(app.into_make_service())<br/>        // You need to register the signal handler here<br/>        .with_graceful_shutdown(shutdown_signal()) // (2)<br/>        .await<br/>        .unwrap();<br/>}</span></pre><p id="cf9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次看看上面代码中的重要行:</p><p id="07e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1):这个函数正好做两件事:它首先等待两个可能的关闭信号之一，并且一旦它接收到一个，它就触发跟踪系统的关闭。</p><p id="8d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">②:<code class="fe ne nf ng nh b">with_graceful_shutdown</code>获得一个未来。如果未来解决了，服务将关闭。这正是函数接收到终止信号时的情况。</p><p id="7d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是测试一切是否如预期那样工作的时候了。Jaeger很乐意提供一个一体化的Docker映像，它拥有您需要的一切。当然，这不是通常应该使用的方式，但足以测试您的服务是否按预期发出跟踪。</p><p id="acc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开终端并执行以下命令:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="478e" class="nm lw it nh b be nn no l np nq">❯ docker run -d --name jaeger \<br/>  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \<br/>  -p 5775:5775/udp \<br/>  -p 6831:6831/udp \<br/>  -p 6832:6832/udp \<br/>  -p 5778:5778 \<br/>  -p 16686:16686 \<br/>  -p 14268:14268 \<br/>  -p 9411:9411 \<br/>  jaegertracing/all-in-one:1.6</span></pre><p id="f72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将启动一个docker容器，其中包含一个Jaeger代理、Jaeger本身、一个前端以及更多内容。</p><p id="ec3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，用<code class="fe ne nf ng nh b">cargo run</code>启动您的服务，并通过GraphQL Playground执行一些请求。之后，打开一个新的浏览器选项卡并导航至<code class="fe ne nf ng nh b">http://localhost:16686/search</code>。从左侧的下拉列表中选择axum-graphql(或者您称之为服务的任何其他名称)，然后单击“Find Traces”这将为您呈现如下视图:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi og"><img src="../Images/0fc82ac17e20e8b53e5c7090babcf8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peQRDowOLTuYI6fcKOHoYQ.png"/></div></div></figure><p id="2835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看到的和上图类似，恭喜你。基本的设置现在已经完成，只剩下一件事要做:用Rust封装您的GraphQL API。</p><h1 id="2960" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">容器化您的GraphQL API</h1><p id="a513" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如今，大多数服务都被容器化了，你的GraphQL API也不例外。是时候为您的服务创建一个容器了，您几乎可以将它部署到任何地方。</p><p id="2e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您首先应该创建一个<code class="fe ne nf ng nh b">.dockerignore</code>文件。这确保了Docker守护进程不会拾取不必要的文件。例如，如果您自己不在Linux机器上工作，那么您的目标文件夹就毫无用处。</p><p id="ccfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下内容放入您的<code class="fe ne nf ng nh b">.dockerignore</code>:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="efbb" class="nm lw it nh b be nn no l np nq">target/<br/>.git/<br/>.env</span></pre><p id="961d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要的下一件东西是一个<code class="fe ne nf ng nh b">Dockerfile</code>。创建一个并添加以下行:</p><pre class="kk kl km kn gt ni nh nj bn nk nl bi"><span id="da87" class="nm lw it nh b be nn no l np nq">FROM --platform=linux/amd64 lukemathwalker/cargo-chef:latest-rust-1.65.0 AS chef # (1)<br/><br/>WORKDIR /app<br/><br/>FROM --platform=linux/amd64 chef AS planner<br/><br/>COPY . .<br/><br/>RUN cargo chef prepare --recipe-path recipe.json<br/><br/>FROM --platform=linux/amd64 chef AS builder<br/><br/>COPY --from=planner /app/recipe.json recipe.json<br/><br/>RUN cargo chef cook --release --recipe-path recipe.json<br/><br/>COPY . .<br/><br/>RUN cargo build --release<br/><br/>FROM debian:bookworm-slim<br/><br/>RUN mkdir -p /app<br/><br/>RUN groupadd -g 999 appuser &amp;&amp; \ # (2)<br/>    useradd -r -u 999 -g appuser appuser<br/><br/>USER appuser<br/><br/>COPY --from=builder /app/target/release/axum-graphql /app<br/><br/>WORKDIR /app<br/><br/>ENV JAEGER_ENABLED=true<br/><br/>EXPOSE 8000<br/><br/>ENTRYPOINT ["./axum-graphql"]</span></pre><p id="3e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经这样了。只有两件事可能需要专门的解释:</p><p id="8f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1): cargo-chef是一个工具，可以更容易地使用Docker的层系统。这大大加快了构建容器的过程。你可以在这里了解更多关于cargo-chef的信息。</p><p id="e4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2):以root身份在容器中运行任何软件从来都不是一个好主意。一个新的用户很快就被创建了，并使你(很可能)免受某些攻击。</p><p id="7dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在可以用<code class="fe ne nf ng nh b">docker build -t axum-graphql:latest .</code>构建你的容器，并用<code class="fe ne nf ng nh b">docker run -p 8000:8000 axum-graphql:latest</code>快速启动它。然后再次打开浏览器，导航至<code class="fe ne nf ng nh b">http://localhost:8000</code>。你应该看到操场运行，并能够发送一些查询。</p><p id="6bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正常，就大功告成了。恭喜你！</p><h1 id="1e49" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速回顾一下</h1><p id="8d6d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">是时候快速回顾一下到目前为止你所取得的成绩了。</p><p id="3e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有:</p><ul class=""><li id="84b5" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">建立一个新的Rust项目</li><li id="5bff" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">添加了格式和林挺</li><li id="be29" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">创建了一个基本的web服务器</li><li id="70d7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">在上面添加了一个非常基本但有效的GraphQL API</li><li id="1931" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">将指标集成到您的服务中，并注册(和收集)一些最重要的指标</li><li id="ddf7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">在顶部添加了跟踪并创建了一个根跨度</li><li id="7b00" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">将您的应用程序容器化，这样您几乎可以将它部署到任何地方</li></ul><p id="a5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是相当大的成就。再次恭喜你！</p><h1 id="7c54" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">下一步是什么？</h1><p id="43b1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">从现在开始，您可以自由地使用新的GraphQL API了。如果你对想要实现的API有什么计划，可以看看<a class="ae ki" href="https://async-graphql.github.io/async-graphql/en/index.html" rel="noopener ugc nofollow" target="_blank"> async-graphql的书</a>。它回答了您在使用Rust实现更高级的GraphQL API时可能会遇到的大多数问题。关于GraphQL和Rust，你还可以学到不少东西。</p><p id="2705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想更进一步，创建一个<a class="ae ki" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>图表，并尝试将您的服务部署到一个真正的Kubernetes集群(或者像<a class="ae ki" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> minikube </a>这样的本地版本)。你会发现这也是另一个挑战性的任务，教会了你很多。</p></div></div>    
</body>
</html>