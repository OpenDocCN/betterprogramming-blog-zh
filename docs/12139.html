<html>
<head>
<title>Build an App for SpaceX Using Clean Architecture in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中使用Clean Architecture为SpaceX构建应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-architecture-in-ios-a5963e61fd8?source=collection_archive---------1-----------------------#2022-05-15">https://betterprogramming.pub/clean-architecture-in-ios-a5963e61fd8?source=collection_archive---------1-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38d7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建一个发射台</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f52df68b9ce1eff3bafb7a7b8a263aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5dXhGHkn1wlF0gIm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@ivvndiaz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊万·迪亚兹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="19eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本演练中，我们将学习如何使用VIP clean architecture模式为Apple平台开发应用程序。</p><p id="2c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将开发一个干净的SpaceX应用程序，在那里我们将展示关于SpaceX已经制造和实验的火箭的信息。</p><h1 id="a863" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是VIP？</h1><p id="e781" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与MVVM、MVC或VIPER相比，VIP架构模式是iOS开发中最不为人知的模式之一。它们基本上是Bob叔叔的干净架构模式的不同实现。</p><p id="5cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">VIP仅仅代表视图-交互者-演示者。</p><p id="a7ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于编写干净Swift代码的VIP架构是由Raymond Law引入的。他创建了一个<a class="ae kv" href="https://clean-swift.com/" rel="noopener ugc nofollow" target="_blank"> clean-swift </a>网站，在那里你可以读到如何在UIKit中使用VIP模式。</p><p id="638c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">VIP实际上是为了解决MVC或大规模视图控制器而创建的，这是UIKit应用程序中的一个常见问题，其中视图控制器成为保存代码的主要对象，并且它们变得非常庞大，因为大多数(如果不是全部)逻辑都保存在其中。当你的目标是通过添加越来越多的功能来扩展你的应用程序时，这也会给你带来很多问题。此外，VIP是单向的，这省去了将我们的代码组件相互混淆的麻烦。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/37d8b59773d202e7511ca8112b42d31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zc81S6SKCmwBCgXVUihrkg.png"/></div></div></figure><h2 id="11ba" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">视角</h2><p id="1639" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">视图通常是应用程序的用户界面。它的作用是在每次用户与UI交互时向交互器发送请求。</p><h2 id="1b48" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">互动者</h2><p id="ee34" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">交互器负责应用程序的业务逻辑，比如从网络获取或发送数据，或者将数据保存在数据库中。当视图请求某些东西时，交互器进行处理，并将结果作为响应发送给呈现者。</p><h2 id="ef32" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">提出者</h2><p id="db25" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">演示者处理演示逻辑。它将接收到的数据格式化为适合显示的视图模型，然后将其传递给视图。</p><h1 id="e180" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">CleanSpaceX入门</h1><p id="4e79" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CleanSpaceX是我创建的一个示例项目，用于演示clean architecture的实现。它主要由两个场景组成，即火箭和<code class="fe nc nd ne nf b">RocketDetails</code>。</p><p id="6dc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们的名字很好地说明了它们的用途，火箭场景从它们的<a class="ae kv" href="https://github.com/r-spacex/SpaceX-API" rel="noopener ugc nofollow" target="_blank">开源端点</a>获取SpaceX火箭的列表以及细节，而<code class="fe nc nd ne nf b">RocketDetails</code>场景显示特定选定火箭的细节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f8e3cd0e175c3edf1e51bcc0c9ea32cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Gr32e2PY8U9rwQ7Pr2VREQ.png"/></div></figure><p id="1ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您可以看到创建的场景的结构，每个组件都互不相同。现在让我们一个接一个地看看它们。在此之前，快速预览一下我们将要构建的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2a2a6116789d67f98387fcf267035a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/1*PzLzffHjMuK9NruEXWpucQ.gif"/></div></figure><h1 id="a1e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模型</h1><p id="d6cd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在该组件中，将保存与所需控制器相关的所有模型。它将是struct类型，主要包含请求、响应和<code class="fe nc nd ne nf b">ViewModel</code>结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="474b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的模型中，您可以清楚地看到请求、响应和视图模型的结构，这使得事情变得非常明显。</p><p id="674e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nc nd ne nf b">Request</code>将包括需要发送给任何网络调用(在我们的例子中是发送给SpaceX)的参数。<code class="fe nc nd ne nf b">Response</code>将包括响应我们的网络调用所期望的参数，而<code class="fe nc nd ne nf b">ViewModel</code>是根据用例映射上述参数的部分。</p><h1 id="16c4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">路由器</h1><p id="6c67" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">路由器的工作是执行所有与视图控制器之间转换和传递数据相关的任务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ad28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面我们讨论了两种情况，我们不仅导航到另一个视图控制器，而且我们还将一些数据传递到我们的目的地视图控制器。注意，这里定义了两个协议，分别命名为<code class="fe nc nd ne nf b">RocketData</code> <code class="fe nc nd ne nf b">Passing</code>和<code class="fe nc nd ne nf b">RocketsRoutingLogic</code>。</p><ol class=""><li id="fa07" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><code class="fe nc nd ne nf b">RocketDataPassing</code>是一种协议，包含需要传递到目的地控制器的数据。</li><li id="e2c4" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe nc nd ne nf b">RocketsRoutingLogic</code>是保存用于路由的所有方法的协议。</li></ol><h1 id="e655" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">工人</h1><p id="96d1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Worker组件处理所有网络请求和响应。响应结构(我们在模型中使用的)将为交互器准备好数据。它将处理成功/错误响应，因此交互器将知道如何继续。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="6dd8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">互动者</h1><p id="eb17" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">交互者是其中最重要的组成部分，在工作者和展示者之间起着调节者的作用。最初，它与<code class="fe nc nd ne nf b">ViewController</code>通信，后者传递工人所需的所有请求参数。在进行到Worker之前，会进行一次验证，以检查是否所有内容都被正确发送。工作者返回一个响应，交互者将这个响应传递给呈现者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里要注意的是，使用了几个名为<code class="fe nc nd ne nf b">RocketsDataStore</code>和<code class="fe nc nd ne nf b">RocketsBusinessLogic</code>的协议，它们用于以下目的:</p><ol class=""><li id="7744" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><code class="fe nc nd ne nf b">RocketsDataStore</code> —用于在视图控制器之间传递数据</li><li id="200a" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe nc nd ne nf b">RocketsBusinessLogic</code> —用于声明该协议中的所有Interactor方法，以便它们可以在ViewController中使用。</li></ol><h1 id="4cb4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提出者</h1><p id="2987" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从交互器获得响应后，就该将它格式化为ViewModel，并将结果传递回<code class="fe nc nd ne nf b">ViewController</code>。演示者将负责演示逻辑。该组件决定如何将数据呈现给用户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nc nd ne nf b">Presenter</code>中，只声明了一个存储表示逻辑方法的协议。在<code class="fe nc nd ne nf b">presentFetchRockets()</code>函数中，一个委托方法被调用，这个方法是在我们关联的视图控制器中声明的。这就是它与视图控制器连接的方式。</p><h1 id="8796" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">视图控制器</h1><p id="cd9b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在是时候看到它全部工作了，所有的组件都已经彼此对齐，但是我们仍然需要执行最后一个主要步骤，以便整个流程工作。</p><p id="278f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您可以看到一个简单的表视图已经被声明，它的委托被用来以可表示的形式显示获取的API数据。</p><p id="746c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是触发交互器，它将最终启动我们的循环，发送一个请求，我们将从提交者那里得到一个响应。在此期间，如果用户想导航到某个地方，那么我们将使<code class="fe nc nd ne nf b">Router</code>生效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="316a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="8869" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以从<a class="ae kv" href="https://github.com/mh-ahmediqbal/CleanSpaceX" rel="noopener ugc nofollow" target="_blank">这个链接</a>得到整个项目。请随意使用它，并让我知道任何建议。请注意，我们也可以在Xcode中安装一个干净的swift模板，这将允许我们使用编辑器创建一个完整的场景。</p><p id="1b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解如何配置Xcode，请<a class="ae kv" href="https://medium.com/@mh.ahmediqbal/installing-clean-architecture-template-in-xcode-50b222a93a94" rel="noopener">参考本演练的</a>。</p></div></div>    
</body>
</html>