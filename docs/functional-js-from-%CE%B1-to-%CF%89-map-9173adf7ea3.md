# 从α到ω的泛函 JS:映射

> 原文：<https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3>

## B.地图功能——我们神圣的三位一体中的第一个

> “Map”是一个重要的构造，不仅因为它捕获了一个公共模式，还因为它在处理列表时建立了一个更高层次的抽象。"
> 
> — SICP，1979 年

![](img/0e7f5c313907a394762e5f383284d1d8.png)

照片由 [Devin Edwards](https://unsplash.com/@devindtx) 在 [Unsplash](https://unsplash.com/photos/V7T7_A0FIIY) 上拍摄

> 我们 JavaScript 编码人员有机会实践一种支持函数式编程的多范例语言。
> 
> 你想学习那种力量吗？
> 
> 让我们从 24 课开始，从α到ω，解决我们的日常问题。课程概述: [α。forEach](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1) ， [β。地图](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3)，γ.滤镜。

# 神圣地图

为什么历史上最伟大的编程语言之一被谦逊地命名为 [Lisp](https://lisp-lang.org/) ，用于*列表处理*？

为什么函数式程序员会对一个名为`*map*`的函数大惊小怪？

这些问题的答案都是一样的，都与信息学的本质有关。

我们整天做的就是*重新映射* 0 和 1 链，到其他的 0 和 1 链。它们最终代表了影响现实世界的新信号(给屏幕着色、移动机械臂、构建网站等)。).

总是相同的*图灵完成*过程，并且，现在，我们被那个卡住了。

好消息是，它足以几乎做任何事情！就像原子创造了宇宙，自远古以来不断运动和重组。

即便如此，在你 15 年的编程历程中，你可以忽略`map`的定义，因为它做的非常简单，非常核心。你只是每天不点名地做。

`map` 函数转换列表中的每个元素，并保持其原来的顺序。我们的数据库包含单数形式的鸟类，但我们需要视图中的复数形式:

我们已经在规划过程中。很常见吧？这就是计算机所做的:存储数据(`birds`数组)，运行程序(为每只鸟添加一个`s`的函数)，然后触发动作(在控制台中记录结果)…并重复。

那么，为什么对列表的操作如此重要呢？

因为，在能够使用任何类型的数据之前，我们必须就数据的模型达成一致。

黑白图像文件可以是由`true` 和`false` 像素组成的矩阵。“人”可以包括姓名或年龄。我们很自然地转向那些新的模型，那些形象/人物应该是什么样的结构良好的抽象。

创建抽象的需要来自于在相同类型的几个对象上，用共同的“属性”一次又一次地重复同样的事情的想法…我们最终得到以相同方式格式化的对象列表，也就是所谓的*集合*。

事实上，我们正在描述一个“领域”,在这个领域中，我们将定义存储数据和创建专用代数的方法。

让我们把一个`persons`的集合转换成别的东西:

你能用`setPlurals` 功能找出常见零件吗？

在`persons`的例子中，我们需要一个全新的数组来存储`ages`，因为我们不想删除程序剩余部分的`persons`*——通过网络获取原始的人员列表可能代价很高。*

*为了在一个独特的、可重用的函数中重新分解列表的转换，让我们编写第一个`map`:*

*如您所见，这里的小技巧是为`map`函数本身提供一个函数——在循环过程中`map`会注意在每个元素上运行它。*

*的确，`map`是一个*高阶函数；*将另一个函数(通常称为*回调*)作为参数的函数，然后在自己的主体中运行它。*

*我们的*映射*签名是`map::(Function, any[]) -> any[]`，其中第一个参数`Function`类型是我们的*回调*。第二个参数`any[]`是任何类型元素的数组。并且`map`当然会返回新的`any[]`列表。*

*我们提供给`map`的*回调*的签名应该类似于`callback::any -> any`，代表一个元素的自由转换，应用于每个元素。*

*我们的`map`比`setPlurals`好多了；我们不想修改原始列表，以防以后需要单数形式的鸟。*

# *神圣的数据*

*函数式程序员就是这么想的:不变性。*

*我们不喜欢仅仅根据程序现在应该做什么来改变数据。我们保留原始数据。转换带来了新的数据，为安全调试、重构和未来的改进做好了准备。*

*面向对象哲学和 FP 方法之间的主要对立是，对我们来说，数据是冻结的事实。我们想保护它们，我们想让它们保持原样。*

*对我们来说，函数不应该作为唯一的方法绑定到对象上。你可以用椅子来坐，但你也可以用它来拿架子上的果酱罐。*

*我们假设`chair.sit()`听起来还可以，但是`chair.takeJarJamOfShelf()`呢？为什么不是`person.sit()`，或者`bird.sit()`？这听起来像是你将总是以一个“上帝物品”结束，伴随着产品所有者的新需求。*

*此外，谁知道我们可以在年龄和姓名之间发现什么新的相关性，为我们未来的系谱部门服务？*

*FP 保持对代码库的控制，分离数据(金矿)，计算(纯函数转换数据，提炼黄金)，和效果(影响现实世界的行为…利润！).*

*但是这种不变性还有第二个目的；我们的精神负担减轻了。*

*如果我们从不共享变化的数据，我们总是能确定我们接受什么作为输入，我们也能确定我们传递什么作为输出。代码库的每一部分仍然是作用域良好的，没有需要记忆和回忆的变量历史。阅读代码的随机部分仍然相对容易。*

*如果我运行`setPlurals`两次，我会得到`["kestrelss", "kitess"]` ，我的应用程序现在有问题了。*

*并且，在 1000 行代码中，它肯定会发生！*

*但是如果我跑 1000 次，我会保证我的小鸟们的安全。*

*那么`map`到底是什么？对一系列值的一般迭代，产生一系列新的转换值。*

*一旦你习惯了，每次看到一个列表+一个`map` +一个函数的应用，你就会明白新列表的形式了。*

*我们已经通过代码控制了列表转换，以一种非常雄辩和可重用的方式。*

*就像`forEach`一样，JavaScript 有自己内置的`map`，作为 array 的原型方法。它的签名是`map::Function -> any[]`，列表是隐式的`this`数组，调用`map`。*

*回调签名是`cb::(any, number?, any[]?) -> any`，其中`number?`是可选的索引，`any[]?`是可选的完整数组——我们也将在上一版本中实现它，因为它可能有用。*

*所以现在，你会完全理解它，并每天重复使用它。*

*因为这个`map`像我们的`map`一样，返回一个新的数组，我们可以很容易地用其他不可变的数组方法一点一点地链接它，比如`concat`、`filter`和`slice` …*

*直到我们找到一个不返回任何东西的方法，比如`forEach`，它将通过一个动作打破转换链，这是控制台中的一个副作用。*

*我在最后提到这个原生的`map`，因为我希望你开始以一种功能性的方式思考，超越内置的工具。*

*从某种意义上来说，`Array.prototype.map`表现出和`Chair.prototype.takeJamJarOnShelf`一样的缺失。*

*`*map*`不应该只绑定到数组，应该是可组合的。事实上，`map`概念也与`observables`、`promises`、树和其他类型的容器一起被大量使用，这些容器也授权有序内容转换。*

*再深入一点，你可以在 JavaScript 引擎中想象下面的前奏，在它运行你的代码之前(请不要重写任何内置的原型，我们在这里这么做只是为了科学)。*

# *皇冠蛋糕*

*其实你会在 FP 里随处看到`map`。*

*一个*可绘制地图的容器在这个世界上是很重要的。这就是为什么我们将会有第二篇文章从更高的角度专门讨论`map`，但这是以后的事了。**

*现在，最后一步当然是 curry 过程，并为`map`回调提供一个索引和完整的数组。*

*但是，像往常一样，如果你没有得到它，它将在未来的课程中解释，所以不要担心。坚持读下去熟悉一下就好了。*

*是的，编程很有趣。*