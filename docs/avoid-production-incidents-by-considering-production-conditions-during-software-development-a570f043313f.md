# 通过在开发过程中考虑生产条件来避免生产事故

> 原文：<https://betterprogramming.pub/avoid-production-incidents-by-considering-production-conditions-during-software-development-a570f043313f>

## 当你在开发过程中忽视生产时，事情可能会出错

![](img/f3ddc16d45d589c6b8c9e869c8b7af9c.png)

照片由[库马·库姆](https://unsplash.com/@kumakum?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄。

在软件开发周期中，必须高度重视生产环境、配置和设置。否则，由于在软件的开发和测试过程中没有考虑设置，生产环境中可能会发生几起事故。

软件开发周期从工程师在本地机器上实现应用程序特性开始。然后，这些特性将在与源代码库合并之前在沙箱上进行测试。稍后，将在与生产设置相同的环境中测试这些更改，以避免生产服务器上的错误或崩溃。

然而，即使采用上述过程，由于没有考虑生产设置，也可能发生一些事故。在这篇文章中，我将强调由于这一事实可能发生的几种事故类型。

# 数据库模式和零停机部署

零停机部署是大多数 web 应用程序试图实现的最重要的特性之一。为新版本创建流程或推出新容器可以由部署中使用的操作系统或集群工具来管理，如 Swarm 或 Kubernetes。

如果工程师没有关注他们实现的数据库迁移，并考虑在生产环境中运行它们，那么数据库模式中的新变化很容易破坏这一特性。

数据库迁移或模式更改通常在发布部署期间应用。首先，迁移将应用于数据库服务器，产生一个新的数据库模式。然后，将部署该版本，并运行一个包含新代码的新流程，为用户的请求提供服务。

在部署期间和推出新版本之前的一段时间内，旧的源代码将针对新的数据库模式运行。长度取决于部署脚本。如果是手动部署，可能会持续很长时间。这意味着新旧版本都必须与新的数据库模式兼容。否则，最终用户在使用 web 应用程序时将开始面临错误和崩溃。

这种风险并不适用于每个数据库模式更改。例如，在表中添加新列或添加新表是安全的，可以毫无问题地完成。另一方面，删除一个列或一个表是非常有害的，并且不能在一次迁移中完成，因为旧版本与新模式不兼容。假设您决定从 users 表中删除电子邮件地址，并将其添加到 contact details 表中。在单次迁移中应用此更改意味着，一旦我们应用数据库更改，向用户发送电子邮件将无法使用旧版本，因为电子邮件列不再可用。

不要在一个版本中应用这个变更，应该在两个版本中完成。第一个版本应该注意复制 contact details 表中的 email 列，并切换源代码以使用 contact details 表作为用户电子邮件的来源。第二个版本将负责从 users 表中删除 email 列。这要安全得多，因为删除 email 列后，任何源代码都不会使用它。

在部署到生产环境期间，可能导致崩溃的数据库更改的另一个例子是在大表上执行的更改。例如，在数据库表的某一列上添加索引是软件开发过程中的一项常见任务，通常需要在基于该列的值搜索记录时提高应用程序的性能。但是，向有 400 万条记录的数据库表添加索引可能需要很长时间才能应用到表中，并且可能会阻塞应用程序部署。还存在数据库查询超时并导致错误的风险。

这些更改很容易通过本地和测试环境，因为这些环境中的数据大小与生产环境中的不同。这种风险不仅限于在数据库表上创建新索引。事实上，需要在大型表上执行的任何更改(例如，添加新列、重命名或删除列)都有同样的风险。

强烈建议在软件开发过程中尽可能早地考虑数据库级别的所有更改的生产数据库模式和大小，以避免生产环境中出现这种类型的崩溃。

# 仅限生产的代码

将代码执行限制在生产环境中是另一个危险的问题，很容易使生产环境崩溃。例如，在 Rails 应用程序中，开发人员编写类似以下代码片段的代码是很常见的:

```
send_notification if Rails.env.production?
```

上面代码的风险是`send_notification`永远不会在本地或测试环境中执行，只会在生产环境中执行。这意味着该功能不会在任何环境中进行测试，如果该功能中存在 bug，那么在部署源代码之后，在生产环境中发现它就太晚了。

为了帮助减少这样的问题，我强烈建议删除任何仅限于生产环境的代码。另一方面，这种行为应该使用特性标志来实现，以便能够在多种环境中启用和测试它们。

# 迭代和补丁处理

在软件应用中使用迭代和循环来执行补丁处理是非常常见的。循环和迭代对于多次应用或执行相同的指令非常有帮助，它们也有助于减少所需的代码行。但是，如果在部署时不考虑补丁处理任务(或任何类似的任务)的迭代和循环，就很容易破坏生产环境。我不是在这里谈论无限循环。

在这一节中，我将重点介绍两个循环会导致生产环境崩溃的例子。我将使用 Rails 示例，但这适用于所有语言——不仅仅是 Ruby。

## 1.遍历一个大列表

在大多数应用程序中，为所有用户或所有同类资源执行相同的任务是很常见的。下面是两个这样做的函数的例子。第一个是`collect_fees`，将用于向所有到期的客户收取订阅费。另一个函数`import_transactions`，将导入用户交易。这两个功能都使用服务来执行实际的工作。让我们假设这些服务使用 RESTful APIs 来执行这项工作。

上述函数的编写方式可能会导致崩溃，原因如下:

*   首先，这两个函数都不处理异常。因此，如果给定用户的操作失败，循环将崩溃，并且列表中的其余用户的流程将不会继续。例如，如果`User.fees_due` 值为 10，并且 API 请求在第三次迭代期间失败，则循环将崩溃，并且不会为其余用户收取费用。这里的失败可能是由多种原因造成的，例如外部服务关闭，或者它用应用程序无法处理的新响应代码或数据进行响应。对于这种情况，考虑生产环境并处理所有预期的异常以使这些功能更加健壮是非常重要的。
*   其次，这两个函数都是在没有指定记录数量限制的情况下选择用户。这意味着随着生产环境中新用户的加入，这些功能的迭代次数将会增加。因此，完成这些任务所需的时间也会增加。如果应用程序的用户基数足够大，这些功能的执行将不会在预期的时间内完成。例如，如果`User.fees_due` 的计数为 3000 万，收款所需时间为`2s`，则需要*23(30000000/(30 * 24 * 60 * 30)~ = 23)*天来为所有受影响的用户收款。你可以争辩说所提供的例子是极端的——是的，对某些企业来说的确如此。然而，即使用户基数很小(例如 700 万)，这段代码仍然需要四天才能完成。这样的功能或任务应该最多在一天内完成。对于这种问题，更好的解决方案是用并行或异步方法处理这些函数。例如，创建执行操作的后台作业，并使用多个工作线程来处理创建的作业。
*   第三，也是最重要的一点，上面的函数很可能会消耗大量的 RAM，并且运行这些函数的进程会被操作系统杀死。是的，它会被 OS 杀死。Linux 内核提供了[内存不足管理](https://www.kernel.org/doc/gorman/html/understand/understand016.html)特性，如果主机内存不足，该特性将终止消耗大部分 RAM 的进程。

但是这和上面的函数有什么关系呢？上述函数中的`each`方法将尝试选择所有受影响的用户并加载到 RAM 中，然后对这些用户进行操作。这就是为什么操作系统更有可能在用户开始迭代之前就终止进程。这也取决于主机节点或 Docker 容器的资源。

通过分批加载和执行这些操作，而不是一次加载所有用户，可以避免这个问题。例如，Rails 提供了一个名为`[find_each](https://apidock.com/rails/ActiveRecord/Batches/ClassMethods/find_each)`的现成方法来实现这一点。

## 2.大宗交易

事务是保护块，其中 SQL 语句只有在作为一个原子操作全部成功时才被提交。这意味着事务 SQL 语句将保存在 RAM 中，直到所有语句都被创建并成功执行。也就是说，编写会导致生成大型事务的源代码会导致软件进程崩溃，如果它开始消耗主机服务器上的大部分可用 RAM 的话。这种(伪)代码的一个例子如下:

上面的`notify_all`函数试图对所有用户执行`notify`函数。我们分批循环用户是正确的。但是，事务数据会将所有 SQL 语句保存在 RAM 中，直到迭代完成，所有用户都能够`commit`或`rollback`这些语句。大事务的结果与迭代一个巨大的列表是一样的，这是操作系统杀死进程。

在上面的例子中，首先实际上不需要有事务(如果我们认为我们不想通知所有用户或者一个也不想通知)。然而，也许在`notify`函数中需要这些事务，以保证按预期为单个用户完成通知。

我在这里试图说明的一点是，总是试图找到正确的事务上下文来确定其范围，并试图限制构建事务所需的资源。

# 结论

开发人员在开发期间必须考虑生产环境配置、数据库方案和应用程序数据。否则，由于在软件开发期间忽略了这些参数，软件可能会在生产环境中崩溃。