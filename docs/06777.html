<html>
<head>
<title>Benchmarking API Endpoints With TypeScript Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript Decorators对API端点进行基准测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/benchmarking-api-endpoints-with-typescript-decorators-27cd462be488?source=collection_archive---------15-----------------------#2020-11-03">https://betterprogramming.pub/benchmarking-api-endpoints-with-typescript-decorators-27cd462be488?source=collection_archive---------15-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在AWS CloudWatch中可视化指标</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6ccffcee8bf8cf69ac5336de19c87f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hM-TC-FrCAjMq4W-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近在工作中，我的任务是找到一种方法来深入了解我们的TypeScript API性能。所以很自然地，我想到了在CloudWatch中创建一个仪表盘来监控CPU和内存的利用率。</p><p id="a817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么不更进一步，同时监控每个端点的响应时间呢？然后，我们可以使用CloudWatch来聚合一些有用的见解，比如百分点数据，这将让我们更好地了解服务的执行情况。</p><p id="5444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我所做的，现在我们有了一个有用的仪表板，它可以监控我们的API，并为我们提供关于每个端点如何执行的数据，以便我们可以战略性地优化服务。</p><p id="c40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想分享我是如何处理这个问题的。我将向您展示如何使用TypeScript decorators生成和发布CloudWatch指标，并且我将逐步介绍使用这些指标在AWS控制台中创建CloudWatch仪表板的步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c9b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="5dc1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我用TypeScript创建了一个基本的Express API来模拟我不得不使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://www.npmjs.com/package/express-generator-typescript" rel="noopener ugc nofollow" target="_blank">express-generator-typescript</a></code>处理的东西。完整的源代码在我的<a class="ae ky" href="https://github.com/mchigit/benchmark-api" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上。</p><p id="edc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以前尝试过创建Express服务器，您的文件夹结构可能如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3aba" class="nh md it nc b gy ni nj l nk nl">.<br/>├── routes                  # Application Routes<br/>│   ├── index.ts         <br/>├── controllers             # Controllers<br/>    ├── postsController.ts<br/>├── models                  # Model for interacting with DB   <br/>│   ├── posts.ts         <br/>├── util                    # Helper Functions<br/>│   ├── postHelper.ts         <br/>├── package.json           <br/>├── README.md         <br/>└── app.js                  # App starting point</span></pre><p id="4df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的模式是将端点应该做什么的逻辑分离到一个不同于定义路由的控制器文件中。我们希望对控制器功能的持续时间进行基准测试，包括参数检查和通常与数据库的交互。通过这一指标，我们可以检测端点是否表现不佳。</p><p id="6456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我创建了一个像这样的基本控制器类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这些异步函数要复杂得多。这是您调用其他API来增强数据或与数据库交互的地方。为了简单起见，我只让我的控制器方法调用<a class="ae ky" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>。对于<code class="fe mz na nb nc b">createPost</code>，我模拟了一个睡眠两秒的参数检查。</p><p id="94ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用控制器的简单路由器代码。它只调用控制器函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种东西没什么令人兴奋的，你可能已经看过几百遍了。现在让我们开始一些更有趣的事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bce8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">发布CloudWatch指标</strong></h1><p id="2460" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">设置好API后，我希望它将指标发送到CloudWatch，这样我们以后就可以使用它了。但是首先，如果您以前从未使用过CloudWatch，我将快速介绍一些基本概念。如果你想更深入地了解它，我找到了马修·肯尼·托马斯的这篇文章，它更详细地解释了每个概念。</p><p id="f876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>是AWS提供的监控服务。CloudWatch中的<a class="ae ky" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace" rel="noopener ugc nofollow" target="_blank">名称空间</a>充当我们发布的<a class="ae ky" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Metric" rel="noopener ugc nofollow" target="_blank">指标</a>的容器。通常，每个应用程序在组织内发布具有唯一名称空间的指标。</p><p id="1364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将这些指标视为代表一个变量随时间变化的值的数据集。例如，这个变量可以是EC2实例的CPU使用率，数据点代表一段时间内CPU使用率的百分比。</p><p id="6dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以定义自己的定制指标并将它们发布到CloudWatch，然后您可以通过创建一个仪表板来检索关于它们的统计信息。</p><p id="a374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在这里要做的。我为它创建了一个实用程序类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="afdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CloudWatch中的指标有<a class="ae ky" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension" rel="noopener ugc nofollow" target="_blank">维度</a>，它们是名称/值对，是指标标识的一部分。我们最多可以将十个维度与一个指标相关联。在第34行，我添加了一个维度来表示API的环境，以区分测试度量和生产。</p><p id="6409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，指标具有指标名称、值和数据点单位等属性。该类型由第3行的<code class="fe mz na nb nc b">MetricData</code>类型定义。</p><p id="3b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">_metricsQueue</code>用于批量处理指标，以减少AWS请求调用。使用<code class="fe mz na nb nc b">putMetricData</code>的每个API调用都要花钱，如果我们一次发送多个指标，就可以避免这笔开销。幸运的是，这个方法允许我们这样做。<code class="fe mz na nb nc b">putMetricData</code>的参数如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6614" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">MetricData.member.N</strong></span><span id="3217" class="nh md it nc b gy no nj l nk nl">     The data for the metric. The array can include no more than 20 <br/>     metrics per call.</span></pre><p id="e30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们传递给<code class="fe mz na nb nc b">putMetricData</code> <em class="np"> </em>的<code class="fe mz na nb nc b">MetricData</code>参数可以是一个度量数组，每一项都有类型<code class="fe mz na nb nc b">MetricData</code>。因此，我们的类维护一个最多存储10个指标的队列。当队列满的时候，我们在第57行用名称空间<code class="fe mz na nb nc b">My API</code>一次发布所有的消息。我们返回sdk 调用的<a class="ae ky" href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/using-promises.html" rel="noopener ugc nofollow" target="_blank">承诺，并让控制器处理结果。</a></p><p id="e2d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的批处理实现，但是如果您希望节省一些AWS成本，有一个更强大的库来处理这个问题。Mixmax发布了一篇博文，展示了他们如何通过批量化指标节省了可观的运营成本:“<a class="ae ky" href="https://engineering.mixmax.com/blog/batching-cloudwatch-metrics" rel="noopener ugc nofollow" target="_blank">批量化CloudWatch指标</a>”</p><p id="1eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个向CloudWatch发布指标的实用程序，让我们看看如何在TypeScript装饰器中使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="993a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定时装饰器</h1><p id="7fcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可以把decorators想象成一个附属于某个东西的函数——通常是一个类、方法或属性——它将包装被装饰的对象并拥有关于它的信息。如果你想了解更多，这里有一个非常好的详细解释和修饰器的用例。</p><p id="15a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的用例，我们将编写一个<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories" rel="noopener ugc nofollow" target="_blank">装饰工厂</a>来包装每个控制器功能，计时持续时间，并向CloudWatch发布指标。下面是装饰函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f9df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">timing()</code>是一个装饰器工厂，它返回一个装饰器，因此我们可以根据它的参数定制行为。如您所见，装饰器接受三个参数:<code class="fe mz na nb nc b">_target</code>、<code class="fe mz na nb nc b">propertyKey</code>和<code class="fe mz na nb nc b">descriptor</code>。原始方法(修饰的控制器方法)存储在<code class="fe mz na nb nc b">descriptor.value</code>中。</p><p id="4485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe mz na nb nc b">descriptor.value</code>被另一个函数代替。运行时将调用这个函数而不是修饰方法。它启动一个计时器，并在第20行调用原始方法。<strong class="lb iu"> </strong>该函数然后使用我们之前创建的<code class="fe mz na nb nc b">cloudwatch</code>实用程序来发布原始方法的持续时间。</p><p id="3646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">cw.publish(`${propertyKey} Duration`, duration, 'Milliseconds')</code>中，如果你记得我们在<code class="fe mz na nb nc b">cloudwatch.ts</code>中定义的参数，度量名是<code class="fe mz na nb nc b">${propertyKey} Duration</code>。<code class="fe mz na nb nc b">propertyKey</code>变量是被修饰方法的名称。因此，将以这些名称发布四个指标:</p><ul class=""><li id="181c" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">getPosts<strong class="lb iu"> </strong>Duration</code></li><li id="48d0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">createPost Duration</code></li><li id="437e" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">updatePost Duration</code></li><li id="867b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe mz na nb nc b">deletePost Duration</code></li></ul><p id="fe17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个指标的值是相应控制器方法的持续时间，单位是毫秒。</p><p id="b50b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要等待发布度量操作，所以我只是附加了一个<code class="fe mz na nb nc b">.catch</code>来捕捉任何错误。</p><p id="3e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在第37行，<strong class="lb iu"/>decorator返回原始方法的结果，因此它可以被后续代码使用。</p><p id="52b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，随着服务器的运行，如果有人向端点发出请求，CloudWatch中应该会发布和提供新的指标。我测试了它，现在度量标准在CloudWatch中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ab1ad362a5ef895e9e53dc9d6d4bb022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHMXa1jIhsWwzVxG3yO0EA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">云观察指标</p></figure><p id="1ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这些指标位于名称空间<code class="fe mz na nb nc b">My API</code>下，维度为<code class="fe mz na nb nc b">Environment: development</code>。每个端点对应四个指标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="78ff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建CloudWatch仪表板</h1><p id="be4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在指标已经准备好了，下一步是创建一个仪表板来可视化它们并使这些数据有用。</p><p id="e95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在AWS控制台中，在服务中搜索“CloudWatch”，然后单击仪表板。在这里，您可以单击“创建仪表板”按钮开始创建一个。填写名称，现在您可以添加小部件了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4707232c878f01d8de2d2cce0a3af36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PowNyC7xf-h1xAoM4lJn4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AWS创建CloudWatch仪表板</p></figure><p id="c6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过单击第一个图块来创建一个线图小部件，并选择Metrics作为数据源，因为我们希望使用API发布的定制指标。单击configure，我们可以看到<code class="fe mz na nb nc b">My API</code>名称空间中的指标。</p><p id="b2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您点击它，您会看到我们刚刚从服务器发布的所有四个指标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1f772be742179aeb9fdbce80c22dff61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhlU3xolbUDfzt3jNM0sEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择要绘制图表的度量</p></figure><p id="8e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过选中复选框来添加它们。转到Graphed Metrics选项卡，定制小部件，使其真正有用。</p><p id="205f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的指标表示每个控制器功能执行的时间。通过绘制默认配置，我们可以获得每个API端点的平均响应时间。但是这种统计可能是不准确的，因为控制器功能中可能到处都有尖峰，这会扭曲数据。</p><p id="d710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更有用的指标是百分位数，我们可以在统计数据列中定义它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/36c1a85862651db213be5352b2ccb8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74PUebZVAwt9spqtSQs2zA.png"/></div></div></figure><p id="8dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将此设置为<code class="fe mz na nb nc b">p95</code>，我们告诉小部件输出一个图表，其中的数据点位于第95个百分点，或者高于其他数据点的95%。这意味着如果<em class="np">"</em>createPost Duration<em class="np">"</em>指标输出2.4k毫秒的数据，那么至少有5%对我们的create post端点的调用花费了超过2.4秒的时间来完成。</p><p id="2d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过查看此图，很明显我们可能需要改进我们的create post端点，因为与其他端点相比，它具有如此高的延迟。</p><p id="d6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这个小部件后，我们可以保存仪表板，它将继续显示关于我们的API执行情况的有用指标。您还可以使用其他统计类型，如平均值、第99百分位等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/afc3e43813b26be8c32afaaf563335f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44cOj_xVp4OXPAjxgC_lwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完成仪表板</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ef35" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c722" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">监控非常重要，尤其是在我们现在已经习惯了高流量的情况下。了解现有的技术并有效地使用它们确实有助于节省成本，或者至少让您更好地了解如何优化服务的性能。</p><p id="0d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您知道如何将定制指标发布到CloudWatch，并在仪表板中可视化它们。虽然这个例子很简单，但希望它能给你一些启发，让你知道如何将这些概念应用到工作或你自己的项目中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9728" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="3a1a" class="nq nr it lb b lc mu lf mv li oj lm ok lq ol lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/express-generator-typescript" rel="noopener ugc nofollow" target="_blank">express-generator-typescript</a></li><li id="672a" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch概念文档</a></li><li id="10d1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://github.com/mixmaxhq/cloudwatch-metrics#readme" rel="noopener ugc nofollow" target="_blank"> cloudwatch-metrics </a></li></ul></div></div>    
</body>
</html>