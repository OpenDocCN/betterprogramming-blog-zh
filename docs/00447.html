<html>
<head>
<title>How To Build a Blazing-Fast GraphQL API With Node.js, MongoDB, and Fastify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js、MongoDB和Fastify构建超快的GraphQL API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998?source=collection_archive---------1-----------------------#2019-05-23">https://betterprogramming.pub/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998?source=collection_archive---------1-----------------------#2019-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42dcfdf52a8f65bcee80bd13b1faa59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUgaEEzxSp2YWsJ7p7jgjA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:<a class="ae kc" href="https://www.freepik.com/free-vector/hand-with-a-pencil-with-lightning-shape_901992.htm" rel="noopener ugc nofollow" target="_blank">由Dooder </a>设计</p></figure><p id="2ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程是系列教程的第2部分，旨在帮助您部署一个全功能的全栈应用程序。</p><ul class=""><li id="864d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">第1部分:如何用Node.js、MongoDB、Fastify和Swagger构建超快的REST APIs</li><li id="e366" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">第2部分:如何用GraphQL、Node.js、MongoDB和Fastify(你在这里。)</strong></li><li id="d452" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">第3部分:用GraphQL API耦合Vue.js</li><li id="0222" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">第4部分:部署一个<strong class="kf ir"> GraphQL API </strong>和<strong class="kf ir"> Vue.js </strong>前端应用程序</li></ul><p id="495e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列的第一部分可以在<a class="ae kc" href="https://medium.freecodecamp.org/how-to-build-blazing-fast-rest-apis-with-node-js-mongodb-fastify-and-swagger-114e062db0c9" rel="noopener ugc nofollow" target="_blank">这里</a>找到，应用程序的源代码可以在<a class="ae kc" href="https://github.com/siegfriedgrimbeek/fastify-graphql-api" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分中，我们将重温第1部分中的模型、控制器和路线，然后将<a class="ae kc" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>集成到应用程序中。作为奖励，我们还将使用<a class="ae kc" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> Faker.js </a>来创建一些假数据并植入数据库。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="dc7b" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">介绍</h1><p id="652b" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。</p><p id="030f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个GraphQL查询都经历三个阶段:查询被解析、验证和执行。</p><p id="6df8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL为您的API中的数据提供了完整且易于理解的描述，使客户能够准确地询问他们需要什么，使API更容易随时间发展，并支持强大的开发工具。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank">https://www . howtographql . com/basics/1-graph QL-is-the-better-rest/</a></p></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2e35" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">先决条件</h1><p id="4954" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">如果您已经完成了本系列的第一部分，那么您应该能够快速掌握初级/中级JavaScript、Node.js和Fastify。JS，还有MongoDB(猫鼬)。</p><p id="3ce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了跟上进度，你需要完成本系列的第1部分，或者从GitHub 获取代码——尽管我强烈建议至少浏览一下第1部分。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="33ff" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我们开始吧</h1><p id="e0cc" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">通过打开您的终端<strong class="kf ir">、</strong>导航到您的项目目录，并<strong class="kf ir">、</strong>执行下面的每一行代码，克隆第1部分的repo(如果您遵循了第1部分，请跳过这一步，继续您自己的代码):</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="0c5c" class="nk lx iq ng b gy nl nm l nn no">git clone <a class="ae kc" href="https://github.com/siegfriedgrimbeek/fastify-api.git" rel="noopener ugc nofollow" target="_blank">https://github.com/siegfriedgrimbeek/fastify-api.git</a><br/>cd fastify-api</span></pre><p id="2c79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了代码库的副本，我们将通过运行下面的代码来更新我们的包和<code class="fe np nq nr ng b">package.json</code>文件:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="6a3a" class="nk lx iq ng b gy nl nm l nn no">sudo <!-- -->npm i -g npm-check-updates<br/>ncu -u<br/>npm install</span></pre><p id="29b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们全局安装<a class="ae kc" href="https://docs.npmjs.com/about-npm/" rel="noopener ugc nofollow" target="_blank"> npm </a>包<code class="fe np nq nr ng b"><a class="ae kc" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank">npm-check-updates</a></code> <strong class="kf ir">，</strong>，然后我们使用这个包用最新的包版本自动更新我们的<code class="fe np nq nr ng b">package.json</code>文件。然后，我们通过运行<code class="fe np nq nr ng b">npm install</code>来安装/更新所有的npm模块。</p><p id="0d09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做是为了确保每个完成教程的人都使用相同的包版本。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8ebb" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">重构我们的服务器并启动应用程序</h1><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/9108ec1a079f4cf55245e4a46f5f0b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rocnESJrNWsRGXMygLfDCQ.png"/></div></div></figure><p id="fd2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和所有软件解决方案一样，随着解决方案的增长，开发人员经常需要重新访问和<a class="ae kc" href="https://en.wikipedia.org/wiki/Code_refactoring" rel="noopener ugc nofollow" target="_blank">重构代码。</a></p><p id="25b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe np nq nr ng b">src</code>目录中，我们将创建一个名为<code class="fe np nq nr ng b">server.js</code>的新文件:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="f11d" class="nk lx iq ng b gy nl nm l nn no">cd src<br/>touch <!-- -->server<!-- -->.js</span></pre><p id="c9df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将以下代码添加到<code class="fe np nq nr ng b">server.js</code>文件中:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">server.js</p></figure><p id="9712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经将启动服务器的逻辑提取到了<code class="fe np nq nr ng b">server.js</code>文件中，允许我们在整个项目中重用这些代码。</p><p id="c2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新<code class="fe np nq nr ng b">src</code>目录中的<code class="fe np nq nr ng b">index.js</code>文件:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">索引. js</p></figure><p id="597c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们设置并配置了GraphQL <strong class="kf ir">，我们将再次访问<code class="fe np nq nr ng b">index.js</code>文件。</strong></p><p id="54c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在终端中运行以下代码，启动Fastify <strong class="kf ir"> </strong>服务器:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="17f7" class="nk lx iq ng b gy nl nm l nn no">npm start</span></pre><p id="4547" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，目前没有默认路由设置。导航到<a class="ae kc" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>将导致服务器返回404错误，这是正确的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="ec63" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">启动MongoDB并更新模型</h1><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/e3afc12158eda19546edb6e7f31ef66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJuaNKhzFpq8vLoorKYXUA.png"/></div></div></figure><p id="279b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们扩展现有的模型，将服务和所有者也包括进来。下图展示了各系列之间的关系:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/154bf8aba7f63cd48af20e04e0191b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*shsVPZjxK1mEnNOjSltXJg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">数据模型</p></figure><ul class=""><li id="0fba" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">一辆车可以有一个主人</li><li id="26d3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一个车主可以拥有多辆汽车</li><li id="f8d5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一辆车可以有多种服务</li></ul><p id="ec01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新访问<code class="fe np nq nr ng b">models</code>目录下的<code class="fe np nq nr ng b">Car.js</code>文件，更新如下:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">汽车. js</p></figure><p id="321c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe np nq nr ng b">models</code>目录下新建两个文件，<code class="fe np nq nr ng b">Owner.js </code>和<code class="fe np nq nr ng b">Service.js</code>，分别在文件中添加以下代码:</p><p id="55d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">Owner.js</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Owner.js</p></figure><p id="7adc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">Service.js</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">服务网</p></figure><p id="5f1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述代码中没有使用新概念。我们刚刚创建了标准的<a class="ae kc" href="https://mongoosejs.com/docs/guide.html" rel="noopener ugc nofollow" target="_blank">mongose模式</a>，与<code class="fe np nq nr ng b">Car.js</code>模型一样。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="777e" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">重新访问汽车控制器并创建附加控制器</h1><p id="0ea9" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><code class="fe np nq nr ng b">carController.js</code>文件有一些细微的变化。因此，导航到<code class="fe np nq nr ng b">controllers</code>目录，并按如下方式更新您的文件:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">汽车控制器. js</p></figure><p id="48be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe np nq nr ng b">controllers</code>目录下新建两个文件<code class="fe np nq nr ng b">serviceController.js</code>和<code class="fe np nq nr ng b">ownerController.js</code>，分别在文件中添加以下代码:</p><p id="6ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">serviceController.js</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">服务控制器..射流研究…</p></figure><p id="7663" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">ownerController.js</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">ownerController.js</p></figure><p id="8e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制器的最大变化是我们如何获得参数:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="d8e3" class="nk lx iq ng b gy nl nm l nn no">const id = req.params === undefined ? req.id : req.params.id<br/>const updateData = req.params === undefined ? req : req.params</span></pre><p id="3bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码称为一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank"> <em class="nv">条件(三元)运算符</em> </a> <strong class="kf ir"> </strong>，用作下面if语句的简写:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="ab7f" class="nk lx iq ng b gy nl nm l nn no">let id</span><span id="44eb" class="nk lx iq ng b gy nw nm l nn no">if (req.params === undefined) {</span><span id="d7a5" class="nk lx iq ng b gy nw nm l nn no">id = req.id</span><span id="454f" class="nk lx iq ng b gy nw nm l nn no">} else {</span><span id="df17" class="nk lx iq ng b gy nw nm l nn no">id = req.params.id</span><span id="60a1" class="nk lx iq ng b gy nw nm l nn no">}</span></pre><p id="7405" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用三元运算符<strong class="kf ir"> </strong>来适应来自REST API和GraphQL API的请求，因为它们的实现略有不同。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="09bd" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">是时候在数据库中植入一些假数据了</h1><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/648789595c6a20e011192b4f3e05a9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*ep1YVMgotY9si-CU9sHHTQ.png"/></div></figure><p id="dbae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe np nq nr ng b">src</code>目录中，让我们通过运行以下代码创建一个新的目录和文件:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="ae7c" class="nk lx iq ng b gy nl nm l nn no">mkdir helpers<br/>touch seed.js</span></pre><p id="eecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将以下代码添加到<code class="fe np nq nr ng b">seed.js</code>文件中:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">种子. js</p></figure><p id="d0a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分解堆积如山的代码:</p><p id="d3ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们导入两个外部库——<a class="ae kc" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank">faker . js</a>、<strong class="kf ir"> </strong>，用于生成假数据，以及<a class="ae kc" href="https://github.com/hapijs/boom" rel="noopener ugc nofollow" target="_blank"> Boom </a>，用于抛出HTTP友好的错误对象。</p><p id="a3cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们导入<code class="fe np nq nr ng b">server.js</code>文件——这将启动我们服务器的一个实例，允许我们与<strong class="kf ir">模型</strong>进行交互。</p><p id="ae74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用假数据声明两个数组，<code class="fe np nq nr ng b">cars</code>和<code class="fe np nq nr ng b">serviceGarages</code>。</p><p id="cf06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们导入<code class="fe np nq nr ng b">models</code>并声明三个函数(<code class="fe np nq nr ng b">generateOwnerData</code>、<code class="fe np nq nr ng b">generateCarData</code>和<code class="fe np nq nr ng b">generateServiceData</code>)，每个函数分别返回一个包含所有者、汽车和服务数据的对象数组。</p><p id="dd17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦Fastify.js实例准备就绪，我们使用<a class="ae kc" href="https://mongoosejs.com/docs/api.html#model_Model.insertMany" rel="noopener ugc nofollow" target="_blank">mongose</a><code class="fe np nq nr ng b"><a class="ae kc" href="https://mongoosejs.com/docs/api.html#model_Model.insertMany" rel="noopener ugc nofollow" target="_blank">insertMany()</a></code><a class="ae kc" href="https://mongoosejs.com/docs/api.html#model_Model.insertMany" rel="noopener ugc nofollow" target="_blank">函数</a>将生成的数组插入数据库。然后，该函数返回包含原始对象数据和每个记录的<code class="fe np nq nr ng b">ids</code>的对象数组。</p><p id="6948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> JavaScript map </a>函数为车主和汽车数组创建一个<code class="fe np nq nr ng b">ids</code>数组。我们使用<code class="fe np nq nr ng b">ownersIDs</code>数组生成汽车数据，使用<code class="fe np nq nr ng b">carsIds</code>数组生成服务数据。它们被传递给各自的函数，然后从中随机选择值。</p><p id="a196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要安装Faker.js包，并将种子任务添加到我们的<code class="fe np nq nr ng b">package.json</code>文件中。</p><p id="37a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过导航到根目录并运行以下代码来添加Faker.js包:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="af23" class="nk lx iq ng b gy nl nm l nn no">npm i faker -D</span></pre><p id="3f9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将以下内容添加到<code class="fe np nq nr ng b">package.json</code>文件中:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="af54" class="nk lx iq ng b gy nl nm l nn no">...</span><span id="ddd0" class="nk lx iq ng b gy nw nm l nn no">"scripts": {</span><span id="1862" class="nk lx iq ng b gy nw nm l nn no">...</span><span id="c2da" class="nk lx iq ng b gy nw nm l nn no">"seed": "node ./src/helpers/seed.js"</span><span id="95e8" class="nk lx iq ng b gy nw nm l nn no">},</span><span id="76e6" class="nk lx iq ng b gy nw nm l nn no">...</span></pre><p id="358f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。现在，我们可以使用以下代码从项目根目录运行我们的播种脚本:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="ff98" class="nk lx iq ng b gy nl nm l nn no">npm run seed</span></pre><p id="c84c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在使用<a class="ae kc" href="https://www.mongodb.com/products/compass" rel="noopener ugc nofollow" target="_blank"> MongoDB Compass </a>(您应该这样做)，您将会看到数据库中的数据:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/9ce15c57ee27c97a90b35544656f29b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDwlcWlV53zEJb2AYliRJw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在MongoDB Compass中查看“mycargarage”数据库</p></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2fbb" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">GraphQL安装、设置和测试</h1><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/23e2e81bfdb41665e32c106967455fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55Tp4JdXkjmDk06cofn6qg.png"/></div></div></figure><p id="a1da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从导航到根目录并运行以下代码开始:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="c7b2" class="nk lx iq ng b gy nl nm l nn no">npm i fastify-gql graphql</span></pre><p id="6ef3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面安装了GraphQL和Fastify准系统GraphQL适配器。</p><p id="99f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航到<code class="fe np nq nr ng b">src</code>目录，并运行以下代码:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="da18" class="nk lx iq ng b gy nl nm l nn no">mkdir schema<br/>cd shema<br/>touch index.js</span></pre><p id="0d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航到<code class="fe np nq nr ng b">src</code>目录，用以下内容更新<code class="fe np nq nr ng b">index.js</code>文件:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="53b5" class="nk lx iq ng b gy nl nm l nn no">// Import Server<br/>const fastify = require('./server.js')</span><span id="b704" class="nk lx iq ng b gy nw nm l nn no">// Import external dependancies<br/>const gql = require('fastify-gql')</span><span id="87be" class="nk lx iq ng b gy nw nm l nn no">// Import GraphQL Schema<br/>const schema = require('./schema')</span><span id="86ef" class="nk lx iq ng b gy nw nm l nn no">// Register Fastify GraphQL<br/>fastify.register(gql, {<br/>   schema,<br/>   graphiql: true<br/>})</span><span id="5ba8" class="nk lx iq ng b gy nw nm l nn no">... end here</span><span id="5f68" class="nk lx iq ng b gy nw nm l nn no">// Import Routes<br/>const routes = require('./routes')</span></pre><p id="b674" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上面的代码，我们需要Fastify GraphQL适配器，因此导入模式并向Fastify注册GraphQL适配器。</p><p id="d0b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们注册模式并启用GraphQL，这是一个用于探索graph QL的浏览器内<a class="ae kc" href="https://en.wikipedia.org/wiki/Integrated_development_environment" rel="noopener ugc nofollow" target="_blank"> IDE </a>。</p><p id="9a4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航到<code class="fe np nq nr ng b">schema</code>目录，打开<code class="fe np nq nr ng b">index.js</code>文件。添加以下样板代码:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">索引. js</p></figure><p id="b2e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们浏览一下上面的代码:</p><p id="b708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要主GraphQL包，并使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> JavaScript析构</a>来获得必要的GraphQL <strong class="kf ir"> </strong>函数(<code class="fe np nq nr ng b">GraphQLSchema</code>、<code class="fe np nq nr ng b">GraphQLObjectType</code>、<code class="fe np nq nr ng b">GraphQLString</code>、<code class="fe np nq nr ng b">GraphQLInt</code>、<code class="fe np nq nr ng b">GraphQLID</code>、<code class="fe np nq nr ng b">GraphQLList</code>和<code class="fe np nq nr ng b">GraphQLNonNull</code>)。</p><p id="abd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入我们的三个<code class="fe np nq nr ng b">controllers</code> ( <code class="fe np nq nr ng b">carController</code>、<code class="fe np nq nr ng b">ownerController</code>和<code class="fe np nq nr ng b">serviceController</code>)。</p><p id="9fc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们声明了<code class="fe np nq nr ng b">carType</code>、<code class="fe np nq nr ng b">ownerType</code>和<code class="fe np nq nr ng b">serviceType</code>、<a class="ae kc" href="https://graphql.org/graphql-js/object-types/" rel="noopener ugc nofollow" target="_blank"> GraphQL对象类型</a>、<strong class="kf ir">、</strong>，它们是接受一个对象作为参数的函数，带有一个<code class="fe np nq nr ng b">name</code>和一个<code class="fe np nq nr ng b">fields</code>键。</p><p id="1d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些函数用于定义我们的GraphQL模式，类似于前面定义的Mongoose模型。</p><p id="c7ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些字段可以返回采用参数的特定类型和方法。</p><p id="9fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们声明<code class="fe np nq nr ng b">RootQuery</code>，它也是一个GraphQL对象类型，可以在每个GraphQL服务器的顶层找到。它代表了GraphQL API的所有可能的入口点。</p><p id="1e39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们声明我们的<code class="fe np nq nr ng b">Mutations</code>，用来改变数据。尽管可以实现任何查询来更改数据，但导致更改的操作应该通过变异显式发送。</p><p id="be80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们导出<code class="fe np nq nr ng b">GraphQLSchema</code>。</p><p id="629a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经设置了模板，我们可以开始填充对象类型、根查询和突变。</p><p id="16b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，有<a class="ae kc" href="https://github.com/sarkistlt/mongoose-schema-to-graphql" rel="noopener ugc nofollow" target="_blank">mongose-to-graph QL</a>模式生成器可用，但是出于教程的目的，我们将手动创建模式。</p><p id="715e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们按如下方式更新<code class="fe np nq nr ng b">carType</code>对象类型:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">carType对象类型</p></figure><p id="bd13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地研究GraphQL函数，从GraphQL中的<a class="ae kc" href="https://softwareengineering.stackexchange.com/questions/238033/what-does-it-mean-when-data-is-scalar" rel="noopener ugc nofollow" target="_blank">标量</a>类型开始:</p><p id="315e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL自带了一组默认的标量类型:</p><ul class=""><li id="c1d7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe np nq nr ng b">Int</code>:有符号32位整数。<code class="fe np nq nr ng b">GraphQLInt</code></li><li id="87a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe np nq nr ng b">Float</code>:有符号双精度浮点值。<code class="fe np nq nr ng b">GraphQLFloat</code></li><li id="2b70" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe np nq nr ng b">String</code>:UTF‐8字符序列。<code class="fe np nq nr ng b">GraphQLString</code></li><li id="1345" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe np nq nr ng b">Boolean</code> : <code class="fe np nq nr ng b">true</code>或者<code class="fe np nq nr ng b">false</code>。<code class="fe np nq nr ng b">GraphQLBoolean</code></li><li id="2da7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe np nq nr ng b">ID</code>:ID标量类型代表一个唯一的标识符，通常用于重新提取一个对象或作为缓存的键。ID类型以与字符串相同的方式序列化；但是，将其定义为<code class="fe np nq nr ng b">ID</code>意味着它不适合人类阅读。<code class="fe np nq nr ng b">GraphQLID</code></li></ul><p id="35ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">owner</code>和<code class="fe np nq nr ng b">service</code>字段是有趣的地方。这些字段没有像其他字段一样被定义为标量类型——相反，它们的<code class="fe np nq nr ng b">type</code>引用了我们已经创建并且尚未填充的<code class="fe np nq nr ng b">ownerType</code>和<code class="fe np nq nr ng b">serviceType</code>。</p><p id="9fb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递给<code class="fe np nq nr ng b">owner</code>和<code class="fe np nq nr ng b">service</code>字段的第二个参数是<a class="ae kc" href="https://graphql.org/learn/execution/" rel="noopener ugc nofollow" target="_blank">解析器</a>函数。</p><p id="8f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析函数或方法是解析模式中类型或字段的值的函数。</p><p id="9ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析器也可以是异步的。它们可以解析来自另一个REST API、数据库、缓存、常量等的值。根据GraphQL的文档:</p><blockquote class="oa ob oc"><p id="1d7f" class="kd ke nv kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">您可以将GraphQL查询中的每个字段视为返回下一个类型的前一个类型的函数或方法。事实上，这正是GraphQL的工作方式。每种类型上的每个字段都由GraphQL服务器开发人员提供的一个名为<em class="iq">解析器</em>的函数支持。当一个字段被执行时，相应的<em class="iq">解析器</em>被调用以产生下一个值。</p><p id="e911" class="kd ke nv kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">如果一个字段产生一个标量值，如字符串或数字，则执行完成。但是，如果一个字段产生一个对象值，那么查询将包含适用于该对象的另一个字段选择。这一直持续到达到标量值。GraphQL查询总是以标量值结束。</p></blockquote><p id="d567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建不同类型之间的关系，我们将<code class="fe np nq nr ng b">_id</code>和<code class="fe np nq nr ng b">owner_id</code>值传递给各自的控制器函数。</p><p id="09b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以本质上，我们需要车主的详细信息和汽车的详细信息:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="8ba7" class="nk lx iq ng b gy nl nm l nn no">return await userController.getSingleOwner({ id: parent.owner_id })</span></pre><p id="599a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及与汽车相关的所有服务的详细信息:</p><pre class="mz na nb nc gt nf ng nh ni aw nj bi"><span id="a447" class="nk lx iq ng b gy nl nm l nn no">return await serviceController.getCarsServices({ id: parent._id })</span></pre><p id="5d08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从GraphQL中返回一个列表或数组，我们使用了<code class="fe np nq nr ng b">GraphQLList</code>。<a class="ae kc" href="https://graphqlmastery.com/blog/graphql-list-how-to-use-arrays-in-graphql-schema" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个很好的关于在GraphQL模式中使用数组的深入教程，但是无论哪种方式，都很简单。每当我们需要一个数组时，我们都会使用<code class="fe np nq nr ng b">GraphQLList</code>函数。</p><p id="cc1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用下面的代码更新<code class="fe np nq nr ng b">ownerType</code>和<code class="fe np nq nr ng b">serviceType</code>:</p><p id="16d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">ownerType</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">ownerType对象类型</p></figure><p id="a1d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe np nq nr ng b">serviceType</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">serviceType对象类型</p></figure><p id="e145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上两种对象类型与<code class="fe np nq nr ng b">carType</code>非常相似。您可以注意到不同对象类型及其关系之间的模式。</p><p id="6bfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以用下面的代码填充<code class="fe np nq nr ng b">RootQuery</code>根:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">rootQuery对象类型</p></figure><p id="e78f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码中没有新概念，但是请记住，<code class="fe np nq nr ng b">RootQuery</code>查询是GraphQL API <strong class="kf ir">上所有查询的入口点。</strong>从上面可以看出，我们可以直接运行以下查询:</p><ul class=""><li id="edef" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">把所有的车都开来</li><li id="1cab" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">买一辆车</li><li id="0964" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获得单一所有者</li><li id="f6b4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">获得单一服务</li></ul><p id="c496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们打开GraphiQL <strong class="kf ir"> </strong>用户界面，构建一些查询:<a class="ae kc" href="http://localhost:3000/graphiql.html" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/GraphiQL . html</a></p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/ebeacece88de831fd00c9d9c894b93ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAEQJsD328s7dXm8XOcZUQ.png"/></div></div></figure><p id="6752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询在左边输入，结果在中间，文档浏览器在右边。</p><p id="5756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">documentation explorer可用于探索整个图形，直至标量级别。这在构建查询时非常有用。</p><p id="d771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于构建查询的语言类似于JSON。这张<a class="ae kc" href="https://devhints.io/graphql" rel="noopener ugc nofollow" target="_blank">小抄</a>是很好的参考。</p><p id="1d97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子演示了为什么GraphQL <strong class="kf ir"> </strong>如此牛逼<strong class="kf ir"> : </strong></p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/e175eead57e064a8151b3286e001af85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jDOrTIS5Q5KvN1oipIg5cQ.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图形集成开发环境</p></figure><p id="0fa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们使用了<code class="fe np nq nr ng b">cars</code>根查询来显示所有汽车、车主及其服务的列表。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/95a8faf963bba3e04209c3678f43f661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcMRr4EzFgE4gVXO7bAmaQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">获取单个汽车-汽车根查询</p></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/68a1f942067e99389567327e4dedd669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLaNg2VKMgP0wyjWAiAMbA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">获取单个所有者-所有者根查询</p></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/8e3ebe0a58d55840e57a55d2b0e01af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JrywxULlRGQU2vYKxsYBg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">获取单个服务—服务根查询</p></figure><p id="99f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还有最后一个话题要谈，那就是<code class="fe np nq nr ng b">mutations</code>。让我们用下面的代码更新<code class="fe np nq nr ng b">mutations</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nt ne l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">突变</p></figure><p id="6f66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像以前一样，我们声明我们的对象类型并指定名称和字段。</p><p id="41fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变异由类型、参数和异步解析函数组成。resolve函数将参数传递给控制器，控制器返回变异的结果。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/ce42209efaf89ef732779d108cfd848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8YYgljcOH9tEW2eQZuQkQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">addCar突变</p></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/b47f12322b0ca49718fe286c6bd4c0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlUI7cREln6KjRd1PVJYow.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">编辑车突变</p></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/555e81c76ccdad58043e8f88ea0c4b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGXgYFAEx36sssh_X-AC3g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">删除汽车突变</p></figure><p id="57cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您已经编写了一个全功能的REST API和一个全功能的GraphQL API。</p><p id="c22e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有规则规定一个人应该独占REST或者独占GraphQL。在某些项目中，最好的解决方案可能是两者的混合。这实际上是根据项目来决定的。</p><p id="ab1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以从GitHub <a class="ae kc" href="https://github.com/siegfriedgrimbeek/fastify-graphql-api" rel="noopener ugc nofollow" target="_blank">这里</a>下载源代码。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="02ce" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">下一步是什么？</h1><p id="bf79" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在下一个教程中，我们将使用一个Vue.js前端作为单页应用程序来使用我们的GraphQL API。</p></div></div>    
</body>
</html>