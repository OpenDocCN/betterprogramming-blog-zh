<html>
<head>
<title>Kubernetes Is Deprecating Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes是在贬低Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-is-deprecating-docker-8a9f7566fbca?source=collection_archive---------0-----------------------#2020-12-08">https://betterprogramming.pub/kubernetes-is-deprecating-docker-8a9f7566fbca?source=collection_archive---------0-----------------------#2020-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e69c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">变化是什么，谁受到影响，如何迁移，为什么这不是恐慌的理由？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/037219bdb9817ddaa4a452dd7958ecc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*l8R1XaZGRuQYQyhBIY_Low.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="3a1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像我们大多数人听说的那样，Kubernetes反对Docker作为1.20版的运行时，而支持使用容器运行时接口(CRI)的运行时，如containerd和CRI-O。</p><p id="e13c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，这不是恐慌的理由。首先:这是一种反对——也就是说，你会从1.20版开始收到警告，所以你不会立即受到影响。你仍然有整整一年的时间来制定计划，因为Docker在1.22版将不受支持，他们将在2021年底推出。</p><p id="8033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使到那时您还没有准备好，您也可以选择不升级到1.22版，直到您认为自己准备好了为止。Kubernetes仍然会用任何安全更新来修补你现有的版本。</p><p id="a6f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，在我们深入了解如何迁移的任何细节之前，让我们先了解一下发生了什么变化以及它会对谁产生影响。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e71a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">有什么变化</h1><p id="7cc2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那么是什么在改变呢？这只是Kubernetes运行时。如果您正在使用Docker构建您的映像，并在开发期间测试您的CI/CD管道，您可以继续使用它。Docker在内部使用containerd来运行Docker容器。</p><p id="84fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果Docker使用containerd，并且众所周知，containerd是另一个容器运行时，那么为什么还要使用Docker呢？好吧，Docker不仅仅是一个容器运行时——容器运行时只形成它的核心，Docker已经把它卸载给containerd了。Docker还在上面提供了许多用户体验层，允许像你我这样的开发人员轻松地与之交互。</p><p id="2881" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这一层对于机器来说毫无意义。最重要的是，Kubernetes不能直接与Docker交互，因为它与Kubernetes CRI不兼容。相反，它需要在上面使用另一个层，称为dockershim，这在已经复杂的容器运行时上增加了额外的复杂性，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/41d2a416322c672088c1be3705a3f12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*MVSj4exa6mU9cViK2wiw4Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="4d7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在这变得有些过头了，因此Kubernetes已经决定逐步取消它的支持，因为Docker最终会与containerd交互，而Kubernetes可以直接与container d交互。Kubernetes也不在乎任何花哨的UI，因为它只是一台机器。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="f44e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">谁受到了影响？</h1><p id="c63a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那么我们是否应该完全停止使用Docker呢？不尽然！Docker有一个非常不同的功能。除了是一个容器运行时，它还是一个开发人员友好的容器引擎。因此，如果您正在使用Docker构建容器映像并在CI/CD管道中使用，您可以继续使用它。</p><p id="daf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker建立了OCI标准的集装箱形象。这意味着Docker映像可以在任何符合OCI标准的容器运行时上运行良好——包括containerd和CRI-O</p><p id="b415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看编排层。如果您在Kubernetes集群中使用Docker作为容器运行时，就会受到影响。您必须用受支持的容器运行时来替换它——container d或CRI-o。Docker容器在这两种环境下都能很好地运行。</p><p id="92d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用的是托管服务，如GKE、EKS或AKS，您可以检查集群设置，找出它使用的容器运行时。无论如何，这三个都默认为containerd，如果您没有进行任何自定义选择，那么您很可能正在使用containerd，并且不会受到影响。</p><p id="606e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您出于某种原因使用Docker，您需要与您的云提供商合作，以确保您获得到受支持的运行时的正确的、经过测试的升级。云提供商将朝着这一目标努力，并很快提供迁移路径和建议。</p><p id="be44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您已经构建了您的集群或者有一个本地设置，那么当您替换您的容器运行时并通过修改<code class="fe mu mv mw mx b">crictl.yaml</code>文件以指向新的容器运行时或者通过允许kubeadm自动检测新的运行时并应用配置来再次启动它时，将会有更多的工作并导致停机。</p><p id="1b60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，如果您不想停机，您可以采用金丝雀方法，使用受支持的容器运行时旋转一个重复的集群，并将您的工作负载迁移到那里，然后关闭现有的集群。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2a6e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">容器工作负载会受到影响吗？</h1><p id="b11d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果您在尝试迁移到新的运行时之前进行评估，那将是最好的。如果您有一个CI/CD管道在Kubernetes中运行，并且它通过挂载<code class="fe mu mv mw mx b">/var/run/docker.sock</code>套接字文件使用Docker-in-Docker (DinD)方法，那么您会受到影响。</p><p id="d18e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为您不会在Kubernetes集群中运行Docker，所以您需要用一个合适的解决方案来替换它——Kaniko是一个很好的解决方案，因为它不依赖Docker守护进程来构建容器映像。你可以阅读“<a class="ae my" href="https://medium.com/better-programming/how-to-build-containers-in-a-kubernetes-cluster-with-kaniko-2d01cd3242a7" rel="noopener">如何用Kaniko </a>在Kubernetes集群中构建容器”来获得关于如何解决这个问题的更详细的观点。</p><p id="9592" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何其他工作负载都不会受到影响，您可以在任何其他受支持的容器运行时上很好地运行它们。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9b81" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="3c68" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">尽管Kubernetes已经决定弃用Docker，转而支持CRI的容器运行时，但没有理由恐慌。这并不意味着Docker的死亡，其影响只是针对Kubernetes集群上的容器运行时。您可以像以前一样继续使用Docker进行开发活动。</p><p id="1416" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，让我们用一个有用的流程图来总结整个故事:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4db7a53f14edf3e47400b4fbf895932a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*amlrI0ig2a-m6lQaFEef-g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="7168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>