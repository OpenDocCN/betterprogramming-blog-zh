<html>
<head>
<title>A Comprehensive Guide to Distributed Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式缓存综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-distributed-caching-471a0319ed35?source=collection_archive---------0-----------------------#2022-05-28">https://betterprogramming.pub/a-comprehensive-guide-to-distributed-caching-471a0319ed35?source=collection_archive---------0-----------------------#2022-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5132" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Kubernetes集群上启动Redis主从集群并实现支持分布式缓存的Spring boot应用程序的指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/47f7fee6fac2e93a1c4f1c8f689f9ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDlNKYG-8NYM4VixrVSlJg.png"/></div></div></figure><p id="37f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗨，伙计们，</p><p id="b9ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在正在做一个性能优化项目。这个项目的目标很不现实，因为我们试图在互联网上的任何地方实现&lt;= 1Seconds response time, and we are dealing with over 1billion data sets. When I got the project requirements the first thing that came to my mind was ‘why not caching ?’ definitely caching should play a considerable role in this requirement.</p><p id="137d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">So when we start the project we begin a couple of POCs to build the ecosystem, but the challenge is I don’t see a comprehensive guideline in <strong class="kt ir"><em class="ln">Kubernetes+Redis+spring boot</em></strong>栈。所以我决定值得与开发社区分享我的实现步骤。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="7366" class="lt lu iq lp b gy lv lw l lx ly"><strong class="lp ir">Note:</strong></span><span id="aa8b" class="lt lu iq lp b gy lz lw l lx ly">The scope of this article is to provide comprehensive guidelines to spin up a Redis master-slave cluster on the Kubernetes cluster and implement a distributed caching-enabled Sprinboot app.</span><span id="94fc" class="lt lu iq lp b gy lz lw l lx ly">A comprehensive introduction to Kubernetes/Redis/Spring boot is out of the scope of this article.</span></pre><h2 id="417c" class="lt lu iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated"><strong class="ak">先决条件</strong></h2><ol class=""><li id="abbb" class="mr ms iq kt b ku mt kx mu la mv le mw li mx lm my mz na nb bi translated">启动并运行Kubernetes集群</li><li id="f9db" class="mr ms iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">Node.js v16.15.0或本地</li><li id="93f6" class="mr ms iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">本地的首选IDE或文本编辑器</li><li id="322d" class="mr ms iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">Java 8或本地的最新版本</li></ol></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="c374" class="lt lu iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated">在Kubernetes上部署Redis集群</h2><p id="d06c" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">以下步骤描述了如何在Kubernetes上设置Redis主从集群。我强烈建议在部署到生产环境之前，对K8S存储类/持久卷/配置图对象进行一些研究。如果您需要获得关于以下步骤<a class="ae nr" href="https://www.containiq.com/post/deploy-redis-cluster-on-kubernetes" rel="noopener ugc nofollow" target="_blank">的全面知识，请阅读本</a>教程。</p><ol class=""><li id="815b" class="mr ms iq kt b ku kv kx ky la ns le nt li nu lm my mz na nb bi translated">创建名称空间</li></ol><p id="e346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在K8S集群上运行以下命令来创建名称空间，这将允许更有效地管理K8S集群上的对象。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="18a9" class="lt lu iq lp b gy lv lw l lx ly">kubectl create ns redis</span></pre><p id="5c7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.定义存储类别</p><p id="364e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将创建一个应用于整个集群的存储类。在K8S集群上运行以下命令来创建存储类。<code class="fe nv nw nx lp b">storage-class.yaml</code>包含配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">storage-class.yaml</p></figure><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="1664" class="lt lu iq lp b gy lv lw l lx ly">kubectl apply -f storage-class.yaml</span></pre><p id="21eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.创建永久卷</p><p id="8fd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在此解决方案中，我们在Redis集群上创建了3个节点，因此我们需要3个持久卷。在K8S集群上运行以下命令来创建持久卷。<code class="fe nv nw nx lp b">persistent-volume.yaml</code>包含配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">持久卷. yaml</p></figure><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="4b49" class="lt lu iq lp b gy lv lw l lx ly">kubectl apply -f persistent-volume.yaml</span></pre><p id="5b18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.创建配置图</p><p id="9c3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在这里获得<a class="ae nr" href="https://gist.github.com/bharathirajatut/dcebde585eba5ac8b1398b8ed653d32d" rel="noopener ugc nofollow" target="_blank"> ConfigMap清单的配置。请确保更改<code class="fe nv nw nx lp b">masterauth</code> &amp; <code class="fe nv nw nx lp b">requirepass </code>值。这两个变量是Redis集群主&amp;从节点的密码。如果对两者使用相同的值，将易于维护。</a></p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3a32" class="lt lu iq lp b gy lv lw l lx ly">kubectl apply -n redis -f redis-config.yaml</span></pre><p id="590e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.使用StatefulSet部署Redis</p><p id="12a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">StatefulSet在需要控制主从行为时管理pod。在K8S集群上运行以下命令来创建持久卷。<code class="fe nv nw nx lp b">persistent-volume.yaml </code>包含配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">redis-statefulset.yaml</p></figure><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="b786" class="lt lu iq lp b gy lv lw l lx ly">kubectl apply -n redis -f redis-statefulset.yaml</span></pre><p id="25c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6.创建负载平衡器服务</p><p id="f71d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Kubernetes部署的最后一步，我们将通过公共IP公开Redis服务器。为此，我们部署了负载平衡器服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="1ddd" class="lt lu iq lp b gy lv lw l lx ly">kubectl apply -n redis -f redis-lb.yaml</span></pre><p id="8b4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6.1检查外部IP</p><p id="5cd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦你部署了负载均衡器，几分钟后集群将提供一个公共的外部IP。为了检查，请在几分钟内运行以下命令。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="c833" class="lt lu iq lp b gy lv lw l lx ly">kubectl get service -n redis</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="3d3b" class="lt lu iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated">从本地访问Redis集群</h2><p id="2108" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">对于这一步，您必须在本地计算机上安装Node.js v16.15.0或最新版本。这一步是可选的，但是为了检查日志/验证连接性，最好能够通过<code class="fe nv nw nx lp b">redis-cli</code>访问远程Redis集群。为此，您不需要在本地机器上安装Redis服务器。</p><ol class=""><li id="d2fa" class="mr ms iq kt b ku kv kx ky la ns le nt li nu lm my mz na nb bi translated">安装redis-cli</li></ol><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="5ca1" class="lt lu iq lp b gy lv lw l lx ly">npm install -g redis-cli</span></pre><p id="02c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.访问Redis集群</p><p id="c6f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦npm安装成功，您可以在终端上运行以下命令之后的任何<code class="fe nv nw nx lp b">redis-cli</code>支持的命令。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="861a" class="lt lu iq lp b gy lv lw l lx ly">rdcli -h {host} -a {password} -p {port}</span></pre><p id="643d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.使用redis-cli监控Redis集群</p><p id="f86f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将分享一些有用的命令来对Redis集群进行基本的维护。您可以使用以下命令刷新所有键并检查集群上存储的值。</p><p id="38fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.1检查Redis群集中存储的值</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="b8de" class="lt lu iq lp b gy lv lw l lx ly">rdcli -h {ip} -a {password} -p {port}</span><span id="961c" class="lt lu iq lp b gy lz lw l lx ly">xxx.xxx.xxx.xxx:xx&gt; KEYS *</span></pre><p id="3f5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.2刷新Redis集群上的缓存</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6424" class="lt lu iq lp b gy lv lw l lx ly">rdcli -h {ip} -a {password} -p {port} FLUSHALL</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="655b" class="lt lu iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated">实施Springboot应用程序</h2><p id="1ce9" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">现在我们将实现具有分布式缓存功能的Springboot应用程序。这个应用程序包含一个GET服务返回字符串值，但是使用<code class="fe nv nw nx lp b">Thread.sleep</code>控制响应时间。让我们看看分布式缓存解决方案如何帮助我们克服这种缓慢。</p><ol class=""><li id="5c2d" class="mr ms iq kt b ku kv kx ky la ns le nt li nu lm my mz na nb bi translated">将以下依赖项添加到POM</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6c3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.Redis配置</p><p id="c2c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要访问Redis远程服务器，我们需要在属性文件中添加一些属性，并在根包中实现RedisConfiguration类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">应用程序.属性文件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">RedisConfiguration.java文件</p></figure><p id="87ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.创建RESTful web API</p><p id="e05a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">至此，我们已经讨论了属于远程Redis集群的配置。现在我们将实现一个典型的spring boot Rest API &amp;惟一的变化是我们在主类和服务类中提供了一些注释来配置缓存启用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">BookingServiceApplication.java(主班)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">BookingController.java(控制器类)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">BookingService.java(服务等级)</p></figure><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3759" class="lt lu iq lp b gy lv lw l lx ly">curl -X GET \<br/>  <a class="ae nr" href="http://localhost:8080/booking" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/booking</a></span></pre><p id="884a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦完成了spring boot Rest服务的实现，就可以启动服务器并尝试上面的GET方法。由于<code class="fe nv nw nx lp b">Thread sleep</code>，初始呼叫应该花费5秒以上。但是当你尝试第二次响应时应该花费&lt; 1秒，因为响应过程来自Redis缓存服务器而不是触及服务层。</p><p id="5cb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请注意，我们在<code class="fe nv nw nx lp b">application.properties</code>文件<em class="ln"> </em>上设置了缓存生存时间属性，因此当您在10秒钟后再次执行GET请求时，您会注意到请求再次从服务层处理，花费了&gt; 5秒钟。</p><p id="9f58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这个指南能节省你的时间。</p><p id="d701" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">快乐编码…</p></div></div>    
</body>
</html>